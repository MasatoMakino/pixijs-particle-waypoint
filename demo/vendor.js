(self.webpackChunk_masatomakino_pixijs_particle_waypoint=self.webpackChunk_masatomakino_pixijs_particle_waypoint||[]).push([[736],{406:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/YTQ3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///406\n")},615:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(801);\n\nvar callBind = __webpack_require__(550);\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7O0FBRTFDLGVBQWUsbUJBQU8sQ0FBQyxHQUFJOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanM/MzE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///615\n")},550:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(930);\nvar GetIntrinsic = __webpack_require__(801);\nvar setFunctionLength = __webpack_require__(521);\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tif (typeof originalFunction !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\tvar func = $reflectApply(bind, $call, arguments);\n\treturn setFunctionLength(\n\t\tfunc,\n\t\t1 + $max(0, originalFunction.length - (arguments.length - 1)),\n\t\ttrue\n\t);\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxHQUFlO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsR0FBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTLFVBQVU7QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RCxFQUFFO0FBQ0YsQ0FBQyxvQkFBb0I7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanM/MDAyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBzZXRGdW5jdGlvbkxlbmd0aCA9IHJlcXVpcmUoJ3NldC1mdW5jdGlvbi1sZW5ndGgnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///550\n")},656:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar hasPropertyDescriptors = __webpack_require__(198)();\n\nvar GetIntrinsic = __webpack_require__(801);\n\nvar $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar gopd = __webpack_require__(828);\n\n/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLEdBQTBCOztBQUUvRCxtQkFBbUIsbUJBQU8sQ0FBQyxHQUFlOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxVQUFVO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxHQUFNOztBQUV6QixXQUFXLHFNQUFxTTtBQUNoTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsMENBQTBDO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQSx5QkFBeUI7QUFDekIsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2RlZmluZS1kYXRhLXByb3BlcnR5L2luZGV4LmpzPzkzNDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpKCk7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzICYmIEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5cdH1cbn1cblxudmFyICRTeW50YXhFcnJvciA9IEdldEludHJpbnNpYygnJVN5bnRheEVycm9yJScpO1xudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cbnZhciBnb3BkID0gcmVxdWlyZSgnZ29wZCcpO1xuXG4vKiogQHR5cGUgeyhvYmo6IFJlY29yZDxQcm9wZXJ0eUtleSwgdW5rbm93bj4sIHByb3BlcnR5OiBQcm9wZXJ0eUtleSwgdmFsdWU6IHVua25vd24sIG5vbkVudW1lcmFibGU/OiBib29sZWFuIHwgbnVsbCwgbm9uV3JpdGFibGU/OiBib29sZWFuIHwgbnVsbCwgbm9uQ29uZmlndXJhYmxlPzogYm9vbGVhbiB8IG51bGwsIGxvb3NlPzogYm9vbGVhbikgPT4gdm9pZH0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lRGF0YVByb3BlcnR5KFxuXHRvYmosXG5cdHByb3BlcnR5LFxuXHR2YWx1ZVxuKSB7XG5cdGlmICghb2JqIHx8ICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgb2JqYCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uYCcpO1xuXHR9XG5cdGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N5bWJvbCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHByb3BlcnR5YCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sYCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzNdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25FbnVtZXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgdHlwZW9mIGFyZ3VtZW50c1s0XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s0XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uV3JpdGFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNSAmJiB0eXBlb2YgYXJndW1lbnRzWzVdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzVdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Db25maWd1cmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNiAmJiB0eXBlb2YgYXJndW1lbnRzWzZdICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxvb3NlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgbm9uRW51bWVyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblx0dmFyIG5vbldyaXRhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXHR2YXIgbm9uQ29uZmlndXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNiA/IGFyZ3VtZW50c1s2XSA6IGZhbHNlO1xuXG5cdC8qIEB0eXBlIHtmYWxzZSB8IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPHVua25vd24+fSAqL1xuXHR2YXIgZGVzYyA9ICEhZ29wZCAmJiBnb3BkKG9iaiwgcHJvcGVydHkpO1xuXG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBub25Db25maWd1cmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuY29uZmlndXJhYmxlIDogIW5vbkNvbmZpZ3VyYWJsZSxcblx0XHRcdGVudW1lcmFibGU6IG5vbkVudW1lcmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuZW51bWVyYWJsZSA6ICFub25FbnVtZXJhYmxlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IG5vbldyaXRhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLndyaXRhYmxlIDogIW5vbldyaXRhYmxlXG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAobG9vc2UgfHwgKCFub25FbnVtZXJhYmxlICYmICFub25Xcml0YWJsZSAmJiAhbm9uQ29uZmlndXJhYmxlKSkge1xuXHRcdC8vIG11c3QgZmFsbCBiYWNrIHRvIFtbU2V0XV0sIGFuZCB3YXMgbm90IGV4cGxpY2l0bHkgYXNrZWQgdG8gbWFrZSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tY29uZmlndXJhYmxlXG5cdFx0b2JqW3Byb3BlcnR5XSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGRlZmluaW5nIGEgcHJvcGVydHkgYXMgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tZW51bWVyYWJsZS4nKTtcblx0fVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///656\n")},720:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHdCQUF3QixvQkFBb0I7QUFDNUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzPzllNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAzMjc2NyAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgdmFyIHAgPSBjLm5leHQ7XG4gICAgd2hpbGUgKHAgIT09IGEpIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcih4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKHgxLCB5MSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAoIWJyaWRnZSkge1xuICAgICAgICByZXR1cm4gb3V0ZXJOb2RlO1xuICAgIH1cblxuICAgIHZhciBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKGJyaWRnZSwgaG9sZSk7XG5cbiAgICAvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICBmaWx0ZXJQb2ludHMoYnJpZGdlUmV2ZXJzZSwgYnJpZGdlUmV2ZXJzZS5uZXh0KTtcbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKGJyaWRnZSwgYnJpZGdlLm5leHQpO1xufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSAwKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAoeCAtIG1pblgpICogaW52U2l6ZSB8IDA7XG4gICAgeSA9ICh5IC0gbWluWSkgKiBpbnZTaXplIHwgMDtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgPj0gKGF4IC0gcHgpICogKGN5IC0gcHkpICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSA+PSAoYnggLSBweCkgKiAoYXkgLSBweSkgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpID49IChjeCAtIHB4KSAqIChieSAtIHB5KTtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG4gICAgICAgICAgIChsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHZhciBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgdmFyIG8yID0gc2lnbihhcmVhKHAxLCBxMSwgcTIpKTtcbiAgICB2YXIgbzMgPSBzaWduKGFyZWEocDIsIHEyLCBwMSkpO1xuICAgIHZhciBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gMDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///720\n")},34:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzPzcwMmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n")},518:module=>{"use strict";eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQSxpRkFBaUYsc0NBQXNDOztBQUV2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanM/ZWZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbnZhciBjb25jYXR0eSA9IGZ1bmN0aW9uIGNvbmNhdHR5KGEsIGIpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGFycltqICsgYS5sZW5ndGhdID0gYltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIHNsaWN5ID0gZnVuY3Rpb24gc2xpY3koYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQgfHwgMCwgaiA9IDA7IGkgPCBhcnJMaWtlLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgICAgYXJyW2pdID0gYXJyTGlrZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBqb2lueSA9IGZ1bmN0aW9uIChhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgICBpZiAoaSArIDEgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmFwcGx5KHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzW2ldID0gJyQnICsgaTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgam9pbnkoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///518\n")},930:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar implementation = __webpack_require__(518);\n\nmodule.exports = Function.prototype.bind || implementation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLEdBQWtCOztBQUUvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanM/MWQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///930\n")},801:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(905)();\nvar hasProto = __webpack_require__(856)();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(930);\nvar hasOwn = __webpack_require__(429);\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOENBQThDO0FBQ2hGLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsR0FBRztBQUNILGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsR0FBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsR0FBVzs7QUFFbEM7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELEdBQUc7QUFDSCxnREFBZ0Q7QUFDaEQsR0FBRztBQUNILHNEQUFzRDtBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLEdBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLEdBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzPzQ3NGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNQcm90byA9IHJlcXVpcmUoJ2hhcy1wcm90bycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhc293bicpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///801\n")},828:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(801);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2dvcGQvaW5kZXguanM/ZWIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///828\n")},198:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(801);\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\tif ($defineProperty) {\n\t\ttry {\n\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// IE 8 has a broken defineProperty\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!hasPropertyDescriptors()) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTLFVBQVU7QUFDeEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycy9pbmRleC5qcz8zMDZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCFoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///198\n")},856:module=>{"use strict";eval("\n\nvar test = {\n\tfoo: {}\n};\n\nvar $Object = Object;\n\nmodule.exports = function hasProto() {\n\treturn { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsaUJBQWlCLHlCQUF5QixrQkFBa0I7QUFDdEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9oYXMtcHJvdG8vaW5kZXguanM/MGQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///856\n")},905:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(682);\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsR0FBUzs7QUFFckM7QUFDQSx5Q0FBeUM7QUFDekMscUNBQXFDO0FBQ3JDLDhDQUE4QztBQUM5QywwQ0FBMEM7O0FBRTFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcz83NTI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///905\n")},682:module=>{"use strict";eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0YsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLGtFQUFrRTtBQUNsRSxxRUFBcUU7O0FBRXJFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsdUNBQXVDOztBQUV2QywyREFBMkQ7QUFDM0QsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQywyRUFBMkU7O0FBRTNFLHlHQUF5Rzs7QUFFekc7QUFDQSw2Q0FBNkM7O0FBRTdDLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanM/MDc0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///682\n")},429:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = __webpack_require__(930);\n\n/** @type {(o: {}, p: PropertyKey) => p is keyof o} */\nmodule.exports = bind.call(call, $hasOwn);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsR0FBZTs7QUFFbEMsV0FBVyxNQUFNLG1DQUFtQztBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2hhc293bi9pbmRleC5qcz9jMGRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG4vKiogQHR5cGUgeyhvOiB7fSwgcDogUHJvcGVydHlLZXkpID0+IHAgaXMga2V5b2Ygb30gKi9cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKGNhbGwsICRoYXNPd24pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///429\n")},126:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = __webpack_require__(654);\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        if (mapForEach) {\n            mapForEach.call(obj, function (value, key) {\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n            });\n        }\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        if (setForEach) {\n            setForEach.call(obj, function (value) {\n                setParts.push(inspect(value, obj));\n            });\n        }\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other\n    /* eslint-env browser */\n    if (typeof window !== 'undefined' && obj === window) {\n        return '{ [object Window] }';\n    }\n    if (obj === __webpack_require__.g) {\n        return '{ [object globalThis] }';\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '\"' : \"'\";\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, /(['\\\\])/g, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QW9DLHNCQUFzQjtBQUMxRDs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsOEJBQThCLFlBQVk7QUFDMUMsd0VBQXdFLFlBQVk7QUFDcEY7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWluc3BlY3QvaW5kZXguanM/ZDlmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlO1xudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgbWFwRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xudmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIHNldFNpemUgPSBoYXNTZXQgJiYgc2V0U2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIHNldFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xudmFyIHdlYWtNYXBIYXMgPSBoYXNXZWFrTWFwID8gV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XG52YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGhhc1dlYWtSZWYgPSB0eXBlb2YgV2Vha1JlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrUmVmLnByb3RvdHlwZTtcbnZhciB3ZWFrUmVmRGVyZWYgPSBoYXNXZWFrUmVmID8gV2Vha1JlZi5wcm90b3R5cGUuZGVyZWYgOiBudWxsO1xudmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciAkbWF0Y2ggPSBTdHJpbmcucHJvdG90eXBlLm1hdGNoO1xudmFyICRzbGljZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgJHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgJHRvVXBwZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZTtcbnZhciAkdG9Mb3dlckNhc2UgPSBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlO1xudmFyICR0ZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xudmFyICRjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyICRqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG52YXIgJGFyclNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyICRmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgYmlnSW50VmFsdWVPZiA9IHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicgPyBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgOiBudWxsO1xudmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHN5bVRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiBudWxsO1xudmFyIGhhc1NoYW1tZWRTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnb2JqZWN0Jztcbi8vIGllLCBgaGFzLXRvc3RyaW5ndGFnL3NoYW1zXG52YXIgdG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gaGFzU2hhbW1lZFN5bWJvbHMgPyAnb2JqZWN0JyA6ICdzeW1ib2wnKVxuICAgID8gU3ltYm9sLnRvU3RyaW5nVGFnXG4gICAgOiBudWxsO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBnUE8gPSAodHlwZW9mIFJlZmxlY3QgPT09ICdmdW5jdGlvbicgPyBSZWZsZWN0LmdldFByb3RvdHlwZU9mIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKSB8fCAoXG4gICAgW10uX19wcm90b19fID09PSBBcnJheS5wcm90b3R5cGUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuICAgICAgICA/IGZ1bmN0aW9uIChPKSB7XG4gICAgICAgICAgICByZXR1cm4gTy5fX3Byb3RvX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgfVxuICAgICAgICA6IG51bGxcbik7XG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNTZXBhcmF0b3IobnVtLCBzdHIpIHtcbiAgICBpZiAoXG4gICAgICAgIG51bSA9PT0gSW5maW5pdHlcbiAgICAgICAgfHwgbnVtID09PSAtSW5maW5pdHlcbiAgICAgICAgfHwgbnVtICE9PSBudW1cbiAgICAgICAgfHwgKG51bSAmJiBudW0gPiAtMTAwMCAmJiBudW0gPCAxMDAwKVxuICAgICAgICB8fCAkdGVzdC5jYWxsKC9lLywgc3RyKVxuICAgICkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB2YXIgc2VwUmVnZXggPSAvWzAtOV0oPz0oPzpbMC05XXszfSkrKD8hWzAtOV0pKS9nO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaW50ID0gbnVtIDwgMCA/IC0kZmxvb3IoLW51bSkgOiAkZmxvb3IobnVtKTsgLy8gdHJ1bmMobnVtKVxuICAgICAgICBpZiAoaW50ICE9PSBudW0pIHtcbiAgICAgICAgICAgIHZhciBpbnRTdHIgPSBTdHJpbmcoaW50KTtcbiAgICAgICAgICAgIHZhciBkZWMgPSAkc2xpY2UuY2FsbChzdHIsIGludFN0ci5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKGludFN0ciwgc2VwUmVnZXgsICckJl8nKSArICcuJyArICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChkZWMsIC8oWzAtOV17M30pL2csICckJl8nKSwgL18kLywgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHN0ciwgc2VwUmVnZXgsICckJl8nKTtcbn1cblxudmFyIHV0aWxJbnNwZWN0ID0gcmVxdWlyZSgnLi91dGlsLmluc3BlY3QnKTtcbnZhciBpbnNwZWN0Q3VzdG9tID0gdXRpbEluc3BlY3QuY3VzdG9tO1xudmFyIGluc3BlY3RTeW1ib2wgPSBpc1N5bWJvbChpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluc3BlY3RfKG9iaiwgb3B0aW9ucywgZGVwdGgsIHNlZW4pIHtcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykgJiYgKG9wdHMucXVvdGVTdHlsZSAhPT0gJ3NpbmdsZScgJiYgb3B0cy5xdW90ZVN0eWxlICE9PSAnZG91YmxlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwicXVvdGVTdHlsZVwiIG11c3QgYmUgXCJzaW5nbGVcIiBvciBcImRvdWJsZVwiJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgaGFzKG9wdHMsICdtYXhTdHJpbmdMZW5ndGgnKSAmJiAodHlwZW9mIG9wdHMubWF4U3RyaW5nTGVuZ3RoID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBvcHRzLm1heFN0cmluZ0xlbmd0aCA8IDAgJiYgb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IEluZmluaXR5XG4gICAgICAgICAgICA6IG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBudWxsXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwibWF4U3RyaW5nTGVuZ3RoXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgSW5maW5pdHksIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICB2YXIgY3VzdG9tSW5zcGVjdCA9IGhhcyhvcHRzLCAnY3VzdG9tSW5zcGVjdCcpID8gb3B0cy5jdXN0b21JbnNwZWN0IDogdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUluc3BlY3QgIT09ICdib29sZWFuJyAmJiBjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJjdXN0b21JbnNwZWN0XCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCwgYGZhbHNlYCwgb3IgYFxcJ3N5bWJvbFxcJ2AnKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnaW5kZW50JylcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09IG51bGxcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09ICdcXHQnXG4gICAgICAgICYmICEocGFyc2VJbnQob3B0cy5pbmRlbnQsIDEwKSA9PT0gb3B0cy5pbmRlbnQgJiYgb3B0cy5pbmRlbnQgPiAwKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJpbmRlbnRcIiBtdXN0IGJlIFwiXFxcXHRcIiwgYW4gaW50ZWdlciA+IDAsIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICBpZiAoaGFzKG9wdHMsICdudW1lcmljU2VwYXJhdG9yJykgJiYgdHlwZW9mIG9wdHMubnVtZXJpY1NlcGFyYXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm51bWVyaWNTZXBhcmF0b3JcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgIG9yIGBmYWxzZWAnKTtcbiAgICB9XG4gICAgdmFyIG51bWVyaWNTZXBhcmF0b3IgPSBvcHRzLm51bWVyaWNTZXBhcmF0b3I7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaiwgb3B0cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAob2JqID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHkgLyBvYmogPiAwID8gJzAnIDogJy0wJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyID0gU3RyaW5nKG9iaik7XG4gICAgICAgIHJldHVybiBudW1lcmljU2VwYXJhdG9yID8gYWRkTnVtZXJpY1NlcGFyYXRvcihvYmosIHN0cikgOiBzdHI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYmlnaW50Jykge1xuICAgICAgICB2YXIgYmlnSW50U3RyID0gU3RyaW5nKG9iaikgKyAnbic7XG4gICAgICAgIHJldHVybiBudW1lcmljU2VwYXJhdG9yID8gYWRkTnVtZXJpY1NlcGFyYXRvcihvYmosIGJpZ0ludFN0cikgOiBiaWdJbnRTdHI7XG4gICAgfVxuXG4gICAgdmFyIG1heERlcHRoID0gdHlwZW9mIG9wdHMuZGVwdGggPT09ICd1bmRlZmluZWQnID8gNSA6IG9wdHMuZGVwdGg7XG4gICAgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVwdGggPSAwOyB9XG4gICAgaWYgKGRlcHRoID49IG1heERlcHRoICYmIG1heERlcHRoID4gMCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopID8gJ1tBcnJheV0nIDogJ1tPYmplY3RdJztcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VlbiA9IFtdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBvYmopID49IDApIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBmcm9tLCBub0luZGVudCkge1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgc2VlbiA9ICRhcnJTbGljZS5jYWxsKHNlZW4pO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub0luZGVudCkge1xuICAgICAgICAgICAgdmFyIG5ld09wdHMgPSB7XG4gICAgICAgICAgICAgICAgZGVwdGg6IG9wdHMuZGVwdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykpIHtcbiAgICAgICAgICAgICAgICBuZXdPcHRzLnF1b3RlU3R5bGUgPSBvcHRzLnF1b3RlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG5ld09wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBvcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmICFpc1JlZ0V4cChvYmopKSB7IC8vIGluIG9sZGVyIGVuZ2luZXMsIHJlZ2V4ZXMgYXJlIGNhbGxhYmxlXG4gICAgICAgIHZhciBuYW1lID0gbmFtZU9mKG9iaik7XG4gICAgICAgIHZhciBrZXlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJyAoYW5vbnltb3VzKScpICsgJ10nICsgKGtleXMubGVuZ3RoID4gMCA/ICcgeyAnICsgJGpvaW4uY2FsbChrZXlzLCAnLCAnKSArICcgfScgOiAnJyk7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChvYmopKSB7XG4gICAgICAgIHZhciBzeW1TdHJpbmcgPSBoYXNTaGFtbWVkU3ltYm9scyA/ICRyZXBsYWNlLmNhbGwoU3RyaW5nKG9iaiksIC9eKFN5bWJvbFxcKC4qXFwpKV9bXildKiQvLCAnJDEnKSA6IHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFoYXNTaGFtbWVkU3ltYm9scyA/IG1hcmtCb3hlZChzeW1TdHJpbmcpIDogc3ltU3RyaW5nO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdmFyIHMgPSAnPCcgKyAkdG9Mb3dlckNhc2UuY2FsbChTdHJpbmcob2JqLm5vZGVOYW1lKSk7XG4gICAgICAgIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzICs9ICcgJyArIGF0dHJzW2ldLm5hbWUgKyAnPScgKyB3cmFwUXVvdGVzKHF1b3RlKGF0dHJzW2ldLnZhbHVlKSwgJ2RvdWJsZScsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gJz4nO1xuICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXMgJiYgb2JqLmNoaWxkTm9kZXMubGVuZ3RoKSB7IHMgKz0gJy4uLic7IH1cbiAgICAgICAgcyArPSAnPC8nICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpICsgJz4nO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1tdJzsgfVxuICAgICAgICB2YXIgeHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmIChpbmRlbnQgJiYgIXNpbmdsZUxpbmVWYWx1ZXMoeHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnWyAnICsgJGpvaW4uY2FsbCh4cywgJywgJykgKyAnIF0nO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcihvYmopKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKCEoJ2NhdXNlJyBpbiBFcnJvci5wcm90b3R5cGUpICYmICdjYXVzZScgaW4gb2JqICYmICFpc0VudW1lcmFibGUuY2FsbChvYmosICdjYXVzZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbCgnW2NhdXNlXTogJyArIGluc3BlY3Qob2JqLmNhdXNlKSwgcGFydHMpLCAnLCAnKSArICcgfSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1snICsgU3RyaW5nKG9iaikgKyAnXSc7IH1cbiAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbChwYXJ0cywgJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY3VzdG9tSW5zcGVjdCkge1xuICAgICAgICBpZiAoaW5zcGVjdFN5bWJvbCAmJiB0eXBlb2Ygb2JqW2luc3BlY3RTeW1ib2xdID09PSAnZnVuY3Rpb24nICYmIHV0aWxJbnNwZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbEluc3BlY3Qob2JqLCB7IGRlcHRoOiBtYXhEZXB0aCAtIGRlcHRoIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbUluc3BlY3QgIT09ICdzeW1ib2wnICYmIHR5cGVvZiBvYmouaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFwKG9iaikpIHtcbiAgICAgICAgdmFyIG1hcFBhcnRzID0gW107XG4gICAgICAgIGlmIChtYXBGb3JFYWNoKSB7XG4gICAgICAgICAgICBtYXBGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU2V0KG9iaikpIHtcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG4gICAgICAgIGlmIChzZXRGb3JFYWNoKSB7XG4gICAgICAgICAgICBzZXRGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXRQYXJ0cy5wdXNoKGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrTWFwKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha1NldChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4ob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuICAgIH1cbiAgICAvLyBub3RlOiBpbiBJRSA4LCBzb21ldGltZXMgYGdsb2JhbCAhPT0gd2luZG93YCBidXQgYm90aCBhcmUgdGhlIHByb3RvdHlwZXMgb2YgZWFjaCBvdGhlclxuICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBvYmogPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gJ3sgW29iamVjdCBXaW5kb3ddIH0nO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBnbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuICd7IFtvYmplY3QgZ2xvYmFsVGhpc10gfSc7XG4gICAgfVxuICAgIGlmICghaXNEYXRlKG9iaikgJiYgIWlzUmVnRXhwKG9iaikpIHtcbiAgICAgICAgdmFyIHlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICB2YXIgaXNQbGFpbk9iamVjdCA9IGdQTyA/IGdQTyhvYmopID09PSBPYmplY3QucHJvdG90eXBlIDogb2JqIGluc3RhbmNlb2YgT2JqZWN0IHx8IG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgICAgICB2YXIgcHJvdG9UYWcgPSBvYmogaW5zdGFuY2VvZiBPYmplY3QgPyAnJyA6ICdudWxsIHByb3RvdHlwZSc7XG4gICAgICAgIHZhciBzdHJpbmdUYWcgPSAhaXNQbGFpbk9iamVjdCAmJiB0b1N0cmluZ1RhZyAmJiBPYmplY3Qob2JqKSA9PT0gb2JqICYmIHRvU3RyaW5nVGFnIGluIG9iaiA/ICRzbGljZS5jYWxsKHRvU3RyKG9iaiksIDgsIC0xKSA6IHByb3RvVGFnID8gJ09iamVjdCcgOiAnJztcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yVGFnID0gaXNQbGFpbk9iamVjdCB8fCB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nID8gJycgOiBvYmouY29uc3RydWN0b3IubmFtZSA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnIDogJyc7XG4gICAgICAgIHZhciB0YWcgPSBjb25zdHJ1Y3RvclRhZyArIChzdHJpbmdUYWcgfHwgcHJvdG9UYWcgPyAnWycgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbChbXSwgc3RyaW5nVGFnIHx8IFtdLCBwcm90b1RhZyB8fCBbXSksICc6ICcpICsgJ10gJyA6ICcnKTtcbiAgICAgICAgaWYgKHlzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdGFnICsgJ3t9JzsgfVxuICAgICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnICsgJ3snICsgaW5kZW50ZWRKb2luKHlzLCBpbmRlbnQpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWcgKyAneyAnICsgJGpvaW4uY2FsbCh5cywgJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKG9iaik7XG59O1xuXG5mdW5jdGlvbiB3cmFwUXVvdGVzKHMsIGRlZmF1bHRTdHlsZSwgb3B0cykge1xuICAgIHZhciBxdW90ZUNoYXIgPSAob3B0cy5xdW90ZVN0eWxlIHx8IGRlZmF1bHRTdHlsZSkgPT09ICdkb3VibGUnID8gJ1wiJyA6IFwiJ1wiO1xuICAgIHJldHVybiBxdW90ZUNoYXIgKyBzICsgcXVvdGVDaGFyO1xufVxuXG5mdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwoU3RyaW5nKHMpLCAvXCIvZywgJyZxdW90OycpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Vycm9yKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXG4vLyBTeW1ib2wgYW5kIEJpZ0ludCBkbyBoYXZlIFN5bWJvbC50b1N0cmluZ1RhZyBieSBzcGVjLCBzbyB0aGF0IGNhbid0IGJlIHVzZWQgdG8gZWxpbWluYXRlIGZhbHNlIHBvc2l0aXZlc1xuZnVuY3Rpb24gaXNTeW1ib2wob2JqKSB7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqIGluc3RhbmNlb2YgU3ltYm9sO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFzeW1Ub1N0cmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmlnSW50KG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFiaWdJbnRWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmlnSW50VmFsdWVPZi5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyKG9iaikge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5hbWVPZihmKSB7XG4gICAgaWYgKGYubmFtZSkgeyByZXR1cm4gZi5uYW1lOyB9XG4gICAgdmFyIG0gPSAkbWF0Y2guY2FsbChmdW5jdGlvblRvU3RyaW5nLmNhbGwoZiksIC9eZnVuY3Rpb25cXHMqKFtcXHckXSspLyk7XG4gICAgaWYgKG0pIHsgcmV0dXJuIG1bMV07IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSB7IHJldHVybiB4cy5pbmRleE9mKHgpOyB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSB7IHJldHVybiBpOyB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNNYXAoeCkge1xuICAgIGlmICghbWFwU2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcbiAgICBpZiAoIXdlYWtNYXBIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtSZWYoeCkge1xuICAgIGlmICghd2Vha1JlZkRlcmVmIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtSZWZEZXJlZi5jYWxsKHgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTZXQoeCkge1xuICAgIGlmICghc2V0U2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrU2V0KHgpIHtcbiAgICBpZiAoIXdlYWtTZXRIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQoeCkge1xuICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHgubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB4LmdldEF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFN0cmluZyhzdHIsIG9wdHMpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IG9wdHMubWF4U3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBzdHIubGVuZ3RoIC0gb3B0cy5tYXhTdHJpbmdMZW5ndGg7XG4gICAgICAgIHZhciB0cmFpbGVyID0gJy4uLiAnICsgcmVtYWluaW5nICsgJyBtb3JlIGNoYXJhY3RlcicgKyAocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RTdHJpbmcoJHNsaWNlLmNhbGwoc3RyLCAwLCBvcHRzLm1heFN0cmluZ0xlbmd0aCksIG9wdHMpICsgdHJhaWxlcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICB2YXIgcyA9ICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChzdHIsIC8oWydcXFxcXSkvZywgJ1xcXFwkMScpLCAvW1xceDAwLVxceDFmXS9nLCBsb3dieXRlKTtcbiAgICByZXR1cm4gd3JhcFF1b3RlcyhzLCAnc2luZ2xlJywgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGxvd2J5dGUoYykge1xuICAgIHZhciBuID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB4ID0ge1xuICAgICAgICA4OiAnYicsXG4gICAgICAgIDk6ICd0JyxcbiAgICAgICAgMTA6ICduJyxcbiAgICAgICAgMTI6ICdmJyxcbiAgICAgICAgMTM6ICdyJ1xuICAgIH1bbl07XG4gICAgaWYgKHgpIHsgcmV0dXJuICdcXFxcJyArIHg7IH1cbiAgICByZXR1cm4gJ1xcXFx4JyArIChuIDwgMHgxMCA/ICcwJyA6ICcnKSArICR0b1VwcGVyQ2FzZS5jYWxsKG4udG9TdHJpbmcoMTYpKTtcbn1cblxuZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xuICAgIHJldHVybiAnT2JqZWN0KCcgKyBzdHIgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHdlYWtDb2xsZWN0aW9uT2YodHlwZSkge1xuICAgIHJldHVybiB0eXBlICsgJyB7ID8gfSc7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25PZih0eXBlLCBzaXplLCBlbnRyaWVzLCBpbmRlbnQpIHtcbiAgICB2YXIgam9pbmVkRW50cmllcyA9IGluZGVudCA/IGluZGVudGVkSm9pbihlbnRyaWVzLCBpbmRlbnQpIDogJGpvaW4uY2FsbChlbnRyaWVzLCAnLCAnKTtcbiAgICByZXR1cm4gdHlwZSArICcgKCcgKyBzaXplICsgJykgeycgKyBqb2luZWRFbnRyaWVzICsgJ30nO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVMaW5lVmFsdWVzKHhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5kZXhPZih4c1tpXSwgJ1xcbicpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKSB7XG4gICAgdmFyIGJhc2VJbmRlbnQ7XG4gICAgaWYgKG9wdHMuaW5kZW50ID09PSAnXFx0Jykge1xuICAgICAgICBiYXNlSW5kZW50ID0gJ1xcdCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5pbmRlbnQgPT09ICdudW1iZXInICYmIG9wdHMuaW5kZW50ID4gMCkge1xuICAgICAgICBiYXNlSW5kZW50ID0gJGpvaW4uY2FsbChBcnJheShvcHRzLmluZGVudCArIDEpLCAnICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBiYXNlSW5kZW50LFxuICAgICAgICBwcmV2OiAkam9pbi5jYWxsKEFycmF5KGRlcHRoICsgMSksIGJhc2VJbmRlbnQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHZhciBsaW5lSm9pbmVyID0gJ1xcbicgKyBpbmRlbnQucHJldiArIGluZGVudC5iYXNlO1xuICAgIHJldHVybiBsaW5lSm9pbmVyICsgJGpvaW4uY2FsbCh4cywgJywnICsgbGluZUpvaW5lcikgKyAnXFxuJyArIGluZGVudC5wcmV2O1xufVxuXG5mdW5jdGlvbiBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCkge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqKTtcbiAgICB2YXIgeHMgPSBbXTtcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgeHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzW2ldID0gaGFzKG9iaiwgaSkgPyBpbnNwZWN0KG9ialtpXSwgb2JqKSA6ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzeW1zID0gdHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicgPyBnT1BTKG9iaikgOiBbXTtcbiAgICB2YXIgc3ltTWFwO1xuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuICAgICAgICBzeW1NYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzeW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBzeW1NYXBbJyQnICsgc3ltc1trXV0gPSBzeW1zW2tdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGlmICghaGFzKG9iaiwga2V5KSkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaXNBcnIgJiYgU3RyaW5nKE51bWJlcihrZXkpKSA9PT0ga2V5ICYmIGtleSA8IG9iai5sZW5ndGgpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzICYmIHN5bU1hcFsnJCcgKyBrZXldIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgc2hhbW1lZCBTeW1ib2xzLCB3aGljaCBhcmUgc3RvcmVkIGFzIHN0cmluZ3MsIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gdGhlIHN0cmluZyBrZXkgc2VjdGlvblxuICAgICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoJHRlc3QuY2FsbCgvW15cXHckXS8sIGtleSkpIHtcbiAgICAgICAgICAgIHhzLnB1c2goaW5zcGVjdChrZXksIG9iaikgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzeW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW1zW2pdKSkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goJ1snICsgaW5zcGVjdChzeW1zW2pdKSArICddOiAnICsgaW5zcGVjdChvYmpbc3ltc1tqXV0sIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///126\n")},663:module=>{"use strict";eval("\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = {\n    'default': Format.RFC3986,\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return String(value);\n        }\n    },\n    RFC1738: Format.RFC1738,\n    RFC3986: Format.RFC3986\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanM/ZjM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxudmFyIEZvcm1hdCA9IHtcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6IEZvcm1hdC5SRkMzOTg2LFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJGQzE3Mzg6IEZvcm1hdC5SRkMxNzM4LFxuICAgIFJGQzM5ODY6IEZvcm1hdC5SRkMzOTg2XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///663\n")},907:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringify = __webpack_require__(38);\nvar parse = __webpack_require__(186);\nvar formats = __webpack_require__(663);\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA3LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLEVBQWE7QUFDckMsWUFBWSxtQkFBTyxDQUFDLEdBQVM7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLEdBQVc7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanM/Y2EwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///907\n")},186:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(304);\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    allowSparse: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\nvar parseArrayValue = function (val, options) {\n    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n        return val.split(',');\n    }\n\n    return val;\n};\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = { __proto__: null };\n\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n            val = utils.maybeMap(\n                parseArrayValue(part.slice(pos + 1), options),\n                function (encodedVal) {\n                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');\n                }\n            );\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (part.indexOf('[]=') > -1) {\n            val = isArray(val) ? [val] : val;\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options, valuesParsed) {\n    var leaf = valuesParsed ? val : parseArrayValue(val, options);\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else if (cleanRoot !== '__proto__') {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = options.depth > 0 && brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options, valuesParsed);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    if (options.allowSparse === true) {\n        return obj;\n    }\n\n    return utils.compact(obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxHQUFTOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0JBQStCOztBQUV4RTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9xcy9saWIvcGFyc2UuanM/ZTNmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYWxsb3dTcGFyc2U6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGludGVycHJldE51bWVyaWNFbnRpdGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbiAoJDAsIG51bWJlclN0cikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChudW1iZXJTdHIsIDEwKSk7XG4gICAgfSk7XG59O1xuXG52YXIgcGFyc2VBcnJheVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5jb21tYSAmJiB2YWwuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zcGxpdCgnLCcpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIHdoYXQgYnJvd3NlcnMgd2lsbCBzdWJtaXQgd2hlbiB0aGUg4pyTIGNoYXJhY3RlciBvY2N1cnMgaW4gYW5cbi8vIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBib2R5IGFuZCB0aGUgZW5jb2Rpbmcgb2YgdGhlIHBhZ2UgY29udGFpbmluZ1xuLy8gdGhlIGZvcm0gaXMgaXNvLTg4NTktMSwgb3Igd2hlbiB0aGUgc3VibWl0dGVkIGZvcm0gaGFzIGFuIGFjY2VwdC1jaGFyc2V0XG4vLyBhdHRyaWJ1dGUgb2YgaXNvLTg4NTktMS4gUHJlc3VtYWJseSBhbHNvIHdpdGggb3RoZXIgY2hhcnNldHMgdGhhdCBkbyBub3QgY29udGFpblxuLy8gdGhlIOKckyBjaGFyYWN0ZXIsIHN1Y2ggYXMgdXMtYXNjaWkuXG52YXIgaXNvU2VudGluZWwgPSAndXRmOD0lMjYlMjMxMDAwMyUzQic7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKVxuXG4vLyBUaGVzZSBhcmUgdGhlIHBlcmNlbnQtZW5jb2RlZCB1dGYtOCBvY3RldHMgcmVwcmVzZW50aW5nIGEgY2hlY2ttYXJrLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHJlcXVlc3QgYWN0dWFsbHkgaXMgdXRmLTggZW5jb2RlZC5cbnZhciBjaGFyc2V0U2VudGluZWwgPSAndXRmOD0lRTIlOUMlOTMnOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHsgX19wcm90b19fOiBudWxsIH07XG5cbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKHBhcnQuc2xpY2UocG9zICsgMSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IGlzQXJyYXkodmFsKSA/IFt2YWxdIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlQXJyYXlzICYmIGNsZWFuUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICAgICAmJiAob3B0aW9ucy5wYXJzZUFycmF5cyAmJiBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgICAgICBvYmpbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xlYW5Sb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XG4gICAgaWYgKCFnaXZlbktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuYWxsb3dEb3RzID8gZ2l2ZW5LZXkucmVwbGFjZSgvXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teW1xcXV0qXSkvZztcblxuICAgIC8vIEdldCB0aGUgcGFyZW50XG5cbiAgICB2YXIgc2VnbWVudCA9IG9wdGlvbnMuZGVwdGggPiAwICYmIGJyYWNrZXRzLmV4ZWMoa2V5KTtcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXMgdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChvcHRpb25zLmRlcHRoID4gMCAmJiAoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KGtleXMsIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKTtcbn07XG5cbnZhciBub3JtYWxpemVQYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRzLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0cy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB2YXIgY2hhcnNldCA9IHR5cGVvZiBvcHRzLmNoYXJzZXQgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuY2hhcnNldCA6IG9wdHMuY2hhcnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGFsbG93UHJvdG90eXBlczogdHlwZW9mIG9wdHMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcyxcbiAgICAgICAgYWxsb3dTcGFyc2U6IHR5cGVvZiBvcHRzLmFsbG93U3BhcnNlID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93U3BhcnNlIDogZGVmYXVsdHMuYWxsb3dTcGFyc2UsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMsIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93U3BhcnNlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///186\n")},38:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar getSideChannel = __webpack_require__(680);\nvar utils = __webpack_require__(304);\nvar formats = __webpack_require__(663);\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar sentinel = {};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    commaRoundTrip,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    format,\n    formatter,\n    encodeValuesOnly,\n    charset,\n    sideChannel\n) {\n    var obj = object;\n\n    var tmpSc = sideChannel;\n    var step = 0;\n    var findFlag = false;\n    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n        // Where object last appeared in the ref tree\n        var pos = tmpSc.get(object);\n        step += 1;\n        if (typeof pos !== 'undefined') {\n            if (pos === step) {\n                throw new RangeError('Cyclic object value');\n            } else {\n                findFlag = true; // Break while\n            }\n        }\n        if (typeof tmpSc.get(sentinel) === 'undefined') {\n            step = 0;\n        }\n    }\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = utils.maybeMap(obj, function (value) {\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            return value;\n        });\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        // we need to join elements in\n        if (encodeValuesOnly && encoder) {\n            obj = utils.maybeMap(obj, encoder);\n        }\n        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n    } else if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;\n\n    for (var j = 0; j < objKeys.length; ++j) {\n        var key = objKeys[j];\n        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n\n        if (skipNulls && value === null) {\n            continue;\n        }\n\n        var keyPrefix = isArray(obj)\n            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix\n            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');\n\n        sideChannel.set(object, step);\n        var valueSideChannel = getSideChannel();\n        valueSideChannel.set(sentinel, sideChannel);\n        pushToArray(values, stringify(\n            value,\n            keyPrefix,\n            generateArrayPrefix,\n            commaRoundTrip,\n            strictNullHandling,\n            skipNulls,\n            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            format,\n            formatter,\n            encodeValuesOnly,\n            charset,\n            valueSideChannel\n        ));\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        format: format,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\n    }\n    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    var sideChannel = getSideChannel();\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            commaRoundTrip,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.format,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset,\n            sideChannel\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsR0FBYztBQUMzQyxZQUFZLG1CQUFPLENBQUMsR0FBUztBQUM3QixjQUFjLG1CQUFPLENBQUMsR0FBVztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRUFBZ0U7QUFDckYsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcz82NjA4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFNpZGVDaGFubmVsID0gcmVxdWlyZSgnc2lkZS1jaGFubmVsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGNvbW1hOiAnY29tbWEnLFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG52YXIgcHVzaFRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB2YWx1ZU9yQXJyYXkpIHtcbiAgICBwdXNoLmFwcGx5KGFyciwgaXNBcnJheSh2YWx1ZU9yQXJyYXkpID8gdmFsdWVPckFycmF5IDogW3ZhbHVlT3JBcnJheV0pO1xufTtcblxudmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBkZWZhdWx0Rm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xudmFyIGRlZmF1bHRzID0ge1xuICAgIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBlbmNvZGU6IHRydWUsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHMuZm9ybWF0dGVyc1tkZWZhdWx0Rm9ybWF0XSxcbiAgICAvLyBkZXByZWNhdGVkXG4gICAgaW5kaWNlczogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaXNOb25OdWxsaXNoUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNOb25OdWxsaXNoUHJpbWl0aXZlKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnc3ltYm9sJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCc7XG59O1xuXG52YXIgc2VudGluZWwgPSB7fTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgY29tbWFSb3VuZFRyaXAsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgIHNraXBOdWxscyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdCxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICBjaGFyc2V0LFxuICAgIHNpZGVDaGFubmVsXG4pIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuXG4gICAgdmFyIHRtcFNjID0gc2lkZUNoYW5uZWw7XG4gICAgdmFyIHN0ZXAgPSAwO1xuICAgIHZhciBmaW5kRmxhZyA9IGZhbHNlO1xuICAgIHdoaWxlICgodG1wU2MgPSB0bXBTYy5nZXQoc2VudGluZWwpKSAhPT0gdm9pZCB1bmRlZmluZWQgJiYgIWZpbmRGbGFnKSB7XG4gICAgICAgIC8vIFdoZXJlIG9iamVjdCBsYXN0IGFwcGVhcmVkIGluIHRoZSByZWYgdHJlZVxuICAgICAgICB2YXIgcG9zID0gdG1wU2MuZ2V0KG9iamVjdCk7XG4gICAgICAgIHN0ZXAgKz0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAocG9zID09PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0N5Y2xpYyBvYmplY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluZEZsYWcgPSB0cnVlOyAvLyBCcmVhayB3aGlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG1wU2MuZ2V0KHNlbnRpbmVsKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG4gICAgICAgIGlmIChlbmNvZGVWYWx1ZXNPbmx5ICYmIGVuY29kZXIpIHtcbiAgICAgICAgICAgIG9iaiA9IHV0aWxzLm1heWJlTWFwKG9iaiwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqS2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgdmFyIGFkanVzdGVkUHJlZml4ID0gY29tbWFSb3VuZFRyaXAgJiYgaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEgPyBwcmVmaXggKyAnW10nIDogcHJlZml4O1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmpLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2pdO1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGtleS52YWx1ZSA6IG9ialtrZXldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGlzQXJyYXkob2JqKVxuICAgICAgICAgICAgPyB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRQcmVmaXgsIGtleSkgOiBhZGp1c3RlZFByZWZpeFxuICAgICAgICAgICAgOiBhZGp1c3RlZFByZWZpeCArIChhbGxvd0RvdHMgPyAnLicgKyBrZXkgOiAnWycgKyBrZXkgKyAnXScpO1xuXG4gICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuICAgICAgICB2YXIgdmFsdWVTaWRlQ2hhbm5lbCA9IGdldFNpZGVDaGFubmVsKCk7XG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwuc2V0KHNlbnRpbmVsLCBzaWRlQ2hhbm5lbCk7XG4gICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBrZXlQcmVmaXgsXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGVuY29kZVZhbHVlc09ubHkgJiYgaXNBcnJheShvYmopID8gbnVsbCA6IGVuY29kZXIsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICBjaGFyc2V0LFxuICAgICAgICAgICAgdmFsdWVTaWRlQ2hhbm5lbFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxudmFyIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmVuY29kZXIgIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBjaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8IGRlZmF1bHRzLmNoYXJzZXQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFoYXMuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IG9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICB2YXIgZmlsdGVyID0gZGVmYXVsdHMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNBcnJheShvcHRzLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0cy5maWx0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXG4gICAgICAgIGVuY29kZTogdHlwZW9mIG9wdHMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZSxcbiAgICAgICAgZW5jb2RlcjogdHlwZW9mIG9wdHMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXIsXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHk6IHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgIHNlcmlhbGl6ZURhdGU6IHR5cGVvZiBvcHRzLnNlcmlhbGl6ZURhdGUgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNlcmlhbGl6ZURhdGUgOiBkZWZhdWx0cy5zZXJpYWxpemVEYXRlLFxuICAgICAgICBza2lwTnVsbHM6IHR5cGVvZiBvcHRzLnNraXBOdWxscyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5za2lwTnVsbHMgOiBkZWZhdWx0cy5za2lwTnVsbHMsXG4gICAgICAgIHNvcnQ6IHR5cGVvZiBvcHRzLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNvcnQgOiBudWxsLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRzKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cyk7XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqID0gZmlsdGVyKCcnLCBvYmopO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvcHRpb25zLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBhcnJheUZvcm1hdDtcbiAgICBpZiAob3B0cyAmJiBvcHRzLmFycmF5Rm9ybWF0IGluIGFycmF5UHJlZml4R2VuZXJhdG9ycykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdHMuYXJyYXlGb3JtYXQ7XG4gICAgfSBlbHNlIGlmIChvcHRzICYmICdpbmRpY2VzJyBpbiBvcHRzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuICAgIGlmIChvcHRzICYmICdjb21tYVJvdW5kVHJpcCcgaW4gb3B0cyAmJiB0eXBlb2Ygb3B0cy5jb21tYVJvdW5kVHJpcCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bjb21tYVJvdW5kVHJpcGAgbXVzdCBiZSBhIGJvb2xlYW4sIG9yIGFic2VudCcpO1xuICAgIH1cbiAgICB2YXIgY29tbWFSb3VuZFRyaXAgPSBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIG9wdHMgJiYgb3B0cy5jb21tYVJvdW5kVHJpcDtcblxuICAgIGlmICghb2JqS2V5cykge1xuICAgICAgICBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgICAgIG9iaktleXMuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIH1cblxuICAgIHZhciBzaWRlQ2hhbm5lbCA9IGdldFNpZGVDaGFubmVsKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaFRvQXJyYXkoa2V5cywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgICAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcE51bGxzLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLnNvcnQsXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzZXQsXG4gICAgICAgICAgICBzaWRlQ2hhbm5lbFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0ga2V5cy5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpLCB0aGUgXCJudW1lcmljIGVudGl0eVwiIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlY2ttYXJrXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0ImJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lRTIlOUMlOTMmJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n")},304:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar formats = __webpack_require__(663);\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    /* eslint no-param-reassign: 0 */\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset, kind, format) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        /* eslint operator-linebreak: [2, \"before\"] */\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nvar maybeMap = function maybeMap(val, fn) {\n    if (isArray(val)) {\n        var mapped = [];\n        for (var i = 0; i < val.length; i += 1) {\n            mapped.push(fn(val[i]));\n        }\n        return mapped;\n    }\n    return fn(val);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    maybeMap: maybeMap,\n    merge: merge\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxHQUFXOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU8sVUFBVSxhQUFhO0FBQ2pEOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanM/MmQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBhcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmICFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIGRlY29kZXIsIGNoYXJzZXQpIHtcbiAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuICAgIH1cbiAgICAvLyB1dGYtOFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuICAgIH1cbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICAgICAgfHwgKGZvcm1hdCA9PT0gZm9ybWF0cy5SRkMxNzM4ICYmIChjID09PSAweDI4IHx8IGMgPT09IDB4MjkpKSAvLyAoIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIC8qIGVzbGludCBvcGVyYXRvci1saW5lYnJlYWs6IFsyLCBcImJlZm9yZVwiXSAqL1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///304\n")},521:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(801);\nvar define = __webpack_require__(656);\nvar hasDescriptors = __webpack_require__(198)();\nvar gOPD = __webpack_require__(828);\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $floor = GetIntrinsic('%Math.floor%');\n\nmodule.exports = function setFunctionLength(fn, length) {\n\tif (typeof fn !== 'function') {\n\t\tthrow new $TypeError('`fn` is not a function');\n\t}\n\tif (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {\n\t\tthrow new $TypeError('`length` must be a positive 32-bit integer');\n\t}\n\n\tvar loose = arguments.length > 2 && !!arguments[2];\n\n\tvar functionLengthIsConfigurable = true;\n\tvar functionLengthIsWritable = true;\n\tif ('length' in fn && gOPD) {\n\t\tvar desc = gOPD(fn, 'length');\n\t\tif (desc && !desc.configurable) {\n\t\t\tfunctionLengthIsConfigurable = false;\n\t\t}\n\t\tif (desc && !desc.writable) {\n\t\t\tfunctionLengthIsWritable = false;\n\t\t}\n\t}\n\n\tif (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n\t\tif (hasDescriptors) {\n\t\t\tdefine(fn, 'length', length, true, true);\n\t\t} else {\n\t\t\tdefine(fn, 'length', length);\n\t\t}\n\t}\n\treturn fn;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLEdBQXNCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLEdBQTBCO0FBQ3ZELFdBQVcsbUJBQU8sQ0FBQyxHQUFNOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9zZXQtZnVuY3Rpb24tbGVuZ3RoL2luZGV4LmpzPzc0MDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1kYXRhLXByb3BlcnR5Jyk7XG52YXIgaGFzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RnVuY3Rpb25MZW5ndGgoZm4sIGxlbmd0aCkge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BmbmAgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0fVxuXHRpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoIDwgMCB8fCBsZW5ndGggPiAweEZGRkZGRkZGIHx8ICRmbG9vcihsZW5ndGgpICE9PSBsZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxlbmd0aGAgbXVzdCBiZSBhIHBvc2l0aXZlIDMyLWJpdCBpbnRlZ2VyJyk7XG5cdH1cblxuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAhIWFyZ3VtZW50c1syXTtcblxuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdHZhciBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSB0cnVlO1xuXHRpZiAoJ2xlbmd0aCcgaW4gZm4gJiYgZ09QRCkge1xuXHRcdHZhciBkZXNjID0gZ09QRChmbiwgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoZGVzYyAmJiAhZGVzYy53cml0YWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgfHwgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlIHx8ICFsb29zZSkge1xuXHRcdGlmIChoYXNEZXNjcmlwdG9ycykge1xuXHRcdFx0ZGVmaW5lKGZuLCAnbGVuZ3RoJywgbGVuZ3RoLCB0cnVlLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVmaW5lKGZuLCAnbGVuZ3RoJywgbGVuZ3RoKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZuO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///521\n")},680:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(801);\nvar callBound = __webpack_require__(615);\nvar inspect = __webpack_require__(126);\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\n\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n\n/*\n * This function traverses the list returning the node corresponding to the\n * given key.\n *\n * That node is also moved to the head of the list, so that if it's accessed\n * again we don't need to traverse the whole list. By doing so, all the recently\n * used nodes can be accessed relatively quickly.\n */\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tcurr.next = list.next;\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\nvar listGet = function (objects, key) {\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t};\n\t}\n};\nvar listHas = function (objects, key) {\n\treturn !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n\tvar $wm;\n\tvar $m;\n\tvar $o;\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapGet($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listGet($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapHas($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listHas($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif (!$wm) {\n\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t}\n\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t} else if ($Map) {\n\t\t\t\tif (!$m) {\n\t\t\t\t\t$m = new $Map();\n\t\t\t\t}\n\t\t\t\t$mapSet($m, key, value);\n\t\t\t} else {\n\t\t\t\tif (!$o) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\n\t\t\t\t\t */\n\t\t\t\t\t$o = { key: {}, next: null };\n\t\t\t\t}\n\t\t\t\tlistSet($o, key, value);\n\t\t\t}\n\t\t}\n\t};\n\treturn channel;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjgwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLEdBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsR0FBcUI7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLEdBQWdCOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3NpZGUtY2hhbm5lbC9pbmRleC5qcz8wYjg4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRXZWFrTWFwID0gR2V0SW50cmluc2ljKCclV2Vha01hcCUnLCB0cnVlKTtcbnZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXG52YXIgJHdlYWtNYXBHZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwU2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcbnZhciAkd2Vha01hcEhhcyA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkbWFwU2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgbGlzdCByZXR1cm5pbmcgdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGVcbiAqIGdpdmVuIGtleS5cbiAqXG4gKiBUaGF0IG5vZGUgaXMgYWxzbyBtb3ZlZCB0byB0aGUgaGVhZCBvZiB0aGUgbGlzdCwgc28gdGhhdCBpZiBpdCdzIGFjY2Vzc2VkXG4gKiBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseVxuICogdXNlZCBub2RlcyBjYW4gYmUgYWNjZXNzZWQgcmVsYXRpdmVseSBxdWlja2x5LlxuICovXG52YXIgbGlzdEdldE5vZGUgPSBmdW5jdGlvbiAobGlzdCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0Zm9yICh2YXIgcHJldiA9IGxpc3QsIGN1cnI7IChjdXJyID0gcHJldi5uZXh0KSAhPT0gbnVsbDsgcHJldiA9IGN1cnIpIHtcblx0XHRpZiAoY3Vyci5rZXkgPT09IGtleSkge1xuXHRcdFx0cHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuXHRcdFx0Y3Vyci5uZXh0ID0gbGlzdC5uZXh0O1xuXHRcdFx0bGlzdC5uZXh0ID0gY3VycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgbGlzdEdldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlO1xufTtcbnZhciBsaXN0U2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSwgdmFsdWUpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRpZiAobm9kZSkge1xuXHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmVwZW5kIHRoZSBuZXcgbm9kZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cdFx0b2JqZWN0cy5uZXh0ID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRrZXk6IGtleSxcblx0XHRcdG5leHQ6IG9iamVjdHMubmV4dCxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cbn07XG52YXIgbGlzdEhhcyA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0cmV0dXJuICEhbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWwoKSB7XG5cdHZhciAkd207XG5cdHZhciAkbTtcblx0dmFyICRvO1xuXHR2YXIgY2hhbm5lbCA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uIChrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEdldCgkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEdldCgkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RHZXQoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEhhcygkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEhhcygkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RIYXMoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICghJHdtKSB7XG5cdFx0XHRcdFx0JHdtID0gbmV3ICRXZWFrTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JHdlYWtNYXBTZXQoJHdtLCBrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoISRtKSB7XG5cdFx0XHRcdFx0JG0gPSBuZXcgJE1hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRtYXBTZXQoJG0sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkbykge1xuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0ICogSW5pdGlhbGl6ZSB0aGUgbGlua2VkIGxpc3QgYXMgYW4gZW1wdHkgbm9kZSwgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG5cdFx0XHRcdFx0ICogdG8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHRoZSBmaXJzdCBub2RlOiB3ZSBjYW4gYWx3YXlzIHJlZmVyIHRvXG5cdFx0XHRcdFx0ICogaXQgYXMgKHByZXZpb3VzIG5vZGUpLm5leHQsIGluc3RlYWQgb2Ygc29tZXRoaW5nIGxpa2UgKGxpc3QpLmhlYWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkbyA9IHsga2V5OiB7fSwgbmV4dDogbnVsbCB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3RTZXQoJG8sIGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGNoYW5uZWw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///680\n")},928:function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUVVO0FBQ1o7QUFDQSxFQUFFLG1DQUFtQjtBQUNyQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQWFOOztBQUVGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzP2JlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///928\n")},44:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n/*\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\nvar punycode = __webpack_require__(928);\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n/*\n * define these here so at least they only have to be\n * compiled once on the first module load.\n */\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/,\n\n  /*\n   * RFC 2396: characters reserved for delimiting URLs.\n   * We actually just auto-escape these.\n   */\n  delims = [\n    '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'\n  ],\n\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = [\n    '{', '}', '|', '\\\\', '^', '`'\n  ].concat(delims),\n\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  /*\n   * Characters that are never ever allowed in a hostname.\n   * Note that any invalid chars are also handled, but these\n   * are the ones that are *expected* to be seen, so we fast-path\n   * them.\n   */\n  nonHostChars = [\n    '%', '/', '?', ';', '#'\n  ].concat(autoEscape),\n  hostEndingChars = [\n    '/', '?', '#'\n  ],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    javascript: true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    http: true,\n    https: true,\n    ftp: true,\n    gopher: true,\n    file: true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = __webpack_require__(907);\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === 'object' && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  /*\n   * Copy chrome, IE, opera backslash-handling behavior.\n   * Back slashes before the query string get converted to forward slashes\n   * See: https://code.google.com/p/chromium/issues/detail?id=25916\n   */\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  /*\n   * trim before proceeding.\n   * This is to support parse stuff like \"  http://foo.com  \\n\"\n   */\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  /*\n   * figure out if it's got a host\n   * user@server is *always* interpreted as a hostname, and url\n   * resolution will treat //foo/bar as host=foo,path=bar because that's\n   * how the browser resolves relative URLs.\n   */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {\n\n    /*\n     * there's a hostname.\n     * the first instance of /, ?, ;, or # ends the host.\n     *\n     * If there is an @ in the hostname, then non-host chars *are* allowed\n     * to the left of the last @ sign, unless some host-ending character\n     * comes *before* the @-sign.\n     * URLs are obnoxious.\n     *\n     * ex:\n     * http://a@b@c/ => user:a@b host:c\n     * http://a@b?@c => user:a host:c path:/?@c\n     */\n\n    /*\n     * v0.12 TODO(isaacs): This is not quite how Chrome does things.\n     * Review our test case against browsers more comprehensively.\n     */\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n\n    /*\n     * at this point, either we have an explicit point where the\n     * auth portion cannot go past, or the last @ char is the decider.\n     */\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      /*\n       * atSign must be in auth portion.\n       * http://a@b/c@d => host:b auth:a path:/c@d\n       */\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    /*\n     * Now we have a portion which is definitely the auth.\n     * Pull that off.\n     */\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) { hostEnd = rest.length; }\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    /*\n     * we've indicated that there is a hostname,\n     * so even if it's empty, it has to be present.\n     */\n    this.hostname = this.hostname || '';\n\n    /*\n     * if hostname begins with [ and ends with ]\n     * assume that it's an IPv6 address.\n     */\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              /*\n               * we replace non-ASCII char with a temporary placeholder\n               * we need this to make sure size of hostname is not\n               * broken by replacing non-ASCII by nothing\n               */\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      /*\n       * IDNA Support: Returns a punycoded representation of \"domain\".\n       * It only converts parts of the domain name that\n       * have non-ASCII characters, i.e. it doesn't matter if\n       * you call it with a domain that already is ASCII-only.\n       */\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    /*\n     * strip [ and ] from the hostname\n     * the host field still retains them, though\n     */\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  /*\n   * now rest is set to the post-host stuff.\n   * chop off any delim chars.\n   */\n  if (!unsafeProtocol[lowerProto]) {\n\n    /*\n     * First, make 100% sure that any \"autoEscape\" chars get\n     * escaped, even if encodeURIComponent doesn't think they\n     * need to be.\n     */\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) { continue; }\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  /*\n   * ensure it's an object, and not a string url.\n   * If it's an obj, this is a no-op.\n   * this way, you can call url_format() on strings\n   * to clean up potentially wonky urls.\n   */\n  if (typeof obj === 'string') { obj = urlParse(obj); }\n  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query, {\n      arrayFormat: 'repeat',\n      addQueryPrefix: false\n    });\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n  /*\n   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n   * unless they had them to begin with.\n   */\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n  if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) { return relative; }\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  /*\n   * hash is always overridden, no matter what.\n   * even href=\"\" will remove it.\n   */\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.pathname = '/';\n      result.path = result.pathname;\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    /*\n     * if it's a known url protocol, then changing\n     * the protocol does weird things\n     * first, if it's not file:, then we MUST have a host,\n     * and if there was a path\n     * to begin with, then we MUST have a path.\n     * if it is file:, then the host is dropped,\n     * because that's known to be hostless.\n     * anything else is assumed to be absolute.\n     */\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift())) { }\n      if (!relative.host) { relative.host = ''; }\n      if (!relative.hostname) { relative.hostname = ''; }\n      if (relPath[0] !== '') { relPath.unshift(''); }\n      if (relPath.length < 2) { relPath.unshift(''); }\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  /*\n   * if the url is a non-slashed url, then relative\n   * links like ../.. should be able\n   * to crawl up to the hostname, as well.  This is strange.\n   * result.protocol has already been set by now.\n   * Later on, put the first path part into the host field.\n   */\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    /*\n     * it's relative\n     * throw away the existing file, and take the new path instead.\n     */\n    if (!srcPath) { srcPath = []; }\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search != null) {\n    /*\n     * just pull out the search.\n     * like href='?foo'.\n     * Put this after the other two cases because it simplifies the booleans\n     */\n    if (psychotic) {\n      result.host = srcPath.shift();\n      result.hostname = result.host;\n      /*\n       * occationaly the auth can get stuck only in host\n       * this especially happens in cases like\n       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n       */\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.hostname = authInHost.shift();\n        result.host = result.hostname;\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    /*\n     * no path at all.  easy.\n     * we've already handled the other stuff above.\n     */\n    result.pathname = null;\n    // to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  /*\n   * if a url ENDs in . or .., then it must get a trailing slash.\n   * however, if it ends in anything else non-slashy,\n   * then it must NOT get a trailing slash.\n   */\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  /*\n   * strip single dots, resolve double dots to parent dir\n   * if the path tries to go above the root, `up` ends up > 0\n   */\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    result.host = result.hostname;\n    /*\n     * occationaly the auth can get stuck only in host\n     * this especially happens in cases like\n     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n     */\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.hostname = authInHost.shift();\n      result.host = result.hostname;\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (srcPath.length > 0) {\n    result.pathname = srcPath.join('/');\n  } else {\n    result.pathname = null;\n    result.path = null;\n  }\n\n  // to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.Qc = urlParse;\nexports.DB = urlResolve;\n__webpack_unused_export__ = urlResolveObject;\nexports.WU = urlFormat;\n\n__webpack_unused_export__ = Url;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxVQUFhO0FBQ2IsVUFBZTtBQUNmLHlCQUFxQjtBQUNyQixVQUFjOztBQUVkLHlCQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz81NzAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gKiBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAqIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gKiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAqIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICogT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICogVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8qXG4gKiBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuICogY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG4gKi9cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW14/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gIC8qXG4gICAqIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAqIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAqL1xuICBkZWxpbXMgPSBbXG4gICAgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXG4gIF0sXG5cbiAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgdW53aXNlID0gW1xuICAgICd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCdcbiAgXS5jb25jYXQoZGVsaW1zKSxcblxuICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAvKlxuICAgKiBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgKiBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAqIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgKiB0aGVtLlxuICAgKi9cbiAgbm9uSG9zdENoYXJzID0gW1xuICAgICclJywgJy8nLCAnPycsICc7JywgJyMnXG4gIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICBob3N0RW5kaW5nQ2hhcnMgPSBbXG4gICAgJy8nLCAnPycsICcjJ1xuICBdLFxuICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICBqYXZhc2NyaXB0OiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgfSxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgIGphdmFzY3JpcHQ6IHRydWUsXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICB9LFxuICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgIGh0dHA6IHRydWUsXG4gICAgaHR0cHM6IHRydWUsXG4gICAgZnRwOiB0cnVlLFxuICAgIGdvcGhlcjogdHJ1ZSxcbiAgICBmaWxlOiB0cnVlLFxuICAgICdodHRwOic6IHRydWUsXG4gICAgJ2h0dHBzOic6IHRydWUsXG4gICAgJ2Z0cDonOiB0cnVlLFxuICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAnZmlsZTonOiB0cnVlXG4gIH0sXG4gIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXMnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8qXG4gICAqIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAgKiBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgICogU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgICovXG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICBzcGxpdHRlciA9IHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpID8gJz8nIDogJyMnLFxuICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvKlxuICAgKiB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgKiBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gICAqL1xuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLypcbiAgICogZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgICogdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAgKiByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gICAqIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICAgKi9cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkAvXStAW15AL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8qXG4gICAgICogdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgICAqIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgICogdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAgKiBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgICAqIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAgKlxuICAgICAqIGV4OlxuICAgICAqIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgICogaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgICogUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cbiAgICAgKi9cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHsgaG9zdEVuZCA9IGhlYzsgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgICogYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgICovXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qXG4gICAgICAgKiBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAgKiBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgICovXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAgKiBQdWxsIHRoYXQgb2ZmLlxuICAgICAqL1xuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkgeyBob3N0RW5kID0gcmVzdC5sZW5ndGg7IH1cblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvKlxuICAgICAqIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgICogc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICAgKi9cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8qXG4gICAgICogaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAgKiBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICAgKi9cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgKiB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICogd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAgKiBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgICAqIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgICAqIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgICAqIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvKlxuICAgICAqIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAgKiB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgICAqL1xuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgICogY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICAgKi9cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLypcbiAgICAgKiBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgICogZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgICogbmVlZCB0byBiZS5cbiAgICAgKi9cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKSB7IGNvbnRpbnVlOyB9XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLypcbiAgICogZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgICogSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgICogdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAgKiB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICAgKi9cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7IG9iaiA9IHVybFBhcnNlKG9iaik7IH1cbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgeyByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopOyB9XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICBob3N0ID0gZmFsc2UsXG4gICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/IHRoaXMuaG9zdG5hbWUgOiAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJiB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSwge1xuICAgICAgYXJyYXlGb3JtYXQ6ICdyZXBlYXQnLFxuICAgICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHsgcHJvdG9jb2wgKz0gJzonOyB9XG5cbiAgLypcbiAgICogb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gICAqIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gICAqL1xuICBpZiAodGhpcy5zbGFzaGVzIHx8ICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHsgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTsgfVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgeyBoYXNoID0gJyMnICsgaGFzaDsgfVxuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgeyBzZWFyY2ggPSAnPycgKyBzZWFyY2g7IH1cblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuIHJlbGF0aXZlOyB9XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgcmVsYXRpdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8qXG4gICAqIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAgKiBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICovXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKSB7IHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldOyB9XG4gICAgfVxuXG4gICAgLy8gdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZTtcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvKlxuICAgICAqIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgKiB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgKiBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAgKiBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAqIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAgKiBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgICAqIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgICAqIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgKi9cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkgeyB9XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHsgcmVsYXRpdmUuaG9zdCA9ICcnOyB9XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSB7IHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7IH1cbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgeyByZWxQYXRoLnVuc2hpZnQoJycpOyB9XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH1cbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICBpc1JlbEFicyA9IHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgbXVzdEVuZEFicyA9IGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8IChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSksXG4gICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8qXG4gICAqIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICogbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAgKiB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAqIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAqIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICAgKi9cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgeyBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7IH0gZWxzZSB7IHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7IH1cbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSB7IHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0OyB9IGVsc2UgeyByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7IH1cbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycgPyByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnID8gcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8qXG4gICAgICogaXQncyByZWxhdGl2ZVxuICAgICAqIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGlmICghc3JjUGF0aCkgeyBzcmNQYXRoID0gW107IH1cbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKHJlbGF0aXZlLnNlYXJjaCAhPSBudWxsKSB7XG4gICAgLypcbiAgICAgKiBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICogbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAgKiBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICAgKi9cbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0O1xuICAgICAgLypcbiAgICAgICAqIG9jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgKiB0aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgKiB1cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgICAqL1xuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lICE9PSBudWxsIHx8IHJlc3VsdC5zZWFyY2ggIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvKlxuICAgICAqIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgKiB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgICAqL1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICAgKiBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICogaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gICAqIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAqL1xuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJztcblxuICAvKlxuICAgKiBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gICAqIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gICAqL1xuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiYgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHwgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IGlzQWJzb2x1dGUgPyAnJyA6IHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWU7XG4gICAgLypcbiAgICAgKiBvY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAqIHRoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgKiB1cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgKi9cbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWU7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoc3JjUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH1cblxuICAvLyB0byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAocmVzdWx0LnBhdGhuYW1lICE9PSBudWxsIHx8IHJlc3VsdC5zZWFyY2ggIT09IG51bGwpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n")},647:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MxU: () => (/* reexport */ Application),\n  T$b: () => (/* reexport */ lib_BLEND_MODES),\n  TCu: () => (/* reexport */ Graphics),\n  jyi: () => (/* reexport */ Sprite_Sprite),\n  xEZ: () => (/* reexport */ Texture_Texture)\n});\n\n// UNUSED EXPORTS: ALPHA_MODES, AbstractMultiResource, AccessibilityManager, AlphaFilter, AnimatedSprite, ArrayResource, Assets, AssetsClass, Attribute, BUFFER_BITS, BUFFER_TYPE, BackgroundSystem, BaseImageResource, BasePrepare, BaseRenderTexture, BaseTexture, BatchDrawCall, BatchGeometry, BatchRenderer, BatchShaderGenerator, BatchSystem, BatchTextureArray, BitmapFont, BitmapFontData, BitmapText, BlobResource, BlurFilter, BlurFilterPass, Bounds, BrowserAdapter, Buffer, BufferResource, BufferSystem, CLEAR_MODES, COLOR_MASK_BITS, Cache, CanvasResource, Circle, Color, ColorMatrixFilter, CompressedTextureResource, Container, ContextSystem, CountLimiter, CubeResource, DEG_TO_RAD, DRAW_MODES, DisplacementFilter, DisplayObject, ENV, Ellipse, EventBoundary, EventSystem, ExtensionType, Extract, FORMATS, FORMATS_TO_COMPONENTS, FXAAFilter, FederatedDisplayObject, FederatedEvent, FederatedMouseEvent, FederatedPointerEvent, FederatedWheelEvent, FillStyle, Filter, FilterState, FilterSystem, Framebuffer, FramebufferSystem, GC_MODES, GLFramebuffer, GLProgram, GLTexture, GRAPHICS_CURVES, GenerateTextureSystem, Geometry, GeometrySystem, GraphicsData, GraphicsGeometry, HTMLText, HTMLTextStyle, IGLUniformData, INSTALLED, INTERNAL_FORMATS, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, ImageBitmapResource, ImageResource, LINE_CAP, LINE_JOIN, LineStyle, LoaderParserPriority, MASK_TYPES, MIPMAP_MODES, MSAA_QUALITY, MaskData, MaskSystem, Matrix, Mesh, MeshBatchUvs, MeshGeometry, MeshMaterial, MultisampleSystem, NineSlicePlane, NoiseFilter, ObjectRenderer, ObjectRendererSystem, ObservablePoint, PI_2, PRECISION, ParticleContainer, ParticleRenderer, PlaneGeometry, PluginSystem, Point, Polygon, Prepare, Program, ProjectionSystem, Quad, QuadUv, RAD_TO_DEG, RENDERER_TYPE, Rectangle, RenderTexture, RenderTexturePool, RenderTextureSystem, Renderer, ResizePlugin, Resource, RopeGeometry, RoundedRectangle, Runner, SAMPLER_TYPES, SCALE_MODES, SHAPES, SVGResource, ScissorSystem, Shader, ShaderSystem, SimpleMesh, SimplePlane, SimpleRope, SpriteMaskFilter, Spritesheet, StartupSystem, State, StateSystem, StencilSystem, SystemManager, TARGETS, TEXT_GRADIENT, TYPES, TYPES_TO_BYTES_PER_COMPONENT, TYPES_TO_BYTES_PER_PIXEL, TemporaryDisplayObject, Text, TextFormat, TextMetrics, TextStyle, TextureGCSystem, TextureMatrix, TextureSystem, TextureUvs, Ticker, TickerPlugin, TilingSprite, TilingSpriteRenderer, TimeLimiter, Transform, TransformFeedback, TransformFeedbackSystem, UPDATE_PRIORITY, UniformGroup, VERSION, VideoResource, ViewSystem, ViewableBuffer, WRAP_MODES, XMLFormat, XMLStringFormat, accessibleTarget, autoDetectFormat, autoDetectRenderer, autoDetectResource, cacheTextureArray, checkDataUrl, checkExtension, checkMaxIfStatementsInShader, convertToList, copySearchParams, createStringVariations, createTexture, createUBOElements, curves, defaultFilterVertex, defaultVertex, detectAvif, detectCompressedTextures, detectDefaults, detectMp4, detectOgv, detectWebm, detectWebp, extensions, filters, generateProgram, generateUniformBufferSync, getFontFamilyName, getTestContext, getUBOData, graphicsUtils, groupD8, isMobile, isSingleItem, loadBitmapFont, loadDDS, loadImageBitmap, loadJson, loadKTX, loadSVG, loadTextures, loadTxt, loadVideo, loadWebFont, parseDDS, parseKTX, resolveCompressedTextureUrl, resolveTextureUrl, settings, spritesheetAsset, uniformParsers, unsafeEvalSupported, utils\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/constants/lib/index.mjs\nvar ENV = /* @__PURE__ */ ((ENV2) => (ENV2[ENV2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", ENV2[ENV2.WEBGL = 1] = "WEBGL", ENV2[ENV2.WEBGL2 = 2] = "WEBGL2", ENV2))(ENV || {}), RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => (RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN = 0] = "UNKNOWN", RENDERER_TYPE2[RENDERER_TYPE2.WEBGL = 1] = "WEBGL", RENDERER_TYPE2[RENDERER_TYPE2.CANVAS = 2] = "CANVAS", RENDERER_TYPE2))(RENDERER_TYPE || {}), BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => (BUFFER_BITS2[BUFFER_BITS2.COLOR = 16384] = "COLOR", BUFFER_BITS2[BUFFER_BITS2.DEPTH = 256] = "DEPTH", BUFFER_BITS2[BUFFER_BITS2.STENCIL = 1024] = "STENCIL", BUFFER_BITS2))(BUFFER_BITS || {}), lib_BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => (BLEND_MODES2[BLEND_MODES2.NORMAL = 0] = "NORMAL", BLEND_MODES2[BLEND_MODES2.ADD = 1] = "ADD", BLEND_MODES2[BLEND_MODES2.MULTIPLY = 2] = "MULTIPLY", BLEND_MODES2[BLEND_MODES2.SCREEN = 3] = "SCREEN", BLEND_MODES2[BLEND_MODES2.OVERLAY = 4] = "OVERLAY", BLEND_MODES2[BLEND_MODES2.DARKEN = 5] = "DARKEN", BLEND_MODES2[BLEND_MODES2.LIGHTEN = 6] = "LIGHTEN", BLEND_MODES2[BLEND_MODES2.COLOR_DODGE = 7] = "COLOR_DODGE", BLEND_MODES2[BLEND_MODES2.COLOR_BURN = 8] = "COLOR_BURN", BLEND_MODES2[BLEND_MODES2.HARD_LIGHT = 9] = "HARD_LIGHT", BLEND_MODES2[BLEND_MODES2.SOFT_LIGHT = 10] = "SOFT_LIGHT", BLEND_MODES2[BLEND_MODES2.DIFFERENCE = 11] = "DIFFERENCE", BLEND_MODES2[BLEND_MODES2.EXCLUSION = 12] = "EXCLUSION", BLEND_MODES2[BLEND_MODES2.HUE = 13] = "HUE", BLEND_MODES2[BLEND_MODES2.SATURATION = 14] = "SATURATION", BLEND_MODES2[BLEND_MODES2.COLOR = 15] = "COLOR", BLEND_MODES2[BLEND_MODES2.LUMINOSITY = 16] = "LUMINOSITY", BLEND_MODES2[BLEND_MODES2.NORMAL_NPM = 17] = "NORMAL_NPM", BLEND_MODES2[BLEND_MODES2.ADD_NPM = 18] = "ADD_NPM", BLEND_MODES2[BLEND_MODES2.SCREEN_NPM = 19] = "SCREEN_NPM", BLEND_MODES2[BLEND_MODES2.NONE = 20] = "NONE", BLEND_MODES2[BLEND_MODES2.SRC_OVER = 0] = "SRC_OVER", BLEND_MODES2[BLEND_MODES2.SRC_IN = 21] = "SRC_IN", BLEND_MODES2[BLEND_MODES2.SRC_OUT = 22] = "SRC_OUT", BLEND_MODES2[BLEND_MODES2.SRC_ATOP = 23] = "SRC_ATOP", BLEND_MODES2[BLEND_MODES2.DST_OVER = 24] = "DST_OVER", BLEND_MODES2[BLEND_MODES2.DST_IN = 25] = "DST_IN", BLEND_MODES2[BLEND_MODES2.DST_OUT = 26] = "DST_OUT", BLEND_MODES2[BLEND_MODES2.DST_ATOP = 27] = "DST_ATOP", BLEND_MODES2[BLEND_MODES2.ERASE = 26] = "ERASE", BLEND_MODES2[BLEND_MODES2.SUBTRACT = 28] = "SUBTRACT", BLEND_MODES2[BLEND_MODES2.XOR = 29] = "XOR", BLEND_MODES2))(lib_BLEND_MODES || {}), DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => (DRAW_MODES2[DRAW_MODES2.POINTS = 0] = "POINTS", DRAW_MODES2[DRAW_MODES2.LINES = 1] = "LINES", DRAW_MODES2[DRAW_MODES2.LINE_LOOP = 2] = "LINE_LOOP", DRAW_MODES2[DRAW_MODES2.LINE_STRIP = 3] = "LINE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLES = 4] = "TRIANGLES", DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", DRAW_MODES2))(DRAW_MODES || {}), FORMATS = /* @__PURE__ */ ((FORMATS2) => (FORMATS2[FORMATS2.RGBA = 6408] = "RGBA", FORMATS2[FORMATS2.RGB = 6407] = "RGB", FORMATS2[FORMATS2.RG = 33319] = "RG", FORMATS2[FORMATS2.RED = 6403] = "RED", FORMATS2[FORMATS2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", FORMATS2[FORMATS2.RGB_INTEGER = 36248] = "RGB_INTEGER", FORMATS2[FORMATS2.RG_INTEGER = 33320] = "RG_INTEGER", FORMATS2[FORMATS2.RED_INTEGER = 36244] = "RED_INTEGER", FORMATS2[FORMATS2.ALPHA = 6406] = "ALPHA", FORMATS2[FORMATS2.LUMINANCE = 6409] = "LUMINANCE", FORMATS2[FORMATS2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", FORMATS2[FORMATS2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", FORMATS2[FORMATS2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", FORMATS2))(FORMATS || {}), TARGETS = /* @__PURE__ */ ((TARGETS2) => (TARGETS2[TARGETS2.TEXTURE_2D = 3553] = "TEXTURE_2D", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", TARGETS2[TARGETS2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", TARGETS2))(TARGETS || {}), TYPES = /* @__PURE__ */ ((TYPES2) => (TYPES2[TYPES2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", TYPES2[TYPES2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", TYPES2[TYPES2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", TYPES2[TYPES2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", TYPES2[TYPES2.BYTE = 5120] = "BYTE", TYPES2[TYPES2.SHORT = 5122] = "SHORT", TYPES2[TYPES2.INT = 5124] = "INT", TYPES2[TYPES2.FLOAT = 5126] = "FLOAT", TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", TYPES2[TYPES2.HALF_FLOAT = 36193] = "HALF_FLOAT", TYPES2))(TYPES || {}), SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => (SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT = 0] = "FLOAT", SAMPLER_TYPES2[SAMPLER_TYPES2.INT = 1] = "INT", SAMPLER_TYPES2[SAMPLER_TYPES2.UINT = 2] = "UINT", SAMPLER_TYPES2))(SAMPLER_TYPES || {}), SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => (SCALE_MODES2[SCALE_MODES2.NEAREST = 0] = "NEAREST", SCALE_MODES2[SCALE_MODES2.LINEAR = 1] = "LINEAR", SCALE_MODES2))(SCALE_MODES || {}), lib_WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => (WRAP_MODES2[WRAP_MODES2.CLAMP = 33071] = "CLAMP", WRAP_MODES2[WRAP_MODES2.REPEAT = 10497] = "REPEAT", WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", WRAP_MODES2))(lib_WRAP_MODES || {}), MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => (MIPMAP_MODES2[MIPMAP_MODES2.OFF = 0] = "OFF", MIPMAP_MODES2[MIPMAP_MODES2.POW2 = 1] = "POW2", MIPMAP_MODES2[MIPMAP_MODES2.ON = 2] = "ON", MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL = 3] = "ON_MANUAL", MIPMAP_MODES2))(MIPMAP_MODES || {}), ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => (ALPHA_MODES2[ALPHA_MODES2.NPM = 0] = "NPM", ALPHA_MODES2[ALPHA_MODES2.UNPACK = 1] = "UNPACK", ALPHA_MODES2[ALPHA_MODES2.PMA = 2] = "PMA", ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", ALPHA_MODES2))(ALPHA_MODES || {}), CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => (CLEAR_MODES2[CLEAR_MODES2.NO = 0] = "NO", CLEAR_MODES2[CLEAR_MODES2.YES = 1] = "YES", CLEAR_MODES2[CLEAR_MODES2.AUTO = 2] = "AUTO", CLEAR_MODES2[CLEAR_MODES2.BLEND = 0] = "BLEND", CLEAR_MODES2[CLEAR_MODES2.CLEAR = 1] = "CLEAR", CLEAR_MODES2[CLEAR_MODES2.BLIT = 2] = "BLIT", CLEAR_MODES2))(CLEAR_MODES || {}), GC_MODES = /* @__PURE__ */ ((GC_MODES2) => (GC_MODES2[GC_MODES2.AUTO = 0] = "AUTO", GC_MODES2[GC_MODES2.MANUAL = 1] = "MANUAL", GC_MODES2))(GC_MODES || {}), PRECISION = /* @__PURE__ */ ((PRECISION2) => (PRECISION2.LOW = "lowp", PRECISION2.MEDIUM = "mediump", PRECISION2.HIGH = "highp", PRECISION2))(PRECISION || {}), MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => (MASK_TYPES2[MASK_TYPES2.NONE = 0] = "NONE", MASK_TYPES2[MASK_TYPES2.SCISSOR = 1] = "SCISSOR", MASK_TYPES2[MASK_TYPES2.STENCIL = 2] = "STENCIL", MASK_TYPES2[MASK_TYPES2.SPRITE = 3] = "SPRITE", MASK_TYPES2[MASK_TYPES2.COLOR = 4] = "COLOR", MASK_TYPES2))(MASK_TYPES || {}), COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => (COLOR_MASK_BITS2[COLOR_MASK_BITS2.RED = 1] = "RED", COLOR_MASK_BITS2[COLOR_MASK_BITS2.GREEN = 2] = "GREEN", COLOR_MASK_BITS2[COLOR_MASK_BITS2.BLUE = 4] = "BLUE", COLOR_MASK_BITS2[COLOR_MASK_BITS2.ALPHA = 8] = "ALPHA", COLOR_MASK_BITS2))(COLOR_MASK_BITS || {}), MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => (MSAA_QUALITY2[MSAA_QUALITY2.NONE = 0] = "NONE", MSAA_QUALITY2[MSAA_QUALITY2.LOW = 2] = "LOW", MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM = 4] = "MEDIUM", MSAA_QUALITY2[MSAA_QUALITY2.HIGH = 8] = "HIGH", MSAA_QUALITY2))(MSAA_QUALITY || {}), BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => (BUFFER_TYPE2[BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", BUFFER_TYPE2[BUFFER_TYPE2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", BUFFER_TYPE2[BUFFER_TYPE2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", BUFFER_TYPE2))(BUFFER_TYPE || {});\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/adapter.mjs\nconst BrowserAdapter = {\n  /**\n   * Creates a canvas element of the given size.\n   * This canvas is created using the browser\'s native canvas element.\n   * @param width - width of the canvas\n   * @param height - height of the canvas\n   */\n  createCanvas: (width, height) => {\n    const canvas = document.createElement("canvas");\n    return canvas.width = width, canvas.height = height, canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => new DOMParser().parseFromString(xml, "text/xml")\n};\n\n//# sourceMappingURL=adapter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/settings.mjs\n\nconst settings = {\n  /**\n   * This adapter is used to call methods that are platform dependent.\n   * For example `document.createElement` only runs on the web but fails in node environments.\n   * This allows us to support more platforms by abstracting away specific implementations per platform.\n   *\n   * By default the adapter is set to work in the browser. However you can create your own\n   * by implementing the `IAdapter` interface. See `IAdapter` for more information.\n   * @name ADAPTER\n   * @memberof PIXI.settings\n   * @type {PIXI.IAdapter}\n   * @default PIXI.BrowserAdapter\n   */\n  ADAPTER: BrowserAdapter,\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @static\n   * @name RESOLUTION\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 1\n   */\n  RESOLUTION: 1,\n  /**\n   * Enables bitmap creation before image load. This feature is experimental.\n   * @static\n   * @name CREATE_IMAGE_BITMAP\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  CREATE_IMAGE_BITMAP: !1,\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * @static\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  ROUND_PIXELS: !1\n};\n\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== \'undefined\' &&\n        navigator.platform === \'MacIntel\' &&\n        typeof navigator.maxTouchPoints === \'number\' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === \'undefined\');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: \'\',\n        platform: \'\',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== \'undefined\') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === \'string\') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split(\'[FBAN\');\n    if (typeof tmp[1] !== \'undefined\') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split(\'Twitter\');\n    if (typeof tmp[1] !== \'undefined\') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/utils/isMobile.mjs\n\nconst isMobileCall = isMobile["default"] ?? isMobile, isMobile_isMobile = isMobileCall(globalThis.navigator);\n\n//# sourceMappingURL=isMobile.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/settings.mjs\n\n\nsettings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\n\n//# sourceMappingURL=settings.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/utils/node_modules/eventemitter3/index.js\nvar eventemitter3 = __webpack_require__(406);\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n// EXTERNAL MODULE: ./node_modules/url/url.js\nvar url = __webpack_require__(44);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/logging/deprecation.mjs\nconst warnings = {};\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message])\n    return;\n  let stack = new Error().stack;\n  typeof stack > "u" ? console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`) : (stack = stack.split(`\n`).splice(ignoreDepth).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\n    "%cPixiJS Deprecation Warning: %c%s",\n    "color:#614108;background:#fffbe6",\n    "font-weight:normal;color:#614108;background:#fffbe6",\n    `${message}\nDeprecated since v${version}`\n  ), console.warn(stack), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`), console.warn(stack))), warnings[message] = !0;\n}\n\n//# sourceMappingURL=deprecation.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/url.mjs\n\n\nconst url_url = {\n  /**\n   * @deprecated since 7.3.0\n   */\n  get parse() {\n    return deprecation("7.3.0", "utils.url.parse is deprecated, use native URL API instead."), url/* parse */.Qc;\n  },\n  /**\n   * @deprecated since 7.3.0\n   */\n  get format() {\n    return deprecation("7.3.0", "utils.url.format is deprecated, use native URL API instead."), url/* format */.WU;\n  },\n  /**\n   * @deprecated since 7.3.0\n   */\n  get resolve() {\n    return deprecation("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."), url/* resolve */.DB;\n  }\n};\n\n//# sourceMappingURL=url.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/path.mjs\n\nfunction assertPath(path2) {\n  if (typeof path2 != "string")\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n}\nfunction removeUrlParams(url) {\n  return url.split("?")[0].split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length)\n      code = path2.charCodeAt(i);\n    else {\n      if (code === 47)\n        break;\n      code = 47;\n    }\n    if (code === 47) {\n      if (!(lastSlash === i - 1 || dots === 1))\n        if (lastSlash !== i - 1 && dots === 2) {\n          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n            if (res.length > 2) {\n              const lastSlashIndex = res.lastIndexOf("/");\n              if (lastSlashIndex !== res.length - 1) {\n                lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = i, dots = 0;\n                continue;\n              }\n            } else if (res.length === 2 || res.length === 1) {\n              res = "", lastSegmentLength = 0, lastSlash = i, dots = 0;\n              continue;\n            }\n          }\n          allowAboveRoot && (res.length > 0 ? res += "/.." : res = "..", lastSegmentLength = 2);\n        } else\n          res.length > 0 ? res += `/${path2.slice(lastSlash + 1, i)}` : res = path2.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;\n      lastSlash = i, dots = 0;\n    } else\n      code === 46 && dots !== -1 ? ++dots : dots = -1;\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith("blob:");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2), path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile)\n      return matchFile[0];\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    return matchProtocol ? matchProtocol[0] : "";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it\'s not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    if (assertPath(url), this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl())), rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    return url = this.toPosix(url), url.startsWith("/") ? path.join(rootUrl, url.slice(1)) : this.isAbsolute(url) ? url : this.join(baseUrl, url);\n  },\n  /**\n   * Normalizes the given path, resolving \'..\' and \'.\' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    if (assertPath(path2), path2.length === 0)\n      return ".";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    this.hasProtocol(path2) && (protocol = this.rootname(path2), path2 = path2.slice(protocol.length));\n    const trailingSeparator = path2.endsWith("/");\n    return path2 = normalizeStringPosix(path2, !1), path2.length > 0 && trailingSeparator && (path2 += "/"), isAbsolute ? `/${path2}` : protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    return assertPath(path2), path2 = this.toPosix(path2), this.hasProtocol(path2) ? !0 : path2.startsWith("/");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0)\n      return ".";\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      if (assertPath(arg), arg.length > 0)\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          this.joinExtensions.includes(this.extname(prevArg).toLowerCase()) ? joined += `/../${arg}` : joined += `/${arg}`;\n        }\n    }\n    return joined === void 0 ? "." : this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    if (assertPath(path2), path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1, matchedSlash = !0;\n    const proto = this.getProtocol(path2), origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i)\n      if (code = path2.charCodeAt(i), code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else\n        matchedSlash = !1;\n    return end === -1 ? hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto : hasRoot && end === 1 ? "//" : proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2), path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/") ? root = "/" : root = this.getProtocol(path2), this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      index !== -1 ? root = path2.slice(0, index) : root = path2, root.endsWith("/") || (root += "/");\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2), ext && assertPath(ext), path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0, end = -1, matchedSlash = !0, i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1, firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else\n          firstNonSlashEnd === -1 && (matchedSlash = !1, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i) : (extIdx = -1, end = firstNonSlashEnd));\n      }\n      return start === end ? end = firstNonSlashEnd : end === -1 && (end = path2.length), path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i)\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else\n        end === -1 && (matchedSlash = !1, end = i + 1);\n    return end === -1 ? "" : path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2), path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);\n    }\n    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the \'root\', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2), isAbsolute || this.hasProtocol(path2) ? start = 1 : start = 0;\n    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, i = path2.length - 1, preDotState = 0;\n    for (; i >= start; --i) {\n      if (code = path2.charCodeAt(i), code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);\n    }\n    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (startPart === 0 && isAbsolute ? ret.base = ret.name = path2.slice(1, end) : ret.base = ret.name = path2.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path2.slice(1, startDot), ret.base = path2.slice(1, end)) : (ret.name = path2.slice(startPart, startDot), ret.base = path2.slice(startPart, end)), ret.ext = path2.slice(startDot, end)), ret.dir = this.dirname(path2), protocol && (ret.dir = protocol + ret.dir), ret;\n  },\n  sep: "/",\n  delimiter: ":",\n  joinExtensions: [".html"]\n};\n\n//# sourceMappingURL=path.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.mjs\n\nlet promise;\nasync function detectVideoAlphaMode() {\n  return promise ?? (promise = (async () => {\n    const gl = document.createElement("canvas").getContext("webgl");\n    if (!gl)\n      return ALPHA_MODES.UNPACK;\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement("video");\n      video2.onloadeddata = () => resolve(video2), video2.onerror = () => resolve(null), video2.autoplay = !1, video2.crossOrigin = "anonymous", video2.preload = "auto", video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", video2.load();\n    });\n    if (!video)\n      return ALPHA_MODES.UNPACK;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer), gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    ), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    return gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel), gl.deleteFramebuffer(framebuffer), gl.deleteTexture(texture), gl.getExtension("WEBGL_lose_context")?.loseContext(), pixel[0] <= pixel[3] ? ALPHA_MODES.PMA : ALPHA_MODES.UNPACK;\n  })()), promise;\n}\n\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/hello.mjs\n\nfunction skipHello() {\n  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");\n}\nfunction sayHello() {\n  deprecation("7.0.0", `sayHello is deprecated, please use Renderer\'s "hello" option`);\n}\n\n//# sourceMappingURL=hello.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs\n\n\nlet supported;\nfunction isWebGLSupported() {\n  return typeof supported > "u" && (supported = function() {\n    const contextOptions = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!settings.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      const canvas = settings.ADAPTER.createCanvas();\n      let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension("WEBGL_lose_context");\n        loseContext && loseContext.loseContext();\n      }\n      return gl = null, success;\n    } catch {\n      return !1;\n    }\n  }()), supported;\n}\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/Color.mjs\n\n\nk([names]);\nconst _Color = class _Color2 {\n  /**\n   * @param {PIXI.ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see PIXI.Color.value\n   */\n  setValue(value) {\n    return this.value = value, this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter\'s parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter\'s parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link PIXI.Color.multiply multiply},\n   *   {@link PIXI.Color.premultiply premultiply} or {@link PIXI.Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   * @type {PIXI.ColorSource}\n   */\n  set value(value) {\n    if (value instanceof _Color2)\n      this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);\n    else {\n      if (value === null)\n        throw new Error("Cannot set PIXI.Color#value to null");\n      (this._value === null || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  cloneSource(value) {\n    return typeof value == "string" || typeof value == "number" || value instanceof Number || value === null ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : typeof value == "object" && value !== null ? { ...value } : value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    if (type1 !== typeof value2)\n      return !1;\n    if (type1 === "number" || type1 === "string" || value1 instanceof Number)\n      return value1 === value2;\n    if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n      return value1.length !== value2.length ? !1 : value1.every((v, i) => v === value2[i]);\n    if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1), keys2 = Object.keys(value2);\n      return keys1.length !== keys2.length ? !1 : keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    return out = out ?? [], out[0] = Math.round(r * 255), out[1] = Math.round(g * 255), out[2] = Math.round(b * 255), out;\n  }\n  toRgbArray(out) {\n    out = out ?? [];\n    const [r, g, b] = this._components;\n    return out[0] = r, out[1] = g, out[2] = b, out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {PIXI.ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color2.temp.setValue(value)._components;\n    return this._components[0] *= r, this._components[1] *= g, this._components[2] *= b, this._components[3] *= a, this.refreshInt(), this._value = null, this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {PIXI.Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = !0) {\n    return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = !0) {\n    if (alpha === 1)\n      return (255 << 24) + this._int;\n    if (alpha === 0)\n      return applyToRGB ? 0 : this._int;\n    let r = this._int >> 16 & 255, g = this._int >> 8 & 255, b = this._int & 255;\n    return applyToRGB && (r = r * alpha + 0.5 | 0, g = g * alpha + 0.5 | 0, b = b * alpha + 0.5 | 0), (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHex(); // returns "#ffffff"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHexa(); // returns "#ffffffff"\n   */\n  toHexa() {\n    const alphaString = Math.round(this._components[3] * 255).toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    return this._components[3] = this._clamp(alpha), this;\n  }\n  /**\n   * Rounds the specified color according to the step. This action is destructive, and will\n   * override the previous `value` property to be `null`. The alpha component is not rounded.\n   * @param steps - Number of steps which will be used as a cap when rounding colors\n   * @deprecated since 7.3.0\n   */\n  round(steps) {\n    const [r, g, b] = this._components;\n    return this._components[0] = Math.round(r * steps) / steps, this._components[1] = Math.round(g * steps) / steps, this._components[2] = Math.round(b * steps) / steps, this.refreshInt(), this._value = null, this;\n  }\n  toArray(out) {\n    out = out ?? [];\n    const [r, g, b, a] = this._components;\n    return out[0] = r, out[1] = g, out[2] = b, out[3] = a, out;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  normalize(value) {\n    let r, g, b, a;\n    if ((typeof value == "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255, g = (int >> 8 & 255) / 255, b = (int & 255) / 255, a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4)\n      value = this._clamp(value), [r, g, b, a = 1] = value;\n    else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4)\n      value = this._clamp(value, 0, 255), [r, g, b, a = 255] = value, r /= 255, g /= 255, b /= 255, a /= 255;\n    else if (typeof value == "string" || typeof value == "object") {\n      if (typeof value == "string") {\n        const match = _Color2.HEX_PATTERN.exec(value);\n        match && (value = `#${match[2]}`);\n      }\n      const color = w(value);\n      color.isValid() && ({ r, g, b, a } = color.rgba, r /= 255, g /= 255, b /= 255);\n    }\n    if (r !== void 0)\n      this._components[0] = r, this._components[1] = g, this._components[2] = b, this._components[3] = a, this.refreshInt();\n    else\n      throw new Error(`Unable to convert color ${value}`);\n  }\n  /** Refresh the internal color rgb number */\n  refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    return typeof value == "number" ? Math.min(Math.max(value, min), max) : (value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    }), value);\n  }\n};\n_Color.shared = new _Color(), /**\n* Temporary Color object for static uses internally.\n* As to not conflict with Color.shared.\n* @ignore\n*/\n_Color.temp = new _Color(), /** Pattern for hex strings */\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color_Color = _Color;\n\n//# sourceMappingURL=Color.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/hex.mjs\n\n\nfunction hex2rgb(hex, out = []) {\n  return deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"), Color_Color.shared.setValue(hex).toRgbArray(out);\n}\nfunction hex2string(hex) {\n  return deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), Color_Color.shared.setValue(hex).toHex();\n}\nfunction string2hex(string) {\n  return deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"), Color_Color.shared.setValue(string).toNumber();\n}\nfunction rgb2hex(rgb) {\n  return deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), Color_Color.shared.setValue(rgb).toNumber();\n}\n\n//# sourceMappingURL=hex.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/premultiply.mjs\n\n\n\nfunction mapPremultipliedBlendModes() {\n  const pm = [], npm = [];\n  for (let i = 0; i < 32; i++)\n    pm[i] = i, npm[i] = i;\n  pm[lib_BLEND_MODES.NORMAL_NPM] = lib_BLEND_MODES.NORMAL, pm[lib_BLEND_MODES.ADD_NPM] = lib_BLEND_MODES.ADD, pm[lib_BLEND_MODES.SCREEN_NPM] = lib_BLEND_MODES.SCREEN, npm[lib_BLEND_MODES.NORMAL] = lib_BLEND_MODES.NORMAL_NPM, npm[lib_BLEND_MODES.ADD] = lib_BLEND_MODES.ADD_NPM, npm[lib_BLEND_MODES.SCREEN] = lib_BLEND_MODES.SCREEN_NPM;\n  const array = [];\n  return array.push(npm), array.push(pm), array;\n}\nconst premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply = !0) {\n  return deprecation("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"), Color_Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\nfunction premultiplyTint(tint, alpha) {\n  return deprecation("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"), Color_Color.shared.setValue(tint).toPremultiplied(alpha);\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply = !0) {\n  return deprecation("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"), Color_Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\n\n//# sourceMappingURL=premultiply.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/const.mjs\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (outBuffer = outBuffer || new Uint16Array(totalIndices), outBuffer.length !== totalIndices)\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    outBuffer[i + 0] = j + 0, outBuffer[i + 1] = j + 1, outBuffer[i + 2] = j + 2, outBuffer[i + 3] = j + 0, outBuffer[i + 4] = j + 2, outBuffer[i + 5] = j + 3;\n  return outBuffer;\n}\n\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/getBufferType.mjs\nfunction getBufferType(array) {\n  if (array.BYTES_PER_ELEMENT === 4)\n    return array instanceof Float32Array ? "Float32Array" : array instanceof Uint32Array ? "Uint32Array" : "Int32Array";\n  if (array.BYTES_PER_ELEMENT === 2) {\n    if (array instanceof Uint16Array)\n      return "Uint16Array";\n  } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array)\n    return "Uint8Array";\n  return null;\n}\n\n//# sourceMappingURL=getBufferType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs\n\nconst map = { Float32Array, Uint32Array, Int32Array, Uint8Array };\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0, stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++)\n    stride += sizes[i], outSize += arrays[i].length;\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null, littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i], array = arrays[i], type = getBufferType(array);\n    views[type] || (views[type] = new map[type](buffer)), out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset, index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n//# sourceMappingURL=interleaveTypedArrays.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/pow2.mjs\nfunction nextPow2(v) {\n  return v += v === 0 ? 1 : 0, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, v |= v >>> 16, v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  return v >>>= shift, r |= shift, shift = (v > 15 ? 1 : 0) << 2, v >>>= shift, r |= shift, shift = (v > 3 ? 1 : 0) << 1, v >>>= shift, r |= shift, r | v >> 1;\n}\n\n//# sourceMappingURL=pow2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/removeItems.mjs\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0)\n    return;\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i)\n    arr[i] = arr[i + removeCount];\n  arr.length = len;\n}\n\n//# sourceMappingURL=removeItems.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/sign.mjs\nfunction sign(n) {\n  return n === 0 ? 0 : n < 0 ? -1 : 1;\n}\n\n//# sourceMappingURL=sign.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/uid.mjs\nlet nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\n\n//# sourceMappingURL=uid.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/BoundingBox.mjs\nconst _BoundingBox = class {\n  /**\n   * @param left - The left coordinate value of the bounding box.\n   * @param top - The top coordinate value of the bounding box.\n   * @param right - The right coordinate value of the bounding box.\n   * @param bottom - The bottom coordinate value of the bounding box.\n   */\n  constructor(left, top, right, bottom) {\n    this.left = left, this.top = top, this.right = right, this.bottom = bottom;\n  }\n  /** The width of the bounding box. */\n  get width() {\n    return this.right - this.left;\n  }\n  /** The height of the bounding box. */\n  get height() {\n    return this.bottom - this.top;\n  }\n  /** Determines whether the BoundingBox is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n};\n_BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);\nlet BoundingBox = _BoundingBox;\n\n//# sourceMappingURL=BoundingBox.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/caches.mjs\nconst ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction destroyTextureCache() {\n  let key;\n  for (key in TextureCache)\n    TextureCache[key].destroy();\n  for (key in BaseTextureCache)\n    BaseTextureCache[key].destroy();\n}\nfunction clearTextureCache() {\n  let key;\n  for (key in TextureCache)\n    delete TextureCache[key];\n  for (key in BaseTextureCache)\n    delete BaseTextureCache[key];\n}\n\n//# sourceMappingURL=caches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs\n\nclass CanvasRenderTarget {\n  /**\n   * @param width - the width for the newly created canvas\n   * @param height - the height for the newly created canvas\n   * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas\n   */\n  constructor(width, height, resolution) {\n    this._canvas = settings.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = resolution || settings.RESOLUTION, this.resize(width, height);\n  }\n  /**\n   * Clears the canvas that was created by the CanvasRenderTarget class.\n   * @private\n   */\n  clear() {\n    this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n  }\n  /**\n   * Resizes the canvas to the specified width and height.\n   * @param desiredWidth - the desired width of the canvas\n   * @param desiredHeight - the desired height of the canvas\n   */\n  resize(desiredWidth, desiredHeight) {\n    this._checkDestroyed(), this._canvas.width = Math.round(desiredWidth * this.resolution), this._canvas.height = Math.round(desiredHeight * this.resolution);\n  }\n  /** Destroys this canvas. */\n  destroy() {\n    this._context = null, this._canvas = null;\n  }\n  /**\n   * The width of the canvas buffer in pixels.\n   * @member {number}\n   */\n  get width() {\n    return this._checkDestroyed(), this._canvas.width;\n  }\n  set width(val) {\n    this._checkDestroyed(), this._canvas.width = Math.round(val);\n  }\n  /**\n   * The height of the canvas buffer in pixels.\n   * @member {number}\n   */\n  get height() {\n    return this._checkDestroyed(), this._canvas.height;\n  }\n  set height(val) {\n    this._checkDestroyed(), this._canvas.height = Math.round(val);\n  }\n  /** The Canvas object that belongs to this CanvasRenderTarget. */\n  get canvas() {\n    return this._checkDestroyed(), this._canvas;\n  }\n  /** A CanvasRenderingContext2D object representing a two-dimensional rendering context. */\n  get context() {\n    return this._checkDestroyed(), this._context;\n  }\n  _checkDestroyed() {\n    if (this._canvas === null)\n      throw new TypeError("The CanvasRenderTarget has already been destroyed");\n  }\n}\n\n//# sourceMappingURL=CanvasRenderTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs\n\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    if (data[index + 3] !== 0)\n      return !1;\n  return !0;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride)\n    if (data[index + 3] !== 0)\n      return !1;\n  return !0;\n}\nfunction getCanvasBoundingBox(canvas) {\n  const { width, height } = canvas, context = canvas.getContext("2d", {\n    willReadFrequently: !0\n  });\n  if (context === null)\n    throw new TypeError("Failed to get canvas 2D context");\n  const data = context.getImageData(0, 0, width, height).data;\n  let left = 0, top = 0, right = width - 1, bottom = height - 1;\n  for (; top < height && checkRow(data, width, top); )\n    ++top;\n  if (top === height)\n    return BoundingBox.EMPTY;\n  for (; checkRow(data, width, bottom); )\n    --bottom;\n  for (; checkColumn(data, width, left, top, bottom); )\n    ++left;\n  for (; checkColumn(data, width, right, top, bottom); )\n    --right;\n  return ++right, ++bottom, new BoundingBox(left, top, right, bottom);\n}\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/trimCanvas.mjs\n\nfunction trimCanvas(canvas) {\n  const boundingBox = getCanvasBoundingBox(canvas), { width, height } = boundingBox;\n  let data = null;\n  if (!boundingBox.isEmpty()) {\n    const context = canvas.getContext("2d");\n    if (context === null)\n      throw new TypeError("Failed to get canvas 2D context");\n    data = context.getImageData(\n      boundingBox.left,\n      boundingBox.top,\n      width,\n      height\n    );\n  }\n  return { width, height, data };\n}\n\n//# sourceMappingURL=trimCanvas.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs\n\nfunction decomposeDataUri(dataUri) {\n  const dataUriMatch = DATA_URI.exec(dataUri);\n  if (dataUriMatch)\n    return {\n      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,\n      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,\n      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,\n      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,\n      data: dataUriMatch[5]\n    };\n}\n\n//# sourceMappingURL=decomposeDataUri.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith("data:"))\n    return "";\n  loc = loc || globalThis.location;\n  const parsedUrl = new URL(url, document.baseURI);\n  return parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol ? "anonymous" : "";\n}\n\n//# sourceMappingURL=determineCrossOrigin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs\n\n\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = settings.RETINA_PREFIX?.exec(url);\n  return resolution ? parseFloat(resolution[1]) : defaultValue;\n}\n\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extensions/lib/index.mjs\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => (ExtensionType2.Renderer = "renderer", ExtensionType2.Application = "application", ExtensionType2.RendererSystem = "renderer-webgl-system", ExtensionType2.RendererPlugin = "renderer-webgl-plugin", ExtensionType2.CanvasRendererSystem = "renderer-canvas-system", ExtensionType2.CanvasRendererPlugin = "renderer-canvas-plugin", ExtensionType2.Asset = "asset", ExtensionType2.LoadParser = "load-parser", ExtensionType2.ResolveParser = "resolve-parser", ExtensionType2.CacheParser = "cache-parser", ExtensionType2.DetectionParser = "detection-parser", ExtensionType2))(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext == "function" || typeof ext == "object" && ext.extension) {\n    if (!ext.extension)\n      throw new Error("Extension class must have an extension object");\n    ext = { ...typeof ext.extension != "object" ? { type: ext.extension } : ext.extension, ref: ext };\n  }\n  if (typeof ext == "object")\n    ext = { ...ext };\n  else\n    throw new Error("Invalid extension type");\n  return typeof ext.type == "string" && (ext.type = [ext.type]), ext;\n}, normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority, extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  remove(...extensions2) {\n    return extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    }), this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  add(...extensions2) {\n    return extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers, queue = this._queue;\n        handlers[type] ? handlers[type](ext) : (queue[type] = queue[type] || [], queue[type].push(ext));\n      });\n    }), this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.\n   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type])\n      throw new Error(`Extension type ${type} already has a handler`);\n    addHandlers[type] = onAdd, removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    return queue[type] && (queue[type].forEach((ext) => onAdd(ext)), delete queue[type]), this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        map[extension.name] = extension.ref;\n      },\n      (extension) => {\n        delete map[extension.name];\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        list.includes(extension.ref) || (list.push(extension.ref), list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority)));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        index !== -1 && list.splice(index, 1);\n      }\n    );\n  }\n};\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    typeof sizeOrBuffer == "number" ? this.rawBinaryData = new ArrayBuffer(sizeOrBuffer) : sizeOrBuffer instanceof Uint8Array ? this.rawBinaryData = sizeOrBuffer.buffer : this.rawBinaryData = sizeOrBuffer, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n  }\n  /** View on the raw binary data as a `Uint16Array`. */\n  get uint16View() {\n    return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n  }\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs\nconst fragTemplate = [\n  "precision mediump float;",\n  "void main(void){",\n  "float test = 0.1;",\n  "%forloop%",\n  "gl_FragColor = vec4(0.0);",\n  "}"\n].join(`\n`);\nfunction generateIfTestSrc(maxIfs) {\n  let src = "";\n  for (let i = 0; i < maxIfs; ++i)\n    i > 0 && (src += `\nelse `), i < maxIfs - 1 && (src += `if(test == ${i}.0){}`);\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0)\n    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  for (; ; ) {\n    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n    if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n      maxIfs = maxIfs / 2 | 0;\n    else\n      break;\n  }\n  return maxIfs;\n}\n\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/State.mjs\n\nconst BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5;\nclass State {\n  constructor() {\n    this.data = 0, this.blendMode = lib_BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    !!(this.data & 1 << BLEND) !== value && (this.data ^= 1 << BLEND);\n  }\n  /**\n   * Activates adding an offset to depth values of polygon\'s fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    !!(this.data & 1 << OFFSET) !== value && (this.data ^= 1 << OFFSET);\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    !!(this.data & 1 << CULLING) !== value && (this.data ^= 1 << CULLING);\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    !!(this.data & 1 << DEPTH_TEST) !== value && (this.data ^= 1 << DEPTH_TEST);\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    !!(this.data & 1 << DEPTH_MASK) !== value && (this.data ^= 1 << DEPTH_MASK);\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    !!(this.data & 1 << WINDING) !== value && (this.data ^= 1 << WINDING);\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== lib_BLEND_MODES.NONE, this._blendMode = value;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value, this._polygonOffset = value;\n  }\n  static for2d() {\n    const state = new State();\n    return state.depthTest = !1, state.blend = !0, state;\n  }\n}\nState.prototype.toString = function() {\n  return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n};\n\n//# sourceMappingURL=State.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs\nconst INSTALLED = [];\nfunction autoDetectResource(source, options) {\n  if (!source)\n    return null;\n  let extension = "";\n  if (typeof source == "string") {\n    const result = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(source);\n    result && (extension = result[1].toLowerCase());\n  }\n  for (let i = INSTALLED.length - 1; i >= 0; --i) {\n    const ResourcePlugin = INSTALLED[i];\n    if (ResourcePlugin.test && ResourcePlugin.test(source, extension))\n      return new ResourcePlugin(source, options);\n  }\n  throw new Error("Unrecognized source type to auto-detect Resource");\n}\n\n//# sourceMappingURL=autoDetectResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/Runner.mjs\nclass Runner_Runner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [], this._name = name, this._aliasCount = 0;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    if (arguments.length > 8)\n      throw new Error("max arguments reached");\n    const { name, items } = this;\n    this._aliasCount++;\n    for (let i = 0, len = items.length; i < len; i++)\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    return items === this.items && this._aliasCount--, this;\n  }\n  ensureNonAliasedItems() {\n    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * E.g. A listener passed to this Runner will require a \'complete\' function.\n   *\n   * ```js\n   * import { Runner } from \'@pixi/runner\';\n   *\n   * const complete = new Runner(\'complete\');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    return item[this._name] && (this.ensureNonAliasedItems(), this.remove(item), this.items.push(item)), this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    return index !== -1 && (this.ensureNonAliasedItems(), this.items.splice(index, 1)), this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.includes(item);\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    return this.ensureNonAliasedItems(), this.items.length = 0, this;\n  }\n  /** Remove all references, don\'t use after this. */\n  destroy() {\n    this.removeAll(), this.items = null, this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\nObject.defineProperties(Runner_Runner.prototype, {\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method dispatch\n   * @see PIXI.Runner#emit\n   */\n  dispatch: { value: Runner_Runner.prototype.emit },\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method run\n   * @see PIXI.Runner#emit\n   */\n  run: { value: Runner_Runner.prototype.emit }\n});\n\n//# sourceMappingURL=Runner.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/Resource.mjs\n\nclass Resource {\n  /**\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   */\n  constructor(width = 0, height = 0) {\n    this._width = width, this._height = height, this.destroyed = !1, this.internal = !1, this.onResize = new Runner_Runner("setRealSize"), this.onUpdate = new Runner_Runner("update"), this.onError = new Runner_Runner("onError");\n  }\n  /**\n   * Bind to a parent BaseTexture\n   * @param baseTexture - Parent texture\n   */\n  bind(baseTexture) {\n    this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), this.onError.add(baseTexture), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n  }\n  /**\n   * Unbind to a parent BaseTexture\n   * @param baseTexture - Parent texture\n   */\n  unbind(baseTexture) {\n    this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture), this.onError.remove(baseTexture);\n  }\n  /**\n   * Trigger a resize event\n   * @param width - X dimension\n   * @param height - Y dimension\n   */\n  resize(width, height) {\n    (width !== this._width || height !== this._height) && (this._width = width, this._height = height, this.onResize.emit(width, height));\n  }\n  /**\n   * Has been validated\n   * @readonly\n   */\n  get valid() {\n    return !!this._width && !!this._height;\n  }\n  /** Has been updated trigger event. */\n  update() {\n    this.destroyed || this.onUpdate.emit();\n  }\n  /**\n   * This can be overridden to start preloading a resource\n   * or do any other prepare step.\n   * @protected\n   * @returns Handle the validate event\n   */\n  load() {\n    return Promise.resolve(this);\n  }\n  /**\n   * The width of the resource.\n   * @readonly\n   */\n  get width() {\n    return this._width;\n  }\n  /**\n   * The height of the resource.\n   * @readonly\n   */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Set the style, optional to override\n   * @param _renderer - yeah, renderer!\n   * @param _baseTexture - the texture\n   * @param _glTexture - texture instance for this webgl context\n   * @returns - `true` is success\n   */\n  style(_renderer, _baseTexture, _glTexture) {\n    return !1;\n  }\n  /** Clean up anything, this happens when destroying is ready. */\n  dispose() {\n  }\n  /**\n   * Call when destroying resource, unbind any BaseTexture object\n   * before calling this method, as reference counts are maintained\n   * internally.\n   */\n  destroy() {\n    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n  }\n  /**\n   * Abstract, used to auto-detect resource type.\n   * @param {*} _source - The source object\n   * @param {string} _extension - The extension of source, if set\n   */\n  static test(_source, _extension) {\n    return !1;\n  }\n}\n\n//# sourceMappingURL=Resource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs\n\n\nclass BufferResource extends Resource {\n  /**\n   * @param source - Source buffer\n   * @param options - Options\n   * @param {number} options.width - Width of the texture\n   * @param {number} options.height - Height of the texture\n   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.\n   */\n  constructor(source, options) {\n    const { width, height } = options || {};\n    if (!width || !height)\n      throw new Error("BufferResource width or height invalid");\n    super(width, height), this.data = source, this.unpackAlignment = options.unpackAlignment ?? 4;\n  }\n  /**\n   * Upload the texture to the GPU.\n   * @param renderer - Upload to the renderer\n   * @param baseTexture - Reference to parent texture\n   * @param glTexture - glTexture\n   * @returns - true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    const gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);\n    const width = baseTexture.realWidth, height = baseTexture.realHeight;\n    return glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(\n      baseTexture.target,\n      0,\n      0,\n      0,\n      width,\n      height,\n      baseTexture.format,\n      glTexture.type,\n      this.data\n    ) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(\n      baseTexture.target,\n      0,\n      glTexture.internalFormat,\n      width,\n      height,\n      0,\n      baseTexture.format,\n      glTexture.type,\n      this.data\n    )), !0;\n  }\n  /** Destroy and don\'t use after this. */\n  dispose() {\n    this.data = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if buffer source\n   */\n  static test(source) {\n    return source === null || source instanceof Int8Array || source instanceof Uint8Array || source instanceof Uint8ClampedArray || source instanceof Int16Array || source instanceof Uint16Array || source instanceof Int32Array || source instanceof Uint32Array || source instanceof Float32Array;\n  }\n}\n\n//# sourceMappingURL=BufferResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/BaseTexture.mjs\n\n\n\n\n\n\nconst defaultBufferOptions = {\n  scaleMode: SCALE_MODES.NEAREST,\n  alphaMode: ALPHA_MODES.NPM\n}, _BaseTexture = class _BaseTexture2 extends eventemitter3 {\n  /**\n   * @param {PIXI.Resource|HTMLImageElement|HTMLVideoElement|ImageBitmap|ICanvas|string} [resource=null] -\n   *        The current resource to use, for things that aren\'t Resource objects, will be converted\n   *        into a Resource.\n   * @param options - Collection of options, default options inherited from {@link PIXI.BaseTexture.defaultOptions}.\n   * @param {PIXI.MIPMAP_MODES} [options.mipmap] - If mipmapping is enabled for texture\n   * @param {number} [options.anisotropicLevel] - Anisotropic filtering level of texture\n   * @param {PIXI.WRAP_MODES} [options.wrapMode] - Wrap mode for textures\n   * @param {PIXI.SCALE_MODES} [options.scaleMode] - Default scale mode, linear, nearest\n   * @param {PIXI.FORMATS} [options.format] - GL format type\n   * @param {PIXI.TYPES} [options.type] - GL data type\n   * @param {PIXI.TARGETS} [options.target] - GL texture target\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode] - Pre multiply the image alpha\n   * @param {number} [options.width=0] - Width of the texture\n   * @param {number} [options.height=0] - Height of the texture\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture\n   * @param {object} [options.resourceOptions] - Optional resource options,\n   *        see {@link PIXI.autoDetectResource autoDetectResource}\n   */\n  constructor(resource = null, options = null) {\n    super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);\n    const {\n      alphaMode,\n      mipmap,\n      anisotropicLevel,\n      scaleMode,\n      width,\n      height,\n      wrapMode,\n      format,\n      type,\n      target,\n      resolution,\n      resourceOptions\n    } = options;\n    resource && !(resource instanceof Resource) && (resource = autoDetectResource(resource, resourceOptions), resource.internal = !0), this.resolution = resolution || settings.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format, this.type = type, this.target = target, this.alphaMode = alphaMode, this.uid = uid(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);\n  }\n  /**\n   * Pixel width of the source of this texture\n   * @readonly\n   */\n  get realWidth() {\n    return Math.round(this.width * this.resolution);\n  }\n  /**\n   * Pixel height of the source of this texture\n   * @readonly\n   */\n  get realHeight() {\n    return Math.round(this.height * this.resolution);\n  }\n  /**\n   * Mipmap mode of the texture, affects downscaled images\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  get mipmap() {\n    return this._mipmap;\n  }\n  set mipmap(value) {\n    this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);\n  }\n  /**\n   * The scale mode to apply when scaling this texture\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  get scaleMode() {\n    return this._scaleMode;\n  }\n  set scaleMode(value) {\n    this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);\n  }\n  /**\n   * How the texture wraps\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  get wrapMode() {\n    return this._wrapMode;\n  }\n  set wrapMode(value) {\n    this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);\n  }\n  /**\n   * Changes style options of BaseTexture\n   * @param scaleMode - Pixi scalemode\n   * @param mipmap - enable mipmaps\n   * @returns - this\n   */\n  setStyle(scaleMode, mipmap) {\n    let dirty;\n    return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = !0), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = !0), dirty && this.dirtyStyleId++, this;\n  }\n  /**\n   * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.\n   * @param desiredWidth - Desired visual width\n   * @param desiredHeight - Desired visual height\n   * @param resolution - Optionally set resolution\n   * @returns - this\n   */\n  setSize(desiredWidth, desiredHeight, resolution) {\n    return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n  }\n  /**\n   * Sets real size of baseTexture, preserves current resolution.\n   * @param realWidth - Full rendered width\n   * @param realHeight - Full rendered height\n   * @param resolution - Optionally set resolution\n   * @returns - this\n   */\n  setRealSize(realWidth, realHeight, resolution) {\n    return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n  }\n  /**\n   * Changes resolution\n   * @param resolution - res\n   * @returns - this\n   */\n  setResolution(resolution) {\n    const oldResolution = this.resolution;\n    return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit("update", this)), this._refreshPOT(), this);\n  }\n  /**\n   * Sets the resource if it wasn\'t set. Throws error if resource already present\n   * @param resource - that is managing this BaseTexture\n   * @returns - this\n   */\n  setResource(resource) {\n    if (this.resource === resource)\n      return this;\n    if (this.resource)\n      throw new Error("Resource can be set only once");\n    return resource.bind(this), this.resource = resource, this;\n  }\n  /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */\n  update() {\n    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));\n  }\n  /**\n   * Handle errors with resources.\n   * @private\n   * @param event - Error event emitted.\n   */\n  onError(event) {\n    this.emit("error", this, event);\n  }\n  /**\n   * Destroys this base texture.\n   * The method stops if resource doesn\'t want this texture to be destroyed.\n   * Removes texture from all caches.\n   * @fires PIXI.BaseTexture#destroyed\n   */\n  destroy() {\n    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.valid = !1, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit("destroyed", this), this.removeAllListeners();\n  }\n  /**\n   * Frees the texture from WebGL memory without destroying this texture object.\n   * This means you can still use the texture later which will upload it to GPU\n   * memory again.\n   * @fires PIXI.BaseTexture#dispose\n   */\n  dispose() {\n    this.emit("dispose", this);\n  }\n  /** Utility function for BaseTexture|Texture cast. */\n  castToBaseTexture() {\n    return this;\n  }\n  /**\n   * Helper function that creates a base texture based on the source you provide.\n   * The source can be - image url, image element, canvas element. If the\n   * source is an image url or an image element and not in the base texture\n   * cache, it will be created and loaded.\n   * @static\n   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string|string[]} source - The\n   *        source to create base texture from.\n   * @param options - See {@link PIXI.BaseTexture}\'s constructor for options.\n   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n   * @returns {PIXI.BaseTexture} The new base texture.\n   */\n  static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source == "string";\n    let cacheId = null;\n    if (isFrame)\n      cacheId = source;\n    else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source._pixiId = `${prefix}_${uid()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let baseTexture = BaseTextureCache[cacheId];\n    if (isFrame && strict && !baseTexture)\n      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);\n    return baseTexture || (baseTexture = new _BaseTexture2(source, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;\n  }\n  /**\n   * Create a new Texture with a BufferResource from a typed array.\n   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   * @param options - See {@link PIXI.BaseTexture}\'s constructor for options.\n   *        Default properties are different from the constructor\'s defaults.\n   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the\n   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,\n   *        otherwise `RGBA_INTEGER`.\n   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the\n   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to\n   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,\n   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]\n   * @returns - The resulting new BaseTexture\n   */\n  static fromBuffer(buffer, width, height, options) {\n    buffer = buffer || new Float32Array(width * height * 4);\n    const resource = new BufferResource(buffer, { width, height, ...options?.resourceOptions });\n    let format, type;\n    return buffer instanceof Float32Array ? (format = FORMATS.RGBA, type = TYPES.FLOAT) : buffer instanceof Int32Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.INT) : buffer instanceof Uint32Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.SHORT) : buffer instanceof Uint16Array ? (format = FORMATS.RGBA_INTEGER, type = TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format = FORMATS.RGBA, type = TYPES.BYTE) : (format = FORMATS.RGBA, type = TYPES.UNSIGNED_BYTE), resource.internal = !0, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type, format }, options));\n  }\n  /**\n   * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.\n   * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.\n   * @param {string} id - The id that the BaseTexture will be stored against.\n   */\n  static addToCache(baseTexture, id) {\n    id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), BaseTextureCache[id] = baseTexture);\n  }\n  /**\n   * Remove a BaseTexture from the global BaseTextureCache.\n   * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.\n   * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.\n   */\n  static removeFromCache(baseTexture) {\n    if (typeof baseTexture == "string") {\n      const baseTextureFromCache = BaseTextureCache[baseTexture];\n      if (baseTextureFromCache) {\n        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n        return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete BaseTextureCache[baseTexture], baseTextureFromCache;\n      }\n    } else if (baseTexture?.textureCacheIds) {\n      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)\n        delete BaseTextureCache[baseTexture.textureCacheIds[i]];\n      return baseTexture.textureCacheIds.length = 0, baseTexture;\n    }\n    return null;\n  }\n};\n_BaseTexture.defaultOptions = {\n  /**\n   * If mipmapping is enabled for texture.\n   * @type {PIXI.MIPMAP_MODES}\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  mipmap: MIPMAP_MODES.POW2,\n  /** Anisotropic filtering level of texture */\n  anisotropicLevel: 0,\n  /**\n   * Default scale mode, linear, nearest.\n   * @type {PIXI.SCALE_MODES}\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  scaleMode: SCALE_MODES.LINEAR,\n  /**\n   * Wrap mode for textures.\n   * @type {PIXI.WRAP_MODES}\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  wrapMode: lib_WRAP_MODES.CLAMP,\n  /**\n   * Pre multiply the image alpha\n   * @type {PIXI.ALPHA_MODES}\n   * @default PIXI.ALPHA_MODES.UNPACK\n   */\n  alphaMode: ALPHA_MODES.UNPACK,\n  /**\n   * GL texture target\n   * @type {PIXI.TARGETS}\n   * @default PIXI.TARGETS.TEXTURE_2D\n   */\n  target: TARGETS.TEXTURE_2D,\n  /**\n   * GL format type\n   * @type {PIXI.FORMATS}\n   * @default PIXI.FORMATS.RGBA\n   */\n  format: FORMATS.RGBA,\n  /**\n   * GL data type\n   * @type {PIXI.TYPES}\n   * @default PIXI.TYPES.UNSIGNED_BYTE\n   */\n  type: TYPES.UNSIGNED_BYTE\n}, /** Global number of the texture batch, used by multi-texture renderers. */\n_BaseTexture._globalBatch = 0;\nlet BaseTexture = _BaseTexture;\n\n//# sourceMappingURL=BaseTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs\n\nclass BatchDrawCall {\n  constructor() {\n    this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n  }\n}\n\n//# sourceMappingURL=BatchDrawCall.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Buffer.mjs\n\n\nlet UID = 0;\nclass Buffer {\n  /**\n   * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.\n   * @param _static - `true` for static buffer\n   * @param index - `true` for index buffer\n   */\n  constructor(data, _static = !0, index = !1) {\n    this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID++, this.disposeRunner = new Runner_Runner("disposeBuffer");\n  }\n  // TODO could explore flagging only a partial upload?\n  /**\n   * Flags this buffer as requiring an upload to the GPU.\n   * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.\n   */\n  update(data) {\n    data instanceof Array && (data = new Float32Array(data)), this.data = data || this.data, this._updateID++;\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys the buffer. */\n  destroy() {\n    this.dispose(), this.data = null;\n  }\n  /**\n   * Flags whether this is an index buffer.\n   *\n   * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make\n   * the buffer of type `ARRAY_BUFFER`.\n   *\n   * For backwards compatibility.\n   */\n  set index(value) {\n    this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;\n  }\n  get index() {\n    return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n  }\n  /**\n   * Helper function that creates a buffer based on an array or TypedArray\n   * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.\n   * @returns - A new Buffer based on the data provided.\n   */\n  static from(data) {\n    return data instanceof Array && (data = new Float32Array(data)), new Buffer(data);\n  }\n}\n\n//# sourceMappingURL=Buffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Attribute.mjs\n\nclass Attribute {\n  /**\n   * @param buffer - the id of the buffer that this attribute will look for\n   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.\n   * @param normalized - should the data be normalized.\n   * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n   * @param [instance=false] - Whether the geometry is instanced.\n   * @param [divisor=1] - Divisor to use when doing instanced rendering\n   */\n  constructor(buffer, size = 0, normalized = !1, type = TYPES.FLOAT, stride, start, instance, divisor = 1) {\n    this.buffer = buffer, this.size = size, this.normalized = normalized, this.type = type, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;\n  }\n  /** Destroys the Attribute. */\n  destroy() {\n    this.buffer = null;\n  }\n  /**\n   * Helper function that creates an Attribute based on the information provided\n   * @param buffer - the id of the buffer that this attribute will look for\n   * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n   * @param [normalized=false] - should the data be normalized.\n   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @returns - A new {@link PIXI.Attribute} based on the information provided\n   */\n  static from(buffer, size, normalized, type, stride) {\n    return new Attribute(buffer, size, normalized, type, stride);\n  }\n}\n\n//# sourceMappingURL=Attribute.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs\n\nconst interleaveTypedArrays_map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays_interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0, stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++)\n    stride += sizes[i], outSize += arrays[i].length;\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null, littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i], array = arrays[i], type = getBufferType(array);\n    views[type] || (views[type] = new interleaveTypedArrays_map[type](buffer)), out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset, index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n//# sourceMappingURL=interleaveTypedArrays.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Geometry.mjs\n\n\n\n\n\n\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet Geometry_UID = 0;\nconst Geometry_map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n};\nclass Geometry {\n  /**\n   * @param buffers - An array of buffers. optional.\n   * @param attributes - Of the geometry, optional structure of the attributes layout\n   */\n  constructor(buffers = [], attributes = {}) {\n    this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = Geometry_UID++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner_Runner("disposeGeometry"), this.refCount = 0;\n  }\n  /**\n   *\n   * Adds an attribute to the geometry\n   * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!\n   * @param id - the name of the attribute (matching up to a shader)\n   * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.\n   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n   * @param normalized - should the data be normalized.\n   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n   * @param instance - Instancing flag\n   * @returns - Returns self, useful for chaining.\n   */\n  addAttribute(id, buffer, size = 0, normalized = !1, type, stride, start, instance = !1) {\n    if (!buffer)\n      throw new Error("You must pass a buffer when creating an attribute");\n    buffer instanceof Buffer || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer(buffer));\n    const ids = id.split("|");\n    if (ids.length > 1) {\n      for (let i = 0; i < ids.length; i++)\n        this.addAttribute(ids[i], buffer, size, normalized, type);\n      return this;\n    }\n    let bufferIndex = this.buffers.indexOf(buffer);\n    return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this;\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.buffers[this.getAttribute(id).buffer];\n  }\n  /**\n   *\n   * Adds an index buffer to the geometry\n   * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.\n   * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.\n   * @returns - Returns self, useful for chaining.\n   */\n  addIndex(buffer) {\n    return buffer instanceof Buffer || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer(buffer)), buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * This function modifies the structure so that all current attributes become interleaved into a single buffer\n   * This can be useful if your model remains static as it offers a little performance boost\n   * @returns - Returns self, useful for chaining.\n   */\n  interleave() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    const arrays = [], sizes = [], interleavedBuffer = new Buffer();\n    let i;\n    for (i in this.attributes) {\n      const attribute = this.attributes[i], buffer = this.buffers[attribute.buffer];\n      arrays.push(buffer.data), sizes.push(attribute.size * byteSizeMap[attribute.type] / 4), attribute.buffer = 0;\n    }\n    for (interleavedBuffer.data = interleaveTypedArrays_interleaveTypedArrays(arrays, sizes), i = 0; i < this.buffers.length; i++)\n      this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();\n    return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n  }\n  /** Get the size of the geometries, in vertices. */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys the geometry. */\n  destroy() {\n    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n  }\n  /**\n   * Returns a clone of the geometry.\n   * @returns - A new clone of this geometry.\n   */\n  clone() {\n    const geometry = new Geometry();\n    for (let i = 0; i < this.buffers.length; i++)\n      geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));\n    for (const i in this.attributes) {\n      const attrib = this.attributes[i];\n      geometry.attributes[i] = new Attribute(\n        attrib.buffer,\n        attrib.size,\n        attrib.normalized,\n        attrib.type,\n        attrib.stride,\n        attrib.start,\n        attrib.instance\n      );\n    }\n    return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;\n  }\n  /**\n   * Merges an array of geometries into a new single one.\n   *\n   * Geometry attribute styles must match for this operation to work.\n   * @param geometries - array of geometries to merge\n   * @returns - Shiny new geometry!\n   */\n  static merge(geometries) {\n    const geometryOut = new Geometry(), arrays = [], sizes = [], offsets = [];\n    let geometry;\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++)\n        sizes[j] = sizes[j] || 0, sizes[j] += geometry.buffers[j].data.length, offsets[j] = 0;\n    }\n    for (let i = 0; i < geometry.buffers.length; i++)\n      arrays[i] = new Geometry_map[getBufferType(geometry.buffers[i].data)](sizes[i]), geometryOut.buffers[i] = new Buffer(arrays[i]);\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++)\n        arrays[j].set(geometry.buffers[j].data, offsets[j]), offsets[j] += geometry.buffers[j].data.length;\n    }\n    if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {\n      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      let offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0;\n      for (let i = 0; i < geometry.buffers.length; i++)\n        if (geometry.buffers[i] !== geometry.indexBuffer) {\n          bufferIndexToCount = i;\n          break;\n        }\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap[attribute.type] / 4);\n      }\n      for (let i = 0; i < geometries.length; i++) {\n        const indexBufferData = geometries[i].indexBuffer.data;\n        for (let j = 0; j < indexBufferData.length; j++)\n          geometryOut.indexBuffer.data[j + offset2] += offset;\n        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length;\n      }\n    }\n    return geometryOut;\n  }\n}\n\n//# sourceMappingURL=Geometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs\n\n\n\nclass BatchGeometry extends Geometry {\n  /**\n   * @param {boolean} [_static=false] - Optimization flag, where `false`\n   *        is updated every frame, `true` doesn\'t change frame-to-frame.\n   */\n  constructor(_static = !1) {\n    super(), this._buffer = new Buffer(null, _static, !1), this._indexBuffer = new Buffer(null, _static, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, !0, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, TYPES.FLOAT).addIndex(this._indexBuffer);\n  }\n}\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/const.mjs\nconst PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180;\nvar SHAPES = /* @__PURE__ */ ((SHAPES2) => (SHAPES2[SHAPES2.POLY = 0] = "POLY", SHAPES2[SHAPES2.RECT = 1] = "RECT", SHAPES2[SHAPES2.CIRC = 2] = "CIRC", SHAPES2[SHAPES2.ELIP = 3] = "ELIP", SHAPES2[SHAPES2.RREC = 4] = "RREC", SHAPES2))(SHAPES || {});\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Point.mjs\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    this.x = 0, this.y = 0, this.x = x, this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    return this.set(p.x, p.y), this;\n  }\n  /**\n   * Copies this point\'s x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    return p.set(this.x, this.y), p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    return this.x = x, this.y = y, this;\n  }\n}\nPoint.prototype.toString = function() {\n  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;\n};\n\n//# sourceMappingURL=Point.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Rectangle.mjs\n\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle_Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = Number(x), this.y = Number(y), this.width = Number(width), this.height = Number(height), this.type = SHAPES.RECT;\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** A constant empty rectangle. */\n  static get EMPTY() {\n    return new Rectangle_Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle_Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    return this.width <= 0 || this.height <= 0 ? !1 : x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can\'t intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      if ((this.right > other.right ? other.right : this.right) <= x02)\n        return !1;\n      const y02 = this.y < other.y ? other.y : this.y;\n      return (this.bottom > other.bottom ? other.bottom : this.bottom) > y02;\n    }\n    const x0 = this.left, x1 = this.right, y0 = this.top, y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0)\n      return !1;\n    const lt = tempPoints[0].set(other.left, other.top), lb = tempPoints[1].set(other.left, other.bottom), rt = tempPoints[2].set(other.right, other.top), rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y)\n      return !1;\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0 || (transform.apply(lt, lt), transform.apply(lb, lb), transform.apply(rt, rt), transform.apply(rb, rb), Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1))\n      return !1;\n    const nx = s * (lb.y - lt.y), ny = s * (lt.x - lb.x), n00 = nx * x0 + ny * y0, n10 = nx * x1 + ny * y0, n01 = nx * x0 + ny * y1, n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y)\n      return !1;\n    const mx = s * (lt.y - rt.y), my = s * (rt.x - lt.x), m00 = mx * x0 + my * y0, m10 = mx * x1 + my * y0, m01 = mx * x0 + my * y1, m11 = mx * x1 + my * y1;\n    return !(Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y);\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    return this.x -= paddingX, this.y -= paddingY, this.width += paddingX * 2, this.height += paddingY * 2, this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y), y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    return this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0), this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y, this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y), y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    return this.x = x1, this.width = x2 - x1, this.y = y1, this.height = y2 - y1, this;\n  }\n}\nRectangle_Rectangle.prototype.toString = function() {\n  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n};\n\n//# sourceMappingURL=Rectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Circle.mjs\n\n\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    this.x = x, this.y = y, this.radius = radius, this.type = SHAPES.CIRC;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return !1;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x, dy = this.y - y;\n    return dx *= dx, dy *= dy, dx + dy <= r2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle_Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }\n}\nCircle.prototype.toString = function() {\n  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n};\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Ellipse.mjs\n\n\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    this.x = x, this.y = y, this.width = halfWidth, this.height = halfHeight, this.type = SHAPES.ELIP;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {PIXI.Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    let normx = (x - this.x) / this.width, normy = (y - this.y) / this.height;\n    return normx *= normx, normy *= normy, normx + normy <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle_Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }\n}\nEllipse.prototype.toString = function() {\n  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n};\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Polygon.mjs\n\nclass Polygon {\n  /**\n   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] != "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++)\n        p.push(flat[i].x, flat[i].y);\n      flat = p;\n    }\n    this.points = flat, this.type = SHAPES.POLY, this.closeStroke = !0;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice(), polygon = new Polygon(points);\n    return polygon.closeStroke = this.closeStroke, polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = !1;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2], yi = this.points[i * 2 + 1], xj = this.points[j * 2], yj = this.points[j * 2 + 1];\n      yi > y != yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi && (inside = !inside);\n    }\n    return inside;\n  }\n}\nPolygon.prototype.toString = function() {\n  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n};\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs\n\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    this.x = x, this.y = y, this.width = width, this.height = height, this.radius = radius, this.type = SHAPES.RREC;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    if (x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height) {\n      const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n      if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius)\n        return !0;\n      let dx = x - (this.x + radius), dy = y - (this.y + radius);\n      const radius2 = radius * radius;\n      if (dx * dx + dy * dy <= radius2 || (dx = x - (this.x + this.width - radius), dx * dx + dy * dy <= radius2) || (dy = y - (this.y + this.height - radius), dx * dx + dy * dy <= radius2) || (dx = x - (this.x + radius), dx * dx + dy * dy <= radius2))\n        return !0;\n    }\n    return !1;\n  }\n}\nRoundedRectangle.prototype.toString = function() {\n  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n};\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Matrix.mjs\n\n\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    this.array = null, this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    this.array || (this.array = new Float32Array(9));\n    const array = out || this.array;\n    return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0, array[8] = 1), array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child\'s coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {PIXI.Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x, y = pos.y;\n    return newPos.x = this.a * x + this.c * y + this.tx, newPos.y = this.b * x + this.d * y + this.ty, newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child\'s coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const id = 1 / (this.a * this.d + this.c * -this.b), x = pos.x, y = pos.y;\n    return newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id, newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    return this.tx += x, this.ty += y, this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;\n    return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;\n    return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x - (pivotX * this.a + pivotY * this.c), this.ty = y - (pivotX * this.b + pivotY * this.d), this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a, c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a, b = this.b, c = this.c, d = this.d, pivot = transform.pivot, skewX = -Math.atan2(-c, d), skewY = Math.atan2(b, a), delta = Math.abs(skewX + skewY);\n    return delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5 ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY), transform.scale.x = Math.sqrt(a * a + b * b), transform.scale.y = Math.sqrt(c * c + d * d), transform.position.x = this.tx + (pivot.x * a + pivot.y * c), transform.position.y = this.ty + (pivot.x * b + pivot.y * d), transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1;\n    return this.a = d1 / n, this.b = -b1 / n, this.c = -c1 / n, this.d = a1 / n, this.tx = (c1 * this.ty - d1 * tx1) / n, this.ty = -(a1 * this.ty - b1 * tx1) / n, this;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param {PIXI.Matrix} matrix - The matrix to copy from.\n   * @returns {PIXI.Matrix} this\n   */\n  copyFrom(matrix) {\n    return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;\n  }\n  /**\n   * A default (identity) matrix\n   * @readonly\n   */\n  static get IDENTITY() {\n    return new Matrix();\n  }\n  /**\n   * A temp matrix\n   * @readonly\n   */\n  static get TEMP_MATRIX() {\n    return new Matrix();\n  }\n}\nMatrix.prototype.toString = function() {\n  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n};\n\n//# sourceMappingURL=Matrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/groupD8.mjs\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]), _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]), _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]), _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++)\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0), rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @readonly\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @readonly\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @readonly\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @readonly\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @readonly\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @readonly\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @readonly\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @readonly\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @readonly\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @readonly\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @readonly\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @readonly\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don\'t.\n   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => rotation & 8 ? rotation & 15 : -rotation & 7,\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {PIXI.GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation\n   * @returns {PIXI.GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn\'t work for reflections.\n   * @param {PIXI.GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {PIXI.GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => Math.abs(dx) * 2 <= Math.abs(dy) ? dy >= 0 ? groupD8.S : groupD8.N : Math.abs(dy) * 2 <= Math.abs(dx) ? dx > 0 ? groupD8.E : groupD8.W : dy > 0 ? dx > 0 ? groupD8.SE : groupD8.SW : dx > 0 ? groupD8.NE : groupD8.NW,\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx, mat.ty = ty, matrix.append(mat);\n  }\n};\n\n//# sourceMappingURL=groupD8.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/ObservablePoint.mjs\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param cb - callback function triggered when `x` and/or `y` are changed\n   * @param scope - owner of callback\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(cb, scope, x = 0, y = 0) {\n    this._x = x, this._y = y, this.cb = cb, this.scope = scope;\n  }\n  /**\n   * Creates a clone of this point.\n   * The callback and scope params can be overridden otherwise they will default\n   * to the clone object\'s values.\n   * @override\n   * @param cb - The callback function triggered when `x` and/or `y` are changed\n   * @param scope - The owner of the callback\n   * @returns a copy of this observable point\n   */\n  clone(cb = this.cb, scope = this.scope) {\n    return new ObservablePoint(cb, scope, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    return (this._x !== x || this._y !== y) && (this._x = x, this._y = y, this.cb.call(this.scope)), this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    return (this._x !== p.x || this._y !== p.y) && (this._x = p.x, this._y = p.y, this.cb.call(this.scope)), this;\n  }\n  /**\n   * Copies this point\'s x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    return p.set(this._x, this._y), p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x !== value && (this._x = value, this.cb.call(this.scope));\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y !== value && (this._y = value, this.cb.call(this.scope));\n  }\n}\nObservablePoint.prototype.toString = function() {\n  return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;\n};\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Transform.mjs\n\n\nconst _Transform = class {\n  constructor() {\n    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n  }\n  /** Called when a value changes. */\n  onChange() {\n    this._localID++;\n  }\n  /** Called when the skew or the rotation changes. */\n  updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n  }\n  /** Updates the local transformation matrix. */\n  updateLocalTransform() {\n    const lt = this.localTransform;\n    this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1);\n  }\n  /**\n   * Updates the local and the world transformation matrices.\n   * @param parentTransform - The parent transform\n   */\n  updateTransform(parentTransform) {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) {\n      const pt = parentTransform.worldTransform, wt = this.worldTransform;\n      wt.a = lt.a * pt.a + lt.b * pt.c, wt.b = lt.a * pt.b + lt.b * pt.d, wt.c = lt.c * pt.a + lt.d * pt.c, wt.d = lt.c * pt.b + lt.d * pt.d, wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx, wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty, this._parentID = parentTransform._worldID, this._worldID++;\n    }\n  }\n  /**\n   * Decomposes a matrix and sets the transforms properties based on it.\n   * @param matrix - The matrix to decompose\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this), this._localID++;\n  }\n  /** The rotation of the object in radians. */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    this._rotation !== value && (this._rotation = value, this.updateSkew());\n  }\n};\n_Transform.IDENTITY = new _Transform();\nlet Transform_Transform = _Transform;\nTransform_Transform.prototype.toString = function() {\n  return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;\n};\n\n//# sourceMappingURL=Transform.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram.frag.mjs\nvar defaultFragment = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`;\n\n//# sourceMappingURL=defaultProgram.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram.vert.mjs\nvar defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`;\n\n//# sourceMappingURL=defaultProgram.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs\nconst uniformParsers = [\n  // a float cache layer\n  {\n    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,\n    code: (name) => `\n            if(uv["${name}"] !== ud["${name}"].value)\n            {\n                ud["${name}"].value = uv["${name}"]\n                gl.uniform1f(ud["${name}"].location, uv["${name}"])\n            }\n            `\n  },\n  // handling samplers\n  {\n    test: (data, uniform) => (\n      // eslint-disable-next-line max-len,no-eq-null,eqeqeq\n      (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0)\n    ),\n    code: (name) => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${name}"], t);\n\n            if(ud["${name}"].value !== t)\n            {\n                ud["${name}"].value = t;\n                gl.uniform1i(ud["${name}"].location, t);\n; // eslint-disable-line max-len\n            }`\n  },\n  // uploading pixi matrix object to mat3\n  {\n    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,\n    code: (name) => (\n      // TODO and some smart caching dirty ids here!\n      `\n            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));\n            `\n    ),\n    codeUbo: (name) => `\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n        \n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n        \n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `\n  },\n  // uploading a pixi point as a vec2 with caching layer\n  {\n    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${name}"].location, v.x, v.y);\n                }`,\n    codeUbo: (name) => `\n                v = uv.${name};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `\n  },\n  // caching layer for a vec2\n  {\n    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);\n                }\n            `\n  },\n  // upload a pixi rectangle as a vec4 with caching layer\n  {\n    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `\n  },\n  // upload a pixi color as vec4 with caching layer\n  {\n    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `\n  },\n  // upload a pixi color as a vec3 with caching layer\n  {\n    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `\n  },\n  // a caching layer for vec4 uploading\n  {\n    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])\n                }`\n  }\n];\n\n//# sourceMappingURL=uniformParsers.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs\n\nconst GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: "gl.uniformMatrix2fv(location, false, v)",\n  mat3: "gl.uniformMatrix3fv(location, false, v)",\n  mat4: "gl.uniformMatrix4fv(location, false, v)",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n}, GLSL_TO_ARRAY_SETTERS = {\n  float: "gl.uniform1fv(location, v)",\n  vec2: "gl.uniform2fv(location, v)",\n  vec3: "gl.uniform3fv(location, v)",\n  vec4: "gl.uniform4fv(location, v)",\n  mat4: "gl.uniformMatrix4fv(location, false, v)",\n  mat3: "gl.uniformMatrix3fv(location, false, v)",\n  mat2: "gl.uniformMatrix2fv(location, false, v)",\n  int: "gl.uniform1iv(location, v)",\n  ivec2: "gl.uniform2iv(location, v)",\n  ivec3: "gl.uniform3iv(location, v)",\n  ivec4: "gl.uniform4iv(location, v)",\n  uint: "gl.uniform1uiv(location, v)",\n  uvec2: "gl.uniform2uiv(location, v)",\n  uvec3: "gl.uniform3uiv(location, v)",\n  uvec4: "gl.uniform4uiv(location, v)",\n  bool: "gl.uniform1iv(location, v)",\n  bvec2: "gl.uniform2iv(location, v)",\n  bvec3: "gl.uniform3iv(location, v)",\n  bvec4: "gl.uniform4iv(location, v)",\n  sampler2D: "gl.uniform1iv(location, v)",\n  samplerCube: "gl.uniform1iv(location, v)",\n  sampler2DArray: "gl.uniform1iv(location, v)"\n};\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (const i in group.uniforms) {\n    const data = uniformData[i];\n    if (!data) {\n      group.uniforms[i]?.group === !0 && (group.uniforms[i].ubo ? funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, \'${i}\');\n                    `) : funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `));\n      continue;\n    }\n    const uniform = group.uniforms[i];\n    let parsed = !1;\n    for (let j = 0; j < uniformParsers.length; j++)\n      if (uniformParsers[j].test(data, uniform)) {\n        funcFragments.push(uniformParsers[j].code(i, uniform)), parsed = !0;\n        break;\n      }\n    if (!parsed) {\n      const template = (data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS)[data.type].replace("location", `ud["${i}"].location`);\n      funcFragments.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${template};`);\n    }\n  }\n  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join(`\n`));\n}\n\n//# sourceMappingURL=generateUniformsSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs\n\n\nconst unknownContext = {};\nlet context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context?.isContextLost()) {\n    const canvas = settings.ADAPTER.createCanvas();\n    let gl;\n    settings.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas.getContext("webgl2", {})), gl || (gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {}), gl ? gl.getExtension("WEBGL_draw_buffers") : gl = null), context = gl;\n  }\n  return context;\n}\n\n//# sourceMappingURL=getTestContext.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs\n\n\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = PRECISION.MEDIUM;\n    const gl = getTestContext();\n    if (gl && gl.getShaderPrecisionFormat) {\n      const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n      shaderFragment && (maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM);\n    }\n  }\n  return maxFragmentPrecision;\n}\n\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs\nconst GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(type) {\n  return GLSL_TO_SIZE[type];\n}\n\n//# sourceMappingURL=mapSize.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapType.mjs\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: "float",\n  FLOAT_VEC2: "vec2",\n  FLOAT_VEC3: "vec3",\n  FLOAT_VEC4: "vec4",\n  INT: "int",\n  INT_VEC2: "ivec2",\n  INT_VEC3: "ivec3",\n  INT_VEC4: "ivec4",\n  UNSIGNED_INT: "uint",\n  UNSIGNED_INT_VEC2: "uvec2",\n  UNSIGNED_INT_VEC3: "uvec3",\n  UNSIGNED_INT_VEC4: "uvec4",\n  BOOL: "bool",\n  BOOL_VEC2: "bvec2",\n  BOOL_VEC3: "bvec3",\n  BOOL_VEC4: "bvec4",\n  FLOAT_MAT2: "mat2",\n  FLOAT_MAT3: "mat3",\n  FLOAT_MAT4: "mat4",\n  SAMPLER_2D: "sampler2D",\n  INT_SAMPLER_2D: "sampler2D",\n  UNSIGNED_INT_SAMPLER_2D: "sampler2D",\n  SAMPLER_CUBE: "samplerCube",\n  INT_SAMPLER_CUBE: "samplerCube",\n  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",\n  SAMPLER_2D_ARRAY: "sampler2DArray",\n  INT_SAMPLER_2D_ARRAY: "sampler2DArray",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\n\n//# sourceMappingURL=mapType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs\n\nfunction setPrecision(src, requestedPrecision, maxSupportedPrecision) {\n  if (src.substring(0, 9) !== "precision") {\n    let precision = requestedPrecision;\n    return requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH && (precision = PRECISION.MEDIUM), `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp")\n    return src.replace("precision highp", "precision mediump");\n  return src;\n}\n\n//# sourceMappingURL=setPrecision.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Program.mjs\n\n\n\n\n\n\n\nlet Program_UID = 0;\nconst nameCache = {}, _Program = class _Program2 {\n  /**\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param name - Name for shader\n   * @param extra - Extra data for shader\n   */\n  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {\n    this.extra = {}, this.id = Program_UID++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== "#version" && (name = name.replace(/\\s+/g, "-"), nameCache[name] ? (nameCache[name]++, name += `-${nameCache[name]}`) : nameCache[name] = 1, this.vertexSrc = `#define SHADER_NAME ${name}\n${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name}\n${this.fragmentSrc}`, this.vertexSrc = setPrecision(\n      this.vertexSrc,\n      _Program2.defaultVertexPrecision,\n      PRECISION.HIGH\n    ), this.fragmentSrc = setPrecision(\n      this.fragmentSrc,\n      _Program2.defaultFragmentPrecision,\n      getMaxFragmentPrecision()\n    )), this.glPrograms = {}, this.syncUniforms = null;\n  }\n  /**\n   * The default vertex shader source.\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return defaultVertex;\n  }\n  /**\n   * The default fragment shader source.\n   * @readonly\n   */\n  static get defaultFragmentSrc() {\n    return defaultFragment;\n  }\n  /**\n   * A short hand function to create a program based of a vertex and fragment shader.\n   *\n   * This method will also check to see if there is a cached program.\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param name - Name for shader\n   * @returns A shiny new PixiJS shader program!\n   */\n  static from(vertexSrc, fragmentSrc, name) {\n    const key = vertexSrc + fragmentSrc;\n    let program = ProgramCache[key];\n    return program || (ProgramCache[key] = program = new _Program2(vertexSrc, fragmentSrc, name)), program;\n  }\n};\n_Program.defaultVertexPrecision = PRECISION.HIGH, /**\n* Default specify float precision in fragment shader.\n* iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742\n* @static\n* @type {PIXI.PRECISION}\n* @default PIXI.PRECISION.MEDIUM\n*/\n_Program.defaultFragmentPrecision = isMobile_isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;\nlet Program = _Program;\n\n//# sourceMappingURL=Program.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/UniformGroup.mjs\n\n\nlet UniformGroup_UID = 0;\nclass UniformGroup {\n  /**\n   * @param {object | Buffer} [uniforms] - Custom uniforms to use to augment the built-in ones. Or a pixi buffer.\n   * @param isStatic - Uniforms wont be changed after creation.\n   * @param isUbo - If true, will treat this uniform group as a uniform buffer object.\n   */\n  constructor(uniforms, isStatic, isUbo) {\n    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UniformGroup_UID++, this.static = !!isStatic, this.ubo = !!isUbo, uniforms instanceof Buffer ? (this.buffer = uniforms, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = uniforms, this.ubo && (this.buffer = new Buffer(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));\n  }\n  update() {\n    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n  }\n  add(name, uniforms, _static) {\n    if (!this.ubo)\n      this.uniforms[name] = new UniformGroup(uniforms, _static);\n    else\n      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");\n  }\n  static from(uniforms, _static, _ubo) {\n    return new UniformGroup(uniforms, _static, _ubo);\n  }\n  /**\n   * A short hand function for creating a static UBO UniformGroup.\n   * @param uniforms - the ubo item\n   * @param _static - should this be updated each time it is used? defaults to true here!\n   */\n  static uboFrom(uniforms, _static) {\n    return new UniformGroup(uniforms, _static ?? !0, !0);\n  }\n}\n\n//# sourceMappingURL=UniformGroup.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Shader.mjs\n\n\n\nclass Shader {\n  /**\n   * @param program - The program the shader will use.\n   * @param uniforms - Custom uniforms to use to augment the built-in ones.\n   */\n  constructor(program, uniforms) {\n    this.uniformBindCount = 0, this.program = program, uniforms ? uniforms instanceof UniformGroup ? this.uniformGroup = uniforms : this.uniformGroup = new UniformGroup(uniforms) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner_Runner("disposeShader");\n  }\n  // TODO move to shader system..\n  checkUniformExists(name, group) {\n    if (group.uniforms[name])\n      return !0;\n    for (const i in group.uniforms) {\n      const uniform = group.uniforms[i];\n      if (uniform.group === !0 && this.checkUniformExists(name, uniform))\n        return !0;\n    }\n    return !1;\n  }\n  destroy() {\n    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();\n  }\n  /**\n   * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n   * @readonly\n   */\n  get uniforms() {\n    return this.uniformGroup.uniforms;\n  }\n  /**\n   * A short hand function to create a shader based of a vertex and fragment shader.\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param uniforms - Custom uniforms to use to augment the built-in ones.\n   * @returns A shiny new PixiJS shader!\n   */\n  static from(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc, fragmentSrc);\n    return new Shader(program, uniforms);\n  }\n}\n\n//# sourceMappingURL=Shader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs\n\n\n\n\nclass BatchShaderGenerator {\n  /**\n   * @param vertexSrc - Vertex shader\n   * @param fragTemplate - Fragment shader template\n   */\n  constructor(vertexSrc, fragTemplate) {\n    if (this.vertexSrc = vertexSrc, this.fragTemplate = fragTemplate, this.programCache = {}, this.defaultGroupCache = {}, !fragTemplate.includes("%count%"))\n      throw new Error(\'Fragment template must contain "%count%".\');\n    if (!fragTemplate.includes("%forloop%"))\n      throw new Error(\'Fragment template must contain "%forloop%".\');\n  }\n  generateShader(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      const sampleValues = new Int32Array(maxTextures);\n      for (let i = 0; i < maxTextures; i++)\n        sampleValues[i] = i;\n      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, !0);\n      let fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`), fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures)), this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n    }\n    const uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader(this.programCache[maxTextures], uniforms);\n  }\n  generateSampleSrc(maxTextures) {\n    let src = "";\n    src += `\n`, src += `\n`;\n    for (let i = 0; i < maxTextures; i++)\n      i > 0 && (src += `\nelse `), i < maxTextures - 1 && (src += `if(vTextureId < ${i}.5)`), src += `\n{`, src += `\n\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`, src += `\n}`;\n    return src += `\n`, src += `\n`, src;\n  }\n}\n\n//# sourceMappingURL=BatchShaderGenerator.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs\nclass BatchTextureArray {\n  constructor() {\n    this.elements = [], this.ids = [], this.count = 0;\n  }\n  clear() {\n    for (let i = 0; i < this.count; i++)\n      this.elements[i] = null;\n    this.count = 0;\n  }\n}\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs\n\nfunction canUploadSameBuffer() {\n  return !isMobile_isMobile.apple.device;\n}\n\n//# sourceMappingURL=canUploadSameBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs\n\nfunction maxRecommendedTextures(max) {\n  let allowMax = !0;\n  const navigator = settings.ADAPTER.getNavigator();\n  if (isMobile_isMobile.tablet || isMobile_isMobile.phone) {\n    if (isMobile_isMobile.apple.device) {\n      const match = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      match && parseInt(match[1], 10) < 11 && (allowMax = !1);\n    }\n    if (isMobile_isMobile.android.device) {\n      const match = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      match && parseInt(match[1], 10) < 7 && (allowMax = !1);\n    }\n  }\n  return allowMax ? max : 4;\n}\n\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs\nclass ObjectRenderer {\n  /**\n   * @param renderer - The renderer this manager works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /** Stub method that should be used to empty the current batch by rendering objects now. */\n  flush() {\n  }\n  /** Generic destruction method that frees all resources. This should be called by subclasses. */\n  destroy() {\n    this.renderer = null;\n  }\n  /**\n   * Stub method that initializes any state required before\n   * rendering starts. It is different from the `prerender`\n   * signal, which occurs every frame, in that it is called\n   * whenever an object requests _this_ renderer specifically.\n   */\n  start() {\n  }\n  /** Stops the renderer. It should free up any state and become dormant. */\n  stop() {\n    this.flush();\n  }\n  /**\n   * Keeps the object to render. It doesn\'t have to be\n   * rendered immediately.\n   * @param {PIXI.DisplayObject} _object - The object to render.\n   */\n  render(_object) {\n  }\n}\n\n//# sourceMappingURL=ObjectRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture.frag.mjs\nvar texture_frag_defaultFragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`;\n\n//# sourceMappingURL=texture.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture.vert.mjs\nvar texture_vert_defaultVertex = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`;\n\n//# sourceMappingURL=texture.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer {\n  /**\n   * This will hook onto the renderer\'s `contextChange`\n   * and `prerender` signals.\n   * @param {PIXI.Renderer} renderer - The renderer this works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry, this.vertexSize = 6, this.state = State.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];\n  }\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @default 32\n   */\n  static get defaultMaxTextures() {\n    return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32), this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   */\n  static get canUploadSameBuffer() {\n    return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer(), this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  /**\n   * @see PIXI.BatchRenderer#maxTextures\n   * @deprecated since 7.1.0\n   * @readonly\n   */\n  get MAX_TEXTURES() {\n    return deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;\n  }\n  /**\n   * The default vertex shader source\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return texture_vert_defaultVertex;\n  }\n  /**\n   * The default fragment shader source\n   * @readonly\n   */\n  static get defaultFragmentTemplate() {\n    return texture_frag_defaultFragment;\n  }\n  /**\n   * Set the shader generator.\n   * @param {object} [options]\n   * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n   * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n   */\n  setShaderGenerator({\n    vertex = _BatchRenderer2.defaultVertexSrc,\n    fragment = _BatchRenderer2.defaultFragmentTemplate\n  } = {}) {\n    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n  }\n  /**\n   * Handles the `contextChange` signal.\n   *\n   * It calculates `this.maxTextures` and allocating the packed-geometry object pool.\n   */\n  contextChange() {\n    const gl = this.renderer.gl;\n    settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(\n      gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n      _BatchRenderer2.defaultMaxTextures\n    ), this.maxTextures = checkMaxIfStatementsInShader(\n      this.maxTextures,\n      gl\n    )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++)\n      this._packedGeometries[i] = new this.geometryClass();\n    this.initFlushBuffers();\n  }\n  /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    for (; _drawCallPool.length < MAX_SPRITES; )\n      _drawCallPool.push(new BatchDrawCall());\n    for (; _textureArrayPool.length < MAX_TA; )\n      _textureArrayPool.push(new BatchTextureArray());\n    for (let i = 0; i < this.maxTextures; i++)\n      this._tempBoundTextures[i] = null;\n  }\n  /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n  onPrerender() {\n    this._flushId = 0;\n  }\n  /**\n   * Buffers the "batchable" object. It need not be rendered immediately.\n   * @param {PIXI.DisplayObject} element - the element to render when\n   *    using this renderer\n   */\n  render(element) {\n    element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i), start = i, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);\n    }\n    texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);\n    for (let i = 0; i < boundTextures.length; i++)\n      boundTextures[i] = null;\n    BaseTexture._globalBatch = TICK;\n  }\n  /**\n   * Populating drawcalls for rendering\n   * @param texArray\n   * @param start\n   * @param finish\n   */\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this, drawCalls = _BatchRenderer2._drawCallPool;\n    let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex, drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i], tex = sprite._texture.baseTexture, spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null, start < i && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;\n    }\n    start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;\n  }\n  /**\n   * Bind textures for current rendering\n   * @param texArray\n   */\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++)\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]), texArray.elements[j] = null;\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex, { gl, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const { texArray, type, size, start, blend } = drawCalls[i];\n      curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  /** Renders the content _now_ and empties the current batch. */\n  flush() {\n    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n  }\n  /** Starts a new sprite batch. */\n  start() {\n    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n  }\n  /** Stops and flushes the current batch. */\n  stop() {\n    this.flush();\n  }\n  /** Destroys this `BatchRenderer`. It cannot be used again. */\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++)\n      this._packedGeometries[i] && this._packedGeometries[i].destroy();\n    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();\n  }\n  /**\n   * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n   * @param size - minimum capacity required\n   * @returns - buffer than can hold atleast `size` floats\n   */\n  getAttributeBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 8)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 8;\n    this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);\n    let buffer = this._aBuffers[roundedSize];\n    return buffer || (this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4)), buffer;\n  }\n  /**\n   * Fetches an index buffer from `this._iBuffers` that can\n   * have at least `size` capacity.\n   * @param size - minimum required capacity\n   * @returns - buffer that can fit `size` indices.\n   */\n  getIndexBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 12)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 12;\n    this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);\n    let buffer = this._iBuffers[roundedSizeIndex];\n    return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer;\n  }\n  /**\n   * Takes the four batching parameters of `element`, interleaves\n   * and pushes them into the batching attribute/index buffers given.\n   *\n   * It uses these properties: `vertexData` `uvs`, `textureId` and\n   * `indicies`. It also uses the "tint" of the base-texture, if\n   * present.\n   * @param {PIXI.DisplayObject} element - element being rendered\n   * @param attributeBuffer - attribute buffer.\n   * @param indexBuffer - index buffer\n   * @param aIndex - number of floats already in the attribute buffer\n   * @param iIndex - number of indices already in `indexBuffer`\n   */\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = Color_Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);\n    for (let i = 0; i < vertexData.length; i += 2)\n      float32View[aIndex++] = vertexData[i], float32View[aIndex++] = vertexData[i + 1], float32View[aIndex++] = uvs[i], float32View[aIndex++] = uvs[i + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;\n    for (let i = 0; i < indicies.length; i++)\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n  }\n};\n_BatchRenderer.defaultBatchSize = 4096, /** @ignore */\n_BatchRenderer.extension = {\n  name: "batch",\n  type: ExtensionType.RendererPlugin\n}, /**\n* Pool of `BatchDrawCall` objects that `flush` used\n* to create "batches" of the objects being rendered.\n*\n* These are never re-allocated again.\n* Shared between all batch renderers because it can be only one "flush" working at the moment.\n* @member {PIXI.BatchDrawCall[]}\n*/\n_BatchRenderer._drawCallPool = [], /**\n* Pool of `BatchDrawCall` objects that `flush` used\n* to create "batches" of the objects being rendered.\n*\n* These are never re-allocated again.\n* Shared between all batch renderers because it can be only one "flush" working at the moment.\n* @member {PIXI.BatchTextureArray[]}\n*/\n_BatchRenderer._textureArrayPool = [];\nlet BatchRenderer = _BatchRenderer;\nextensions.add(BatchRenderer);\n\n//# sourceMappingURL=BatchRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter.frag.mjs\nvar defaultFilter_frag_defaultFragment = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`;\n\n//# sourceMappingURL=defaultFilter.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter.vert.mjs\nvar defaultFilter_vert_defaultVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`;\n\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/Filter.mjs\n\n\n\n\n\n\nconst _Filter = class _Filter2 extends Shader {\n  /**\n   * @param vertexSrc - The source of the vertex shader.\n   * @param fragmentSrc - The source of the fragment shader.\n   * @param uniforms - Custom uniforms to use to augment the built-in ones.\n   */\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(\n      vertexSrc || _Filter2.defaultVertexSrc,\n      fragmentSrc || _Filter2.defaultFragmentSrc\n    );\n    super(program, uniforms), this.padding = 0, this.resolution = _Filter2.defaultResolution, this.multisample = _Filter2.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new State();\n  }\n  /**\n   * Applies the filter\n   * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from\n   * @param {PIXI.RenderTexture} input - The input render target.\n   * @param {PIXI.RenderTexture} output - The target to output to.\n   * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it.\n   * @param {object} [_currentState] - It\'s current state of filter.\n   *        There are some useful properties in the currentState :\n   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n   */\n  apply(filterManager, input, output, clearMode, _currentState) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Sets the blend mode of the filter.\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  /**\n   * The resolution of the filter. Setting this to be lower will lower the quality but\n   * increase the performance of the filter.\n   * If set to `null` or `0`, the resolution of the current render target is used.\n   * @default PIXI.Filter.defaultResolution\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._resolution = value;\n  }\n  /**\n   * The default vertex shader source\n   * @readonly\n   */\n  static get defaultVertexSrc() {\n    return defaultFilter_vert_defaultVertex;\n  }\n  /**\n   * The default fragment shader source\n   * @readonly\n   */\n  static get defaultFragmentSrc() {\n    return defaultFilter_frag_defaultFragment;\n  }\n};\n_Filter.defaultResolution = 1, /**\n* Default filter samples for any filter.\n* @static\n* @type {PIXI.MSAA_QUALITY|null}\n* @default PIXI.MSAA_QUALITY.NONE\n*/\n_Filter.defaultMultisample = MSAA_QUALITY.NONE;\nlet Filter = _Filter;\n\n//# sourceMappingURL=Filter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs\n\n\nclass BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = !0, this._backgroundColor = new Color_Color(0), this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param {PIXI.IRendererOptions} options - the options for the background colors\n   */\n  init(options) {\n    this.clearBeforeRender = options.clearBeforeRender;\n    const { backgroundColor, background, backgroundAlpha } = options, color = background ?? backgroundColor;\n    color !== void 0 && (this.color = color), this.alpha = backgroundAlpha;\n  }\n  /**\n   * The background color to fill if not transparent.\n   * @member {PIXI.ColorSource}\n   */\n  get color() {\n    return this._backgroundColor.value;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /**\n   * The background color alpha. Setting this to 0 will make the canvas transparent.\n   * @member {number}\n   */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color object. */\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  destroy() {\n  }\n}\nBackgroundSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.backgroundAlpha}\n   * @default 1\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link PIXI.IRendererOptions.backgroundColor}\n   * @default 0x000000\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  backgroundColor: 0,\n  /**\n   * {@link PIXI.IRendererOptions.clearBeforeRender}\n   * @default true\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  clearBeforeRender: !0\n}, /** @ignore */\nBackgroundSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "background"\n};\nextensions.add(BackgroundSystem);\n\n//# sourceMappingURL=BackgroundSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchSystem.mjs\n\n\nclass BatchSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.emptyRenderer = new ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer;\n  }\n  /**\n   * Changes the current renderer to the one given in parameter\n   * @param objectRenderer - The object renderer to use.\n   */\n  setObjectRenderer(objectRenderer) {\n    this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start());\n  }\n  /**\n   * This should be called if you wish to do some custom rendering\n   * It will basically render anything that may be batched up such as sprites\n   */\n  flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  /** Reset the system to an empty renderer */\n  reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  /**\n   * Handy function for batch renderers: copies bound textures in first maxTextures locations to array\n   * sets actual _batchLocation for them\n   * @param arr - arr copy destination\n   * @param maxTextures - number of copied elements\n   */\n  copyBoundTextures(arr, maxTextures) {\n    const { boundTextures } = this.renderer.texture;\n    for (let i = maxTextures - 1; i >= 0; --i)\n      arr[i] = boundTextures[i] || null, arr[i] && (arr[i]._batchLocation = i);\n  }\n  /**\n   * Assigns batch locations to textures in array based on boundTextures state.\n   * All textures in texArray should have `_batchEnabled = _batchId`,\n   * and their count should be less than `maxTextures`.\n   * @param texArray - textures to bound\n   * @param boundTextures - current state of bound textures\n   * @param batchId - marker for _batchEnabled param of textures in texArray\n   * @param maxTextures - number of texture locations to manipulate\n   */\n  boundArray(texArray, boundTextures, batchId, maxTextures) {\n    const { elements, ids, count } = texArray;\n    let j = 0;\n    for (let i = 0; i < count; i++) {\n      const tex = elements[i], loc = tex._batchLocation;\n      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {\n        ids[i] = loc;\n        continue;\n      }\n      for (; j < maxTextures; ) {\n        const bound = boundTextures[j];\n        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {\n          j++;\n          continue;\n        }\n        ids[i] = j, tex._batchLocation = j, boundTextures[j] = tex;\n        break;\n      }\n    }\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.renderer = null;\n  }\n}\nBatchSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "batch"\n};\nextensions.add(BatchSystem);\n\n//# sourceMappingURL=BatchSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/context/ContextSystem.mjs\n\n\n\nlet CONTEXT_UID_COUNTER = 0;\nclass ContextSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n      uint32Indices: !1\n    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  /**\n   * `true` if the context is lost\n   * @readonly\n   */\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  /**\n   * Handles the context change event.\n   * @param {WebGLRenderingContext} gl - New WebGL context.\n   */\n  contextChange(gl) {\n    this.gl = gl, this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n  }\n  init(options) {\n    if (options.context)\n      this.initFromContext(options.context);\n    else {\n      const alpha = this.renderer.background.alpha < 1, premultipliedAlpha = options.premultipliedAlpha;\n      this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.useContextAlpha = options.useContextAlpha, this.powerPreference = options.powerPreference, this.initFromOptions({\n        alpha,\n        premultipliedAlpha,\n        antialias: options.antialias,\n        stencil: !0,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference\n      });\n    }\n  }\n  /**\n   * Initializes the context.\n   * @protected\n   * @param {WebGLRenderingContext} gl - WebGL context\n   */\n  initFromContext(gl) {\n    this.gl = gl, this.validateContext(gl), this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(gl);\n    const view = this.renderer.view;\n    view.addEventListener !== void 0 && (view.addEventListener("webglcontextlost", this.handleContextLost, !1), view.addEventListener("webglcontextrestored", this.handleContextRestored, !1));\n  }\n  /**\n   * Initialize from context options\n   * @protected\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n   * @param {object} options - context attributes\n   */\n  initFromOptions(options) {\n    const gl = this.createContext(this.renderer.view, options);\n    this.initFromContext(gl);\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param canvas - the canvas element that we will get the context from\n   * @param options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  createContext(canvas, options) {\n    let gl;\n    if (settings.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas.getContext("webgl2", options)), gl)\n      this.webGLVersion = 2;\n    else if (this.webGLVersion = 1, gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options), !gl)\n      throw new Error("This browser does not support WebGL. Try using the canvas renderer");\n    return this.gl = gl, this.getExtensions(), this.gl;\n  }\n  /** Auto-populate the {@link PIXI.ContextSystem.extensions extensions}. */\n  getExtensions() {\n    const { gl } = this, common = {\n      loseContext: gl.getExtension("WEBGL_lose_context"),\n      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),\n      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),\n      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n      // eslint-disable-line camelcase\n      etc: gl.getExtension("WEBGL_compressed_texture_etc"),\n      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),\n      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n      atc: gl.getExtension("WEBGL_compressed_texture_atc"),\n      astc: gl.getExtension("WEBGL_compressed_texture_astc")\n    };\n    this.webGLVersion === 1 ? Object.assign(this.extensions, common, {\n      drawBuffers: gl.getExtension("WEBGL_draw_buffers"),\n      depthTexture: gl.getExtension("WEBGL_depth_texture"),\n      vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),\n      uint32ElementIndex: gl.getExtension("OES_element_index_uint"),\n      // Floats and half-floats\n      floatTexture: gl.getExtension("OES_texture_float"),\n      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n      textureHalfFloat: gl.getExtension("OES_texture_half_float"),\n      textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")\n    }) : this.webGLVersion === 2 && Object.assign(this.extensions, common, {\n      // Floats and half-floats\n      colorBufferFloat: gl.getExtension("EXT_color_buffer_float")\n    });\n  }\n  /**\n   * Handles a lost webgl context\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n  handleContextLost(event) {\n    event.preventDefault(), setTimeout(() => {\n      this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();\n    }, 0);\n  }\n  /** Handles a restored webgl context. */\n  handleContextRestored() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const view = this.renderer.view;\n    this.renderer = null, view.removeEventListener !== void 0 && (view.removeEventListener("webglcontextlost", this.handleContextLost), view.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n  }\n  /** Handle the post-render runner event. */\n  postrender() {\n    this.renderer.objectRenderer.renderingToScreen && this.gl.flush();\n  }\n  /**\n   * Validate context.\n   * @param {WebGLRenderingContext} gl - Render context.\n   */\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes(), isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;\n    isWebGl2 && (this.webGLVersion = 2), attributes && !attributes.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");\n    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");\n    this.supports.uint32Indices = hasuint32, hasuint32 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");\n  }\n}\nContextSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.context}\n   * @default null\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  context: null,\n  /**\n   * {@link PIXI.IRendererOptions.antialias}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  antialias: !1,\n  /**\n   * {@link PIXI.IRendererOptions.premultipliedAlpha}\n   * @default true\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  premultipliedAlpha: !0,\n  /**\n   * {@link PIXI.IRendererOptions.preserveDrawingBuffer}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  preserveDrawingBuffer: !1,\n  /**\n   * {@link PIXI.IRendererOptions.powerPreference}\n   * @default default\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  powerPreference: "default"\n}, /** @ignore */\nContextSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "context"\n};\nextensions.add(ContextSystem);\n\n//# sourceMappingURL=ContextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs\n\n\n\nclass Framebuffer {\n  /**\n   * @param width - Width of the frame buffer\n   * @param height - Height of the frame buffer\n   */\n  constructor(width, height) {\n    if (this.width = Math.round(width), this.height = Math.round(height), !this.width || !this.height)\n      throw new Error("Framebuffer width or height is zero");\n    this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner_Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;\n  }\n  /**\n   * Reference to the colorTexture.\n   * @readonly\n   */\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  /**\n   * Add texture to the colorTexture array.\n   * @param index - Index of the array to add the texture to\n   * @param texture - Texture to add to the array\n   */\n  addColorTexture(index = 0, texture) {\n    return this.colorTextures[index] = texture || new BaseTexture(null, {\n      scaleMode: SCALE_MODES.NEAREST,\n      resolution: 1,\n      mipmap: MIPMAP_MODES.OFF,\n      width: this.width,\n      height: this.height\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /**\n   * Add a depth texture to the frame buffer.\n   * @param texture - Texture to add.\n   */\n  addDepthTexture(texture) {\n    return this.depthTexture = texture || new BaseTexture(null, {\n      scaleMode: SCALE_MODES.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: MIPMAP_MODES.OFF,\n      format: FORMATS.DEPTH_COMPONENT,\n      type: TYPES.UNSIGNED_SHORT\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /** Enable depth on the frame buffer. */\n  enableDepth() {\n    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /** Enable stencil on the frame buffer. */\n  enableStencil() {\n    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }\n  /**\n   * Resize the frame buffer\n   * @param width - Width of the frame buffer to resize to\n   * @param height - Height of the frame buffer to resize to\n   */\n  resize(width, height) {\n    if (width = Math.round(width), height = Math.round(height), !width || !height)\n      throw new Error("Framebuffer width and height must not be zero");\n    if (!(width === this.width && height === this.height)) {\n      this.width = width, this.height = height, this.dirtyId++, this.dirtySize++;\n      for (let i = 0; i < this.colorTextures.length; i++) {\n        const texture = this.colorTextures[i], resolution = texture.resolution;\n        texture.setSize(width / resolution, height / resolution);\n      }\n      if (this.depthTexture) {\n        const resolution = this.depthTexture.resolution;\n        this.depthTexture.setSize(width / resolution, height / resolution);\n      }\n    }\n  }\n  /** Disposes WebGL resources that are connected to this geometry. */\n  dispose() {\n    this.disposeRunner.emit(this, !1);\n  }\n  /** Destroys and removes the depth texture added to this framebuffer. */\n  destroyDepthTexture() {\n    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n  }\n}\n\n//# sourceMappingURL=Framebuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs\n\n\n\n\nclass BaseRenderTexture extends BaseTexture {\n  /**\n   * @param options\n   * @param {number} [options.width=100] - The width of the base render texture.\n   * @param {number} [options.height=100] - The height of the base render texture.\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}\n   *   for possible values.\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio\n   *   of the texture being generated.\n   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer.\n   */\n  constructor(options = {}) {\n    if (typeof options == "number") {\n      const width = arguments[0], height = arguments[1], scaleMode = arguments[2], resolution = arguments[3];\n      options = { width, height, scaleMode, resolution };\n    }\n    options.width = options.width ?? 100, options.height = options.height ?? 100, options.multisample ?? (options.multisample = MSAA_QUALITY.NONE), super(null, options), this.mipmap = MIPMAP_MODES.OFF, this.valid = !0, this._clear = new Color_Color([0, 0, 0, 0]), this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = options.multisample, this.maskStack = [], this.filterStack = [{}];\n  }\n  /** Color when clearning the texture. */\n  set clearColor(value) {\n    this._clear.setValue(value);\n  }\n  get clearColor() {\n    return this._clear.value;\n  }\n  /**\n   * Color object when clearning the texture.\n   * @readonly\n   * @since 7.2.0\n   */\n  get clear() {\n    return this._clear;\n  }\n  /**\n   * Shortcut to `this.framebuffer.multisample`.\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  get multisample() {\n    return this.framebuffer.multisample;\n  }\n  set multisample(value) {\n    this.framebuffer.multisample = value;\n  }\n  /**\n   * Resizes the BaseRenderTexture.\n   * @param desiredWidth - The desired width to resize to.\n   * @param desiredHeight - The desired height to resize to.\n   */\n  resize(desiredWidth, desiredHeight) {\n    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }\n  /**\n   * Frees the texture and framebuffer from WebGL memory without destroying this texture object.\n   * This means you can still use the texture later which will upload it to GPU\n   * memory again.\n   * @fires PIXI.BaseTexture#dispose\n   */\n  dispose() {\n    this.framebuffer.dispose(), super.dispose();\n  }\n  /** Destroys this texture. */\n  destroy() {\n    super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n  }\n}\n\n//# sourceMappingURL=BaseRenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs\n\n\n\nclass BaseImageResource extends Resource {\n  /**\n   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source\n   */\n  constructor(source) {\n    const sourceAny = source, width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width, height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;\n    super(width, height), this.source = source, this.noSubImage = !1;\n  }\n  /**\n   * Set cross origin based detecting the url and the crossorigin\n   * @param element - Element to apply crossOrigin\n   * @param url - URL to check\n   * @param crossorigin - Cross origin value to use\n   */\n  static crossOrigin(element, url, crossorigin) {\n    crossorigin === void 0 && !url.startsWith("data:") ? element.crossOrigin = determineCrossOrigin(url) : crossorigin !== !1 && (element.crossOrigin = typeof crossorigin == "string" ? crossorigin : "anonymous");\n  }\n  /**\n   * Upload the texture to the GPU.\n   * @param renderer - Upload to the renderer\n   * @param baseTexture - Reference to parent texture\n   * @param glTexture\n   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} [source] - (optional)\n   * @returns - true is success\n   */\n  upload(renderer, baseTexture, glTexture, source) {\n    const gl = renderer.gl, width = baseTexture.realWidth, height = baseTexture.realHeight;\n    if (source = source || this.source, typeof HTMLImageElement < "u" && source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0)\n        return !1;\n    } else if (typeof HTMLVideoElement < "u" && source instanceof HTMLVideoElement && source.readyState <= 1)\n      return !1;\n    return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source)), !0;\n  }\n  /**\n   * Checks if source width/height was changed, resize can cause extra baseTexture update.\n   * Triggers one update in any case.\n   */\n  update() {\n    if (this.destroyed)\n      return;\n    const source = this.source, width = source.naturalWidth || source.videoWidth || source.width, height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height), super.update();\n  }\n  /** Destroy this {@link PIXI.BaseImageResource} */\n  dispose() {\n    this.source = null;\n  }\n}\n\n//# sourceMappingURL=BaseImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs\n\n\n\nclass ImageResource extends BaseImageResource {\n  /**\n   * @param source - image source or URL\n   * @param options\n   * @param {boolean} [options.autoLoad=true] - start loading process\n   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n   *        a bitmap before upload\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n   */\n  constructor(source, options) {\n    if (options = options || {}, typeof source == "string") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement;\n    }\n    super(source), !source.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Returns a promise when image will be loaded and processed.\n   * @param createBitmap - whether process image into bitmap\n   */\n  load(createBitmap) {\n    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve(this.process()) : resolve(this));\n      };\n      source.complete && source.src ? completed() : (source.onload = completed, source.onerror = (event) => {\n        reject(event), this.onError.emit(event);\n      });\n    }), this._load);\n  }\n  /**\n   * Called when we need to convert image into BitmapImage.\n   * Can be called multiple times, real promise is cached inside.\n   * @returns - Cached promise to fill that bitmap\n   */\n  process() {\n    const source = this.source;\n    if (this._process !== null)\n      return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap)\n      return Promise.resolve(this);\n    const createImageBitmap = globalThis.createImageBitmap, cors = !source.crossOrigin || source.crossOrigin === "anonymous";\n    return this._process = fetch(\n      source.src,\n      {\n        mode: cors ? "cors" : "no-cors"\n      }\n    ).then((r) => r.blob()).then((blob) => createImageBitmap(\n      blob,\n      0,\n      0,\n      source.width,\n      source.height,\n      {\n        premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"\n      }\n    )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;\n  }\n  /**\n   * Upload the image resource to GPU.\n   * @param renderer - Renderer to upload to\n   * @param baseTexture - BaseTexture for this resource\n   * @param glTexture - GLTexture to use\n   * @returns {boolean} true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)\n      return super.upload(renderer, baseTexture, glTexture);\n    if (!this.bitmap && (this.process(), !this.bitmap))\n      return !1;\n    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {\n      let flag = !0;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = !1;\n          break;\n        }\n      }\n      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }\n  /** Destroys this resource. */\n  dispose() {\n    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n   */\n  static test(source) {\n    return typeof HTMLImageElement < "u" && (typeof source == "string" || source instanceof HTMLImageElement);\n  }\n}\n\n//# sourceMappingURL=ImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureUvs.mjs\n\nclass TextureUvs {\n  constructor() {\n    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n  }\n  /**\n   * Sets the texture Uvs based on the given frame information.\n   * @protected\n   * @param frame - The frame of the texture\n   * @param baseFrame - The base frame of the texture\n   * @param rotate - Rotation of frame, see {@link PIXI.groupD8}\n   */\n  set(frame, baseFrame, rotate) {\n    const tw = baseFrame.width, th = baseFrame.height;\n    if (rotate) {\n      const w2 = frame.width / 2 / tw, h2 = frame.height / 2 / th, cX = frame.x / tw + w2, cY = frame.y / th + h2;\n      rotate = groupD8.add(rotate, groupD8.NW), this.x0 = cX + w2 * groupD8.uX(rotate), this.y0 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x1 = cX + w2 * groupD8.uX(rotate), this.y1 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x2 = cX + w2 * groupD8.uX(rotate), this.y2 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x3 = cX + w2 * groupD8.uX(rotate), this.y3 = cY + h2 * groupD8.uY(rotate);\n    } else\n      this.x0 = frame.x / tw, this.y0 = frame.y / th, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th;\n    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n  }\n}\nTextureUvs.prototype.toString = function() {\n  return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;\n};\n\n//# sourceMappingURL=TextureUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/Texture.mjs\n\n\n\n\n\n\nconst DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function() {\n  }, tex.on = function() {\n  }, tex.once = function() {\n  }, tex.emit = function() {\n  };\n}\nclass Texture_Texture extends eventemitter3 {\n  /**\n   * @param baseTexture - The base texture source to create the texture from\n   * @param frame - The rectangle frame of the texture to show\n   * @param orig - The area of original texture\n   * @param trim - Trimmed rectangle of original texture\n   * @param rotate - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}\n   * @param anchor - Default anchor point used for sprite placement / rotation\n   * @param borders - Default borders used for 9-slice scaling. See {@link PIXI.NineSlicePlane}\n   */\n  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {\n    if (super(), this.noFrame = !1, frame || (this.noFrame = !0, frame = new Rectangle_Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture_Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = !1, this.destroyed = !1, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === !0)\n      this._rotate = 2;\n    else if (this._rotate % 2 !== 0)\n      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");\n    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0), this.defaultBorders = borders, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on("update", this.onBaseTextureUpdated, this);\n  }\n  /**\n   * Updates this texture on the gpu.\n   *\n   * Calls the TextureResource update.\n   *\n   * If you adjusted `frame` manually, please call `updateUvs()` instead.\n   */\n  update() {\n    this.baseTexture.resource && this.baseTexture.resource.update();\n  }\n  /**\n   * Called when the base texture is updated\n   * @protected\n   * @param baseTexture - The base texture.\n   */\n  onBaseTextureUpdated(baseTexture) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid)\n        return;\n      this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = !0, this.updateUvs();\n    } else\n      this.frame = this._frame;\n    this.emit("update", this);\n  }\n  /**\n   * Destroys this texture\n   * @param [destroyBase=false] - Whether to destroy the base texture as well\n   * @fires PIXI.Texture#destroyed\n   */\n  destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        const { resource } = this.baseTexture;\n        resource?.url && TextureCache[resource.url] && Texture_Texture.removeFromCache(resource.url), this.baseTexture.destroy();\n      }\n      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;\n    }\n    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, Texture_Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit("destroyed", this), this.removeAllListeners();\n  }\n  /**\n   * Creates a new texture object that acts the same as this one.\n   * @returns - The new texture\n   */\n  clone() {\n    const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new Texture_Texture(\n      this.baseTexture,\n      !this.noFrame && clonedFrame,\n      clonedOrig,\n      this.trim?.clone(),\n      this.rotate,\n      this.defaultAnchor,\n      this.defaultBorders\n    );\n    return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;\n  }\n  /**\n   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n   * Call it after changing the frame\n   */\n  updateUvs() {\n    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n  }\n  /**\n   * Helper function that creates a new Texture based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @param {string|PIXI.BaseTexture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source -\n   *        Source or array of sources to create texture from\n   * @param options - See {@link PIXI.BaseTexture}\'s constructor for options.\n   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n   * @returns {PIXI.Texture} The newly created texture\n   */\n  static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source == "string";\n    let cacheId = null;\n    if (isFrame)\n      cacheId = source;\n    else if (source instanceof BaseTexture) {\n      if (!source.cacheId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source.cacheId = `${prefix}-${uid()}`, BaseTexture.addToCache(source, source.cacheId);\n      }\n      cacheId = source.cacheId;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source._pixiId = `${prefix}_${uid()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let texture = TextureCache[cacheId];\n    if (isFrame && strict && !texture)\n      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);\n    return !texture && !(source instanceof BaseTexture) ? (options.resolution || (options.resolution = getResolutionOfUrl(source)), texture = new Texture_Texture(new BaseTexture(source, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.addToCache(texture.baseTexture, cacheId), Texture_Texture.addToCache(texture, cacheId)) : !texture && source instanceof BaseTexture && (texture = new Texture_Texture(source), Texture_Texture.addToCache(texture, cacheId)), texture;\n  }\n  /**\n   * Useful for loading textures via URLs. Use instead of `Texture.from` because\n   * it does a better job of handling failed URLs more effectively. This also ignores\n   * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.\n   * @param url - The remote URL or array of URLs to load.\n   * @param options - Optional options to include\n   * @returns - A Promise that resolves to a Texture.\n   */\n  static fromURL(url, options) {\n    const resourceOptions = Object.assign({ autoLoad: !1 }, options?.resourceOptions), texture = Texture_Texture.from(url, Object.assign({ resourceOptions }, options), !1), resource = texture.baseTexture.resource;\n    return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));\n  }\n  /**\n   * Create a new Texture with a BufferResource from a typed array.\n   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.\n   * @param width - Width of the resource\n   * @param height - Height of the resource\n   * @param options - See {@link PIXI.BaseTexture}\'s constructor for options.\n   *        Default properties are different from the constructor\'s defaults.\n   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the\n   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,\n   *        otherwise `RGBA_INTEGER`.\n   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the\n   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to\n   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,\n   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.\n   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]\n   * @returns - The resulting new BaseTexture\n   */\n  static fromBuffer(buffer, width, height, options) {\n    return new Texture_Texture(BaseTexture.fromBuffer(buffer, width, height, options));\n  }\n  /**\n   * Create a texture from a source and add to the cache.\n   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string} source - The input source.\n   * @param imageUrl - File name of texture, for cache and resolving resolution.\n   * @param name - Human readable name for the texture cache. If no name is\n   *        specified, only `imageUrl` will be used as the cache ID.\n   * @param options\n   * @returns - Output texture\n   */\n  static fromLoader(source, imageUrl, name, options) {\n    const baseTexture = new BaseTexture(source, Object.assign({\n      scaleMode: BaseTexture.defaultOptions.scaleMode,\n      resolution: getResolutionOfUrl(imageUrl)\n    }, options)), { resource } = baseTexture;\n    resource instanceof ImageResource && (resource.url = imageUrl);\n    const texture = new Texture_Texture(baseTexture);\n    return name || (name = imageUrl), BaseTexture.addToCache(texture.baseTexture, name), Texture_Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture_Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve) => {\n      texture.baseTexture.once("loaded", () => resolve(texture));\n    });\n  }\n  /**\n   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n   * @param texture - The Texture to add to the cache.\n   * @param id - The id that the Texture will be stored against.\n   */\n  static addToCache(texture, id) {\n    id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), TextureCache[id] && TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), TextureCache[id] = texture);\n  }\n  /**\n   * Remove a Texture from the global TextureCache.\n   * @param texture - id of a Texture to be removed, or a Texture instance itself\n   * @returns - The Texture that was removed\n   */\n  static removeFromCache(texture) {\n    if (typeof texture == "string") {\n      const textureFromCache = TextureCache[texture];\n      if (textureFromCache) {\n        const index = textureFromCache.textureCacheIds.indexOf(texture);\n        return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete TextureCache[texture], textureFromCache;\n      }\n    } else if (texture?.textureCacheIds) {\n      for (let i = 0; i < texture.textureCacheIds.length; ++i)\n        TextureCache[texture.textureCacheIds[i]] === texture && delete TextureCache[texture.textureCacheIds[i]];\n      return texture.textureCacheIds.length = 0, texture;\n    }\n    return null;\n  }\n  /**\n   * Returns resolution of baseTexture\n   * @readonly\n   */\n  get resolution() {\n    return this.baseTexture.resolution;\n  }\n  /**\n   * The frame specifies the region of the base texture that this texture uses.\n   * Please call `updateUvs()` after you change coordinates of `frame` manually.\n   */\n  get frame() {\n    return this._frame;\n  }\n  set frame(frame) {\n    this._frame = frame, this.noFrame = !1;\n    const { x, y, width, height } = frame, xNotFit = x + width > this.baseTexture.width, yNotFit = y + height > this.baseTexture.height;\n    if (xNotFit || yNotFit) {\n      const relationship = xNotFit && yNotFit ? "and" : "or", errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`, errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);\n    }\n    this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();\n  }\n  /**\n   * Indicates whether the texture is rotated inside the atlas\n   * set to 2 to compensate for texture packer rotation\n   * set to 6 to compensate for spine packer rotation\n   * can be used to rotate or mirror sprites\n   * See {@link PIXI.groupD8} for explanation\n   */\n  get rotate() {\n    return this._rotate;\n  }\n  set rotate(rotate) {\n    this._rotate = rotate, this.valid && this.updateUvs();\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Utility function for BaseTexture|Texture cast. */\n  castToBaseTexture() {\n    return this.baseTexture;\n  }\n  /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */\n  static get EMPTY() {\n    return Texture_Texture._EMPTY || (Texture_Texture._EMPTY = new Texture_Texture(new BaseTexture()), removeAllHandlers(Texture_Texture._EMPTY), removeAllHandlers(Texture_Texture._EMPTY.baseTexture)), Texture_Texture._EMPTY;\n  }\n  /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */\n  static get WHITE() {\n    if (!Texture_Texture._WHITE) {\n      const canvas = settings.ADAPTER.createCanvas(16, 16), context = canvas.getContext("2d");\n      canvas.width = 16, canvas.height = 16, context.fillStyle = "white", context.fillRect(0, 0, 16, 16), Texture_Texture._WHITE = new Texture_Texture(BaseTexture.from(canvas)), removeAllHandlers(Texture_Texture._WHITE), removeAllHandlers(Texture_Texture._WHITE.baseTexture);\n    }\n    return Texture_Texture._WHITE;\n  }\n}\n\n//# sourceMappingURL=Texture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs\n\n\nclass RenderTexture extends Texture_Texture {\n  /**\n   * @param baseRenderTexture - The base texture object that this texture uses.\n   * @param frame - The rectangle frame of the texture to show.\n   */\n  constructor(baseRenderTexture, frame) {\n    super(baseRenderTexture, frame), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs();\n  }\n  /**\n   * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.\n   * @readonly\n   */\n  get framebuffer() {\n    return this.baseTexture.framebuffer;\n  }\n  /**\n   * Shortcut to `this.framebuffer.multisample`.\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  get multisample() {\n    return this.framebuffer.multisample;\n  }\n  set multisample(value) {\n    this.framebuffer.multisample = value;\n  }\n  /**\n   * Resizes the RenderTexture.\n   * @param desiredWidth - The desired width to resize to.\n   * @param desiredHeight - The desired height to resize to.\n   * @param resizeBaseTexture - Should the baseTexture.width and height values be resized as well?\n   */\n  resize(desiredWidth, desiredHeight, resizeBaseTexture = !0) {\n    const resolution = this.baseTexture.resolution, width = Math.round(desiredWidth * resolution) / resolution, height = Math.round(desiredHeight * resolution) / resolution;\n    this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs();\n  }\n  /**\n   * Changes the resolution of baseTexture, but does not change framebuffer size.\n   * @param resolution - The new resolution to apply to RenderTexture\n   */\n  setResolution(resolution) {\n    const { baseTexture } = this;\n    baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, !1));\n  }\n  /**\n   * A short hand way of creating a render texture.\n   * @param options - Options\n   * @param {number} [options.width=100] - The width of the render texture\n   * @param {number} [options.height=100] - The height of the render texture\n   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}\n   *    for possible values\n   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the texture\n   *    being generated\n   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer\n   * @returns The new render texture\n   */\n  static create(options) {\n    return new RenderTexture(new BaseRenderTexture(options));\n  }\n}\n\n//# sourceMappingURL=RenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs\n\n\n\n\nclass RenderTexturePool {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.\n   */\n  constructor(textureOptions) {\n    this.texturePool = {}, this.textureOptions = textureOptions || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param realWidth - Width of texture in pixels.\n   * @param realHeight - Height of texture in pixels.\n   * @param multisample - Number of samples of the framebuffer.\n   */\n  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {\n    const baseRenderTexture = new BaseRenderTexture(Object.assign({\n      width: realWidth,\n      height: realHeight,\n      resolution: 1,\n      multisample\n    }, this.textureOptions));\n    return new RenderTexture(baseRenderTexture);\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param multisample - Number of samples of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {\n    let key;\n    minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1), minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1), !this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight ? (minWidth = nextPow2(minWidth), minHeight = nextPow2(minHeight), key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, multisample > 1 && (key += multisample * 4294967296)) : key = multisample > 1 ? -multisample : -1, this.texturePool[key] || (this.texturePool[key] = []);\n    let renderTexture = this.texturePool[key].pop();\n    return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   *\n   * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`\n   * @param input - renderTexture from which size and resolution will be copied\n   * @param resolution - override resolution of the renderTexture\n   *  It overrides, it does not multiply\n   * @param multisample - number of samples of the renderTexture\n   */\n  getFilterTexture(input, resolution, multisample) {\n    const filterTexture = this.getOptimalTexture(\n      input.width,\n      input.height,\n      resolution || input.resolution,\n      multisample || MSAA_QUALITY.NONE\n    );\n    return filterTexture.filterFrame = input.filterFrame, filterTexture;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = renderTexture.filterPoolKey;\n    renderTexture.filterFrame = null, this.texturePool[key].push(renderTexture);\n  }\n  /**\n   * Alias for returnTexture, to be compliant with FilterSystem interface.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnFilterTexture(renderTexture) {\n    this.returnTexture(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    if (destroyTextures = destroyTextures !== !1, destroyTextures)\n      for (const i in this.texturePool) {\n        const textures = this.texturePool[i];\n        if (textures)\n          for (let j = 0; j < textures.length; j++)\n            textures[j].destroy(!0);\n      }\n    this.texturePool = {};\n  }\n  /**\n   * If screen size was changed, drops all screen-sized textures,\n   * sets new screen size, sets `enableFullScreen` to true\n   *\n   * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`\n   * @param size - Initial size of screen.\n   */\n  setScreenSize(size) {\n    if (!(size.width === this._pixelsWidth && size.height === this._pixelsHeight)) {\n      this.enableFullScreen = size.width > 0 && size.height > 0;\n      for (const i in this.texturePool) {\n        if (!(Number(i) < 0))\n          continue;\n        const textures = this.texturePool[i];\n        if (textures)\n          for (let j = 0; j < textures.length; j++)\n            textures[j].destroy(!0);\n        this.texturePool[i] = [];\n      }\n      this._pixelsWidth = size.width, this._pixelsHeight = size.height;\n    }\n  }\n}\nRenderTexturePool.SCREEN_KEY = -1;\n\n//# sourceMappingURL=RenderTexturePool.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/Quad.mjs\n\nclass Quad extends Geometry {\n  constructor() {\n    super(), this.addAttribute("aVertexPosition", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]);\n  }\n}\n\n//# sourceMappingURL=Quad.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/QuadUv.mjs\n\n\nclass QuadUv extends Geometry {\n  constructor() {\n    super(), this.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]), this.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]), this.vertexBuffer = new Buffer(this.vertices), this.uvBuffer = new Buffer(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);\n  }\n  /**\n   * Maps two Rectangle to the quad.\n   * @param targetTextureFrame - The first rectangle\n   * @param destinationFrame - The second rectangle\n   * @returns - Returns itself.\n   */\n  map(targetTextureFrame, destinationFrame) {\n    let x = 0, y = 0;\n    return this.uvs[0] = x, this.uvs[1] = y, this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y, this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x, this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height, x = destinationFrame.x, y = destinationFrame.y, this.vertices[0] = x, this.vertices[1] = y, this.vertices[2] = x + destinationFrame.width, this.vertices[3] = y, this.vertices[4] = x + destinationFrame.width, this.vertices[5] = y + destinationFrame.height, this.vertices[6] = x, this.vertices[7] = y + destinationFrame.height, this.invalidate(), this;\n  }\n  /**\n   * Legacy upload method, just marks buffers dirty.\n   * @returns - Returns itself.\n   */\n  invalidate() {\n    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n  }\n}\n\n//# sourceMappingURL=QuadUv.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterState.mjs\n\n\nclass FilterState {\n  constructor() {\n    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle_Rectangle(), this.destinationFrame = new Rectangle_Rectangle(), this.bindingSourceFrame = new Rectangle_Rectangle(), this.bindingDestinationFrame = new Rectangle_Rectangle(), this.filters = [], this.transform = null;\n  }\n  /** Clears the state */\n  clear() {\n    this.target = null, this.filters = null, this.renderTexture = null;\n  }\n}\n\n//# sourceMappingURL=FilterState.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\nconst FilterSystem_tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix = new Matrix();\nclass FilterSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle_Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle_Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      // legacy variables\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n   * input render-texture for the rest of the filtering pipeline.\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param filters - The filters to apply.\n   */\n  push(target, filters) {\n    const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState(), renderTextureSystem = renderer.renderTexture;\n    let currentResolution, currentMultisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;\n    } else\n      currentResolution = renderer.resolution, currentMultisample = renderer.multisample;\n    let resolution = filters[0].resolution || currentResolution, multisample = filters[0].multisample ?? currentMultisample, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy ?? !0;\n    for (let i = 1; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? !0);\n    }\n    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0)), state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    renderer.projection.transform && this.transformAABB(\n      tempMatrix.copyFrom(renderer.projection.transform).invert(),\n      sourceFrameProjected\n    ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(\n      state.sourceFrame,\n      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n      renderTextureSystem.sourceFrame,\n      renderTextureSystem.destinationFrame,\n      renderer.projection.transform\n    ), state.renderTexture = this.getOptimalFilterTexture(\n      state.sourceFrame.width,\n      state.sourceFrame.height,\n      resolution,\n      multisample\n    ), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /** Pops off the filter and applies it. */\n  pop() {\n    const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;\n    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    if (this.renderer.framebuffer.blit(), filters.length === 1)\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);\n    else {\n      let flip = state.renderTexture, flop = this.getOptimalFilterTexture(\n        flip.width,\n        flip.height,\n        state.resolution\n      );\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        i === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(\n          flip.width,\n          flip.height,\n          state.resolution\n        ), flop.filterFrame = flip.filterFrame), filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n        const t = flip;\n        flip = flop, flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state), i > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);\n    }\n    state.clear(), this.statePool.push(state);\n  }\n  /**\n   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n   */\n  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else\n      filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(\n        filterTexture,\n        this.activeState.bindingSourceFrame,\n        this.activeState.bindingDestinationFrame\n      );\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  /**\n   * Draws a filter using the default rendering process.\n   *\n   * This should be called only by {@link PIXI.Filter#apply}.\n   * @param filter - The filter to draw.\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(\n      destinationFrame.width,\n      0,\n      0,\n      destinationFrame.height,\n      sourceFrame.x,\n      sourceFrame.y\n    ), worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;\n  }\n  /** Destroys this Filter System. */\n  destroy() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture in real pixels.\n   * @param minHeight - The minimum height of the render texture in real pixels.\n   * @param resolution - The resolution of the render texture.\n   * @param multisample - Number of samples of the render texture.\n   * @returns - The new render texture.\n   */\n  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  /**\n   * Gets extra render texture to use inside current filter\n   * To be compliant with older filters, you can use params in any order\n   * @param input - renderTexture from which size and resolution will be copied\n   * @param resolution - override resolution of the renderTexture\n   * @param multisample - number of samples of the renderTexture\n   */\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input == "number") {\n      const swap = input;\n      input = resolution, resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(\n      input.width,\n      input.height,\n      resolution || input.resolution,\n      multisample || MSAA_QUALITY.NONE\n    );\n    return filterTexture.filterFrame = input.filterFrame, filterTexture;\n  }\n  /**\n   * Frees a render texture back into the pool.\n   * @param renderTexture - The renderTarget to free\n   */\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  /** Empties the texture pool. */\n  emptyPool() {\n    this.texturePool.clear(!0);\n  }\n  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  /**\n   * @param matrix - first param\n   * @param rect - second param\n   */\n  transformAABB(matrix, rect) {\n    const lt = FilterSystem_tempPoints[0], lb = FilterSystem_tempPoints[1], rt = FilterSystem_tempPoints[2], rb = FilterSystem_tempPoints[3];\n    lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x), y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x), y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {\n      if (transform) {\n        const { a, b, c, d } = transform;\n        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n          return;\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(\n        bindingDestinationFrame.width / bindingSourceFrame.width,\n        bindingDestinationFrame.height / bindingSourceFrame.height\n      ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform, frame), frame.ceil(resolution), this.transformAABB(transform.invert(), frame);\n    }\n  }\n}\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "filter"\n};\nextensions.add(FilterSystem);\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs\n\nclass GLFramebuffer {\n  constructor(framebuffer) {\n    this.framebuffer = framebuffer, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n  }\n}\n\n//# sourceMappingURL=GLFramebuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs\n\n\n\n\n\n\nconst tempRectangle = new Rectangle_Rectangle();\nclass FramebufferSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.disposeAll(!0);\n    const gl = this.gl = this.renderer.gl;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle_Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {\n      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;\n      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null), nativeDrawBuffersExtension ? gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = !1, gl.drawBuffers = () => {\n      }), nativeDepthTextureExtension || (this.writeDepthTexture = !1);\n    } else\n      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);\n  }\n  /**\n   * Bind a framebuffer.\n   * @param framebuffer\n   * @param frame - frame, default is framebuffer size\n   * @param mipLevel - optional mip level to set on the framebuffer - defaults to 0\n   */\n  bind(framebuffer, frame, mipLevel = 0) {\n    const { gl } = this;\n    if (framebuffer) {\n      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);\n      this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer)), fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));\n      for (let i = 0; i < framebuffer.colorTextures.length; i++) {\n        const tex = framebuffer.colorTextures[i];\n        this.renderer.texture.unbind(tex.parentTextureArray || tex);\n      }\n      if (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) {\n        const mipWidth = frame.width >> mipLevel, mipHeight = frame.height >> mipLevel, scale = mipWidth / frame.width;\n        this.setViewport(\n          frame.x * scale,\n          frame.y * scale,\n          mipWidth,\n          mipHeight\n        );\n      } else {\n        const mipWidth = framebuffer.width >> mipLevel, mipHeight = framebuffer.height >> mipLevel;\n        this.setViewport(0, 0, mipWidth, mipHeight);\n      }\n    } else\n      this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n  }\n  /**\n   * Set the WebGLRenderingContext\'s viewport.\n   * @param x - X position of viewport\n   * @param y - Y position of viewport\n   * @param width - Width of viewport\n   * @param height - Height of viewport\n   */\n  setViewport(x, y, width, height) {\n    const v = this.viewport;\n    x = Math.round(x), y = Math.round(y), width = Math.round(width), height = Math.round(height), (v.width !== width || v.height !== height || v.x !== x || v.y !== y) && (v.x = x, v.y = y, v.width = width, v.height = height, this.gl.viewport(x, y, width, height));\n  }\n  /**\n   * Get the size of the current width and height. Returns object with `width` and `height` values.\n   * @readonly\n   */\n  get size() {\n    return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n  }\n  /**\n   * Clear the color of the context\n   * @param r - Red value from 0 to 1\n   * @param g - Green value from 0 to 1\n   * @param b - Blue value from 0 to 1\n   * @param a - Alpha value from 0 to 1\n   * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n   */\n  clear(r, g, b, a, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {\n    const { gl } = this;\n    gl.clearColor(r, g, b, a), gl.clear(mask);\n  }\n  /**\n   * Initialize framebuffer for this context\n   * @protected\n   * @param framebuffer\n   * @returns - created GLFramebuffer\n   */\n  initFramebuffer(framebuffer) {\n    const { gl } = this, fbo = new GLFramebuffer(gl.createFramebuffer());\n    return fbo.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo;\n  }\n  /**\n   * Resize the framebuffer\n   * @param framebuffer\n   * @protected\n   */\n  resizeFramebuffer(framebuffer) {\n    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (fbo.stencil) {\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      let stencilFormat;\n      this.renderer.context.webGLVersion === 1 ? stencilFormat = gl.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl.DEPTH_COMPONENT24 : stencilFormat = gl.STENCIL_INDEX8, fbo.msaaBuffer ? gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        stencilFormat,\n        framebuffer.width,\n        framebuffer.height\n      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);\n    }\n    const colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    gl.drawBuffers || (count = Math.min(count, 1));\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0), i === 0 && fbo.msaaBuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,\n        framebuffer.width,\n        framebuffer.height\n      ));\n    }\n    framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);\n  }\n  /**\n   * Update the framebuffer\n   * @param framebuffer\n   * @param mipLevel\n   * @protected\n   */\n  updateFramebuffer(framebuffer, mipLevel) {\n    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    gl.drawBuffers || (count = Math.min(count, 1)), fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer() : fbo.msaaBuffer && (gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));\n    const activeTextures = [];\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0), i === 0 && fbo.msaaBuffer ? (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,\n        framebuffer.width,\n        framebuffer.height\n      ), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer)) : (gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0 + i,\n        texture.target,\n        parentTexture._glTextures[this.CONTEXT_UID].texture,\n        mipLevel\n      ), activeTextures.push(gl.COLOR_ATTACHMENT0 + i));\n    }\n    if (activeTextures.length > 1 && gl.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {\n      const depthTexture = framebuffer.depthTexture;\n      this.renderer.texture.bind(depthTexture, 0), gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_ATTACHMENT,\n        gl.TEXTURE_2D,\n        depthTexture._glTextures[this.CONTEXT_UID].texture,\n        mipLevel\n      );\n    }\n    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {\n      fbo.stencil = fbo.stencil || gl.createRenderbuffer();\n      let stencilAttachment, stencilFormat;\n      this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_ATTACHMENT, stencilFormat = gl.DEPTH_COMPONENT24) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        fbo.multisample,\n        stencilFormat,\n        framebuffer.width,\n        framebuffer.height\n      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, fbo.stencil);\n    } else\n      fbo.stencil && (gl.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);\n  }\n  /**\n   * Returns true if the frame buffer can be multisampled.\n   * @param framebuffer\n   */\n  canMultisampleFramebuffer(framebuffer) {\n    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;\n  }\n  /**\n   * Detects number of samples that is not more than a param but as close to it as possible\n   * @param samples - number of samples\n   * @returns - recommended number of samples\n   */\n  detectSamples(samples) {\n    const { msaaSamples } = this;\n    let res = MSAA_QUALITY.NONE;\n    if (samples <= 1 || msaaSamples === null)\n      return res;\n    for (let i = 0; i < msaaSamples.length; i++)\n      if (msaaSamples[i] <= samples) {\n        res = msaaSamples[i];\n        break;\n      }\n    return res === 1 && (res = MSAA_QUALITY.NONE), res;\n  }\n  /**\n   * Only works with WebGL2\n   *\n   * blits framebuffer to another of the same or bigger size\n   * after that target framebuffer is bound\n   *\n   * Fails with WebGL warning if blits multisample framebuffer to different size\n   * @param framebuffer - by default it blits "into itself", from renderBuffer to texture.\n   * @param sourcePixels - source rectangle in pixels\n   * @param destPixels - dest rectangle in pixels, assumed to be the same as sourcePixels\n   */\n  blit(framebuffer, sourcePixels, destPixels) {\n    const { current, renderer, gl, CONTEXT_UID } = this;\n    if (renderer.context.webGLVersion !== 2 || !current)\n      return;\n    const fbo = current.glFramebuffers[CONTEXT_UID];\n    if (!fbo)\n      return;\n    if (!framebuffer) {\n      if (!fbo.msaaBuffer)\n        return;\n      const colorTexture = current.colorTextures[0];\n      if (!colorTexture)\n        return;\n      fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture)), framebuffer = fbo.blitFramebuffer, framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++), (framebuffer.width !== current.width || framebuffer.height !== current.height) && (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);\n    }\n    sourcePixels || (sourcePixels = tempRectangle, sourcePixels.width = current.width, sourcePixels.height = current.height), destPixels || (destPixels = sourcePixels);\n    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;\n    this.bind(framebuffer), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer), gl.blitFramebuffer(\n      sourcePixels.left,\n      sourcePixels.top,\n      sourcePixels.right,\n      sourcePixels.bottom,\n      destPixels.left,\n      destPixels.top,\n      destPixels.right,\n      destPixels.bottom,\n      gl.COLOR_BUFFER_BIT,\n      sameSize ? gl.NEAREST : gl.LINEAR\n    ), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);\n  }\n  /**\n   * Disposes framebuffer.\n   * @param framebuffer - framebuffer that has to be disposed of\n   * @param contextLost - If context was lost, we suppress all delete function calls\n   */\n  disposeFramebuffer(framebuffer, contextLost) {\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl = this.gl;\n    if (!fbo)\n      return;\n    delete framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const index = this.managedFramebuffers.indexOf(framebuffer);\n    index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil)), fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);\n  }\n  /**\n   * Disposes all framebuffers, but not textures bound to them.\n   * @param [contextLost=false] - If context was lost, we suppress all delete function calls\n   */\n  disposeAll(contextLost) {\n    const list = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (let i = 0; i < list.length; i++)\n      this.disposeFramebuffer(list[i], contextLost);\n  }\n  /**\n   * Forcing creation of stencil buffer for current framebuffer, if it wasn\'t done before.\n   * Used by MaskSystem, when its time to use stencil mask for Graphics element.\n   *\n   * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.\n   * @private\n   */\n  forceStencil() {\n    const framebuffer = this.current;\n    if (!framebuffer)\n      return;\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (!fbo || fbo.stencil && framebuffer.stencil)\n      return;\n    framebuffer.stencil = !0;\n    const w = framebuffer.width, h = framebuffer.height, gl = this.gl, stencil = fbo.stencil = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);\n    let stencilAttachment, stencilFormat;\n    this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, w, h) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, w, h), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, stencil);\n  }\n  /** Resets framebuffer stored state, binds screen framebuffer. Should be called before renderTexture reset(). */\n  reset() {\n    this.current = this.unknownFramebuffer, this.viewport = new Rectangle_Rectangle();\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nFramebufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "framebuffer"\n};\nextensions.add(FramebufferSystem);\n\n//# sourceMappingURL=FramebufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs\n\n\n\nconst GeometrySystem_byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nclass GeometrySystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.disposeAll(!0);\n    const gl = this.gl = this.renderer.gl, context = this.renderer.context;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, context.webGLVersion !== 2) {\n      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao), gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = !1, gl.createVertexArray = () => null, gl.bindVertexArray = () => null, gl.deleteVertexArray = () => null);\n    }\n    if (context.webGLVersion !== 2) {\n      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");\n      instanceExt ? (gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b), gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e), gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d)) : this.hasInstance = !1;\n    }\n    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n  }\n  /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param shader - Instance of shader to use vao for.\n   */\n  bind(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    const { gl } = this;\n    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], incRefCount = !1;\n    vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = !0);\n    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers();\n  }\n  /** Reset and unbind any active VAO and geometry. */\n  reset() {\n    this.unbind();\n  }\n  /** Update buffers of the currently bound geometry. */\n  updateBuffers() {\n    const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.update(buffer);\n    }\n  }\n  /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes, shaderAttributes = program.attributeData;\n    for (const j in shaderAttributes)\n      if (!geometryAttributes[j])\n        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);\n  }\n  /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes, shaderAttributes = program.attributeData, strings = ["g", geometry.id];\n    for (const i in attribs)\n      shaderAttributes[i] && strings.push(i, shaderAttributes[i].location);\n    return strings.join("-");\n  }\n  /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param shader - Instance of the shader.\n   * @param incRefCount - Increment refCount of all geometry buffers.\n   */\n  initGeometryVao(geometry, shader, incRefCount = !0) {\n    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;\n    program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader), this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program), vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let vao = vaoObjectHash[signature];\n    if (vao)\n      return vaoObjectHash[program.id] = vao, vao;\n    const buffers = geometry.buffers, attributes = geometry.attributes, tempStride = {}, tempStart = {};\n    for (const j in buffers)\n      tempStride[j] = 0, tempStart[j] = 0;\n    for (const j in attributes)\n      !attributes[j].size && program.attributeData[j] ? attributes[j].size = program.attributeData[j].size : attributes[j].size || console.warn(`PIXI Geometry attribute \'${j}\' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[attributes[j].buffer] += attributes[j].size * GeometrySystem_byteSizeMap[attributes[j].type];\n    for (const j in attributes) {\n      const attribute = attributes[j], attribSize = attribute.size;\n      attribute.stride === void 0 && (tempStride[attribute.buffer] === attribSize * GeometrySystem_byteSizeMap[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), attribute.start === void 0 && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * GeometrySystem_byteSizeMap[attribute.type]);\n    }\n    vao = gl.createVertexArray(), gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer), incRefCount && buffer._glBuffers[CONTEXT_UID].refCount++;\n    }\n    return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao, gl.bindVertexArray(null), bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER), vao;\n  }\n  /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  disposeGeometry(geometry, contextLost) {\n    if (!this.managedGeometries[geometry.id])\n      return;\n    delete this.managedGeometries[geometry.id];\n    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;\n    if (geometry.disposeRunner.remove(this), !!vaos) {\n      if (bufferSystem)\n        for (let i = 0; i < buffers.length; i++) {\n          const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n          buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffers[i], contextLost));\n        }\n      if (!contextLost) {\n        for (const vaoId in vaos)\n          if (vaoId[0] === "g") {\n            const vao = vaos[vaoId];\n            this._activeVao === vao && this.unbind(), gl.deleteVertexArray(vao);\n          }\n      }\n      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n  }\n  /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedGeometries);\n    for (let i = 0; i < all.length; i++)\n      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n  }\n  /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */\n  activateVao(geometry, program) {\n    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;\n    geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j], buffer = buffers[attribute.buffer], glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j]) {\n        lastBuffer !== glBuffer && (bufferSystem.bind(buffer), lastBuffer = glBuffer);\n        const location = program.attributeData[j].location;\n        if (gl.enableVertexAttribArray(location), gl.vertexAttribPointer(\n          location,\n          attribute.size,\n          attribute.type || gl.FLOAT,\n          attribute.normalized,\n          attribute.stride,\n          attribute.start\n        ), attribute.instance)\n          if (this.hasInstance)\n            gl.vertexAttribDivisor(location, attribute.divisor);\n          else\n            throw new Error("geometry error, GPU Instancing is not supported on this device");\n      }\n    }\n  }\n  /**\n   * Draws the currently bound geometry.\n   * @param type - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */\n  draw(type, size, start, instanceCount) {\n    const { gl } = this, geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn("unsupported index buffer type: uint32");\n    } else\n      geometry.instanced ? gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type, start, size || geometry.getSize());\n    return this;\n  }\n  /** Unbind/reset everything. */\n  unbind() {\n    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nGeometrySystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "geometry"\n};\nextensions.add(GeometrySystem);\n\n//# sourceMappingURL=GeometrySystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs\n\nconst tempMat = new Matrix();\nclass TextureMatrix_TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this._texture = texture, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > "u" ? 0.5 : clampMargin, this.isSimple = !1;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture = value, this._textureID = -1;\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    out === void 0 && (out = uvs);\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i], y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx, out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed.\n   * @param [forceUpdate=false] - if true, matrices will be updated any case\n   * @returns - Whether or not it was updated\n   */\n  update(forceUpdate) {\n    const tex = this._texture;\n    if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)\n      return !1;\n    this._textureID = tex._updateID, this._updateID++;\n    const uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig, trim = tex.trim;\n    trim && (tempMat.set(\n      orig.width / trim.width,\n      0,\n      0,\n      orig.height / trim.height,\n      -trim.x / trim.width,\n      -trim.y / trim.height\n    ), this.mapCoord.append(tempMat));\n    const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset = this.clampOffset;\n    return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, !0;\n  }\n}\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.mjs\nvar fragment = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`;\n\n//# sourceMappingURL=spriteMaskFilter.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.mjs\nvar vertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`;\n\n//# sourceMappingURL=spriteMaskFilter.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs\n\n\n\n\n\nclass SpriteMaskFilter extends Filter {\n  /** @ignore */\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    let sprite = null;\n    typeof vertexSrc != "string" && fragmentSrc === void 0 && uniforms === void 0 && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0), super(vertexSrc || vertex, fragmentSrc || fragment, uniforms), this.maskSprite = sprite, this.maskMatrix = new Matrix();\n  }\n  /**\n   * Sprite mask\n   * @type {PIXI.DisplayObject}\n   */\n  get maskSprite() {\n    return this._maskSprite;\n  }\n  set maskSprite(value) {\n    this._maskSprite = value, this._maskSprite && (this._maskSprite.renderable = !1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it.\n   */\n  apply(filterManager, input, output, clearMode) {\n    const maskSprite = this._maskSprite, tex = maskSprite._texture;\n    tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix_TextureMatrix(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));\n  }\n}\n\n//# sourceMappingURL=SpriteMaskFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskData.mjs\n\n\nclass MaskData {\n  /**\n   * Create MaskData\n   * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n   */\n  constructor(maskObject = null) {\n    this.type = MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = maskObject || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = Filter.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n  }\n  /**\n   * The sprite mask filter.\n   * If set to `null`, the default sprite mask filter is used.\n   * @default null\n   */\n  get filter() {\n    return this._filters ? this._filters[0] : null;\n  }\n  set filter(value) {\n    value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;\n  }\n  /** Resets the mask data after popMask(). */\n  reset() {\n    this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n  }\n  /**\n   * Copies counters from maskData above, called from pushMask().\n   * @param maskAbove\n   */\n  copyCountersOrReset(maskAbove) {\n    maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n  }\n}\n\n//# sourceMappingURL=MaskData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskSystem.mjs\n\n\n\n\nclass MaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n  }\n  /**\n   * Changes the mask stack that is used by this System.\n   * @param maskStack - The mask stack\n   */\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);\n  }\n  /**\n   * Enables the mask and appends it to the current mask stack.\n   *\n   * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.\n   * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n   * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.\n   */\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData();\n      d.pooled = !0, d.maskObject = maskDataOrTarget, maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)\n      switch (maskData.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case MASK_TYPES.SPRITE:\n          maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);\n          break;\n        case MASK_TYPES.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    maskData.type === MASK_TYPES.SPRITE && this.maskStack.push(maskData);\n  }\n  /**\n   * Removes the last mask from the mask stack and doesn\'t return it.\n   *\n   * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.\n   * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from\n   */\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!(!maskData || maskData._target !== target)) {\n      if (maskData.enabled)\n        switch (maskData.type) {\n          case MASK_TYPES.SCISSOR:\n            this.renderer.scissor.pop(maskData);\n            break;\n          case MASK_TYPES.STENCIL:\n            this.renderer.stencil.pop(maskData.maskObject);\n            break;\n          case MASK_TYPES.SPRITE:\n            this.popSpriteMask(maskData);\n            break;\n          case MASK_TYPES.COLOR:\n            this.popColorMask(maskData);\n            break;\n          default:\n            break;\n        }\n      if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {\n        const maskCurrent = this.maskStack[this.maskStack.length - 1];\n        maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);\n      }\n    }\n  }\n  /**\n   * Sets type of MaskData based on its maskObject.\n   * @param maskData\n   */\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    maskObject ? maskObject.isSprite ? maskData.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = MASK_TYPES.SCISSOR : maskData.type = MASK_TYPES.STENCIL : maskData.type = MASK_TYPES.COLOR;\n  }\n  /**\n   * Applies the Mask and adds it to the current filter stack.\n   * @param maskData - Sprite to be used as the mask.\n   */\n  pushSpriteMask(maskData) {\n    const { maskObject } = maskData, target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(!0), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;\n  }\n  /**\n   * Removes the last filter from the filter stack and doesn\'t return it.\n   * @param maskData - Sprite to be used as the mask.\n   */\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n  }\n  /**\n   * Pushes the color mask.\n   * @param maskData - The mask data\n   */\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    nextColorMask !== currColorMask && this.renderer.gl.colorMask(\n      (nextColorMask & 1) !== 0,\n      (nextColorMask & 2) !== 0,\n      (nextColorMask & 4) !== 0,\n      (nextColorMask & 8) !== 0\n    );\n  }\n  /**\n   * Pops the color mask.\n   * @param maskData - The mask data\n   */\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    nextColorMask !== currColorMask && this.renderer.gl.colorMask(\n      (nextColorMask & 1) !== 0,\n      (nextColorMask & 2) !== 0,\n      (nextColorMask & 4) !== 0,\n      (nextColorMask & 8) !== 0\n    );\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "mask"\n};\nextensions.add(MaskSystem);\n\n//# sourceMappingURL=MaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs\nclass AbstractMaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.maskStack = [], this.glConst = 0;\n  }\n  /** Gets count of masks of certain type. */\n  getStackLength() {\n    return this.maskStack.length;\n  }\n  /**\n   * Changes the mask stack that is used by this System.\n   * @param {PIXI.MaskData[]} maskStack - The mask stack\n   */\n  setMaskStack(maskStack) {\n    const { gl } = this.renderer, curStackLen = this.getStackLength();\n    this.maskStack = maskStack;\n    const newStackLen = this.getStackLength();\n    newStackLen !== curStackLen && (newStackLen === 0 ? gl.disable(this.glConst) : (gl.enable(this.glConst), this._useCurrent()));\n  }\n  /**\n   * Setup renderer to use the current mask data.\n   * @private\n   */\n  _useCurrent() {\n  }\n  /** Destroys the mask stack. */\n  destroy() {\n    this.renderer = null, this.maskStack = null;\n  }\n}\n\n//# sourceMappingURL=AbstractMaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs\n\n\n\n\nconst ScissorSystem_tempMatrix = new Matrix(), rectPool = [], _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem {\n  /**\n   * @param {PIXI.Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    return maskData ? maskData._scissorCounter : 0;\n  }\n  /**\n   * evaluates _boundsTransformed, _scissorRect for MaskData\n   * @param maskData\n   */\n  calcScissorRect(maskData) {\n    if (maskData._scissorRectLocal)\n      return;\n    const prevData = maskData._scissorRect, { maskObject } = maskData, { renderer } = this, renderTextureSystem = renderer.renderTexture, rect = maskObject.getBounds(!0, rectPool.pop() ?? new Rectangle_Rectangle());\n    this.roundFrameToPixels(\n      rect,\n      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n      renderTextureSystem.sourceFrame,\n      renderTextureSystem.destinationFrame,\n      renderer.projection.transform\n    ), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;\n  }\n  static isMatrixRotated(matrix) {\n    if (!matrix)\n      return !1;\n    const { a, b, c, d } = matrix;\n    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n  }\n  /**\n   * Test, whether the object can be scissor mask with current renderer projection.\n   * Calls "calcScissorRect()" if its true.\n   * @param maskData - mask data\n   * @returns whether Whether the object can be scissor mask\n   */\n  testScissor(maskData) {\n    const { maskObject } = maskData;\n    if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))\n      return !1;\n    this.calcScissorRect(maskData);\n    const rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  }\n  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    _ScissorSystem2.isMatrixRotated(transform) || (transform = transform ? ScissorSystem_tempMatrix.copyFrom(transform) : ScissorSystem_tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(\n      bindingDestinationFrame.width / bindingSourceFrame.width,\n      bindingDestinationFrame.height / bindingSourceFrame.height\n    ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));\n  }\n  /**\n   * Applies the Mask and adds it to the current stencil stack.\n   * @author alvin\n   * @param maskData - The mask data.\n   */\n  push(maskData) {\n    maskData._scissorRectLocal || this.calcScissorRect(maskData);\n    const { gl } = this.renderer;\n    maskData._scissorRect || gl.enable(gl.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();\n  }\n  /**\n   * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n   * last mask in the stack.\n   *\n   * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n   * @param maskData - The mask data.\n   */\n  pop(maskData) {\n    const { gl } = this.renderer;\n    maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);\n  }\n  /**\n   * Setup renderer to use the current scissor data.\n   * @private\n   */\n  _useCurrent() {\n    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    let y;\n    this.renderer.renderTexture.current ? y = rect.y : y = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n  }\n};\n_ScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "scissor"\n};\nlet ScissorSystem = _ScissorSystem;\nextensions.add(ScissorSystem);\n\n//# sourceMappingURL=ScissorSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/StencilSystem.mjs\n\n\n\nclass StencilSystem extends AbstractMaskSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    return maskData ? maskData._stencilCounter : 0;\n  }\n  /**\n   * Applies the Mask and adds it to the current stencil stack.\n   * @param maskData - The mask data\n   */\n  push(maskData) {\n    const maskObject = maskData.maskObject, { gl } = this.renderer, prevMaskCount = maskData._stencilCounter;\n    prevMaskCount === 0 && (this.renderer.framebuffer.forceStencil(), gl.clearStencil(0), gl.clear(gl.STENCIL_BUFFER_BIT), gl.enable(gl.STENCIL_TEST)), maskData._stencilCounter++;\n    const colorMask = maskData._colorMask;\n    colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(!1, !1, !1, !1)), gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR), maskObject.renderable = !0, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = !1, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(\n      (colorMask & 1) !== 0,\n      (colorMask & 2) !== 0,\n      (colorMask & 4) !== 0,\n      (colorMask & 8) !== 0\n    )), this._useCurrent();\n  }\n  /**\n   * Pops stencil mask. MaskData is already removed from stack\n   * @param {PIXI.DisplayObject} maskObject - object of popped mask data\n   */\n  pop(maskObject) {\n    const gl = this.renderer.gl;\n    if (this.getStackLength() === 0)\n      gl.disable(gl.STENCIL_TEST);\n    else {\n      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, colorMask = maskData ? maskData._colorMask : 15;\n      colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(!1, !1, !1, !1)), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR), maskObject.renderable = !0, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = !1, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(\n        (colorMask & 1) !== 0,\n        (colorMask & 2) !== 0,\n        (colorMask & 4) !== 0,\n        (colorMask & 8) !== 0\n      )), this._useCurrent();\n    }\n  }\n  /**\n   * Setup renderer to use the current stencil data.\n   * @private\n   */\n  _useCurrent() {\n    const gl = this.renderer.gl;\n    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n  }\n}\nStencilSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "stencil"\n};\nextensions.add(StencilSystem);\n\n//# sourceMappingURL=StencilSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs\n\n\nclass PluginSystem {\n  constructor(renderer) {\n    this.renderer = renderer, this.plugins = {}, Object.defineProperties(this.plugins, {\n      extract: {\n        enumerable: !1,\n        get() {\n          return deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), renderer.extract;\n        }\n      },\n      prepare: {\n        enumerable: !1,\n        get() {\n          return deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), renderer.prepare;\n        }\n      },\n      interaction: {\n        enumerable: !1,\n        get() {\n          return deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), renderer.events;\n        }\n      }\n    });\n  }\n  /**\n   * Initialize the plugins.\n   * @protected\n   */\n  init() {\n    const staticMap = this.rendererPlugins;\n    for (const o in staticMap)\n      this.plugins[o] = new staticMap[o](this.renderer);\n  }\n  destroy() {\n    for (const o in this.plugins)\n      this.plugins[o].destroy(), this.plugins[o] = null;\n  }\n}\nPluginSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "_plugin"\n};\nextensions.add(PluginSystem);\n\n//# sourceMappingURL=PluginSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs\n\n\nclass ProjectionSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;\n  }\n  /**\n   * Updates the projection-matrix based on the sourceFrame → destinationFrame mapping provided.\n   *\n   * NOTE: It is expected you call `renderer.framebuffer.setViewport(destinationFrame)` after this. This is because\n   * the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates.\n   *\n   * NOTE-2: {@link PIXI.RenderTextureSystem#bind} updates the projection-matrix when you bind a render-texture.\n   * It is expected\n   * that you dirty the current bindings when calling this manually.\n   * @param destinationFrame - The rectangle in the render-target to render the contents into. If rendering to the canvas,\n   *  the origin is on the top-left; if rendering to a render-texture, the origin is on the bottom-left.\n   * @param sourceFrame - The rectangle in world space that contains the contents being rendered.\n   * @param resolution - The resolution of the render-target, which is the ratio of\n   *  world-space (or CSS) pixels to physical pixels.\n   * @param root - Whether the render-target is the screen. This is required because rendering to textures\n   *  is y-flipped (i.e. upside down relative to the screen).\n   */\n  update(destinationFrame, sourceFrame, resolution, root) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform);\n    const renderer = this.renderer;\n    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);\n  }\n  /**\n   * Calculates the `projectionMatrix` to map points inside `sourceFrame` to inside `destinationFrame`.\n   * @param _destinationFrame - The destination frame in the render-target.\n   * @param sourceFrame - The source frame in world space.\n   * @param _resolution - The render-target\'s resolution, i.e. ratio of CSS to physical pixels.\n   * @param root - Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection\n   *  is y-flipped.\n   */\n  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {\n    const pm = this.projectionMatrix, sign = root ? -1 : 1;\n    pm.identity(), pm.a = 1 / sourceFrame.width * 2, pm.d = sign * (1 / sourceFrame.height * 2), pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -sign - sourceFrame.y * pm.d;\n  }\n  /**\n   * Sets the transform of the active render target to the given matrix.\n   * @param _matrix - The transformation matrix\n   */\n  setTransform(_matrix) {\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nProjectionSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "projection"\n};\nextensions.add(ProjectionSystem);\n\n//# sourceMappingURL=ProjectionSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs\n\n\n\nconst tempTransform = new Transform_Transform(), tempRect = new Rectangle_Rectangle();\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer, this._tempMatrix = new Matrix();\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.\n   * @param displayObject - The displayObject the object will be generated from.\n   * @param {IGenerateTextureOptions} options - Generate texture options.\n   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,\n   *        if no region is specified, defaults to the local bounds of the displayObject.\n   * @param {number} [options.resolution] - If not given, the renderer\'s resolution is used.\n   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer\'s multisample is used.\n   * @returns a shiny new texture of the display object passed in\n   */\n  generateTexture(displayObject, options) {\n    const { region: manualRegion, ...textureOptions } = options || {}, region = manualRegion?.copyTo(tempRect) || displayObject.getLocalBounds(tempRect, !0), resolution = textureOptions.resolution || this.renderer.resolution;\n    region.width = Math.max(region.width, 1 / resolution), region.height = Math.max(region.height, 1 / resolution), textureOptions.width = region.width, textureOptions.height = region.height, textureOptions.resolution = resolution, textureOptions.multisample ?? (textureOptions.multisample = this.renderer.multisample);\n    const renderTexture = RenderTexture.create(textureOptions);\n    this._tempMatrix.tx = -region.x, this._tempMatrix.ty = -region.y;\n    const transform = displayObject.transform;\n    return displayObject.transform = tempTransform, this.renderer.render(displayObject, {\n      renderTexture,\n      transform: this._tempMatrix,\n      skipUpdateTransform: !!displayObject.parent,\n      blit: !0\n    }), displayObject.transform = transform, renderTexture;\n  }\n  destroy() {\n  }\n}\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "textureGenerator"\n};\nextensions.add(GenerateTextureSystem);\n\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs\n\n\n\nconst RenderTextureSystem_tempRect = new Rectangle_Rectangle(), tempRect2 = new Rectangle_Rectangle();\nclass RenderTextureSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle_Rectangle(), this.destinationFrame = new Rectangle_Rectangle(), this.viewportFrame = new Rectangle_Rectangle();\n  }\n  contextChange() {\n    const attributes = this.renderer?.gl.getContextAttributes();\n    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);\n  }\n  /**\n   * Bind the current render texture.\n   * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.\n   * @param sourceFrame - Part of world that is mapped to the renderTexture.\n   * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.\n   */\n  bind(renderTexture = null, sourceFrame, destinationFrame) {\n    const renderer = this.renderer;\n    this.current = renderTexture;\n    let baseTexture, framebuffer, resolution;\n    renderTexture ? (baseTexture = renderTexture.baseTexture, resolution = baseTexture.resolution, sourceFrame || (RenderTextureSystem_tempRect.width = renderTexture.frame.width, RenderTextureSystem_tempRect.height = renderTexture.frame.height, sourceFrame = RenderTextureSystem_tempRect), destinationFrame || (tempRect2.x = renderTexture.frame.x, tempRect2.y = renderTexture.frame.y, tempRect2.width = sourceFrame.width, tempRect2.height = sourceFrame.height, destinationFrame = tempRect2), framebuffer = baseTexture.framebuffer) : (resolution = renderer.resolution, sourceFrame || (RenderTextureSystem_tempRect.width = renderer._view.screen.width, RenderTextureSystem_tempRect.height = renderer._view.screen.height, sourceFrame = RenderTextureSystem_tempRect), destinationFrame || (destinationFrame = RenderTextureSystem_tempRect, destinationFrame.width = sourceFrame.width, destinationFrame.height = sourceFrame.height));\n    const viewportFrame = this.viewportFrame;\n    viewportFrame.x = destinationFrame.x * resolution, viewportFrame.y = destinationFrame.y * resolution, viewportFrame.width = destinationFrame.width * resolution, viewportFrame.height = destinationFrame.height * resolution, renderTexture || (viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height)), viewportFrame.ceil(), this.renderer.framebuffer.bind(framebuffer, viewportFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer), renderTexture ? this.renderer.mask.setMaskStack(baseTexture.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.copyFrom(destinationFrame);\n  }\n  /**\n   * Erases the render texture and fills the drawing area with a colour.\n   * @param clearColor - The color as rgba, default to use the renderer backgroundColor\n   * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n   */\n  clear(clearColor, mask) {\n    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor, color = Color_Color.shared.setValue(clearColor || fallbackColor);\n    (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && color.premultiply(color.alpha);\n    const destinationFrame = this.destinationFrame, baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen, clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n    if (clearMask) {\n      let { x, y, width, height } = this.viewportFrame;\n      x = Math.round(x), y = Math.round(y), width = Math.round(width), height = Math.round(height), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(x, y, width, height);\n    }\n    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask), clearMask && this.renderer.scissor.pop();\n  }\n  resize() {\n    this.bind(null);\n  }\n  /** Resets render-texture state. */\n  reset() {\n    this.bind(null);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nRenderTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "renderTexture"\n};\nextensions.add(RenderTextureSystem);\n\n//# sourceMappingURL=RenderTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/GLProgram.mjs\nclass IGLUniformData {\n}\nclass GLProgram {\n  /**\n   * Makes a new Pixi program.\n   * @param program - webgl program\n   * @param uniformData - uniforms\n   */\n  constructor(program, uniformData) {\n    this.program = program, this.uniformData = uniformData, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n  }\n  /** Destroys this program. */\n  destroy() {\n    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n  }\n}\n\n//# sourceMappingURL=GLProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  return gl.shaderSource(shader, src), gl.compileShader(shader), shader;\n}\n\n//# sourceMappingURL=compileShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++)\n    array[i] = !1;\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case "float":\n      return 0;\n    case "vec2":\n      return new Float32Array(2 * size);\n    case "vec3":\n      return new Float32Array(3 * size);\n    case "vec4":\n      return new Float32Array(4 * size);\n    case "int":\n    case "uint":\n    case "sampler2D":\n    case "sampler2DArray":\n      return 0;\n    case "ivec2":\n      return new Int32Array(2 * size);\n    case "ivec3":\n      return new Int32Array(3 * size);\n    case "ivec4":\n      return new Int32Array(4 * size);\n    case "uvec2":\n      return new Uint32Array(2 * size);\n    case "uvec3":\n      return new Uint32Array(3 * size);\n    case "uvec4":\n      return new Uint32Array(4 * size);\n    case "bool":\n      return !1;\n    case "bvec2":\n      return booleanArray(2 * size);\n    case "bvec3":\n      return booleanArray(3 * size);\n    case "bvec4":\n      return booleanArray(4 * size);\n    case "mat2":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case "mat3":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case "mat4":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\n//# sourceMappingURL=defaultValue.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs\n\n\nfunction getAttributeData(program, gl) {\n  const attributes = {}, totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith("gl_"))\n      continue;\n    const type = mapType(gl, attribData.type), data = {\n      type,\n      name: attribData.name,\n      size: mapSize(type),\n      location: gl.getAttribLocation(program, attribData.name)\n    };\n    attributes[attribData.name] = data;\n  }\n  return attributes;\n}\n\n//# sourceMappingURL=getAttributeData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs\n\n\nfunction getUniformData(program, gl) {\n  const uniforms = {}, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i), name = uniformData.name.replace(/\\[.*?\\]$/, ""), isArray = !!uniformData.name.match(/\\[.*?\\]$/), type = mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\n\n//# sourceMappingURL=getUniformData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split(`\n`).map((line, index) => `${index}: ${line}`), shaderLog = gl.getShaderInfoLog(shader), splitShader = shaderLog.split(`\n`), dedupe = {}, lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, "$1"))).filter((n) => n && !dedupe[n] ? (dedupe[n] = !0, !0) : !1), logArgs = [""];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`, logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");\n  });\n  const fragmentSourceToLog = shaderSrc.join(`\n`);\n  logArgs[0] = fragmentSourceToLog, console.error(shaderLog), console.groupCollapsed("click to view full shader code"), console.warn(...logArgs), console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  gl.getProgramParameter(program, gl.LINK_STATUS) || (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, vertexShader), gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, fragmentShader), console.error("PixiJS Error: Could not initialize shader."), gl.getProgramInfoLog(program) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program)));\n}\n\n//# sourceMappingURL=logProgramError.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs\n\n\n\n\n\n\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc), webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader), gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;\n  if (transformFeedbackVaryings && (typeof gl.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl.transformFeedbackVaryings(\n    webGLProgram,\n    transformFeedbackVaryings.names,\n    transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS\n  )), gl.linkProgram(webGLProgram), gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError(gl, webGLProgram, glVertShader, glFragShader), program.attributeData = getAttributeData(webGLProgram, gl), program.uniformData = getUniformData(webGLProgram, gl), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertexSrc)) {\n    const keys = Object.keys(program.attributeData);\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++)\n      program.attributeData[keys[i]].location = i, gl.bindAttribLocation(webGLProgram, i, keys[i]);\n    gl.linkProgram(webGLProgram);\n  }\n  gl.deleteShader(glVertShader), gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program.uniformData) {\n    const data = program.uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  return new GLProgram(webGLProgram, uniformData);\n}\n\n//# sourceMappingURL=generateProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs\n\n\n\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nconst UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    dataLen: 0,\n    dirty: 0\n  }));\n  let size = 0, chunkSize = 0, offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    if (size = GLSL_TO_STD40_SIZE[uboElement.data.type], uboElement.data.size > 1 && (size = Math.max(size, 16) * uboElement.data.size), uboElement.dataLen = size, chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue, offset += lineUpValue;\n    }\n    chunkSize + size > 16 ? (offset = Math.ceil(offset / 16) * 16, uboElement.offset = offset, offset += size, chunkSize = size) : (uboElement.offset = offset, chunkSize += size, offset += size);\n  }\n  return offset = Math.ceil(offset / 16) * 16, { uboElements, size: offset };\n}\nfunction getUBOData(uniforms, uniformData) {\n  const usedUniformDatas = [];\n  for (const i in uniforms)\n    uniformData[i] && usedUniformDatas.push(uniformData[i]);\n  return usedUniformDatas.sort((a, b) => a.index - b.index), usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage)\n    return { size: 0, syncFunc: uboUpdate };\n  const usedUniformDatas = getUBOData(group.uniforms, uniformData), { uboElements, size } = createUBOElements(usedUniformDatas), funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i], uniform = group.uniforms[uboElement.data.name], name = uboElement.data.name;\n    let parsed = !1;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(\n          `offset = ${uboElement.offset / 4};`,\n          uniformParsers[j].codeUbo(uboElement.data.name, uniform)\n        ), parsed = !0;\n        break;\n      }\n    }\n    if (!parsed)\n      if (uboElement.data.size > 1) {\n        const size2 = mapSize(uboElement.data.type), rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), elementSize = size2 / rowSize, remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n      } else {\n        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n      }\n  }\n  return funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size,\n    // eslint-disable-next-line no-new-func\n    syncFunc: new Function(\n      "ud",\n      "uv",\n      "renderer",\n      "syncData",\n      "buffer",\n      funcFragments.join(`\n`)\n    )\n  };\n}\n\n//# sourceMappingURL=generateUniformBufferSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval == "boolean")\n    return unsafeEval;\n  try {\n    unsafeEval = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;\n  } catch {\n    unsafeEval = !1;\n  }\n  return unsafeEval;\n}\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs\n\n\n\n\n\n\nlet ShaderSystem_UID = 0;\nconst defaultSyncData = { textureCount: 0, uboCount: 0 };\nclass ShaderSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.destroyed = !1, this.renderer = renderer, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = ShaderSystem_UID++;\n  }\n  /**\n   * Overrideable function by `@pixi/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   */\n  systemCheck() {\n    if (!unsafeEvalSupported())\n      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");\n  }\n  contextChange(gl) {\n    this.gl = gl, this.reset();\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param dontSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, dontSync) {\n    shader.disposeRunner.add(this), shader.uniforms.globals = this.renderer.globalUniforms;\n    const program = shader.program, glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);\n    return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData)), glProgram;\n  }\n  /**\n   * Uploads the uniforms values to the currently bound shader.\n   * @param uniforms - the uniforms values that be applied to the current shader\n   */\n  setUniforms(uniforms) {\n    const shader = this.shader.program, glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];\n    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);\n  }\n  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n  /**\n   * Syncs uniforms on the group\n   * @param group - the uniform group to sync\n   * @param syncData - this is data that is passed to the sync function and any nested sync functions\n   */\n  syncUniformGroup(group, syncData) {\n    const glProgram = this.getGlProgram();\n    (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) && (glProgram.uniformDirtyGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram, syncData));\n  }\n  /**\n   * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.\n   * @param group\n   * @param glProgram\n   * @param syncData\n   */\n  syncUniforms(group, glProgram, syncData) {\n    (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram.uniformData, group.uniforms, this.renderer, syncData);\n  }\n  createSyncGroups(group) {\n    const id = this.getSignature(group, this.shader.program.uniformData, "u");\n    return this.cache[id] || (this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData)), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id];\n  }\n  /**\n   * Syncs uniform buffers\n   * @param group - the uniform buffer group to sync\n   * @param name - the name of the uniform buffer\n   */\n  syncUniformBufferGroup(group, name) {\n    const glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {\n      group.dirtyId = 0;\n      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);\n      group.buffer.update(), syncFunc(\n        glProgram.uniformData,\n        group.uniforms,\n        this.renderer,\n        defaultSyncData,\n        group.buffer\n      );\n    }\n    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);\n  }\n  /**\n   * Will create a function that uploads a uniform buffer using the STD140 standard.\n   * The upload function will then be cached for future calls\n   * If a group is manually managed, then a simple upload function is generated\n   * @param group - the uniform buffer group to sync\n   * @param glProgram - the gl program to attach the uniform bindings to\n   * @param name - the name of the uniform buffer (must exist on the shader)\n   */\n  createSyncBufferGroup(group, glProgram, name) {\n    const { gl } = this.renderer;\n    this.renderer.buffer.bind(group.buffer);\n    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);\n    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount, gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");\n    let uboData = this._uboCache[id];\n    if (uboData || (uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData)), group.autoManage) {\n      const data = new Float32Array(uboData.size / 4);\n      group.buffer.update(data);\n    }\n    return glProgram.uniformGroups[group.id] = uboData.syncFunc, glProgram.uniformGroups[group.id];\n  }\n  /**\n   * Takes a uniform group and data and generates a unique signature for them.\n   * @param group - The uniform group to get signature of\n   * @param group.uniforms\n   * @param uniformData - Uniform information generated by the shader\n   * @param preFix\n   * @returns Unique signature of the uniform group\n   */\n  getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms, strings = [`${preFix}-`];\n    for (const i in uniforms)\n      strings.push(i), uniformData[i] && strings.push(uniformData[i].type);\n    return strings.join("-");\n  }\n  /**\n   * Returns the underlying GLShade rof the currently bound shader.\n   *\n   * This can be handy for when you to have a little more control over the setting of your uniforms.\n   * @returns The glProgram for the currently bound Shader for this context\n   */\n  getGlProgram() {\n    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n  }\n  /**\n   * Generates a glProgram version of the Shader provided.\n   * @param shader - The shader that the glProgram will be based on.\n   * @returns A shiny new glProgram!\n   */\n  generateProgram(shader) {\n    const gl = this.gl, program = shader.program, glProgram = generateProgram(gl, program);\n    return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram, glProgram;\n  }\n  /** Resets ShaderSystem state, does not affect WebGL state. */\n  reset() {\n    this.program = null, this.shader = null;\n  }\n  /**\n   * Disposes shader.\n   * If disposing one equals with current shader, set current as null.\n   * @param shader - Shader object\n   */\n  disposeShader(shader) {\n    this.shader === shader && (this.shader = null);\n  }\n  /** Destroys this System and removes all its textures. */\n  destroy() {\n    this.renderer = null, this.destroyed = !0;\n  }\n}\nShaderSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "shader"\n};\nextensions.add(ShaderSystem);\n\n//# sourceMappingURL=ShaderSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/startup/StartupSystem.mjs\n\nclass StartupSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  run(options) {\n    const { renderer } = this;\n    renderer.runners.init.emit(renderer.options), options.hello && console.log(`PixiJS 7.3.3 - ${renderer.rendererLogId} - https://pixijs.com`), renderer.resize(renderer.screen.width, renderer.screen.height);\n  }\n  destroy() {\n  }\n}\nStartupSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.hello}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  hello: !1\n}, /** @ignore */\nStartupSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "startup"\n};\nextensions.add(StartupSystem);\n\n//# sourceMappingURL=StartupSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs\n\nfunction mapWebGLBlendModesToPixi(gl, array = []) {\n  return array[lib_BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.ADD] = [gl.ONE, gl.ONE], array[lib_BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.NONE] = [0, 0], array[lib_BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE], array[lib_BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO], array[lib_BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO], array[lib_BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE], array[lib_BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA], array[lib_BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA], array[lib_BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[lib_BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD], array;\n}\n\n//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/StateSystem.mjs\n\n\n\n\nconst StateSystem_BLEND = 0, StateSystem_OFFSET = 1, StateSystem_CULLING = 2, StateSystem_DEPTH_TEST = 3, StateSystem_WINDING = 4, StateSystem_DEPTH_MASK = 5, _StateSystem = class _StateSystem2 {\n  constructor() {\n    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = lib_BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[StateSystem_BLEND] = this.setBlend, this.map[StateSystem_OFFSET] = this.setOffset, this.map[StateSystem_CULLING] = this.setCullFace, this.map[StateSystem_DEPTH_TEST] = this.setDepthTest, this.map[StateSystem_WINDING] = this.setFrontFace, this.map[StateSystem_DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;\n  }\n  contextChange(gl) {\n    this.gl = gl, this.blendModes = mapWebGLBlendModesToPixi(gl), this.set(this.defaultState), this.reset();\n  }\n  /**\n   * Sets the current state\n   * @param {*} state - The state to set.\n   */\n  set(state) {\n    if (state = state || this.defaultState, this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data, i = 0;\n      for (; diff; )\n        diff & 1 && this.map[i].call(this, !!(state.data & 1 << i)), diff = diff >> 1, i++;\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++)\n      this.checks[i](this, state);\n  }\n  /**\n   * Sets the state, when previous state is unknown.\n   * @param {*} state - The state to set\n   */\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++)\n      this.map[i].call(this, !!(state.data & 1 << i));\n    for (let i = 0; i < this.checks.length; i++)\n      this.checks[i](this, state);\n    this.stateId = state.data;\n  }\n  /**\n   * Sets whether to enable or disable blending.\n   * @param value - Turn on or off WebGl blending.\n   */\n  setBlend(value) {\n    this.updateCheck(_StateSystem2.checkBlendMode, value), this.gl[value ? "enable" : "disable"](this.gl.BLEND);\n  }\n  /**\n   * Sets whether to enable or disable polygon offset fill.\n   * @param value - Turn on or off webgl polygon offset testing.\n   */\n  setOffset(value) {\n    this.updateCheck(_StateSystem2.checkPolygonOffset, value), this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  /**\n   * Sets whether to enable or disable depth test.\n   * @param value - Turn on or off webgl depth testing.\n   */\n  setDepthTest(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);\n  }\n  /**\n   * Sets whether to enable or disable depth mask.\n   * @param value - Turn on or off webgl depth mask.\n   */\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  /**\n   * Sets whether to enable or disable cull face.\n   * @param {boolean} value - Turn on or off webgl cull face.\n   */\n  setCullFace(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);\n  }\n  /**\n   * Sets the gl front face.\n   * @param {boolean} value - true is clockwise and false is counter-clockwise\n   */\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);\n  }\n  /**\n   * Sets the blend mode.\n   * @param {number} value - The blend mode to set to.\n   */\n  setBlendMode(value) {\n    if (value === this.blendMode)\n      return;\n    this.blendMode = value;\n    const mode = this.blendModes[value], gl = this.gl;\n    mode.length === 2 ? gl.blendFunc(mode[0], mode[1]) : gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = !0, gl.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = !1, gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD));\n  }\n  /**\n   * Sets the polygon offset.\n   * @param {number} value - the polygon offset\n   * @param {number} scale - the polygon offset scale\n   */\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  // used\n  /** Resets all the logic and disables the VAOs. */\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n  }\n  /**\n   * Checks to see which updates should be checked based on which settings have been activated.\n   *\n   * For example, if blend is enabled then we should check the blend modes each time the state is changed\n   * or if polygon fill is activated then we need to check if the polygon offset changes.\n   * The idea is that we only check what we have too.\n   * @param func - the checking function to add or remove\n   * @param value - should the check function be added or removed.\n   */\n  updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    value && index === -1 ? this.checks.push(func) : !value && index !== -1 && this.checks.splice(index, 1);\n  }\n  /**\n   * A private little wrapper function that we call to check the blend mode.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  /**\n   * A private little wrapper function that we call to check the polygon offset.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.gl = null;\n  }\n};\n_StateSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "state"\n};\nlet StateSystem = _StateSystem;\nextensions.add(StateSystem);\n\n//# sourceMappingURL=StateSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/system/SystemManager.mjs\n\n\nclass SystemManager extends eventemitter3 {\n  constructor() {\n    super(...arguments), this.runners = {}, this._systemsHash = {};\n  }\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  setup(config) {\n    this.addRunners(...config.runners);\n    const priority = (config.priority ?? []).filter((key) => config.systems[key]), orderByPriority = [\n      ...priority,\n      ...Object.keys(config.systems).filter((key) => !priority.includes(key))\n    ];\n    for (const i of orderByPriority)\n      this.addSystem(config.systems[i], i);\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new Runner_Runner(runnerId);\n    });\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn\'t collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name])\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    this[name] = system, this._systemsHash[name] = system;\n    for (const i in this.runners)\n      this.runners[i].add(system);\n    return this;\n  }\n  /**\n   * A function that will run a runner and call the runners function but pass in different options\n   * to each system based on there name.\n   *\n   * E.g. If you have two systems added called `systemA` and `systemB` you could call do the following:\n   *\n   * ```js\n   * system.emitWithCustomOptions(init, {\n   *     systemA: {...optionsForA},\n   *     systemB: {...optionsForB},\n   * });\n   * ```\n   *\n   * `init` would be called on system A passing `optionsForA` and on system B passing `optionsForB`.\n   * @param runner - the runner to target\n   * @param options - key value options for each system\n   */\n  emitWithCustomOptions(runner, options) {\n    const systemHashKeys = Object.keys(this._systemsHash);\n    runner.items.forEach((system) => {\n      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);\n      system[runner.name](options[systemName]);\n    });\n  }\n  /** destroy the all runners and systems. Its apps job to */\n  destroy() {\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    }), this._systemsHash = {};\n  }\n  // TODO implement!\n  // removeSystem(ClassRef: ISystemConstructor, name: string): void\n  // {\n  // }\n}\n\n//# sourceMappingURL=SystemManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs\n\n\nconst _TextureGCSystem = class _TextureGCSystem2 {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this.renderer = renderer, this.count = 0, this.checkCount = 0, this.maxIdle = _TextureGCSystem2.defaultMaxIdle, this.checkCountMax = _TextureGCSystem2.defaultCheckCountMax, this.mode = _TextureGCSystem2.defaultMode;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const tm = this.renderer.texture, managedTextures = tm.managedTextures;\n    let wasRemoved = !1;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      texture.resource && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, !0), managedTextures[i] = null, wasRemoved = !0);\n    }\n    if (wasRemoved) {\n      let j = 0;\n      for (let i = 0; i < managedTextures.length; i++)\n        managedTextures[i] !== null && (managedTextures[j++] = managedTextures[i]);\n      managedTextures.length = j;\n    }\n  }\n  /**\n   * Removes all the textures within the specified displayObject and its children from the GPU.\n   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.\n   */\n  unload(displayObject) {\n    const tm = this.renderer.texture, texture = displayObject._texture;\n    texture && !texture.framebuffer && tm.destroyTexture(texture);\n    for (let i = displayObject.children.length - 1; i >= 0; i--)\n      this.unload(displayObject.children[i]);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n};\n_TextureGCSystem.defaultMode = GC_MODES.AUTO, /**\n* Default maximum idle frames before a texture is destroyed by garbage collection.\n* @static\n* @default 3600\n* @see PIXI.TextureGCSystem#maxIdle\n*/\n_TextureGCSystem.defaultMaxIdle = 60 * 60, /**\n* Default frames between two garbage collections.\n* @static\n* @default 600\n* @see PIXI.TextureGCSystem#checkCountMax\n*/\n_TextureGCSystem.defaultCheckCountMax = 60 * 10, /** @ignore */\n_TextureGCSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "textureGC"\n};\nlet TextureGCSystem = _TextureGCSystem;\nextensions.add(TextureGCSystem);\n\n//# sourceMappingURL=TextureGCSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/GLTexture.mjs\n\nclass GLTexture {\n  constructor(texture) {\n    this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;\n  }\n}\n\n//# sourceMappingURL=GLTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.mjs\n\nfunction mapInternalFormatToSamplerType(gl) {\n  let table;\n  return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {\n    [gl.RGB]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA]: SAMPLER_TYPES.FLOAT,\n    [gl.ALPHA]: SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE]: SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,\n    [gl.R8]: SAMPLER_TYPES.FLOAT,\n    [gl.R8_SNORM]: SAMPLER_TYPES.FLOAT,\n    [gl.RG8]: SAMPLER_TYPES.FLOAT,\n    [gl.RG8_SNORM]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB8]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB8_SNORM]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB565]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA4]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB5_A1]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA8]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA8_SNORM]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB10_A2]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB10_A2UI]: SAMPLER_TYPES.FLOAT,\n    [gl.SRGB8]: SAMPLER_TYPES.FLOAT,\n    [gl.SRGB8_ALPHA8]: SAMPLER_TYPES.FLOAT,\n    [gl.R16F]: SAMPLER_TYPES.FLOAT,\n    [gl.RG16F]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB16F]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA16F]: SAMPLER_TYPES.FLOAT,\n    [gl.R32F]: SAMPLER_TYPES.FLOAT,\n    [gl.RG32F]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB32F]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA32F]: SAMPLER_TYPES.FLOAT,\n    [gl.R11F_G11F_B10F]: SAMPLER_TYPES.FLOAT,\n    [gl.RGB9_E5]: SAMPLER_TYPES.FLOAT,\n    [gl.R8I]: SAMPLER_TYPES.INT,\n    [gl.R8UI]: SAMPLER_TYPES.UINT,\n    [gl.R16I]: SAMPLER_TYPES.INT,\n    [gl.R16UI]: SAMPLER_TYPES.UINT,\n    [gl.R32I]: SAMPLER_TYPES.INT,\n    [gl.R32UI]: SAMPLER_TYPES.UINT,\n    [gl.RG8I]: SAMPLER_TYPES.INT,\n    [gl.RG8UI]: SAMPLER_TYPES.UINT,\n    [gl.RG16I]: SAMPLER_TYPES.INT,\n    [gl.RG16UI]: SAMPLER_TYPES.UINT,\n    [gl.RG32I]: SAMPLER_TYPES.INT,\n    [gl.RG32UI]: SAMPLER_TYPES.UINT,\n    [gl.RGB8I]: SAMPLER_TYPES.INT,\n    [gl.RGB8UI]: SAMPLER_TYPES.UINT,\n    [gl.RGB16I]: SAMPLER_TYPES.INT,\n    [gl.RGB16UI]: SAMPLER_TYPES.UINT,\n    [gl.RGB32I]: SAMPLER_TYPES.INT,\n    [gl.RGB32UI]: SAMPLER_TYPES.UINT,\n    [gl.RGBA8I]: SAMPLER_TYPES.INT,\n    [gl.RGBA8UI]: SAMPLER_TYPES.UINT,\n    [gl.RGBA16I]: SAMPLER_TYPES.INT,\n    [gl.RGBA16UI]: SAMPLER_TYPES.UINT,\n    [gl.RGBA32I]: SAMPLER_TYPES.INT,\n    [gl.RGBA32UI]: SAMPLER_TYPES.UINT,\n    [gl.DEPTH_COMPONENT16]: SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_COMPONENT24]: SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_COMPONENT32F]: SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH24_STENCIL8]: SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH32F_STENCIL8]: SAMPLER_TYPES.FLOAT\n  } : table = {\n    [gl.RGB]: SAMPLER_TYPES.FLOAT,\n    [gl.RGBA]: SAMPLER_TYPES.FLOAT,\n    [gl.ALPHA]: SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE]: SAMPLER_TYPES.FLOAT,\n    [gl.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,\n    [gl.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT\n  }, table;\n}\n\n//# sourceMappingURL=mapInternalFormatToSamplerType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs\n\nfunction mapTypeAndFormatToInternalFormat(gl) {\n  let table;\n  return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {\n    [TYPES.UNSIGNED_BYTE]: {\n      [FORMATS.RGBA]: gl.RGBA8,\n      [FORMATS.RGB]: gl.RGB8,\n      [FORMATS.RG]: gl.RG8,\n      [FORMATS.RED]: gl.R8,\n      [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,\n      [FORMATS.RGB_INTEGER]: gl.RGB8UI,\n      [FORMATS.RG_INTEGER]: gl.RG8UI,\n      [FORMATS.RED_INTEGER]: gl.R8UI,\n      [FORMATS.ALPHA]: gl.ALPHA,\n      [FORMATS.LUMINANCE]: gl.LUMINANCE,\n      [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n    },\n    [TYPES.BYTE]: {\n      [FORMATS.RGBA]: gl.RGBA8_SNORM,\n      [FORMATS.RGB]: gl.RGB8_SNORM,\n      [FORMATS.RG]: gl.RG8_SNORM,\n      [FORMATS.RED]: gl.R8_SNORM,\n      [FORMATS.RGBA_INTEGER]: gl.RGBA8I,\n      [FORMATS.RGB_INTEGER]: gl.RGB8I,\n      [FORMATS.RG_INTEGER]: gl.RG8I,\n      [FORMATS.RED_INTEGER]: gl.R8I\n    },\n    [TYPES.UNSIGNED_SHORT]: {\n      [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,\n      [FORMATS.RGB_INTEGER]: gl.RGB16UI,\n      [FORMATS.RG_INTEGER]: gl.RG16UI,\n      [FORMATS.RED_INTEGER]: gl.R16UI,\n      [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16\n    },\n    [TYPES.SHORT]: {\n      [FORMATS.RGBA_INTEGER]: gl.RGBA16I,\n      [FORMATS.RGB_INTEGER]: gl.RGB16I,\n      [FORMATS.RG_INTEGER]: gl.RG16I,\n      [FORMATS.RED_INTEGER]: gl.R16I\n    },\n    [TYPES.UNSIGNED_INT]: {\n      [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,\n      [FORMATS.RGB_INTEGER]: gl.RGB32UI,\n      [FORMATS.RG_INTEGER]: gl.RG32UI,\n      [FORMATS.RED_INTEGER]: gl.R32UI,\n      [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24\n    },\n    [TYPES.INT]: {\n      [FORMATS.RGBA_INTEGER]: gl.RGBA32I,\n      [FORMATS.RGB_INTEGER]: gl.RGB32I,\n      [FORMATS.RG_INTEGER]: gl.RG32I,\n      [FORMATS.RED_INTEGER]: gl.R32I\n    },\n    [TYPES.FLOAT]: {\n      [FORMATS.RGBA]: gl.RGBA32F,\n      [FORMATS.RGB]: gl.RGB32F,\n      [FORMATS.RG]: gl.RG32F,\n      [FORMATS.RED]: gl.R32F,\n      [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F\n    },\n    [TYPES.HALF_FLOAT]: {\n      [FORMATS.RGBA]: gl.RGBA16F,\n      [FORMATS.RGB]: gl.RGB16F,\n      [FORMATS.RG]: gl.RG16F,\n      [FORMATS.RED]: gl.R16F\n    },\n    [TYPES.UNSIGNED_SHORT_5_6_5]: {\n      [FORMATS.RGB]: gl.RGB565\n    },\n    [TYPES.UNSIGNED_SHORT_4_4_4_4]: {\n      [FORMATS.RGBA]: gl.RGBA4\n    },\n    [TYPES.UNSIGNED_SHORT_5_5_5_1]: {\n      [FORMATS.RGBA]: gl.RGB5_A1\n    },\n    [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {\n      [FORMATS.RGBA]: gl.RGB10_A2,\n      [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI\n    },\n    [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {\n      [FORMATS.RGB]: gl.R11F_G11F_B10F\n    },\n    [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {\n      [FORMATS.RGB]: gl.RGB9_E5\n    },\n    [TYPES.UNSIGNED_INT_24_8]: {\n      [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8\n    },\n    [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {\n      [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8\n    }\n  } : table = {\n    [TYPES.UNSIGNED_BYTE]: {\n      [FORMATS.RGBA]: gl.RGBA,\n      [FORMATS.RGB]: gl.RGB,\n      [FORMATS.ALPHA]: gl.ALPHA,\n      [FORMATS.LUMINANCE]: gl.LUMINANCE,\n      [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n    },\n    [TYPES.UNSIGNED_SHORT_5_6_5]: {\n      [FORMATS.RGB]: gl.RGB\n    },\n    [TYPES.UNSIGNED_SHORT_4_4_4_4]: {\n      [FORMATS.RGBA]: gl.RGBA\n    },\n    [TYPES.UNSIGNED_SHORT_5_5_5_1]: {\n      [FORMATS.RGBA]: gl.RGBA\n    }\n  }, table;\n}\n\n//# sourceMappingURL=mapTypeAndFormatToInternalFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureSystem.mjs\n\n\n\n\n\n\n\nclass TextureSystem {\n  /**\n   * @param renderer - The renderer this system works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(gl), this.samplerTypes = mapInternalFormatToSamplerType(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++)\n      this.boundTextures[i] = null;\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++)\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++)\n      this.bind(null, i);\n  }\n  /**\n   * Bind a texture to a specific location\n   *\n   * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n   * @param texture - Texture to bind\n   * @param [location=0] - Location to bind at\n   */\n  bind(texture, location = 0) {\n    const { gl } = this;\n    if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;\n    } else\n      this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;\n  }\n  /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n  reset() {\n    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++)\n      this.boundTextures[i] = this.unknownTexture;\n  }\n  /**\n   * Unbind a texture.\n   * @param texture - Texture to bind\n   */\n  unbind(texture) {\n    const { gl, boundTextures } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = !1;\n      for (let i = 0; i < boundTextures.length; i++)\n        boundTextures[i] === this.unknownTexture && this.bind(null, i);\n    }\n    for (let i = 0; i < boundTextures.length; i++)\n      boundTextures[i] === texture && (this.currentLocation !== i && (gl.activeTexture(gl.TEXTURE0 + i), this.currentLocation = i), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i] = null);\n  }\n  /**\n   * Ensures that current boundTextures all have FLOAT sampler type,\n   * see {@link PIXI.SAMPLER_TYPES} for explanation.\n   * @param maxTextures - number of locations to check\n   */\n  ensureSamplerType(maxTextures) {\n    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n    if (hasIntegerTextures)\n      for (let i = maxTextures - 1; i >= 0; --i) {\n        const tex = boundTextures[i];\n        tex && tex._glTextures[CONTEXT_UID].samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);\n      }\n  }\n  /**\n   * Initialize a texture\n   * @private\n   * @param texture - Texture to initialize\n   */\n  initTexture(texture) {\n    const glTexture = new GLTexture(this.gl.createTexture());\n    return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on("dispose", this.destroyTexture, this), glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;\n  }\n  /**\n   * Update a texture\n   * @private\n   * @param {PIXI.BaseTexture} texture - Texture to initialize\n   */\n  updateTexture(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture)\n      return;\n    const renderer = this.renderer;\n    if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture))\n      glTexture.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);\n    else {\n      const width = texture.realWidth, height = texture.realHeight, gl = renderer.gl;\n      (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(\n        texture.target,\n        0,\n        glTexture.internalFormat,\n        width,\n        height,\n        0,\n        texture.format,\n        glTexture.type,\n        null\n      ));\n    }\n    texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;\n  }\n  /**\n   * Deletes the texture from WebGL\n   * @private\n   * @param texture - the texture to destroy\n   * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n   */\n  destroyTexture(texture, skipRemove) {\n    const { gl } = this;\n    if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off("dispose", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {\n      const i = this.managedTextures.indexOf(texture);\n      i !== -1 && removeItems(this.managedTextures, i, 1);\n    }\n  }\n  /**\n   * Update texture style such as mipmap flag\n   * @private\n   * @param {PIXI.BaseTexture} texture - Texture to update\n   */\n  updateTextureStyle(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    glTexture && ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = !1 : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = lib_WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);\n  }\n  /**\n   * Set style for texture\n   * @private\n   * @param texture - Texture to update\n   * @param glTexture\n   */\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "texture"\n};\nextensions.add(TextureSystem);\n\n//# sourceMappingURL=TextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs\n\nclass TransformFeedbackSystem {\n  /**\n   * @param renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  /**\n   * Bind TransformFeedback and buffers\n   * @param transformFeedback - TransformFeedback to bind\n   */\n  bind(transformFeedback) {\n    const { gl, CONTEXT_UID } = this, glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n  }\n  /** Unbind TransformFeedback */\n  unbind() {\n    const { gl } = this;\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n  }\n  /**\n   * Begin TransformFeedback\n   * @param drawMode - DrawMode for TransformFeedback\n   * @param shader - A Shader used by TransformFeedback. Current bound shader will be used if not provided.\n   */\n  beginTransformFeedback(drawMode, shader) {\n    const { gl, renderer } = this;\n    shader && renderer.shader.bind(shader), gl.beginTransformFeedback(drawMode);\n  }\n  /** End TransformFeedback */\n  endTransformFeedback() {\n    const { gl } = this;\n    gl.endTransformFeedback();\n  }\n  /**\n   * Create TransformFeedback and bind buffers\n   * @param tf - TransformFeedback\n   * @returns WebGLTransformFeedback\n   */\n  createGLTransformFeedback(tf) {\n    const { gl, renderer, CONTEXT_UID } = this, glTransformFeedback = gl.createTransformFeedback();\n    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback, gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n    for (let i = 0; i < tf.buffers.length; i++) {\n      const buffer = tf.buffers[i];\n      buffer && (renderer.buffer.update(buffer), buffer._glBuffers[CONTEXT_UID].refCount++, gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null));\n    }\n    return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null), tf.disposeRunner.add(this), glTransformFeedback;\n  }\n  /**\n   * Disposes TransfromFeedback\n   * @param {PIXI.TransformFeedback} tf - TransformFeedback\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress delete TransformFeedback\n   */\n  disposeTransformFeedback(tf, contextLost) {\n    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID], gl = this.gl;\n    tf.disposeRunner.remove(this);\n    const bufferSystem = this.renderer.buffer;\n    if (bufferSystem)\n      for (let i = 0; i < tf.buffers.length; i++) {\n        const buffer = tf.buffers[i];\n        if (!buffer)\n          continue;\n        const buf = buffer._glBuffers[this.CONTEXT_UID];\n        buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffer, contextLost));\n      }\n    glTF && (contextLost || gl.deleteTransformFeedback(glTF), delete tf._glTransformFeedbacks[this.CONTEXT_UID]);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTransformFeedbackSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "transformFeedback"\n};\nextensions.add(TransformFeedbackSystem);\n\n//# sourceMappingURL=TransformFeedbackSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/view/ViewSystem.mjs\n\n\n\nclass ViewSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * initiates the view system\n   * @param {PIXI.ViewOptions} options - the options for the view\n   */\n  init(options) {\n    this.screen = new Rectangle_Rectangle(0, 0, options.width, options.height), this.element = options.view || settings.ADAPTER.createCanvas(), this.resolution = options.resolution || settings.RESOLUTION, this.autoDensity = !!options.autoDensity;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   */\n  resizeView(desiredScreenWidth, desiredScreenHeight) {\n    this.element.width = Math.round(desiredScreenWidth * this.resolution), this.element.height = Math.round(desiredScreenHeight * this.resolution);\n    const screenWidth = this.element.width / this.resolution, screenHeight = this.element.height / this.resolution;\n    this.screen.width = screenWidth, this.screen.height = screenHeight, this.autoDensity && (this.element.style.width = `${screenWidth}px`, this.element.style.height = `${screenHeight}px`), this.renderer.emit("resize", screenWidth, screenHeight), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {boolean} [removeView=false] - Whether to remove the canvas from the DOM.\n   */\n  destroy(removeView) {\n    removeView && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null;\n  }\n}\nViewSystem.defaultOptions = {\n  /**\n   * {@link PIXI.IRendererOptions.width}\n   * @default 800\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  width: 800,\n  /**\n   * {@link PIXI.IRendererOptions.height}\n   * @default 600\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  height: 600,\n  /**\n   * {@link PIXI.IRendererOptions.resolution}\n   * @type {number}\n   * @default PIXI.settings.RESOLUTION\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  resolution: void 0,\n  /**\n   * {@link PIXI.IRendererOptions.autoDensity}\n   * @default false\n   * @memberof PIXI.settings.RENDER_OPTIONS\n   */\n  autoDensity: !1\n}, /** @ignore */\nViewSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "_view"\n};\nextensions.add(ViewSystem);\n\n//# sourceMappingURL=ViewSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/systems.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=systems.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/settings.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\nsettings.PREFER_ENV = ENV.WEBGL2;\nsettings.STRICT_TEXTURE_CACHE = !1;\nsettings.RENDER_OPTIONS = {\n  ...ContextSystem.defaultOptions,\n  ...BackgroundSystem.defaultOptions,\n  ...ViewSystem.defaultOptions,\n  ...StartupSystem.defaultOptions\n};\nObject.defineProperties(settings, {\n  /**\n   * @static\n   * @name WRAP_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.WRAP_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.wrapMode\n   */\n  WRAP_MODE: {\n    get() {\n      return BaseTexture.defaultOptions.wrapMode;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), BaseTexture.defaultOptions.wrapMode = value;\n    }\n  },\n  /**\n   * @static\n   * @name SCALE_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.SCALE_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.scaleMode\n   */\n  SCALE_MODE: {\n    get() {\n      return BaseTexture.defaultOptions.scaleMode;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), BaseTexture.defaultOptions.scaleMode = value;\n    }\n  },\n  /**\n   * @static\n   * @name MIPMAP_TEXTURES\n   * @memberof PIXI.settings\n   * @type {PIXI.MIPMAP_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.mipmap\n   */\n  MIPMAP_TEXTURES: {\n    get() {\n      return BaseTexture.defaultOptions.mipmap;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), BaseTexture.defaultOptions.mipmap = value;\n    }\n    // MIPMAP_MODES.POW2,\n  },\n  /**\n   * @static\n   * @name ANISOTROPIC_LEVEL\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.BaseTexture.defaultOptions.anisotropicLevel\n   */\n  ANISOTROPIC_LEVEL: {\n    get() {\n      return BaseTexture.defaultOptions.anisotropicLevel;\n    },\n    set(value) {\n      deprecation(\n        "7.1.0",\n        "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"\n      ), BaseTexture.defaultOptions.anisotropicLevel = value;\n    }\n  },\n  /**\n   * Default filter resolution.\n   * @static\n   * @name FILTER_RESOLUTION\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @type {number|null}\n   * @see PIXI.Filter.defaultResolution\n   */\n  FILTER_RESOLUTION: {\n    get() {\n      return deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), Filter.defaultResolution;\n    },\n    set(value) {\n      Filter.defaultResolution = value;\n    }\n  },\n  /**\n   * Default filter samples.\n   * @static\n   * @name FILTER_MULTISAMPLE\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @type {PIXI.MSAA_QUALITY}\n   * @see PIXI.Filter.defaultMultisample\n   */\n  FILTER_MULTISAMPLE: {\n    get() {\n      return deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), Filter.defaultMultisample;\n    },\n    set(value) {\n      Filter.defaultMultisample = value;\n    }\n  },\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @name SPRITE_MAX_TEXTURES\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @see PIXI.BatchRenderer.defaultMaxTextures\n   * @type {number}\n   */\n  SPRITE_MAX_TEXTURES: {\n    get() {\n      return BatchRenderer.defaultMaxTextures;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), BatchRenderer.defaultMaxTextures = value;\n    }\n  },\n  /**\n   * The default sprite batch size.\n   *\n   * The default aims to balance desktop and mobile devices.\n   * @static\n   * @name SPRITE_BATCH_SIZE\n   * @memberof PIXI.settings\n   * @see PIXI.BatchRenderer.defaultBatchSize\n   * @deprecated since 7.1.0\n   * @type {number}\n   */\n  SPRITE_BATCH_SIZE: {\n    get() {\n      return BatchRenderer.defaultBatchSize;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), BatchRenderer.defaultBatchSize = value;\n    }\n  },\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   * @name CAN_UPLOAD_SAME_BUFFER\n   * @memberof PIXI.settings\n   * @see PIXI.BatchRenderer.canUploadSameBuffer\n   * @deprecated since 7.1.0\n   * @type {boolean}\n   */\n  CAN_UPLOAD_SAME_BUFFER: {\n    get() {\n      return BatchRenderer.canUploadSameBuffer;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), BatchRenderer.canUploadSameBuffer = value;\n    }\n  },\n  /**\n   * Default Garbage Collection mode.\n   * @static\n   * @name GC_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.GC_MODES}\n   * @deprecated since 7.1.0\n   * @see PIXI.TextureGCSystem.defaultMode\n   */\n  GC_MODE: {\n    get() {\n      return TextureGCSystem.defaultMode;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), TextureGCSystem.defaultMode = value;\n    }\n  },\n  /**\n   * Default Garbage Collection max idle.\n   * @static\n   * @name GC_MAX_IDLE\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.TextureGCSystem.defaultMaxIdle\n   */\n  GC_MAX_IDLE: {\n    get() {\n      return TextureGCSystem.defaultMaxIdle;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), TextureGCSystem.defaultMaxIdle = value;\n    }\n  },\n  /**\n   * Default Garbage Collection maximum check count.\n   * @static\n   * @name GC_MAX_CHECK_COUNT\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.TextureGCSystem.defaultCheckCountMax\n   */\n  GC_MAX_CHECK_COUNT: {\n    get() {\n      return TextureGCSystem.defaultCheckCountMax;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), TextureGCSystem.defaultCheckCountMax = value;\n    }\n  },\n  /**\n   * Default specify float precision in vertex shader.\n   * @static\n   * @name PRECISION_VERTEX\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @deprecated since 7.1.0\n   * @see PIXI.Program.defaultVertexPrecision\n   */\n  PRECISION_VERTEX: {\n    get() {\n      return Program.defaultVertexPrecision;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Program.defaultVertexPrecision = value;\n    }\n  },\n  /**\n   * Default specify float precision in fragment shader.\n   * @static\n   * @name PRECISION_FRAGMENT\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @deprecated since 7.1.0\n   * @see PIXI.Program.defaultFragmentPrecision\n   */\n  PRECISION_FRAGMENT: {\n    get() {\n      return Program.defaultFragmentPrecision;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Program.defaultFragmentPrecision = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/const.mjs\nvar const_UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => (UPDATE_PRIORITY2[UPDATE_PRIORITY2.INTERACTION = 50] = "INTERACTION", UPDATE_PRIORITY2[UPDATE_PRIORITY2.HIGH = 25] = "HIGH", UPDATE_PRIORITY2[UPDATE_PRIORITY2.NORMAL = 0] = "NORMAL", UPDATE_PRIORITY2[UPDATE_PRIORITY2.LOW = -25] = "LOW", UPDATE_PRIORITY2[UPDATE_PRIORITY2.UTILITY = -50] = "UTILITY", UPDATE_PRIORITY2))(const_UPDATE_PRIORITY || {});\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerListener.mjs\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = !1) {\n    this.next = null, this.previous = null, this._destroyed = !1, this.fn = fn, this.context = context, this.priority = priority, this.once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this.fn === fn && this.context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @private\n   * @param deltaTime - time since the last emit.\n   * @returns Next ticker\n   */\n  emit(deltaTime) {\n    this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime));\n    const redirect = this.next;\n    return this.once && this.destroy(!0), this._destroyed && (this.next = null), redirect;\n  }\n  /**\n   * Connect to the list.\n   * @private\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous, previous.next && (previous.next.previous = this), this.next = previous.next, previous.next = this;\n  }\n  /**\n   * Destroy and don\'t use after this.\n   * @private\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = !1) {\n    this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n    const redirect = this.next;\n    return this.next = hard ? null : redirect, this.previous = null, redirect;\n  }\n}\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/Ticker.mjs\n\n\nconst _Ticker = class _Ticker2 {\n  constructor() {\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {\n      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = const_UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = const_UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, !0));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next, previous = this._head;\n    if (!current)\n      listener.connect(previous);\n    else {\n      for (; current; ) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current, current = current.next;\n      }\n      listener.previous || listener.connect(previous);\n    }\n    return this._startIfPossible(), this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    for (; listener; )\n      listener.match(fn, context) ? listener = listener.destroy() : listener = listener.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head)\n      return 0;\n    let count = 0, current = this._head;\n    for (; current = current.next; )\n      count++;\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }\n  /** Destroy the ticker and don\'t use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      for (; listener; )\n        listener = listener.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link PIXI.Ticker#elapsedMS},\n   * the current {@link PIXI.Ticker#deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link PIXI.Ticker#lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS)\n          return;\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      for (; listener; )\n        listener = listener.emit(this.deltaTime);\n      head.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.Ticker#deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This value is used to cap {@link PIXI.Ticker#deltaTime},\n   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This will effect the measured value of {@link PIXI.Ticker#FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0)\n      this._minElapsedMS = 0;\n    else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by\n   * {@link PIXI.VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from \'pixi.js\';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the PIXI.Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from \'pixi.js\';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker2._shared) {\n      const shared = _Ticker2._shared = new _Ticker2();\n      shared.autoStart = !0, shared._protected = !0;\n    }\n    return _Ticker2._shared;\n  }\n  /**\n   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing\n   * functionality that shouldn\'t usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get system() {\n    if (!_Ticker2._system) {\n      const system = _Ticker2._system = new _Ticker2();\n      system.autoStart = !0, system._protected = !0;\n    }\n    return _Ticker2._system;\n  }\n};\n_Ticker.targetFPMS = 0.06;\nlet Ticker_Ticker = _Ticker;\n\n//# sourceMappingURL=Ticker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/settings.mjs\n\n\n\n\nObject.defineProperties(settings, {\n  /**\n   * Target frames per millisecond.\n   * @static\n   * @name TARGET_FPMS\n   * @memberof PIXI.settings\n   * @type {number}\n   * @deprecated since 7.1.0\n   * @see PIXI.Ticker.targetFPMS\n   */\n  TARGET_FPMS: {\n    get() {\n      return Ticker_Ticker.targetFPMS;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Ticker_Ticker.targetFPMS = value;\n    }\n  }\n});\n\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerPlugin.mjs\n\n\n\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: !0,\n      sharedTicker: !1\n    }, options), Object.defineProperty(\n      this,\n      "ticker",\n      {\n        set(ticker) {\n          this._ticker && this._ticker.remove(this.render, this), this._ticker = ticker, ticker && ticker.add(this.render, this, const_UPDATE_PRIORITY.LOW);\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    ), this.stop = () => {\n      this._ticker.stop();\n    }, this.start = () => {\n      this._ticker.start();\n    }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker_Ticker.shared : new Ticker_Ticker(), options.autoStart && this.start();\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null, oldTicker.destroy();\n    }\n  }\n}\nTickerPlugin.extension = ExtensionType.Application;\nextensions.add(TickerPlugin);\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/autoDetectRenderer.mjs\n\nconst renderers = [];\nextensions.handleByList(ExtensionType.Renderer, renderers);\nfunction autoDetectRenderer(options) {\n  for (const RendererType of renderers)\n    if (RendererType.test(options))\n      return new RendererType(options);\n  throw new Error("Unable to auto-detect a suitable renderer.");\n}\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/default.vert.mjs\nvar $defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`;\n\n//# sourceMappingURL=default.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.mjs\nvar $defaultFilterVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`;\n\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/index.mjs\n\n\nconst fragments_defaultVertex = $defaultVertex, defaultFilterVertex = $defaultFilterVertex;\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs\n\n\nclass MultisampleSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  contextChange(gl) {\n    let samples;\n    if (this.renderer.context.webGLVersion === 1) {\n      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    } else {\n      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);\n    }\n    samples >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : samples >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : samples >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;\n  }\n  destroy() {\n  }\n}\nMultisampleSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "_multisample"\n};\nextensions.add(MultisampleSystem);\n\n//# sourceMappingURL=MultisampleSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs\nclass GLBuffer {\n  constructor(buffer) {\n    this.buffer = buffer || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n  }\n}\n\n//# sourceMappingURL=GLBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs\n\n\nclass BufferSystem {\n  /**\n   * @param {PIXI.Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this.managedBuffers = {}, this.boundBufferBases = {};\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.renderer = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  }\n  unbind(type) {\n    const { gl } = this;\n    gl.bindBuffer(type, null);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(buffer, index) {\n    const { gl, CONTEXT_UID } = this;\n    if (this.boundBufferBases[index] !== buffer) {\n      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer, gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   */\n  bindBufferRange(buffer, index, offset) {\n    const { gl, CONTEXT_UID } = this;\n    offset = offset || 0;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {PIXI.Buffer} buffer - the buffer to update\n   */\n  update(buffer) {\n    const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    if (buffer._updateID !== glBuffer.updateID)\n      if (glBuffer.updateID = buffer._updateID, gl.bindBuffer(buffer.type, glBuffer.buffer), glBuffer.byteLength >= buffer.data.byteLength)\n        gl.bufferSubData(buffer.type, 0, buffer.data);\n      else {\n        const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n        glBuffer.byteLength = buffer.data.byteLength, gl.bufferData(buffer.type, buffer.data, drawType);\n      }\n  }\n  /**\n   * Disposes buffer\n   * @param {PIXI.Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  dispose(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id])\n      return;\n    delete this.managedBuffers[buffer.id];\n    const glBuffer = buffer._glBuffers[this.CONTEXT_UID], gl = this.gl;\n    buffer.disposeRunner.remove(this), glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]);\n  }\n  /**\n   * dispose all WebGL resources of all managed buffers\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedBuffers);\n    for (let i = 0; i < all.length; i++)\n      this.dispose(this.managedBuffers[all[i]], contextLost);\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const { CONTEXT_UID, gl } = this;\n    return buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer()), this.managedBuffers[buffer.id] = buffer, buffer.disposeRunner.add(this), buffer._glBuffers[CONTEXT_UID];\n  }\n}\nBufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "buffer"\n};\nextensions.add(BufferSystem);\n\n//# sourceMappingURL=BufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs\n\nclass ObjectRendererSystem {\n  // renderers scene graph!\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the object to its WebGL view.\n   * @param displayObject - The object to be rendered.\n   * @param options - the options to be passed to the renderer\n   */\n  render(displayObject, options) {\n    const renderer = this.renderer;\n    let renderTexture, clear, transform, skipUpdateTransform;\n    if (options && (renderTexture = options.renderTexture, clear = options.clear, transform = options.transform, skipUpdateTransform = options.skipUpdateTransform), this.renderingToScreen = !renderTexture, renderer.runners.prerender.emit(), renderer.emit("prerender"), renderer.projection.transform = transform, !renderer.context.isLost) {\n      if (renderTexture || (this.lastObjectRendered = displayObject), !skipUpdateTransform) {\n        const cacheParent = displayObject.enableTempParent();\n        displayObject.updateTransform(), displayObject.disableTempParent(cacheParent);\n      }\n      renderer.renderTexture.bind(renderTexture), renderer.batch.currentRenderer.start(), (clear ?? renderer.background.clearBeforeRender) && renderer.renderTexture.clear(), displayObject.render(renderer), renderer.batch.currentRenderer.flush(), renderTexture && (options.blit && renderer.framebuffer.blit(), renderTexture.baseTexture.update()), renderer.runners.postrender.emit(), renderer.projection.transform = null, renderer.emit("postrender");\n    }\n  }\n  destroy() {\n    this.renderer = null, this.lastObjectRendered = null;\n  }\n}\nObjectRendererSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "objectRenderer"\n};\nextensions.add(ObjectRendererSystem);\n\n//# sourceMappingURL=ObjectRendererSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/Renderer.mjs\n\n\n\n\n\n\n\nconst _Renderer = class _Renderer2 extends SystemManager {\n  /**\n   * @param {PIXI.IRendererOptions} [options] - See {@link PIXI.settings.RENDER_OPTIONS} for defaults.\n   */\n  constructor(options) {\n    super(), this.type = RENDERER_TYPE.WEBGL, options = Object.assign({}, settings.RENDER_OPTIONS, options), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new UniformGroup({\n      projectionMatrix: new Matrix()\n    }, !0);\n    const systemConfig = {\n      runners: [\n        "init",\n        "destroy",\n        "contextChange",\n        "resolutionChange",\n        "reset",\n        "update",\n        "postrender",\n        "prerender",\n        "resize"\n      ],\n      systems: _Renderer2.__systems,\n      priority: [\n        "_view",\n        "textureGenerator",\n        "background",\n        "_plugin",\n        "startup",\n        // low level WebGL systems\n        "context",\n        "state",\n        "texture",\n        "buffer",\n        "geometry",\n        "framebuffer",\n        "transformFeedback",\n        // high level pixi specific rendering\n        "mask",\n        "scissor",\n        "stencil",\n        "projection",\n        "textureGC",\n        "filter",\n        "renderTexture",\n        "batch",\n        "objectRenderer",\n        "_multisample"\n      ]\n    };\n    this.setup(systemConfig), "useContextAlpha" in options && (deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied", options.backgroundAlpha = options.useContextAlpha === !1 ? 1 : options.backgroundAlpha), this._plugin.rendererPlugins = _Renderer2.__plugins, this.options = options, this.startup.run(this.options);\n  }\n  /**\n   * Create renderer if WebGL is available. Overrideable\n   * by the **@pixi/canvas-renderer** package to allow fallback.\n   * throws error if WebGL is not available.\n   * @param options\n   * @private\n   */\n  static test(options) {\n    return options?.forceCanvas ? !1 : isWebGLSupported();\n  }\n  /**\n   * Renders the object to its WebGL view.\n   * @param displayObject - The object to be rendered.\n   * @param {object} [options] - Object to use for render options.\n   * @param {PIXI.RenderTexture} [options.renderTexture] - The render texture to render to.\n   * @param {boolean} [options.clear=true] - Should the canvas be cleared before the new render.\n   * @param {PIXI.Matrix} [options.transform] - A transform to apply to the render texture before rendering.\n   * @param {boolean} [options.skipUpdateTransform=false] - Should we skip the update transform pass?\n   */\n  render(displayObject, options) {\n    this.objectRenderer.render(displayObject, options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight) {\n    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);\n  }\n  /**\n   * Resets the WebGL state so you can render things however you fancy!\n   * @returns Returns itself.\n   */\n  reset() {\n    return this.runners.reset.emit(), this;\n  }\n  /** Clear the frame buffer. */\n  clear() {\n    this.renderTexture.bind(), this.renderTexture.clear();\n  }\n  /**\n   * Removes everything from the renderer (event listeners, spritebatch, etc...)\n   * @param [removeView=false] - Removes the Canvas element from the DOM.\n   *  See: https://github.com/pixijs/pixijs/issues/2233\n   */\n  destroy(removeView = !1) {\n    this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {\n      _view: removeView\n    }), super.destroy();\n  }\n  /** Collection of plugins */\n  get plugins() {\n    return this._plugin.plugins;\n  }\n  /** The number of msaa samples of the canvas. */\n  get multisample() {\n    return this._multisample.multisample;\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this._view.element.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this._view.element.height;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this._view.resolution;\n  }\n  set resolution(value) {\n    this._view.resolution = value, this.runners.resolutionChange.emit(value);\n  }\n  /** Whether CSS dimensions of canvas view should be resized to screen dimensions automatically. */\n  get autoDensity() {\n    return this._view.autoDensity;\n  }\n  /** The canvas element that everything is drawn to.*/\n  get view() {\n    return this._view.element;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   * @member {PIXI.Rectangle}\n   */\n  get screen() {\n    return this._view.screen;\n  }\n  /** the last object rendered by the renderer. Useful for other plugins like interaction managers */\n  get lastObjectRendered() {\n    return this.objectRenderer.lastObjectRendered;\n  }\n  /** Flag if we are rendering to the screen vs renderTexture */\n  get renderingToScreen() {\n    return this.objectRenderer.renderingToScreen;\n  }\n  /** When logging Pixi to the console, this is the name we will show */\n  get rendererLogId() {\n    return `WebGL ${this.context.webGLVersion}`;\n  }\n  /**\n   * This sets weather the screen is totally cleared between each frame withthe background color and alpha\n   * @deprecated since 7.0.0\n   */\n  get clearBeforeRender() {\n    return deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;\n  }\n  /**\n   * Pass-thru setting for the canvas\' context `alpha` property. This is typically\n   * not something you need to fiddle with. If you want transparency, use `backgroundAlpha`.\n   * @deprecated since 7.0.0\n   * @member {boolean}\n   */\n  get useContextAlpha() {\n    return deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;\n  }\n  /**\n   * readonly drawing buffer preservation\n   * we can only know this if Pixi created the context\n   * @deprecated since 7.0.0\n   */\n  get preserveDrawingBuffer() {\n    return deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;\n  }\n  /**\n   * The background color to fill if not transparent\n   * @member {number}\n   * @deprecated since 7.0.0\n   */\n  get backgroundColor() {\n    return deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;\n  }\n  set backgroundColor(value) {\n    deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = value;\n  }\n  /**\n   * The background color alpha. Setting this to 0 will make the canvas transparent.\n   * @member {number}\n   * @deprecated since 7.0.0\n   */\n  get backgroundAlpha() {\n    return deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;\n  }\n  /**\n   * @deprecated since 7.0.0\n   */\n  set backgroundAlpha(value) {\n    deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = value;\n  }\n  /**\n   * @deprecated since 7.0.0\n   */\n  get powerPreference() {\n    return deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;\n  }\n  /**\n   * Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.\n   * @param displayObject - The displayObject the object will be generated from.\n   * @param {IGenerateTextureOptions} options - Generate texture options.\n   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,\n   *        if no region is specified, defaults to the local bounds of the displayObject.\n   * @param {number} [options.resolution] - If not given, the renderer\'s resolution is used.\n   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer\'s multisample is used.\n   * @returns A texture of the graphics object.\n   */\n  generateTexture(displayObject, options) {\n    return this.textureGenerator.generateTexture(displayObject, options);\n  }\n};\n_Renderer.extension = {\n  type: ExtensionType.Renderer,\n  priority: 1\n}, /**\n* Collection of installed plugins. These are included by default in PIXI, but can be excluded\n* by creating a custom build. Consult the README for more information about creating custom\n* builds and excluding plugins.\n* @private\n*/\n_Renderer.__plugins = {}, /**\n* The collection of installed systems.\n* @private\n*/\n_Renderer.__systems = {};\nlet Renderer = _Renderer;\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nextensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);\nextensions.add(Renderer);\n\n//# sourceMappingURL=Renderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs\n\n\n\nclass AbstractMultiResource extends Resource {\n  /**\n   * @param length\n   * @param options - Options to for Resource constructor\n   * @param {number} [options.width] - Width of the resource\n   * @param {number} [options.height] - Height of the resource\n   */\n  constructor(length, options) {\n    const { width, height } = options || {};\n    super(width, height), this.items = [], this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture();\n      this.items.push(partTexture), this.itemDirtyIds.push(-2);\n    }\n    this.length = length, this._load = null, this.baseTexture = null;\n  }\n  /**\n   * Used from ArrayResource and CubeResource constructors.\n   * @param resources - Can be resources, image elements, canvas, etc. ,\n   *  length should be same as constructor length\n   * @param options - Detect options for resources\n   */\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++)\n      resources[i] && (resources[i].castToBaseTexture ? this.addBaseTextureAt(resources[i].castToBaseTexture(), i) : resources[i] instanceof Resource ? this.addResourceAt(resources[i], i) : this.addResourceAt(autoDetectResource(resources[i], options), i));\n  }\n  /** Destroy this BaseImageResource. */\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++)\n      this.items[i].destroy();\n    this.items = null, this.itemDirtyIds = null, this._load = null;\n  }\n  /**\n   * Set a resource by ID\n   * @param resource\n   * @param index - Zero-based index of resource to set\n   * @returns - Instance for chaining\n   */\n  addResourceAt(resource, index) {\n    if (!this.items[index])\n      throw new Error(`Index ${index} is out of bounds`);\n    return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;\n  }\n  /**\n   * Set the parent base texture.\n   * @param baseTexture\n   */\n  bind(baseTexture) {\n    if (this.baseTexture !== null)\n      throw new Error("Only one base texture per TextureArray is allowed");\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++)\n      this.items[i].parentTextureArray = baseTexture, this.items[i].on("update", baseTexture.update, baseTexture);\n  }\n  /**\n   * Unset the parent base texture.\n   * @param baseTexture\n   */\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++)\n      this.items[i].parentTextureArray = null, this.items[i].off("update", baseTexture.update, baseTexture);\n  }\n  /**\n   * Load all the resources simultaneously\n   * @returns - When load is resolved\n   */\n  load() {\n    if (this._load)\n      return this._load;\n    const promises = this.items.map((item) => item.resource).filter((item) => item).map((item) => item.load());\n    return this._load = Promise.all(promises).then(\n      () => {\n        const { realWidth, realHeight } = this.items[0];\n        return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);\n      }\n    ), this._load;\n  }\n}\n\n//# sourceMappingURL=AbstractMultiResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs\n\n\nclass ArrayResource extends AbstractMultiResource {\n  /**\n   * @param source - Number of items in array or the collection\n   *        of image URLs to use. Can also be resources, image elements, canvas, etc.\n   * @param options - Options to apply to {@link PIXI.autoDetectResource}\n   * @param {number} [options.width] - Width of the resource\n   * @param {number} [options.height] - Height of the resource\n   */\n  constructor(source, options) {\n    const { width, height } = options || {};\n    let urls, length;\n    Array.isArray(source) ? (urls = source, length = source.length) : length = source, super(length, { width, height }), urls && this.initFromArray(urls, options);\n  }\n  /**\n   * Set a baseTexture by ID,\n   * ArrayResource just takes resource from it, nothing more\n   * @param baseTexture\n   * @param index - Zero-based index of resource to set\n   * @returns - Instance for chaining\n   */\n  addBaseTextureAt(baseTexture, index) {\n    if (baseTexture.resource)\n      this.addResourceAt(baseTexture.resource, index);\n    else\n      throw new Error("ArrayResource does not support RenderTexture");\n    return this;\n  }\n  /**\n   * Add binding\n   * @param baseTexture\n   */\n  bind(baseTexture) {\n    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n  }\n  /**\n   * Upload the resources to the GPU.\n   * @param renderer\n   * @param texture\n   * @param glTexture\n   * @returns - whether texture was uploaded\n   */\n  upload(renderer, texture, glTexture) {\n    const { length, itemDirtyIds, items } = this, { gl } = renderer;\n    glTexture.dirtyId < 0 && gl.texImage3D(\n      gl.TEXTURE_2D_ARRAY,\n      0,\n      glTexture.internalFormat,\n      this._width,\n      this._height,\n      length,\n      0,\n      texture.format,\n      glTexture.type,\n      null\n    );\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n      itemDirtyIds[i] < item.dirtyId && (itemDirtyIds[i] = item.dirtyId, item.valid && gl.texSubImage3D(\n        gl.TEXTURE_2D_ARRAY,\n        0,\n        0,\n        // xoffset\n        0,\n        // yoffset\n        i,\n        // zoffset\n        item.resource.width,\n        item.resource.height,\n        1,\n        texture.format,\n        glTexture.type,\n        item.resource.source\n      ));\n    }\n    return !0;\n  }\n}\n\n//# sourceMappingURL=ArrayResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs\n\nclass CanvasResource extends BaseImageResource {\n  /**\n   * @param source - Canvas element to use\n   */\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(source) {\n    super(source);\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas\n   */\n  static test(source) {\n    const { OffscreenCanvas } = globalThis;\n    return OffscreenCanvas && source instanceof OffscreenCanvas ? !0 : globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;\n  }\n}\n\n//# sourceMappingURL=CanvasResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs\n\n\nconst _CubeResource = class _CubeResource2 extends AbstractMultiResource {\n  /**\n   * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n   *        to use as the sides of the cube.\n   * @param options - ImageResource options\n   * @param {number} [options.width] - Width of resource\n   * @param {number} [options.height] - Height of resource\n   * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n   * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n   *   whether to copy them or use\n   */\n  constructor(source, options) {\n    const { width, height, autoLoad, linkBaseTexture } = options || {};\n    if (source && source.length !== _CubeResource2.SIDES)\n      throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n    super(6, { width, height });\n    for (let i = 0; i < _CubeResource2.SIDES; i++)\n      this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    this.linkBaseTexture = linkBaseTexture !== !1, source && this.initFromArray(source, options), autoLoad !== !1 && this.load();\n  }\n  /**\n   * Add binding.\n   * @param baseTexture - parent base texture\n   */\n  bind(baseTexture) {\n    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index])\n      throw new Error(`Index ${index} is out of bounds`);\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0)\n      if (baseTexture.resource)\n        this.addResourceAt(baseTexture.resource, index);\n      else\n        throw new Error("CubeResource does not support copying of renderTexture.");\n    else\n      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;\n    return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;\n  }\n  /**\n   * Upload the resource\n   * @param renderer\n   * @param _baseTexture\n   * @param glTexture\n   * @returns {boolean} true is success\n   */\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource2.SIDES; i++) {\n      const side = this.items[i];\n      (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i] = side.dirtyId) : dirty[i] < -1 && (renderer.gl.texImage2D(\n        side.target,\n        0,\n        glTexture.internalFormat,\n        _baseTexture.realWidth,\n        _baseTexture.realHeight,\n        0,\n        _baseTexture.format,\n        glTexture.type,\n        null\n      ), dirty[i] = -1));\n    }\n    return !0;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if source is an array of 6 elements\n   */\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource2.SIDES;\n  }\n};\n_CubeResource.SIDES = 6;\nlet CubeResource = _CubeResource;\n\n//# sourceMappingURL=CubeResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs\n\n\n\nclass ImageBitmapResource extends BaseImageResource {\n  /**\n   * @param source - ImageBitmap or URL to use.\n   * @param options - Options to use.\n   */\n  constructor(source, options) {\n    options = options || {};\n    let baseSource, url, ownsImageBitmap;\n    typeof source == "string" ? (baseSource = ImageBitmapResource.EMPTY, url = source, ownsImageBitmap = !0) : (baseSource = source, url = null, ownsImageBitmap = !1), super(baseSource), this.url = url, this.crossOrigin = options.crossOrigin ?? !0, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.ownsImageBitmap = options.ownsImageBitmap ?? ownsImageBitmap, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  load() {\n    return this._load ? this._load : (this._load = new Promise(async (resolve, reject) => {\n      if (this.url === null) {\n        resolve(this);\n        return;\n      }\n      try {\n        const response = await settings.ADAPTER.fetch(this.url, {\n          mode: this.crossOrigin ? "cors" : "no-cors"\n        });\n        if (this.destroyed)\n          return;\n        const imageBlob = await response.blob();\n        if (this.destroyed)\n          return;\n        const imageBitmap = await createImageBitmap(imageBlob, {\n          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"\n        });\n        if (this.destroyed) {\n          imageBitmap.close();\n          return;\n        }\n        this.source = imageBitmap, this.update(), resolve(this);\n      } catch (e) {\n        if (this.destroyed)\n          return;\n        reject(e), this.onError.emit(e);\n      }\n    }), this._load);\n  }\n  /**\n   * Upload the image bitmap resource to GPU.\n   * @param renderer - Renderer to upload to\n   * @param baseTexture - BaseTexture for this resource\n   * @param glTexture - GLTexture to use\n   * @returns {boolean} true is success\n   */\n  upload(renderer, baseTexture, glTexture) {\n    return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), super.upload(renderer, baseTexture, glTexture)) : (this.load(), !1);\n  }\n  /** Destroys this resource. */\n  dispose() {\n    this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap\n   */\n  static test(source) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof source == "string" || source instanceof ImageBitmap);\n  }\n  /**\n   * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.\n   * Only for internal usage.\n   * @returns The cached placeholder canvas.\n   */\n  static get EMPTY() {\n    return ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0), ImageBitmapResource._EMPTY;\n  }\n}\n\n//# sourceMappingURL=ImageBitmapResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs\n\n\n\nconst _SVGResource = class _SVGResource2 extends BaseImageResource {\n  /**\n   * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n   * @param {object} [options] - Options to use\n   * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n   * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n   * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n   * @param {boolean} [options.autoLoad=true] - Start loading right away.\n   */\n  constructor(sourceBase64, options) {\n    options = options || {}, super(settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== !1 && this.load();\n  }\n  load() {\n    return this._load ? this._load : (this._load = new Promise((resolve) => {\n      if (this._resolve = () => {\n        this.update(), resolve(this);\n      }, _SVGResource2.SVG_XML.test(this.svg.trim())) {\n        if (!btoa)\n          throw new Error("Your browser doesn\'t support base64 conversions.");\n        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n      }\n      this._loadSvg();\n    }), this._load);\n  }\n  /** Loads an SVG image from `imageUrl` or `data URL`. */\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = (event) => {\n      this._resolve && (tempImage.onerror = null, this.onError.emit(event));\n    }, tempImage.onload = () => {\n      if (!this._resolve)\n        return;\n      const svgWidth = tempImage.width, svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight)\n        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");\n      let width = svgWidth * this.scale, height = svgHeight * this.scale;\n      (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width, canvas.height = height, canvas._pixiId = `canvas_${uid()}`, canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;\n    };\n  }\n  /**\n   * Get size from an svg string using a regular expression.\n   * @param svgString - a serialized svg element\n   * @returns - image extension\n   */\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString), size = {};\n    return sizeMatch && (size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size;\n  }\n  /** Destroys this texture. */\n  dispose() {\n    super.dispose(), this._resolve = null, this._crossorigin = null;\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @param {string} extension - The extension of source, if set\n   * @returns {boolean} - If the source is a SVG source or data file\n   */\n  static test(source, extension) {\n    return extension === "svg" || typeof source == "string" && source.startsWith("data:image/svg+xml") || typeof source == "string" && _SVGResource2.SVG_XML.test(source);\n  }\n  // eslint-disable-line max-len\n};\n_SVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(\x3c!--[^(--\x3e)]*--\x3e)?\\s*\\<svg/m, /**\n* Regular expression for SVG size.\n* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;\n* @readonly\n*/\n_SVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=(\'|")(\\d*(?:\\.\\d+)?)(?:px)?(\'|"))[^>]*(?:\\s(width|height)=(\'|")(\\d*(?:\\.\\d+)?)(?:px)?(\'|"))[^>]*>/i;\nlet SVGResource = _SVGResource;\n\n//# sourceMappingURL=SVGResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs\n\n\nconst _VideoResource = class _VideoResource2 extends BaseImageResource {\n  /**\n   * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.\n   * @param {object} [options] - Options to use\n   * @param {boolean} [options.autoLoad=true] - Start loading the video immediately\n   * @param {boolean} [options.autoPlay=true] - Start playing video immediately\n   * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n   * @param {boolean} [options.loop=false] - Loops the video\n   * @param {boolean} [options.muted=false] - Mutes the video audio, useful for autoplay\n   * @param {boolean} [options.playsinline=true] - Prevents opening the video on mobile devices\n   */\n  constructor(source, options) {\n    if (options = options || {}, !(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement("video");\n      options.autoLoad !== !1 && videoElement.setAttribute("preload", "auto"), options.playsinline !== !1 && (videoElement.setAttribute("webkit-playsinline", ""), videoElement.setAttribute("playsinline", "")), options.muted === !0 && (videoElement.setAttribute("muted", ""), videoElement.muted = !0), options.loop === !0 && videoElement.setAttribute("loop", ""), options.autoPlay !== !1 && videoElement.setAttribute("autoplay", ""), typeof source == "string" && (source = [source]);\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement("source");\n        let { src, mime } = source[i];\n        if (src = src || source[i], src.startsWith("data:"))\n          mime = src.slice(5, src.indexOf(";"));\n        else if (!src.startsWith("blob:")) {\n          const baseSrc = src.split("?").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);\n          mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;\n        }\n        sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== !1, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== !1 && this.load();\n  }\n  /**\n   * Trigger updating of the texture.\n   * @param _deltaTime - time delta since last tick\n   */\n  update(_deltaTime = 0) {\n    if (!this.destroyed) {\n      if (this._updateFPS) {\n        const elapsedMS = Ticker_Ticker.shared.elapsedMS * this.source.playbackRate;\n        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      }\n      (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(\n        /* deltaTime*/\n      ), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n    }\n  }\n  _videoFrameRequestCallback() {\n    this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n      this._videoFrameRequestCallback\n    );\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<void>} Handle the validate event\n   */\n  load() {\n    if (this._load)\n      return this._load;\n    const source = this.source;\n    return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0), source.addEventListener("play", this._onPlayStart), source.addEventListener("pause", this._onPlayStop), source.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener("canplay", this._onCanPlay), source.addEventListener("canplaythrough", this._onCanPlay), source.addEventListener("error", this._onError, !0)), this._load = new Promise((resolve, reject) => {\n      this.valid ? resolve(this) : (this._resolve = resolve, this._reject = reject, source.load());\n    }), this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event\n   */\n  _onError(event) {\n    this.source.removeEventListener("error", this._onError, !0), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);\n  }\n  /**\n   * Returns true if the underlying source is playing.\n   * @returns - True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Returns true if the underlying source is ready for playing.\n   * @returns - True if ready.\n   */\n  _isSourceReady() {\n    return this.source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    this.valid || this._onCanPlay(), this._configureAutoUpdate();\n  }\n  /** Fired when a pause event is triggered, stops the update loop. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Fired when the video is completed seeking to the current playback position. */\n  _onSeeked() {\n    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay);\n    const valid = this.valid;\n    this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play();\n  }\n  /** Destroys this texture. */\n  dispose() {\n    this._configureAutoUpdate();\n    const source = this.source;\n    source && (source.removeEventListener("play", this._onPlayStart), source.removeEventListener("pause", this._onPlayStop), source.removeEventListener("seeked", this._onSeeked), source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay), source.removeEventListener("error", this._onError, !0), source.pause(), source.src = "", source.load()), super.dispose();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());\n  }\n  /**\n   * How many times a second to update the texture from the video. Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());\n  }\n  _configureAutoUpdate() {\n    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ticker_Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n      this._videoFrameRequestCallback\n    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ticker_Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ticker_Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));\n  }\n  /**\n   * Used to auto-detect the type of resource.\n   * @param {*} source - The source object\n   * @param {string} extension - The extension of source, if set\n   * @returns {boolean} `true` if video source\n   */\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);\n  }\n};\n_VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], /**\n* Map of video MIME types that can\'t be directly derived from file extensions.\n* @readonly\n*/\n_VideoResource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\nlet VideoResource = _VideoResource;\n\n//# sourceMappingURL=VideoResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\nINSTALLED.push(\n  ImageBitmapResource,\n  ImageResource,\n  CanvasResource,\n  VideoResource,\n  SVGResource,\n  BufferResource,\n  CubeResource,\n  ArrayResource\n);\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs\n\nclass TransformFeedback {\n  constructor() {\n    this._glTransformFeedbacks = {}, this.buffers = [], this.disposeRunner = new Runner("disposeTransformFeedback");\n  }\n  /**\n   * Bind buffer to TransformFeedback\n   * @param index - index to bind\n   * @param buffer - buffer to bind\n   */\n  bindBuffer(index, buffer) {\n    this.buffers[index] = buffer;\n  }\n  /** Destroy WebGL resources that are connected to this TransformFeedback. */\n  destroy() {\n    this.disposeRunner.emit(this, !1);\n  }\n}\n\n//# sourceMappingURL=TransformFeedback.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = "7.3.3";\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Bounds.mjs\n\nclass Bounds {\n  constructor() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;\n  }\n  /**\n   * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n   * It is not guaranteed that it will return tempRect\n   * @param rect - Temporary object will be used if AABB is not empty\n   * @returns - A rectangle of the bounds\n   */\n  getRectangle(rect) {\n    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle_Rectangle.EMPTY : (rect = rect || new Rectangle_Rectangle(0, 0, 1, 1), rect.x = this.minX, rect.y = this.minY, rect.width = this.maxX - this.minX, rect.height = this.maxY - this.minY, rect);\n  }\n  /**\n   * This function should be inlined when its possible.\n   * @param point - The point to add.\n   */\n  addPoint(point) {\n    this.minX = Math.min(this.minX, point.x), this.maxX = Math.max(this.maxX, point.x), this.minY = Math.min(this.minY, point.y), this.maxY = Math.max(this.maxY, point.y);\n  }\n  /**\n   * Adds a point, after transformed. This should be inlined when its possible.\n   * @param matrix\n   * @param point\n   */\n  addPointMatrix(matrix, point) {\n    const { a, b, c, d, tx, ty } = matrix, x = a * point.x + c * point.y + tx, y = b * point.x + d * point.y + ty;\n    this.minX = Math.min(this.minX, x), this.maxX = Math.max(this.maxX, x), this.minY = Math.min(this.minY, y), this.maxY = Math.max(this.maxY, y);\n  }\n  /**\n   * Adds a quad, not transformed\n   * @param vertices - The verts to add.\n   */\n  addQuad(vertices) {\n    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = vertices[0], y = vertices[1];\n    minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = vertices[2], y = vertices[3], minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = vertices[4], y = vertices[5], minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = vertices[6], y = vertices[7], minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;\n  }\n  /**\n   * Adds sprite frame, transformed.\n   * @param transform - transform to apply\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  addFrame(transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  }\n  /**\n   * Adds sprite frame, multiplied by matrix\n   * @param matrix - matrix to apply\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  addFrameMatrix(matrix, x0, y0, x1, y1) {\n    const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;\n    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = a * x0 + c * y0 + tx, y = b * x0 + d * y0 + ty;\n    minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = a * x1 + c * y0 + tx, y = b * x1 + d * y0 + ty, minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = a * x0 + c * y1 + tx, y = b * x0 + d * y1 + ty, minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = a * x1 + c * y1 + tx, y = b * x1 + d * y1 + ty, minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   */\n  addVertexData(vertexData, beginOffset, endOffset) {\n    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const x = vertexData[i], y = vertexData[i + 1];\n      minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;\n  }\n  /**\n   * Add an array of mesh vertices\n   * @param transform - mesh transform\n   * @param vertices - mesh coordinates in array\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   */\n  addVertices(transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  }\n  /**\n   * Add an array of mesh vertices.\n   * @param matrix - mesh matrix\n   * @param vertices - mesh coordinates in array\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param padX - x padding\n   * @param padY - y padding\n   */\n  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {\n    const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;\n    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const rawX = vertices[i], rawY = vertices[i + 1], x = a * rawX + c * rawY + tx, y = d * rawY + b * rawX + ty;\n      minX = Math.min(minX, x - padX), maxX = Math.max(maxX, x + padX), minY = Math.min(minY, y - padY), maxY = Math.max(maxY, y + padY);\n    }\n    this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;\n  }\n  /**\n   * Adds other {@link PIXI.Bounds}.\n   * @param bounds - The Bounds to be added\n   */\n  addBounds(bounds) {\n    const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX, this.minY = bounds.minY < minY ? bounds.minY : minY, this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX, this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param bounds - The Bounds to be added.\n   * @param mask - TODO\n   */\n  addBoundsMask(bounds, mask) {\n    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX, _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY, _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX, _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  /**\n   * Adds other Bounds, multiplied by matrix. Bounds shouldn\'t be empty.\n   * @param bounds - other bounds\n   * @param matrix - multiplicator\n   */\n  addBoundsMatrix(bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  }\n  /**\n   * Adds other Bounds, masked with Rectangle.\n   * @param bounds - TODO\n   * @param area - TODO\n   */\n  addBoundsArea(bounds, area) {\n    const _minX = bounds.minX > area.x ? bounds.minX : area.x, _minY = bounds.minY > area.y ? bounds.minY : area.y, _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width, _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.isEmpty() || (this.minX -= paddingX, this.maxX += paddingX, this.minY -= paddingY, this.maxY += paddingY);\n  }\n  /**\n   * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param padX - padding X\n   * @param padY - padding Y\n   */\n  addFramePad(x0, y0, x1, y1, padX, padY) {\n    x0 -= padX, y0 -= padY, x1 += padX, y1 += padY, this.minX = this.minX < x0 ? this.minX : x0, this.maxX = this.maxX > x1 ? this.maxX : x1, this.minY = this.minY < y0 ? this.minY : y0, this.maxY = this.maxY > y1 ? this.maxY : y1;\n  }\n}\n\n//# sourceMappingURL=Bounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/DisplayObject.mjs\n\n\nclass DisplayObject extends eventemitter3 {\n  constructor() {\n    super(), this.tempDisplayObjectParent = null, this.transform = new Transform_Transform(), this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Bounds(), this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1;\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to DisplayObject.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n      const propertyName = keys[i];\n      Object.defineProperty(\n        DisplayObject.prototype,\n        propertyName,\n        Object.getOwnPropertyDescriptor(source, propertyName)\n      );\n    }\n  }\n  /**\n   * Fired when this DisplayObject is added to a Container.\n   * @instance\n   * @event added\n   * @param {PIXI.Container} container - The container added to.\n   */\n  /**\n   * Fired when this DisplayObject is removed from a Container.\n   * @instance\n   * @event removed\n   * @param {PIXI.Container} container - The container removed from.\n   */\n  /**\n   * Fired when this DisplayObject is destroyed. This event is emitted once\n   * destroy is finished.\n   * @instance\n   * @event destroyed\n   */\n  /** Readonly flag for destroyed display objects. */\n  get destroyed() {\n    return this._destroyed;\n  }\n  /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\n  _recursivePostUpdateTransform() {\n    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n  }\n  /** Updates the object transform for rendering. TODO - Optimization pass! */\n  updateTransform() {\n    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  }\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n   *\n   * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n   * of a container depend on its children\'s bounds, which recursively causes all bounds in the subtree to\n   * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n   * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n   * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n   * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n   * its height increases.\n   *\n   * The transforms of all objects in a container\'s **subtree** and of all **ancestors** are updated.\n   * The world bounds of all display objects in a container\'s **subtree** will also be recalculated.\n   *\n   * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n   * calculation if needed.\n   *\n   * ```js\n   * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n   * ```\n   *\n   * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n   * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n   * details.\n   *\n   * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n   * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n   * cases.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param rect - Optional rectangle to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   */\n  getBounds(skipUpdate, rect) {\n    return skipUpdate || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), rect || (this._boundsRect || (this._boundsRect = new Rectangle_Rectangle()), rect = this._boundsRect), this._bounds.getRectangle(rect);\n  }\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   * @param rect - Optional rectangle to store the result of the bounds calculation.\n   * @returns - The rectangular bounding area.\n   */\n  getLocalBounds(rect) {\n    rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle_Rectangle()), rect = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());\n    const transformRef = this.transform, parentRef = this.parent;\n    this.parent = null, this._tempDisplayObjectParent.worldAlpha = parentRef?.worldAlpha ?? 1, this.transform = this._tempDisplayObjectParent.transform;\n    const worldBounds = this._bounds, worldBoundsID = this._boundsID;\n    this._bounds = this._localBounds;\n    const bounds = this.getBounds(!1, rect);\n    return this.parent = parentRef, this.transform = transformRef, this._bounds = worldBounds, this._bounds.updateID += this._boundsID - worldBoundsID, bounds;\n  }\n  /**\n   * Calculates the global position of the display object.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   */\n  toGlobal(position, point, skipUpdate = !1) {\n    return skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(position, point);\n  }\n  /**\n   * Calculates the local position of the display object relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The DisplayObject to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   */\n  toLocal(position, from, point, skipUpdate) {\n    return from && (position = from.toGlobal(position, point, skipUpdate)), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(position, point);\n  }\n  /**\n   * Set the parent Container of this DisplayObject.\n   * @param container - The Container to add this DisplayObject to.\n   * @returns - The Container that this DisplayObject was added to.\n   */\n  setParent(container) {\n    if (!container || !container.addChild)\n      throw new Error("setParent: Argument must be a Container");\n    return container.addChild(this), container;\n  }\n  /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n  /**\n   * Convenience function to set the position, scale, skew and pivot at once.\n   * @param x - The X position\n   * @param y - The Y position\n   * @param scaleX - The X scale value\n   * @param scaleY - The Y scale value\n   * @param rotation - The rotation\n   * @param skewX - The X skew value\n   * @param skewY - The Y skew value\n   * @param pivotX - The X pivot value\n   * @param pivotY - The Y pivot value\n   * @returns - The DisplayObject instance\n   */\n  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {\n    return this.position.x = x, this.position.y = y, this.scale.x = scaleX || 1, this.scale.y = scaleY || 1, this.rotation = rotation, this.skew.x = skewX, this.skew.y = skewY, this.pivot.x = pivotX, this.pivot.y = pivotY, this;\n  }\n  /**\n   * Base destroy method for generic display objects. This will automatically\n   * remove the display object from its parent Container as well as remove\n   * all current event listeners and internal references. Do not use a DisplayObject\n   * after calling `destroy()`.\n   * @param _options\n   */\n  destroy(_options) {\n    this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.eventMode = "auto", this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();\n  }\n  /**\n   * @protected\n   * @member {PIXI.Container}\n   */\n  get _tempDisplayObjectParent() {\n    return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;\n  }\n  /**\n   * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root.\n   *\n   * ```js\n   * const cacheParent = elem.enableTempParent();\n   * elem.updateTransform();\n   * elem.disableTempParent(cacheParent);\n   * ```\n   * @returns - Current parent\n   */\n  enableTempParent() {\n    const myParent = this.parent;\n    return this.parent = this._tempDisplayObjectParent, myParent;\n  }\n  /**\n   * Pair method for `enableTempParent`\n   * @param cacheParent - Actual parent of element\n   */\n  disableTempParent(cacheParent) {\n    this.parent = cacheParent;\n  }\n  /**\n   * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this.position.x;\n  }\n  set x(value) {\n    this.transform.position.x = value;\n  }\n  /**\n   * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this.position.y;\n  }\n  set y(value) {\n    this.transform.position.y = value;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    return this.transform.worldTransform;\n  }\n  /**\n   * Current transform of the object based on local factors: position, scale, other stuff.\n   * @readonly\n   */\n  get localTransform() {\n    return this.transform.localTransform;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this.transform.position;\n  }\n  set position(value) {\n    this.transform.position.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    return this.transform.scale;\n  }\n  set scale(value) {\n    this.transform.scale.copyFrom(value);\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent\'s local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    return this.transform.pivot;\n  }\n  set pivot(value) {\n    this.transform.pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    return this.transform.skew;\n  }\n  set skew(value) {\n    this.transform.skew.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this.transform.rotation;\n  }\n  set rotation(value) {\n    this.transform.rotation = value;\n  }\n  /**\n   * The angle of the object in degrees.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.transform.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.transform.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The zIndex of the displayObject.\n   *\n   * If a container has the sortableChildren property set to true, children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see PIXI.Container#sortableChildren\n   */\n  get zIndex() {\n    return this._zIndex;\n  }\n  set zIndex(value) {\n    this._zIndex !== value && (this._zIndex = value, this.parent && (this.parent.sortDirty = !0));\n  }\n  /**\n   * Indicates if the object is globally visible.\n   * @readonly\n   */\n  get worldVisible() {\n    let item = this;\n    do {\n      if (!item.visible)\n        return !1;\n      item = item.parent;\n    } while (item);\n    return !0;\n  }\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container\'s width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from \'pixi.js\';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @todo At the moment, CanvasRenderer doesn\'t support Sprite as mask.\n   */\n  get mask() {\n    return this._mask;\n  }\n  set mask(value) {\n    if (this._mask !== value) {\n      if (this._mask) {\n        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n        maskObject && (maskObject._maskRefCount--, maskObject._maskRefCount === 0 && (maskObject.renderable = !0, maskObject.isMask = !1));\n      }\n      if (this._mask = value, this._mask) {\n        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n        maskObject && (maskObject._maskRefCount === 0 && (maskObject.renderable = !1, maskObject.isMask = !0), maskObject._maskRefCount++);\n      }\n    }\n  }\n}\nclass TemporaryDisplayObject extends DisplayObject {\n  constructor() {\n    super(...arguments), this.sortDirty = null;\n  }\n}\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n\n//# sourceMappingURL=DisplayObject.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Container.mjs\n\n\nconst Container_tempMatrix = new Matrix();\nfunction sortChildren(a, b) {\n  return a.zIndex === b.zIndex ? a._lastSortedIndex - b._lastSortedIndex : a.zIndex - b.zIndex;\n}\nconst _Container = class _Container2 extends DisplayObject {\n  constructor() {\n    super(), this.children = [], this.sortableChildren = _Container2.defaultSortableChildren, this.sortDirty = !1;\n  }\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified.\n   * @param _length\n   */\n  onChildrenChange(_length) {\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n   * @returns {PIXI.DisplayObject} - The first child that was added.\n   */\n  addChild(...children) {\n    if (children.length > 1)\n      for (let i = 0; i < children.length; i++)\n        this.addChild(children[i]);\n    else {\n      const child = children[0];\n      child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = !0, child.transform._parentID = -1, this.children.push(child), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", child, this, this.children.length - 1), child.emit("added", this);\n    }\n    return children[0];\n  }\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {PIXI.DisplayObject} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {PIXI.DisplayObject} The child that was added.\n   */\n  addChildAt(child, index) {\n    if (index < 0 || index > this.children.length)\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n    return child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = !0, child.transform._parentID = -1, this.children.splice(index, 0, child), this._boundsID++, this.onChildrenChange(index), child.emit("added", this), this.emit("childAdded", child, this, index), child;\n  }\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   * @param child - First display object to swap\n   * @param child2 - Second display object to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2)\n      return;\n    const index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);\n    this.children[index1] = child2, this.children[index2] = child, this.onChildrenChange(index1 < index2 ? index1 : index2);\n  }\n  /**\n   * Returns the index position of a child DisplayObject instance\n   * @param child - The DisplayObject instance to identify\n   * @returns - The index position of the child display object to identify\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1)\n      throw new Error("The supplied DisplayObject must be a child of the caller");\n    return index;\n  }\n  /**\n   * Changes the position of an existing child in the display object container\n   * @param child - The child DisplayObject instance for which you want to change the index number\n   * @param index - The resulting index number for the child display object\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length)\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    const currentIndex = this.getChildIndex(child);\n    removeItems(this.children, currentIndex, 1), this.children.splice(index, 0, child), this.onChildrenChange(index);\n  }\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length)\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    return this.children[index];\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n   * @returns {PIXI.DisplayObject} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1)\n      for (let i = 0; i < children.length; i++)\n        this.removeChild(children[i]);\n    else {\n      const child = children[0], index = this.children.indexOf(child);\n      if (index === -1)\n        return null;\n      child.parent = null, child.transform._parentID = -1, removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index);\n    }\n    return children[0];\n  }\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return child.parent = null, child.transform._parentID = -1, removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index), child;\n  }\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   */\n  removeChildren(beginIndex = 0, endIndex = this.children.length) {\n    const begin = beginIndex, end = endIndex, range = end - begin;\n    let removed;\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n      for (let i = 0; i < removed.length; ++i)\n        removed[i].parent = null, removed[i].transform && (removed[i].transform._parentID = -1);\n      this._boundsID++, this.onChildrenChange(beginIndex);\n      for (let i = 0; i < removed.length; ++i)\n        removed[i].emit("removed", this), this.emit("childRemoved", removed[i], this, i);\n      return removed;\n    } else if (range === 0 && this.children.length === 0)\n      return [];\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  }\n  /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */\n  sortChildren() {\n    let sortRequired = !1;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      child._lastSortedIndex = i, !sortRequired && child.zIndex !== 0 && (sortRequired = !0);\n    }\n    sortRequired && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;\n  }\n  /** Updates the transform on all children of this container for rendering. */\n  updateTransform() {\n    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      child.visible && child.updateTransform();\n    }\n  }\n  /**\n   * Recalculates the bounds of the container.\n   *\n   * This implementation will automatically fit the children\'s bounds into the calculation. Each child\'s bounds\n   * is limited to its mask\'s bounds or filterArea, if any is applied.\n   */\n  calculateBounds() {\n    this._bounds.clear(), this._calculateBounds();\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (!(!child.visible || !child.renderable))\n        if (child.calculateBounds(), child._mask) {\n          const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;\n          maskObject ? (maskObject.calculateBounds(), this._bounds.addBoundsMask(child._bounds, maskObject._bounds)) : this._bounds.addBounds(child._bounds);\n        } else\n          child.filterArea ? this._bounds.addBoundsArea(child._bounds, child.filterArea) : this._bounds.addBounds(child._bounds);\n    }\n    this._bounds.updateID = this._boundsID;\n  }\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   *\n   * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\n   * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\n   * @param rect - Optional rectangle to store the result of the bounds calculation.\n   * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\n   *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n   * @returns - The rectangular bounding area.\n   */\n  getLocalBounds(rect, skipChildrenUpdate = !1) {\n    const result = super.getLocalBounds(rect);\n    if (!skipChildrenUpdate)\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        const child = this.children[i];\n        child.visible && child.updateTransform();\n      }\n    return result;\n  }\n  /**\n   * Recalculates the content bounds of this object. This should be overriden to\n   * calculate the bounds of this specific object (not including children).\n   * @protected\n   */\n  _calculateBounds() {\n  }\n  /**\n   * Renders this object and its children with culling.\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  _renderWithCulling(renderer) {\n    const sourceFrame = renderer.renderTexture.sourceFrame;\n    if (!(sourceFrame.width > 0 && sourceFrame.height > 0))\n      return;\n    let bounds, transform;\n    this.cullArea ? (bounds = this.cullArea, transform = this.worldTransform) : this._render !== _Container2.prototype._render && (bounds = this.getBounds(!0));\n    const projectionTransform = renderer.projection.transform;\n    if (projectionTransform && (transform ? (transform = Container_tempMatrix.copyFrom(transform), transform.prepend(projectionTransform)) : transform = projectionTransform), bounds && sourceFrame.intersects(bounds, transform))\n      this._render(renderer);\n    else if (this.cullArea)\n      return;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i], childCullable = child.cullable;\n      child.cullable = childCullable || !this.cullArea, child.render(renderer), child.cullable = childCullable;\n    }\n  }\n  /**\n   * Renders the object using the WebGL renderer.\n   *\n   * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\n   * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\n   * children afterward.\n   *\n   * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\n   * the bounds of this object are out of frame, this implementation will entirely skip rendering.\n   * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\n   * setting alpha to zero is not recommended for purely skipping rendering.\n   *\n   * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\n   * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\n   * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\n   * Other culling methods might be better suited for a large number static objects; see\n   * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\n   * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\n   *\n   * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\n   * filtering is applied on a container. This does, however, break batching and can affect performance when\n   * masking and filtering is applied extensively throughout the scene graph.\n   * @param renderer - The renderer\n   */\n  render(renderer) {\n    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))\n      if (this._mask || this.filters?.length)\n        this.renderAdvanced(renderer);\n      else if (this.cullable)\n        this._renderWithCulling(renderer);\n      else {\n        this._render(renderer);\n        for (let i = 0, j = this.children.length; i < j; ++i)\n          this.children[i].render(renderer);\n      }\n  }\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   * @param renderer - The renderer\n   */\n  renderAdvanced(renderer) {\n    const filters = this.filters, mask = this._mask;\n    if (filters) {\n      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;\n      for (let i = 0; i < filters.length; i++)\n        filters[i].enabled && this._enabledFilters.push(filters[i]);\n    }\n    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));\n    if (flush && renderer.batch.flush(), filters && this._enabledFilters?.length && renderer.filter.push(this, this._enabledFilters), mask && renderer.mask.push(this, this._mask), this.cullable)\n      this._renderWithCulling(renderer);\n    else {\n      this._render(renderer);\n      for (let i = 0, j = this.children.length; i < j; ++i)\n        this.children[i].render(renderer);\n    }\n    flush && renderer.batch.flush(), mask && renderer.mask.pop(this), filters && this._enabledFilters?.length && renderer.filter.pop();\n  }\n  /**\n   * To be overridden by the subclasses.\n   * @param _renderer - The renderer\n   */\n  _render(_renderer) {\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  destroy(options) {\n    super.destroy(), this.sortDirty = !1;\n    const destroyChildren = typeof options == "boolean" ? options : options?.children, oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren)\n      for (let i = 0; i < oldChildren.length; ++i)\n        oldChildren[i].destroy(options);\n  }\n  /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return this.scale.x * this.getLocalBounds().width;\n  }\n  set width(value) {\n    const width = this.getLocalBounds().width;\n    width !== 0 ? this.scale.x = value / width : this.scale.x = 1, this._width = value;\n  }\n  /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return this.scale.y * this.getLocalBounds().height;\n  }\n  set height(value) {\n    const height = this.getLocalBounds().height;\n    height !== 0 ? this.scale.y = value / height : this.scale.y = 1, this._height = value;\n  }\n};\n_Container.defaultSortableChildren = !1;\nlet Container_Container = _Container;\nContainer_Container.prototype.containerUpdateTransform = Container_Container.prototype.updateTransform;\n\n//# sourceMappingURL=Container.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/settings.mjs\n\n\n\nObject.defineProperties(settings, {\n  /**\n   * Sets the default value for the container property \'sortableChildren\'.\n   * @static\n   * @name SORTABLE_CHILDREN\n   * @memberof PIXI.settings\n   * @deprecated since 7.1.0\n   * @type {boolean}\n   * @see PIXI.Container.defaultSortableChildren\n   */\n  SORTABLE_CHILDREN: {\n    get() {\n      return Container_Container.defaultSortableChildren;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), Container_Container.defaultSortableChildren = value;\n    }\n  }\n});\n\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/Sprite.mjs\n\n\nconst tempPoint = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\nclass Sprite_Sprite extends Container_Container {\n  /** @param texture - The texture for this sprite. */\n  constructor(texture) {\n    super(), this._anchor = new ObservablePoint(\n      this._onAnchorUpdate,\n      this,\n      texture ? texture.defaultAnchor.x : 0,\n      texture ? texture.defaultAnchor.y : 0\n    ), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new Color_Color(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = lib_BLEND_MODES.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = texture || Texture_Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = indices, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = settings.ROUND_PIXELS;\n  }\n  /** When the texture is updated, this event will fire to update the scale and frame. */\n  _onTextureUpdate() {\n    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);\n  }\n  /** Called when the anchor position updates. */\n  _onAnchorUpdate() {\n    this._transformID = -1, this._transformTrimmedID = -1;\n  }\n  /** Calculates worldTransform * vertices, store it in vertexData. */\n  calculateVertices() {\n    const texture = this._texture;\n    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)\n      return;\n    this._textureID !== texture._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = texture._updateID;\n    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData, trim = texture.trim, orig = texture.orig, anchor = this._anchor;\n    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;\n    if (trim ? (w1 = trim.x - anchor._x * orig.width, w0 = w1 + trim.width, h1 = trim.y - anchor._y * orig.height, h0 = h1 + trim.height) : (w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height), vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) {\n      const resolution = settings.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i)\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n    }\n  }\n  /**\n   * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.\n   *\n   * This is used to ensure that the true width and height of a trimmed texture is respected.\n   */\n  calculateTrimmedVertices() {\n    if (!this.vertexTrimmedData)\n      this.vertexTrimmedData = new Float32Array(8);\n    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n      return;\n    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n    const texture = this._texture, vertexData = this.vertexTrimmedData, orig = texture.orig, anchor = this._anchor, wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height;\n    if (vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) {\n      const resolution = settings.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i)\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n    }\n  }\n  /**\n   *\n   * Renders the object using the WebGL renderer\n   * @param renderer - The webgl renderer to use.\n   */\n  _render(renderer) {\n    this.calculateVertices(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this);\n  }\n  /** Updates the bounds of the sprite. */\n  _calculateBounds() {\n    const trim = this._texture.trim, orig = this._texture.orig;\n    !trim || trim.width === orig.width && trim.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n  }\n  /**\n   * Gets the local bounds of the sprite object.\n   * @param rect - Optional output rectangle.\n   * @returns The bounds.\n   */\n  getLocalBounds(rect) {\n    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle_Rectangle()), rect = this._localBoundsRect), this._localBounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);\n  }\n  /**\n   * Tests if a point is inside this sprite\n   * @param point - the point to test\n   * @returns The result of the test\n   */\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    const width = this._texture.orig.width, height = this._texture.orig.height, x1 = -width * this.anchor.x;\n    let y1 = 0;\n    return tempPoint.x >= x1 && tempPoint.x < x1 + width && (y1 = -height * this.anchor.y, tempPoint.y >= y1 && tempPoint.y < y1 + height);\n  }\n  /**\n   * Destroys this sprite and optionally its texture and children.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. \'options\' will be passed on to those calls.\n   * @param [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n  destroy(options) {\n    if (super.destroy(options), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof options == "boolean" ? options : options?.texture) {\n      const destroyBaseTexture = typeof options == "boolean" ? options : options?.baseTexture;\n      this._texture.destroy(!!destroyBaseTexture);\n    }\n    this._texture = null;\n  }\n  // some helper functions..\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @param {string|PIXI.Texture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source\n   *     - Source to create texture from\n   * @param {object} [options] - See {@link PIXI.BaseTexture}\'s constructor for options.\n   * @returns The newly created sprite\n   */\n  static from(source, options) {\n    const texture = source instanceof Texture_Texture ? source : Texture_Texture.from(source, options);\n    return new Sprite_Sprite(texture);\n  }\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   *\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   *\n   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n   * @default false\n   */\n  set roundPixels(value) {\n    this._roundPixels !== value && (this._transformID = -1, this._transformTrimmedID = -1), this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    const s = sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width, this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    const s = sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height, this._height = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite\'s origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite(Texture.WHITE);\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    this._anchor.copyFrom(value);\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber();\n  }\n  /**\n   * Get the tint as a RGB integer.\n   * @ignore\n   */\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture !== value && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = value || Texture_Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once("update", this._onTextureUpdate, this)));\n  }\n}\n\n//# sourceMappingURL=Sprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs\n\n\n\nconst _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = !1;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = null;\nclass CacheData {\n  constructor() {\n    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n  }\n}\nObject.defineProperties(DisplayObject.prototype, {\n  /**\n   * The resolution to use for cacheAsBitmap. By default this will use the renderer\'s resolution\n   * but can be overriden for performance. Lower values will reduce memory usage at the expense\n   * of render quality. A falsey value of `null` or `0` will default to the renderer\'s resolution.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.\n   * @member {number|null} cacheAsBitmapResolution\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   */\n  cacheAsBitmapResolution: {\n    get() {\n      return this._cacheAsBitmapResolution;\n    },\n    set(resolution) {\n      resolution !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = resolution, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer\'s\n   * sample count is used.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.\n   * @member {number|null} cacheAsBitmapMultisample\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   */\n  cacheAsBitmapMultisample: {\n    get() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set(multisample) {\n      multisample !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = multisample, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * Set this to true if you want this display object to be cached as a bitmap.\n   * This basically takes a snapshot of the display object as it is at that moment. It can\n   * provide a performance benefit for complex static displayObjects.\n   * To remove simply set this property to `false`\n   *\n   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true\n   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  cacheAsBitmap: {\n    get() {\n      return this._cacheAsBitmap;\n    },\n    set(value) {\n      if (this._cacheAsBitmap === value)\n        return;\n      this._cacheAsBitmap = value;\n      let data;\n      value ? (this._cacheData || (this._cacheData = new CacheData()), data = this._cacheData, data.originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (data = this._cacheData, data.sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, this._mask = data.originalMask, this.filterArea = data.originalFilterArea);\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function(renderer) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer));\n};\nDisplayObject.prototype._initCachedDisplayObject = function(renderer) {\n  if (this._cacheData?.sprite)\n    return;\n  const cacheAlpha = this.alpha;\n  this.alpha = 1, renderer.batch.flush();\n  const bounds = this.getLocalBounds(new Rectangle_Rectangle(), !0);\n  if (this.filters?.length) {\n    const padding = this.filters[0].padding;\n    bounds.pad(padding);\n  }\n  const resolution = this.cacheAsBitmapResolution || renderer.resolution;\n  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);\n  const cachedRenderTexture = renderer.renderTexture.current, cachedSourceFrame = renderer.renderTexture.sourceFrame.clone(), cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone(), cachedProjectionTransform = renderer.projection.transform, renderTexture = RenderTexture.create({\n    width: bounds.width,\n    height: bounds.height,\n    resolution,\n    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample\n  }), textureCacheId = `cacheAsBitmap_${uid()}`;\n  this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture_Texture.addToCache(renderTexture, textureCacheId);\n  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);\n  this.render = this._cacheData.originalRender, renderer.render(this, { renderTexture, clear: !0, transform: m, skipUpdateTransform: !1 }), renderer.framebuffer.blit(), renderer.projection.transform = cachedProjectionTransform, renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite_Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._renderCachedCanvas = function(renderer) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer));\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function(renderer) {\n  if (this._cacheData?.sprite)\n    return;\n  const bounds = this.getLocalBounds(new Rectangle_Rectangle(), !0), cacheAlpha = this.alpha;\n  this.alpha = 1;\n  const cachedRenderTarget = renderer.canvasContext.activeContext, cachedProjectionTransform = renderer._projTransform, resolution = this.cacheAsBitmapResolution || renderer.resolution;\n  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);\n  const renderTexture = RenderTexture.create({\n    width: bounds.width,\n    height: bounds.height,\n    resolution\n  }), textureCacheId = `cacheAsBitmap_${uid()}`;\n  this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture_Texture.addToCache(renderTexture, textureCacheId);\n  const m = _tempMatrix;\n  this.transform.localTransform.copyTo(m), m.invert(), m.tx -= bounds.x, m.ty -= bounds.y, this.renderCanvas = this._cacheData.originalRenderCanvas, renderer.render(this, { renderTexture, clear: !0, transform: m, skipUpdateTransform: !1 }), renderer.canvasContext.activeContext = cachedRenderTarget, renderer._projTransform = cachedProjectionTransform, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite_Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._calculateCachedBounds = function() {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function() {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture_Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function(options) {\n  this.cacheAsBitmap = !1, this.destroy(options);\n};\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs\n\nDisplayObject.prototype.name = null;\nContainer_Container.prototype.getChildByName = function(name, deep) {\n  for (let i = 0, j = this.children.length; i < j; i++)\n    if (this.children[i].name === name)\n      return this.children[i];\n  if (deep)\n    for (let i = 0, j = this.children.length; i < j; i++) {\n      const child = this.children[i];\n      if (!child.getChildByName)\n        continue;\n      const target = child.getChildByName(name, !0);\n      if (target)\n        return target;\n    }\n  return null;\n};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-global-position/lib/index.mjs\n\n\nDisplayObject.prototype.getGlobalPosition = function(point = new Point(), skipUpdate = !1) {\n  return this.parent ? this.parent.toGlobal(this.position, point, skipUpdate) : (point.x = this.position.x, point.y = this.position.y), point;\n};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/alpha.frag.mjs\nvar alpha_frag_fragment = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n`;\n\n//# sourceMappingURL=alpha.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs\n\n\nclass AlphaFilter extends Filter {\n  /**\n   * @param alpha - Amount of alpha from 0 to 1, where 0 is transparent\n   */\n  constructor(alpha = 1) {\n    super(fragments_defaultVertex, alpha_frag_fragment, { uAlpha: 1 }), this.alpha = alpha;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n}\n\n//# sourceMappingURL=AlphaFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs\nconst GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n}, generateBlurFragSource_fragTemplate = [\n  "varying vec2 vBlurTexCoords[%size%];",\n  "uniform sampler2D uSampler;",\n  "void main(void)",\n  "{",\n  "    gl_FragColor = vec4(0.0);",\n  "    %blur%",\n  "}"\n].join(`\n`);\nfunction generateBlurFragSource(kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize], halfLength = kernel.length;\n  let fragSource = generateBlurFragSource_fragTemplate, blurLoop = "";\n  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";\n  let value;\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace("%index%", i.toString());\n    value = i, i >= halfLength && (value = kernelSize - i - 1), blur = blur.replace("%value%", kernel[value].toString()), blurLoop += blur, blurLoop += `\n`;\n  }\n  return fragSource = fragSource.replace("%blur%", blurLoop), fragSource = fragSource.replace("%size%", kernelSize.toString()), fragSource;\n}\n\n//# sourceMappingURL=generateBlurFragSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs\nconst vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(kernelSize, x) {\n  const halfLength = Math.ceil(kernelSize / 2);\n  let vertSource = vertTemplate, blurLoop = "", template;\n  x ? template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace("%index%", i.toString());\n    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`), blurLoop += blur, blurLoop += `\n`;\n  }\n  return vertSource = vertSource.replace("%blur%", blurLoop), vertSource = vertSource.replace("%size%", kernelSize.toString()), vertSource;\n}\n\n//# sourceMappingURL=generateBlurVertSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs\n\n\n\nclass BlurFilterPass extends Filter {\n  /**\n   * @param horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n   * @param strength - The strength of the blur filter.\n   * @param quality - The quality of the blur filter.\n   * @param {number|null} [resolution=PIXI.Filter.defaultResolution] - The resolution of the blur filter.\n   * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n   */\n  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {\n    const vertSrc = generateBlurVertSource(kernelSize, horizontal), fragSrc = generateBlurFragSource(kernelSize);\n    super(\n      // vertex shader\n      vertSrc,\n      // fragment shader\n      fragSrc\n    ), this.horizontal = horizontal, this.resolution = resolution, this._quality = 0, this.quality = quality, this.blur = strength;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   */\n  apply(filterManager, input, output, clearMode) {\n    if (output ? this.horizontal ? this.uniforms.strength = 1 / output.width * (output.width / input.width) : this.uniforms.strength = 1 / output.height * (output.height / input.height) : this.horizontal ? this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width) : this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)\n      filterManager.applyFilter(this, input, output, clearMode);\n    else {\n      const renderTarget = filterManager.getFilterTexture(), renderer = filterManager.renderer;\n      let flip = input, flop = renderTarget;\n      this.state.blend = !1, filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);\n      for (let i = 1; i < this.passes - 1; i++) {\n        filterManager.bindAndClear(flip, CLEAR_MODES.BLIT), this.uniforms.uSampler = flop;\n        const temp = flop;\n        flop = flip, flip = temp, renderer.shader.bind(this), renderer.geometry.draw(5);\n      }\n      this.state.blend = !0, filterManager.applyFilter(this, flop, output, clearMode), filterManager.returnFilterTexture(renderTarget);\n    }\n  }\n  /**\n   * Sets the strength of both the blur.\n   * @default 16\n   */\n  get blur() {\n    return this.strength;\n  }\n  set blur(value) {\n    this.padding = 1 + Math.abs(value) * 2, this.strength = value;\n  }\n  /**\n   * Sets the quality of the blur by modifying the number of passes. More passes means higher\n   * quality bluring but the lower the performance.\n   * @default 4\n   */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value, this.passes = value;\n  }\n}\n\n//# sourceMappingURL=BlurFilterPass.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs\n\n\nclass BlurFilter extends Filter {\n  /**\n   * @param strength - The strength of the blur filter.\n   * @param quality - The quality of the blur filter.\n   * @param {number|null} [resolution=PIXI.Filter.defaultResolution] - The resolution of the blur filter.\n   * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n   */\n  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {\n    super(), this._repeatEdgePixels = !1, this.blurXFilter = new BlurFilterPass(!0, strength, quality, resolution, kernelSize), this.blurYFilter = new BlurFilterPass(!1, strength, quality, resolution, kernelSize), this.resolution = resolution, this.quality = quality, this.blur = strength, this.repeatEdgePixels = !1;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   */\n  apply(filterManager, input, output, clearMode) {\n    const xStrength = Math.abs(this.blurXFilter.strength), yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      const renderTarget = filterManager.getFilterTexture();\n      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR), this.blurYFilter.apply(filterManager, renderTarget, output, clearMode), filterManager.returnFilterTexture(renderTarget);\n    } else\n      yStrength ? this.blurYFilter.apply(filterManager, input, output, clearMode) : this.blurXFilter.apply(filterManager, input, output, clearMode);\n  }\n  updatePadding() {\n    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   */\n  get blur() {\n    return this.blurXFilter.blur;\n  }\n  set blur(value) {\n    this.blurXFilter.blur = this.blurYFilter.blur = value, this.updatePadding();\n  }\n  /**\n   * Sets the number of passes for blur. More passes means higher quality bluring.\n   * @default 1\n   */\n  get quality() {\n    return this.blurXFilter.quality;\n  }\n  set quality(value) {\n    this.blurXFilter.quality = this.blurYFilter.quality = value;\n  }\n  /**\n   * Sets the strength of the blurX property\n   * @default 2\n   */\n  get blurX() {\n    return this.blurXFilter.blur;\n  }\n  set blurX(value) {\n    this.blurXFilter.blur = value, this.updatePadding();\n  }\n  /**\n   * Sets the strength of the blurY property\n   * @default 2\n   */\n  get blurY() {\n    return this.blurYFilter.blur;\n  }\n  set blurY(value) {\n    this.blurYFilter.blur = value, this.updatePadding();\n  }\n  /**\n   * Sets the blendmode of the filter\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  get blendMode() {\n    return this.blurYFilter.blendMode;\n  }\n  set blendMode(value) {\n    this.blurYFilter.blendMode = value;\n  }\n  /**\n   * If set to true the edge of the target will be clamped\n   * @default false\n   */\n  get repeatEdgePixels() {\n    return this._repeatEdgePixels;\n  }\n  set repeatEdgePixels(value) {\n    this._repeatEdgePixels = value, this.updatePadding();\n  }\n}\n\n//# sourceMappingURL=BlurFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.frag.mjs\nvar colorMatrix_frag_fragment = `varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n`;\n\n//# sourceMappingURL=colorMatrix.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs\n\n\nclass ColorMatrixFilter extends Filter {\n  constructor() {\n    const uniforms = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    super(defaultFilterVertex, colorMatrix_frag_fragment, uniforms), this.alpha = 1;\n  }\n  /**\n   * Transforms current matrix and set the new one\n   * @param {number[]} matrix - 5x4 matrix\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  _loadMatrix(matrix, multiply = !1) {\n    let newMatrix = matrix;\n    multiply && (this._multiply(newMatrix, this.uniforms.m, matrix), newMatrix = this._colorMatrix(newMatrix)), this.uniforms.m = newMatrix;\n  }\n  /**\n   * Multiplies two mat5\'s\n   * @private\n   * @param out - 5x4 matrix the receiving matrix\n   * @param a - 5x4 matrix the first operand\n   * @param b - 5x4 matrix the second operand\n   * @returns {number[]} 5x4 matrix\n   */\n  _multiply(out, a, b) {\n    return out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15], out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16], out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17], out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18], out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4], out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15], out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16], out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17], out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18], out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9], out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15], out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16], out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17], out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18], out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14], out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15], out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16], out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17], out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18], out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19], out;\n  }\n  /**\n   * Create a Float32 Array and normalize the offset component to 0-1\n   * @param {number[]} matrix - 5x4 matrix\n   * @returns {number[]} 5x4 matrix with all values between 0-1\n   */\n  _colorMatrix(matrix) {\n    const m = new Float32Array(matrix);\n    return m[4] /= 255, m[9] /= 255, m[14] /= 255, m[19] /= 255, m;\n  }\n  /**\n   * Adjusts brightness\n   * @param b - value of the brigthness (0-1, where 0 is black)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  brightness(b, multiply) {\n    const matrix = [\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Sets each channel on the diagonal of the color matrix.\n   * This can be used to achieve a tinting effect on Containers similar to the tint field of some\n   * display objects like Sprite, Text, Graphics, and Mesh.\n   * @param color - Color of the tint. This is a hex value.\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  tint(color, multiply) {\n    const [r, g, b] = Color_Color.shared.setValue(color).toArray(), matrix = [\n      r,\n      0,\n      0,\n      0,\n      0,\n      0,\n      g,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Set the matrices in grey scales\n   * @param scale - value of the grey (0-1, where 0 is black)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  greyscale(scale, multiply) {\n    const matrix = [\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Set the black and white matrice.\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  blackAndWhite(multiply) {\n    const matrix = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Set the hue property of the color\n   * @param rotation - in degrees\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  hue(rotation, multiply) {\n    rotation = (rotation || 0) / 180 * Math.PI;\n    const cosR = Math.cos(rotation), sinR = Math.sin(rotation), sqrt = Math.sqrt, w = 1 / 3, sqrW = sqrt(w), a00 = cosR + (1 - cosR) * w, a01 = w * (1 - cosR) - sqrW * sinR, a02 = w * (1 - cosR) + sqrW * sinR, a10 = w * (1 - cosR) + sqrW * sinR, a11 = cosR + w * (1 - cosR), a12 = w * (1 - cosR) - sqrW * sinR, a20 = w * (1 - cosR) - sqrW * sinR, a21 = w * (1 - cosR) + sqrW * sinR, a22 = cosR + w * (1 - cosR), matrix = [\n      a00,\n      a01,\n      a02,\n      0,\n      0,\n      a10,\n      a11,\n      a12,\n      0,\n      0,\n      a20,\n      a21,\n      a22,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Set the contrast matrix, increase the separation between dark and bright\n   * Increase contrast : shadows darker and highlights brighter\n   * Decrease contrast : bring the shadows up and the highlights down\n   * @param amount - value of the contrast (0-1)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  contrast(amount, multiply) {\n    const v = (amount || 0) + 1, o = -0.5 * (v - 1), matrix = [\n      v,\n      0,\n      0,\n      0,\n      o,\n      0,\n      v,\n      0,\n      0,\n      o,\n      0,\n      0,\n      v,\n      0,\n      o,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Set the saturation matrix, increase the separation between colors\n   * Increase saturation : increase contrast, brightness, and sharpness\n   * @param amount - The saturation amount (0-1)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  saturate(amount = 0, multiply) {\n    const x = amount * 2 / 3 + 1, y = (x - 1) * -0.5, matrix = [\n      x,\n      y,\n      y,\n      0,\n      0,\n      y,\n      x,\n      y,\n      0,\n      0,\n      y,\n      y,\n      x,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /** Desaturate image (remove color) Call the saturate function */\n  desaturate() {\n    this.saturate(-1);\n  }\n  /**\n   * Negative image (inverse of classic rgb matrix)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  negative(multiply) {\n    const matrix = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Sepia image\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  sepia(multiply) {\n    const matrix = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Color motion picture process invented in 1916 (thanks Dominic Szablewski)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  technicolor(multiply) {\n    const matrix = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Polaroid filter\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  polaroid(multiply) {\n    const matrix = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Filter who transforms : Red -> Blue and Blue -> Red\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  toBGR(multiply) {\n    const matrix = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  kodachrome(multiply) {\n    const matrix = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Brown delicious browni filter (thanks Dominic Szablewski)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  browni(multiply) {\n    const matrix = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Vintage filter (thanks Dominic Szablewski)\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  vintage(multiply) {\n    const matrix = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * We don\'t know exactly what it does, kind of gradient map, but funny to play with!\n   * @param desaturation - Tone values.\n   * @param toned - Tone values.\n   * @param lightColor - Tone values, example: `0xFFE580`\n   * @param darkColor - Tone values, example: `0xFFE580`\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  colorTone(desaturation, toned, lightColor, darkColor, multiply) {\n    desaturation = desaturation || 0.2, toned = toned || 0.15, lightColor = lightColor || 16770432, darkColor = darkColor || 3375104;\n    const temp = Color_Color.shared, [lR, lG, lB] = temp.setValue(lightColor).toArray(), [dR, dG, dB] = temp.setValue(darkColor).toArray(), matrix = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      lR,\n      lG,\n      lB,\n      desaturation,\n      0,\n      dR,\n      dG,\n      dB,\n      toned,\n      0,\n      lR - dR,\n      lG - dG,\n      lB - dB,\n      0,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Night effect\n   * @param intensity - The intensity of the night effect.\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  night(intensity, multiply) {\n    intensity = intensity || 0.1;\n    const matrix = [\n      intensity * -2,\n      -intensity,\n      0,\n      0,\n      0,\n      -intensity,\n      0,\n      intensity,\n      0,\n      0,\n      0,\n      intensity,\n      intensity * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * Predator effect\n   *\n   * Erase the current matrix by setting a new indepent one\n   * @param amount - how much the predator feels his future victim\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  predator(amount, multiply) {\n    const matrix = [\n      // row 1\n      11.224130630493164 * amount,\n      -4.794486999511719 * amount,\n      -2.8746118545532227 * amount,\n      0 * amount,\n      0.40342438220977783 * amount,\n      // row 2\n      -3.6330697536468506 * amount,\n      9.193157196044922 * amount,\n      -2.951810836791992 * amount,\n      0 * amount,\n      -1.316135048866272 * amount,\n      // row 3\n      -3.2184197902679443 * amount,\n      -4.2375030517578125 * amount,\n      7.476448059082031 * amount,\n      0 * amount,\n      0.8044459223747253 * amount,\n      // row 4\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /**\n   * LSD effect\n   *\n   * Multiply the current matrix\n   * @param multiply - if true, current matrix and matrix are multiplied. If false,\n   *  just set the current matrix with @param matrix\n   */\n  lsd(multiply) {\n    const matrix = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  /** Erase the current matrix by setting the default one. */\n  reset() {\n    const matrix = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, !1);\n  }\n  /**\n   * The matrix of the color matrix filter\n   * @member {number[]}\n   * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n   */\n  get matrix() {\n    return this.uniforms.m;\n  }\n  set matrix(value) {\n    this.uniforms.m = value;\n  }\n  /**\n   * The opacity value to use when mixing the original and resultant colors.\n   *\n   * When the value is 0, the original color is used without modification.\n   * When the value is 1, the result color is used.\n   * When in the range (0, 1) the color is interpolated between the original and result by this amount.\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n}\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n\n//# sourceMappingURL=ColorMatrixFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement.frag.mjs\nvar displacement_frag_fragment = `varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n`;\n\n//# sourceMappingURL=displacement.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement.vert.mjs\nvar displacement_vert_vertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n`;\n\n//# sourceMappingURL=displacement.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs\n\n\n\nclass DisplacementFilter extends Filter {\n  /**\n   * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n   * @param scale - The scale of the displacement\n   */\n  constructor(sprite, scale) {\n    const maskMatrix = new Matrix();\n    sprite.renderable = !1, super(displacement_vert_vertex, displacement_frag_fragment, {\n      mapSampler: sprite._texture,\n      filterMatrix: maskMatrix,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }), this.maskSprite = sprite, this.maskMatrix = maskMatrix, scale == null && (scale = 20), this.scale = new Point(scale, scale);\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - clearMode.\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;\n    const wt = this.maskSprite.worldTransform, lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b), lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n    lenX !== 0 && lenY !== 0 && (this.uniforms.rotation[0] = wt.a / lenX, this.uniforms.rotation[1] = wt.b / lenX, this.uniforms.rotation[2] = wt.c / lenY, this.uniforms.rotation[3] = wt.d / lenY), filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /** The texture used for the displacement map. Must be power of 2 sized texture. */\n  get map() {\n    return this.uniforms.mapSampler;\n  }\n  set map(value) {\n    this.uniforms.mapSampler = value;\n  }\n}\n\n//# sourceMappingURL=DisplacementFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa.frag.mjs\nvar fxaa_frag_fragment = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n\n//# sourceMappingURL=fxaa.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa.vert.mjs\nvar fxaa_vert_vertex = `\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n`;\n\n//# sourceMappingURL=fxaa.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs\n\n\n\nclass FXAAFilter extends Filter {\n  constructor() {\n    super(fxaa_vert_vertex, fxaa_frag_fragment);\n  }\n}\n\n//# sourceMappingURL=FXAAFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/noise.frag.mjs\nvar noise_frag_fragment = `precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n`;\n\n//# sourceMappingURL=noise.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs\n\n\nclass NoiseFilter extends Filter {\n  /**\n   * @param {number} [noise=0.5] - The noise intensity, should be a normalized value in the range [0, 1].\n   * @param {number} [seed] - A random seed for the noise generation. Default is `Math.random()`.\n   */\n  constructor(noise = 0.5, seed = Math.random()) {\n    super(defaultFilterVertex, noise_frag_fragment, {\n      uNoise: 0,\n      uSeed: 0\n    }), this.noise = noise, this.seed = seed;\n  }\n  /**\n   * The amount of noise to apply, this value should be in the range (0, 1].\n   * @default 0.5\n   */\n  get noise() {\n    return this.uniforms.uNoise;\n  }\n  set noise(value) {\n    this.uniforms.uNoise = value;\n  }\n  /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */\n  get seed() {\n    return this.uniforms.uSeed;\n  }\n  set seed(value) {\n    this.uniforms.uSeed = value;\n  }\n}\n\n//# sourceMappingURL=NoiseFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters.mjs\n\n\n\n\n\n\n\nconst filters = {\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.AlphaFilter\n   */\n  AlphaFilter: AlphaFilter,\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.BlurFilter\n   */\n  BlurFilter: BlurFilter,\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.BlurFilterPass\n   */\n  BlurFilterPass: BlurFilterPass,\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.ColorMatrixFilter\n   */\n  ColorMatrixFilter: ColorMatrixFilter,\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.DisplacementFilter\n   */\n  DisplacementFilter: DisplacementFilter,\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.FXAAFilter\n   */\n  FXAAFilter: FXAAFilter,\n  /**\n   * @class\n   * @memberof PIXI.filters\n   * @deprecated since 7.1.0\n   * @see PIXI.NoiseFilter\n   */\n  NoiseFilter: NoiseFilter\n};\nObject.entries(filters).forEach(([key, FilterClass]) => {\n  Object.defineProperty(filters, key, {\n    get() {\n      return deprecation("7.1.0", `filters.${key} has moved to ${key}`), FilterClass;\n    }\n  });\n});\n\n//# sourceMappingURL=filters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventTicker.mjs\n\nclass EventsTickerClass {\n  constructor() {\n    this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0;\n  }\n  /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */\n  init(events) {\n    this.removeTickerListener(), this.events = events, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0;\n  }\n  /** Whether to pause the update checks or not. */\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  /** Adds the ticker listener. */\n  addTickerListener() {\n    this.tickerAdded || !this.domElement || (Ticker_Ticker.system.add(this.tickerUpdate, this, const_UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);\n  }\n  /** Removes the ticker listener. */\n  removeTickerListener() {\n    this.tickerAdded && (Ticker_Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);\n  }\n  /** Sets flag to not fire extra events when the user has already moved there mouse */\n  pointerMoved() {\n    this._didMove = !0;\n  }\n  /** Updates the state of interactive objects. */\n  update() {\n    if (!this.domElement || this._pauseUpdate)\n      return;\n    if (this._didMove) {\n      this._didMove = !1;\n      return;\n    }\n    const rootPointerEvent = this.events.rootPointerEvent;\n    this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY\n    }));\n  }\n  /**\n   * Updates the state of interactive objects if at least {@link PIXI.EventsTicker#interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n   * @param deltaTime - time delta since the last call\n   */\n  tickerUpdate(deltaTime) {\n    this._deltaTime += deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\n//# sourceMappingURL=EventTicker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEvent.mjs\n\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary\'s jurisdiction.\n   */\n  constructor(manager) {\n    this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new Point(), this.page = new Point(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated @code{PIXI.InteractionEvent.data}.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /** The propagation path for this event. Alias for {@link PIXI.EventBoundary.propagationPath}. */\n  composedPath() {\n    return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /** Prevent default behavior of PixiJS and the user agent. */\n  preventDefault() {\n    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0;\n  }\n  /**\n   * Stop this event from propagating to any addition listeners, including on the\n   * {@link PIXI.FederatedEventTarget.currentTarget currentTarget} and also the following\n   * event targets on the propagation path.\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = !0;\n  }\n  /**\n   * Stop this event from propagating to the next {@link PIXI.FederatedEventTarget}. The rest of the listeners\n   * on the {@link PIXI.FederatedEventTarget.currentTarget currentTarget} will still be notified.\n   */\n  stopPropagation() {\n    this.propagationStopped = !0;\n  }\n}\n\n//# sourceMappingURL=FederatedEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs\n\n\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments), this.client = new Point(), this.movement = new Point(), this.offset = new Point(), this.global = new Point(), this.screen = new Point();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link PIXI.FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link PIXI.FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for {@code screen.x}.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for {@code screen.y}.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * This will return the local coordinates of the specified displayObject for this InteractionData\n   * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local\n   *  coords off\n   * @param {PIXI.IPointData} point - A Point object in which to store the value, optional (otherwise\n   *  will create a new point)\n   * @param {PIXI.IPointData} globalPos - A Point object containing your custom global coords, optional\n   *  (otherwise will use the current global coords)\n   * @returns - A point containing the coordinates of the InteractionData position relative\n   *  to the DisplayObject\n   */\n  getLocalPosition(displayObject, point, globalPos) {\n    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error("Method not implemented.");\n  }\n}\n\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs\n\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;\n  }\n  // Only included for completeness for now\n  getCoalescedEvents() {\n    return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [];\n  }\n  // Only included for completeness for now\n  getPredictedEvents() {\n    throw new Error("getPredictedEvents is not supported!");\n  }\n}\n\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs\n\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;\n  }\n}\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0, /** Units specified in lines. */\nFederatedWheelEvent.DOM_DELTA_LINE = 1, /** Units specified in pages. */\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventBoundary.mjs\n\n\n\n\n\nconst PROPAGATION_LIMIT = 2048, tempHitLocation = new Point(), tempLocalMapping = new Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    this.dispatch = new eventemitter3(), this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {\n      trackingData: {}\n    }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = rootTarget, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({\n      fn,\n      priority: 0\n    }), this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e\n   * @param type\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e\n   */\n  mapEvent(e) {\n    if (!this.rootTarget)\n      return;\n    const mappers = this.mappingTable[e.type];\n    if (mappers)\n      for (let i = 0, j = mappers.length; i < j; i++)\n        mappers[i].fn(e);\n    else\n      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n  }\n  /**\n   * Finds the DisplayObject that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x\n   * @param y\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = !0;\n    const fn = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link PIXI.EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type\n   */\n  propagate(e, type) {\n    if (!e.target)\n      return;\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++)\n      if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !(e.propagationStopped || e.propagationImmediatelyStopped)) {\n      e.eventPhase = e.BUBBLING_PHASE;\n      for (let i = composedPath.length - 2; i >= 0; i--)\n        if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)\n          return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive display objects. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--)\n      events.forEach((event) => {\n        e.currentTarget = targets[i], this.notifyTarget(e, event);\n      });\n  }\n  /**\n   * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n      if (!target.parent)\n        throw new Error("Cannot find propagation path to disconnected target");\n      propagationPath.push(target.parent), target = target.parent;\n    }\n    return propagationPath.reverse(), propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = !1) {\n    let shouldReturn = !1;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i], nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n            continue;\n          const isInteractive = currentTarget.isInteractive();\n          (nestedHit.length > 0 || isInteractive) && (isInteractive && this._allInteractiveElements.push(currentTarget), nestedHit.push(currentTarget)), this._hitElements.length === 0 && (this._hitElements = nestedHit), shouldReturn = !0;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();\n    return isInteractiveMode && isInteractiveTarget && this._allInteractiveElements.push(currentTarget), ignore || this._hitElements.length > 0 ? null : shouldReturn ? this._hitElements : isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;\n  }\n  /**\n   * Recursive implementation for {@link PIXI.EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The DisplayObject that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the display object.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link PIXI.EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n      return null;\n    if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i], nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n            continue;\n          const isInteractive = currentTarget.isInteractive();\n          return (nestedHit.length > 0 || isInteractive) && nestedHit.push(currentTarget), nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();\n    return isInteractiveMode && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;\n  }\n  _isInteractive(int) {\n    return int === "static" || int === "dynamic";\n  }\n  _interactivePrune(displayObject) {\n    return !!(!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable || displayObject.eventMode === "none" || displayObject.eventMode === "passive" && !displayObject.interactiveChildren || displayObject.isMask);\n  }\n  /**\n   * Checks whether the display object or any of its children cannot pass the hit test at all.\n   *\n   * {@link PIXI.EventBoundary}\'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}\n   * and {@link PIXI.DisplayObject._mask} for pruning.\n   * @param displayObject\n   * @param location\n   */\n  hitPruneFn(displayObject, location) {\n    if (displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)))\n      return !0;\n    if (displayObject._mask) {\n      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n      if (maskObject && !maskObject.containsPoint?.(location))\n        return !0;\n    }\n    return !1;\n  }\n  /**\n   * Checks whether the display object passes hit testing for the given location.\n   * @param displayObject\n   * @param location\n   * @returns - Whether `displayObject` passes hit testing for `location`.\n   */\n  hitTestFn(displayObject, location) {\n    return displayObject.eventMode === "passive" ? !1 : displayObject.hitArea ? !0 : displayObject.containsPoint ? displayObject.containsPoint(location) : !1;\n  }\n  /**\n   * Notify all the listeners to the event\'s `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type\n   */\n  notifyTarget(e, type) {\n    type = type ?? e.type;\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch")\n      this.dispatchEvent(e, "touchstart");\n    else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = !1;\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen", trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === "mousemove" ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget);\n      if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); )\n          leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === "mousemove" ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");\n      let overTargetAncestor = outTarget?.parent;\n      for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; )\n        overTargetAncestor = overTargetAncestor.parent;\n      if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {\n        const enterEvent = this.clonePointerEvent(e, "pointerenter");\n        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; )\n          enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [], allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? !0;\n    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove"), allowGlobalPointerEvents && allMethods.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), allowGlobalPointerEvents && allMethods.push("globaltouchmove")), isMouse && (this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), allowGlobalPointerEvents && allMethods.push("globalmousemove"), this.cursor = e.target?.cursor), allMethods.length > 0 && this.all(e, allMethods), this._allInteractiveElements.length = 0, this._hitElements.length = 0, trackingData.overTargets = e.composedPath(), this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from), isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), e.pointerType === "mouse" && (this.cursor = e.target?.cursor);\n    const enterEvent = this.clonePointerEvent(e, "pointerenter");\n    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )\n      enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;\n    trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen", outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget);\n      this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");\n      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n      for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )\n        leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;\n      trackingData.overTargets = null, this.freeEvent(outEvent), this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event\'s target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const now = performance.now(), e = this.createPointerEvent(from);\n    if (this.dispatchEvent(e, "pointerup"), e.pointerType === "touch")\n      this.dispatchEvent(e, "touchend");\n    else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");\n    }\n    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      for (; currentTarget && !e.composedPath().includes(currentTarget); ) {\n        if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), e.pointerType === "touch")\n          this.notifyTarget(e, "touchendoutside");\n        else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, "click");\n      clickEvent.target = clickTarget, clickEvent.path = null, trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {\n        clickCount: 0,\n        target: clickEvent.target,\n        timeStamp: now\n      });\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, clickEvent.pointerType === "mouse") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");\n      } else\n        clickEvent.pointerType === "touch" && this.dispatchEvent(clickEvent, "tap");\n      this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link PIXI.EventBoundary}\'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      for (; currentTarget; )\n        e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), e.pointerType === "touch" ? this.notifyTarget(e, "touchendoutside") : (e.pointerType === "mouse" || e.pointerType === "pen") && this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath)\n      return null;\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++)\n      currentTarget = propagationPath[i];\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], typeof type == "string" && (event.type = type), event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = this.hitTest(event.global.x, event.global.y), event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = type ?? event.type, event;\n  }\n  /**\n   * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from\n   * @param to\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from\n   * @param to\n   */\n  copyPointerData(from, to) {\n    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);\n  }\n  /**\n   * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from\n   * @param to\n   */\n  copyMouseData(from, to) {\n    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), to.ctrlKey = from.ctrlKey, to.metaKey = from.metaKey, to.movement.copyFrom(from.movement), to.screen.copyFrom(from.screen), to.shiftKey = from.shiftKey, to.global.copyFrom(from.global));\n  }\n  /**\n   * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = performance.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {\n      pressTargetsByButton: {},\n      clicksByButton: {},\n      overTarget: null\n    }), this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event\'s constructor.\n   */\n  allocateEvent(constructor) {\n    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = null, event.target = null, event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error("It is illegal to free an event not managed by this EventBoundary!");\n    const constructor = event.constructor;\n    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link PIXI.EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (listeners && e.currentTarget.isInteractive())\n      if ("fn" in listeners)\n        listeners.once && e.currentTarget.removeListener(type, listeners.fn, void 0, !0), listeners.fn.call(listeners.context, e);\n      else\n        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)\n          listeners[i].once && e.currentTarget.removeListener(type, listeners[i].fn, void 0, !0), listeners[i].fn.call(listeners[i].context, e);\n  }\n}\n\n//# sourceMappingURL=EventBoundary.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventSystem.mjs\n\n\n\n\n\nconst MOUSE_POINTER_ID = 1, TOUCH_TO_POINTER = {\n  touchstart: "pointerdown",\n  touchend: "pointerup",\n  touchendoutside: "pointerupoutside",\n  touchmove: "pointermove",\n  touchcancel: "pointercancel"\n}, _EventSystem = class _EventSystem2 {\n  /**\n   * @param {PIXI.Renderer} renderer\n   */\n  constructor(renderer) {\n    this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = renderer, this.rootBoundary = new EventBoundary(null), EventsTicker.init(this), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new FederatedPointerEvent(null), this.rootWheelEvent = new FederatedWheelEvent(null), this.cursorStyles = {\n      default: "inherit",\n      pointer: "pointer"\n    }, this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {\n      set: (target, key, value) => (key === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = value), target[key] = value, !0)\n    }), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);\n  }\n  /**\n   * The default interaction mode for all display objects.\n   * @see PIXI.DisplayObject.eventMode\n   * @type {PIXI.EventMode}\n   * @readonly\n   * @since 7.2.0\n   */\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const { view, resolution } = this.renderer;\n    this.setTargetElement(view), this.resolution = resolution, _EventSystem2._defaultEventMode = options.eventMode ?? "auto", Object.assign(this.features, options.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  /**\n   * Handle changing resolution.\n   * @ignore\n   */\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  /** Destroys all event listeners and detaches the renderer. */\n  destroy() {\n    this.setTargetElement(null), this.renderer = null;\n  }\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * @param mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursor(mode) {\n    mode = mode || "default";\n    let applyStyles = !0;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (applyStyles = !1), this.currentCursor === mode)\n      return;\n    this.currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style)\n      switch (typeof style) {\n        case "string":\n          applyStyles && (this.domElement.style.cursor = style);\n          break;\n        case "function":\n          style(mode);\n          break;\n        case "object":\n          applyStyles && Object.assign(this.domElement.style, style);\n          break;\n      }\n    else\n      applyStyles && typeof mode == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode) && (this.domElement.style.cursor = mode);\n  }\n  /**\n   * The global pointer event.\n   * Useful for getting the pointer position without listening to events.\n   * @since 7.2.0\n   */\n  get pointer() {\n    return this.rootPointerEvent;\n  }\n  /**\n   * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const events = this.normalizeToPointerData(nativeEvent);\n    this.autoPreventDefault && events[0].isNormalized && (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */\n  onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, EventsTicker.pointerMoved();\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    let target = nativeEvent.target;\n    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);\n    const outside = target !== this.domElement ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      event.type += outside, this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Passive handler for `wheel` events on {@link PIXI.EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(wheelEvent);\n  }\n  /**\n   * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.\n   *\n   * To deregister the current DOM element without setting a new one, pass {@code null}.\n   * @param element - The new DOM element.\n   */\n  setTargetElement(element) {\n    this.removeEvents(), this.domElement = element, EventsTicker.domElement = element, this.addEvents();\n  }\n  /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */\n  addEvents() {\n    if (this.eventsAdded || !this.domElement)\n      return;\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    style && (globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "none", style.msTouchAction = "none") : this.supportsPointerEvents && (style.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, {\n      passive: !0,\n      capture: !0\n    }), this.eventsAdded = !0;\n  }\n  /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */\n  removeEvents() {\n    if (!this.eventsAdded || !this.domElement)\n      return;\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "", style.msTouchAction = "") : this.supportsPointerEvents && (style.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1;\n  }\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   * @param  {PIXI.IPointData} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n      x: 0,\n      y: 0,\n      width: this.domElement.width,\n      height: this.domElement.height,\n      left: 0,\n      top: 0\n    }, resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier, point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent)\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        typeof touch.button > "u" && (touch.button = 0), typeof touch.buttons > "u" && (touch.buttons = 1), typeof touch.isPrimary > "u" && (touch.isPrimary = event.touches.length === 1 && event.type === "touchstart"), typeof touch.width > "u" && (touch.width = touch.radiusX || 1), typeof touch.height > "u" && (touch.height = touch.radiusY || 1), typeof touch.tiltX > "u" && (touch.tiltX = 0), typeof touch.tiltY > "u" && (touch.tiltY = 0), typeof touch.pointerType > "u" && (touch.pointerType = "touch"), typeof touch.pointerId > "u" && (touch.pointerId = touch.identifier || 0), typeof touch.pressure > "u" && (touch.pressure = touch.force || 0.5), typeof touch.twist > "u" && (touch.twist = 0), typeof touch.tangentialPressure > "u" && (touch.tangentialPressure = 0), typeof touch.layerX > "u" && (touch.layerX = touch.offsetX = touch.clientX), typeof touch.layerY > "u" && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);\n      }\n    else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      typeof tempEvent.isPrimary > "u" && (tempEvent.isPrimary = !0), typeof tempEvent.width > "u" && (tempEvent.width = 1), typeof tempEvent.height > "u" && (tempEvent.height = 1), typeof tempEvent.tiltX > "u" && (tempEvent.tiltX = 0), typeof tempEvent.tiltY > "u" && (tempEvent.tiltY = 0), typeof tempEvent.pointerType > "u" && (tempEvent.pointerType = "mouse"), typeof tempEvent.pointerId > "u" && (tempEvent.pointerId = MOUSE_POINTER_ID), typeof tempEvent.pressure > "u" && (tempEvent.pressure = 0.5), typeof tempEvent.twist > "u" && (tempEvent.twist = 0), typeof tempEvent.tangentialPressure > "u" && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);\n    } else\n      normalizedEvents.push(event);\n    return normalizedEvents;\n  }\n  /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */\n  normalizeWheelEvent(nativeEvent) {\n    const event = this.rootWheelEvent;\n    return this.transferMouseData(event, nativeEvent), event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ, event.deltaMode = nativeEvent.deltaMode, this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;\n  }\n  /**\n   * Normalizes the `nativeEvent` into a federateed {@link PIXI.FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */\n  bootstrapEvent(event, nativeEvent) {\n    return event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent), this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.isTrusted = nativeEvent.isTrusted, event.type === "pointerleave" && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;\n  }\n  /**\n   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n   * @param event\n   * @param nativeEvent\n   */\n  transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = performance.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null, event.shiftKey = nativeEvent.shiftKey;\n  }\n};\n_EventSystem.extension = {\n  name: "events",\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ]\n}, /**\n* The event features that are enabled by the EventSystem\n* This option only is available when using **@pixi/events** package\n* (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n* @since 7.2.0\n*/\n_EventSystem.defaultEventFeatures = {\n  move: !0,\n  globalMove: !0,\n  click: !0,\n  wheel: !0\n};\nlet EventSystem = _EventSystem;\nextensions.add(EventSystem);\n\n//# sourceMappingURL=EventSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEventTarget.mjs\n\n\n\n\nfunction convertEventModeToInteractiveMode(mode) {\n  return mode === "dynamic" || mode === "static";\n}\nconst FederatedDisplayObject = {\n  /**\n   * Property-based event handler for the `click` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onclick = (event) => {\n   *  //some function here that happens on click\n   * }\n   */\n  onclick: null,\n  /**\n   * Property-based event handler for the `mousedown` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmousedown = (event) => {\n   *  //some function here that happens on mousedown\n   * }\n   */\n  onmousedown: null,\n  /**\n   * Property-based event handler for the `mouseenter` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmouseenter = (event) => {\n   *  //some function here that happens on mouseenter\n   * }\n   */\n  onmouseenter: null,\n  /**\n   * Property-based event handler for the `mouseleave` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmouseleave = (event) => {\n   *  //some function here that happens on mouseleave\n   * }\n   */\n  onmouseleave: null,\n  /**\n   * Property-based event handler for the `mousemove` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmousemove = (event) => {\n   *  //some function here that happens on mousemove\n   * }\n   */\n  onmousemove: null,\n  /**\n   * Property-based event handler for the `globalmousemove` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onglobalmousemove = (event) => {\n   *  //some function here that happens on globalmousemove\n   * }\n   */\n  onglobalmousemove: null,\n  /**\n   * Property-based event handler for the `mouseout` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmouseout = (event) => {\n   *  //some function here that happens on mouseout\n   * }\n   */\n  onmouseout: null,\n  /**\n   * Property-based event handler for the `mouseover` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmouseover = (event) => {\n   *  //some function here that happens on mouseover\n   * }\n   */\n  onmouseover: null,\n  /**\n   * Property-based event handler for the `mouseup` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmouseup = (event) => {\n   *  //some function here that happens on mouseup\n   * }\n   */\n  onmouseup: null,\n  /**\n   * Property-based event handler for the `mouseupoutside` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onmouseupoutside = (event) => {\n   *  //some function here that happens on mouseupoutside\n   * }\n   */\n  onmouseupoutside: null,\n  /**\n   * Property-based event handler for the `pointercancel` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointercancel = (event) => {\n   *  //some function here that happens on pointercancel\n   * }\n   */\n  onpointercancel: null,\n  /**\n   * Property-based event handler for the `pointerdown` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerdown = (event) => {\n   *  //some function here that happens on pointerdown\n   * }\n   */\n  onpointerdown: null,\n  /**\n   * Property-based event handler for the `pointerenter` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerenter = (event) => {\n   *  //some function here that happens on pointerenter\n   * }\n   */\n  onpointerenter: null,\n  /**\n   * Property-based event handler for the `pointerleave` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerleave = (event) => {\n   *  //some function here that happens on pointerleave\n   * }\n   */\n  onpointerleave: null,\n  /**\n   * Property-based event handler for the `pointermove` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointermove = (event) => {\n   *  //some function here that happens on pointermove\n   * }\n   */\n  onpointermove: null,\n  /**\n   * Property-based event handler for the `globalpointermove` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onglobalpointermove = (event) => {\n   *  //some function here that happens on globalpointermove\n   * }\n   */\n  onglobalpointermove: null,\n  /**\n   * Property-based event handler for the `pointerout` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerout = (event) => {\n   *  //some function here that happens on pointerout\n   * }\n   */\n  onpointerout: null,\n  /**\n   * Property-based event handler for the `pointerover` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerover = (event) => {\n   *  //some function here that happens on pointerover\n   * }\n   */\n  onpointerover: null,\n  /**\n   * Property-based event handler for the `pointertap` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointertap = (event) => {\n   *  //some function here that happens on pointertap\n   * }\n   */\n  onpointertap: null,\n  /**\n   * Property-based event handler for the `pointerup` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerup = (event) => {\n   *  //some function here that happens on pointerup\n   * }\n   */\n  onpointerup: null,\n  /**\n   * Property-based event handler for the `pointerupoutside` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onpointerupoutside = (event) => {\n   *  //some function here that happens on pointerupoutside\n   * }\n   */\n  onpointerupoutside: null,\n  /**\n   * Property-based event handler for the `rightclick` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onrightclick = (event) => {\n   *  //some function here that happens on rightclick\n   * }\n   */\n  onrightclick: null,\n  /**\n   * Property-based event handler for the `rightdown` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onrightdown = (event) => {\n   *  //some function here that happens on rightdown\n   * }\n   */\n  onrightdown: null,\n  /**\n   * Property-based event handler for the `rightup` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onrightup = (event) => {\n   *  //some function here that happens on rightup\n   * }\n   */\n  onrightup: null,\n  /**\n   * Property-based event handler for the `rightupoutside` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onrightupoutside = (event) => {\n   *  //some function here that happens on rightupoutside\n   * }\n   */\n  onrightupoutside: null,\n  /**\n   * Property-based event handler for the `tap` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.ontap = (event) => {\n   *  //some function here that happens on tap\n   * }\n   */\n  ontap: null,\n  /**\n   * Property-based event handler for the `touchcancel` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.ontouchcancel = (event) => {\n   *  //some function here that happens on touchcancel\n   * }\n   */\n  ontouchcancel: null,\n  /**\n   * Property-based event handler for the `touchend` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.ontouchend = (event) => {\n   *  //some function here that happens on touchend\n   * }\n   */\n  ontouchend: null,\n  /**\n   * Property-based event handler for the `touchendoutside` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.ontouchendoutside = (event) => {\n   *  //some function here that happens on touchendoutside\n   * }\n   */\n  ontouchendoutside: null,\n  /**\n   * Property-based event handler for the `touchmove` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.ontouchmove = (event) => {\n   *  //some function here that happens on touchmove\n   * }\n   */\n  ontouchmove: null,\n  /**\n   * Property-based event handler for the `globaltouchmove` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onglobaltouchmove = (event) => {\n   *  //some function here that happens on globaltouchmove\n   * }\n   */\n  onglobaltouchmove: null,\n  /**\n   * Property-based event handler for the `touchstart` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.ontouchstart = (event) => {\n   *  //some function here that happens on touchstart\n   * }\n   */\n  ontouchstart: null,\n  /**\n   * Property-based event handler for the `wheel` event.\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   * @example\n   * this.onwheel = (event) => {\n   *  //some function here that happens on wheel\n   * }\n   */\n  onwheel: null,\n  /**\n   * @ignore\n   */\n  _internalInteractive: void 0,\n  /**\n   * Enable interaction events for the DisplayObject. Touch, pointer and mouse\n   * @memberof PIXI.DisplayObject#\n   */\n  get interactive() {\n    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);\n  },\n  set interactive(value) {\n    deprecation(\n      "7.2.0",\n      // eslint-disable-next-line max-len\n      "Setting interactive is deprecated, use eventMode = \'none\'/\'passive\'/\'auto\'/\'static\'/\'dynamic\' instead."\n    ), this._internalInteractive = value, this.eventMode = value ? "static" : "auto";\n  },\n  /**\n   * @ignore\n   */\n  _internalEventMode: void 0,\n  /**\n   * Enable interaction events for the DisplayObject. Touch, pointer and mouse.\n   * This now replaces the `interactive` property.\n   * There are 5 types of interaction settings:\n   * - `\'none\'`: Ignores all interaction events, even on its children.\n   * - `\'passive\'`: Does not emit events and ignores all hit testing on itself and non-interactive children.\n   * Interactive children will still emit events.\n   * - `\'auto\'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n   * - `\'static\'`: Emit events and is hit tested. Same as `interaction = true` in v7\n   * - `\'dynamic\'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n   * allow for interaction when the mouse isn\'t moving\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.eventMode = \'static\';\n   * sprite.on(\'tap\', (event) => {\n   *     // Handle event\n   * });\n   * @memberof PIXI.DisplayObject#\n   * @since 7.2.0\n   */\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalInteractive = convertEventModeToInteractiveMode(value), this._internalEventMode = value;\n  },\n  /**\n   * Determines if the displayObject is interactive or not\n   * @returns {boolean} Whether the displayObject is interactive or not\n   * @memberof PIXI.DisplayObject#\n   * @since 7.2.0\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   * const sprite = new Sprite(texture);\n   * sprite.eventMode = \'static\';\n   * sprite.isInteractive(); // true\n   *\n   * sprite.eventMode = \'dynamic\';\n   * sprite.isInteractive(); // true\n   *\n   * sprite.eventMode = \'none\';\n   * sprite.isInteractive(); // false\n   *\n   * sprite.eventMode = \'passive\';\n   * sprite.isInteractive(); // false\n   *\n   * sprite.eventMode = \'auto\';\n   * sprite.isInteractive(); // false\n   */\n  isInteractive() {\n    return this.eventMode === "static" || this.eventMode === "dynamic";\n  },\n  /**\n   * Determines if the children to the displayObject can be clicked/touched\n   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n   * @memberof PIXI.Container#\n   */\n  interactiveChildren: !0,\n  /**\n   * Interaction shape. Children will be hit first, then this shape will be checked.\n   * Setting this will cause this shape to be checked in hit tests rather than the displayObject\'s bounds.\n   * @example\n   * import { Rectangle, Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n   * @member {PIXI.IHitArea}\n   * @memberof PIXI.DisplayObject#\n   */\n  hitArea: null,\n  /**\n   * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n   * seeks to be compatible with the DOM\'s `addEventListener` with support for options.\n   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n   * @memberof PIXI.DisplayObject\n   * @param type - The type of event to listen to.\n   * @param listener - The listener callback or object.\n   * @param options - Listener options, used for capture phase.\n   * @example\n   * // Tell the user whether they did a single, double, triple, or nth click.\n   * button.addEventListener(\'click\', {\n   *     handleEvent(e): {\n   *         let prefix;\n   *\n   *         switch (e.detail) {\n   *             case 1: prefix = \'single\'; break;\n   *             case 2: prefix = \'double\'; break;\n   *             case 3: prefix = \'triple\'; break;\n   *             default: prefix = e.detail + \'th\'; break;\n   *         }\n   *\n   *         console.log(\'That was a \' + prefix + \'click\');\n   *     }\n   * });\n   *\n   * // But skip the first click!\n   * button.parent.addEventListener(\'click\', function blockClickOnce(e) {\n   *     e.stopImmediatePropagation();\n   *     button.parent.removeEventListener(\'click\', blockClickOnce, true);\n   * }, {\n   *     capture: true,\n   * });\n   */\n  addEventListener(type, listener, options) {\n    const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context = typeof listener == "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type, listener = typeof listener == "function" ? listener : listener.handleEvent, this.on(type, listener, context);\n  },\n  /**\n   * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n   * seeks to be compatible with the DOM\'s `removeEventListener` with support for options.\n   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n   * @memberof PIXI.DisplayObject\n   * @param type - The type of event the listener is bound to.\n   * @param listener - The listener callback or object.\n   * @param options - The original listener options. This is required to deregister a capture phase listener.\n   */\n  removeEventListener(type, listener, options) {\n    const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context = typeof listener == "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type, listener = typeof listener == "function" ? listener : listener.handleEvent, this.off(type, listener, context);\n  },\n  /**\n   * Dispatch the event on this {@link PIXI.DisplayObject} using the event\'s {@link PIXI.EventBoundary}.\n   *\n   * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n   *\n   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n   * @memberof PIXI.DisplayObject\n   * @param e - The event to dispatch.\n   * @returns Whether the {@link PIXI.FederatedEvent.preventDefault preventDefault}() method was not invoked.\n   * @example\n   * // Reuse a click event!\n   * button.dispatchEvent(clickEvent);\n   */\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent))\n      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");\n    return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented;\n  }\n};\nDisplayObject.mixin(FederatedDisplayObject);\n\n//# sourceMappingURL=FederatedEventTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/index.mjs\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs\nconst accessibleTarget = {\n  /**\n   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a\n   *   shadow div with attributes set\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessible: !1,\n  /**\n   * Sets the title attribute of the shadow div\n   * If accessibleTitle AND accessibleHint has not been this will default to \'displayObject [tabIndex]\'\n   * @member {?string}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessibleTitle: null,\n  /**\n   * Sets the aria-label attribute of the shadow div\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessibleHint: null,\n  /**\n   * @member {number}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   * @todo Needs docs.\n   */\n  tabIndex: 0,\n  /**\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @todo Needs docs.\n   */\n  _accessibleActive: !1,\n  /**\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @todo Needs docs.\n   */\n  _accessibleDiv: null,\n  /**\n   * Specify the type of div the accessible layer is. Screen readers treat the element differently\n   * depending on this type. Defaults to button.\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   * @default \'button\'\n   */\n  accessibleType: "button",\n  /**\n   * Specify the pointer-events the accessible div will use\n   * Defaults to auto.\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   * @default \'auto\'\n   */\n  accessiblePointerEvents: "auto",\n  /**\n   * Setting to false will prevent any children inside this container to\n   * be accessible. Defaults to true.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @default true\n   */\n  accessibleChildren: !0,\n  renderId: -1\n};\n\n//# sourceMappingURL=accessibleTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs\n\n\n\n\nDisplayObject.mixin(accessibleTarget);\nconst KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2;\nclass AccessibilityManager {\n  // 2fps\n  /**\n   * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer) {\n    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile_isMobile.tablet || isMobile_isMobile.phone) && this.createTouchHook();\n    const div = document.createElement("div");\n    div.style.width = `${DIV_TOUCH_SIZE}px`, div.style.height = `${DIV_TOUCH_SIZE}px`, div.style.position = "absolute", div.style.top = `${DIV_TOUCH_POS_X}px`, div.style.left = `${DIV_TOUCH_POS_Y}px`, div.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = div, this.renderer = renderer, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);\n  }\n  /**\n   * Value of `true` if accessibility is currently active and accessibility layers are showing.\n   * @member {boolean}\n   * @readonly\n   */\n  get isActive() {\n    return this._isActive;\n  }\n  /**\n   * Value of `true` if accessibility is enabled for touch devices.\n   * @member {boolean}\n   * @readonly\n   */\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  /**\n   * Creates the touch hooks.\n   * @private\n   */\n  createTouchHook() {\n    const hookDiv = document.createElement("button");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`, hookDiv.style.height = `${DIV_HOOK_SIZE}px`, hookDiv.style.position = "absolute", hookDiv.style.top = `${DIV_HOOK_POS_X}px`, hookDiv.style.left = `${DIV_HOOK_POS_Y}px`, hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString(), hookDiv.style.backgroundColor = "#FF0000", hookDiv.title = "select to enable accessibility for this content", hookDiv.addEventListener("focus", () => {\n      this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook();\n    }), document.body.appendChild(hookDiv), this._hookDiv = hookDiv;\n  }\n  /**\n   * Destroys the touch hooks.\n   * @private\n   */\n  destroyTouchHook() {\n    this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);\n  }\n  /**\n   * Activating will cause the Accessibility layer to be shown.\n   * This is called when a user presses the tab key.\n   * @private\n   */\n  activate() {\n    this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode?.appendChild(this.div));\n  }\n  /**\n   * Deactivating will cause the Accessibility layer to be hidden.\n   * This is called when a user moves the mouse.\n   * @private\n   */\n  deactivate() {\n    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode?.removeChild(this.div));\n  }\n  /**\n   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n   * @private\n   * @param {PIXI.Container} displayObject - The DisplayObject to check.\n   */\n  updateAccessibleObjects(displayObject) {\n    if (!displayObject.visible || !displayObject.accessibleChildren)\n      return;\n    displayObject.accessible && displayObject.isInteractive() && (displayObject._accessibleActive || this.addChild(displayObject), displayObject.renderId = this.renderId);\n    const children = displayObject.children;\n    if (children)\n      for (let i = 0; i < children.length; i++)\n        this.updateAccessibleObjects(children[i]);\n  }\n  /**\n   * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.\n   * @private\n   */\n  update() {\n    const now = performance.now();\n    if (isMobile_isMobile.android.device && now < this.androidUpdateCount || (this.androidUpdateCount = now + this.androidUpdateFrequency, !this.renderer.renderingToScreen))\n      return;\n    this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);\n    const { x, y, width, height } = this.renderer.view.getBoundingClientRect(), { width: viewWidth, height: viewHeight, resolution } = this.renderer, sx = width / viewWidth * resolution, sy = height / viewHeight * resolution;\n    let div = this.div;\n    div.style.left = `${x}px`, div.style.top = `${y}px`, div.style.width = `${viewWidth}px`, div.style.height = `${viewHeight}px`;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (child.renderId !== this.renderId)\n        child._accessibleActive = !1, removeItems(this.children, i, 1), this.div.removeChild(child._accessibleDiv), this.pool.push(child._accessibleDiv), child._accessibleDiv = null, i--;\n      else {\n        div = child._accessibleDiv;\n        let hitArea = child.hitArea;\n        const wt = child.worldTransform;\n        child.hitArea ? (div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`, div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`, div.style.width = `${hitArea.width * wt.a * sx}px`, div.style.height = `${hitArea.height * wt.d * sy}px`) : (hitArea = child.getBounds(), this.capHitArea(hitArea), div.style.left = `${hitArea.x * sx}px`, div.style.top = `${hitArea.y * sy}px`, div.style.width = `${hitArea.width * sx}px`, div.style.height = `${hitArea.height * sy}px`, div.title !== child.accessibleTitle && child.accessibleTitle !== null && (div.title = child.accessibleTitle), div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null && div.setAttribute("aria-label", child.accessibleHint)), (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) && (div.title = child.accessibleTitle, div.tabIndex = child.tabIndex, this.debug && this.updateDebugHTML(div));\n      }\n    }\n    this.renderId++;\n  }\n  /**\n   * private function that will visually add the information to the\n   * accessability div\n   * @param {HTMLElement} div -\n   */\n  updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  /**\n   * Adjust the hit area based on the bounds of a display object\n   * @param {PIXI.Rectangle} hitArea - Bounds of the child\n   */\n  capHitArea(hitArea) {\n    hitArea.x < 0 && (hitArea.width += hitArea.x, hitArea.x = 0), hitArea.y < 0 && (hitArea.height += hitArea.y, hitArea.y = 0);\n    const { width: viewWidth, height: viewHeight } = this.renderer;\n    hitArea.x + hitArea.width > viewWidth && (hitArea.width = viewWidth - hitArea.x), hitArea.y + hitArea.height > viewHeight && (hitArea.height = viewHeight - hitArea.y);\n  }\n  /**\n   * Adds a DisplayObject to the accessibility manager\n   * @private\n   * @param {PIXI.DisplayObject} displayObject - The child to make accessible.\n   */\n  addChild(displayObject) {\n    let div = this.pool.pop();\n    div || (div = document.createElement("button"), div.style.width = `${DIV_TOUCH_SIZE}px`, div.style.height = `${DIV_TOUCH_SIZE}px`, div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", div.style.position = "absolute", div.style.zIndex = DIV_TOUCH_ZINDEX.toString(), div.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? div.setAttribute("aria-live", "off") : div.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\\//) ? div.setAttribute("aria-relevant", "additions") : div.setAttribute("aria-relevant", "text"), div.addEventListener("click", this._onClick.bind(this)), div.addEventListener("focus", this._onFocus.bind(this)), div.addEventListener("focusout", this._onFocusOut.bind(this))), div.style.pointerEvents = displayObject.accessiblePointerEvents, div.type = displayObject.accessibleType, displayObject.accessibleTitle && displayObject.accessibleTitle !== null ? div.title = displayObject.accessibleTitle : (!displayObject.accessibleHint || displayObject.accessibleHint === null) && (div.title = `displayObject ${displayObject.tabIndex}`), displayObject.accessibleHint && displayObject.accessibleHint !== null && div.setAttribute("aria-label", displayObject.accessibleHint), this.debug && this.updateDebugHTML(div), displayObject._accessibleActive = !0, displayObject._accessibleDiv = div, div.displayObject = displayObject, this.children.push(displayObject), this.div.appendChild(displayObject._accessibleDiv), displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;\n  }\n  /**\n   * Dispatch events with the EventSystem.\n   * @param e\n   * @param type\n   * @private\n   */\n  _dispatchEvent(e, type) {\n    const { displayObject: target } = e.target, boundry = this.renderer.events.rootBoundary, event = Object.assign(new FederatedEvent(boundry), { target });\n    boundry.rootTarget = this.renderer.lastObjectRendered, type.forEach((type2) => boundry.dispatchEvent(event, type2));\n  }\n  /**\n   * Maps the div button press to pixi\'s EventSystem (click)\n   * @private\n   * @param {MouseEvent} e - The click event.\n   */\n  _onClick(e) {\n    this._dispatchEvent(e, ["click", "pointertap", "tap"]);\n  }\n  /**\n   * Maps the div focus events to pixi\'s EventSystem (mouseover)\n   * @private\n   * @param {FocusEvent} e - The focus event.\n   */\n  _onFocus(e) {\n    e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"]);\n  }\n  /**\n   * Maps the div focus events to pixi\'s EventSystem (mouseout)\n   * @private\n   * @param {FocusEvent} e - The focusout event.\n   */\n  _onFocusOut(e) {\n    e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"]);\n  }\n  /**\n   * Is called when a key is pressed\n   * @private\n   * @param {KeyboardEvent} e - The keydown event.\n   */\n  _onKeyDown(e) {\n    e.keyCode === KEY_CODE_TAB && this.activate();\n  }\n  /**\n   * Is called when the mouse moves across the renderer element\n   * @private\n   * @param {MouseEvent} e - The mouse event.\n   */\n  _onMouseMove(e) {\n    e.movementX === 0 && e.movementY === 0 || this.deactivate();\n  }\n  /** Destroys the accessibility manager */\n  destroy() {\n    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;\n  }\n}\nAccessibilityManager.extension = {\n  name: "accessibility",\n  type: [\n    ExtensionType.RendererPlugin,\n    ExtensionType.CanvasRendererPlugin\n  ]\n};\nextensions.add(AccessibilityManager);\n\n//# sourceMappingURL=AccessibilityManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/Application.mjs\n\n\nconst _Application = class _Application2 {\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  constructor(options) {\n    this.stage = new Container_Container(), options = Object.assign({\n      forceCanvas: !1\n    }, options), this.renderer = autoDetectRenderer(options), _Application2._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render(this.stage);\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @member {PIXI.ICanvas}\n   * @readonly\n   */\n  get view() {\n    return this.renderer?.view;\n  }\n  /**\n   * Reference to the renderer\'s screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @member {PIXI.Rectangle}\n   * @readonly\n   */\n  get screen() {\n    return this.renderer?.screen;\n  }\n  /**\n   * Destroy and don\'t use after this.\n   * @param {boolean} [removeView=false] - Automatically remove canvas from DOM.\n   * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. \'stageOptions\' will be passed on to those calls.\n   * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set\n   *  to true. Should it destroy the texture of the child sprite\n   * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set\n   *  to true. Should it destroy the base texture of the child sprite\n   */\n  destroy(removeView, stageOptions) {\n    const plugins = _Application2._plugins.slice(0);\n    plugins.reverse(), plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    }), this.stage.destroy(stageOptions), this.stage = null, this.renderer.destroy(removeView), this.renderer = null;\n  }\n};\n_Application._plugins = [];\nlet Application = _Application;\nextensions.handleByList(ExtensionType.Application, Application._plugins);\n\n//# sourceMappingURL=Application.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/ResizePlugin.mjs\n\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      "resizeTo",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer\'s view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof PIXI.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = dom, dom && (globalThis.addEventListener("resize", this.queueResize), this.resize());\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    ), this.queueResize = () => {\n      this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));\n    }, this.cancelResize = () => {\n      this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);\n    }, this.resize = () => {\n      if (!this._resizeTo)\n        return;\n      this.cancelResize();\n      let width, height;\n      if (this._resizeTo === globalThis.window)\n        width = globalThis.innerWidth, height = globalThis.innerHeight;\n      else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth, height = clientHeight;\n      }\n      this.renderer.resize(width, height), this.render();\n    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;\n  }\n}\nResizePlugin.extension = ExtensionType.Application;\nextensions.add(ResizePlugin);\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/AssetExtension.mjs\n\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it\'s own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));\n});\n//# sourceMappingURL=AssetExtension.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/BackgroundLoader.mjs\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = !1) {\n    this._loader = loader, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = verbose;\n  }\n  /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = !0;\n      const toLoad = [], toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++)\n        toLoad.push(this._assetList.pop());\n      await this._loader.load(toLoad), this._isLoading = !1, this._next();\n    }\n  }\n  /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    this._isActive !== value && (this._isActive = value, value && !this._isLoading && this._next());\n  }\n}\n\n//# sourceMappingURL=BackgroundLoader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkExtension.mjs\n\nfunction checkExtension(url, extension) {\n  const tempURL = url.split("?")[0], ext = path.extname(tempURL).toLowerCase();\n  return Array.isArray(extension) ? extension.includes(ext) : ext === extension;\n}\n\n//# sourceMappingURL=checkExtension.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/index.mjs\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/convertToList.mjs\nconst convertToList = (input, transform, forceTransform = !1) => (Array.isArray(input) || (input = [input]), transform ? input.map((item) => typeof item == "string" || forceTransform ? transform(item) : item) : input);\n\n//# sourceMappingURL=convertToList.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/Cache.mjs\n\n\n\nclass CacheClass {\n  constructor() {\n    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear(), this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    return result || console.warn(`[Assets] Asset id ${key} was not found in the Cache`), result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    cacheableAssets || (cacheableAssets = {}, keys.forEach((key2) => {\n      cacheableAssets[key2] = value;\n    }));\n    const cacheKeys = Object.keys(cacheableAssets), cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    if (keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    }), cacheKeys.forEach((key2) => {\n      this._cache.has(key2) && this._cache.get(key2) !== value && console.warn("[Cache] already has key:", key2), this._cache.set(key2, cacheableAssets[key2]);\n    }), value instanceof Texture_Texture) {\n      const texture = value;\n      keys.forEach((key2) => {\n        texture.baseTexture !== Texture_Texture.EMPTY.baseTexture && BaseTexture.addToCache(texture.baseTexture, key2), Texture_Texture.addToCache(texture, key2);\n      });\n    }\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    cacheMap.cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    }), cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n//# sourceMappingURL=Cache.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs\nconst isSingleItem = (item) => !Array.isArray(item);\n\n//# sourceMappingURL=isSingleItem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/Loader.mjs\n\n\n\n\nclass Loader {\n  constructor() {\n    this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => (this._parsersValidated = !1, target[key] = value, !0)\n    }), this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = !1, this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    return result.promise = (async () => {\n      let asset = null, parser = null;\n      if (data.loadParser && (parser = this._parserHash[data.loadParser], parser || console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`)), !parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser)\n          return console.warn(`[Assets] ${url} could not be loaded as we don\'t know how to parse it, ensure the correct parser has been added`), null;\n      }\n      asset = await parser.load(url, data, this), result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        parser2.parse && parser2.parse && await parser2.testParse?.(asset, data, this) && (asset = await parser2.parse(asset, data, this) || asset, result.parser = parser2);\n      }\n      return asset;\n    })(), result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    this._parsersValidated || this._validateParsers();\n    let count = 0;\n    const assets = {}, singleAsset = isSingleItem(assetsToLoadIn), assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item\n    })), total = assetsToLoad.length, promises = assetsToLoad.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      if (!assets[asset.src])\n        try {\n          this.promiseCache[url] || (this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset)), assets[asset.src] = await this.promiseCache[url].promise, onProgress && onProgress(++count / total);\n        } catch (e) {\n          throw delete this.promiseCache[url], delete assets[asset.src], new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n    });\n    return await Promise.all(promises), singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load(\'cool.png\');\n   *\n   * await Loader.unload(\'cool.png\');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const promises = convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    })).map(async (asset) => {\n      const url = path.toAbsolute(asset.src), loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url], loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = !0, this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => (hash[parser.name] && console.warn(`[Assets] loadParser name conflict "${parser.name}"`), { ...hash, [parser.name]: parser }), {});\n  }\n}\n\n//# sourceMappingURL=Loader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => (LoaderParserPriority2[LoaderParserPriority2.Low = 0] = "Low", LoaderParserPriority2[LoaderParserPriority2.Normal = 1] = "Normal", LoaderParserPriority2[LoaderParserPriority2.High = 2] = "High", LoaderParserPriority2))(LoaderParserPriority || {});\n\n//# sourceMappingURL=LoaderParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes)\n      if (url.startsWith(`data:${mime}`))\n        return !0;\n    return !1;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\n//# sourceMappingURL=checkDataUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs\n\n\n\n\nconst validJSONExtension = ".json", validJSONMIME = "application/json", loadJson = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: "loadJson",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    return await (await settings.ADAPTER.fetch(url)).json();\n  }\n};\nextensions.add(loadJson);\n\n//# sourceMappingURL=loadJson.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs\n\n\n\n\nconst validTXTExtension = ".txt", validTXTMIME = "text/plain", loadTxt = {\n  name: "loadTxt",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    return await (await settings.ADAPTER.fetch(url)).text();\n  }\n};\nextensions.add(loadTxt);\n\n//# sourceMappingURL=loadTxt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs\n\n\n\n\nconst validWeights = [\n  "normal",\n  "bold",\n  "100",\n  "200",\n  "300",\n  "400",\n  "500",\n  "600",\n  "700",\n  "800",\n  "900"\n], validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"], validFontMIMEs = [\n  "font/ttf",\n  "font/otf",\n  "font/woff",\n  "font/woff2"\n], CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path.extname(url), nameTokens = path.basename(url, ext).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens)\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = !1;\n      break;\n    }\n  let fontFamilyName = nameTokens.join(" ");\n  return valid || (fontFamilyName = `"${fontFamilyName.replace(/[\\\\"]/g, "\\\\$&")}"`), fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&\'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  return validURICharactersRegex.test(uri) ? uri : encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: "loadWebFont",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = settings.ADAPTER.getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [], name = options.data?.family ?? getFontFamilyName(url), weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"], data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i], font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load(), fonts.add(font), fontFaces.push(font);\n      }\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));\n  }\n};\nextensions.add(loadWebFont);\n\n//# sourceMappingURL=loadWebFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs\nlet UUID = 0, MAX_WORKERS;\nconst WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=", checkImageBitmapCode = {\n  id: "checkImageBitmap",\n  code: `\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== \'function\') return false;\n\n            const response = await fetch(\'${WHITE_PNG}\');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    `\n}, workerCode = {\n  id: "loadImageBitmap",\n  code: `\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(\\`[WorkerManager.loadImageBitmap] Failed to fetch \\${url}: \\`\n                + \\`\\${response.status} \\${response.statusText}\\`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };`\n};\nlet workerURL;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((resolve) => {\n      const workerURL2 = URL.createObjectURL(new Blob(\n        [checkImageBitmapCode.code],\n        { type: "application/javascript" }\n      )), worker = new Worker(workerURL2);\n      worker.addEventListener("message", (event) => {\n        worker.terminate(), URL.revokeObjectURL(workerURL2), resolve(event.data);\n      });\n    }), this._isImageBitmapSupported);\n  }\n  loadImageBitmap(src) {\n    return this._run("loadImageBitmap", [src]);\n  }\n  async _initWorkers() {\n    this._initialized || (this._initialized = !0);\n  }\n  getWorker() {\n    MAX_WORKERS === void 0 && (MAX_WORKERS = navigator.hardwareConcurrency || 4);\n    let worker = this.workerPool.pop();\n    return !worker && this._createdWorkers < MAX_WORKERS && (workerURL || (workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }))), this._createdWorkers++, worker = new Worker(workerURL), worker.addEventListener("message", (event) => {\n      this.complete(event.data), this.returnWorker(event.target), this.next();\n    })), worker;\n  }\n  returnWorker(worker) {\n    this.workerPool.push(worker);\n  }\n  complete(data) {\n    data.error !== void 0 ? this.resolveHash[data.uuid].reject(data.error) : this.resolveHash[data.uuid].resolve(data.data), this.resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({ id, arguments: args, resolve, reject });\n    });\n    return this.next(), promise;\n  }\n  next() {\n    if (!this.queue.length)\n      return;\n    const worker = this.getWorker();\n    if (!worker)\n      return;\n    const toDo = this.queue.pop(), id = toDo.id;\n    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject }, worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\n//# sourceMappingURL=WorkerManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs\n\n\nfunction createTexture(base, loader, url) {\n  base.resource.internal = !0;\n  const texture = new Texture_Texture(base), unload = () => {\n    delete loader.promiseCache[url], Cache.has(url) && Cache.remove(url);\n  };\n  return texture.baseTexture.once("destroyed", () => {\n    url in loader.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."), unload());\n  }), texture.once("destroyed", () => {\n    base.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), unload());\n  }), texture;\n}\n\n//# sourceMappingURL=createTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs\n\n\n\n\n\n\nconst validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"], validImageMIMEs = [\n  "image/jpeg",\n  "image/png",\n  "image/webp",\n  "image/avif"\n];\nasync function loadImageBitmap(url) {\n  const response = await settings.ADAPTER.fetch(url);\n  if (!response.ok)\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  const imageBlob = await response.blob();\n  return await createImageBitmap(imageBlob);\n}\nconst loadTextures = {\n  name: "loadTextures",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: !0,\n    preferCreateImageBitmap: !0,\n    crossOrigin: "anonymous"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    const useImageBitmap = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;\n    let src;\n    useImageBitmap ? this.config.preferWorkers && await WorkerManager.isImageBitmapSupported() ? src = await WorkerManager.loadImageBitmap(url) : src = await loadImageBitmap(url) : src = await new Promise((resolve, reject) => {\n      const src2 = new Image();\n      src2.crossOrigin = this.config.crossOrigin, src2.src = url, src2.complete ? resolve(src2) : (src2.onload = () => resolve(src2), src2.onerror = (e) => reject(e));\n    });\n    const options = { ...asset.data };\n    options.resolution ?? (options.resolution = getResolutionOfUrl(url)), useImageBitmap && options.resourceOptions?.ownsImageBitmap === void 0 && (options.resourceOptions = { ...options.resourceOptions }, options.resourceOptions.ownsImageBitmap = !0);\n    const base = new BaseTexture(src, options);\n    return base.resource.src = url, createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(!0);\n  }\n};\nextensions.add(loadTextures);\n\n//# sourceMappingURL=loadTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs\n\n\n\n\n\n\nconst validSVGExtension = ".svg", validSVGMIME = "image/svg+xml", loadSVG = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadSVG",\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async testParse(data) {\n    return SVGResource.test(data);\n  },\n  async parse(asset, data, loader) {\n    const src = new SVGResource(asset, data?.data?.resourceOptions);\n    await src.load();\n    const base = new BaseTexture(src, {\n      resolution: getResolutionOfUrl(asset),\n      ...data?.data\n    });\n    return base.resource.src = data.src, createTexture(base, loader, data.src);\n  },\n  async load(url, _options) {\n    return (await settings.ADAPTER.fetch(url)).text();\n  },\n  unload: loadTextures.unload\n};\nextensions.add(loadSVG);\n\n//# sourceMappingURL=loadSVG.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.mjs\n\n\n\n\n\nconst validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogv"], validVideoMIMEs = [\n  "video/mp4",\n  "video/webm",\n  "video/ogg"\n], loadVideo = {\n  name: "loadVideo",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    defaultAutoPlay: !0\n  },\n  test(url) {\n    return checkDataUrl(url, validVideoMIMEs) || checkExtension(url, validVideoExtensions);\n  },\n  async load(url, loadAsset, loader) {\n    let texture;\n    const blob = await (await settings.ADAPTER.fetch(url)).blob(), blobURL = URL.createObjectURL(blob);\n    try {\n      const options = {\n        autoPlay: this.config.defaultAutoPlay,\n        ...loadAsset?.data?.resourceOptions\n      }, src = new VideoResource(blobURL, options);\n      await src.load();\n      const base = new BaseTexture(src, {\n        alphaMode: await detectVideoAlphaMode(),\n        resolution: getResolutionOfUrl(url),\n        ...loadAsset?.data\n      });\n      base.resource.src = url, texture = createTexture(base, loader, url), texture.baseTexture.once("destroyed", () => {\n        URL.revokeObjectURL(blobURL);\n      });\n    } catch (e) {\n      throw URL.revokeObjectURL(blobURL), e;\n    }\n    return texture;\n  },\n  unload(texture) {\n    texture.destroy(!0);\n  }\n};\nextensions.add(loadVideo);\n\n//# sourceMappingURL=loadVideo.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    depth < ids.length - 1 ? processX(base.replace(result[depth], value), ids, depth + 1, result, tags) : tags.push(base.replace(result[depth], value));\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g, result = string.match(regex), tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(",");\n      ids.push(split);\n    }), processX(string, ids, 0, result, tags);\n  } else\n    tags.push(string);\n  return tags;\n}\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/Resolver.mjs\n\n\n\n\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: "-",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")\n    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    if (this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector, this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")\n      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: [\'format\', \'resolution\'],\n   *     params:{\n   *         format:\'webp\', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add(\'foo\', [\'bar@2x.webp\', \'bar@2x.png\', \'bar.webp\', \'bar.png\']);\n   * resolver.resolveUrl(\'foo\') // => \'bar@2x.webp\'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer), prefer.priority || (prefer.priority = Object.keys(prefer.params));\n    }), this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = \'https://home.com/\';\n   * resolver.add(\'foo\', \'bar.ong\');\n   * resolver.resolveUrl(\'foo\', \'bar.png\'); // => \'https://home.com/bar.png\'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`\'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = \'https://home.com/some-path/\';\n   * resolver.rootPath = \'https://home.com/\';\n   * resolver.add(\'foo\', \'/bar.png\');\n   * resolver.resolveUrl(\'foo\', \'/bar.png\'); // => \'https://home.com/bar.png\'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add(\'foo\', [\n   *     {\n   *         resolution: 2,\n   *         format: \'png\',\n   *         src: \'image@2x.png\',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:\'png\',\n   *         src: \'image.png\',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? \'1\'),\n   *         format: value.split(\'.\').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add(\'foo\', [\n   *     \'image@2x.png\',\n   *     \'image.png\',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams == "string")\n      this._defaultSearchParams = searchParams;\n    else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, name, src, srcs } = asset;\n    return convertToList(\n      alias || name || src || srcs,\n      (value) => typeof value == "string" ? value : Array.isArray(value) ? value.map((v) => v?.src ?? v?.srcs ?? v) : value?.src || value?.srcs ? value.src ?? value.srcs : value,\n      !0\n    );\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = manifest, manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle(\'animals\', {\n   *     bunny: \'bunny.png\',\n   *     chicken: \'chicken.png\',\n   *     thumper: \'thumper.png\',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle(\'animals\');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    Array.isArray(assets) ? assets.forEach((asset) => {\n      const srcs = asset.src ?? asset.srcs, aliases = asset.alias ?? asset.name;\n      let ids;\n      if (typeof aliases == "string") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId), ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds), ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        alias: ids,\n        src: srcs\n      });\n    }) : Object.keys(assets).forEach((key) => {\n      const aliases = [key, this._createBundleAssetId(bundleId, key)];\n      if (typeof assets[key] == "string")\n        this.add({\n          alias: aliases,\n          src: assets[key]\n        });\n      else if (Array.isArray(assets[key]))\n        this.add({\n          alias: aliases,\n          src: assets[key]\n        });\n      else {\n        const asset = assets[key], assetSrc = asset.src ?? asset.srcs;\n        this.add({\n          ...asset,\n          alias: aliases,\n          src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]\n        });\n      }\n      assetNames.push(...aliases);\n    }), this._bundles[bundleId] = assetNames;\n  }\n  add(aliases, srcs, data, format, loadParser) {\n    const assets = [];\n    typeof aliases == "string" || Array.isArray(aliases) && typeof aliases[0] == "string" ? (deprecation("7.2.0", `Assets.add now uses an object instead of individual parameters.\nPlease use Assets.add({ alias, src, data, format, loadParser }) instead.`), assets.push({ alias: aliases, src: srcs, data, format, loadParser })) : Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);\n    let keyCheck;\n    keyCheck = (key) => {\n      this.hasKey(key) && console.warn(`[Resolver] already has key: ${key} overwriting`);\n    }, convertToList(assets).forEach((asset) => {\n      const { src, srcs: srcs2 } = asset;\n      let { data: data2, format: format2, loadParser: loadParser2 } = asset;\n      const srcsToUse = convertToList(src || srcs2).map((src2) => typeof src2 == "string" ? createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]), aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs3) => {\n        srcs3.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 != "object") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else\n            data2 = src2.data ?? data2, format2 = src2.format ?? format2, loadParser2 = src2.loadParser ?? loadParser2, formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          if (!aliasesToUse)\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          formattedAsset = this.buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data: data2,\n            format: format2,\n            loadParser: loadParser2\n          }), resolvedAssets.push(formattedAsset);\n        });\n      }), aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: \'load-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'background\',\n   *                     src: \'sunset.png\',\n   *                 },\n   *                 {\n   *                     alias: \'bar\',\n   *                     src: \'load-bar.{png,webp}\',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: \'game-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'character\',\n   *                     src: \'robot.png\',\n   *                 },\n   *                 {\n   *                     alias: \'enemy\',\n   *                     src: \'bad-guy.png\',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle(\'load-screen\');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    return bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames), assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    }), singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key != "string") {\n      const out = {};\n      for (const i in result)\n        out[i] = result[i].src;\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    return keys.forEach((key) => {\n      if (!this._resolverHash[key])\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const bestAsset = assets[0], preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => asset[priorityKey] ? asset[priorityKey] === value : !1);\n              filteredAssets.length && (assets = filteredAssets);\n            });\n          }), this._resolverHash[key] = assets[0] ?? bestAsset;\n        } else\n          this._resolverHash[key] = this.buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n      result[key] = this._resolverHash[key];\n    }), singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0], preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred)\n        return preferred;\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? "&" : "?";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    return (this._basePath || this._rootPath) && (formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath)), formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src], formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src), formattedAsset.data = { ...assetData || {}, ...formattedAsset.data }, formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser, formattedAsset.format = format ?? path.extname(formattedAsset.src).slice(1), formattedAsset.srcs = formattedAsset.src, formattedAsset.name = formattedAsset.alias, formattedAsset;\n  }\n}\n\n//# sourceMappingURL=Resolver.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/Assets.mjs\n\n\n\n\n\n\n\n\n\nclass AssetsClass {\n  constructor() {\n    this._detections = [], this._initialized = !1, this.resolver = new Resolver(), this.loader = new Loader(), this.cache = Cache, this._backgroundLoader = new BackgroundLoader(this.loader), this._backgroundLoader.active = !0, this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Asset manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      console.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");\n      return;\n    }\n    if (this._initialized = !0, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {\n      let manifest = options.manifest;\n      typeof manifest == "string" && (manifest = await this.load(manifest)), this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1, resolution = typeof resolutionPref == "number" ? [resolutionPref] : resolutionPref, formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    }), options.preferences && this.setPreferences(options.preferences);\n  }\n  add(aliases, srcs, data, format, loadParser) {\n    this.resolver.add(aliases, srcs, data, format, loadParser);\n  }\n  async load(urls, onProgress) {\n    this._initialized || await this.init();\n    const singleAsset = isSingleItem(urls), urlArray = convertToList(urls).map((url) => {\n      if (typeof url != "string") {\n        const aliases = this.resolver.getAlias(url);\n        return aliases.some((alias) => !this.resolver.hasKey(alias)) && this.add(url), Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      return this.resolver.hasKey(url) || this.add({ alias: url, src: url }), url;\n    }), resolveResults = this.resolver.resolve(urlArray), out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.addBundle(\'animals\', {\n   *     bunny: \'bunny.png\',\n   *     chicken: \'chicken.png\',\n   *     thumper: \'thumper.png\',\n   * });\n   *\n   * const assets = await Assets.loadBundle(\'animals\');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: \'load-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'background\',\n   *                     src: \'sunset.png\',\n   *                 },\n   *                 {\n   *                     alias: \'bar\',\n   *                     src: \'load-bar.{png,webp}\',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: \'game-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'character\',\n   *                     src: \'robot.png\',\n   *                 },\n   *                 {\n   *                     alias: \'enemy\',\n   *                     src: \'bad-guy.png\',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle(\'load-screen\');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle(\'game-screen\');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    this._initialized || await this.init();\n    let singleAsset = !1;\n    typeof bundleIds == "string" && (singleAsset = !0, bundleIds = [bundleIds]);\n    const resolveResults = this.resolver.resolveBundle(bundleIds), out = {}, keys = Object.keys(resolveResults);\n    let count = 0, total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    }, promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    return await Promise.all(promises), singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.backgroundLoad(\'bunny.png\');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle(\'bunny.png\'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    this._initialized || await this.init(), typeof urls == "string" && (urls = [urls]);\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: \'load-screen\',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle(\'load-screen\');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle(\'load-screen\'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    this._initialized || await this.init(), typeof bundleIds == "string" && (bundleIds = [bundleIds]);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;\n  }\n  get(keys) {\n    if (typeof keys == "string")\n      return Cache.get(keys);\n    const assets = {};\n    for (let i = 0; i < keys.length; i++)\n      assets[i] = Cache.get(keys[i]);\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);\n    this._backgroundLoader.active = !1;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = !0;\n    const out = {};\n    return resolveArray.forEach((resolveResult, i) => {\n      const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];\n      resolveResult.alias && keys.push(...resolveResult.alias), out[resolveKeys[i]] = asset, Cache.set(keys, asset);\n    }), out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it\'s up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won\'t break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load(\'http://some.url.com/image.png\'); // => returns a texture\n   *\n   * await Assets.unload(\'http://some.url.com/image.png\')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload([\'thumper\', \'chicko\']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    this._initialized || await this.init();\n    const urlArray = convertToList(urls).map((url) => typeof url != "string" ? url.src : url), resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.addBundle({\n   *     \'thumper\': \'http://some.url.com/thumper.png\',\n   * })\n   *\n   * const assets = await Assets.loadBundle(\'thumper\');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle(\'thumper\');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    this._initialized || await this.init(), bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds), promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    }), await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    options.preferredFormats && (formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);\n    for (const detection of options.detections)\n      options.skipDetections || await detection.test() ? formats = await detection.add(formats) : options.skipDetections || (formats = await detection.remove(formats));\n    return formats = formats.filter((format, index) => formats.indexOf(format) === index), formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * @deprecated since 7.2.0\n   * @see {@link Assets.setPreferences}\n   */\n  get preferWorkers() {\n    return loadTextures.config.preferWorkers;\n  }\n  set preferWorkers(value) {\n    deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({ preferWorkers: value });\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      parser.config && Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\n\n//# sourceMappingURL=Assets.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs\n\nconst cacheTextureArray = {\n  extension: ExtensionType.CacheParser,\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture_Texture),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    return keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? "" : i + 1)] = item;\n      });\n    }), out;\n  }\n};\nextensions.add(cacheTextureArray);\n\n//# sourceMappingURL=cacheTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/utils/testImageFormat.mjs\nasync function testImageFormat(imageData) {\n  if ("Image" in globalThis)\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(!0);\n      }, image.onerror = () => {\n        resolve(!1);\n      }, image.src = imageData;\n    });\n  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch {\n      return !1;\n    }\n    return !0;\n  }\n  return !1;\n}\n\n//# sourceMappingURL=testImageFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs\n\n\nconst detectAvif = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat(\n    // eslint-disable-next-line max-len\n    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="\n  ),\n  add: async (formats) => [...formats, "avif"],\n  remove: async (formats) => formats.filter((f) => f !== "avif")\n};\nextensions.add(detectAvif);\n\n//# sourceMappingURL=detectAvif.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs\n\n\nconst detectWebp = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat(\n    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="\n  ),\n  add: async (formats) => [...formats, "webp"],\n  remove: async (formats) => formats.filter((f) => f !== "webp")\n};\nextensions.add(detectWebp);\n\n//# sourceMappingURL=detectWebp.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs\n\nconst imageFormats = ["png", "jpg", "jpeg"], detectDefaults = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(!0),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\nextensions.add(detectDefaults);\n\n//# sourceMappingURL=detectDefaults.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.mjs\nconst inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  return inWorker ? !1 : document.createElement("video").canPlayType(mimeType) !== "";\n}\n\n//# sourceMappingURL=testVideoFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectWebm.mjs\n\n\nconst detectWebm = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/webm"),\n  add: async (formats) => [...formats, "webm"],\n  remove: async (formats) => formats.filter((f) => f !== "webm")\n};\nextensions.add(detectWebm);\n\n//# sourceMappingURL=detectWebm.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectMp4.mjs\n\n\nconst detectMp4 = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/mp4"),\n  add: async (formats) => [...formats, "mp4", "m4v"],\n  remove: async (formats) => formats.filter((f) => f !== "mp4" && f !== "m4v")\n};\nextensions.add(detectMp4);\n\n//# sourceMappingURL=detectMp4.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectOgv.mjs\n\n\nconst detectOgv = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/ogg"),\n  add: async (formats) => [...formats, "ogv"],\n  remove: async (formats) => formats.filter((f) => f !== "ogv")\n};\nextensions.add(detectOgv);\n\n//# sourceMappingURL=detectOgv.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/index.mjs\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs\n\n\n\nconst resolveTextureUrl = {\n  extension: ExtensionType.ResolveParser,\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n    format: path.extname(value).slice(1),\n    src: value\n  })\n};\nextensions.add(resolveTextureUrl);\n\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  return searchParams && (targetUrl += `?${searchParams}`), targetUrl;\n};\n\n//# sourceMappingURL=copySearchParams.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/const.mjs\nvar INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => (INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", INTERNAL_FORMATS2))(INTERNAL_FORMATS || {});\nconst INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {\n  // WEBGL_compressed_texture_s3tc\n  33776: 0.5,\n  33777: 0.5,\n  33778: 1,\n  33779: 1,\n  // WEBGL_compressed_texture_s3tc\n  35916: 0.5,\n  35917: 0.5,\n  35918: 1,\n  35919: 1,\n  // WEBGL_compressed_texture_etc\n  37488: 0.5,\n  37489: 0.5,\n  37490: 1,\n  37491: 1,\n  37492: 0.5,\n  37496: 1,\n  37493: 0.5,\n  37497: 1,\n  37494: 0.5,\n  // ~~\n  37495: 0.5,\n  // ~~\n  // WEBGL_compressed_texture_pvrtc\n  35840: 0.5,\n  35842: 0.5,\n  35841: 0.25,\n  35843: 0.25,\n  // WEBGL_compressed_texture_etc1\n  36196: 0.5,\n  // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt\n  // WEBGL_compressed_texture_atc\n  35986: 0.5,\n  35987: 1,\n  34798: 1,\n  // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n  // WEBGL_compressed_texture_astc\n  /* eslint-disable-next-line camelcase */\n  37808: 1\n};\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs\n\n//# sourceMappingURL=compressedTextureExtensions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs\n\nlet storedGl, detectCompressedTextures_extensions;\nfunction getCompressedTextureExtensions() {\n  detectCompressedTextures_extensions = {\n    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),\n    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n    /* eslint-disable-line camelcase */\n    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),\n    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),\n    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),\n    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")\n  };\n}\nconst detectCompressedTextures = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    const gl = settings.ADAPTER.createCanvas().getContext("webgl");\n    return gl ? (storedGl = gl, !0) : (console.warn("WebGL not available for compressed textures."), !1);\n  },\n  add: async (formats) => {\n    detectCompressedTextures_extensions || getCompressedTextureExtensions();\n    const textureFormats = [];\n    for (const extensionName in detectCompressedTextures_extensions)\n      detectCompressedTextures_extensions[extensionName] && textureFormats.push(extensionName);\n    return [...textureFormats, ...formats];\n  },\n  remove: async (formats) => (detectCompressedTextures_extensions || getCompressedTextureExtensions(), formats.filter((f) => !(f in detectCompressedTextures_extensions)))\n};\nextensions.add(detectCompressedTextures);\n\n//# sourceMappingURL=detectCompressedTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs\n\nclass BlobResource extends BufferResource {\n  /**\n   * @param source - The buffer/URL of the texture file.\n   * @param {PIXI.IBlobResourceOptions} [options]\n   * @param {boolean} [options.autoLoad=false] - Whether to fetch the data immediately;\n   *  you can fetch it later via {@link PIXI.BlobResource#load}.\n   * @param {number} [options.width=1] - The width in pixels.\n   * @param {number} [options.height=1] - The height in pixels.\n   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.\n   */\n  constructor(source, options = { width: 1, height: 1, autoLoad: !0 }) {\n    let origin, data;\n    typeof source == "string" ? (origin = source, data = new Uint8Array()) : (origin = null, data = source), super(data, options), this.origin = origin, this.buffer = data ? new ViewableBuffer(data) : null, this._load = null, this.loaded = !1, this.origin !== null && options.autoLoad !== !1 && this.load(), this.origin === null && this.buffer && (this._load = Promise.resolve(this), this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData));\n  }\n  onBlobLoaded(_data) {\n  }\n  /** Loads the blob */\n  load() {\n    return this._load ? this._load : (this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => (this.data = new Uint32Array(arrayBuffer), this.buffer = new ViewableBuffer(arrayBuffer), this.loaded = !0, this.onBlobLoaded(arrayBuffer), this.update(), this)), this._load);\n  }\n}\n\n//# sourceMappingURL=BlobResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs\n\n\nclass CompressedTextureResource extends BlobResource {\n  /**\n   * @param source - the buffer/URL holding the compressed texture data\n   * @param options\n   * @param {PIXI.INTERNAL_FORMATS} options.format - the compression format\n   * @param {number} options.width - the image width in pixels.\n   * @param {number} options.height - the image height in pixels.\n   * @param {number} [options.level=1] - the mipmap levels stored in the compressed texture, including level 0.\n   * @param {number} [options.levelBuffers] - the buffers for each mipmap level. `CompressedTextureResource` can allows you\n   *      to pass `null` for `source`, for cases where each level is stored in non-contiguous memory.\n   */\n  constructor(source, options) {\n    super(source, options), this.format = options.format, this.levels = options.levels || 1, this._width = options.width, this._height = options.height, this._extension = CompressedTextureResource._formatToExtension(this.format), (options.levelBuffers || this.buffer) && (this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(\n      source instanceof Uint8Array ? source : this.buffer.uint8View,\n      this.format,\n      this.levels,\n      4,\n      4,\n      // PVRTC has 8x4 blocks in 2bpp mode\n      this.width,\n      this.height\n    ));\n  }\n  /**\n   * @override\n   * @param renderer - A reference to the current renderer\n   * @param _texture - the texture\n   * @param _glTexture - texture instance for this webgl context\n   */\n  upload(renderer, _texture, _glTexture) {\n    const gl = renderer.gl;\n    if (!renderer.context.extensions[this._extension])\n      throw new Error(`${this._extension} textures are not supported on the current machine`);\n    if (!this._levelBuffers)\n      return !1;\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n    for (let i = 0, j = this.levels; i < j; i++) {\n      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];\n      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);\n    }\n    return !0;\n  }\n  /** @protected */\n  onBlobLoaded() {\n    this._levelBuffers = CompressedTextureResource._createLevelBuffers(\n      this.buffer.uint8View,\n      this.format,\n      this.levels,\n      4,\n      4,\n      // PVRTC has 8x4 blocks in 2bpp mode\n      this.width,\n      this.height\n    );\n  }\n  /**\n   * Returns the key (to ContextSystem#extensions) for the WebGL extension supporting the compression format\n   * @private\n   * @param format - the compression format to get the extension for.\n   */\n  static _formatToExtension(format) {\n    if (format >= 33776 && format <= 33779)\n      return "s3tc";\n    if (format >= 37488 && format <= 37497)\n      return "etc";\n    if (format >= 35840 && format <= 35843)\n      return "pvrtc";\n    if (format >= 36196)\n      return "etc1";\n    if (format >= 35986 && format <= 34798)\n      return "atc";\n    throw new Error("Invalid (compressed) texture format given!");\n  }\n  /**\n   * Pre-creates buffer views for each mipmap level\n   * @private\n   * @param buffer -\n   * @param format - compression formats\n   * @param levels - mipmap levels\n   * @param blockWidth -\n   * @param blockHeight -\n   * @param imageWidth - width of the image in pixels\n   * @param imageHeight - height of the image in pixels\n   */\n  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {\n    const buffers = new Array(levels);\n    let offset = buffer.byteOffset, levelWidth = imageWidth, levelHeight = imageHeight, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n    for (let i = 0; i < levels; i++)\n      buffers[i] = {\n        levelID: i,\n        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,\n        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,\n        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)\n      }, offset += levelSize, levelWidth = levelWidth >> 1 || 1, levelHeight = levelHeight >> 1 || 1, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n    return buffers;\n  }\n}\n\n//# sourceMappingURL=CompressedTextureResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs\n\n\n\nconst DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n}, DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n}, DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n}, PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = {\n  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n}, DXGI_TO_FORMAT = {\n  // WEBGL_compressed_texture_s3tc\n  70: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  71: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  73: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  74: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  76: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  77: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  // WEBGL_compressed_texture_s3tc_srgb\n  72: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n  75: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n  78: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n};\nfunction parseDDS(arrayBuffer) {\n  const data = new Uint32Array(arrayBuffer);\n  if (data[0] !== DDS_MAGIC)\n    throw new Error("Invalid DDS file magic word");\n  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), height = header[DDS_FIELDS.HEIGHT], width = header[DDS_FIELDS.WIDTH], mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT], pixelFormat = new Uint32Array(\n    arrayBuffer,\n    DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,\n    DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT\n  ), formatFlags = pixelFormat[PF_FLAGS];\n  if (formatFlags & DDPF_FOURCC) {\n    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];\n    if (fourCC !== FOURCC_DX10) {\n      const internalFormat2 = FOURCC_TO_FORMAT[fourCC], dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, texData = new Uint8Array(arrayBuffer, dataOffset2);\n      return [new CompressedTextureResource(texData, {\n        format: internalFormat2,\n        width,\n        height,\n        levels: mipmapCount\n        // CompressedTextureResource will separate the levelBuffers for us!\n      })];\n    }\n    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, dx10Header = new Uint32Array(\n      data.buffer,\n      dx10Offset,\n      DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT\n    ), dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT], resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION], miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG], arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE], internalFormat = DXGI_TO_FORMAT[dxgiFormat];\n    if (internalFormat === void 0)\n      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE)\n      throw new Error("DDSParser does not support cubemap textures");\n    if (resourceDimension === 6)\n      throw new Error("DDSParser does not supported 3D texture data");\n    const imageBuffers = new Array(), dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (arraySize === 1)\n      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));\n    else {\n      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];\n      let imageSize = 0, levelWidth = width, levelHeight = height;\n      for (let i = 0; i < mipmapCount; i++) {\n        const alignedLevelWidth = Math.max(1, levelWidth + 3 & -4), alignedLevelHeight = Math.max(1, levelHeight + 3 & -4), levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;\n        imageSize += levelSize, levelWidth = levelWidth >>> 1, levelHeight = levelHeight >>> 1;\n      }\n      let imageOffset = dataOffset;\n      for (let i = 0; i < arraySize; i++)\n        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize)), imageOffset += imageSize;\n    }\n    return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {\n      format: internalFormat,\n      width,\n      height,\n      levels: mipmapCount\n    }));\n  }\n  throw formatFlags & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : formatFlags & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : formatFlags & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : formatFlags & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");\n}\n\n//# sourceMappingURL=parseDDS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs\n\n\n\n\nconst FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = {\n  [TYPES.UNSIGNED_BYTE]: 1,\n  [TYPES.UNSIGNED_SHORT]: 2,\n  [TYPES.INT]: 4,\n  [TYPES.UNSIGNED_INT]: 4,\n  [TYPES.FLOAT]: 4,\n  [TYPES.HALF_FLOAT]: 8\n}, FORMATS_TO_COMPONENTS = {\n  [FORMATS.RGBA]: 4,\n  [FORMATS.RGB]: 3,\n  [FORMATS.RG]: 2,\n  [FORMATS.RED]: 1,\n  [FORMATS.LUMINANCE]: 1,\n  [FORMATS.LUMINANCE_ALPHA]: 2,\n  [FORMATS.ALPHA]: 1\n}, TYPES_TO_BYTES_PER_PIXEL = {\n  [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,\n  [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,\n  [TYPES.UNSIGNED_SHORT_5_6_5]: 2\n};\nfunction parseKTX(url, arrayBuffer, loadKeyValueData = !1) {\n  const dataView = new DataView(arrayBuffer);\n  if (!validate(url, dataView))\n    return null;\n  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian), glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian), glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian), pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian), pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1, pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1, numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1, numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian), numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian), bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n  if (pixelHeight === 0 || pixelDepth !== 1)\n    throw new Error("Only 2D textures are supported");\n  if (numberOfFaces !== 1)\n    throw new Error("CubeTextures are not supported by KTXLoader yet!");\n  if (numberOfArrayElements !== 1)\n    throw new Error("WebGL does not support array textures");\n  const blockWidth = 4, blockHeight = 4, alignedWidth = pixelWidth + 3 & -4, alignedHeight = pixelHeight + 3 & -4, imageBuffers = new Array(numberOfArrayElements);\n  let imagePixels = pixelWidth * pixelHeight;\n  glType === 0 && (imagePixels = alignedWidth * alignedHeight);\n  let imagePixelByteSize;\n  if (glType !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[glType] ? imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat] : imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType] : imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat], imagePixelByteSize === void 0)\n    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");\n  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;\n  let mipByteSize = imagePixels * imagePixelByteSize, mipWidth = pixelWidth, mipHeight = pixelHeight, alignedMipWidth = alignedWidth, alignedMipHeight = alignedHeight, imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;\n  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {\n    const imageSize = dataView.getUint32(imageOffset, littleEndian);\n    let elementOffset = imageOffset + 4;\n    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {\n      let mips = imageBuffers[arrayElement];\n      mips || (mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels)), mips[mipmapLevel] = {\n        levelID: mipmapLevel,\n        // don\'t align mipWidth when texture not compressed! (glType not zero)\n        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,\n        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,\n        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)\n      }, elementOffset += mipByteSize;\n    }\n    imageOffset += imageSize + 4, imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset, mipWidth = mipWidth >> 1 || 1, mipHeight = mipHeight >> 1 || 1, alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1), alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1), mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n  }\n  return glType !== 0 ? {\n    uncompressed: imageBuffers.map((levelBuffers) => {\n      let buffer = levelBuffers[0].levelBuffer, convertToInt = !1;\n      return glType === TYPES.FLOAT ? buffer = new Float32Array(\n        levelBuffers[0].levelBuffer.buffer,\n        levelBuffers[0].levelBuffer.byteOffset,\n        levelBuffers[0].levelBuffer.byteLength / 4\n      ) : glType === TYPES.UNSIGNED_INT ? (convertToInt = !0, buffer = new Uint32Array(\n        levelBuffers[0].levelBuffer.buffer,\n        levelBuffers[0].levelBuffer.byteOffset,\n        levelBuffers[0].levelBuffer.byteLength / 4\n      )) : glType === TYPES.INT && (convertToInt = !0, buffer = new Int32Array(\n        levelBuffers[0].levelBuffer.buffer,\n        levelBuffers[0].levelBuffer.byteOffset,\n        levelBuffers[0].levelBuffer.byteLength / 4\n      )), {\n        resource: new BufferResource(\n          buffer,\n          {\n            width: levelBuffers[0].levelWidth,\n            height: levelBuffers[0].levelHeight\n          }\n        ),\n        type: glType,\n        format: convertToInt ? convertFormatToInteger(glFormat) : glFormat\n      };\n    }),\n    kvData\n  } : {\n    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {\n      format: glInternalFormat,\n      width: pixelWidth,\n      height: pixelHeight,\n      levels: numberOfMipmapLevels,\n      levelBuffers\n    })),\n    kvData\n  };\n}\nfunction validate(url, dataView) {\n  for (let i = 0; i < FILE_IDENTIFIER.length; i++)\n    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i])\n      return console.error(`${url} is not a valid *.ktx file!`), !1;\n  return !0;\n}\nfunction convertFormatToInteger(format) {\n  switch (format) {\n    case FORMATS.RGBA:\n      return FORMATS.RGBA_INTEGER;\n    case FORMATS.RGB:\n      return FORMATS.RGB_INTEGER;\n    case FORMATS.RG:\n      return FORMATS.RG_INTEGER;\n    case FORMATS.RED:\n      return FORMATS.RED_INTEGER;\n    default:\n      return format;\n  }\n}\nfunction parseKvData(dataView, bytesOfKeyValueData, littleEndian) {\n  const kvData = /* @__PURE__ */ new Map();\n  let bytesIntoKeyValueData = 0;\n  for (; bytesIntoKeyValueData < bytesOfKeyValueData; ) {\n    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian), keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4, valuePadding = 3 - (keyAndValueByteSize + 3) % 4;\n    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {\n      console.error("KTXLoader: keyAndValueByteSize out of bounds");\n      break;\n    }\n    let keyNulByte = 0;\n    for (; keyNulByte < keyAndValueByteSize && dataView.getUint8(keyAndValueByteOffset + keyNulByte) !== 0; keyNulByte++)\n      ;\n    if (keyNulByte === -1) {\n      console.error("KTXLoader: Failed to find null byte terminating kvData key");\n      break;\n    }\n    const key = new TextDecoder().decode(\n      new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte)\n    ), value = new DataView(\n      dataView.buffer,\n      keyAndValueByteOffset + keyNulByte + 1,\n      keyAndValueByteSize - keyNulByte - 1\n    );\n    kvData.set(key, value), bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;\n  }\n  return kvData;\n}\n\n//# sourceMappingURL=parseKTX.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs\n\n\n\n\nconst loadDDS = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadDDS",\n  test(url) {\n    return checkExtension(url, ".dds");\n  },\n  async load(url, asset, loader) {\n    const arrayBuffer = await (await settings.ADAPTER.fetch(url)).arrayBuffer(), textures = parseDDS(arrayBuffer).map((resource) => {\n      const base = new BaseTexture(resource, {\n        mipmap: MIPMAP_MODES.OFF,\n        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n        resolution: getResolutionOfUrl(url),\n        ...asset.data\n      });\n      return createTexture(base, loader, url);\n    });\n    return textures.length === 1 ? textures[0] : textures;\n  },\n  unload(texture) {\n    Array.isArray(texture) ? texture.forEach((t) => t.destroy(!0)) : texture.destroy(!0);\n  }\n};\nextensions.add(loadDDS);\n\n//# sourceMappingURL=loadDDS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs\n\n\n\n\nconst loadKTX = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadKTX",\n  test(url) {\n    return checkExtension(url, ".ktx");\n  },\n  async load(url, asset, loader) {\n    const arrayBuffer = await (await settings.ADAPTER.fetch(url)).arrayBuffer(), { compressed, uncompressed, kvData } = parseKTX(url, arrayBuffer), resources = compressed ?? uncompressed, options = {\n      mipmap: MIPMAP_MODES.OFF,\n      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n      resolution: getResolutionOfUrl(url),\n      ...asset.data\n    }, textures = resources.map((resource) => {\n      resources === uncompressed && Object.assign(options, {\n        type: resource.type,\n        format: resource.format\n      });\n      const res = resource.resource ?? resource, base = new BaseTexture(res, options);\n      return base.ktxKeyValueData = kvData, createTexture(base, loader, url);\n    });\n    return textures.length === 1 ? textures[0] : textures;\n  },\n  unload(texture) {\n    Array.isArray(texture) ? texture.forEach((t) => t.destroy(!0)) : texture.destroy(!0);\n  }\n};\nextensions.add(loadKTX);\n\n//# sourceMappingURL=loadKTX.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs\n\nconst resolveCompressedTextureUrl = {\n  extension: ExtensionType.ResolveParser,\n  test: (value) => {\n    const extension = path.extname(value).slice(1);\n    return ["basis", "ktx", "dds"].includes(extension);\n  },\n  parse: (value) => {\n    const extension = path.extname(value).slice(1);\n    if (extension === "ktx") {\n      const extensions2 = [\n        ".s3tc.ktx",\n        ".s3tc_sRGB.ktx",\n        ".etc.ktx",\n        ".etc1.ktx",\n        ".pvrt.ktx",\n        ".atc.ktx",\n        ".astc.ktx"\n      ];\n      if (extensions2.some((ext) => value.endsWith(ext)))\n        return {\n          resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n          format: extensions2.find((ext) => value.endsWith(ext)),\n          src: value\n        };\n    }\n    return {\n      resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n      format: extension,\n      src: value\n    };\n  }\n};\nextensions.add(resolveCompressedTextureUrl);\n\n//# sourceMappingURL=resolveCompressedTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/Extract.mjs\n\nconst TEMP_RECT = new Rectangle_Rectangle(), BYTES_PER_PIXEL = 4, _Extract = class _Extract2 {\n  /**\n   * @param renderer - A reference to the current renderer\n   */\n  constructor(renderer) {\n    this.renderer = renderer, this._rendererPremultipliedAlpha = !1;\n  }\n  contextChange() {\n    const attributes = this.renderer?.gl.getContextAttributes();\n    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param format - Image format, e.g. "image/jpeg" or "image/webp".\n   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - HTML Image of the target\n   */\n  async image(target, format, quality, frame) {\n    const image = new Image();\n    return image.src = await this.base64(target, format, quality, frame), image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   *  `Extract.canvas` and then running toDataURL on that.\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param format - Image format, e.g. "image/jpeg" or "image/webp".\n   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - A base64 encoded string of the texture.\n   */\n  async base64(target, format, quality, frame) {\n    const canvas = this.canvas(target, frame);\n    if (canvas.toBlob !== void 0)\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error("ICanvas.toBlob failed!"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);\n        }, format, quality);\n      });\n    if (canvas.toDataURL !== void 0)\n      return canvas.toDataURL(format, quality);\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: format, quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(target, frame) {\n    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);\n    flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels);\n    const canvasBuffer = new CanvasRenderTarget(width, height, 1), imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);\n    return canvasBuffer.context.putImageData(imageData, 0, 0), canvasBuffer.canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param target - A displayObject or renderTexture\n   *  to convert. If left empty will use the main renderer\n   * @param frame - The frame the extraction is restricted to.\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(target, frame) {\n    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);\n    return flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels), pixels;\n  }\n  _rawPixels(target, frame) {\n    const renderer = this.renderer;\n    if (!renderer)\n      throw new Error("The Extract has already been destroyed");\n    let resolution, flipY = !1, premultipliedAlpha = !1, renderTexture, generated = !1;\n    target && (target instanceof RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {\n      region: frame,\n      resolution: renderer.resolution,\n      multisample: renderer.multisample\n    }), generated = !0, frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT)));\n    const gl = renderer.gl;\n    if (renderTexture) {\n      if (resolution = renderTexture.baseTexture.resolution, frame = frame ?? renderTexture.frame, flipY = !1, premultipliedAlpha = renderTexture.baseTexture.alphaMode > 0 && renderTexture.baseTexture.format === FORMATS.RGBA, !generated) {\n        renderer.renderTexture.bind(renderTexture);\n        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];\n        fbo.blitFramebuffer && renderer.framebuffer.bind(fbo.blitFramebuffer);\n      }\n    } else\n      resolution = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution), flipY = !0, premultipliedAlpha = this._rendererPremultipliedAlpha, renderer.renderTexture.bind();\n    const width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    return gl.readPixels(\n      Math.round(frame.x * resolution),\n      Math.round(frame.y * resolution),\n      width,\n      height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    ), generated && renderTexture?.destroy(!0), { pixels, width, height, flipY, premultipliedAlpha };\n  }\n  /** Destroys the extract. */\n  destroy() {\n    this.renderer = null;\n  }\n  static _flipY(pixels, width, height) {\n    const w = width << 2, h = height >> 1, temp = new Uint8Array(w);\n    for (let y = 0; y < h; y++) {\n      const t = y * w, b = (height - y - 1) * w;\n      temp.set(pixels.subarray(t, t + w)), pixels.copyWithin(t, b, b + w), pixels.set(temp, b);\n    }\n  }\n  static _unpremultiplyAlpha(pixels) {\n    pixels instanceof Uint8ClampedArray && (pixels = new Uint8Array(pixels.buffer));\n    const n = pixels.length;\n    for (let i = 0; i < n; i += 4) {\n      const alpha = pixels[i + 3];\n      if (alpha !== 0) {\n        const a = 255.001 / alpha;\n        pixels[i] = pixels[i] * a + 0.5, pixels[i + 1] = pixels[i + 1] * a + 0.5, pixels[i + 2] = pixels[i + 2] * a + 0.5;\n      }\n    }\n  }\n};\n_Extract.extension = {\n  name: "extract",\n  type: ExtensionType.RendererSystem\n};\nlet Extract = _Extract;\nextensions.add(Extract);\n\n//# sourceMappingURL=Extract.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs\n\nconst buildCircle = {\n  build(graphicsData) {\n    const points = graphicsData.points;\n    let x, y, dx, dy, rx, ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      const circle = graphicsData.shape;\n      x = circle.x, y = circle.y, rx = ry = circle.radius, dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      const ellipse = graphicsData.shape;\n      x = ellipse.x, y = ellipse.y, rx = ellipse.width, ry = ellipse.height, dx = dy = 0;\n    } else {\n      const roundedRect = graphicsData.shape, halfWidth = roundedRect.width / 2, halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth, y = roundedRect.y + halfHeight, rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight))), dx = halfWidth - rx, dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry)), m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (points.length = m, m === 0)\n      return;\n    if (n === 0) {\n      points.length = 8, points[0] = points[6] = x + dx, points[1] = points[3] = y + dy, points[2] = points[4] = x - dx, points[5] = points[7] = y - dy;\n      return;\n    }\n    let j1 = 0, j2 = n * 4 + (dx ? 2 : 0) + 2, j3 = j2, j4 = m;\n    {\n      const x0 = dx + rx, y0 = dy, x1 = x + x0, x2 = x - x0, y1 = y + y0;\n      if (points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x2, dy) {\n        const y2 = y - y0;\n        points[j3++] = x2, points[j3++] = y2, points[--j4] = y2, points[--j4] = x1;\n      }\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n), x0 = dx + Math.cos(a) * rx, y0 = dy + Math.sin(a) * ry, x1 = x + x0, x2 = x - x0, y1 = y + y0, y2 = y - y0;\n      points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x2, points[j3++] = x2, points[j3++] = y2, points[--j4] = y2, points[--j4] = x1;\n    }\n    {\n      const x0 = dx, y0 = dy + ry, x1 = x + x0, x2 = x - x0, y1 = y + y0, y2 = y - y0;\n      points[j1++] = x1, points[j1++] = y1, points[--j4] = y2, points[--j4] = x1, dx && (points[j1++] = x2, points[j1++] = y1, points[--j4] = y2, points[--j4] = x2);\n    }\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points, verts = graphicsGeometry.points, indices = graphicsGeometry.indices;\n    if (points.length === 0)\n      return;\n    let vertPos = verts.length / 2;\n    const center = vertPos;\n    let x, y;\n    if (graphicsData.type !== SHAPES.RREC) {\n      const circle = graphicsData.shape;\n      x = circle.x, y = circle.y;\n    } else {\n      const roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2, y = roundedRect.y + roundedRect.height / 2;\n    }\n    const matrix = graphicsData.matrix;\n    verts.push(\n      graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x,\n      graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y\n    ), vertPos++, verts.push(points[0], points[1]);\n    for (let i = 2; i < points.length; i += 2)\n      verts.push(points[i], points[i + 1]), indices.push(vertPos++, center, vertPos);\n    indices.push(center + 1, center, vertPos);\n  }\n};\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs\n\nfunction fixOrientation(points, hole = !1) {\n  const m = points.length;\n  if (m < 6)\n    return;\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i], y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1), x1 = x2, y1 = y2;\n  }\n  if (!hole && area > 0 || hole && area <= 0) {\n    const n = m / 2;\n    for (let i = n + n % 2; i < m; i += 2) {\n      const i1 = m - i - 2, i2 = m - i - 1, i3 = i, i4 = i + 1;\n      [points[i1], points[i3]] = [points[i3], points[i1]], [points[i2], points[i4]] = [points[i4], points[i2]];\n    }\n  }\n}\nconst buildPoly = {\n  build(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    let points = graphicsData.points;\n    const holes = graphicsData.holes, verts = graphicsGeometry.points, indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, !1);\n      const holeArray = [];\n      for (let i = 0; i < holes.length; i++) {\n        const hole = holes[i];\n        fixOrientation(hole.points, !0), holeArray.push(points.length / 2), points = points.concat(hole.points);\n      }\n      const triangles = earcut(points, holeArray, 2);\n      if (!triangles)\n        return;\n      const vertPos = verts.length / 2;\n      for (let i = 0; i < triangles.length; i += 3)\n        indices.push(triangles[i] + vertPos), indices.push(triangles[i + 1] + vertPos), indices.push(triangles[i + 2] + vertPos);\n      for (let i = 0; i < points.length; i++)\n        verts.push(points[i]);\n    }\n  }\n};\n\n//# sourceMappingURL=buildPoly.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs\nconst buildRectangle = {\n  build(graphicsData) {\n    const rectData = graphicsData.shape, x = rectData.x, y = rectData.y, width = rectData.width, height = rectData.height, points = graphicsData.points;\n    points.length = 0, width >= 0 && height >= 0 && points.push(\n      x,\n      y,\n      x + width,\n      y,\n      x + width,\n      y + height,\n      x,\n      y + height\n    );\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points, verts = graphicsGeometry.points;\n    if (points.length === 0)\n      return;\n    const vertPos = verts.length / 2;\n    verts.push(\n      points[0],\n      points[1],\n      points[2],\n      points[3],\n      points[6],\n      points[7],\n      points[4],\n      points[5]\n    ), graphicsGeometry.indices.push(\n      vertPos,\n      vertPos + 1,\n      vertPos + 2,\n      vertPos + 1,\n      vertPos + 2,\n      vertPos + 3\n    );\n  }\n};\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs\n\nconst buildRoundedRectangle = {\n  build(graphicsData) {\n    buildCircle.build(graphicsData);\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    buildCircle.triangulate(graphicsData, graphicsGeometry);\n  }\n};\n\n//# sourceMappingURL=buildRoundedRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/const.mjs\nvar LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => (LINE_JOIN2.MITER = "miter", LINE_JOIN2.BEVEL = "bevel", LINE_JOIN2.ROUND = "round", LINE_JOIN2))(LINE_JOIN || {}), LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => (LINE_CAP2.BUTT = "butt", LINE_CAP2.ROUND = "round", LINE_CAP2.SQUARE = "square", LINE_CAP2))(LINE_CAP || {});\nconst curves = {\n  adaptive: !0,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount(length, defaultSegments = 20) {\n    if (!this.adaptive || !length || isNaN(length))\n      return defaultSegments;\n    let result = Math.ceil(length / this.maxLength);\n    return result < this.minSegments ? result = this.minSegments : result > this.maxSegments && (result = this.maxSegments), result;\n  }\n}, GRAPHICS_CURVES = (/* unused pure expression or super */ null && (curves));\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs\n\n\nclass ArcUtils {\n  /**\n   * Calculate information of the arc for {@link PIXI.Graphics.arcTo}.\n   * @private\n   * @param x1 - The x-coordinate of the first control point of the arc\n   * @param y1 - The y-coordinate of the first control point of the arc\n   * @param x2 - The x-coordinate of the second control point of the arc\n   * @param y2 - The y-coordinate of the second control point of the arc\n   * @param radius - The radius of the arc\n   * @param points - Collection of points to add to\n   * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n   */\n  static curveTo(x1, y1, x2, y2, radius, points) {\n    const fromX = points[points.length - 2], a1 = points[points.length - 1] - y1, b1 = fromX - x1, a2 = y2 - y1, b2 = x2 - x1, mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0)\n      return (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) && points.push(x1, y1), null;\n    const dd = a1 * a1 + b1 * b1, cc = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd) / mm, k2 = radius * Math.sqrt(cc) / mm, j1 = k1 * tt / dd, j2 = k2 * tt / cc, cx = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx), endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius,\n      startAngle,\n      endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  }\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   * @private\n   * @param _startX - Start x location of arc\n   * @param _startY - Start y location of arc\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o\'clock position\n   *  of the arc\'s circle)\n   * @param endAngle - The ending angle, in radians\n   * @param _anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @param points - Collection of points to add to\n   */\n  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    const sweep = endAngle - startAngle, n = curves._segmentsCount(\n      Math.abs(sweep) * radius,\n      Math.ceil(Math.abs(sweep) / PI_2) * 40\n    ), theta = sweep / (n * 2), theta2 = theta * 2, cTheta = Math.cos(theta), sTheta = Math.sin(theta), segMinus = n - 1, remainder = segMinus % 1 / segMinus;\n    for (let i = 0; i <= segMinus; ++i) {\n      const real = i + remainder * i, angle = theta + startAngle + theta2 * real, c = Math.cos(angle), s = -Math.sin(angle);\n      points.push(\n        (cTheta * c + sTheta * s) * radius + cx,\n        (cTheta * -s + sTheta * c) * radius + cy\n      );\n    }\n  }\n}\n\n//# sourceMappingURL=ArcUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs\n\nclass BezierUtils {\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   * @private\n   * @param fromX - Starting point x\n   * @param fromY - Starting point y\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns - Length of bezier curve\n   */\n  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    let result = 0, t = 0, t2 = 0, t3 = 0, nt = 0, nt2 = 0, nt3 = 0, x = 0, y = 0, dx = 0, dy = 0, prevX = fromX, prevY = fromY;\n    for (let i = 1; i <= 10; ++i)\n      t = i / 10, t2 = t * t, t3 = t2 * t, nt = 1 - t, nt2 = nt * nt, nt3 = nt2 * nt, x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX, y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY, dx = prevX - x, dy = prevY - y, prevX = x, prevY = y, result += Math.sqrt(dx * dx + dy * dy);\n    return result;\n  }\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * Ignored from docs since it is not directly exposed.\n   * @ignore\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Path array to push points into\n   */\n  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    const fromX = points[points.length - 2], fromY = points[points.length - 1];\n    points.length -= 2;\n    const n = curves._segmentsCount(\n      BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n    );\n    let dt = 0, dt2 = 0, dt3 = 0, t2 = 0, t3 = 0;\n    points.push(fromX, fromY);\n    for (let i = 1, j = 0; i <= n; ++i)\n      j = i / n, dt = 1 - j, dt2 = dt * dt, dt3 = dt2 * dt, t2 = j * j, t3 = t2 * j, points.push(\n        dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,\n        dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY\n      );\n  }\n}\n\n//# sourceMappingURL=BezierUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildLine.mjs\n\n\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight, iy = y - ny * innerWeight, ox = x + nx * outerWeight, oy = y + ny * outerWeight;\n  let exx, eyy;\n  clockwise ? (exx = ny, eyy = -nx) : (exx = -ny, eyy = nx);\n  const eix = ix + exx, eiy = iy + eyy, eox = ox + exx, eoy = oy + eyy;\n  return verts.push(\n    eix,\n    eiy,\n    eox,\n    eoy\n  ), 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx, cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y), angle1 = Math.atan2(ex - cx, ey - cy);\n  clockwise && angle0 < angle1 ? angle0 += Math.PI * 2 : !clockwise && angle0 > angle1 && (angle1 += Math.PI * 2);\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0, absAngleDiff = Math.abs(angleDiff), radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y), segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1, angleInc = angleDiff / segCount;\n  if (startAngle += angleInc, clockwise) {\n    verts.push(\n      cx,\n      cy,\n      sx,\n      sy\n    );\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n      verts.push(\n        cx,\n        cy,\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    verts.push(\n      cx,\n      cy,\n      ex,\n      ey\n    );\n  } else {\n    verts.push(\n      sx,\n      sy,\n      cx,\n      cy\n    );\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius,\n        cx,\n        cy\n      );\n    verts.push(\n      ex,\n      ey,\n      cx,\n      cy\n    );\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  const shape = graphicsData.shape;\n  let points = graphicsData.points || shape.points.slice();\n  const eps = graphicsGeometry.closePointEps;\n  if (points.length === 0)\n    return;\n  const style = graphicsData.lineStyle, firstPoint = new Point(points[0], points[1]), lastPoint = new Point(points[points.length - 2], points[points.length - 1]), closedShape = shape.type !== SHAPES.POLY || shape.closeStroke, closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice(), closedPath && (points.pop(), points.pop(), lastPoint.set(points[points.length - 2], points[points.length - 1]));\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5, midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY), points.push(midPointX, midPointY);\n  }\n  const verts = graphicsGeometry.points, length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2, width = style.width / 2, widthSquared = width * width, miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0], y0 = points[1], x1 = points[2], y1 = points[3], x2 = 0, y2 = 0, perpx = -(y0 - y1), perpy = x0 - x1, perp1x = 0, perp1y = 0, dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist, perpy /= dist, perpx *= width, perpy *= width;\n  const ratio = style.alignment, innerWeight = (1 - ratio) * 2, outerWeight = ratio * 2;\n  closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(\n    x0 - perpx * (innerWeight - outerWeight) * 0.5,\n    y0 - perpy * (innerWeight - outerWeight) * 0.5,\n    x0 - perpx * innerWeight,\n    y0 - perpy * innerWeight,\n    x0 + perpx * outerWeight,\n    y0 + perpy * outerWeight,\n    verts,\n    !0\n  ) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, !0, verts))), verts.push(\n    x0 - perpx * innerWeight,\n    y0 - perpy * innerWeight,\n    x0 + perpx * outerWeight,\n    y0 + perpy * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2], y0 = points[(i - 1) * 2 + 1], x1 = points[i * 2], y1 = points[i * 2 + 1], x2 = points[(i + 1) * 2], y2 = points[(i + 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, perp1x = -(y1 - y2), perp1y = x1 - x2, dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y), perp1x /= dist, perp1y /= dist, perp1x *= width, perp1y *= width;\n    const dx0 = x1 - x0, dy0 = y0 - y1, dx1 = x1 - x2, dy1 = y2 - y1, dot = dx0 * dx1 + dy0 * dy1, cross = dy0 * dx1 - dy1 * dx0, clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpx * innerWeight,\n        y1 - perpy * innerWeight,\n        x1 + perpx * outerWeight,\n        y1 + perpy * outerWeight\n      ), dot >= 0 && (style.join === LINE_JOIN.ROUND ? indexCount += round(\n        x1,\n        y1,\n        x1 - perpx * innerWeight,\n        y1 - perpy * innerWeight,\n        x1 - perp1x * innerWeight,\n        y1 - perp1y * innerWeight,\n        verts,\n        !1\n      ) + 4 : indexCount += 2, verts.push(\n        x1 - perp1x * outerWeight,\n        y1 - perp1y * outerWeight,\n        x1 + perp1x * innerWeight,\n        y1 + perp1y * innerWeight\n      ));\n      continue;\n    }\n    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0), c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2), px = (dx0 * c2 - dx1 * c1) / cross, py = (dy1 * c1 - dy0 * c2) / cross, pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1), imx = x1 + (px - x1) * innerWeight, imy = y1 + (py - y1) * innerWeight, omx = x1 - (px - x1) * outerWeight, omy = y1 - (py - y1) * outerWeight, smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1), insideWeight = clockwise ? innerWeight : outerWeight, smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared, insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    let join = style.join;\n    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared && (join = LINE_JOIN.BEVEL), insideMiterOk)\n      switch (join) {\n        case LINE_JOIN.MITER: {\n          verts.push(\n            imx,\n            imy,\n            omx,\n            omy\n          );\n          break;\n        }\n        case LINE_JOIN.BEVEL: {\n          clockwise ? verts.push(\n            imx,\n            imy,\n            // inner miter point\n            x1 + perpx * outerWeight,\n            y1 + perpy * outerWeight,\n            // first segment\'s outer vertex\n            imx,\n            imy,\n            // inner miter point\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight\n          ) : verts.push(\n            x1 - perpx * innerWeight,\n            y1 - perpy * innerWeight,\n            // first segment\'s inner vertex\n            omx,\n            omy,\n            // outer miter point\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            // second segment\'s outer vertex\n            omx,\n            omy\n          ), indexCount += 2;\n          break;\n        }\n        case LINE_JOIN.ROUND: {\n          clockwise ? (verts.push(\n            imx,\n            imy,\n            x1 + perpx * outerWeight,\n            y1 + perpy * outerWeight\n          ), indexCount += round(\n            x1,\n            y1,\n            x1 + perpx * outerWeight,\n            y1 + perpy * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            !0\n          ) + 4, verts.push(\n            imx,\n            imy,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight\n          )) : (verts.push(\n            x1 - perpx * innerWeight,\n            y1 - perpy * innerWeight,\n            omx,\n            omy\n          ), indexCount += round(\n            x1,\n            y1,\n            x1 - perpx * innerWeight,\n            y1 - perpy * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            !1\n          ) + 4, verts.push(\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            omx,\n            omy\n          ));\n          break;\n        }\n      }\n    else {\n      switch (verts.push(\n        x1 - perpx * innerWeight,\n        y1 - perpy * innerWeight,\n        // first segment\'s inner vertex\n        x1 + perpx * outerWeight,\n        y1 + perpy * outerWeight\n      ), join) {\n        case LINE_JOIN.MITER: {\n          clockwise ? verts.push(\n            omx,\n            omy,\n            // inner miter point\n            omx,\n            omy\n          ) : verts.push(\n            imx,\n            imy,\n            // outer miter point\n            imx,\n            imy\n          ), indexCount += 2;\n          break;\n        }\n        case LINE_JOIN.ROUND: {\n          clockwise ? indexCount += round(\n            x1,\n            y1,\n            x1 + perpx * outerWeight,\n            y1 + perpy * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            !0\n          ) + 2 : indexCount += round(\n            x1,\n            y1,\n            x1 - perpx * innerWeight,\n            y1 - perpy * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            !1\n          ) + 2;\n          break;\n        }\n      }\n      verts.push(\n        x1 - perp1x * innerWeight,\n        y1 - perp1y * innerWeight,\n        // second segment\'s inner vertex\n        x1 + perp1x * outerWeight,\n        y1 + perp1y * outerWeight\n      ), indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2], y0 = points[(length - 2) * 2 + 1], x1 = points[(length - 1) * 2], y1 = points[(length - 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, verts.push(\n    x1 - perpx * innerWeight,\n    y1 - perpy * innerWeight,\n    x1 + perpx * outerWeight,\n    y1 + perpy * outerWeight\n  ), closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(\n    x1 - perpx * (innerWeight - outerWeight) * 0.5,\n    y1 - perpy * (innerWeight - outerWeight) * 0.5,\n    x1 - perpx * innerWeight,\n    y1 - perpy * innerWeight,\n    x1 + perpx * outerWeight,\n    y1 + perpy * outerWeight,\n    verts,\n    !1\n  ) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, !1, verts)));\n  const indices = graphicsGeometry.indices, eps2 = curves.epsilon * curves.epsilon;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    x0 = verts[i * 2], y0 = verts[i * 2 + 1], x1 = verts[(i + 1) * 2], y1 = verts[(i + 1) * 2 + 1], x2 = verts[(i + 2) * 2], y2 = verts[(i + 2) * 2 + 1], !(Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) && indices.push(i, i + 1, i + 2);\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  let i = 0;\n  const shape = graphicsData.shape, points = graphicsData.points || shape.points, closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0)\n    return;\n  const verts = graphicsGeometry.points, indices = graphicsGeometry.indices, length = points.length / 2, startIndex = verts.length / 2;\n  let currentIndex = startIndex;\n  for (verts.push(points[0], points[1]), i = 1; i < length; i++)\n    verts.push(points[i * 2], points[i * 2 + 1]), indices.push(currentIndex, currentIndex + 1), currentIndex++;\n  closedShape && indices.push(currentIndex, startIndex);\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  graphicsData.lineStyle.native ? buildNativeLine(graphicsData, graphicsGeometry) : buildNonNativeLine(graphicsData, graphicsGeometry);\n}\n\n//# sourceMappingURL=buildLine.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs\n\nclass QuadraticUtils {\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   * @private\n   * @param fromX - x-coordinate of curve start point\n   * @param fromY - y-coordinate of curve start point\n   * @param cpX - x-coordinate of curve control point\n   * @param cpY - y-coordinate of curve control point\n   * @param toX - x-coordinate of curve end point\n   * @param toY - y-coordinate of curve end point\n   * @returns - Length of quadratic curve\n   */\n  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {\n    const ax = fromX - 2 * cpX + toX, ay = fromY - 2 * cpY + toY, bx = 2 * cpX - 2 * fromX, by = 2 * cpY - 2 * fromY, a = 4 * (ax * ax + ay * ay), b = 4 * (ax * bx + ay * by), c = bx * bx + by * by, s = 2 * Math.sqrt(a + b + c), a2 = Math.sqrt(a), a32 = 2 * a * a2, c2 = 2 * Math.sqrt(c), ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);\n  }\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   * @private\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Points to add segments to.\n   */\n  static curveTo(cpX, cpY, toX, toY, points) {\n    const fromX = points[points.length - 2], fromY = points[points.length - 1], n = curves._segmentsCount(\n      QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n    );\n    let xa = 0, ya = 0;\n    for (let i = 1; i <= n; ++i) {\n      const j = i / n;\n      xa = fromX + (cpX - fromX) * j, ya = fromY + (cpY - fromY) * j, points.push(\n        xa + (cpX + (toX - cpX) * j - xa) * j,\n        ya + (cpY + (toY - cpY) * j - ya) * j\n      );\n    }\n  }\n}\n\n//# sourceMappingURL=QuadraticUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/index.mjs\n\n\n\n\n\n\n\n\n\n\nconst FILL_COMMANDS = {\n  [SHAPES.POLY]: buildPoly,\n  [SHAPES.CIRC]: buildCircle,\n  [SHAPES.ELIP]: buildCircle,\n  [SHAPES.RECT]: buildRectangle,\n  [SHAPES.RREC]: buildRoundedRectangle\n}, BATCH_POOL = [], DRAW_CALL_POOL = [];\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsData.mjs\nclass GraphicsData {\n  /**\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - the width of the line to draw\n   * @param lineStyle - the color of the line to draw\n   * @param matrix - Transform matrix\n   */\n  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    this.points = [], this.holes = [], this.shape = shape, this.lineStyle = lineStyle, this.fillStyle = fillStyle, this.matrix = matrix, this.type = shape.type;\n  }\n  /**\n   * Creates a new GraphicsData object with the same values as this one.\n   * @returns - Cloned GraphicsData object\n   */\n  clone() {\n    return new GraphicsData(\n      this.shape,\n      this.fillStyle,\n      this.lineStyle,\n      this.matrix\n    );\n  }\n  /** Destroys the Graphics data. */\n  destroy() {\n    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;\n  }\n}\n\n//# sourceMappingURL=GraphicsData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs\nclass BatchPart {\n  constructor() {\n    this.reset();\n  }\n  /**\n   * Begin batch part.\n   * @param style\n   * @param startIndex\n   * @param attribStart\n   */\n  begin(style, startIndex, attribStart) {\n    this.reset(), this.style = style, this.start = startIndex, this.attribStart = attribStart;\n  }\n  /**\n   * End batch part.\n   * @param endIndex\n   * @param endAttrib\n   */\n  end(endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart, this.size = endIndex - this.start;\n  }\n  reset() {\n    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;\n  }\n}\n\n//# sourceMappingURL=BatchPart.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs\n\n\n\n\n\n\n\nconst tmpPoint = new Point(), _GraphicsGeometry = class _GraphicsGeometry2 extends BatchGeometry {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor() {\n    super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new Bounds(), this.boundsDirty = -1;\n  }\n  /**\n   * Get the current bounds of the graphic geometry.\n   *\n   * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.\n   * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered\n   * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}\n   * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.\n   * @readonly\n   */\n  get bounds() {\n    return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n  }\n  /** Call if you changed graphicsData manually. Empties all batch buffers. */\n  invalidate() {\n    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n    for (let i = 0; i < this.drawCalls.length; i++)\n      this.drawCalls[i].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i]);\n    this.drawCalls.length = 0;\n    for (let i = 0; i < this.batches.length; i++) {\n      const batchPart = this.batches[i];\n      batchPart.reset(), BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  }\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   * @returns - This GraphicsGeometry object. Good for chaining method calls\n   */\n  clear() {\n    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n  }\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - Defines style of the fill.\n   * @param lineStyle - Defines style of the lines.\n   * @param matrix - Transform applied to the points of the shape.\n   * @returns - Returns geometry for chaining.\n   */\n  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    return this.graphicsData.push(data), this.dirty++, this;\n  }\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param matrix - Transform applied to the points of the shape.\n   * @returns - Returns geometry for chaining.\n   */\n  drawHole(shape, matrix = null) {\n    if (!this.graphicsData.length)\n      return null;\n    const data = new GraphicsData(shape, null, null, matrix), lastShape = this.graphicsData[this.graphicsData.length - 1];\n    return data.lineStyle = lastShape.lineStyle, lastShape.holes.push(data), this.dirty++, this;\n  }\n  /** Destroys the GraphicsGeometry object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.graphicsData.length; ++i)\n      this.graphicsData[i].destroy();\n    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it\'s contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    const graphicsData = this.graphicsData;\n    for (let i = 0; i < graphicsData.length; ++i) {\n      const data = graphicsData[i];\n      if (data.fillStyle.visible && data.shape && (data.matrix ? data.matrix.applyInverse(point, tmpPoint) : tmpPoint.copyFrom(point), data.shape.contains(tmpPoint.x, tmpPoint.y))) {\n        let hitHole = !1;\n        if (data.holes) {\n          for (let i2 = 0; i2 < data.holes.length; i2++)\n            if (data.holes[i2].shape.contains(tmpPoint.x, tmpPoint.y)) {\n              hitHole = !0;\n              break;\n            }\n        }\n        if (!hitHole)\n          return !0;\n      }\n    }\n    return !1;\n  }\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   */\n  updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = !0;\n      return;\n    }\n    if (!this.validateBatching())\n      return;\n    this.cacheDirty = this.dirty;\n    const uvs = this.uvs, graphicsData = this.graphicsData;\n    let batchPart = null, currentStyle = null;\n    this.batches.length > 0 && (batchPart = this.batches[this.batches.length - 1], currentStyle = batchPart.style);\n    for (let i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      const data = graphicsData[i], fillStyle = data.fillStyle, lineStyle = data.lineStyle;\n      FILL_COMMANDS[data.type].build(data), data.matrix && this.transformPoints(data.points, data.matrix), (fillStyle.visible || lineStyle.visible) && this.processHoles(data.holes);\n      for (let j = 0; j < 2; j++) {\n        const style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible)\n          continue;\n        const nextTexture = style.texture.baseTexture, index2 = this.indices.length, attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = lib_WRAP_MODES.REPEAT, j === 0 ? this.processFill(data) : this.processLine(data);\n        const size = this.points.length / 2 - attribIndex;\n        size !== 0 && (batchPart && !this._compareStyles(currentStyle, style) && (batchPart.end(index2, attribIndex), batchPart = null), batchPart || (batchPart = BATCH_POOL.pop() || new BatchPart(), batchPart.begin(style, index2, attribIndex), this.batches.push(batchPart), currentStyle = style), this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix));\n      }\n    }\n    const index = this.indices.length, attrib = this.points.length / 2;\n    if (batchPart && batchPart.end(index, attrib), this.batches.length === 0) {\n      this.batchable = !0;\n      return;\n    }\n    const need32 = attrib > 65535;\n    this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n  }\n  /**\n   * Affinity check\n   * @param styleA\n   * @param styleB\n   */\n  _compareStyles(styleA, styleB) {\n    return !(!styleA || !styleB || styleA.texture.baseTexture !== styleB.texture.baseTexture || styleA.color + styleA.alpha !== styleB.color + styleB.alpha || !!styleA.native != !!styleB.native);\n  }\n  /** Test geometry for batching process. */\n  validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n      return !1;\n    for (let i = 0, l = this.graphicsData.length; i < l; i++) {\n      const data = this.graphicsData[i], fill = data.fillStyle, line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid || line && !line.texture.baseTexture.valid)\n        return !1;\n    }\n    return !0;\n  }\n  /** Offset the indices so that it works with the batcher. */\n  packBatches() {\n    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n    const batches = this.batches;\n    for (let i = 0, l = batches.length; i < l; i++) {\n      const batch = batches[i];\n      for (let j = 0; j < batch.size; j++) {\n        const index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  }\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   */\n  isBatchable() {\n    if (this.points.length > 65535 * 2)\n      return !1;\n    const batches = this.batches;\n    for (let i = 0; i < batches.length; i++)\n      if (batches[i].style.native)\n        return !1;\n    return this.points.length < _GraphicsGeometry2.BATCHABLE_SIZE * 2;\n  }\n  /** Converts intermediate batches data to drawCalls. */\n  buildDrawCalls() {\n    let TICK = ++BaseTexture._globalBatch;\n    for (let i = 0; i < this.drawCalls.length; i++)\n      this.drawCalls[i].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i]);\n    this.drawCalls.length = 0;\n    const colors = this.colors, textureIds = this.textureIds;\n    let currentGroup = DRAW_CALL_POOL.pop();\n    currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), currentGroup.texArray.count = 0, currentGroup.start = 0, currentGroup.size = 0, currentGroup.type = DRAW_MODES.TRIANGLES;\n    let textureCount = 0, currentTexture = null, textureId = 0, native = !1, drawMode = DRAW_MODES.TRIANGLES, index = 0;\n    this.drawCalls.push(currentGroup);\n    for (let i = 0; i < this.batches.length; i++) {\n      const data = this.batches[i], maxTextures = 8, style = data.style, nextTexture = style.texture.baseTexture;\n      native !== !!style.native && (native = !!style.native, drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = maxTextures, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture, nextTexture._batchEnabled !== TICK && (textureCount === maxTextures && (TICK++, textureCount = 0, currentGroup.size > 0 && (currentGroup = DRAW_CALL_POOL.pop(), currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), this.drawCalls.push(currentGroup)), currentGroup.start = index, currentGroup.size = 0, currentGroup.texArray.count = 0, currentGroup.type = drawMode), nextTexture.touched = 1, nextTexture._batchEnabled = TICK, nextTexture._batchLocation = textureCount, nextTexture.wrapMode = lib_WRAP_MODES.REPEAT, currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture, textureCount++)), currentGroup.size += data.size, index += data.size, textureId = nextTexture._batchLocation, this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart), this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK, this.packAttributes();\n  }\n  /** Packs attributes to single buffer. */\n  packAttributes() {\n    const verts = this.points, uvs = this.uvs, colors = this.colors, textureIds = this.textureIds, glPoints = new ArrayBuffer(verts.length * 3 * 4), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints);\n    let p = 0;\n    for (let i = 0; i < verts.length / 2; i++)\n      f32[p++] = verts[i * 2], f32[p++] = verts[i * 2 + 1], f32[p++] = uvs[i * 2], f32[p++] = uvs[i * 2 + 1], u32[p++] = colors[i], f32[p++] = textureIds[i];\n    this._buffer.update(glPoints), this._indexBuffer.update(this.indicesUint16);\n  }\n  /**\n   * Process fill part of Graphics.\n   * @param data\n   */\n  processFill(data) {\n    data.holes.length ? buildPoly.triangulate(data, this) : FILL_COMMANDS[data.type].triangulate(data, this);\n  }\n  /**\n   * Process line part of Graphics.\n   * @param data\n   */\n  processLine(data) {\n    buildLine(data, this);\n    for (let i = 0; i < data.holes.length; i++)\n      buildLine(data.holes[i], this);\n  }\n  /**\n   * Process the holes data.\n   * @param holes\n   */\n  processHoles(holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      FILL_COMMANDS[hole.type].build(hole), hole.matrix && this.transformPoints(hole.points, hole.matrix);\n    }\n  }\n  /** Update the local bounds of the object. Expensive to use performance-wise. */\n  calculateBounds() {\n    const bounds = this._bounds;\n    bounds.clear(), bounds.addVertexData(this.points, 0, this.points.length), bounds.pad(this.boundsPadding, this.boundsPadding);\n  }\n  /**\n   * Transform points using matrix.\n   * @param points - Points to transform\n   * @param matrix - Transform matrix\n   */\n  transformPoints(points, matrix) {\n    for (let i = 0; i < points.length / 2; i++) {\n      const x = points[i * 2], y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx, points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  }\n  /**\n   * Add colors.\n   * @param colors - List of colors to add to\n   * @param color - Color to add\n   * @param alpha - Alpha to use\n   * @param size - Number of colors to add\n   * @param offset\n   */\n  addColors(colors, color, alpha, size, offset = 0) {\n    const bgr = Color_Color.shared.setValue(color).toLittleEndianNumber(), result = Color_Color.shared.setValue(bgr).toPremultiplied(alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (let i = 0; i < size; i++)\n      colors[offset + i] = result;\n  }\n  /**\n   * Add texture id that the shader/fragment wants to use.\n   * @param textureIds\n   * @param id\n   * @param size\n   * @param offset\n   */\n  addTextureIds(textureIds, id, size, offset = 0) {\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (let i = 0; i < size; i++)\n      textureIds[offset + i] = id;\n  }\n  /**\n   * Generates the UVs for a shape.\n   * @param verts - Vertices\n   * @param uvs - UVs\n   * @param texture - Reference to Texture\n   * @param start - Index buffer start index.\n   * @param size - The size/length for index buffer.\n   * @param matrix - Optional transform for all points.\n   */\n  addUvs(verts, uvs, texture, start, size, matrix = null) {\n    let index = 0;\n    const uvsStart = uvs.length, frame = texture.frame;\n    for (; index < size; ) {\n      let x = verts[(start + index) * 2], y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        const nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty, x = nx;\n      }\n      index++, uvs.push(x / frame.width, y / frame.height);\n    }\n    const baseTexture = texture.baseTexture;\n    (frame.width < baseTexture.width || frame.height < baseTexture.height) && this.adjustUvs(uvs, texture, uvsStart, size);\n  }\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   * @param uvs - array\n   * @param texture - region\n   * @param start - starting index for uvs\n   * @param size - how many points to adjust\n   */\n  adjustUvs(uvs, texture, start, size) {\n    const baseTexture = texture.baseTexture, eps = 1e-6, finish = start + size * 2, frame = texture.frame, scaleX = frame.width / baseTexture.width, scaleY = frame.height / baseTexture.height;\n    let offsetX = frame.x / frame.width, offsetY = frame.y / frame.height, minX = Math.floor(uvs[start] + eps), minY = Math.floor(uvs[start + 1] + eps);\n    for (let i = start + 2; i < finish; i += 2)\n      minX = Math.min(minX, Math.floor(uvs[i] + eps)), minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    offsetX -= minX, offsetY -= minY;\n    for (let i = start; i < finish; i += 2)\n      uvs[i] = (uvs[i] + offsetX) * scaleX, uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n  }\n};\n_GraphicsGeometry.BATCHABLE_SIZE = 100;\nlet GraphicsGeometry = _GraphicsGeometry;\n\n//# sourceMappingURL=GraphicsGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs\n\nclass FillStyle {\n  constructor() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture_Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();\n  }\n  /** Clones the object */\n  clone() {\n    const obj = new FillStyle();\n    return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj;\n  }\n  /** Reset */\n  reset() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture_Texture.WHITE, this.matrix = null, this.visible = !1;\n  }\n  /** Destroy and don\'t use after this. */\n  destroy() {\n    this.texture = null, this.matrix = null;\n  }\n}\n\n//# sourceMappingURL=FillStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs\n\n\nclass LineStyle extends FillStyle {\n  constructor() {\n    super(...arguments), this.width = 0, this.alignment = 0.5, this.native = !1, this.cap = LINE_CAP.BUTT, this.join = LINE_JOIN.MITER, this.miterLimit = 10;\n  }\n  /** Clones the object. */\n  clone() {\n    const obj = new LineStyle();\n    return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj.width = this.width, obj.alignment = this.alignment, obj.native = this.native, obj.cap = this.cap, obj.join = this.join, obj.miterLimit = this.miterLimit, obj;\n  }\n  /** Reset the line style to default. */\n  reset() {\n    super.reset(), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1, this.cap = LINE_CAP.BUTT, this.join = LINE_JOIN.MITER, this.miterLimit = 10;\n  }\n}\n\n//# sourceMappingURL=LineStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/Graphics.mjs\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_SHADERS = {}, _Graphics = class _Graphics2 extends Container_Container {\n  /**\n   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n   */\n  constructor(geometry = null) {\n    super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new FillStyle(), this._lineStyle = new LineStyle(), this._matrix = null, this._holeMode = !1, this.state = State.for2d(), this._geometry = geometry || new GraphicsGeometry(), this._geometry.refCount++, this._transformID = -1, this._tintColor = new Color_Color(16777215), this.blendMode = lib_BLEND_MODES.NORMAL;\n  }\n  /**\n   * Includes vertex positions, face indices, normals, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n   * @readonly\n   */\n  get geometry() {\n    return this._geometry;\n  }\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n   * @returns - A clone of the graphics object\n   */\n  clone() {\n    return this.finishPoly(), new _Graphics2(this._geometry);\n  }\n  /**\n   * The blend mode to be applied to the graphic shape. Apply a value of\n   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n   * primitive in the GraphicsGeometry list is rendered sequentially, modes\n   * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n   * be applied per-primitive.\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  /**\n   * The tint applied to each graphic shape. This is a hex value. A value of\n   * 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n  }\n  /**\n   * The current fill style.\n   * @readonly\n   */\n  get fill() {\n    return this._fillStyle;\n  }\n  /**\n   * The current line style.\n   * @readonly\n   */\n  get line() {\n    return this._lineStyle;\n  }\n  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = !1) {\n    return typeof options == "number" && (options = { width: options, color, alpha, alignment, native }), this.lineTextureStyle(options);\n  }\n  /**\n   * Like line style but support texture for line fill.\n   * @param [options] - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   *        WebGL only.\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  lineTextureStyle(options) {\n    const defaultLineStyleOptions = {\n      width: 0,\n      texture: Texture_Texture.WHITE,\n      color: options?.texture ? 16777215 : 0,\n      matrix: null,\n      alignment: 0.5,\n      native: !1,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    };\n    options = Object.assign(defaultLineStyleOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();\n    const visible = options.width > 0 && options.alpha > 0;\n    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._lineStyle, { visible }, options)) : this._lineStyle.reset(), this;\n  }\n  /**\n   * Start a polygon object internally.\n   * @protected\n   */\n  startPoly() {\n    if (this.currentPath) {\n      const points = this.currentPath.points, len = this.currentPath.points.length;\n      len > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(points[len - 2], points[len - 1]));\n    } else\n      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;\n  }\n  /**\n   * Finish the polygon object.\n   * @protected\n   */\n  finishPoly() {\n    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n  }\n  /**\n   * Moves the current drawing position to x, y.\n   * @param x - the X coordinate to move to\n   * @param y - the Y coordinate to move to\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  moveTo(x, y) {\n    return this.startPoly(), this.currentPath.points[0] = x, this.currentPath.points[1] = y, this;\n  }\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   * @param x - the X coordinate to draw to\n   * @param y - the Y coordinate to draw to\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  lineTo(x, y) {\n    this.currentPath || this.moveTo(0, 0);\n    const points = this.currentPath.points, fromX = points[points.length - 2], fromY = points[points.length - 1];\n    return (fromX !== x || fromY !== y) && points.push(x, y), this;\n  }\n  /**\n   * Initialize the curve\n   * @param x\n   * @param y\n   */\n  _initCurve(x = 0, y = 0) {\n    this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [x, y]) : this.moveTo(x, y);\n  }\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._initCurve();\n    const points = this.currentPath.points;\n    return points.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this;\n  }\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @returns This Graphics object. Good for chaining method calls\n   */\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    return this._initCurve(), BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this;\n  }\n  /**\n   * The `arcTo` method creates an arc/curve between two tangents on the canvas.\n   * The first tangent is from the start point to the first control point,\n   * and the second tangent is from the first control point to the second control point.\n   * Note that the second control point is not necessarily the end point of the arc.\n   *\n   * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!\n   * @param x1 - The x-coordinate of the first control point of the arc\n   * @param y1 - The y-coordinate of the first control point of the arc\n   * @param x2 - The x-coordinate of the second control point of the arc\n   * @param y2 - The y-coordinate of the second control point of the arc\n   * @param radius - The radius of the arc\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    const points = this.currentPath.points, result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;\n      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  }\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o\'clock position\n   *  of the arc\'s circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = !1) {\n    if (startAngle === endAngle)\n      return this;\n    if (!anticlockwise && endAngle <= startAngle ? endAngle += PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += PI_2), endAngle - startAngle === 0)\n      return this;\n    const startX = cx + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius, eps = this._geometry.closePointEps;\n    let points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      const xDiff = Math.abs(points[points.length - 2] - startX), yDiff = Math.abs(points[points.length - 1] - startY);\n      xDiff < eps && yDiff < eps || points.push(startX, startY);\n    } else\n      this.moveTo(startX, startY), points = this.currentPath.points;\n    return ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points), this;\n  }\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   * @param {PIXI.ColorSource} color - the color of the fill\n   * @param alpha - the alpha of the fill, will override the color\'s alpha\n   * @returns - This Graphics object. Suitable for chaining method calls\n   */\n  beginFill(color = 0, alpha) {\n    return this.beginTextureFill({ texture: Texture_Texture.WHITE, color, alpha });\n  }\n  /**\n   * Normalize the color input from options for line style or fill\n   * @param {PIXI.IFillStyleOptions} options - Fill style object.\n   */\n  normalizeColor(options) {\n    const temp = Color_Color.shared.setValue(options.color ?? 0);\n    options.color = temp.toNumber(), options.alpha ?? (options.alpha = temp.alpha);\n  }\n  /**\n   * Begin the texture fill.\n   * Note: The wrap mode of the texture is forced to REPEAT on render.\n   * @param options - Fill style object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {PIXI.ColorSource} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha] - Alpha of fill, overrides the color\'s alpha\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  beginTextureFill(options) {\n    const defaultOptions = {\n      texture: Texture_Texture.WHITE,\n      color: 16777215,\n      matrix: null\n    };\n    options = Object.assign(defaultOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();\n    const visible = options.alpha > 0;\n    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._fillStyle, { visible }, options)) : this._fillStyle.reset(), this;\n  }\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  endFill() {\n    return this.finishPoly(), this._fillStyle.reset(), this;\n  }\n  /**\n   * Draws a rectangle shape.\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawRect(x, y, width, height) {\n    return this.drawShape(new Rectangle_Rectangle(x, y, width, height));\n  }\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @param radius - Radius of the rectangle corners\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawRoundedRect(x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  }\n  /**\n   * Draws a circle.\n   * @param x - The X coordinate of the center of the circle\n   * @param y - The Y coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawCircle(x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  }\n  /**\n   * Draws an ellipse.\n   * @param x - The X coordinate of the center of the ellipse\n   * @param y - The Y coordinate of the center of the ellipse\n   * @param width - The half width of the ellipse\n   * @param height - The half height of the ellipse\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawEllipse(x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  }\n  /**\n   * Draws a polygon using the given path.\n   * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawPolygon(...path) {\n    let points, closeStroke = !0;\n    const poly = path[0];\n    poly.points ? (closeStroke = poly.closeStroke, points = poly.points) : Array.isArray(path[0]) ? points = path[0] : points = path;\n    const shape = new Polygon(points);\n    return shape.closeStroke = closeStroke, this.drawShape(shape), this;\n  }\n  /**\n   * Draw any shape.\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  drawShape(shape) {\n    return this._holeMode ? this._geometry.drawHole(shape, this._matrix) : this._geometry.drawShape(\n      shape,\n      this._fillStyle.clone(),\n      this._lineStyle.clone(),\n      this._matrix\n    ), this;\n  }\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   * @returns - This Graphics object. Good for chaining method calls\n   */\n  clear() {\n    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n  }\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   * @returns - True if only 1 rect.\n   */\n  isFastRect() {\n    const data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  _render(renderer) {\n    this.finishPoly();\n    const geometry = this._geometry;\n    geometry.updateBatches(), geometry.batchable ? (this.batchDirty !== geometry.batchDirty && this._populateBatches(), this._renderBatched(renderer)) : (renderer.batch.flush(), this._renderDirect(renderer));\n  }\n  /** Populating batches for rendering. */\n  _populateBatches() {\n    const geometry = this._geometry, blendMode = this.blendMode, len = geometry.batches.length;\n    this.batchTint = -1, this._transformID = -1, this.batchDirty = geometry.batchDirty, this.batches.length = len, this.vertexData = new Float32Array(geometry.points);\n    for (let i = 0; i < len; i++) {\n      const gI = geometry.batches[i], color = gI.style.color, vertexData = new Float32Array(\n        this.vertexData.buffer,\n        gI.attribStart * 4 * 2,\n        gI.attribSize * 2\n      ), uvs = new Float32Array(\n        geometry.uvsFloat32.buffer,\n        gI.attribStart * 4 * 2,\n        gI.attribSize * 2\n      ), indices = new Uint16Array(\n        geometry.indicesUint16.buffer,\n        gI.start * 2,\n        gI.size\n      ), batch = {\n        vertexData,\n        blendMode,\n        indices,\n        uvs,\n        _batchRGB: Color_Color.shared.setValue(color).toRgbArray(),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  }\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   * @param renderer - The renderer\n   */\n  _renderBatched(renderer) {\n    if (this.batches.length) {\n      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n      for (let i = 0, l = this.batches.length; i < l; i++) {\n        const batch = this.batches[i];\n        batch.worldAlpha = this.worldAlpha * batch.alpha, renderer.plugins[this.pluginName].render(batch);\n      }\n    }\n  }\n  /**\n   * Renders the graphics direct\n   * @param renderer - The renderer\n   */\n  _renderDirect(renderer) {\n    const shader = this._resolveDirectShader(renderer), geometry = this._geometry, worldAlpha = this.worldAlpha, uniforms = shader.uniforms, drawCalls = geometry.drawCalls;\n    uniforms.translationMatrix = this.transform.worldTransform, Color_Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint), renderer.shader.bind(shader), renderer.geometry.bind(geometry, shader), renderer.state.set(this.state);\n    for (let i = 0, l = drawCalls.length; i < l; i++)\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n  }\n  /**\n   * Renders specific DrawCall\n   * @param renderer\n   * @param drawCall\n   */\n  _renderDrawCallDirect(renderer, drawCall) {\n    const { texArray, type, size, start } = drawCall, groupTextureCount = texArray.count;\n    for (let j = 0; j < groupTextureCount; j++)\n      renderer.texture.bind(texArray.elements[j], j);\n    renderer.geometry.draw(type, size, start);\n  }\n  /**\n   * Resolves shader for direct rendering\n   * @param renderer - The renderer\n   */\n  _resolveDirectShader(renderer) {\n    let shader = this.shader;\n    const pluginName = this.pluginName;\n    if (!shader) {\n      if (!DEFAULT_SHADERS[pluginName]) {\n        const { maxTextures } = renderer.plugins[pluginName], sampleValues = new Int32Array(maxTextures);\n        for (let i = 0; i < maxTextures; i++)\n          sampleValues[i] = i;\n        const uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: sampleValues }, !0)\n        }, program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  }\n  /**\n   * Retrieves the bounds of the graphic shape as a rectangle object.\n   * @see PIXI.GraphicsGeometry#bounds\n   */\n  _calculateBounds() {\n    this.finishPoly();\n    const geometry = this._geometry;\n    if (!geometry.graphicsData.length)\n      return;\n    const { minX, minY, maxX, maxY } = geometry.bounds;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  /**\n   * Tests if a point is inside this graphics object\n   * @param point - the point to test\n   * @returns - the result of the test\n   */\n  containsPoint(point) {\n    return this.worldTransform.applyInverse(point, _Graphics2._TEMP_POINT), this._geometry.containsPoint(_Graphics2._TEMP_POINT);\n  }\n  /** Recalculate the tint by applying tint to batches using Graphics tint. */\n  calculateTints() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this._tintColor.toNumber();\n      for (let i = 0; i < this.batches.length; i++) {\n        const batch = this.batches[i];\n        batch._tintRGB = Color_Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();\n      }\n    }\n  }\n  /** If there\'s a transform update or a change to the shape of the geometry, recalculate the vertices. */\n  calculateVertices() {\n    const wtID = this.transform._worldID;\n    if (this._transformID === wtID)\n      return;\n    this._transformID = wtID;\n    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, data = this._geometry.points, vertexData = this.vertexData;\n    let count = 0;\n    for (let i = 0; i < data.length; i += 2) {\n      const x = data[i], y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx, vertexData[count++] = d * y + b * x + ty;\n    }\n  }\n  /**\n   * Closes the current path.\n   * @returns - Returns itself.\n   */\n  closePath() {\n    const currentPath = this.currentPath;\n    return currentPath && (currentPath.closeStroke = !0, this.finishPoly()), this;\n  }\n  /**\n   * Apply a matrix to the positional data.\n   * @param matrix - Matrix to use for transform current shape.\n   * @returns - Returns itself.\n   */\n  setMatrix(matrix) {\n    return this._matrix = matrix, this;\n  }\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   * @returns - Returns itself.\n   */\n  beginHole() {\n    return this.finishPoly(), this._holeMode = !0, this;\n  }\n  /**\n   * End adding holes to the last draw shape.\n   * @returns - Returns itself.\n   */\n  endHole() {\n    return this.finishPoly(), this._holeMode = !1, this;\n  }\n  /**\n   * Destroys the Graphics object.\n   * @param options - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  destroy(options) {\n    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(options);\n  }\n};\n_Graphics.curves = curves, /**\n* Temporary point to use for containsPoint.\n* @private\n*/\n_Graphics._TEMP_POINT = new Point();\nlet Graphics = _Graphics;\n\n//# sourceMappingURL=Graphics.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst graphicsUtils = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  buildLine: buildLine,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL\n};\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs\nclass MeshBatchUvs {\n  /**\n   * @param uvBuffer - Buffer with normalized uv\'s\n   * @param uvMatrix - Material UV matrix\n   */\n  constructor(uvBuffer, uvMatrix) {\n    this.uvBuffer = uvBuffer, this.uvMatrix = uvMatrix, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n  }\n  /**\n   * Updates\n   * @param forceUpdate - force the update\n   */\n  update(forceUpdate) {\n    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)\n      return;\n    this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n    const data = this.uvBuffer.data;\n    (!this.data || this.data.length !== data.length) && (this.data = new Float32Array(data.length)), this.uvMatrix.multiplyUvs(data, this.data), this._updateID++;\n  }\n}\n\n//# sourceMappingURL=MeshBatchUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/Mesh.mjs\n\n\n\nconst Mesh_tempPoint = new Point(), tempPolygon = new Polygon(), _Mesh = class _Mesh2 extends Container_Container {\n  /**\n   * @param geometry - The geometry the mesh will use.\n   * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n   * @param state - The state that the WebGL context is required to be in to render the mesh\n   *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n   * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n   */\n  constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {\n    super(), this.geometry = geometry, this.shader = shader, this.state = state || State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = settings.ROUND_PIXELS, this.batchUvs = null;\n  }\n  /**\n   * Includes vertex positions, face indices, normals, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh objects.\n   */\n  get geometry() {\n    return this._geometry;\n  }\n  set geometry(value) {\n    this._geometry !== value && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n  }\n  /**\n   * To change mesh uv\'s, change its uvBuffer data and increment its _updateID.\n   * @readonly\n   */\n  get uvBuffer() {\n    return this.geometry.buffers[1];\n  }\n  /**\n   * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n   * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n   * @readonly\n   */\n  get verticesBuffer() {\n    return this.geometry.buffers[0];\n  }\n  /** Alias for {@link PIXI.Mesh#shader}. */\n  set material(value) {\n    this.shader = value;\n  }\n  get material() {\n    return this.shader;\n  }\n  /**\n   * The blend mode to be applied to the Mesh. Apply a value of\n   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n   * @default PIXI.BLEND_MODES.NORMAL;\n   */\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n   * @default false\n   */\n  set roundPixels(value) {\n    this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  /**\n   * The multiply tint applied to the Mesh. This is a hex value. A value of\n   * `0xFFFFFF` will remove any tint effect.\n   *\n   * Null for non-MeshMaterial shaders\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return "tint" in this.shader ? this.shader.tint : null;\n  }\n  set tint(value) {\n    this.shader.tint = value;\n  }\n  /**\n   * The tint color as a RGB integer\n   * @ignore\n   */\n  get tintValue() {\n    return this.shader.tintValue;\n  }\n  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n  get texture() {\n    return "texture" in this.shader ? this.shader.texture : null;\n  }\n  set texture(value) {\n    this.shader.texture = value;\n  }\n  /**\n   * Standard renderer draw.\n   * @param renderer - Instance to renderer.\n   */\n  _render(renderer) {\n    const vertices = this.geometry.buffers[0].data;\n    this.shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh2.BATCHABLE_SIZE * 2 ? this._renderToBatch(renderer) : this._renderDefault(renderer);\n  }\n  /**\n   * Standard non-batching way of rendering.\n   * @param renderer - Instance to renderer.\n   */\n  _renderDefault(renderer) {\n    const shader = this.shader;\n    shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), renderer.shader.bind(shader), renderer.state.set(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }\n  /**\n   * Rendering by using the Batch system.\n   * @param renderer - Instance to renderer.\n   */\n  _renderToBatch(renderer) {\n    const geometry = this.geometry, shader = this.shader;\n    shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = shader._tintRGB, this._texture = shader.texture;\n    const pluginName = this.material.pluginName;\n    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this);\n  }\n  /** Updates vertexData field based on transform and vertices. */\n  calculateVertices() {\n    const verticesBuffer = this.geometry.buffers[0], vertices = verticesBuffer.data, vertexDirtyId = verticesBuffer._updateID;\n    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n      return;\n    this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));\n    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData;\n    for (let i = 0; i < vertexData.length / 2; i++) {\n      const x = vertices[i * 2], y = vertices[i * 2 + 1];\n      vertexData[i * 2] = a * x + c * y + tx, vertexData[i * 2 + 1] = b * x + d * y + ty;\n    }\n    if (this._roundPixels) {\n      const resolution = settings.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i)\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n    }\n    this.vertexDirty = vertexDirtyId;\n  }\n  /** Updates uv field based on from geometry uv\'s or batchUvs. */\n  calculateUvs() {\n    const geomUvs = this.geometry.buffers[1], shader = this.shader;\n    shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n  }\n  /**\n   * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n   * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n   */\n  _calculateBounds() {\n    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }\n  /**\n   * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n   * @param point - The point to test.\n   * @returns - The result of the test.\n   */\n  containsPoint(point) {\n    if (!this.getBounds().contains(point.x, point.y))\n      return !1;\n    this.worldTransform.applyInverse(point, Mesh_tempPoint);\n    const vertices = this.geometry.getBuffer("aVertexPosition").data, points = tempPolygon.points, indices = this.geometry.getIndex().data, len = indices.length, step = this.drawMode === 4 ? 3 : 1;\n    for (let i = 0; i + 2 < len; i += step) {\n      const ind0 = indices[i] * 2, ind1 = indices[i + 1] * 2, ind2 = indices[i + 2] * 2;\n      if (points[0] = vertices[ind0], points[1] = vertices[ind0 + 1], points[2] = vertices[ind1], points[3] = vertices[ind1 + 1], points[4] = vertices[ind2], points[5] = vertices[ind2 + 1], tempPolygon.contains(Mesh_tempPoint.x, Mesh_tempPoint.y))\n        return !0;\n    }\n    return !1;\n  }\n  destroy(options) {\n    super.destroy(options), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n  }\n};\n_Mesh.BATCHABLE_SIZE = 100;\nlet Mesh_Mesh = _Mesh;\n\n//# sourceMappingURL=Mesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshGeometry.mjs\n\nclass MeshGeometry_MeshGeometry extends Geometry {\n  /**\n   * @param {Float32Array|number[]} [vertices] - Positional data on geometry.\n   * @param {Float32Array|number[]} [uvs] - Texture UVs.\n   * @param {Uint16Array|number[]} [index] - IndexBuffer\n   */\n  constructor(vertices, uvs, index) {\n    super();\n    const verticesBuffer = new Buffer(vertices), uvsBuffer = new Buffer(uvs, !0), indexBuffer = new Buffer(index, !0, !0);\n    this.addAttribute("aVertexPosition", verticesBuffer, 2, !1, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, !1, TYPES.FLOAT).addIndex(indexBuffer), this._updateId = -1;\n  }\n  /**\n   * If the vertex position is updated.\n   * @readonly\n   * @private\n   */\n  get vertexDirtyId() {\n    return this.buffers[0]._updateID;\n  }\n}\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh.frag.mjs\nvar mesh_frag_fragment = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`;\n\n//# sourceMappingURL=mesh.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh.vert.mjs\nvar mesh_vert_vertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`;\n\n//# sourceMappingURL=mesh.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshMaterial.mjs\n\n\n\nclass MeshMaterial_MeshMaterial extends Shader {\n  /**\n   * @param uSampler - Texture that material uses to render.\n   * @param options - Additional options\n   * @param {number} [options.alpha=1] - Default alpha.\n   * @param {PIXI.ColorSource} [options.tint=0xFFFFFF] - Default tint.\n   * @param {string} [options.pluginName=\'batch\'] - Renderer plugin for batching.\n   * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.\n   * @param {object} [options.uniforms] - Custom uniforms.\n   */\n  constructor(uSampler, options) {\n    const uniforms = {\n      uSampler,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    options = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: "batch"\n    }, options), options.uniforms && Object.assign(uniforms, options.uniforms), super(options.program || Program.from(mesh_vert_vertex, mesh_frag_fragment), uniforms), this._colorDirty = !1, this.uvMatrix = new TextureMatrix_TextureMatrix(uSampler), this.batchable = options.program === void 0, this.pluginName = options.pluginName, this._tintColor = new Color_Color(options.tint), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0, this.alpha = options.alpha;\n  }\n  /** Reference to the texture being rendered. */\n  get texture() {\n    return this.uniforms.uSampler;\n  }\n  set texture(value) {\n    this.uniforms.uSampler !== value && (!this.uniforms.uSampler.baseTexture.alphaMode != !value.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = value, this.uvMatrix.texture = value);\n  }\n  /**\n   * This gets automatically set by the object using this.\n   * @default 1\n   */\n  set alpha(value) {\n    value !== this._alpha && (this._alpha = value, this._colorDirty = !0);\n  }\n  get alpha() {\n    return this._alpha;\n  }\n  /**\n   * Multiply tint for the material.\n   * @default 0xFFFFFF\n   */\n  set tint(value) {\n    value !== this.tint && (this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0);\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  /**\n   * Get the internal number from tint color\n   * @ignore\n   */\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link PIXI.MeshMaterial} objects. */\n  update() {\n    if (this._colorDirty) {\n      this._colorDirty = !1;\n      const applyToChannels = this.texture.baseTexture.alphaMode;\n      Color_Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);\n    }\n    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);\n  }\n}\n\n//# sourceMappingURL=MeshMaterial.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs\n\nclass PlaneGeometry_PlaneGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {\n  /**\n   * @param width - The width of the plane.\n   * @param height - The height of the plane.\n   * @param segWidth - Number of horizontal segments.\n   * @param segHeight - Number of vertical segments.\n   */\n  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {\n    super(), this.segWidth = segWidth, this.segHeight = segHeight, this.width = width, this.height = height, this.build();\n  }\n  /**\n   * Refreshes plane coordinates\n   * @private\n   */\n  build() {\n    const total = this.segWidth * this.segHeight, verts = [], uvs = [], indices = [], segmentsX = this.segWidth - 1, segmentsY = this.segHeight - 1, sizeX = this.width / segmentsX, sizeY = this.height / segmentsY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.segWidth, y = i / this.segWidth | 0;\n      verts.push(x * sizeX, y * sizeY), uvs.push(x / segmentsX, y / segmentsY);\n    }\n    const totalSub = segmentsX * segmentsY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % segmentsX, ypos = i / segmentsX | 0, value = ypos * this.segWidth + xpos, value2 = ypos * this.segWidth + xpos + 1, value3 = (ypos + 1) * this.segWidth + xpos, value4 = (ypos + 1) * this.segWidth + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts), this.buffers[1].data = new Float32Array(uvs), this.indexBuffer.data = new Uint16Array(indices), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();\n  }\n}\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs\n\nclass RopeGeometry_RopeGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {\n  /**\n   * @param width - The width (i.e., thickness) of the rope.\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   * @param textureScale - By default the rope texture will be stretched to match\n   *     rope length. If textureScale is positive this value will be treated as a scaling\n   *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n   *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,\n   *     then set textureScale=1 to keep the original texture pixel size.\n   *     In order to reduce alpha channel artifacts provide a larger texture and downsample -\n   *     i.e. set textureScale=0.5 to scale it down twice.\n   */\n  constructor(width = 200, points, textureScale = 0) {\n    super(\n      new Float32Array(points.length * 4),\n      new Float32Array(points.length * 4),\n      new Uint16Array((points.length - 1) * 6)\n    ), this.points = points, this._width = width, this.textureScale = textureScale, this.build();\n  }\n  /**\n   * The width (i.e., thickness) of the rope.\n   * @readonly\n   */\n  get width() {\n    return this._width;\n  }\n  /** Refreshes Rope indices and uvs */\n  build() {\n    const points = this.points;\n    if (!points)\n      return;\n    const vertexBuffer = this.getBuffer("aVertexPosition"), uvBuffer = this.getBuffer("aTextureCoord"), indexBuffer = this.getIndex();\n    if (points.length < 1)\n      return;\n    vertexBuffer.data.length / 4 !== points.length && (vertexBuffer.data = new Float32Array(points.length * 4), uvBuffer.data = new Float32Array(points.length * 4), indexBuffer.data = new Uint16Array((points.length - 1) * 6));\n    const uvs = uvBuffer.data, indices = indexBuffer.data;\n    uvs[0] = 0, uvs[1] = 0, uvs[2] = 0, uvs[3] = 1;\n    let amount = 0, prev = points[0];\n    const textureWidth = this._width * this.textureScale, total = points.length;\n    for (let i = 0; i < total; i++) {\n      const index = i * 4;\n      if (this.textureScale > 0) {\n        const dx = prev.x - points[i].x, dy = prev.y - points[i].y, distance = Math.sqrt(dx * dx + dy * dy);\n        prev = points[i], amount += distance / textureWidth;\n      } else\n        amount = i / (total - 1);\n      uvs[index] = amount, uvs[index + 1] = 0, uvs[index + 2] = amount, uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index, indices[indexCount++] = index + 1, indices[indexCount++] = index + 2, indices[indexCount++] = index + 2, indices[indexCount++] = index + 1, indices[indexCount++] = index + 3;\n    }\n    uvBuffer.update(), indexBuffer.update(), this.updateVertices();\n  }\n  /** refreshes vertices of Rope mesh */\n  updateVertices() {\n    const points = this.points;\n    if (points.length < 1)\n      return;\n    let lastPoint = points[0], nextPoint, perpX = 0, perpY = 0;\n    const vertices = this.buffers[0].data, total = points.length, halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n    for (let i = 0; i < total; i++) {\n      const point = points[i], index = i * 4;\n      i < points.length - 1 ? nextPoint = points[i + 1] : nextPoint = point, perpY = -(nextPoint.x - lastPoint.x), perpX = nextPoint.y - lastPoint.y;\n      let ratio = (1 - i / (total - 1)) * 10;\n      ratio > 1 && (ratio = 1);\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      perpLength < 1e-6 ? (perpX = 0, perpY = 0) : (perpX /= perpLength, perpY /= perpLength, perpX *= halfWidth, perpY *= halfWidth), vertices[index] = point.x + perpX, vertices[index + 1] = point.y + perpY, vertices[index + 2] = point.x - perpX, vertices[index + 3] = point.y - perpY, lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n  update() {\n    this.textureScale > 0 ? this.build() : this.updateVertices();\n  }\n}\n\n//# sourceMappingURL=RopeGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs\n\n\n\nclass SimplePlane_SimplePlane extends (/* unused pure expression or super */ null && (Mesh)) {\n  /**\n   * @param texture - The texture to use on the SimplePlane.\n   * @param verticesX - The number of vertices in the x-axis\n   * @param verticesY - The number of vertices in the y-axis\n   */\n  constructor(texture, verticesX, verticesY) {\n    const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY), meshMaterial = new MeshMaterial(Texture.WHITE);\n    super(planeGeometry, meshMaterial), this.texture = texture, this.autoResize = !0;\n  }\n  /**\n   * Method used for overrides, to do something in case texture frame was changed.\n   * Meshes based on plane can override it and change more details based on texture.\n   */\n  textureUpdated() {\n    this._textureID = this.shader.texture._updateID;\n    const geometry = this.geometry, { width, height } = this.shader.texture;\n    this.autoResize && (geometry.width !== width || geometry.height !== height) && (geometry.width = this.shader.texture.width, geometry.height = this.shader.texture.height, geometry.build());\n  }\n  set texture(value) {\n    this.shader.texture !== value && (this.shader.texture = value, this._textureID = -1, value.baseTexture.valid ? this.textureUpdated() : value.once("update", this.textureUpdated, this));\n  }\n  get texture() {\n    return this.shader.texture;\n  }\n  _render(renderer) {\n    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(renderer);\n  }\n  destroy(options) {\n    this.shader.texture.off("update", this.textureUpdated, this), super.destroy(options);\n  }\n}\n\n//# sourceMappingURL=SimplePlane.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs\n\n\nconst DEFAULT_BORDER_SIZE = 10;\nclass NineSlicePlane extends (/* unused pure expression or super */ null && (SimplePlane)) {\n  /**\n   * @param texture - The texture to use on the NineSlicePlane.\n   * @param {number} [leftWidth=10] - size of the left vertical bar (A)\n   * @param {number} [topHeight=10] - size of the top horizontal bar (C)\n   * @param {number} [rightWidth=10] - size of the right vertical bar (B)\n   * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)\n   */\n  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {\n    super(Texture.WHITE, 4, 4), this._origWidth = texture.orig.width, this._origHeight = texture.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE, this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE, this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE, this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE, this.texture = texture;\n  }\n  textureUpdated() {\n    this._textureID = this.shader.texture._updateID, this._refresh();\n  }\n  get vertices() {\n    return this.geometry.getBuffer("aVertexPosition").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer("aVertexPosition").data = value;\n  }\n  /** Updates the horizontal vertices. */\n  updateHorizontalVertices() {\n    const vertices = this.vertices, scale = this._getMinScale();\n    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale, vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale, vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n  }\n  /** Updates the vertical vertices. */\n  updateVerticalVertices() {\n    const vertices = this.vertices, scale = this._getMinScale();\n    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale, vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale, vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n  }\n  /**\n   * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.\n   * @returns Smaller number of vertical and horizontal scale.\n   */\n  _getMinScale() {\n    const w = this._leftWidth + this._rightWidth, scaleW = this._width > w ? 1 : this._width / w, h = this._topHeight + this._bottomHeight, scaleH = this._height > h ? 1 : this._height / h;\n    return Math.min(scaleW, scaleH);\n  }\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value, this._refresh();\n  }\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value, this._refresh();\n  }\n  /** The width of the left column. */\n  get leftWidth() {\n    return this._leftWidth;\n  }\n  set leftWidth(value) {\n    this._leftWidth = value, this._refresh();\n  }\n  /** The width of the right column. */\n  get rightWidth() {\n    return this._rightWidth;\n  }\n  set rightWidth(value) {\n    this._rightWidth = value, this._refresh();\n  }\n  /** The height of the top row. */\n  get topHeight() {\n    return this._topHeight;\n  }\n  set topHeight(value) {\n    this._topHeight = value, this._refresh();\n  }\n  /** The height of the bottom row. */\n  get bottomHeight() {\n    return this._bottomHeight;\n  }\n  set bottomHeight(value) {\n    this._bottomHeight = value, this._refresh();\n  }\n  /** Refreshes NineSlicePlane coords. All of them. */\n  _refresh() {\n    const texture = this.texture, uvs = this.geometry.buffers[1].data;\n    this._origWidth = texture.orig.width, this._origHeight = texture.orig.height;\n    const _uvw = 1 / this._origWidth, _uvh = 1 / this._origHeight;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0, uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0, uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1, uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1, uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth, uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth, uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight, uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();\n  }\n}\n\n//# sourceMappingURL=NineSlicePlane.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs\n\n\nclass SimpleMesh extends (/* unused pure expression or super */ null && (Mesh)) {\n  /**\n   * @param texture - The texture to use\n   * @param {Float32Array} [vertices] - if you want to specify the vertices\n   * @param {Float32Array} [uvs] - if you want to specify the uvs\n   * @param {Uint16Array} [indices] - if you want to specify the indices\n   * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts\n   */\n  constructor(texture = Texture.EMPTY, vertices, uvs, indices, drawMode) {\n    const geometry = new MeshGeometry(vertices, uvs, indices);\n    geometry.getBuffer("aVertexPosition").static = !1;\n    const meshMaterial = new MeshMaterial(texture);\n    super(geometry, meshMaterial, null, drawMode), this.autoUpdate = !0;\n  }\n  /**\n   * Collection of vertices data.\n   * @type {Float32Array}\n   */\n  get vertices() {\n    return this.geometry.getBuffer("aVertexPosition").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer("aVertexPosition").data = value;\n  }\n  _render(renderer) {\n    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(renderer);\n  }\n}\n\n//# sourceMappingURL=SimpleMesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs\n\n\n\nclass SimpleRope extends (/* unused pure expression or super */ null && (Mesh)) {\n  /**\n   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n   * @param texture - The texture to use on the rope.\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   * @param {number} textureScale - Optional. Positive values scale rope texture\n   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n   * and downsampling here. If set to zero, texture will be stretched instead.\n   */\n  constructor(texture, points, textureScale = 0) {\n    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale), meshMaterial = new MeshMaterial(texture);\n    textureScale > 0 && (texture.baseTexture.wrapMode = WRAP_MODES.REPEAT), super(ropeGeometry, meshMaterial), this.autoUpdate = !0;\n  }\n  _render(renderer) {\n    const geometry = this.geometry;\n    (this.autoUpdate || geometry._width !== this.shader.texture.height) && (geometry._width = this.shader.texture.height, geometry.update()), super._render(renderer);\n  }\n}\n\n//# sourceMappingURL=SimpleRope.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/index.mjs\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs\n\n\nclass ParticleContainer extends (/* unused pure expression or super */ null && (Container)) {\n  /**\n   * @param maxSize - The maximum number of particles that can be rendered by the container.\n   *  Affects size of allocated buffers.\n   * @param properties - The properties of children that should be uploaded to the gpu and applied.\n   * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n   *                  if sprite\'s ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n   * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n   * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n   * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n   * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n   * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n   * @param {boolean} [autoResize=false] - If true, container allocates more batches in case\n   *  there are more than `maxSize` particles.\n   */\n  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = !1) {\n    super();\n    const maxBatchSize = 16384;\n    batchSize > maxBatchSize && (batchSize = maxBatchSize), this._properties = [!1, !0, !1, !1, !1], this._maxSize = maxSize, this._batchSize = batchSize, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = BLEND_MODES.NORMAL, this.autoResize = autoResize, this.roundPixels = !0, this.baseTexture = null, this.setProperties(properties), this._tintColor = new Color(0), this.tintRgb = new Float32Array(3), this.tint = 16777215;\n  }\n  /**\n   * Sets the private properties array to dynamic / static based on the passed properties object\n   * @param properties - The properties to be uploaded\n   */\n  setProperties(properties) {\n    properties && (this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0], this._properties[1] = "position" in properties ? !!properties.position : this._properties[1], this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2], this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3], this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4]);\n  }\n  updateTransform() {\n    this.displayObjectUpdateTransform();\n  }\n  /**\n   * The tint applied to the container. This is a hex value.\n   * A value of 0xFFFFFF will remove any tint effect.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value), this._tintColor.toRgbArray(this.tintRgb);\n  }\n  /**\n   * Renders the container using the WebGL renderer.\n   * @param renderer - The WebGL renderer.\n   */\n  render(renderer) {\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))), renderer.batch.setObjectRenderer(renderer.plugins.particle), renderer.plugins.particle.render(this));\n  }\n  /**\n   * Set the flag that static data should be updated to true\n   * @param smallestChildIndex - The smallest child index.\n   */\n  onChildrenChange(smallestChildIndex) {\n    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    for (; this._bufferUpdateIDs.length < bufferIndex; )\n      this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  }\n  dispose() {\n    if (this._buffers) {\n      for (let i = 0; i < this._buffers.length; ++i)\n        this._buffers[i].destroy();\n      this._buffers = null;\n    }\n  }\n  /**\n   * Destroys the container\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  destroy(options) {\n    super.destroy(options), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }\n}\n\n//# sourceMappingURL=ParticleContainer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs\n\nclass ParticleBuffer {\n  /**\n   * @param {object} properties - The properties to upload.\n   * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.\n   * @param {number} size - The size of the batch.\n   */\n  constructor(properties, dynamicPropertyFlags, size) {\n    this.geometry = new Geometry(), this.indexBuffer = null, this.size = size, this.dynamicProperties = [], this.staticProperties = [];\n    for (let i = 0; i < properties.length; ++i) {\n      let property = properties[i];\n      property = {\n        attributeName: property.attributeName,\n        size: property.size,\n        uploadFunction: property.uploadFunction,\n        type: property.type || TYPES.FLOAT,\n        offset: property.offset\n      }, dynamicPropertyFlags[i] ? this.dynamicProperties.push(property) : this.staticProperties.push(property);\n    }\n    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  initBuffers() {\n    const geometry = this.geometry;\n    let dynamicOffset = 0;\n    this.indexBuffer = new Buffer(createIndicesForQuads(this.size), !0, !0), geometry.addIndex(this.indexBuffer), this.dynamicStride = 0;\n    for (let i = 0; i < this.dynamicProperties.length; ++i) {\n      const property = this.dynamicProperties[i];\n      property.offset = dynamicOffset, dynamicOffset += property.size, this.dynamicStride += property.size;\n    }\n    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(dynBuffer), this.dynamicDataUint32 = new Uint32Array(dynBuffer), this.dynamicBuffer = new Buffer(this.dynamicData, !1, !1);\n    let staticOffset = 0;\n    this.staticStride = 0;\n    for (let i = 0; i < this.staticProperties.length; ++i) {\n      const property = this.staticProperties[i];\n      property.offset = staticOffset, staticOffset += property.size, this.staticStride += property.size;\n    }\n    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(statBuffer), this.staticDataUint32 = new Uint32Array(statBuffer), this.staticBuffer = new Buffer(this.staticData, !0, !1);\n    for (let i = 0; i < this.dynamicProperties.length; ++i) {\n      const property = this.dynamicProperties[i];\n      geometry.addAttribute(\n        property.attributeName,\n        this.dynamicBuffer,\n        0,\n        property.type === TYPES.UNSIGNED_BYTE,\n        property.type,\n        this.dynamicStride * 4,\n        property.offset * 4\n      );\n    }\n    for (let i = 0; i < this.staticProperties.length; ++i) {\n      const property = this.staticProperties[i];\n      geometry.addAttribute(\n        property.attributeName,\n        this.staticBuffer,\n        0,\n        property.type === TYPES.UNSIGNED_BYTE,\n        property.type,\n        this.staticStride * 4,\n        property.offset * 4\n      );\n    }\n  }\n  /**\n   * Uploads the dynamic properties.\n   * @param children - The children to upload.\n   * @param startIndex - The index to start at.\n   * @param amount - The number to upload.\n   */\n  uploadDynamic(children, startIndex, amount) {\n    for (let i = 0; i < this.dynamicProperties.length; i++) {\n      const property = this.dynamicProperties[i];\n      property.uploadFunction(\n        children,\n        startIndex,\n        amount,\n        property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,\n        this.dynamicStride,\n        property.offset\n      );\n    }\n    this.dynamicBuffer._updateID++;\n  }\n  /**\n   * Uploads the static properties.\n   * @param children - The children to upload.\n   * @param startIndex - The index to start at.\n   * @param amount - The number to upload.\n   */\n  uploadStatic(children, startIndex, amount) {\n    for (let i = 0; i < this.staticProperties.length; i++) {\n      const property = this.staticProperties[i];\n      property.uploadFunction(\n        children,\n        startIndex,\n        amount,\n        property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,\n        this.staticStride,\n        property.offset\n      );\n    }\n    this.staticBuffer._updateID++;\n  }\n  /** Destroys the ParticleBuffer. */\n  destroy() {\n    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();\n  }\n}\n\n//# sourceMappingURL=ParticleBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles.frag.mjs\nvar particles_frag_fragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}`;\n\n//# sourceMappingURL=particles.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles.vert.mjs\nvar particles_vert_vertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n`;\n\n//# sourceMappingURL=particles.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs\n\n\n\n\nclass ParticleRenderer extends ObjectRenderer {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   */\n  constructor(renderer) {\n    super(renderer), this.shader = null, this.properties = null, this.tempMatrix = new Matrix(), this.properties = [\n      // verticesData\n      {\n        attributeName: "aVertexPosition",\n        size: 2,\n        uploadFunction: this.uploadVertices,\n        offset: 0\n      },\n      // positionData\n      {\n        attributeName: "aPositionCoord",\n        size: 2,\n        uploadFunction: this.uploadPosition,\n        offset: 0\n      },\n      // rotationData\n      {\n        attributeName: "aRotation",\n        size: 1,\n        uploadFunction: this.uploadRotation,\n        offset: 0\n      },\n      // uvsData\n      {\n        attributeName: "aTextureCoord",\n        size: 2,\n        uploadFunction: this.uploadUvs,\n        offset: 0\n      },\n      // tintData\n      {\n        attributeName: "aColor",\n        size: 1,\n        type: TYPES.UNSIGNED_BYTE,\n        uploadFunction: this.uploadTint,\n        offset: 0\n      }\n    ], this.shader = Shader.from(particles_vert_vertex, particles_frag_fragment, {}), this.state = State.for2d();\n  }\n  /**\n   * Renders the particle container object.\n   * @param container - The container to render using this ParticleRenderer.\n   */\n  render(container) {\n    const children = container.children, maxSize = container._maxSize, batchSize = container._batchSize, renderer = this.renderer;\n    let totalChildren = children.length;\n    if (totalChildren === 0)\n      return;\n    totalChildren > maxSize && !container.autoResize && (totalChildren = maxSize);\n    let buffers = container._buffers;\n    buffers || (buffers = container._buffers = this.generateBuffers(container));\n    const baseTexture = children[0]._texture.baseTexture, premultiplied = baseTexture.alphaMode > 0;\n    this.state.blendMode = correctBlendMode(container.blendMode, premultiplied), renderer.state.set(this.state);\n    const gl = renderer.gl, m = container.worldTransform.copyTo(this.tempMatrix);\n    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = m.toArray(!0), this.shader.uniforms.uColor = Color_Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor), this.shader.uniforms.uSampler = baseTexture, this.renderer.shader.bind(this.shader);\n    let updateStatic = !1;\n    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      let amount = totalChildren - i;\n      amount > batchSize && (amount = batchSize), j >= buffers.length && buffers.push(this._generateOneMoreBuffer(container));\n      const buffer = buffers[j];\n      buffer.uploadDynamic(children, i, amount);\n      const bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid, updateStatic && (buffer._updateID = container._updateID, buffer.uploadStatic(children, i, amount)), renderer.geometry.bind(buffer.geometry), gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    }\n  }\n  /**\n   * Creates one particle buffer for each child in the container we want to render and updates internal properties.\n   * @param container - The container to render using this ParticleRenderer\n   * @returns - The buffers\n   */\n  generateBuffers(container) {\n    const buffers = [], size = container._maxSize, batchSize = container._batchSize, dynamicPropertyFlags = container._properties;\n    for (let i = 0; i < size; i += batchSize)\n      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n    return buffers;\n  }\n  /**\n   * Creates one more particle buffer, because container has autoResize feature.\n   * @param container - The container to render using this ParticleRenderer\n   * @returns - The generated buffer\n   */\n  _generateOneMoreBuffer(container) {\n    const batchSize = container._batchSize, dynamicPropertyFlags = container._properties;\n    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n  }\n  /**\n   * Uploads the vertices.\n   * @param children - the array of sprites to render\n   * @param startIndex - the index to start from in the children array\n   * @param amount - the amount of children that will have their vertices uploaded\n   * @param array - The vertices to upload.\n   * @param stride - Stride to use for iteration.\n   * @param offset - Offset to start at.\n   */\n  uploadVertices(children, startIndex, amount, array, stride, offset) {\n    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i], texture = sprite._texture, sx = sprite.scale.x, sy = sprite.scale.y, trim = texture.trim, orig = texture.orig;\n      trim ? (w1 = trim.x - sprite.anchor.x * orig.width, w0 = w1 + trim.width, h1 = trim.y - sprite.anchor.y * orig.height, h0 = h1 + trim.height) : (w0 = orig.width * (1 - sprite.anchor.x), w1 = orig.width * -sprite.anchor.x, h0 = orig.height * (1 - sprite.anchor.y), h1 = orig.height * -sprite.anchor.y), array[offset] = w1 * sx, array[offset + 1] = h1 * sy, array[offset + stride] = w0 * sx, array[offset + stride + 1] = h1 * sy, array[offset + stride * 2] = w0 * sx, array[offset + stride * 2 + 1] = h0 * sy, array[offset + stride * 3] = w1 * sx, array[offset + stride * 3 + 1] = h0 * sy, offset += stride * 4;\n    }\n  }\n  /**\n   * Uploads the position.\n   * @param children - the array of sprites to render\n   * @param startIndex - the index to start from in the children array\n   * @param amount - the amount of children that will have their positions uploaded\n   * @param array - The vertices to upload.\n   * @param stride - Stride to use for iteration.\n   * @param offset - Offset to start at.\n   */\n  uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x, array[offset + 1] = spritePosition.y, array[offset + stride] = spritePosition.x, array[offset + stride + 1] = spritePosition.y, array[offset + stride * 2] = spritePosition.x, array[offset + stride * 2 + 1] = spritePosition.y, array[offset + stride * 3] = spritePosition.x, array[offset + stride * 3 + 1] = spritePosition.y, offset += stride * 4;\n    }\n  }\n  /**\n   * Uploads the rotation.\n   * @param children - the array of sprites to render\n   * @param startIndex - the index to start from in the children array\n   * @param amount - the amount of children that will have their rotation uploaded\n   * @param array - The vertices to upload.\n   * @param stride - Stride to use for iteration.\n   * @param offset - Offset to start at.\n   */\n  uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation, array[offset + stride] = spriteRotation, array[offset + stride * 2] = spriteRotation, array[offset + stride * 3] = spriteRotation, offset += stride * 4;\n    }\n  }\n  /**\n   * Uploads the UVs.\n   * @param children - the array of sprites to render\n   * @param startIndex - the index to start from in the children array\n   * @param amount - the amount of children that will have their rotation uploaded\n   * @param array - The vertices to upload.\n   * @param stride - Stride to use for iteration.\n   * @param offset - Offset to start at.\n   */\n  uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const textureUvs = children[startIndex + i]._texture._uvs;\n      textureUvs ? (array[offset] = textureUvs.x0, array[offset + 1] = textureUvs.y0, array[offset + stride] = textureUvs.x1, array[offset + stride + 1] = textureUvs.y1, array[offset + stride * 2] = textureUvs.x2, array[offset + stride * 2 + 1] = textureUvs.y2, array[offset + stride * 3] = textureUvs.x3, array[offset + stride * 3 + 1] = textureUvs.y3, offset += stride * 4) : (array[offset] = 0, array[offset + 1] = 0, array[offset + stride] = 0, array[offset + stride + 1] = 0, array[offset + stride * 2] = 0, array[offset + stride * 2 + 1] = 0, array[offset + stride * 3] = 0, array[offset + stride * 3 + 1] = 0, offset += stride * 4);\n    }\n  }\n  /**\n   * Uploads the tint.\n   * @param children - the array of sprites to render\n   * @param startIndex - the index to start from in the children array\n   * @param amount - the amount of children that will have their rotation uploaded\n   * @param array - The vertices to upload.\n   * @param stride - Stride to use for iteration.\n   * @param offset - Offset to start at.\n   */\n  uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i], result = Color_Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);\n      array[offset] = result, array[offset + stride] = result, array[offset + stride * 2] = result, array[offset + stride * 3] = result, offset += stride * 4;\n    }\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;\n  }\n}\nParticleRenderer.extension = {\n  name: "particle",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(ParticleRenderer);\n\n//# sourceMappingURL=ParticleRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/const.mjs\nvar TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => (TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", TEXT_GRADIENT2))(TEXT_GRADIENT || {});\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextMetrics.mjs\n\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: !0\n}, _TextMetrics = class _TextMetrics2 {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see PIXI.TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _TextMetrics2._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;\n      result = _TextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param wordWrap - Override for if word-wrap should be applied to the text.\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text, style, wordWrap, canvas = _TextMetrics2._canvas) {\n    wordWrap = wordWrap ?? style.wordWrap;\n    const font = style.toFontString(), fontProperties = _TextMetrics2.measureFont(font);\n    fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);\n    const context = canvas.getContext("2d", contextSettings);\n    context.font = font;\n    const lines = (wordWrap ? _TextMetrics2.wordWrap(text, style, canvas) : text).split(/(?:\\r\\n|\\r|\\n)/), lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _TextMetrics2._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n    style.dropShadow && (width += style.dropShadowDistance);\n    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + style.leading + (lines.length - 1) * (lineHeight + style.leading);\n    return style.dropShadow && (height += style.dropShadowDistance), new _TextMetrics2(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = !1;\n    _TextMetrics2.experimentalLetterSpacingSupported && (_TextMetrics2.experimentalLetterSpacing ? (context.letterSpacing = `${letterSpacing}px`, context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (context.letterSpacing = "0px", context.textLetterSpacing = "0px"));\n    let width = context.measureText(text).width;\n    return width > 0 && (useExperimentalLetterSpacing ? width -= letterSpacing : width += (_TextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing), width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object\'s wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static wordWrap(text, style, canvas = _TextMetrics2._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0, line = "", lines = "";\n    const cache = /* @__PURE__ */ Object.create(null), { letterSpacing, whiteSpace } = style, collapseSpaces = _TextMetrics2.collapseSpaces(whiteSpace), collapseNewlines = _TextMetrics2.collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = _TextMetrics2.tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_TextMetrics2.isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _TextMetrics2.addLine(line), canPrependSpaces = !collapseSpaces, line = "", width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _TextMetrics2.isBreakingSpace(token), lastIsBreakingSpace = _TextMetrics2.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace)\n          continue;\n      }\n      const tokenWidth = _TextMetrics2.getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth)\n        if (line !== "" && (lines += _TextMetrics2.addLine(line), line = "", width = 0), _TextMetrics2.canBreakWords(token, style.breakWords)) {\n          const characters = _TextMetrics2.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j], lastChar = char, k = 1;\n            for (; characters[j + k]; ) {\n              const nextChar = characters[j + k];\n              if (!_TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                char += nextChar;\n              else\n                break;\n              lastChar = nextChar, k++;\n            }\n            j += k - 1;\n            const characterWidth = _TextMetrics2.getFromCache(char, letterSpacing, cache, context);\n            characterWidth + width > wordWrapWidth && (lines += _TextMetrics2.addLine(line), canPrependSpaces = !1, line = "", width = 0), line += char, width += characterWidth;\n          }\n        } else {\n          line.length > 0 && (lines += _TextMetrics2.addLine(line), line = "", width = 0);\n          const isLastToken = i === tokens.length - 1;\n          lines += _TextMetrics2.addLine(token, !isLastToken), canPrependSpaces = !1, line = "", width = 0;\n        }\n      else\n        tokenWidth + width > wordWrapWidth && (canPrependSpaces = !1, lines += _TextMetrics2.addLine(line), line = "", width = 0), (line.length > 0 || !_TextMetrics2.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += tokenWidth);\n    }\n    return lines += _TextMetrics2.addLine(line, !1), lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static addLine(line, newLine = !0) {\n    return line = _TextMetrics2.trimRight(line), line = newLine ? `${line}\n` : line, line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    return typeof width != "number" && (width = _TextMetrics2._measureText(key, letterSpacing, context) + letterSpacing, cache[key] = width), width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static trimRight(text) {\n    if (typeof text != "string")\n      return "";\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_TextMetrics2.isBreakingSpace(char))\n        break;\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static isNewline(char) {\n    return typeof char != "string" ? !1 : _TextMetrics2._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    return typeof char != "string" ? !1 : _TextMetrics2._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text != "string")\n      return tokens;\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i], nextChar = text[i + 1];\n      if (_TextMetrics2.isBreakingSpace(char, nextChar) || _TextMetrics2.isNewline(char)) {\n        token !== "" && (tokens.push(token), token = ""), tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    return token !== "" && tokens.push(token), tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return !0;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see TextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _TextMetrics2.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_TextMetrics2._fonts[font])\n      return _TextMetrics2._fonts[font];\n    const properties = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    }, canvas = _TextMetrics2._canvas, context = _TextMetrics2._context;\n    context.font = font;\n    const metricsString = _TextMetrics2.METRICS_STRING + _TextMetrics2.BASELINE_SYMBOL, width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(context.measureText(_TextMetrics2.BASELINE_SYMBOL).width);\n    const height = Math.ceil(_TextMetrics2.HEIGHT_MULTIPLIER * baseline);\n    if (baseline = baseline * _TextMetrics2.BASELINE_MULTIPLIER | 0, width === 0 || height === 0)\n      return _TextMetrics2._fonts[font] = properties, properties;\n    canvas.width = width, canvas.height = height, context.fillStyle = "#f00", context.fillRect(0, 0, width, height), context.font = font, context.textBaseline = "alphabetic", context.fillStyle = "#000", context.fillText(metricsString, 0, baseline);\n    const imagedata = context.getImageData(0, 0, width, height).data, pixels = imagedata.length, line = width * 4;\n    let i = 0, idx = 0, stop = !1;\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4)\n        if (imagedata[idx + j] !== 255) {\n          stop = !0;\n          break;\n        }\n      if (!stop)\n        idx += line;\n      else\n        break;\n    }\n    for (properties.ascent = baseline - i, idx = pixels - line, stop = !1, i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4)\n        if (imagedata[idx + j] !== 255) {\n          stop = !0;\n          break;\n        }\n      if (!stop)\n        idx -= line;\n      else\n        break;\n    }\n    return properties.descent = i - baseline, properties.fontSize = properties.ascent + properties.descent, _TextMetrics2._fonts[font] = properties, properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = "") {\n    font ? delete _TextMetrics2._fonts[font] : _TextMetrics2._fonts = {};\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_TextMetrics2.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        if (c.getContext("2d", contextSettings)?.measureText)\n          return _TextMetrics2.__canvas = c, c;\n        canvas = settings.ADAPTER.createCanvas();\n      } catch {\n        canvas = settings.ADAPTER.createCanvas();\n      }\n      canvas.width = canvas.height = 10, _TextMetrics2.__canvas = canvas;\n    }\n    return _TextMetrics2.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    return _TextMetrics2.__context || (_TextMetrics2.__context = _TextMetrics2._canvas.getContext("2d", contextSettings)), _TextMetrics2.__context;\n  }\n};\n_TextMetrics.METRICS_STRING = "|\\xC9q\\xC5", /** Baseline symbol for calculate font metrics. */\n_TextMetrics.BASELINE_SYMBOL = "M", /** Baseline multiplier for calculate font metrics. */\n_TextMetrics.BASELINE_MULTIPLIER = 1.4, /** Height multiplier for setting height of canvas to calculate font metrics. */\n_TextMetrics.HEIGHT_MULTIPLIER = 2, /**\n* A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,\n* such as letters with diacritical marks (e.g. `\'\\u0065\\u0301\'`, letter e with acute)\n* or emojis with modifiers (e.g. `\'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\'`, technologist).\n* The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n* PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n* If you want to get full functionality in environments that don\'t support `Intl.Segmenter` (such as Firefox),\n* you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n* or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n* relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won\'t use them directly.\n*/\n_TextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter == "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})(), /**\n* New rendering behavior for letter-spacing which uses Chrome\'s new native API. This will\n* lead to more accurate letter-spacing results because it does not try to manually draw\n* each character. However, this Chrome API is experimental and may not serve all cases yet.\n* @see PIXI.TextMetrics.experimentalLetterSpacingSupported\n*/\n_TextMetrics.experimentalLetterSpacing = !1, /** Cache of {@see PIXI.TextMetrics.FontMetrics} objects. */\n_TextMetrics._fonts = {}, /** Cache of new line chars. */\n_TextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n], /** Cache of breaking spaces. */\n_TextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\nlet TextMetrics = _TextMetrics;\n\n//# sourceMappingURL=TextMetrics.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextStyle.mjs\n\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n], _TextStyle = class _TextStyle2 {\n  /**\n   * @param style - TextStyle properties to be set on the text. See {@link PIXI.TextStyle.defaultStyle}\n   *       for the default values.\n   */\n  constructor(style) {\n    this.styleID = 0, this.reset(), deepCopyProperties(this, style, style);\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * Note that the only the properties of the object are cloned.\n   *\n   * @return New cloned TextStyle object\n   */\n  clone() {\n    const clonedProperties = {};\n    return deepCopyProperties(clonedProperties, this, _TextStyle2.defaultStyle), new _TextStyle2(clonedProperties);\n  }\n  /** Resets all properties to the defaults specified in TextStyle.prototype._default */\n  reset() {\n    deepCopyProperties(this, _TextStyle2.defaultStyle, _TextStyle2.defaultStyle);\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   *\n   * @member {\'left\'|\'center\'|\'right\'|\'justify\'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(align) {\n    this._align !== align && (this._align = align, this.styleID++);\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(breakWords) {\n    this._breakWords !== breakWords && (this._breakWords = breakWords, this.styleID++);\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(dropShadow) {\n    this._dropShadow !== dropShadow && (this._dropShadow = dropShadow, this.styleID++);\n  }\n  /** Set alpha for the drop shadow. */\n  get dropShadowAlpha() {\n    return this._dropShadowAlpha;\n  }\n  set dropShadowAlpha(dropShadowAlpha) {\n    this._dropShadowAlpha !== dropShadowAlpha && (this._dropShadowAlpha = dropShadowAlpha, this.styleID++);\n  }\n  /** Set a angle of the drop shadow. */\n  get dropShadowAngle() {\n    return this._dropShadowAngle;\n  }\n  set dropShadowAngle(dropShadowAngle) {\n    this._dropShadowAngle !== dropShadowAngle && (this._dropShadowAngle = dropShadowAngle, this.styleID++);\n  }\n  /** Set a shadow blur radius. */\n  get dropShadowBlur() {\n    return this._dropShadowBlur;\n  }\n  set dropShadowBlur(dropShadowBlur) {\n    this._dropShadowBlur !== dropShadowBlur && (this._dropShadowBlur = dropShadowBlur, this.styleID++);\n  }\n  /** A fill style to be used on the dropshadow e.g., \'red\', \'#00FF00\'. */\n  get dropShadowColor() {\n    return this._dropShadowColor;\n  }\n  set dropShadowColor(dropShadowColor) {\n    const outputColor = getColor(dropShadowColor);\n    this._dropShadowColor !== outputColor && (this._dropShadowColor = outputColor, this.styleID++);\n  }\n  /** Set a distance of the drop shadow. */\n  get dropShadowDistance() {\n    return this._dropShadowDistance;\n  }\n  set dropShadowDistance(dropShadowDistance) {\n    this._dropShadowDistance !== dropShadowDistance && (this._dropShadowDistance = dropShadowDistance, this.styleID++);\n  }\n  /**\n   * A canvas fillstyle that will be used on the text e.g., \'red\', \'#00FF00\'.\n   *\n   * Can be an array to create a gradient e.g., `[\'#000000\',\'#FFFFFF\']`\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n   *\n   * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  get fill() {\n    return this._fill;\n  }\n  set fill(fill) {\n    const outputColor = getColor(fill);\n    this._fill !== outputColor && (this._fill = outputColor, this.styleID++);\n  }\n  /**\n   * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.\n   *\n   * @type {PIXI.TEXT_GRADIENT}\n   */\n  get fillGradientType() {\n    return this._fillGradientType;\n  }\n  set fillGradientType(fillGradientType) {\n    this._fillGradientType !== fillGradientType && (this._fillGradientType = fillGradientType, this.styleID++);\n  }\n  /**\n   * If fill is an array of colours to create a gradient, this array can set the stop points\n   * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.\n   */\n  get fillGradientStops() {\n    return this._fillGradientStops;\n  }\n  set fillGradientStops(fillGradientStops) {\n    areArraysEqual(this._fillGradientStops, fillGradientStops) || (this._fillGradientStops = fillGradientStops, this.styleID++);\n  }\n  /**\n   * The font family, can be a single font name, or a list of names where the first\n   * is the preferred font.\n   */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(fontFamily) {\n    this.fontFamily !== fontFamily && (this._fontFamily = fontFamily, this.styleID++);\n  }\n  /**\n   * The font size\n   * (as a number it converts to px, but as a string, equivalents are \'26px\',\'20pt\',\'160%\' or \'1.6em\')\n   */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(fontSize) {\n    this._fontSize !== fontSize && (this._fontSize = fontSize, this.styleID++);\n  }\n  /**\n   * The font style.\n   *\n   * @member {\'normal\'|\'italic\'|\'oblique\'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(fontStyle) {\n    this._fontStyle !== fontStyle && (this._fontStyle = fontStyle, this.styleID++);\n  }\n  /**\n   * The font variant.\n   *\n   * @member {\'normal\'|\'small-caps\'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(fontVariant) {\n    this._fontVariant !== fontVariant && (this._fontVariant = fontVariant, this.styleID++);\n  }\n  /**\n   * The font weight.\n   *\n   * @member {\'normal\'|\'bold\'|\'bolder\'|\'lighter\'|\'100\'|\'200\'|\'300\'|\'400\'|\'500\'|\'600\'|\'700\'|\'800\'|\'900\'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(fontWeight) {\n    this._fontWeight !== fontWeight && (this._fontWeight = fontWeight, this.styleID++);\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(letterSpacing) {\n    this._letterSpacing !== letterSpacing && (this._letterSpacing = letterSpacing, this.styleID++);\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(lineHeight) {\n    this._lineHeight !== lineHeight && (this._lineHeight = lineHeight, this.styleID++);\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(leading) {\n    this._leading !== leading && (this._leading = leading, this.styleID++);\n  }\n  /**\n   * The lineJoin property sets the type of corner created, it can resolve spiked text issues.\n   * Default is \'miter\' (creates a sharp corner).\n   *\n   * @member {\'miter\'|\'round\'|\'bevel\'}\n   */\n  get lineJoin() {\n    return this._lineJoin;\n  }\n  set lineJoin(lineJoin) {\n    this._lineJoin !== lineJoin && (this._lineJoin = lineJoin, this.styleID++);\n  }\n  /**\n   * The miter limit to use when using the \'miter\' lineJoin mode.\n   *\n   * This can reduce or increase the spikiness of rendered text.\n   */\n  get miterLimit() {\n    return this._miterLimit;\n  }\n  set miterLimit(miterLimit) {\n    this._miterLimit !== miterLimit && (this._miterLimit = miterLimit, this.styleID++);\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(padding) {\n    this._padding !== padding && (this._padding = padding, this.styleID++);\n  }\n  /**\n   * A canvas fillstyle that will be used on the text stroke, e.g., \'blue\', \'#FCFF00\'\n   */\n  get stroke() {\n    return this._stroke;\n  }\n  set stroke(stroke) {\n    const outputColor = getColor(stroke);\n    this._stroke !== outputColor && (this._stroke = outputColor, this.styleID++);\n  }\n  /**\n   * A number that represents the thickness of the stroke.\n   *\n   * @default 0\n   */\n  get strokeThickness() {\n    return this._strokeThickness;\n  }\n  set strokeThickness(strokeThickness) {\n    this._strokeThickness !== strokeThickness && (this._strokeThickness = strokeThickness, this.styleID++);\n  }\n  /**\n   * The baseline of the text that is rendered.\n   *\n   * @member {\'alphabetic\'|\'top\'|\'hanging\'|\'middle\'|\'ideographic\'|\'bottom\'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(textBaseline) {\n    this._textBaseline !== textBaseline && (this._textBaseline = textBaseline, this.styleID++);\n  }\n  /** Trim transparent borders. */\n  get trim() {\n    return this._trim;\n  }\n  set trim(trim) {\n    this._trim !== trim && (this._trim = trim, this.styleID++);\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is \'pre\' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * \'normal\'     | Collapse      |   Collapse\n   * \'pre\'        | Preserve      |   Preserve\n   * \'pre-line\'   | Preserve      |   Collapse\n   *\n   * @member {\'normal\'|\'pre\'|\'pre-line\'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(whiteSpace) {\n    this._whiteSpace !== whiteSpace && (this._whiteSpace = whiteSpace, this.styleID++);\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(wordWrap) {\n    this._wordWrap !== wordWrap && (this._wordWrap = wordWrap, this.styleID++);\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(wordWrapWidth) {\n    this._wordWrapWidth !== wordWrapWidth && (this._wordWrapWidth = wordWrapWidth, this.styleID++);\n  }\n  /**\n   * Generates a font style string to use for `TextMetrics.measureFont()`.\n   *\n   * @return Font style string, for passing to `TextMetrics.measureFont()`\n   */\n  toFontString() {\n    const fontSizeString = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;\n    let fontFamilies = this.fontFamily;\n    Array.isArray(this.fontFamily) || (fontFamilies = this.fontFamily.split(","));\n    for (let i = fontFamilies.length - 1; i >= 0; i--) {\n      let fontFamily = fontFamilies[i].trim();\n      !/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily) && (fontFamily = `"${fontFamily}"`), fontFamilies[i] = fontFamily;\n    }\n    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n  }\n};\n_TextStyle.defaultStyle = {\n  /**\n   * See {@link PIXI.TextStyle.align}\n   * @type {\'left\'|\'center\'|\'right\'|\'justify\'}\n   */\n  align: "left",\n  /** See {@link PIXI.TextStyle.breakWords} */\n  breakWords: !1,\n  /** See {@link PIXI.TextStyle.dropShadow} */\n  dropShadow: !1,\n  /** See {@link PIXI.TextStyle.dropShadowAlpha} */\n  dropShadowAlpha: 1,\n  /**\n   * See {@link PIXI.TextStyle.dropShadowAngle}\n   * @type {number}\n   * @default Math.PI / 6\n   */\n  dropShadowAngle: Math.PI / 6,\n  /** See {@link PIXI.TextStyle.dropShadowBlur} */\n  dropShadowBlur: 0,\n  /**\n   * See {@link PIXI.TextStyle.dropShadowColor}\n   * @type {string|number}\n   */\n  dropShadowColor: "black",\n  /** See {@link PIXI.TextStyle.dropShadowDistance} */\n  dropShadowDistance: 5,\n  /**\n   * See {@link PIXI.TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: "black",\n  /**\n   * See {@link PIXI.TextStyle.fillGradientType}\n   * @type {PIXI.TEXT_GRADIENT}\n   * @default PIXI.TEXT_GRADIENT.LINEAR_VERTICAL\n   */\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  /**\n   * See {@link PIXI.TextStyle.fillGradientStops}\n   * @type {number[]}\n   * @default []\n   */\n  fillGradientStops: [],\n  /**\n   * See {@link PIXI.TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: "Arial",\n  /**\n   * See {@link PIXI.TextStyle.fontSize}\n   * @type {number|string} \n   */\n  fontSize: 26,\n  /**\n   * See {@link PIXI.TextStyle.fontStyle}\n   * @type {\'normal\'|\'italic\'|\'oblique\'}\n   */\n  fontStyle: "normal",\n  /**\n   * See {@link PIXI.TextStyle.fontVariant}\n   * @type {\'normal\'|\'small-caps\'}\n   */\n  fontVariant: "normal",\n  /**\n   * See {@link PIXI.TextStyle.fontWeight}\n   * @type {\'normal\'|\'bold\'|\'bolder\'|\'lighter\'|\'100\'|\'200\'|\'300\'|\'400\'|\'500\'|\'600\'|\'700\'|\'800\'|\'900\'}\n   */\n  fontWeight: "normal",\n  /** See {@link PIXI.TextStyle.leading} */\n  leading: 0,\n  /** See {@link PIXI.TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link PIXI.TextStyle.lineHeight} */\n  lineHeight: 0,\n  /**\n   * See {@link PIXI.TextStyle.lineJoin}\n   * @type {\'miter\'|\'round\'|\'bevel\'}\n   */\n  lineJoin: "miter",\n  /** See {@link PIXI.TextStyle.miterLimit} */\n  miterLimit: 10,\n  /** See {@link PIXI.TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link PIXI.TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: "black",\n  /** See {@link PIXI.TextStyle.strokeThickness} */\n  strokeThickness: 0,\n  /**\n   * See {@link PIXI.TextStyle.textBaseline} \n   * @type {\'alphabetic\'|\'top\'|\'hanging\'|\'middle\'|\'ideographic\'|\'bottom\'}\n   */\n  textBaseline: "alphabetic",\n  /** See {@link PIXI.TextStyle.trim} */\n  trim: !1,\n  /**\n   * See {@link PIXI.TextStyle.whiteSpace}\n   * @type {\'normal\'|\'pre\'|\'pre-line\'}\n   */\n  whiteSpace: "pre",\n  /** See {@link PIXI.TextStyle.wordWrap} */\n  wordWrap: !1,\n  /** See {@link PIXI.TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction getColor(color) {\n  const temp = Color_Color.shared, format = (color2) => {\n    const res = temp.setValue(color2);\n    return res.alpha === 1 ? res.toHex() : res.toRgbaString();\n  };\n  return Array.isArray(color) ? color.map(format) : format(color);\n}\nfunction areArraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length)\n    return !1;\n  for (let i = 0; i < array1.length; ++i)\n    if (array1[i] !== array2[i])\n      return !1;\n  return !0;\n}\nfunction deepCopyProperties(target, source, propertyObj) {\n  for (const prop in propertyObj)\n    Array.isArray(source[prop]) ? target[prop] = source[prop].slice() : target[prop] = source[prop];\n}\n\n//# sourceMappingURL=TextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/Text.mjs\n\n\n\n\n\nconst defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, _Text = class _Text2 extends Sprite_Sprite {\n  /**\n   * @param text - The string that you would like the text to display\n   * @param style - The style parameters\n   * @param canvas - The canvas element for drawing text\n   */\n  constructor(text, style, canvas) {\n    let ownCanvas = !1;\n    canvas || (canvas = settings.ADAPTER.createCanvas(), ownCanvas = !0), canvas.width = 3, canvas.height = 3;\n    const texture = Texture_Texture.from(canvas);\n    texture.orig = new Rectangle_Rectangle(), texture.trim = new Rectangle_Rectangle(), super(texture), this._ownCanvas = ownCanvas, this.canvas = canvas, this.context = canvas.getContext("2d", {\n      // required for trimming to work without warnings\n      willReadFrequently: !0\n    }), this._resolution = _Text2.defaultResolution ?? settings.RESOLUTION, this._autoResolution = _Text2.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = text, this.style = style, this.localStyleID = -1;\n  }\n  /**\n   * @see PIXI.TextMetrics.experimentalLetterSpacing\n   * @deprecated since 7.1.0\n   */\n  static get experimentalLetterSpacing() {\n    return TextMetrics.experimentalLetterSpacing;\n  }\n  static set experimentalLetterSpacing(value) {\n    deprecation(\n      "7.1.0",\n      "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"\n    ), TextMetrics.experimentalLetterSpacing = value;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to \'pre-generate\' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param respectDirty - Whether to abort updating the text if the Text isn\'t dirty and the function is called.\n   */\n  updateText(respectDirty) {\n    const style = this._style;\n    if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty)\n      return;\n    this._font = this._style.toFontString();\n    const context = this.context, measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), width = measured.width, height = measured.height, lines = measured.lines, lineHeight = measured.lineHeight, lineWidths = measured.lineWidths, maxLineWidth = measured.maxLineWidth, fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution), context.scale(this._resolution, this._resolution), context.clearRect(0, 0, this.canvas.width, this.canvas.height), context.font = this._font, context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit;\n    let linePositionX, linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0, dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0, dsOffsetShadow = dsOffsetText * this._resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black", context.strokeStyle = "black";\n        const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * this._resolution, dropShadowDistance = style.dropShadowDistance * this._resolution;\n        context.shadowColor = Color_Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context.shadowBlur = dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n      } else\n        context.fillStyle = this._generateFillStyle(style, lines, measured), context.strokeStyle = style.stroke, context.shadowColor = "black", context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0;\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      lineHeight - fontProperties.fontSize < 0 && (linePositionYShift = 0);\n      for (let i2 = 0; i2 < lines.length; i2++)\n        linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift, style.align === "right" ? linePositionX += maxLineWidth - lineWidths[i2] : style.align === "center" && (linePositionX += (maxLineWidth - lineWidths[i2]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(\n          lines[i2],\n          linePositionX + style.padding,\n          linePositionY + style.padding - dsOffsetText,\n          !0\n        ), style.fill && this.drawLetterSpacing(\n          lines[i2],\n          linePositionX + style.padding,\n          linePositionY + style.padding - dsOffsetText\n        );\n    }\n    this.updateTexture();\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it\'s for the inside fill\n   */\n  drawLetterSpacing(text, x, y, isStroke = !1) {\n    const letterSpacing = this._style.letterSpacing;\n    let useExperimentalLetterSpacing = !1;\n    if (TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), letterSpacing === 0 || useExperimentalLetterSpacing) {\n      isStroke ? this.context.strokeText(text, x, y) : this.context.fillText(text, x, y);\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = TextMetrics.graphemeSegmenter(text);\n    let previousWidth = this.context.measureText(text).width, currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      isStroke ? this.context.strokeText(currentChar, currentPosition, y) : this.context.fillText(currentChar, currentPosition, y);\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j)\n        textStr += stringArray[j];\n      currentWidth = this.context.measureText(textStr).width, currentPosition += previousWidth - currentWidth + letterSpacing, previousWidth = currentWidth;\n    }\n  }\n  /** Updates texture size based on canvas size. */\n  updateTexture() {\n    const canvas = this.canvas;\n    if (this._style.trim) {\n      const trimmed = trimCanvas(canvas);\n      trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));\n    }\n    const texture = this._texture, style = this._style, padding = style.trim ? 0 : style.padding, baseTexture = texture.baseTexture;\n    texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), texture.updateUvs(), this.dirty = !1;\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  _render(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);\n  }\n  /** Updates the transform on all children of this container for rendering. */\n  updateTransform() {\n    this.updateText(!0), super.updateTransform();\n  }\n  getBounds(skipUpdate, rect) {\n    return this.updateText(!0), this._textureID === -1 && (skipUpdate = !1), super.getBounds(skipUpdate, rect);\n  }\n  /**\n   * Gets the local bounds of the text object.\n   * @param rect - The output rectangle.\n   * @returns The bounds.\n   */\n  getLocalBounds(rect) {\n    return this.updateText(!0), super.getLocalBounds.call(this, rect);\n  }\n  /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n  _calculateBounds() {\n    this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }\n  /**\n   * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n   * @param style - The style.\n   * @param lines - The lines of text.\n   * @param metrics\n   * @returns The fill style\n   */\n  _generateFillStyle(style, lines, metrics) {\n    const fillStyle = style.fill;\n    if (Array.isArray(fillStyle)) {\n      if (fillStyle.length === 1)\n        return fillStyle[0];\n    } else\n      return fillStyle;\n    let gradient;\n    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2, height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();\n    if (!fillGradientStops.length) {\n      const lengthPlus1 = fill.length + 1;\n      for (let i = 1; i < lengthPlus1; ++i)\n        fillGradientStops.push(i / lengthPlus1);\n    }\n    if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n      for (let i = 0; i < lines.length; i++) {\n        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight, thisLineTop = metrics.lineHeight * i;\n        let thisLineGradientStart = thisLineTop;\n        i > 0 && lastLineBottom > thisLineTop && (thisLineGradientStart = (thisLineTop + lastLineBottom) / 2);\n        const thisLineBottom = thisLineTop + textHeight, nextLineTop = metrics.lineHeight * (i + 1);\n        let thisLineGradientEnd = thisLineBottom;\n        i + 1 < lines.length && nextLineTop < thisLineBottom && (thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2);\n        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n        for (let j = 0; j < fill.length; j++) {\n          let lineStop = 0;\n          typeof fillGradientStops[j] == "number" ? lineStop = fillGradientStops[j] : lineStop = j / fill.length;\n          let globalStop = Math.min(1, Math.max(\n            0,\n            thisLineGradientStart / height + lineStop * gradStopLineHeight\n          ));\n          globalStop = Number(globalStop.toFixed(5)), gradient.addColorStop(globalStop, fill[j]);\n        }\n      }\n    } else {\n      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n      const totalIterations = fill.length + 1;\n      let currentIteration = 1;\n      for (let i = 0; i < fill.length; i++) {\n        let stop;\n        typeof fillGradientStops[i] == "number" ? stop = fillGradientStops[i] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i]), currentIteration++;\n      }\n    }\n    return gradient;\n  }\n  /**\n   * Destroys this text object.\n   *\n   * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n   * the majority of the time the texture will not be shared with any other Sprites.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n   */\n  destroy(options) {\n    typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, defaultDestroyOptions, options), super.destroy(options), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n  }\n  /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this.updateText(!0);\n    const s = sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width, this._width = value;\n  }\n  /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this.updateText(!0);\n    const s = sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height, this._height = value;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link PIXI.ITextStyle}.\n   */\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    style = style || {}, style instanceof TextStyle ? this._style = style : this._style = new TextStyle(style), this.localStyleID = -1, this.dirty = !0;\n  }\n  /** Set the copy for the text object. To split a line you can use \'\\n\'. */\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = !0);\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   *\n   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n   * @default 1\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n  }\n};\n_Text.defaultAutoResolution = !0;\nlet Text = _Text;\n\n//# sourceMappingURL=Text.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/CountLimiter.mjs\nclass CountLimiter {\n  /**\n   * @param maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n   */\n  constructor(maxItemsPerFrame) {\n    this.maxItemsPerFrame = maxItemsPerFrame, this.itemsLeft = 0;\n  }\n  /** Resets any counting properties to start fresh on a new frame. */\n  beginFrame() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  }\n  /**\n   * Checks to see if another item can be uploaded. This should only be called once per item.\n   * @returns If the item is allowed to be uploaded.\n   */\n  allowedToUpload() {\n    return this.itemsLeft-- > 0;\n  }\n}\n\n//# sourceMappingURL=CountLimiter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/BasePrepare.mjs\n\n\n\n\nfunction findMultipleBaseTextures(item, queue) {\n  let result = !1;\n  if (item?._textures?.length) {\n    for (let i = 0; i < item._textures.length; i++)\n      if (item._textures[i] instanceof Texture_Texture) {\n        const baseTexture = item._textures[i].baseTexture;\n        queue.includes(baseTexture) || (queue.push(baseTexture), result = !0);\n      }\n  }\n  return result;\n}\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof BaseTexture) {\n    const texture = item.baseTexture;\n    return queue.includes(texture) || queue.push(texture), !0;\n  }\n  return !1;\n}\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof Texture_Texture) {\n    const texture = item._texture.baseTexture;\n    return queue.includes(texture) || queue.push(texture), !0;\n  }\n  return !1;\n}\nfunction drawText(_helper, item) {\n  return item instanceof Text ? (item.updateText(!0), !0) : !1;\n}\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof TextStyle) {\n    const font = item.toFontString();\n    return TextMetrics.measureFont(font), !0;\n  }\n  return !1;\n}\nfunction findText(item, queue) {\n  if (item instanceof Text) {\n    queue.includes(item.style) || queue.push(item.style), queue.includes(item) || queue.push(item);\n    const texture = item._texture.baseTexture;\n    return queue.includes(texture) || queue.push(texture), !0;\n  }\n  return !1;\n}\nfunction findTextStyle(item, queue) {\n  return item instanceof TextStyle ? (queue.includes(item) || queue.push(item), !0) : !1;\n}\nconst _BasePrepare = class _BasePrepare2 {\n  /**\n   * @param {PIXI.IRenderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer) {\n    this.limiter = new CountLimiter(_BasePrepare2.uploadsPerFrame), this.renderer = renderer, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {\n      this.queue && this.prepareItems();\n    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);\n  }\n  /**\n   * Upload all the textures and graphics to the GPU.\n   * @method PIXI.BasePrepare#upload\n   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} [item] -\n   *        Container or display object to search for items to upload or the items to upload themselves,\n   *        or optionally ommitted, if items have been added using {@link PIXI.BasePrepare#add `prepare.add`}.\n   */\n  upload(item) {\n    return new Promise((resolve) => {\n      item && this.add(item), this.queue.length ? (this.completes.push(resolve), this.ticking || (this.ticking = !0, Ticker_Ticker.system.addOnce(this.tick, this, const_UPDATE_PRIORITY.UTILITY))) : resolve();\n    });\n  }\n  /**\n   * Handle tick update\n   * @private\n   */\n  tick() {\n    setTimeout(this.delayedTick, 0);\n  }\n  /**\n   * Actually prepare items. This is handled outside of the tick because it will take a while\n   * and we do NOT want to block the current animation frame from rendering.\n   * @private\n   */\n  prepareItems() {\n    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {\n      const item = this.queue[0];\n      let uploaded = !1;\n      if (item && !item._destroyed) {\n        for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift(), uploaded = !0;\n            break;\n          }\n      }\n      uploaded || this.queue.shift();\n    }\n    if (this.queue.length)\n      Ticker_Ticker.system.addOnce(this.tick, this, const_UPDATE_PRIORITY.UTILITY);\n    else {\n      this.ticking = !1;\n      const completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (let i = 0, len = completes.length; i < len; i++)\n        completes[i]();\n    }\n  }\n  /**\n   * Adds hooks for finding items.\n   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n   *          function must return `true` if it was able to add item to the queue.\n   * @returns Instance of plugin for chaining.\n   */\n  registerFindHook(addHook) {\n    return addHook && this.addHooks.push(addHook), this;\n  }\n  /**\n   * Adds hooks for uploading items.\n   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n   *          function must return `true` if it was able to handle upload of item.\n   * @returns Instance of plugin for chaining.\n   */\n  registerUploadHook(uploadHook) {\n    return uploadHook && this.uploadHooks.push(uploadHook), this;\n  }\n  /**\n   * Manually add an item to the uploading queue.\n   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n   *        add to the queue\n   * @returns Instance of plugin for chaining.\n   */\n  add(item) {\n    for (let i = 0, len = this.addHooks.length; i < len && !this.addHooks[i](item, this.queue); i++)\n      ;\n    if (item instanceof Container_Container)\n      for (let i = item.children.length - 1; i >= 0; i--)\n        this.add(item.children[i]);\n    return this;\n  }\n  /** Destroys the plugin, don\'t use after this. */\n  destroy() {\n    this.ticking && Ticker_Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;\n  }\n};\n_BasePrepare.uploadsPerFrame = 4;\nlet BasePrepare = _BasePrepare;\n\n//# sourceMappingURL=BasePrepare.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/settings.mjs\n\n\n\nObject.defineProperties(settings, {\n  /**\n   * Default number of uploads per frame using prepare plugin.\n   * @static\n   * @memberof PIXI.settings\n   * @name UPLOADS_PER_FRAME\n   * @deprecated since 7.1.0\n   * @see PIXI.BasePrepare.uploadsPerFrame\n   * @type {number}\n   */\n  UPLOADS_PER_FRAME: {\n    get() {\n      return BasePrepare.uploadsPerFrame;\n    },\n    set(value) {\n      deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), BasePrepare.uploadsPerFrame = value;\n    }\n  }\n});\n\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/Prepare.mjs\n\n\n\nfunction uploadBaseTextures(renderer, item) {\n  return item instanceof BaseTexture ? (item._glTextures[renderer.CONTEXT_UID] || renderer.texture.bind(item), !0) : !1;\n}\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof Graphics))\n    return !1;\n  const { geometry } = item;\n  item.finishPoly(), geometry.updateBatches();\n  const { batches } = geometry;\n  for (let i = 0; i < batches.length; i++) {\n    const { texture } = batches[i].style;\n    texture && uploadBaseTextures(renderer, texture.baseTexture);\n  }\n  return geometry.batchable || renderer.geometry.bind(geometry, item._resolveDirectShader(renderer)), !0;\n}\nfunction findGraphics(item, queue) {\n  return item instanceof Graphics ? (queue.push(item), !0) : !1;\n}\nclass Prepare extends BasePrepare {\n  /**\n   * @param {PIXI.Renderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer) {\n    super(renderer), this.uploadHookHelper = this.renderer, this.registerFindHook(findGraphics), this.registerUploadHook(uploadBaseTextures), this.registerUploadHook(uploadGraphics);\n  }\n}\nPrepare.extension = {\n  name: "prepare",\n  type: ExtensionType.RendererSystem\n};\nextensions.add(Prepare);\n\n//# sourceMappingURL=Prepare.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs\n\n\nclass AnimatedSprite extends (/* unused pure expression or super */ null && (Sprite)) {\n  /**\n   * @param textures - An array of {@link PIXI.Texture} or frame\n   *  objects that make up the animation.\n   * @param {boolean} [autoUpdate=true] - Whether to use Ticker.shared to auto update animation time.\n   */\n  constructor(textures, autoUpdate = !0) {\n    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture), this._textures = null, this._durations = null, this._autoUpdate = autoUpdate, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = textures;\n  }\n  /** Stops the AnimatedSprite. */\n  stop() {\n    this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));\n  }\n  /** Plays the AnimatedSprite. */\n  play() {\n    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));\n  }\n  /**\n   * Stops the AnimatedSprite and goes to a specific frame.\n   * @param frameNumber - Frame index to stop at.\n   */\n  gotoAndStop(frameNumber) {\n    this.stop(), this.currentFrame = frameNumber;\n  }\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite.\n   * @param frameNumber - Frame index to start at.\n   */\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber, this.play();\n  }\n  /**\n   * Updates the object transform for rendering.\n   * @param deltaTime - Time since last tick.\n   */\n  update(deltaTime) {\n    if (!this._playing)\n      return;\n    const elapsed = this.animationSpeed * deltaTime, previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      for (lag += elapsed / 60 * 1e3; lag < 0; )\n        this._currentTime--, lag += this._durations[this.currentFrame];\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      for (this._currentTime = Math.floor(this._currentTime); lag >= this._durations[this.currentFrame]; )\n        lag -= this._durations[this.currentFrame] * sign, this._currentTime += sign;\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else\n      this._currentTime += elapsed;\n    this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : previousFrame !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) && this.onLoop(), this.updateTexture());\n  }\n  /** Updates the displayed texture to match the current frame index. */\n  updateTexture() {\n    const currentFrame = this.currentFrame;\n    this._previousFrame !== currentFrame && (this._previousFrame = currentFrame, this._texture = this._textures[currentFrame], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));\n  }\n  /**\n   * Stops the AnimatedSprite and destroys it.\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy\n   *      method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.\n   */\n  destroy(options) {\n    this.stop(), super.destroy(options), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n   * @returns - The new animated sprite with the specified frames.\n   */\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i)\n      textures.push(Texture.from(frames[i]));\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image ids.\n   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n   * @returns The new animate sprite with the specified images as frames.\n   */\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i)\n      textures.push(Texture.from(images[i]));\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * The total number of frames in the AnimatedSprite. This is the same as number of textures\n   * assigned to the AnimatedSprite.\n   * @readonly\n   * @default 0\n   */\n  get totalFrames() {\n    return this._textures.length;\n  }\n  /** The array of textures used for this AnimatedSprite. */\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture)\n      this._textures = value, this._durations = null;\n    else {\n      this._textures = [], this._durations = [];\n      for (let i = 0; i < value.length; i++)\n        this._textures.push(value[i].texture), this._durations.push(value[i].time);\n    }\n    this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();\n  }\n  /** The AnimatedSprite\'s current frame index. */\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    return currentFrame < 0 && (currentFrame += this._textures.length), currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1)\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    const previousFrame = this.currentFrame;\n    this._currentTime = value, previousFrame !== this.currentFrame && this.updateTexture();\n  }\n  /**\n   * Indicates if the AnimatedSprite is currently playing.\n   * @readonly\n   */\n  get playing() {\n    return this._playing;\n  }\n  /** Whether to use Ticker.shared to auto update animation time. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    value !== this._autoUpdate && (this._autoUpdate = value, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n  }\n}\n\n//# sourceMappingURL=AnimatedSprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs\n\n\nconst TilingSprite_tempPoint = new Point();\nclass TilingSprite extends (/* unused pure expression or super */ null && (Sprite)) {\n  /**\n   * Note: The wrap mode of the texture is forced to REPEAT on render if the size of the texture\n   * is a power of two, the texture\'s wrap mode is CLAMP, and the texture hasn\'t been bound yet.\n   * @param texture - The texture of the tiling sprite.\n   * @param width - The width of the tiling sprite.\n   * @param height - The height of the tiling sprite.\n   */\n  constructor(texture, width = 100, height = 100) {\n    super(texture), this.tileTransform = new Transform(), this._width = width, this._height = height, this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1;\n  }\n  /**\n   * Changes frame clamping in corresponding textureTransform, shortcut\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   * @default 0.5\n   * @member {number}\n   */\n  get clampMargin() {\n    return this.uvMatrix.clampMargin;\n  }\n  set clampMargin(value) {\n    this.uvMatrix.clampMargin = value, this.uvMatrix.update(!0);\n  }\n  /** The scaling of the image that is being tiled. */\n  get tileScale() {\n    return this.tileTransform.scale;\n  }\n  set tileScale(value) {\n    this.tileTransform.scale.copyFrom(value);\n  }\n  /** The offset of the image that is being tiled. */\n  get tilePosition() {\n    return this.tileTransform.position;\n  }\n  set tilePosition(value) {\n    this.tileTransform.position.copyFrom(value);\n  }\n  /**\n   * @protected\n   */\n  _onTextureUpdate() {\n    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  _render(renderer) {\n    const texture = this._texture;\n    !texture || !texture.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this));\n  }\n  /** Updates the bounds of the tiling sprite. */\n  _calculateBounds() {\n    const minX = this._width * -this._anchor._x, minY = this._height * -this._anchor._y, maxX = this._width * (1 - this._anchor._x), maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  /**\n   * Gets the local bounds of the sprite object.\n   * @param rect - Optional output rectangle.\n   * @returns The bounds.\n   */\n  getLocalBounds(rect) {\n    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._bounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);\n  }\n  /**\n   * Checks if a point is inside this tiling sprite.\n   * @param point - The point to check.\n   * @returns Whether or not the sprite contains the point.\n   */\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, TilingSprite_tempPoint);\n    const width = this._width, height = this._height, x1 = -width * this.anchor._x;\n    if (TilingSprite_tempPoint.x >= x1 && TilingSprite_tempPoint.x < x1 + width) {\n      const y1 = -height * this.anchor._y;\n      if (TilingSprite_tempPoint.y >= y1 && TilingSprite_tempPoint.y < y1 + height)\n        return !0;\n    }\n    return !1;\n  }\n  /**\n   * Destroys this sprite and optionally its texture and children\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n  destroy(options) {\n    super.destroy(options), this.tileTransform = null, this.uvMatrix = null;\n  }\n  /**\n   * Helper function that creates a new tiling sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @static\n   * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {object} options - See {@link PIXI.BaseTexture}\'s constructor for options.\n   * @param {number} options.width - required width of the tiling sprite\n   * @param {number} options.height - required height of the tiling sprite\n   * @returns {PIXI.TilingSprite} The newly created texture\n   */\n  static from(source, options) {\n    const texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new TilingSprite(\n      texture,\n      options.width,\n      options.height\n    );\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n  }\n  /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n  }\n}\n\n//# sourceMappingURL=TilingSprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.frag.mjs\nvar gl2FragmentSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n`;\n\n//# sourceMappingURL=sprite-tiling.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.vert.mjs\nvar gl2VertexSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`;\n\n//# sourceMappingURL=sprite-tiling.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.frag.mjs\nvar gl1FragmentSrc = `#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n`;\n\n//# sourceMappingURL=sprite-tiling-fallback.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.vert.mjs\nvar gl1VertexSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`;\n\n//# sourceMappingURL=sprite-tiling-fallback.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.frag.mjs\nvar fragmentSimpleSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n`;\n\n//# sourceMappingURL=sprite-tiling-simple.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs\n\n\n\n\n\n\nconst TilingSpriteRenderer_tempMat = new Matrix();\nclass TilingSpriteRenderer extends ObjectRenderer {\n  /**\n   * constructor for renderer\n   * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n   */\n  constructor(renderer) {\n    super(renderer), renderer.runners.contextChange.add(this), this.quad = new QuadUv(), this.state = State.for2d();\n  }\n  /** Creates shaders when context is initialized. */\n  contextChange() {\n    const renderer = this.renderer, uniforms = { globals: renderer.globalUniforms };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms), this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  }\n  /**\n   * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n   */\n  render(ts) {\n    const renderer = this.renderer, quad = this.quad;\n    let vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x, vertices[1] = vertices[3] = ts._height * -ts.anchor.y, vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x), vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0, anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs, vertices[0] = vertices[6] = -anchorX, vertices[1] = vertices[3] = -anchorY, vertices[2] = vertices[4] = 1 - anchorX, vertices[5] = vertices[7] = 1 - anchorY, quad.invalidate();\n    const tex = ts._texture, baseTex = tex.baseTexture, premultiplied = baseTex.alphaMode > 0, lt = ts.tileTransform.localTransform, uv = ts.uvMatrix;\n    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== lib_WRAP_MODES.CLAMP : baseTex.wrapMode === lib_WRAP_MODES.CLAMP && (baseTex.wrapMode = lib_WRAP_MODES.REPEAT));\n    const shader = isSimple ? this.simpleShader : this.shader, w = tex.width, h = tex.height, W = ts._width, H = ts._height;\n    TilingSpriteRenderer_tempMat.set(\n      lt.a * w / W,\n      lt.b * w / H,\n      lt.c * h / W,\n      lt.d * h / H,\n      lt.tx / W,\n      lt.ty / H\n    ), TilingSpriteRenderer_tempMat.invert(), isSimple ? TilingSpriteRenderer_tempMat.prepend(uv.mapCoord) : (shader.uniforms.uMapCoord = uv.mapCoord.toArray(!0), shader.uniforms.uClampFrame = uv.uClampFrame, shader.uniforms.uClampOffset = uv.uClampOffset), shader.uniforms.uTransform = TilingSpriteRenderer_tempMat.toArray(!0), shader.uniforms.uColor = Color_Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor), shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(!0), shader.uniforms.uSampler = tex, renderer.shader.bind(shader), renderer.geometry.bind(quad), this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied), renderer.state.set(this.state), renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }\n}\nTilingSpriteRenderer.extension = {\n  name: "tilingSprite",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(TilingSpriteRenderer);\n\n//# sourceMappingURL=TilingSpriteRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs\n\nconst _Spritesheet = class _Spritesheet2 {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   * @param resolutionFilename - The filename to consider when determining\n   *        the resolution of the spritesheet. If not provided, the imageUrl will\n   *        be used on the BaseTexture.\n   */\n  constructor(texture, data, resolutionFilename = null) {\n    this.linkedSheets = [], this._texture = texture instanceof Texture_Texture ? texture : null, this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = data;\n    const resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;\n  }\n  /**\n   * Generate the resolution from the filename or fallback\n   * to the meta.scale field of the JSON data.\n   * @param resolutionFilename - The filename to use for resolving\n   *        the default resolution.\n   * @returns Resolution to use for spritesheet.\n   */\n  _updateResolution(resolutionFilename = null) {\n    const { scale } = this.data.meta;\n    let resolution = getResolutionOfUrl(resolutionFilename, null);\n    return resolution === null && (resolution = typeof scale == "number" ? scale : parseFloat(scale ?? "1")), resolution !== 1 && this.baseTexture.setResolution(resolution), resolution;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   * @method PIXI.Spritesheet#parse\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve, this._batchIndex = 0, this._frameKeys.length <= _Spritesheet2.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet2.BATCH_SIZE;\n    for (; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length; ) {\n      const i = this._frameKeys[frameIndex], data = this._frames[i], rect = data.frame;\n      if (rect) {\n        let frame = null, trim = null;\n        const sourceSize = data.trimmed !== !1 && data.sourceSize ? data.sourceSize : data.frame, orig = new Rectangle_Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        data.rotated ? frame = new Rectangle_Rectangle(\n          Math.floor(rect.x) / this.resolution,\n          Math.floor(rect.y) / this.resolution,\n          Math.floor(rect.h) / this.resolution,\n          Math.floor(rect.w) / this.resolution\n        ) : frame = new Rectangle_Rectangle(\n          Math.floor(rect.x) / this.resolution,\n          Math.floor(rect.y) / this.resolution,\n          Math.floor(rect.w) / this.resolution,\n          Math.floor(rect.h) / this.resolution\n        ), data.trimmed !== !1 && data.spriteSourceSize && (trim = new Rectangle_Rectangle(\n          Math.floor(data.spriteSourceSize.x) / this.resolution,\n          Math.floor(data.spriteSourceSize.y) / this.resolution,\n          Math.floor(rect.w) / this.resolution,\n          Math.floor(rect.h) / this.resolution\n        )), this.textures[i] = new Texture_Texture(\n          this.baseTexture,\n          frame,\n          orig,\n          trim,\n          data.rotated ? 2 : 0,\n          data.anchor,\n          data.borders\n        ), Texture_Texture.addToCache(this.textures[i], i.toString());\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null, this._batchIndex = 0, callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE), this._batchIndex++, setTimeout(() => {\n      this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don\'t use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = !1) {\n    for (const i in this.textures)\n      this.textures[i].destroy();\n    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, destroyBase && (this._texture?.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];\n  }\n};\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs\n\n\n\nconst validImages = ["jpg", "png", "jpeg", "avif", "webp"];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  if (keys.forEach((key) => {\n    out[key] = asset;\n  }), Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  }), !ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, !0);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, !1)\n  },\n  /** Resolve the the resolution of the asset. */\n  resolver: {\n    test: (value) => {\n      const split = value.split("?")[0].split("."), extension = split.pop(), format = split.pop();\n      return extension === "json" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(".");\n      return {\n        resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into PIXI.Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   * @ignore\n   */\n  loader: {\n    name: "spritesheetLoader",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      let basePath = path.dirname(options.src);\n      basePath && basePath.lastIndexOf("/") !== basePath.length - 1 && (basePath += "/");\n      let imagePath = basePath + asset.meta.image;\n      imagePath = copySearchParams(imagePath, options.src);\n      const texture = (await loader.load([imagePath]))[imagePath], spritesheet = new Spritesheet(\n        texture.baseTexture,\n        asset,\n        options.src\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item != "string")\n            continue;\n          let itemUrl = basePath + item;\n          options.data?.ignoreMultiPack || (itemUrl = copySearchParams(itemUrl, options.src), promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: !0\n            }\n          })));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res, res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    unload(spritesheet) {\n      spritesheet.destroy(!0);\n    }\n  }\n};\nextensions.add(spritesheetAsset);\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs\nclass BitmapFontData {\n  constructor() {\n    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];\n  }\n}\n\n//# sourceMappingURL=BitmapFontData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs\n\nclass TextFormat {\n  /**\n   * Check if resource refers to txt font data.\n   * @param data\n   * @returns - True if resource could be treated as font data, false otherwise.\n   */\n  static test(data) {\n    return typeof data == "string" && data.startsWith("info face=");\n  }\n  /**\n   * Convert text font data to a javascript object.\n   * @param txt - Raw string data to be converted\n   * @returns - Parsed font data\n   */\n  static parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm), rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0], attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm), itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("="), key = split[0], strValue = split[1].replace(/"/gm, ""), floatValue = parseFloat(strValue), value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = new BitmapFontData();\n    return rawData.info.forEach((info) => font.info.push({\n      face: info.face,\n      size: parseInt(info.size, 10)\n    })), rawData.common.forEach((common) => font.common.push({\n      lineHeight: parseInt(common.lineHeight, 10)\n    })), rawData.page.forEach((page) => font.page.push({\n      id: parseInt(page.id, 10),\n      file: page.file\n    })), rawData.char.forEach((char) => font.char.push({\n      id: parseInt(char.id, 10),\n      page: parseInt(char.page, 10),\n      x: parseInt(char.x, 10),\n      y: parseInt(char.y, 10),\n      width: parseInt(char.width, 10),\n      height: parseInt(char.height, 10),\n      xoffset: parseInt(char.xoffset, 10),\n      yoffset: parseInt(char.yoffset, 10),\n      xadvance: parseInt(char.xadvance, 10)\n    })), rawData.kerning.forEach((kerning) => font.kerning.push({\n      first: parseInt(kerning.first, 10),\n      second: parseInt(kerning.second, 10),\n      amount: parseInt(kerning.amount, 10)\n    })), rawData.distanceField.forEach((df) => font.distanceField.push({\n      distanceRange: parseInt(df.distanceRange, 10),\n      fieldType: df.fieldType\n    })), font;\n  }\n}\n\n//# sourceMappingURL=TextFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs\n\nclass XMLFormat {\n  /**\n   * Check if resource refers to xml font data.\n   * @param data\n   * @returns - True if resource could be treated as font data, false otherwise.\n   */\n  static test(data) {\n    const xml = data;\n    return typeof data != "string" && "getElementsByTagName" in data && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  }\n  /**\n   * Convert the XML into BitmapFontData that we can use.\n   * @param xml\n   * @returns - Data to use for BitmapFont\n   */\n  static parse(xml) {\n    const data = new BitmapFontData(), info = xml.getElementsByTagName("info"), common = xml.getElementsByTagName("common"), page = xml.getElementsByTagName("page"), char = xml.getElementsByTagName("char"), kerning = xml.getElementsByTagName("kerning"), distanceField = xml.getElementsByTagName("distanceField");\n    for (let i = 0; i < info.length; i++)\n      data.info.push({\n        face: info[i].getAttribute("face"),\n        size: parseInt(info[i].getAttribute("size"), 10)\n      });\n    for (let i = 0; i < common.length; i++)\n      data.common.push({\n        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)\n      });\n    for (let i = 0; i < page.length; i++)\n      data.page.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    for (let i = 0; i < char.length; i++) {\n      const letter = char[i];\n      data.char.push({\n        id: parseInt(letter.getAttribute("id"), 10),\n        page: parseInt(letter.getAttribute("page"), 10) || 0,\n        x: parseInt(letter.getAttribute("x"), 10),\n        y: parseInt(letter.getAttribute("y"), 10),\n        width: parseInt(letter.getAttribute("width"), 10),\n        height: parseInt(letter.getAttribute("height"), 10),\n        xoffset: parseInt(letter.getAttribute("xoffset"), 10),\n        yoffset: parseInt(letter.getAttribute("yoffset"), 10),\n        xadvance: parseInt(letter.getAttribute("xadvance"), 10)\n      });\n    }\n    for (let i = 0; i < kerning.length; i++)\n      data.kerning.push({\n        first: parseInt(kerning[i].getAttribute("first"), 10),\n        second: parseInt(kerning[i].getAttribute("second"), 10),\n        amount: parseInt(kerning[i].getAttribute("amount"), 10)\n      });\n    for (let i = 0; i < distanceField.length; i++)\n      data.distanceField.push({\n        fieldType: distanceField[i].getAttribute("fieldType"),\n        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)\n      });\n    return data;\n  }\n}\n\n//# sourceMappingURL=XMLFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs\n\n\nclass XMLStringFormat {\n  /**\n   * Check if resource refers to text xml font data.\n   * @param data\n   * @returns - True if resource could be treated as font data, false otherwise.\n   */\n  static test(data) {\n    return typeof data == "string" && data.includes("<font>") ? XMLFormat.test(settings.ADAPTER.parseXML(data)) : !1;\n  }\n  /**\n   * Convert the text XML into BitmapFontData that we can use.\n   * @param xmlTxt\n   * @returns - Data to use for BitmapFont\n   */\n  static parse(xmlTxt) {\n    return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));\n  }\n}\n\n//# sourceMappingURL=XMLStringFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/index.mjs\n\n\n\nconst formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(data) {\n  for (let i = 0; i < formats.length; i++)\n    if (formats[i].test(data))\n      return formats[i];\n  return null;\n}\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs\n\nfunction generateFillStyle(canvas, context, style, resolution, lines, metrics) {\n  const fillStyle = style.fill;\n  if (Array.isArray(fillStyle)) {\n    if (fillStyle.length === 1)\n      return fillStyle[0];\n  } else\n    return fillStyle;\n  let gradient;\n  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = canvas.width / resolution - dropShadowCorrection - padding * 2, height = canvas.height / resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();\n  if (!fillGradientStops.length) {\n    const lengthPlus1 = fill.length + 1;\n    for (let i = 1; i < lengthPlus1; ++i)\n      fillGradientStops.push(i / lengthPlus1);\n  }\n  if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n    let lastIterationStop = 0;\n    const gradStopLineHeight = (metrics.fontProperties.fontSize + style.strokeThickness) / height;\n    for (let i = 0; i < lines.length; i++) {\n      const thisLineTop = metrics.lineHeight * i;\n      for (let j = 0; j < fill.length; j++) {\n        let lineStop = 0;\n        typeof fillGradientStops[j] == "number" ? lineStop = fillGradientStops[j] : lineStop = j / fill.length;\n        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;\n        let clampedStop = Math.max(lastIterationStop, globalStop);\n        clampedStop = Math.min(clampedStop, 1), gradient.addColorStop(clampedStop, fill[j]), lastIterationStop = clampedStop;\n      }\n    }\n  } else {\n    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n    const totalIterations = fill.length + 1;\n    let currentIteration = 1;\n    for (let i = 0; i < fill.length; i++) {\n      let stop;\n      typeof fillGradientStops[i] == "number" ? stop = fillGradientStops[i] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i]), currentIteration++;\n    }\n  }\n  return gradient;\n}\n\n//# sourceMappingURL=generateFillStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs\n\n\nfunction drawGlyph(canvas, context, metrics, x, y, resolution, style) {\n  const char = metrics.text, fontProperties = metrics.fontProperties;\n  context.translate(x, y), context.scale(resolution, resolution);\n  const tx = style.strokeThickness / 2, ty = -(style.strokeThickness / 2);\n  if (context.font = style.toFontString(), context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit, context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics), context.strokeStyle = style.stroke, style.dropShadow) {\n    const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * resolution, dropShadowDistance = style.dropShadowDistance * resolution;\n    context.shadowColor = Color_Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context.shadowBlur = dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n  } else\n    context.shadowColor = "black", context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0;\n  style.stroke && style.strokeThickness && context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent), style.fill && context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent), context.setTransform(1, 0, 0, 1, 0, 0), context.fillStyle = "rgba(0, 0, 0, 0)";\n}\n\n//# sourceMappingURL=drawGlyph.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs\nfunction splitTextToCharacters(text) {\n  return Array.from ? Array.from(text) : text.split("");\n}\n\n//# sourceMappingURL=splitTextToCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  typeof chars == "string" && (chars = [chars]);\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2)\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      const startCode = item[0].charCodeAt(0), endCode = item[1].charCodeAt(0);\n      if (endCode < startCode)\n        throw new Error("[BitmapFont]: Invalid character range.");\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++)\n        result.push(String.fromCharCode(i2));\n    } else\n      result.push(...splitTextToCharacters(item));\n  }\n  if (result.length === 0)\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  return result;\n}\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs\nfunction extractCharCode(str) {\n  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);\n}\n\n//# sourceMappingURL=extractCharCode.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs\n\n\n\n\n\n\n\n\nconst _BitmapFont = class _BitmapFont2 {\n  /**\n   * @param data\n   * @param textures\n   * @param ownsTextures - Setting to `true` will destroy page textures\n   *        when the font is uninstalled.\n   */\n  constructor(data, textures, ownsTextures) {\n    const [info] = data.info, [common] = data.common, [page] = data.page, [distanceField] = data.distanceField, res = getResolutionOfUrl(page.file), pageTextures = {};\n    this._ownsTextures = ownsTextures, this.font = info.face, this.size = info.size, this.lineHeight = common.lineHeight / res, this.chars = {}, this.pageTextures = pageTextures;\n    for (let i = 0; i < data.page.length; i++) {\n      const { id, file } = data.page[i];\n      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file], distanceField?.fieldType && distanceField.fieldType !== "none" && (pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF);\n    }\n    for (let i = 0; i < data.char.length; i++) {\n      const { id, page: page2 } = data.char[i];\n      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];\n      x /= res, y /= res, width /= res, height /= res, xoffset /= res, yoffset /= res, xadvance /= res;\n      const rect = new Rectangle_Rectangle(\n        x + pageTextures[page2].frame.x / res,\n        y + pageTextures[page2].frame.y / res,\n        width,\n        height\n      );\n      this.chars[id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new Texture_Texture(\n          pageTextures[page2].baseTexture,\n          rect\n        ),\n        page: page2\n      };\n    }\n    for (let i = 0; i < data.kerning.length; i++) {\n      let { first, second, amount } = data.kerning[i];\n      first /= res, second /= res, amount /= res, this.chars[second] && (this.chars[second].kerning[first] = amount);\n    }\n    this.distanceFieldRange = distanceField?.distanceRange, this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";\n  }\n  /** Remove references to created glyph textures. */\n  destroy() {\n    for (const id in this.chars)\n      this.chars[id].texture.destroy(), this.chars[id].texture = null;\n    for (const id in this.pageTextures)\n      this._ownsTextures && this.pageTextures[id].destroy(!0), this.pageTextures[id] = null;\n    this.chars = null, this.pageTextures = null;\n  }\n  /**\n   * Register a new bitmap font.\n   * @param data - The\n   *        characters map that could be provided as xml or raw string.\n   * @param textures - List of textures for each page.\n   * @param ownsTextures - Set to `true` to destroy page textures\n   *        when the font is uninstalled. By default fonts created with\n   *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.\n   * @returns {PIXI.BitmapFont} Result font object with font, size, lineHeight\n   *         and char fields.\n   */\n  static install(data, textures, ownsTextures) {\n    let fontData;\n    if (data instanceof BitmapFontData)\n      fontData = data;\n    else {\n      const format = autoDetectFormat(data);\n      if (!format)\n        throw new Error("Unrecognized data format for font.");\n      fontData = format.parse(data);\n    }\n    textures instanceof Texture_Texture && (textures = [textures]);\n    const font = new _BitmapFont2(fontData, textures, ownsTextures);\n    return _BitmapFont2.available[font.font] = font, font;\n  }\n  /**\n   * Remove bitmap font by name.\n   * @param name - Name of the font to uninstall.\n   */\n  static uninstall(name) {\n    const font = _BitmapFont2.available[name];\n    if (!font)\n      throw new Error(`No font found named \'${name}\'`);\n    font.destroy(), delete _BitmapFont2.available[name];\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set. This does not support\n   * kernings yet. With `style` properties, only the following non-layout properties are used:\n   *\n   * - {@link PIXI.TextStyle#dropShadow|dropShadow}\n   * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}\n   * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}\n   * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}\n   * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}\n   * - {@link PIXI.TextStyle#fill|fill}\n   * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}\n   * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}\n   * - {@link PIXI.TextStyle#fontFamily|fontFamily}\n   * - {@link PIXI.TextStyle#fontSize|fontSize}\n   * - {@link PIXI.TextStyle#fontVariant|fontVariant}\n   * - {@link PIXI.TextStyle#fontWeight|fontWeight}\n   * - {@link PIXI.TextStyle#lineJoin|lineJoin}\n   * - {@link PIXI.TextStyle#miterLimit|miterLimit}\n   * - {@link PIXI.TextStyle#stroke|stroke}\n   * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}\n   * - {@link PIXI.TextStyle#textBaseline|textBaseline}\n   * @param name - The name of the custom font to use with BitmapText.\n   * @param textStyle - Style options to render with BitmapFont.\n   * @param options - Setup options for font or name of the font.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from \'pixi.js\';\n   *\n   * BitmapFont.from(\'TitleFont\', {\n   *     fontFamily: \'Arial\',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: \'purple\',\n   * });\n   *\n   * const title = new BitmapText(\'This is the title\', { fontName: \'TitleFont\' });\n   */\n  static from(name, textStyle, options) {\n    if (!name)\n      throw new Error("[BitmapFont] Property `name` is required.");\n    const {\n      chars,\n      padding,\n      resolution,\n      textureWidth,\n      textureHeight,\n      ...baseOptions\n    } = Object.assign({}, _BitmapFont2.defaultOptions, options), charsList = resolveCharacters(chars), style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle), lineWidth = textureWidth, fontData = new BitmapFontData();\n    fontData.info[0] = {\n      face: style.fontFamily,\n      size: style.fontSize\n    }, fontData.common[0] = {\n      lineHeight: style.fontSize\n    };\n    let positionX = 0, positionY = 0, canvas, context, baseTexture, maxCharHeight = 0;\n    const baseTextures = [], textures = [];\n    for (let i = 0; i < charsList.length; i++) {\n      canvas || (canvas = settings.ADAPTER.createCanvas(), canvas.width = textureWidth, canvas.height = textureHeight, context = canvas.getContext("2d"), baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions }), baseTextures.push(baseTexture), textures.push(new Texture_Texture(baseTexture)), fontData.page.push({\n        id: textures.length - 1,\n        file: ""\n      }));\n      const character = charsList[i], metrics = TextMetrics.measureText(character, style, !1, canvas), width = metrics.width, height = Math.ceil(metrics.height), textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);\n      if (positionY >= textureHeight - height * resolution) {\n        if (positionY === 0)\n          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: \'${style.fontFamily}\', fontSize: ${style.fontSize}px, char: \'${character}\')`);\n        --i, canvas = null, context = null, baseTexture = null, positionY = 0, positionX = 0, maxCharHeight = 0;\n        continue;\n      }\n      if (maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight), textureGlyphWidth * resolution + positionX >= lineWidth) {\n        if (positionX === 0)\n          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: \'${style.fontFamily}\', fontSize: ${style.fontSize}px, char: \'${character}\')`);\n        --i, positionY += maxCharHeight * resolution, positionY = Math.ceil(positionY), positionX = 0, maxCharHeight = 0;\n        continue;\n      }\n      drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n      const id = extractCharCode(metrics.text);\n      fontData.char.push({\n        id,\n        page: textures.length - 1,\n        x: positionX / resolution,\n        y: positionY / resolution,\n        width: textureGlyphWidth,\n        height,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)\n      }), positionX += (textureGlyphWidth + 2 * padding) * resolution, positionX = Math.ceil(positionX);\n    }\n    if (!options?.skipKerning)\n      for (let i = 0, len = charsList.length; i < len; i++) {\n        const first = charsList[i];\n        for (let j = 0; j < len; j++) {\n          const second = charsList[j], c1 = context.measureText(first).width, c2 = context.measureText(second).width, amount = context.measureText(first + second).width - (c1 + c2);\n          amount && fontData.kerning.push({\n            first: extractCharCode(first),\n            second: extractCharCode(second),\n            amount\n          });\n        }\n      }\n    const font = new _BitmapFont2(fontData, textures, !0);\n    return _BitmapFont2.available[name] !== void 0 && _BitmapFont2.uninstall(name), _BitmapFont2.available[name] = font, font;\n  }\n};\n_BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "], /**\n* This character set includes all decimal digits (from 0 to 9).\n* @type {string[][]}\n* @example\n* BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n*/\n_BitmapFont.NUMERIC = [["0", "9"]], /**\n* This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n* @type {string[][]}\n*/\n_BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], /**\n* This character set consists of all the ASCII table.\n* @member {string[][]}\n* @see http://www.asciitable.com/\n*/\n_BitmapFont.ASCII = [[" ", "~"]], /**\n* Collection of default options when using `BitmapFont.from`.\n* @property {number} [resolution=1] -\n* @property {number} [textureWidth=512] -\n* @property {number} [textureHeight=512] -\n* @property {number} [padding=4] -\n* @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC\n*/\n_BitmapFont.defaultOptions = {\n  resolution: 1,\n  textureWidth: 512,\n  textureHeight: 512,\n  padding: 4,\n  chars: _BitmapFont.ALPHANUMERIC\n}, /** Collection of available/installed fonts. */\n_BitmapFont.available = {};\nlet BitmapFont = _BitmapFont;\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf.frag.mjs\nvar msdfFrag = `// Pixi texture info\\r\nvarying vec2 vTextureCoord;\\r\nuniform sampler2D uSampler;\\r\n\\r\n// Tint\\r\nuniform vec4 uColor;\\r\n\\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\nuniform float uFWidth;\\r\n\\r\nvoid main(void) {\\r\n\\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\n\\r\n  // MSDF\\r\n  float median = texColor.r + texColor.g + texColor.b -\\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\n  // SDF\\r\n  median = min(median, texColor.a);\\r\n\\r\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\n  if (median < 0.01) {\\r\n    alpha = 0.0;\\r\n  } else if (median > 0.99) {\\r\n    alpha = 1.0;\\r\n  }\\r\n\\r\n  // Gamma correction for coverage-like alpha\\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\\r\n  float coverage = pow(uColor.a * alpha, gamma);  \\r\n\\r\n  // NPM Textures, NPM outputs\\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\\r\n}\\r\n`;\n\n//# sourceMappingURL=msdf.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf.vert.mjs\nvar msdfVert = `// Mesh material default fragment\\r\nattribute vec2 aVertexPosition;\\r\nattribute vec2 aTextureCoord;\\r\n\\r\nuniform mat3 projectionMatrix;\\r\nuniform mat3 translationMatrix;\\r\nuniform mat3 uTextureMatrix;\\r\n\\r\nvarying vec2 vTextureCoord;\\r\n\\r\nvoid main(void)\\r\n{\\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\n\\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\n}\\r\n`;\n\n//# sourceMappingURL=msdf.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs\n\n\n\n\n\n\n\n\n\nconst pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [], _BitmapText = class _BitmapText2 extends Container_Container {\n  /**\n   * @param text - A string that you would like the text to display.\n   * @param style - The style parameters.\n   * @param {string} style.fontName - The installed BitmapFont name.\n   * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n   *.     this will default to the BitmapFont size.\n   * @param {string} [style.align=\'left\'] - Alignment for multiline text (\'left\', \'center\', \'right\' or \'justify\'),\n   *      does not affect single line text.\n   * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.\n   * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n   * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n   */\n  constructor(text, style = {}) {\n    super();\n    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(\n      {},\n      _BitmapText2.styleDefaults,\n      style\n    );\n    if (!BitmapFont.available[fontName])\n      throw new Error(`Missing BitmapFont "${fontName}"`);\n    this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = align, this._tintColor = new Color_Color(tint), this._font = void 0, this._fontName = fontName, this._fontSize = fontSize, this.text = text, this._maxWidth = maxWidth, this._maxLineHeight = 0, this._letterSpacing = letterSpacing, this._anchor = new ObservablePoint(() => {\n      this.dirty = !0;\n    }, this, 0, 0), this._roundPixels = settings.ROUND_PIXELS, this.dirty = !0, this._resolution = settings.RESOLUTION, this._autoResolution = !0, this._textureCache = {};\n  }\n  /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n  updateText() {\n    const data = BitmapFont.available[this._fontName], fontSize = this.fontSize, scale = fontSize / data.size, pos = new Point(), chars = [], lineWidths = [], lineSpaces = [], text = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || " ", charsInput = splitTextToCharacters(text), maxWidth = this._maxWidth * data.size / fontSize, pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    let prevCharCode = null, lastLineWidth = 0, maxLineWidth = 0, line = 0, lastBreakPos = -1, lastBreakWidth = 0, spacesRemoved = 0, maxLineHeight = 0, spaceCount = 0;\n    for (let i = 0; i < charsInput.length; i++) {\n      const char = charsInput[i], charCode = extractCharCode(char);\n      if (/(?:\\s)/.test(char) && (lastBreakPos = i, lastBreakWidth = lastLineWidth, spaceCount++), char === "\\r" || char === `\n`) {\n        lineWidths.push(lastLineWidth), lineSpaces.push(-1), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), ++line, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0;\n        continue;\n      }\n      const charData = data.chars[charCode];\n      if (!charData)\n        continue;\n      prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]);\n      const charRenderData = charRenderDataPool.pop() || {\n        texture: Texture_Texture.EMPTY,\n        line: 0,\n        charCode: 0,\n        prevSpaces: 0,\n        position: new Point()\n      };\n      charRenderData.texture = charData.texture, charRenderData.line = line, charRenderData.charCode = charCode, charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2), charRenderData.position.y = Math.round(pos.y + charData.yOffset), charRenderData.prevSpaces = spaceCount, chars.push(charRenderData), lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width), pos.x += charData.xAdvance + this._letterSpacing, maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height), prevCharCode = charCode, lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth && (++spacesRemoved, removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos), i = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0), maxLineWidth = Math.max(maxLineWidth, lastBreakWidth), line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0);\n    }\n    const lastChar = charsInput[charsInput.length - 1];\n    lastChar !== "\\r" && lastChar !== `\n` && (/(?:\\s)/.test(lastChar) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), lineSpaces.push(-1));\n    const lineAlignOffsets = [];\n    for (let i = 0; i <= line; i++) {\n      let alignOffset = 0;\n      this._align === "right" ? alignOffset = maxLineWidth - lineWidths[i] : this._align === "center" ? alignOffset = (maxLineWidth - lineWidths[i]) / 2 : this._align === "justify" && (alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i]), lineAlignOffsets.push(alignOffset);\n    }\n    const lenChars = chars.length, pagesMeshData = {}, newPagesMeshData = [], activePagesMeshData = this._activePagesMeshData;\n    pageMeshDataPool.push(...activePagesMeshData);\n    for (let i = 0; i < lenChars; i++) {\n      const texture = chars[i].texture, baseTextureUid = texture.baseTexture.uid;\n      if (!pagesMeshData[baseTextureUid]) {\n        let pageMeshData = pageMeshDataPool.pop();\n        if (!pageMeshData) {\n          const geometry = new MeshGeometry_MeshGeometry();\n          let material, meshBlendMode;\n          data.distanceFieldType === "none" ? (material = new MeshMaterial_MeshMaterial(Texture_Texture.EMPTY), meshBlendMode = lib_BLEND_MODES.NORMAL) : (material = new MeshMaterial_MeshMaterial(\n            Texture_Texture.EMPTY,\n            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }\n          ), meshBlendMode = lib_BLEND_MODES.NORMAL_NPM);\n          const mesh = new Mesh_Mesh(geometry, material);\n          mesh.blendMode = meshBlendMode, pageMeshData = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        pageMeshData.index = 0, pageMeshData.indexCount = 0, pageMeshData.vertexCount = 0, pageMeshData.uvsCount = 0, pageMeshData.total = 0;\n        const { _textureCache } = this;\n        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture_Texture(texture.baseTexture), pageMeshData.mesh.texture = _textureCache[baseTextureUid], pageMeshData.mesh.tint = this._tintColor.value, newPagesMeshData.push(pageMeshData), pagesMeshData[baseTextureUid] = pageMeshData;\n      }\n      pagesMeshData[baseTextureUid].total++;\n    }\n    for (let i = 0; i < activePagesMeshData.length; i++)\n      newPagesMeshData.includes(activePagesMeshData[i]) || this.removeChild(activePagesMeshData[i].mesh);\n    for (let i = 0; i < newPagesMeshData.length; i++)\n      newPagesMeshData[i].mesh.parent !== this && this.addChild(newPagesMeshData[i].mesh);\n    this._activePagesMeshData = newPagesMeshData;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i], total = pageMeshData.total;\n      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh_Mesh.BATCHABLE_SIZE * 2)\n        pageMeshData.vertices = new Float32Array(4 * 2 * total), pageMeshData.uvs = new Float32Array(4 * 2 * total), pageMeshData.indices = new Uint16Array(6 * total);\n      else {\n        const total2 = pageMeshData.total, vertices = pageMeshData.vertices;\n        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++)\n          vertices[i2] = 0;\n      }\n      pageMeshData.mesh.size = 6 * total;\n    }\n    for (let i = 0; i < lenChars; i++) {\n      const char = chars[i];\n      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);\n      this._roundPixels && (offset = Math.round(offset));\n      const xPos = offset * scale, yPos = char.position.y * scale, texture = char.texture, pageMesh = pagesMeshData[texture.baseTexture.uid], textureFrame = texture.frame, textureUvs = texture._uvs, index = pageMesh.index++;\n      pageMesh.indices[index * 6 + 0] = 0 + index * 4, pageMesh.indices[index * 6 + 1] = 1 + index * 4, pageMesh.indices[index * 6 + 2] = 2 + index * 4, pageMesh.indices[index * 6 + 3] = 0 + index * 4, pageMesh.indices[index * 6 + 4] = 2 + index * 4, pageMesh.indices[index * 6 + 5] = 3 + index * 4, pageMesh.vertices[index * 8 + 0] = xPos, pageMesh.vertices[index * 8 + 1] = yPos, pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 3] = yPos, pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale, pageMesh.vertices[index * 8 + 6] = xPos, pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale, pageMesh.uvs[index * 8 + 0] = textureUvs.x0, pageMesh.uvs[index * 8 + 1] = textureUvs.y0, pageMesh.uvs[index * 8 + 2] = textureUvs.x1, pageMesh.uvs[index * 8 + 3] = textureUvs.y1, pageMesh.uvs[index * 8 + 4] = textureUvs.x2, pageMesh.uvs[index * 8 + 5] = textureUvs.y2, pageMesh.uvs[index * 8 + 6] = textureUvs.x3, pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n    }\n    this._textWidth = maxLineWidth * scale, this._textHeight = (pos.y + data.lineHeight) * scale;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n        let vertexCount = 0;\n        const anchorOffsetX = this._textWidth * this.anchor.x, anchorOffsetY = this._textHeight * this.anchor.y;\n        for (let i2 = 0; i2 < pageMeshData.total; i2++)\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n      }\n      this._maxLineHeight = maxLineHeight * scale;\n      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition"), textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord"), indexBuffer = pageMeshData.mesh.geometry.getIndex();\n      vertexBuffer.data = pageMeshData.vertices, textureBuffer.data = pageMeshData.uvs, indexBuffer.data = pageMeshData.indices, vertexBuffer.update(), textureBuffer.update(), indexBuffer.update();\n    }\n    for (let i = 0; i < chars.length; i++)\n      charRenderDataPool.push(chars[i]);\n    this._font = data, this.dirty = !1;\n  }\n  updateTransform() {\n    this.validate(), this.containerUpdateTransform();\n  }\n  _render(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);\n    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n    if (distanceFieldType !== "none") {\n      const { a, b, c, d } = this.worldTransform, dx = Math.sqrt(a * a + b * b), dy = Math.sqrt(c * c + d * d), worldScale = (Math.abs(dx) + Math.abs(dy)) / 2, fontScale = this.fontSize / size, resolution = renderer._view.resolution;\n      for (const mesh of this._activePagesMeshData)\n        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n    }\n    super._render(renderer);\n  }\n  /**\n   * Validates text before calling parent\'s getLocalBounds\n   * @returns - The rectangular bounding area\n   */\n  getLocalBounds() {\n    return this.validate(), super.getLocalBounds();\n  }\n  /**\n   * Updates text when needed\n   * @private\n   */\n  validate() {\n    const font = BitmapFont.available[this._fontName];\n    if (!font)\n      throw new Error(`Missing BitmapFont "${this._fontName}"`);\n    this._font !== font && (this.dirty = !0), this.dirty && this.updateText();\n  }\n  /**\n   * The tint of the BitmapText object.\n   * @default 0xffffff\n   */\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    if (this.tint !== value) {\n      this._tintColor.setValue(value);\n      for (let i = 0; i < this._activePagesMeshData.length; i++)\n        this._activePagesMeshData[i].mesh.tint = value;\n    }\n  }\n  /**\n   * The alignment of the BitmapText object.\n   * @member {string}\n   * @default \'left\'\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align !== value && (this._align = value, this.dirty = !0);\n  }\n  /** The name of the BitmapFont. */\n  get fontName() {\n    return this._fontName;\n  }\n  set fontName(value) {\n    if (!BitmapFont.available[value])\n      throw new Error(`Missing BitmapFont "${value}"`);\n    this._fontName !== value && (this._fontName = value, this.dirty = !0);\n  }\n  /** The size of the font to display. */\n  get fontSize() {\n    return this._fontSize ?? BitmapFont.available[this._fontName].size;\n  }\n  set fontSize(value) {\n    this._fontSize !== value && (this._fontSize = value, this.dirty = !0);\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   *\n   * The default is `(0,0)`, this means the text\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text\'s origin point will be the bottom right corner.\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value == "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The text of the BitmapText object. */\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = !0);\n  }\n  /**\n   * The max width of this bitmap text in pixels. If the text provided is longer than the\n   * value provided, line breaks will be automatically inserted in the last whitespace.\n   * Disable by setting the value to 0.\n   */\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  set maxWidth(value) {\n    this._maxWidth !== value && (this._maxWidth = value, this.dirty = !0);\n  }\n  /**\n   * The max line height. This is useful when trying to use the total height of the Text,\n   * i.e. when trying to vertically align.\n   * @readonly\n   */\n  get maxLineHeight() {\n    return this.validate(), this._maxLineHeight;\n  }\n  /**\n   * The width of the overall text, different from fontSize,\n   * which is defined in the style object.\n   * @readonly\n   */\n  get textWidth() {\n    return this.validate(), this._textWidth;\n  }\n  /** Additional space between characters. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = !0);\n  }\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n   * @default PIXI.settings.ROUND_PIXELS\n   */\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  set roundPixels(value) {\n    value !== this._roundPixels && (this._roundPixels = value, this.dirty = !0);\n  }\n  /**\n   * The height of the overall text, different from fontSize,\n   * which is defined in the style object.\n   * @readonly\n   */\n  get textHeight() {\n    return this.validate(), this._textHeight;\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   *\n   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n   * @default 1\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n  }\n  destroy(options) {\n    const { _textureCache } = this, pageMeshDataPool = BitmapFont.available[this._fontName].distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    pageMeshDataPool.push(...this._activePagesMeshData);\n    for (const pageMeshData of this._activePagesMeshData)\n      this.removeChild(pageMeshData.mesh);\n    this._activePagesMeshData = [], pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {\n      page.mesh.texture = Texture_Texture.EMPTY;\n    });\n    for (const id in _textureCache)\n      _textureCache[id].destroy(), delete _textureCache[id];\n    this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(options);\n  }\n};\n_BitmapText.styleDefaults = {\n  align: "left",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\nlet BitmapText = (/* unused pure expression or super */ null && (_BitmapText));\n\n//# sourceMappingURL=BitmapText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs\n\n\n\n\n\n\nconst validExtensions = [".xml", ".fnt"], loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  name: "loadBitmapFont",\n  test(url) {\n    return validExtensions.includes(path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return TextFormat.test(data) || XMLStringFormat.test(data);\n  },\n  async parse(asset, data, loader) {\n    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset), { src } = data, { page: pages } = fontData, textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.join(path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src), textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls), textures = textureUrls.map((url) => loadedTextures[url]);\n    return BitmapFont.install(fontData, textures, !0);\n  },\n  async load(url, _options) {\n    return (await settings.ADAPTER.fetch(url)).text();\n  },\n  unload(bitmapFont) {\n    bitmapFont.destroy();\n  }\n};\nextensions.add(loadBitmapFont);\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs\n\n\nconst _HTMLTextStyle = class _HTMLTextStyle2 extends TextStyle {\n  constructor() {\n    super(...arguments), this._fonts = [], this._overrides = [], this._stylesheet = "", this.fontsDirty = !1;\n  }\n  /**\n   * Convert a TextStyle to HTMLTextStyle\n   * @param originalStyle\n   * @example\n   * import {TextStyle } from \'pixi.js\';\n   * import {HTMLTextStyle} from \'@pixi/text-html\';\n   * const style = new TextStyle();\n   * const htmlStyle = HTMLTextStyle.from(style);\n   */\n  static from(originalStyle) {\n    return new _HTMLTextStyle2(\n      Object.keys(_HTMLTextStyle2.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {})\n    );\n  }\n  /** Clear the current font */\n  cleanFonts() {\n    this._fonts.length > 0 && (this._fonts.forEach((font) => {\n      URL.revokeObjectURL(font.src), font.refs--, font.refs === 0 && (font.fontFace && document.fonts.delete(font.fontFace), delete _HTMLTextStyle2.availableFonts[font.originalUrl]);\n    }), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = !0);\n  }\n  /**\n   * Because of how HTMLText renders, fonts need to be imported\n   * @param url\n   * @param options\n   */\n  loadFont(url, options = {}) {\n    const { availableFonts } = _HTMLTextStyle2;\n    if (availableFonts[url]) {\n      const font = availableFonts[url];\n      return this._fonts.push(font), font.refs++, this.styleID++, this.fontsDirty = !0, Promise.resolve();\n    }\n    return settings.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {\n      const src = URL.createObjectURL(blob), reader = new FileReader();\n      reader.onload = () => resolve([src, reader.result]), reader.onerror = reject, reader.readAsDataURL(blob);\n    })).then(async ([src, dataSrc]) => {\n      const font = Object.assign({\n        family: path.basename(url, path.extname(url)),\n        weight: "normal",\n        style: "normal",\n        display: "auto",\n        src,\n        dataSrc,\n        refs: 1,\n        originalUrl: url,\n        fontFace: null\n      }, options);\n      availableFonts[url] = font, this._fonts.push(font), this.styleID++;\n      const fontFace = new FontFace(font.family, `url(${font.src})`, {\n        weight: font.weight,\n        style: font.style,\n        display: font.display\n      });\n      font.fontFace = fontFace, await fontFace.load(), document.fonts.add(fontFace), await document.fonts.ready, this.styleID++, this.fontsDirty = !0;\n    });\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride(\'background-color: red\');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this._overrides.includes(v));\n    toAdd.length > 0 && (this._overrides.push(...toAdd), this.styleID++);\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride(\'background-color: red\');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this._overrides.includes(v));\n    toRemove.length > 0 && (this._overrides = this._overrides.filter((v) => !toRemove.includes(v)), this.styleID++);\n  }\n  /**\n   * Internally converts all of the style properties into CSS equivalents.\n   * @param scale\n   * @returns The CSS style string, for setting `style` property of root HTMLElement.\n   */\n  toCSS(scale) {\n    return [\n      `transform: scale(${scale})`,\n      "transform-origin: top left",\n      "display: inline-block",\n      `color: ${this.normalizeColor(this.fill)}`,\n      `font-size: ${this.fontSize}px`,\n      `font-family: ${this.fontFamily}`,\n      `font-weight: ${this.fontWeight}`,\n      `font-style: ${this.fontStyle}`,\n      `font-variant: ${this.fontVariant}`,\n      `letter-spacing: ${this.letterSpacing}px`,\n      `text-align: ${this.align}`,\n      `padding: ${this.padding}px`,\n      `white-space: ${this.whiteSpace}`,\n      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],\n      ...this.wordWrap ? [\n        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,\n        `max-width: ${this.wordWrapWidth}px`\n      ] : [],\n      ...this.strokeThickness ? [\n        `-webkit-text-stroke-width: ${this.strokeThickness}px`,\n        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,\n        `text-stroke-width: ${this.strokeThickness}px`,\n        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,\n        "paint-order: stroke"\n      ] : [],\n      ...this.dropShadow ? [this.dropShadowToCSS()] : [],\n      ...this._overrides\n    ].join(";");\n  }\n  /** Get the font CSS styles from the loaded font, If available. */\n  toGlobalCSS() {\n    return this._fonts.reduce((result, font) => `${result}\n            @font-face {\n                font-family: "${font.family}";\n                src: url(\'${font.dataSrc}\');\n                font-weight: ${font.weight};\n                font-style: ${font.style};\n                font-display: ${font.display};\n            }`, this._stylesheet);\n  }\n  /** Internal stylesheet contents, useful for creating rules for rendering */\n  get stylesheet() {\n    return this._stylesheet;\n  }\n  set stylesheet(value) {\n    this._stylesheet !== value && (this._stylesheet = value, this.styleID++);\n  }\n  /**\n   * Convert numerical colors into hex-strings\n   * @param color\n   */\n  normalizeColor(color) {\n    return Array.isArray(color) && (color = rgb2hex(color)), typeof color == "number" ? hex2string(color) : color;\n  }\n  /** Convert the internal drop-shadow settings to CSS text-shadow */\n  dropShadowToCSS() {\n    let color = this.normalizeColor(this.dropShadowColor);\n    const alpha = this.dropShadowAlpha, x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance), y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);\n    color.startsWith("#") && alpha < 1 && (color += (alpha * 255 | 0).toString(16).padStart(2, "0"));\n    const position = `${x}px ${y}px`;\n    return this.dropShadowBlur > 0 ? `text-shadow: ${position} ${this.dropShadowBlur}px ${color}` : `text-shadow: ${position} ${color}`;\n  }\n  /** Resets all properties to the defaults specified in TextStyle.prototype._default */\n  reset() {\n    Object.assign(this, _HTMLTextStyle2.defaultOptions);\n  }\n  /**\n   * Called after the image is loaded but before drawing to the canvas.\n   * Mostly used to handle Safari\'s font loading bug.\n   * @ignore\n   */\n  onBeforeDraw() {\n    const { fontsDirty: prevFontsDirty } = this;\n    return this.fontsDirty = !1, this.isSafari && this._fonts.length > 0 && prevFontsDirty ? new Promise((resolve) => setTimeout(resolve, 100)) : Promise.resolve();\n  }\n  /**\n   * Proving that Safari is the new IE\n   * @ignore\n   */\n  get isSafari() {\n    const { userAgent } = settings.ADAPTER.getNavigator();\n    return /^((?!chrome|android).)*safari/i.test(userAgent);\n  }\n  set fillGradientStops(_value) {\n    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");\n  }\n  get fillGradientStops() {\n    return super.fillGradientStops;\n  }\n  set fillGradientType(_value) {\n    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");\n  }\n  get fillGradientType() {\n    return super.fillGradientType;\n  }\n  set miterLimit(_value) {\n    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");\n  }\n  get miterLimit() {\n    return super.miterLimit;\n  }\n  set trim(_value) {\n    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");\n  }\n  get trim() {\n    return super.trim;\n  }\n  set textBaseline(_value) {\n    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");\n  }\n  get textBaseline() {\n    return super.textBaseline;\n  }\n  set leading(_value) {\n    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");\n  }\n  get leading() {\n    return super.leading;\n  }\n  set lineJoin(_value) {\n    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");\n  }\n  get lineJoin() {\n    return super.lineJoin;\n  }\n};\n_HTMLTextStyle.availableFonts = {}, /**\n* List of default options, these are largely the same as TextStyle,\n* with the exception of whiteSpace, which is set to \'normal\' by default.\n*/\n_HTMLTextStyle.defaultOptions = {\n  /** Align */\n  align: "left",\n  /** Break words */\n  breakWords: !1,\n  /** Drop shadow */\n  dropShadow: !1,\n  /** Drop shadow alpha */\n  dropShadowAlpha: 1,\n  /**\n   * Drop shadow angle\n   * @type {number}\n   * @default Math.PI / 6\n   */\n  dropShadowAngle: Math.PI / 6,\n  /** Drop shadow blur */\n  dropShadowBlur: 0,\n  /** Drop shadow color */\n  dropShadowColor: "black",\n  /** Drop shadow distance */\n  dropShadowDistance: 5,\n  /** Fill */\n  fill: "black",\n  /** Font family */\n  fontFamily: "Arial",\n  /** Font size */\n  fontSize: 26,\n  /** Font style */\n  fontStyle: "normal",\n  /** Font variant */\n  fontVariant: "normal",\n  /** Font weight */\n  fontWeight: "normal",\n  /** Letter spacing */\n  letterSpacing: 0,\n  /** Line height */\n  lineHeight: 0,\n  /** Padding */\n  padding: 0,\n  /** Stroke */\n  stroke: "black",\n  /** Stroke thickness */\n  strokeThickness: 0,\n  /** White space */\n  whiteSpace: "normal",\n  /** Word wrap */\n  wordWrap: !1,\n  /** Word wrap width */\n  wordWrapWidth: 100\n};\nlet HTMLTextStyle = _HTMLTextStyle;\n\n//# sourceMappingURL=HTMLTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLText.mjs\n\n\n\n\nconst _HTMLText = class _HTMLText2 extends Sprite_Sprite {\n  /**\n   * @param {string} [text] - Text contents\n   * @param {PIXI.HTMLTextStyle|PIXI.TextStyle|PIXI.ITextStyle} [style] - Style setting to use.\n   *        Strongly recommend using an HTMLTextStyle object. Providing a PIXI.TextStyle\n   *        will convert the TextStyle to an HTMLTextStyle and will no longer be linked.\n   */\n  constructor(text = "", style = {}) {\n    super(Texture_Texture.EMPTY), this._text = null, this._style = null, this._autoResolution = !0, this.localStyleID = -1, this.dirty = !1, this._updateID = 0, this.ownsStyle = !1;\n    const image = new Image(), texture = Texture_Texture.from(image, {\n      scaleMode: settings.SCALE_MODE,\n      resourceOptions: {\n        autoLoad: !1\n      }\n    });\n    texture.orig = new Rectangle_Rectangle(), texture.trim = new Rectangle_Rectangle(), this.texture = texture;\n    const nssvg = "http://www.w3.org/2000/svg", nsxhtml = "http://www.w3.org/1999/xhtml", svgRoot = document.createElementNS(nssvg, "svg"), foreignObject = document.createElementNS(nssvg, "foreignObject"), domElement = document.createElementNS(nsxhtml, "div"), styleElement = document.createElementNS(nsxhtml, "style");\n    foreignObject.setAttribute("width", "10000"), foreignObject.setAttribute("height", "10000"), foreignObject.style.overflow = "hidden", svgRoot.appendChild(foreignObject), this.maxWidth = _HTMLText2.defaultMaxWidth, this.maxHeight = _HTMLText2.defaultMaxHeight, this._domElement = domElement, this._styleElement = styleElement, this._svgRoot = svgRoot, this._foreignObject = foreignObject, this._foreignObject.appendChild(styleElement), this._foreignObject.appendChild(domElement), this._image = image, this._loadImage = new Image(), this._autoResolution = _HTMLText2.defaultAutoResolution, this._resolution = _HTMLText2.defaultResolution ?? settings.RESOLUTION, this.text = text, this.style = style;\n  }\n  /**\n   * Calculate the size of the output text without actually drawing it.\n   * This includes the `padding` in the `style` object.\n   * This can be used as a fast-pass to do things like text-fitting.\n   * @param {object} [overrides] - Overrides for the text, style, and resolution.\n   * @param {string} [overrides.text] - The text to measure, if not specified, the current text is used.\n   * @param {PIXI.HTMLTextStyle} [overrides.style] - The style to measure, if not specified, the current style is used.\n   * @param {number} [overrides.resolution] - The resolution to measure, if not specified, the current resolution is used.\n   * @returns {PIXI.ISize} Width and height of the measured text.\n   */\n  measureText(overrides) {\n    const { text, style, resolution } = Object.assign({\n      text: this._text,\n      style: this._style,\n      resolution: this._resolution\n    }, overrides);\n    Object.assign(this._domElement, {\n      innerHTML: text,\n      style: style.toCSS(resolution)\n    }), this._styleElement.textContent = style.toGlobalCSS(), document.body.appendChild(this._svgRoot);\n    const contentBounds = this._domElement.getBoundingClientRect();\n    this._svgRoot.remove();\n    const { width, height } = contentBounds;\n    (width > this.maxWidth || height > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");\n    const contentWidth = Math.min(this.maxWidth, Math.ceil(width)), contentHeight = Math.min(this.maxHeight, Math.ceil(height));\n    return this._svgRoot.setAttribute("width", contentWidth.toString()), this._svgRoot.setAttribute("height", contentHeight.toString()), text !== this._text && (this._domElement.innerHTML = this._text), style !== this._style && (Object.assign(this._domElement, { style: this._style?.toCSS(resolution) }), this._styleElement.textContent = this._style?.toGlobalCSS()), {\n      width: contentWidth + style.padding * 2,\n      height: contentHeight + style.padding * 2\n    };\n  }\n  /**\n   * Manually refresh the text.\n   * @public\n   * @param {boolean} respectDirty - Whether to abort updating the\n   *        text if the Text isn\'t dirty and the function is called.\n   */\n  async updateText(respectDirty = !0) {\n    const { style, _image: image, _loadImage: loadImage } = this;\n    if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty)\n      return;\n    const { width, height } = this.measureText();\n    image.width = loadImage.width = Math.ceil(Math.max(1, width)), image.height = loadImage.height = Math.ceil(Math.max(1, height)), this._updateID++;\n    const updateID = this._updateID;\n    await new Promise((resolve) => {\n      loadImage.onload = async () => {\n        if (updateID < this._updateID) {\n          resolve();\n          return;\n        }\n        await style.onBeforeDraw(), image.src = loadImage.src, loadImage.onload = null, loadImage.src = "", this.updateTexture(), resolve();\n      };\n      const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n      loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n    });\n  }\n  /** The raw image element that is rendered under-the-hood. */\n  get source() {\n    return this._image;\n  }\n  /**\n   * Update the texture resource.\n   * @private\n   */\n  updateTexture() {\n    const { style, texture, _image: image, resolution } = this, { padding } = style, { baseTexture } = texture;\n    texture.trim.width = texture._frame.width = image.width / resolution, texture.trim.height = texture._frame.height = image.height / resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(image.width, image.height, resolution), this.dirty = !1;\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param {PIXI.Renderer} renderer - The renderer\n   * @private\n   */\n  _render(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);\n  }\n  /**\n   * Renders the object using the Canvas Renderer.\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  _renderCanvas(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._renderCanvas(renderer);\n  }\n  /**\n   * Get the local bounds.\n   * @param {PIXI.Rectangle} rect - Input rectangle.\n   * @returns {PIXI.Rectangle} Local bounds\n   */\n  getLocalBounds(rect) {\n    return this.updateText(!0), super.getLocalBounds(rect);\n  }\n  _calculateBounds() {\n    this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }\n  /**\n   * Handle dirty style changes\n   * @private\n   */\n  _onStyleChange() {\n    this.dirty = !0;\n  }\n  /**\n   * Destroy this Text object. Don\'t use after calling.\n   * @param {boolean|object} options - Same as Sprite destroy options.\n   */\n  destroy(options) {\n    typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, _HTMLText2.defaultDestroyOptions, options), super.destroy(options);\n    const forceClear = null;\n    this.ownsStyle && this._style?.cleanFonts(), this._style = forceClear, this._svgRoot?.remove(), this._svgRoot = forceClear, this._domElement?.remove(), this._domElement = forceClear, this._foreignObject?.remove(), this._foreignObject = forceClear, this._styleElement?.remove(), this._styleElement = forceClear, this._loadImage.src = "", this._loadImage.onload = null, this._loadImage = forceClear, this._image.src = "", this._image = forceClear;\n  }\n  /**\n   * Get the width in pixels.\n   * @member {number}\n   */\n  get width() {\n    return this.updateText(!0), Math.abs(this.scale.x) * this._image.width / this.resolution;\n  }\n  set width(value) {\n    this.updateText(!0);\n    const s = sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._image.width / this.resolution, this._width = value;\n  }\n  /**\n   * Get the height in pixels.\n   * @member {number}\n   */\n  get height() {\n    return this.updateText(!0), Math.abs(this.scale.y) * this._image.height / this.resolution;\n  }\n  set height(value) {\n    this.updateText(!0);\n    const s = sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._image.height / this.resolution, this._height = value;\n  }\n  /** The base style to render with text. */\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    this._style !== style && (style = style || {}, style instanceof HTMLTextStyle ? (this.ownsStyle = !1, this._style = style) : style instanceof TextStyle ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = !0, this._style = HTMLTextStyle.from(style)) : (this.ownsStyle = !0, this._style = new HTMLTextStyle(style)), this.localStyleID = -1, this.dirty = !0);\n  }\n  /**\n   * Contents of text. This can be HTML text and include tags.\n   * @example\n   * const text = new HTMLText(\'This is a <em>styled</em> text!\');\n   * @member {string}\n   */\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === "" || text === null || text === void 0 ? " " : text), text = this.sanitiseText(text), this._text !== text && (this._text = text, this.dirty = !0);\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n   * @member {number}\n   * @default 1\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n  }\n  /**\n   * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`\n   * @param text\n   * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3\n   */\n  sanitiseText(text) {\n    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");\n  }\n};\n_HTMLText.defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, /** Default maxWidth, set at construction */\n_HTMLText.defaultMaxWidth = 2024, /** Default maxHeight, set at construction */\n_HTMLText.defaultMaxHeight = 2024, /** Default autoResolution for all HTMLText objects */\n_HTMLText.defaultAutoResolution = !0;\nlet HTMLText = (/* unused pure expression or super */ null && (_HTMLText));\n\n//# sourceMappingURL=HTMLText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxh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SztBQUNWLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTCxLQUFLLEtBQUs7QUFDVixPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxLQUFLO0FBQ0wsS0FBSyxLQUFLO0FBQ1YsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsS0FBSztBQUNMLEtBQUssS0FBSztBQUNWLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTCxLQUFLLEtBQUs7QUFDVixPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxLQUFLO0FBQ0wsS0FBSyxLQUFLO0FBQ1YsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsT0FBTyxPQUFPO0FBQ2QsS0FBSztBQUNMLEtBQUssS0FBSztBQUNWLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTCxLQUFLLEtBQUs7QUFDVixPQUFPLE9BQU87QUFDZCxLQUFLO0FBQ0wsS0FBSyxLQUFLO0FBQ1YsT0FBTyxPQUFPO0FBQ2QsS0FBSztBQUNMLEtBQUssS0FBSztBQUNWLE9BQU8sT0FBTztBQUNkLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTCxLQUFLLEtBQUs7QUFDVixPQUFPLE9BQU87QUFDZCxLQUFLO0FBQ0wsS0FBSyxLQUFLO0FBQ1YsT0FBTyxPQUFPO0FBQ2QsS0FBSztBQUNMLEtBQUssS0FBSztBQUNWLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTCxLQUFLLEtBQUs7QUFDVixPQUFPLE9BQU87QUFDZDtBQUNBLElBQUk7QUFDSixLQUFLLEtBQUs7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUseUNBQXlDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdXQUF3VyxtQkFBUztBQUNqWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxtQkFBUyxrRkFBa0YsTUFBTTtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQy9zQjREO0FBRzFEO0FBQ0Y7OztBQ0pBLElBQUksMEJBQVE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQ3hCQSxJ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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBYTtBQUNqQixJQUFJLGFBQWE7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUdSO0FBQ0Y7OztBQ3RSbUM7QUFDVztBQUNFO0FBQ007QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBLCtHQUErRyxXQUFXO0FBQzFIO0FBQ0EsY0FBYyxnQkFBZ0IsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSx1QkFBdUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQSxXQUFXLG9DQUFvQztBQUMvQztBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQ3Jjd0U7QUFDbEM7QUFDTTtBQUNJO0FBQ0o7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQixhQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsb0JBQW9CLGVBQU87QUFDM0IsdUJBQXVCLG1CQUFTLHVCQUF1QixtQkFBUztBQUNoRTtBQUNBO0FBQ0EsS0FBSyxrREFBa0QsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBLElBQUksV0FBaUI7QUFDckI7QUFDQTtBQUNBLE9BQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFLO0FBQ25DLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVyx3Q0FBd0MsV0FBVyw4REFBOEQsY0FBYyx5Q0FBeUMsY0FBYztBQUN6TTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLG9LQUFvSyxhQUFhO0FBQ2pMO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUIsNkJBQTZCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CLFNBQVMsMkNBQTJDLFNBQVM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQ3pRNEM7QUFDVjtBQUNjO0FBQ0o7QUFNMUM7QUFDRjs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGOzs7QUN0QjJFO0FBQ2pDO0FBQ2dCO0FBQ1I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQyx1Q0FBdUMsZUFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5RkFBeUY7QUFDdEc7QUFDQSxvRUFBb0UseUNBQXlDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxhQUFNLGlDQUFpQyxxQkFBZTtBQUMzSyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxREFBcUQ7QUFDekY7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBTSxpQ0FBaUMscUJBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkZBQTJGO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdEQUFnRDtBQUNoRztBQUNBLHdCQUF3QixtQkFBUztBQUNqQyw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGOzs7QUNwSjZDO0FBQ007QUFDSDtBQUNoRCx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsS0FBSztBQUNMO0FBQ0EsTUFBTSxXQUFpQixnR0FBZ0csV0FBVztBQUNsSTtBQUNBO0FBQ0EsQ0FBQztBQUdDO0FBQ0Y7OztBQ3pCb0U7QUFDMUI7QUFDTTtBQUNoRDtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBLFVBQVUsVUFBVTtBQUNwQixrQkFBa0Isb0JBQW9CO0FBQ3RDLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBLFVBQVU7QUFHUjtBQUNGOzs7QUNyQ3dCO0FBQ3dCO0FBQ0U7QUFDVjtBQUNRO0FBTTlDO0FBQ0Y7OztBQ1g4RDtBQUN4QjtBQUN0Qyw2QkFBNkIsc0RBQU07QUFDbkM7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSw4REFBOEQsMkNBQTJDO0FBQ3pHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNLDZDQUE2QyxpQkFBaUI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDaEpzRDtBQUdwRDtBQUNGOzs7QUNKaUY7QUFDM0M7QUFDdEMsTUFBTSxzQkFBUyxPQUFPLEtBQUs7QUFDM0IsMkJBQTJCLHNEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFTO0FBQ3JEO0FBQ0EsUUFBUSxzQkFBUyxZQUFZLHNCQUFTO0FBQ3RDO0FBQ0EsVUFBVSxzQkFBUyxZQUFZLHNCQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBd0Q7QUFDckUsYUFBYSxRQUFRLGVBQWUsdUJBQXVCO0FBQzNELGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDbElBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0ZBQWtGOztBQUVsRjtBQUNBO0FBQ0E7QUFHRTtBQUNGOzs7QUM5QkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDckNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQ3hCQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDbkJnSTtBQUMxRTtBQUNGO0FBQ1c7QUFDRjtBQUNHO0FBQ2hFLE1BQU0sNEJBQU8sT0FBTyxNQUFNO0FBQzFCLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLCtFQUErRSxNQUFNLGlCQUFpQixLQUFLO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx3QkFBd0IsTUFBTSxNQUFNLFlBQVksRUFBRSxpQkFBaUIsK0RBQStELE1BQU0sTUFBTSxZQUFZLEVBQUUsY0FBYyxjQUFjLE1BQU0sTUFBTSxZQUFZLEVBQUUsY0FBYztBQUNoTztBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGNBQVUsOEJBQThCLGNBQVUsOEJBQThCLGNBQVU7QUFDdkw7QUFDQSxJQUFJLDRCQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0QkFBTyxzQkFBc0IsNEJBQU8sME1BQTBNLDRCQUFPLHVDQUF1QyxXQUFLLHFTQUFxUyxnQkFBc0I7QUFDbm1CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0EsVUFBVTtBQUdSO0FBQ0Y7OztBQ25Ea0Q7QUFDZ0I7QUFJaEU7QUFDRjs7O0FDTm9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGVBQU8seURBQXlELFdBQVcsMERBQTBELHNCQUFzQjtBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLHFCQUFxQixrQkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQW1GO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxtQkFBUztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG1CQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGOzs7QUN0SHNFO0FBQ0U7QUFDeEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsSUFBVTtBQUMvQjtBQUNBLDBDQUEwQyxTQUFTLEdBQUcsdUNBQXVDO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGdCQUFnQixvQkFBb0I7QUFDcEMsS0FBSztBQUNMO0FBQ0EsYUFBYSxJQUFVO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixJQUFVO0FBQy9CO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLHFGQUFxRixXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUdSO0FBQ0Y7OztBQ2xHZ0Q7QUFDVTtBQUl4RDtBQUNGOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDUnVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBR0U7QUFDRjs7O0FDbEV1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQy9Ec0M7QUFDTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTLE1BQU0sUUFBUTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxPQUFPLFFBQVE7QUFDbkM7QUFDQTtBQUdFO0FBQ0Y7OztBQ3ZCOEM7QUFDRjtBQUNZO0FBQ3hEO0FBQ0EsRUFBRSxVQUFVO0FBQ1osRUFBRSxTQUFTO0FBQ1gsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRjs7O0FDcEIyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxrS0FBa0ssYUFBYTtBQUMvSztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQzNDbUM7QUFDeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrTkFBK04saUJBQWlCO0FBQ2hQO0FBQ0EsMEJBQTBCLFdBQUs7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQ2hCNEM7QUFDWTtBQUNJO0FBQ0E7QUFDUTtBQU9sRTtBQUNGOzs7QUNaQTtBQUNBO0FBQ0E7QUFHRTtBQUNGOzs7QUNOb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFlBQVk7QUFDckc7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQSxNQUFNO0FBQ04scUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDeEJBO0FBQ0E7QUFDQTtBQUdFO0FBQ0Y7OztBQ055RztBQUNyRDtBQUNFO0FBQ0M7QUFDNUI7QUFDdUM7QUFDaEI7QUFDWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILGtCQUF3QjtBQUM5SSwrSUFBK0k7QUFDL0ksb0JBQW9CLHNCQUFzQjtBQUMxQyxjQUFjLFdBQVc7QUFDekIsK0xBQStMLFdBQVcsK0RBQStELFlBQVk7QUFDclI7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLGNBQWMsa0JBQWtCO0FBQ2hDLFlBQVksa0RBQWtEO0FBQzlEO0FBQ0EsdUJBQXVCLG1CQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixxQkFBcUIsZUFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5REFBeUQsdUJBQXVCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtCQUFrQixxREFBcUQsaUJBQWlCLHNDQUFzQyxTQUFTLG1CQUFtQixTQUFTLHNEQUFzRCxjQUFjO0FBQzdPO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsMEJBQTBCLFFBQVEsMElBQTBJLFdBQVcsV0FBVyw0QkFBNEIscURBQXFELGVBQU87QUFDMVI7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0Esd0RBQXdELGNBQWMsZ0NBQWdDLGlCQUFpQixlQUFlLGVBQWUsYUFBYSxVQUFVO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYSxnQ0FBZ0MsaUJBQWlCLGVBQWUsZUFBZSxhQUFhLFVBQVU7QUFDMUs7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTO0FBQ2YsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUdFO0FBQ0Y7OztBQ3hPQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvREFBb0Q7QUFDcEQsd0RBQXdEO0FBQ3hELHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIsSUFBSSx5QkFBeUI7QUFDN0IsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBDQUEwQztBQUMxQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxDQUFDO0FBQ0Q7QUFHRTtBQUNGOzs7QUMxQ0E7QUFDQSwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCO0FBQ0EsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLENBQUM7QUFDRCx5R0FBeUc7QUFDekc7QUFDQSxtRUFBbUU7QUFDbkUsQ0FBQztBQUNEO0FBR0U7QUFDRjs7O0FDcEIyRztBQUNqRTtBQUNvQjtBQUNoQjtBQUNBO0FBQ0E7QUFDbkI7QUFDK0M7QUFDWjtBQUM5RCxpSkFBaUosbUJBQVM7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxZQUFZLDJEQUEyRDtBQUN2RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CLDZDQUE2QyxTQUFTO0FBQ3RELDBIQUEwSCxXQUFLLGlOQUFpTixlQUFlO0FBQy9WO0FBQ0EsS0FBSyxtQ0FBbUMsUUFBUSxtREFBbUQsUUFBUTtBQUMzRztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVSw4RkFBOEYsS0FBSztBQUM5SCx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQyw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0EseXJCQUF5ckIsV0FBaUI7QUFDMXNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBWTtBQUMzQztBQUNBLDhEQUE4RCx5QkFBWSxDQUFDLGVBQU8seUJBQXlCLGVBQVcsMkJBQTJCLHlCQUFZO0FBQzdKLFlBQVksZUFBTztBQUNuQixjQUFjLFNBQVMsT0FBTyxNQUFNLFFBQVEsRUFBRSxRQUFRLGVBQWU7QUFDckUsNkJBQTZCLGVBQVc7QUFDeEMsMkJBQTJCLFNBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLDZFQUE2RSxlQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFNBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEMsRUFBRSxVQUFVO0FBQ3RFO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQiw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQiwyQkFBMkIsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFPO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFXO0FBRzFCO0FBQ0Y7OztBQ25Vc0U7QUFDRTtBQUMxQjtBQUNqQjtBQUN5QjtBQUNVO0FBQ2hFO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsY0FBYyxvQkFBb0I7QUFDbEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBVTtBQUM5QyxHQUFHO0FBQ0g7QUFDQSxXQUFXLFVBQVUsZUFBZSxlQUFlO0FBQ25ELEdBQUc7QUFDSDtBQUNBLHFCQUFxQixVQUFVLGVBQWUsVUFBVSxnQkFBZ0IsZUFBZSxpQkFBaUIsTUFBTSxVQUFVLGNBQWM7QUFDdEksb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHNCQUFzQixJQUFVLE1BQU0sSUFBVTtBQUNoRCxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUdSO0FBQ0Y7OztBQ3ZDOEM7QUFDUTtBQUNSO0FBQ2Y7QUFDd0I7QUFDRDtBQUNBO0FBQ0Y7QUFDWTtBQVU5RDtBQUNGOzs7QUNuQjZDO0FBQ047QUFDdkMscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUscUNBQXFDLEtBQUs7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLElBQVUsZUFBZSxJQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0Msb0JBQW9CLGNBQWM7QUFDbEMsc0JBQXNCLGdCQUFnQjtBQUN0QyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLHFCQUFxQixlQUFlO0FBQ3BDLHVCQUF1QixpQkFBaUI7QUFDeEMseUJBQXlCLG1CQUFtQjtBQUM1QyxxQkFBcUIsV0FBVztBQUNoQyxrQkFBa0IsYUFBYTtBQUMvQixzQkFBc0IsZ0JBQWdCO0FBQ3RDLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Qsc0NBQXNDLGlDQUFpQztBQUN2RSw4QkFBOEIscUJBQXFCO0FBQ25ELDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUMsNEJBQTRCLGFBQWE7QUFDekMsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQWEscUNBQXFDLFVBQWdCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLEtBQUssRUFBRTtBQUNqQyxxREFBcUQsVUFBVSxFQUFFLG9CQUFvQixLQUFLLE1BQU0sb0JBQW9CLFVBQVUsRUFBRSxNQUFNO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWSxFQUFFLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRjs7O0FDblJpRTtBQUMzQjtBQUNDO0FBQ2E7QUFDcEQsMkNBQTJDLGFBQU07QUFDakQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtREFBbUQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFVBQVUsZUFBTztBQUNqQix5Q0FBeUMsZUFBTztBQUNoRCxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLG1CQUFTLHVCQUF1QixtQkFBUztBQUNoRTtBQUNBLG9vQkFBb29CLFFBQVE7QUFDNW9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsUUFBUTtBQUNyQixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSx1UUFBdVEsdUNBQXVDO0FBQzlTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWUsMkJBQTJCO0FBQ3BGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQTRDLFVBQVUsVUFBVSxXQUFXLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUIsNkJBQTZCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUIsYUFBYSxpRUFBaUUsU0FBUyxzSUFBc0ksYUFBYSx3REFBd0QsYUFBYTtBQUNuWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFHdEI7QUFDRjs7O0FDak4wQztBQUNVO0FBSWxEO0FBQ0Y7OztBQ05xQztBQUNFO0FBQ0U7QUFDRDtBQUNKO0FBQ1Y7QUFDRztBQUNhO0FBQ2Y7QUFDRztBQUNEO0FBQ0M7QUFDSztBQUNEO0FBQ1E7QUFDQTtBQUNSO0FBQ0M7QUFDSjtBQUNKO0FBQ087QUFDTztBQUNYO0FBQ0Q7QUFDUztBQUNGO0FBQ0Y7QUFDUDtBQUNPO0FBQ0Y7QUFHOUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbnN0YW50cy9saWIvaW5kZXgubWpzPzBhNjMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL2FkYXB0ZXIubWpzPzE4MmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL3NldHRpbmdzLm1qcz81NzlhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2lzbW9iaWxlanMvc3JjL2lzTW9iaWxlLnRzP2FhOTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL3V0aWxzL2lzTW9iaWxlLm1qcz85NTdiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9pbmRleC5tanM/ODhiNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvc2V0dGluZ3MubWpzP2U5MTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzP2VlNTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL3VybC5tanM/ZDE2MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvcGF0aC5tanM/OWYyYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvYnJvd3Nlci9kZXRlY3RWaWRlb0FscGhhTW9kZS5tanM/YTJkOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvYnJvd3Nlci9oZWxsby5tanM/NDUzOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qcz83MDQ1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbG9yZC9pbmRleC5tanM/YzY0NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvcmQvcGx1Z2lucy9uYW1lcy5tanM/ODA3NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvci9saWIvQ29sb3IubWpzPzA3YzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3IvbGliL2luZGV4Lm1qcz84MGNkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9jb2xvci9oZXgubWpzP2VhZTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2NvbG9yL3ByZW11bHRpcGx5Lm1qcz8zMTUyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9jb25zdC5tanM/NTljYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9jcmVhdGVJbmRpY2VzRm9yUXVhZHMubWpzPzE2ZWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvZ2V0QnVmZmVyVHlwZS5tanM/YzI0MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzP2Y0YTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvcG93Mi5tanM/ZDM1MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9yZW1vdmVJdGVtcy5tanM/ZjYwNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9zaWduLm1qcz83ZTIzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL3VpZC5tanM/ZWM4MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvQm91bmRpbmdCb3gubWpzPzM0NWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL2NhY2hlcy5tanM/N2NmMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvQ2FudmFzUmVuZGVyVGFyZ2V0Lm1qcz80MDE0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9nZXRDYW52YXNCb3VuZGluZ0JveC5tanM/YmJhOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvdHJpbUNhbnZhcy5tanM/NWNhMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbmV0d29yay9kZWNvbXBvc2VEYXRhVXJpLm1qcz84NTFkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2RldGVybWluZUNyb3NzT3JpZ2luLm1qcz9jNDQ5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2dldFJlc29sdXRpb25PZlVybC5tanM/NWM4OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvaW5kZXgubWpzP2MxZTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXh0ZW5zaW9ucy9saWIvaW5kZXgubWpzP2ZlNTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIubWpzPzY4ZGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzPzdmZWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3RhdGUvU3RhdGUubWpzPzQyMmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5tanM/Y2U4OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ydW5uZXIvbGliL1J1bm5lci5tanM/Y2I3YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ydW5uZXIvbGliL2luZGV4Lm1qcz9iZDQxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9SZXNvdXJjZS5tanM/MjQ0NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQnVmZmVyUmVzb3VyY2UubWpzPzYzZjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvQmFzZVRleHR1cmUubWpzPzQ1ZGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hEcmF3Q2FsbC5tanM/NDNhMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9CdWZmZXIubWpzPzY1ZGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvQXR0cmlidXRlLm1qcz8yOGQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5tanM/ZTVmYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9HZW9tZXRyeS5tanM/MmFkYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaEdlb21ldHJ5Lm1qcz8xY2E3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2NvbnN0Lm1qcz8wNWFjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL1BvaW50Lm1qcz81OGFkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9SZWN0YW5nbGUubWpzP2JlYmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL0NpcmNsZS5tanM/OTRkMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvRWxsaXBzZS5tanM/MDdlNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvUG9seWdvbi5tanM/ZjVmOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanM/ZmFhMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9NYXRyaXgubWpzP2FiNzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvZ3JvdXBEOC5tanM/ZjllMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9PYnNlcnZhYmxlUG9pbnQubWpzPzYzM2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvVHJhbnNmb3JtLm1qcz9iZmVlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2luZGV4Lm1qcz9mNjI5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9kZWZhdWx0UHJvZ3JhbS5mcmFnLm1qcz9kYWZlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9kZWZhdWx0UHJvZ3JhbS52ZXJ0Lm1qcz8wNzM2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy91bmlmb3JtUGFyc2Vycy5tanM/NzI1ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzP2M4YTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldFRlc3RDb250ZXh0Lm1qcz9hYTlkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5tanM/NjliZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvbWFwU2l6ZS5tanM/NjUxZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvbWFwVHlwZS5tanM/YTgzYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvc2V0UHJlY2lzaW9uLm1qcz9iOWJlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9pbmRleC5tanM/MjM2MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvUHJvZ3JhbS5tanM/YzZkNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcz9hZWYxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9TaGFkZXIubWpzPzE2MGQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hTaGFkZXJHZW5lcmF0b3IubWpzPzBkNTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hUZXh0dXJlQXJyYXkubWpzP2NkNDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvY2FuVXBsb2FkU2FtZUJ1ZmZlci5tanM/OWI2OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcz84YWEwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL09iamVjdFJlbmRlcmVyLm1qcz81YjhkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUuZnJhZy5tanM/NTUxZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC90ZXh0dXJlLnZlcnQubWpzP2VmNjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hSZW5kZXJlci5tanM/MGIyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL2RlZmF1bHRGaWx0ZXIuZnJhZy5tanM/YjBmMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL2RlZmF1bHRGaWx0ZXIudmVydC5tanM/OTA2YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL0ZpbHRlci5tanM/YzIyNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzP2NkNDYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hTeXN0ZW0ubWpzP2QxZDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvY29udGV4dC9Db250ZXh0U3lzdGVtLm1qcz83YWI5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyLm1qcz9kMjRiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvQmFzZVJlbmRlclRleHR1cmUubWpzPzI4ZGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0Jhc2VJbWFnZVJlc291cmNlLm1qcz85ZmQwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLm1qcz9kZjhiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVVdnMubWpzP2Y2MjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZS5tanM/NjlhMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmUubWpzP2JhMzQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlUG9vbC5tanM/ZDNkMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkLm1qcz8xYTNhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3V0aWxzL1F1YWRVdi5tanM/NDhmZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL0ZpbHRlclN0YXRlLm1qcz8wN2RjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcz9lMTI5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYW1lYnVmZmVyL0dMRnJhbWVidWZmZXIubWpzPzdjZWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhbWVidWZmZXIvRnJhbWVidWZmZXJTeXN0ZW0ubWpzPzJiY2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0ubWpzPzg3YmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZU1hdHJpeC5tanM/ZGMwNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL3Nwcml0ZU1hc2svc3ByaXRlTWFza0ZpbHRlci5mcmFnLm1qcz8zNTg5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvc3ByaXRlTWFzay9zcHJpdGVNYXNrRmlsdGVyLnZlcnQubWpzP2YyOTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIubWpzP2Q4YWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrRGF0YS5tanM/M2NlOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL01hc2tTeXN0ZW0ubWpzPzVkZjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9BYnN0cmFjdE1hc2tTeXN0ZW0ubWpzP2Y4NDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9TY2lzc29yU3lzdGVtLm1qcz9hYTE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL21hc2svU3RlbmNpbFN5c3RlbS5tanM/NDBhZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9wbHVnaW4vUGx1Z2luU3lzdGVtLm1qcz81OGQxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5tanM/ZGY5OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5tanM/NjMyMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVTeXN0ZW0ubWpzP2ZjZTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL0dMUHJvZ3JhbS5tanM/MzY5ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvY29tcGlsZVNoYWRlci5tanM/NjhmZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZGVmYXVsdFZhbHVlLm1qcz82MDExIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRBdHRyaWJ1dGVEYXRhLm1qcz85N2M4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRVbmlmb3JtRGF0YS5tanM/NDU5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvbG9nUHJvZ3JhbUVycm9yLm1qcz9lZjVmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVByb2dyYW0ubWpzP2NhN2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMubWpzPzhmODEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL3Vuc2FmZUV2YWxTdXBwb3J0ZWQubWpzP2M4OTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1NoYWRlclN5c3RlbS5tanM/OWQzMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGFydHVwL1N0YXJ0dXBTeXN0ZW0ubWpzP2Y2ODQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3RhdGUvdXRpbHMvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLm1qcz9mMTBiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N0YXRlL1N0YXRlU3lzdGVtLm1qcz8yZDNhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLm1qcz80ZDVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5tanM/MjFiMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9HTFRleHR1cmUubWpzPzUzYmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvdXRpbHMvbWFwSW50ZXJuYWxGb3JtYXRUb1NhbXBsZXJUeXBlLm1qcz8xOTA1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3V0aWxzL21hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1qcz81YjA4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVTeXN0ZW0ubWpzP2I5MzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ubWpzPzQ1NzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdmlldy9WaWV3U3lzdGVtLm1qcz83ZGU0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N5c3RlbXMubWpzPzMwZTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2V0dGluZ3MubWpzP2ZlNjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9jb25zdC5tanM/ZjlhNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL1RpY2tlckxpc3RlbmVyLm1qcz81MjM4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvVGlja2VyLm1qcz9mZjE5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvc2V0dGluZ3MubWpzP2Y4MDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9UaWNrZXJQbHVnaW4ubWpzP2ZhZmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9pbmRleC5tanM/ZDZiNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzPzI5ZDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhZ21lbnRzL2RlZmF1bHQudmVydC5tanM/N2Q4ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvZGVmYXVsdEZpbHRlci52ZXJ0Lm1qcz8xYjIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYWdtZW50cy9pbmRleC5tanM/MDAwZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9NdWx0aXNhbXBsZVN5c3RlbS5tanM/Y2E0NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9HTEJ1ZmZlci5tanM/ODhhZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9CdWZmZXJTeXN0ZW0ubWpzPzMwNzciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyL09iamVjdFJlbmRlcmVyU3lzdGVtLm1qcz80YzFlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL1JlbmRlcmVyLm1qcz81YmNlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9BYnN0cmFjdE11bHRpUmVzb3VyY2UubWpzPzdhNmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0FycmF5UmVzb3VyY2UubWpzPzk5YTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0NhbnZhc1Jlc291cmNlLm1qcz9mYjk3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9DdWJlUmVzb3VyY2UubWpzPzFjNWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UubWpzPzdjYjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL1NWR1Jlc291cmNlLm1qcz80Y2ZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9WaWRlb1Jlc291cmNlLm1qcz8zODcwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5tanM/OTM2MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFjay5tanM/MGExNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9pbmRleC5tanM/NGE0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9Cb3VuZHMubWpzP2Q4Y2IiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvRGlzcGxheU9iamVjdC5tanM/OTQ5OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9Db250YWluZXIubWpzP2MwYmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvc2V0dGluZ3MubWpzP2Q1ZTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvaW5kZXgubWpzP2Q1ZGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlL2xpYi9TcHJpdGUubWpzP2Q4MzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlL2xpYi9pbmRleC5tanM/NmM5ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9taXhpbi1jYWNoZS1hcy1iaXRtYXAvbGliL2luZGV4Lm1qcz9kZTllIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lL2xpYi9pbmRleC5tanM/NDdmMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uL2xpYi9pbmRleC5tanM/MzBkZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYWxwaGEvbGliL2FscGhhLmZyYWcubWpzP2E2ODEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9BbHBoYUZpbHRlci5tanM/ZjhkYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYWxwaGEvbGliL2luZGV4Lm1qcz8wMzUwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9nZW5lcmF0ZUJsdXJGcmFnU291cmNlLm1qcz8wMmZmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLm1qcz8xZDA0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9CbHVyRmlsdGVyUGFzcy5tanM/N2FjMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvQmx1ckZpbHRlci5tanM/ZjhlOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvaW5kZXgubWpzP2EzYTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvY29sb3JNYXRyaXguZnJhZy5tanM/N2Y5MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItY29sb3ItbWF0cml4L2xpYi9Db2xvck1hdHJpeEZpbHRlci5tanM/MzNiNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItY29sb3ItbWF0cml4L2xpYi9pbmRleC5tanM/YzFmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9kaXNwbGFjZW1lbnQuZnJhZy5tanM/ZmQyZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9kaXNwbGFjZW1lbnQudmVydC5tanM/NTExZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9EaXNwbGFjZW1lbnRGaWx0ZXIubWpzPzUyMGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvaW5kZXgubWpzPzQxYzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL2Z4YWEuZnJhZy5tanM/OGNkYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZnhhYS9saWIvZnhhYS52ZXJ0Lm1qcz8yNzY5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9GWEFBRmlsdGVyLm1qcz9lY2M4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9pbmRleC5tanM/MzAxOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItbm9pc2UvbGliL25vaXNlLmZyYWcubWpzPzQwZDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9Ob2lzZUZpbHRlci5tanM/NmVhOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItbm9pc2UvbGliL2luZGV4Lm1qcz83YTIxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMubWpzPzk4YWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9FdmVudFRpY2tlci5tanM/ODRkZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZEV2ZW50Lm1qcz8wOTdkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRmVkZXJhdGVkTW91c2VFdmVudC5tanM/ODhlMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanM/Mjg3NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzPzliNjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9FdmVudEJvdW5kYXJ5Lm1qcz83NzE2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRXZlbnRTeXN0ZW0ubWpzPzhlYzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRFdmVudFRhcmdldC5tanM/N2YyOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL2luZGV4Lm1qcz9mNjFhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL2FjY2Vzc2libGVUYXJnZXQubWpzP2Q1ZjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYWNjZXNzaWJpbGl0eS9saWIvQWNjZXNzaWJpbGl0eU1hbmFnZXIubWpzP2VlNWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYWNjZXNzaWJpbGl0eS9saWIvaW5kZXgubWpzPzE0MzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9BcHBsaWNhdGlvbi5tanM/N2I0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hcHAvbGliL1Jlc2l6ZVBsdWdpbi5tanM/MWQ2OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hcHAvbGliL2luZGV4Lm1qcz9lY2YyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQXNzZXRFeHRlbnNpb24ubWpzPzA5OGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9CYWNrZ3JvdW5kTG9hZGVyLm1qcz8yYjQ3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzP2RjNDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9pbmRleC5tanM/OTNkYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzP2FjZTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9DYWNoZS5tanM/YWJiZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2lzU2luZ2xlSXRlbS5tanM/ZDM4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9Mb2FkZXIubWpzPzNiZGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzP2I3ZTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jaGVja0RhdGFVcmwubWpzPzcwYWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5tanM/NDhiMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL2xvYWRUeHQubWpzP2RiYjciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkV2ViRm9udC5tanM/Y2YxYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL1dvcmtlck1hbmFnZXIubWpzP2VjNmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy91dGlscy9jcmVhdGVUZXh0dXJlLm1qcz85OTQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcz83ODNjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFNWRy5tanM/NTVhYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRWaWRlby5tanM/NDFjNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2luZGV4Lm1qcz9hMDRjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvaW5kZXgubWpzPzY2NjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9pbmRleC5tanM/OTAwNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzP2E2NTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9SZXNvbHZlci5tanM/MjgyNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL0Fzc2V0cy5tanM/MWRkZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkubWpzPzRmZWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9wYXJzZXJzL2luZGV4Lm1qcz82ZDc1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvY2FjaGUvaW5kZXgubWpzPzM0NDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3V0aWxzL3Rlc3RJbWFnZUZvcm1hdC5tanM/NjY1ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLm1qcz9kZjk1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYnAubWpzPzExNzQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0RGVmYXVsdHMubWpzP2I5MWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3V0aWxzL3Rlc3RWaWRlb0Zvcm1hdC5tanM/MTU0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJtLm1qcz9lZjRkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdE1wNC5tanM/YzIwMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RPZ3YubWpzP2VkMDAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvaW5kZXgubWpzP2Q0YzgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL2luZGV4Lm1qcz80NDIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL2luZGV4Lm1qcz84ODI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlVGV4dHVyZVVybC5tanM/NDZmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3Jlc29sdmVyL3BhcnNlcnMvaW5kZXgubWpzPzkxNGQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9pbmRleC5tanM/OTEwYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzP2VkNmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9pbmRleC5tanM/NWNlNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9jb25zdC5tanM/Mjc0NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanM/MjEwMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2RldGVjdENvbXByZXNzZWRUZXh0dXJlcy5tanM/ZWNhNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9yZXNvdXJjZXMvQmxvYlJlc291cmNlLm1qcz9jMGVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcz82NjlmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9pbmRleC5tanM/YzkxYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9wYXJzZXJzL3BhcnNlRERTLm1qcz81Y2ExIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VLVFgubWpzP2JlZGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvcGFyc2Vycy9pbmRleC5tanM/ZTllYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2xvYWRERFMubWpzPzlhMzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9sb2FkS1RYLm1qcz9lNmZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qcz8yOGNjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvaW5kZXgubWpzP2NkYzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvaW5kZXgubWpzPzA3OGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXh0cmFjdC9saWIvRXh0cmFjdC5tanM/ODQ4ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9leHRyYWN0L2xpYi9pbmRleC5tanM/YjliNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRDaXJjbGUubWpzPzI3ZTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkUG9seS5tanM/MjkxYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRSZWN0YW5nbGUubWpzP2Y5ZjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5tanM/ODNmYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvY29uc3QubWpzPzE1MmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL0FyY1V0aWxzLm1qcz9kMDk4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9CZXppZXJVdGlscy5tanM/YmFhMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRMaW5lLm1qcz9kNDA0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9RdWFkcmF0aWNVdGlscy5tanM/Zjc0MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvaW5kZXgubWpzPzI2NTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL0dyYXBoaWNzRGF0YS5tanM/MDQ1NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvQmF0Y2hQYXJ0Lm1qcz9hMjc2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0dlb21ldHJ5Lm1qcz8xMWJhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9zdHlsZXMvRmlsbFN0eWxlLm1qcz84M2M3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9zdHlsZXMvTGluZVN0eWxlLm1qcz9jOGIxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljcy5tanM/ZjU2MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvaW5kZXgubWpzP2UyY2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvTWVzaEJhdGNoVXZzLm1qcz80Y2NiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2gubWpzP2Y2NTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvTWVzaEdlb21ldHJ5Lm1qcz9lNWQ5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL3NoYWRlci9tZXNoLmZyYWcubWpzPzcwOWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvc2hhZGVyL21lc2gudmVydC5tanM/ZTRjMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoTWF0ZXJpYWwubWpzPzZkNTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvaW5kZXgubWpzPzM0ZDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1BsYW5lR2VvbWV0cnkubWpzP2M3ZDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1JvcGVHZW9tZXRyeS5tanM/NjY1YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlUGxhbmUubWpzPzQ2MTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL05pbmVTbGljZVBsYW5lLm1qcz85ZTczIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9TaW1wbGVNZXNoLm1qcz8yMzI0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9TaW1wbGVSb3BlLm1qcz82MWNjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9pbmRleC5tanM/YmEwOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL1BhcnRpY2xlQ29udGFpbmVyLm1qcz9iNGMxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvUGFydGljbGVCdWZmZXIubWpzP2MyNGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9wYXJ0aWNsZXMuZnJhZy5tanM/MWJlMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL3BhcnRpY2xlcy52ZXJ0Lm1qcz81MjJiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvUGFydGljbGVSZW5kZXJlci5tanM/OWJlNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL2luZGV4Lm1qcz9lZTUxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL2NvbnN0Lm1qcz9lNDg1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHRNZXRyaWNzLm1qcz85MjE0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHRTdHlsZS5tanM/MDE3YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0L2xpYi9UZXh0Lm1qcz83NGVjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL2luZGV4Lm1qcz8wMDViIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL0NvdW50TGltaXRlci5tanM/ZDMxNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9CYXNlUHJlcGFyZS5tanM/NzEzZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9zZXR0aW5ncy5tanM/OTEyZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9QcmVwYXJlLm1qcz84ZjZmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL2luZGV4Lm1qcz81NzE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS1hbmltYXRlZC9saWIvQW5pbWF0ZWRTcHJpdGUubWpzPzA2NTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9pbmRleC5tanM/NTVmMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9UaWxpbmdTcHJpdGUubWpzP2NjOGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy5mcmFnLm1qcz82YWUyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL3Nwcml0ZS10aWxpbmcudmVydC5tanM/ZGRjZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLmZyYWcubWpzPzM5ZmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy1mYWxsYmFjay52ZXJ0Lm1qcz9hZWM2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL3Nwcml0ZS10aWxpbmctc2ltcGxlLmZyYWcubWpzP2NhY2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvVGlsaW5nU3ByaXRlUmVuZGVyZXIubWpzPzMyNTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvaW5kZXgubWpzPzRjNzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL1Nwcml0ZXNoZWV0Lm1qcz8wNzk3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9zcHJpdGVzaGVldEFzc2V0Lm1qcz83YTU4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9pbmRleC5tanM/ZWZmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvQml0bWFwRm9udERhdGEubWpzPzFiYWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL2Zvcm1hdHMvVGV4dEZvcm1hdC5tanM/NTcyMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9YTUxGb3JtYXQubWpzPzVkNWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL2Zvcm1hdHMvWE1MU3RyaW5nRm9ybWF0Lm1qcz8wYjg5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9mb3JtYXRzL2luZGV4Lm1qcz8xNWEyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9nZW5lcmF0ZUZpbGxTdHlsZS5tanM/ZDBkMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvZHJhd0dseXBoLm1qcz81Y2RjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9pbmRleC5tanM/MWY4NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcz8xZGFhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5tanM/MjczZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvZXh0cmFjdENoYXJDb2RlLm1qcz9iMjE4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBGb250Lm1qcz83MDgxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9zaGFkZXIvbXNkZi5mcmFnLm1qcz9iZTRjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9zaGFkZXIvbXNkZi52ZXJ0Lm1qcz9kZmYyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBUZXh0Lm1qcz81ZGVjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9sb2FkQml0bWFwRm9udC5tanM/ZjdkMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvaW5kZXgubWpzPzNlODciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1odG1sL2xpYi9IVE1MVGV4dFN0eWxlLm1qcz9mYjM2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtaHRtbC9saWIvSFRNTFRleHQubWpzP2YyYTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1odG1sL2xpYi9pbmRleC5tanM/Zjk0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbmRleC5tanM/NjUzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRU5WID0gLyogQF9fUFVSRV9fICovICgoRU5WMikgPT4gKEVOVjJbRU5WMi5XRUJHTF9MRUdBQ1kgPSAwXSA9IFwiV0VCR0xfTEVHQUNZXCIsIEVOVjJbRU5WMi5XRUJHTCA9IDFdID0gXCJXRUJHTFwiLCBFTlYyW0VOVjIuV0VCR0wyID0gMl0gPSBcIldFQkdMMlwiLCBFTlYyKSkoRU5WIHx8IHt9KSwgUkVOREVSRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJFTkRFUkVSX1RZUEUyKSA9PiAoUkVOREVSRVJfVFlQRTJbUkVOREVSRVJfVFlQRTIuVU5LTk9XTiA9IDBdID0gXCJVTktOT1dOXCIsIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyLldFQkdMID0gMV0gPSBcIldFQkdMXCIsIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyLkNBTlZBUyA9IDJdID0gXCJDQU5WQVNcIiwgUkVOREVSRVJfVFlQRTIpKShSRU5ERVJFUl9UWVBFIHx8IHt9KSwgQlVGRkVSX0JJVFMgPSAvKiBAX19QVVJFX18gKi8gKChCVUZGRVJfQklUUzIpID0+IChCVUZGRVJfQklUUzJbQlVGRkVSX0JJVFMyLkNPTE9SID0gMTYzODRdID0gXCJDT0xPUlwiLCBCVUZGRVJfQklUUzJbQlVGRkVSX0JJVFMyLkRFUFRIID0gMjU2XSA9IFwiREVQVEhcIiwgQlVGRkVSX0JJVFMyW0JVRkZFUl9CSVRTMi5TVEVOQ0lMID0gMTAyNF0gPSBcIlNURU5DSUxcIiwgQlVGRkVSX0JJVFMyKSkoQlVGRkVSX0JJVFMgfHwge30pLCBCTEVORF9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJMRU5EX01PREVTMikgPT4gKEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuTk9STUFMID0gMF0gPSBcIk5PUk1BTFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkFERCA9IDFdID0gXCJBRERcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5NVUxUSVBMWSA9IDJdID0gXCJNVUxUSVBMWVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNDUkVFTiA9IDNdID0gXCJTQ1JFRU5cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5PVkVSTEFZID0gNF0gPSBcIk9WRVJMQVlcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5EQVJLRU4gPSA1XSA9IFwiREFSS0VOXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuTElHSFRFTiA9IDZdID0gXCJMSUdIVEVOXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuQ09MT1JfRE9ER0UgPSA3XSA9IFwiQ09MT1JfRE9ER0VcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5DT0xPUl9CVVJOID0gOF0gPSBcIkNPTE9SX0JVUk5cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5IQVJEX0xJR0hUID0gOV0gPSBcIkhBUkRfTElHSFRcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5TT0ZUX0xJR0hUID0gMTBdID0gXCJTT0ZUX0xJR0hUXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRElGRkVSRU5DRSA9IDExXSA9IFwiRElGRkVSRU5DRVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkVYQ0xVU0lPTiA9IDEyXSA9IFwiRVhDTFVTSU9OXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuSFVFID0gMTNdID0gXCJIVUVcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5TQVRVUkFUSU9OID0gMTRdID0gXCJTQVRVUkFUSU9OXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuQ09MT1IgPSAxNV0gPSBcIkNPTE9SXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuTFVNSU5PU0lUWSA9IDE2XSA9IFwiTFVNSU5PU0lUWVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLk5PUk1BTF9OUE0gPSAxN10gPSBcIk5PUk1BTF9OUE1cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5BRERfTlBNID0gMThdID0gXCJBRERfTlBNXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuU0NSRUVOX05QTSA9IDE5XSA9IFwiU0NSRUVOX05QTVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLk5PTkUgPSAyMF0gPSBcIk5PTkVcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5TUkNfT1ZFUiA9IDBdID0gXCJTUkNfT1ZFUlwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNSQ19JTiA9IDIxXSA9IFwiU1JDX0lOXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuU1JDX09VVCA9IDIyXSA9IFwiU1JDX09VVFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNSQ19BVE9QID0gMjNdID0gXCJTUkNfQVRPUFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkRTVF9PVkVSID0gMjRdID0gXCJEU1RfT1ZFUlwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkRTVF9JTiA9IDI1XSA9IFwiRFNUX0lOXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRFNUX09VVCA9IDI2XSA9IFwiRFNUX09VVFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkRTVF9BVE9QID0gMjddID0gXCJEU1RfQVRPUFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkVSQVNFID0gMjZdID0gXCJFUkFTRVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNVQlRSQUNUID0gMjhdID0gXCJTVUJUUkFDVFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlhPUiA9IDI5XSA9IFwiWE9SXCIsIEJMRU5EX01PREVTMikpKEJMRU5EX01PREVTIHx8IHt9KSwgRFJBV19NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKERSQVdfTU9ERVMyKSA9PiAoRFJBV19NT0RFUzJbRFJBV19NT0RFUzIuUE9JTlRTID0gMF0gPSBcIlBPSU5UU1wiLCBEUkFXX01PREVTMltEUkFXX01PREVTMi5MSU5FUyA9IDFdID0gXCJMSU5FU1wiLCBEUkFXX01PREVTMltEUkFXX01PREVTMi5MSU5FX0xPT1AgPSAyXSA9IFwiTElORV9MT09QXCIsIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyLkxJTkVfU1RSSVAgPSAzXSA9IFwiTElORV9TVFJJUFwiLCBEUkFXX01PREVTMltEUkFXX01PREVTMi5UUklBTkdMRVMgPSA0XSA9IFwiVFJJQU5HTEVTXCIsIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyLlRSSUFOR0xFX1NUUklQID0gNV0gPSBcIlRSSUFOR0xFX1NUUklQXCIsIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyLlRSSUFOR0xFX0ZBTiA9IDZdID0gXCJUUklBTkdMRV9GQU5cIiwgRFJBV19NT0RFUzIpKShEUkFXX01PREVTIHx8IHt9KSwgRk9STUFUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEZPUk1BVFMyKSA9PiAoRk9STUFUUzJbRk9STUFUUzIuUkdCQSA9IDY0MDhdID0gXCJSR0JBXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLlJHQiA9IDY0MDddID0gXCJSR0JcIiwgRk9STUFUUzJbRk9STUFUUzIuUkcgPSAzMzMxOV0gPSBcIlJHXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLlJFRCA9IDY0MDNdID0gXCJSRURcIiwgRk9STUFUUzJbRk9STUFUUzIuUkdCQV9JTlRFR0VSID0gMzYyNDldID0gXCJSR0JBX0lOVEVHRVJcIiwgRk9STUFUUzJbRk9STUFUUzIuUkdCX0lOVEVHRVIgPSAzNjI0OF0gPSBcIlJHQl9JTlRFR0VSXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLlJHX0lOVEVHRVIgPSAzMzMyMF0gPSBcIlJHX0lOVEVHRVJcIiwgRk9STUFUUzJbRk9STUFUUzIuUkVEX0lOVEVHRVIgPSAzNjI0NF0gPSBcIlJFRF9JTlRFR0VSXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLkFMUEhBID0gNjQwNl0gPSBcIkFMUEhBXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLkxVTUlOQU5DRSA9IDY0MDldID0gXCJMVU1JTkFOQ0VcIiwgRk9STUFUUzJbRk9STUFUUzIuTFVNSU5BTkNFX0FMUEhBID0gNjQxMF0gPSBcIkxVTUlOQU5DRV9BTFBIQVwiLCBGT1JNQVRTMltGT1JNQVRTMi5ERVBUSF9DT01QT05FTlQgPSA2NDAyXSA9IFwiREVQVEhfQ09NUE9ORU5UXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLkRFUFRIX1NURU5DSUwgPSAzNDA0MV0gPSBcIkRFUFRIX1NURU5DSUxcIiwgRk9STUFUUzIpKShGT1JNQVRTIHx8IHt9KSwgVEFSR0VUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRBUkdFVFMyKSA9PiAoVEFSR0VUUzJbVEFSR0VUUzIuVEVYVFVSRV8yRCA9IDM1NTNdID0gXCJURVhUVVJFXzJEXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVAgPSAzNDA2N10gPSBcIlRFWFRVUkVfQ1VCRV9NQVBcIiwgVEFSR0VUUzJbVEFSR0VUUzIuVEVYVFVSRV8yRF9BUlJBWSA9IDM1ODY2XSA9IFwiVEVYVFVSRV8yRF9BUlJBWVwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAzNDA2OV0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWFwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ggPSAzNDA3MF0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWFwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1kgPSAzNDA3MV0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWVwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kgPSAzNDA3Ml0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWVwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ogPSAzNDA3M10gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWlwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ogPSAzNDA3NF0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlwiLCBUQVJHRVRTMikpKFRBUkdFVFMgfHwge30pLCBUWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRZUEVTMikgPT4gKFRZUEVTMltUWVBFUzIuVU5TSUdORURfQllURSA9IDUxMjFdID0gXCJVTlNJR05FRF9CWVRFXCIsIFRZUEVTMltUWVBFUzIuVU5TSUdORURfU0hPUlQgPSA1MTIzXSA9IFwiVU5TSUdORURfU0hPUlRcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9TSE9SVF81XzZfNSA9IDMzNjM1XSA9IFwiVU5TSUdORURfU0hPUlRfNV82XzVcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9TSE9SVF80XzRfNF80ID0gMzI4MTldID0gXCJVTlNJR05FRF9TSE9SVF80XzRfNF80XCIsIFRZUEVTMltUWVBFUzIuVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDMyODIwXSA9IFwiVU5TSUdORURfU0hPUlRfNV81XzVfMVwiLCBUWVBFUzJbVFlQRVMyLlVOU0lHTkVEX0lOVCA9IDUxMjVdID0gXCJVTlNJR05FRF9JTlRcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWID0gMzU4OTldID0gXCJVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWXCIsIFRZUEVTMltUWVBFUzIuVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWID0gMzM2NDBdID0gXCJVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVZcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9JTlRfMjRfOCA9IDM0MDQyXSA9IFwiVU5TSUdORURfSU5UXzI0XzhcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9JTlRfNV85XzlfOV9SRVYgPSAzNTkwMl0gPSBcIlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVlwiLCBUWVBFUzJbVFlQRVMyLkJZVEUgPSA1MTIwXSA9IFwiQllURVwiLCBUWVBFUzJbVFlQRVMyLlNIT1JUID0gNTEyMl0gPSBcIlNIT1JUXCIsIFRZUEVTMltUWVBFUzIuSU5UID0gNTEyNF0gPSBcIklOVFwiLCBUWVBFUzJbVFlQRVMyLkZMT0FUID0gNTEyNl0gPSBcIkZMT0FUXCIsIFRZUEVTMltUWVBFUzIuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWID0gMzYyNjldID0gXCJGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZcIiwgVFlQRVMyW1RZUEVTMi5IQUxGX0ZMT0FUID0gMzYxOTNdID0gXCJIQUxGX0ZMT0FUXCIsIFRZUEVTMikpKFRZUEVTIHx8IHt9KSwgU0FNUExFUl9UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNBTVBMRVJfVFlQRVMyKSA9PiAoU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzIuRkxPQVQgPSAwXSA9IFwiRkxPQVRcIiwgU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzIuSU5UID0gMV0gPSBcIklOVFwiLCBTQU1QTEVSX1RZUEVTMltTQU1QTEVSX1RZUEVTMi5VSU5UID0gMl0gPSBcIlVJTlRcIiwgU0FNUExFUl9UWVBFUzIpKShTQU1QTEVSX1RZUEVTIHx8IHt9KSwgU0NBTEVfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChTQ0FMRV9NT0RFUzIpID0+IChTQ0FMRV9NT0RFUzJbU0NBTEVfTU9ERVMyLk5FQVJFU1QgPSAwXSA9IFwiTkVBUkVTVFwiLCBTQ0FMRV9NT0RFUzJbU0NBTEVfTU9ERVMyLkxJTkVBUiA9IDFdID0gXCJMSU5FQVJcIiwgU0NBTEVfTU9ERVMyKSkoU0NBTEVfTU9ERVMgfHwge30pLCBXUkFQX01PREVTID0gLyogQF9fUFVSRV9fICovICgoV1JBUF9NT0RFUzIpID0+IChXUkFQX01PREVTMltXUkFQX01PREVTMi5DTEFNUCA9IDMzMDcxXSA9IFwiQ0xBTVBcIiwgV1JBUF9NT0RFUzJbV1JBUF9NT0RFUzIuUkVQRUFUID0gMTA0OTddID0gXCJSRVBFQVRcIiwgV1JBUF9NT0RFUzJbV1JBUF9NT0RFUzIuTUlSUk9SRURfUkVQRUFUID0gMzM2NDhdID0gXCJNSVJST1JFRF9SRVBFQVRcIiwgV1JBUF9NT0RFUzIpKShXUkFQX01PREVTIHx8IHt9KSwgTUlQTUFQX01PREVTID0gLyogQF9fUFVSRV9fICovICgoTUlQTUFQX01PREVTMikgPT4gKE1JUE1BUF9NT0RFUzJbTUlQTUFQX01PREVTMi5PRkYgPSAwXSA9IFwiT0ZGXCIsIE1JUE1BUF9NT0RFUzJbTUlQTUFQX01PREVTMi5QT1cyID0gMV0gPSBcIlBPVzJcIiwgTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyLk9OID0gMl0gPSBcIk9OXCIsIE1JUE1BUF9NT0RFUzJbTUlQTUFQX01PREVTMi5PTl9NQU5VQUwgPSAzXSA9IFwiT05fTUFOVUFMXCIsIE1JUE1BUF9NT0RFUzIpKShNSVBNQVBfTU9ERVMgfHwge30pLCBBTFBIQV9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEFMUEhBX01PREVTMikgPT4gKEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzIuTlBNID0gMF0gPSBcIk5QTVwiLCBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyLlVOUEFDSyA9IDFdID0gXCJVTlBBQ0tcIiwgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMi5QTUEgPSAyXSA9IFwiUE1BXCIsIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzIuTk9fUFJFTVVMVElQTElFRF9BTFBIQSA9IDBdID0gXCJOT19QUkVNVUxUSVBMSUVEX0FMUEhBXCIsIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzIuUFJFTVVMVElQTFlfT05fVVBMT0FEID0gMV0gPSBcIlBSRU1VTFRJUExZX09OX1VQTE9BRFwiLCBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyLlBSRU1VTFRJUExJRURfQUxQSEEgPSAyXSA9IFwiUFJFTVVMVElQTElFRF9BTFBIQVwiLCBBTFBIQV9NT0RFUzIpKShBTFBIQV9NT0RFUyB8fCB7fSksIENMRUFSX01PREVTID0gLyogQF9fUFVSRV9fICovICgoQ0xFQVJfTU9ERVMyKSA9PiAoQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMi5OTyA9IDBdID0gXCJOT1wiLCBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyLllFUyA9IDFdID0gXCJZRVNcIiwgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMi5BVVRPID0gMl0gPSBcIkFVVE9cIiwgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMi5CTEVORCA9IDBdID0gXCJCTEVORFwiLCBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyLkNMRUFSID0gMV0gPSBcIkNMRUFSXCIsIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzIuQkxJVCA9IDJdID0gXCJCTElUXCIsIENMRUFSX01PREVTMikpKENMRUFSX01PREVTIHx8IHt9KSwgR0NfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChHQ19NT0RFUzIpID0+IChHQ19NT0RFUzJbR0NfTU9ERVMyLkFVVE8gPSAwXSA9IFwiQVVUT1wiLCBHQ19NT0RFUzJbR0NfTU9ERVMyLk1BTlVBTCA9IDFdID0gXCJNQU5VQUxcIiwgR0NfTU9ERVMyKSkoR0NfTU9ERVMgfHwge30pLCBQUkVDSVNJT04gPSAvKiBAX19QVVJFX18gKi8gKChQUkVDSVNJT04yKSA9PiAoUFJFQ0lTSU9OMi5MT1cgPSBcImxvd3BcIiwgUFJFQ0lTSU9OMi5NRURJVU0gPSBcIm1lZGl1bXBcIiwgUFJFQ0lTSU9OMi5ISUdIID0gXCJoaWdocFwiLCBQUkVDSVNJT04yKSkoUFJFQ0lTSU9OIHx8IHt9KSwgTUFTS19UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1BU0tfVFlQRVMyKSA9PiAoTUFTS19UWVBFUzJbTUFTS19UWVBFUzIuTk9ORSA9IDBdID0gXCJOT05FXCIsIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyLlNDSVNTT1IgPSAxXSA9IFwiU0NJU1NPUlwiLCBNQVNLX1RZUEVTMltNQVNLX1RZUEVTMi5TVEVOQ0lMID0gMl0gPSBcIlNURU5DSUxcIiwgTUFTS19UWVBFUzJbTUFTS19UWVBFUzIuU1BSSVRFID0gM10gPSBcIlNQUklURVwiLCBNQVNLX1RZUEVTMltNQVNLX1RZUEVTMi5DT0xPUiA9IDRdID0gXCJDT0xPUlwiLCBNQVNLX1RZUEVTMikpKE1BU0tfVFlQRVMgfHwge30pLCBDT0xPUl9NQVNLX0JJVFMgPSAvKiBAX19QVVJFX18gKi8gKChDT0xPUl9NQVNLX0JJVFMyKSA9PiAoQ09MT1JfTUFTS19CSVRTMltDT0xPUl9NQVNLX0JJVFMyLlJFRCA9IDFdID0gXCJSRURcIiwgQ09MT1JfTUFTS19CSVRTMltDT0xPUl9NQVNLX0JJVFMyLkdSRUVOID0gMl0gPSBcIkdSRUVOXCIsIENPTE9SX01BU0tfQklUUzJbQ09MT1JfTUFTS19CSVRTMi5CTFVFID0gNF0gPSBcIkJMVUVcIiwgQ09MT1JfTUFTS19CSVRTMltDT0xPUl9NQVNLX0JJVFMyLkFMUEhBID0gOF0gPSBcIkFMUEhBXCIsIENPTE9SX01BU0tfQklUUzIpKShDT0xPUl9NQVNLX0JJVFMgfHwge30pLCBNU0FBX1FVQUxJVFkgPSAvKiBAX19QVVJFX18gKi8gKChNU0FBX1FVQUxJVFkyKSA9PiAoTVNBQV9RVUFMSVRZMltNU0FBX1FVQUxJVFkyLk5PTkUgPSAwXSA9IFwiTk9ORVwiLCBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTIuTE9XID0gMl0gPSBcIkxPV1wiLCBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTIuTUVESVVNID0gNF0gPSBcIk1FRElVTVwiLCBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTIuSElHSCA9IDhdID0gXCJISUdIXCIsIE1TQUFfUVVBTElUWTIpKShNU0FBX1FVQUxJVFkgfHwge30pLCBCVUZGRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKEJVRkZFUl9UWVBFMikgPT4gKEJVRkZFUl9UWVBFMltCVUZGRVJfVFlQRTIuRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAzNDk2M10gPSBcIkVMRU1FTlRfQVJSQVlfQlVGRkVSXCIsIEJVRkZFUl9UWVBFMltCVUZGRVJfVFlQRTIuQVJSQVlfQlVGRkVSID0gMzQ5NjJdID0gXCJBUlJBWV9CVUZGRVJcIiwgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMi5VTklGT1JNX0JVRkZFUiA9IDM1MzQ1XSA9IFwiVU5JRk9STV9CVUZGRVJcIiwgQlVGRkVSX1RZUEUyKSkoQlVGRkVSX1RZUEUgfHwge30pO1xuZXhwb3J0IHtcbiAgQUxQSEFfTU9ERVMsXG4gIEJMRU5EX01PREVTLFxuICBCVUZGRVJfQklUUyxcbiAgQlVGRkVSX1RZUEUsXG4gIENMRUFSX01PREVTLFxuICBDT0xPUl9NQVNLX0JJVFMsXG4gIERSQVdfTU9ERVMsXG4gIEVOVixcbiAgRk9STUFUUyxcbiAgR0NfTU9ERVMsXG4gIE1BU0tfVFlQRVMsXG4gIE1JUE1BUF9NT0RFUyxcbiAgTVNBQV9RVUFMSVRZLFxuICBQUkVDSVNJT04sXG4gIFJFTkRFUkVSX1RZUEUsXG4gIFNBTVBMRVJfVFlQRVMsXG4gIFNDQUxFX01PREVTLFxuICBUQVJHRVRTLFxuICBUWVBFUyxcbiAgV1JBUF9NT0RFU1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNvbnN0IEJyb3dzZXJBZGFwdGVyID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbnZhcyBlbGVtZW50IG9mIHRoZSBnaXZlbiBzaXplLlxuICAgKiBUaGlzIGNhbnZhcyBpcyBjcmVhdGVkIHVzaW5nIHRoZSBicm93c2VyJ3MgbmF0aXZlIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAcGFyYW0gd2lkdGggLSB3aWR0aCBvZiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgY3JlYXRlQ2FudmFzOiAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgcmV0dXJuIGNhbnZhcy53aWR0aCA9IHdpZHRoLCBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0LCBjYW52YXM7XG4gIH0sXG4gIGdldENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDogKCkgPT4gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQ6ICgpID0+IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgZ2V0TmF2aWdhdG9yOiAoKSA9PiBuYXZpZ2F0b3IsXG4gIGdldEJhc2VVcmw6ICgpID0+IGRvY3VtZW50LmJhc2VVUkkgPz8gd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gIGdldEZvbnRGYWNlU2V0OiAoKSA9PiBkb2N1bWVudC5mb250cyxcbiAgZmV0Y2g6ICh1cmwsIG9wdGlvbnMpID0+IGZldGNoKHVybCwgb3B0aW9ucyksXG4gIHBhcnNlWE1MOiAoeG1sKSA9PiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbCwgXCJ0ZXh0L3htbFwiKVxufTtcbmV4cG9ydCB7XG4gIEJyb3dzZXJBZGFwdGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCcm93c2VyQWRhcHRlciB9IGZyb20gXCIuL2FkYXB0ZXIubWpzXCI7XG5jb25zdCBzZXR0aW5ncyA9IHtcbiAgLyoqXG4gICAqIFRoaXMgYWRhcHRlciBpcyB1c2VkIHRvIGNhbGwgbWV0aG9kcyB0aGF0IGFyZSBwbGF0Zm9ybSBkZXBlbmRlbnQuXG4gICAqIEZvciBleGFtcGxlIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50YCBvbmx5IHJ1bnMgb24gdGhlIHdlYiBidXQgZmFpbHMgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG4gICAqIFRoaXMgYWxsb3dzIHVzIHRvIHN1cHBvcnQgbW9yZSBwbGF0Zm9ybXMgYnkgYWJzdHJhY3RpbmcgYXdheSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMgcGVyIHBsYXRmb3JtLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBhZGFwdGVyIGlzIHNldCB0byB3b3JrIGluIHRoZSBicm93c2VyLiBIb3dldmVyIHlvdSBjYW4gY3JlYXRlIHlvdXIgb3duXG4gICAqIGJ5IGltcGxlbWVudGluZyB0aGUgYElBZGFwdGVyYCBpbnRlcmZhY2UuIFNlZSBgSUFkYXB0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAbmFtZSBBREFQVEVSXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLklBZGFwdGVyfVxuICAgKiBAZGVmYXVsdCBQSVhJLkJyb3dzZXJBZGFwdGVyXG4gICAqL1xuICBBREFQVEVSOiBCcm93c2VyQWRhcHRlcixcbiAgLyoqXG4gICAqIERlZmF1bHQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgUkVTT0xVVElPTlxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBSRVNPTFVUSU9OOiAxLFxuICAvKipcbiAgICogRW5hYmxlcyBiaXRtYXAgY3JlYXRpb24gYmVmb3JlIGltYWdlIGxvYWQuIFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWwuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgQ1JFQVRFX0lNQUdFX0JJVE1BUFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIENSRUFURV9JTUFHRV9CSVRNQVA6ICExLFxuICAvKipcbiAgICogSWYgdHJ1ZSBQaXhpSlMgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxuICAgKiBUaGUgbWFpbiBkaXNhZHZhbnRhZ2UgaXMgbW92ZW1lbnQgb2Ygb2JqZWN0cyBtYXkgYXBwZWFyIGxlc3Mgc21vb3RoLlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgUk9VTkRfUElYRUxTOiAhMVxufTtcbmV4cG9ydCB7XG4gIHNldHRpbmdzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwiY29uc3QgYXBwbGVJcGhvbmUgPSAvaVBob25lL2k7XG5jb25zdCBhcHBsZUlwb2QgPSAvaVBvZC9pO1xuY29uc3QgYXBwbGVUYWJsZXQgPSAvaVBhZC9pO1xuY29uc3QgYXBwbGVVbml2ZXJzYWwgPSAvXFxiaU9TLXVuaXZlcnNhbCg/Oi4rKU1hY1xcYi9pO1xuY29uc3QgYW5kcm9pZFBob25lID0gL1xcYkFuZHJvaWQoPzouKylNb2JpbGVcXGIvaTsgLy8gTWF0Y2ggJ0FuZHJvaWQnIEFORCAnTW9iaWxlJ1xuY29uc3QgYW5kcm9pZFRhYmxldCA9IC9BbmRyb2lkL2k7XG5jb25zdCBhbWF6b25QaG9uZSA9IC8oPzpTRDQ5MzBVUnxcXGJTaWxrKD86LispTW9iaWxlXFxiKS9pOyAvLyBNYXRjaCAnU2lsaycgQU5EICdNb2JpbGUnXG5jb25zdCBhbWF6b25UYWJsZXQgPSAvU2lsay9pO1xuY29uc3Qgd2luZG93c1Bob25lID0gL1dpbmRvd3MgUGhvbmUvaTtcbmNvbnN0IHdpbmRvd3NUYWJsZXQgPSAvXFxiV2luZG93cyg/Oi4rKUFSTVxcYi9pOyAvLyBNYXRjaCAnV2luZG93cycgQU5EICdBUk0nXG5jb25zdCBvdGhlckJsYWNrQmVycnkgPSAvQmxhY2tCZXJyeS9pO1xuY29uc3Qgb3RoZXJCbGFja0JlcnJ5MTAgPSAvQkIxMC9pO1xuY29uc3Qgb3RoZXJPcGVyYSA9IC9PcGVyYSBNaW5pL2k7XG5jb25zdCBvdGhlckNocm9tZSA9IC9cXGIoQ3JpT1N8Q2hyb21lKSg/Oi4rKU1vYmlsZS9pO1xuY29uc3Qgb3RoZXJGaXJlZm94ID0gL01vYmlsZSg/Oi4rKUZpcmVmb3hcXGIvaTsgLy8gTWF0Y2ggJ01vYmlsZScgQU5EICdGaXJlZm94J1xuXG5leHBvcnQgdHlwZSBVc2VyQWdlbnQgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBOYXZpZ2F0b3IgPSB7XG4gIHVzZXJBZ2VudDogc3RyaW5nO1xuICBwbGF0Zm9ybTogc3RyaW5nO1xuICBtYXhUb3VjaFBvaW50cz86IG51bWJlcjtcbn07XG5cbmNvbnN0IGlzQXBwbGVUYWJsZXRPbklvczEzID0gKG5hdmlnYXRvcj86IE5hdmlnYXRvcik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA9PT0gJ251bWJlcicgJiZcbiAgICBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxICYmXG4gICAgdHlwZW9mIE1TU3RyZWFtID09PSAndW5kZWZpbmVkJ1xuICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2godXNlckFnZW50OiBVc2VyQWdlbnQpOiAocmVnZXg6IFJlZ0V4cCkgPT4gYm9vbGVhbiB7XG4gIHJldHVybiAocmVnZXg6IFJlZ0V4cCk6IGJvb2xlYW4gPT4gcmVnZXgudGVzdCh1c2VyQWdlbnQpO1xufVxuXG5leHBvcnQgdHlwZSBpc01vYmlsZVJlc3VsdCA9IHtcbiAgYXBwbGU6IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICBpcG9kOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICB1bml2ZXJzYWw6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBhbWF6b246IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICB0YWJsZXQ6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBhbmRyb2lkOiB7XG4gICAgcGhvbmU6IGJvb2xlYW47XG4gICAgdGFibGV0OiBib29sZWFuO1xuICAgIGRldmljZTogYm9vbGVhbjtcbiAgfTtcbiAgd2luZG93czoge1xuICAgIHBob25lOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICBkZXZpY2U6IGJvb2xlYW47XG4gIH07XG4gIG90aGVyOiB7XG4gICAgYmxhY2tiZXJyeTogYm9vbGVhbjtcbiAgICBibGFja2JlcnJ5MTA6IGJvb2xlYW47XG4gICAgb3BlcmE6IGJvb2xlYW47XG4gICAgZmlyZWZveDogYm9vbGVhbjtcbiAgICBjaHJvbWU6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBwaG9uZTogYm9vbGVhbjtcbiAgdGFibGV0OiBib29sZWFuO1xuICBhbnk6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBJc01vYmlsZVBhcmFtZXRlciA9IFVzZXJBZ2VudCB8IE5hdmlnYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2JpbGUocGFyYW0/OiBJc01vYmlsZVBhcmFtZXRlcik6IGlzTW9iaWxlUmVzdWx0IHtcbiAgbGV0IG5hdjogTmF2aWdhdG9yID0ge1xuICAgIHVzZXJBZ2VudDogJycsXG4gICAgcGxhdGZvcm06ICcnLFxuICAgIG1heFRvdWNoUG9pbnRzOiAwLFxuICB9O1xuXG4gIGlmICghcGFyYW0gJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYXYgPSB7XG4gICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBwbGF0Zm9ybTogbmF2aWdhdG9yLnBsYXRmb3JtLFxuICAgICAgbWF4VG91Y2hQb2ludHM6IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwLFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIG5hdi51c2VyQWdlbnQgPSBwYXJhbTtcbiAgfSBlbHNlIGlmIChwYXJhbSAmJiBwYXJhbS51c2VyQWdlbnQpIHtcbiAgICBuYXYgPSB7XG4gICAgICB1c2VyQWdlbnQ6IHBhcmFtLnVzZXJBZ2VudCxcbiAgICAgIHBsYXRmb3JtOiBwYXJhbS5wbGF0Zm9ybSxcbiAgICAgIG1heFRvdWNoUG9pbnRzOiBwYXJhbS5tYXhUb3VjaFBvaW50cyB8fCAwLFxuICAgIH07XG4gIH1cblxuICBsZXQgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudDtcblxuICAvLyBGYWNlYm9vayBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIGFkZHMgYSBidW5jaCBvZiBzdHJpbmdzIHRoYXRcbiAgLy8gbWF0Y2ggZXZlcnl0aGluZy4gU3RyaXAgaXQgb3V0IGlmIGl0IGV4aXN0cy5cbiAgbGV0IHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnW0ZCQU4nKTtcbiAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdXNlckFnZW50ID0gdG1wWzBdO1xuICB9XG5cbiAgLy8gVHdpdHRlciBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIG9uIGlQYWQgYWRkcyBhIFwiVHdpdHRlciBmb3JcbiAgLy8gaVBob25lXCIgc3RyaW5nLiBTYW1lIHByb2JhYmx5IGhhcHBlbnMgb24gb3RoZXIgdGFibGV0IHBsYXRmb3Jtcy5cbiAgLy8gVGhpcyB3aWxsIGNvbmZ1c2UgZGV0ZWN0aW9uIHNvIHN0cmlwIGl0IG91dCBpZiBpdCBleGlzdHMuXG4gIHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnVHdpdHRlcicpO1xuICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gIH1cblxuICBjb25zdCBtYXRjaCA9IGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCk7XG5cbiAgY29uc3QgcmVzdWx0OiBpc01vYmlsZVJlc3VsdCA9IHtcbiAgICBhcHBsZToge1xuICAgICAgcGhvbmU6IG1hdGNoKGFwcGxlSXBob25lKSAmJiAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgIGlwb2Q6IG1hdGNoKGFwcGxlSXBvZCksXG4gICAgICB0YWJsZXQ6XG4gICAgICAgICFtYXRjaChhcHBsZUlwaG9uZSkgJiZcbiAgICAgICAgKG1hdGNoKGFwcGxlVGFibGV0KSB8fCBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgIHVuaXZlcnNhbDogbWF0Y2goYXBwbGVVbml2ZXJzYWwpLFxuICAgICAgZGV2aWNlOlxuICAgICAgICAobWF0Y2goYXBwbGVJcGhvbmUpIHx8XG4gICAgICAgICAgbWF0Y2goYXBwbGVJcG9kKSB8fFxuICAgICAgICAgIG1hdGNoKGFwcGxlVGFibGV0KSB8fFxuICAgICAgICAgIG1hdGNoKGFwcGxlVW5pdmVyc2FsKSB8fFxuICAgICAgICAgIGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgIH0sXG4gICAgYW1hem9uOiB7XG4gICAgICBwaG9uZTogbWF0Y2goYW1hem9uUGhvbmUpLFxuICAgICAgdGFibGV0OiAhbWF0Y2goYW1hem9uUGhvbmUpICYmIG1hdGNoKGFtYXpvblRhYmxldCksXG4gICAgICBkZXZpY2U6IG1hdGNoKGFtYXpvblBob25lKSB8fCBtYXRjaChhbWF6b25UYWJsZXQpLFxuICAgIH0sXG4gICAgYW5kcm9pZDoge1xuICAgICAgcGhvbmU6XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbWF6b25QaG9uZSkpIHx8XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbmRyb2lkUGhvbmUpKSxcbiAgICAgIHRhYmxldDpcbiAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiZcbiAgICAgICAgIW1hdGNoKGFtYXpvblBob25lKSAmJlxuICAgICAgICAhbWF0Y2goYW5kcm9pZFBob25lKSAmJlxuICAgICAgICAobWF0Y2goYW1hem9uVGFibGV0KSB8fCBtYXRjaChhbmRyb2lkVGFibGV0KSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAgIChtYXRjaChhbWF6b25QaG9uZSkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFtYXpvblRhYmxldCkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRQaG9uZSkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRUYWJsZXQpKSkgfHxcbiAgICAgICAgbWF0Y2goL1xcYm9raHR0cFxcYi9pKSxcbiAgICB9LFxuICAgIHdpbmRvd3M6IHtcbiAgICAgIHBob25lOiBtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgdGFibGV0OiBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICAgIGRldmljZTogbWF0Y2god2luZG93c1Bob25lKSB8fCBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICB9LFxuICAgIG90aGVyOiB7XG4gICAgICBibGFja2JlcnJ5OiBtYXRjaChvdGhlckJsYWNrQmVycnkpLFxuICAgICAgYmxhY2tiZXJyeTEwOiBtYXRjaChvdGhlckJsYWNrQmVycnkxMCksXG4gICAgICBvcGVyYTogbWF0Y2gob3RoZXJPcGVyYSksXG4gICAgICBmaXJlZm94OiBtYXRjaChvdGhlckZpcmVmb3gpLFxuICAgICAgY2hyb21lOiBtYXRjaChvdGhlckNocm9tZSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgIG1hdGNoKG90aGVyQmxhY2tCZXJyeSkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJCbGFja0JlcnJ5MTApIHx8XG4gICAgICAgIG1hdGNoKG90aGVyT3BlcmEpIHx8XG4gICAgICAgIG1hdGNoKG90aGVyRmlyZWZveCkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJDaHJvbWUpLFxuICAgIH0sXG4gICAgYW55OiBmYWxzZSxcbiAgICBwaG9uZTogZmFsc2UsXG4gICAgdGFibGV0OiBmYWxzZSxcbiAgfTtcblxuICByZXN1bHQuYW55ID1cbiAgICByZXN1bHQuYXBwbGUuZGV2aWNlIHx8XG4gICAgcmVzdWx0LmFuZHJvaWQuZGV2aWNlIHx8XG4gICAgcmVzdWx0LndpbmRvd3MuZGV2aWNlIHx8XG4gICAgcmVzdWx0Lm90aGVyLmRldmljZTtcbiAgLy8gZXhjbHVkZXMgJ290aGVyJyBkZXZpY2VzIGFuZCBpcG9kcywgdGFyZ2V0aW5nIHRvdWNoc2NyZWVuIHBob25lc1xuICByZXN1bHQucGhvbmUgPVxuICAgIHJlc3VsdC5hcHBsZS5waG9uZSB8fCByZXN1bHQuYW5kcm9pZC5waG9uZSB8fCByZXN1bHQud2luZG93cy5waG9uZTtcbiAgcmVzdWx0LnRhYmxldCA9XG4gICAgcmVzdWx0LmFwcGxlLnRhYmxldCB8fCByZXN1bHQuYW5kcm9pZC50YWJsZXQgfHwgcmVzdWx0LndpbmRvd3MudGFibGV0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgaXNNb2JpbGVKcyBmcm9tIFwiaXNtb2JpbGVqc1wiO1xuY29uc3QgaXNNb2JpbGVDYWxsID0gaXNNb2JpbGVKcy5kZWZhdWx0ID8/IGlzTW9iaWxlSnMsIGlzTW9iaWxlID0gaXNNb2JpbGVDYWxsKGdsb2JhbFRoaXMubmF2aWdhdG9yKTtcbmV4cG9ydCB7XG4gIGlzTW9iaWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNb2JpbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQnJvd3NlckFkYXB0ZXIgfSBmcm9tIFwiLi9hZGFwdGVyLm1qc1wiO1xuaW1wb3J0IFwiLi9JQ2FudmFzLm1qc1wiO1xuaW1wb3J0IFwiLi9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELm1qc1wiO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5ncy5tanNcIjtcbmltcG9ydCB7IGlzTW9iaWxlIH0gZnJvbSBcIi4vdXRpbHMvaXNNb2JpbGUubWpzXCI7XG5leHBvcnQge1xuICBCcm93c2VyQWRhcHRlcixcbiAgaXNNb2JpbGUsXG4gIHNldHRpbmdzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmltcG9ydCB7IHNldHRpbmdzIGFzIHNldHRpbmdzMiB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWCA9IC9AKFswLTlcXC5dKyl4LztcbnNldHRpbmdzLkZBSUxfSUZfTUFKT1JfUEVSRk9STUFOQ0VfQ0FWRUFUID0gITE7XG5leHBvcnQge1xuICBzZXR0aW5nczIgYXMgc2V0dGluZ3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJjb25zdCB3YXJuaW5ncyA9IHt9O1xuZnVuY3Rpb24gZGVwcmVjYXRpb24odmVyc2lvbiwgbWVzc2FnZSwgaWdub3JlRGVwdGggPSAzKSB7XG4gIGlmICh3YXJuaW5nc1ttZXNzYWdlXSlcbiAgICByZXR1cm47XG4gIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICB0eXBlb2Ygc3RhY2sgPiBcInVcIiA/IGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKSA6IChzdGFjayA9IHN0YWNrLnNwbGl0KGBcbmApLnNwbGljZShpZ25vcmVEZXB0aCkuam9pbihgXG5gKSwgY29uc29sZS5ncm91cENvbGxhcHNlZCA/IChjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgIFwiJWNQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogJWMlc1wiLFxuICAgIFwiY29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTZcIixcbiAgICBcImZvbnQtd2VpZ2h0Om5vcm1hbDtjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLFxuICAgIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YFxuICApLCBjb25zb2xlLndhcm4oc3RhY2spLCBjb25zb2xlLmdyb3VwRW5kKCkpIDogKGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKSwgY29uc29sZS53YXJuKHN0YWNrKSkpLCB3YXJuaW5nc1ttZXNzYWdlXSA9ICEwO1xufVxuZXhwb3J0IHtcbiAgZGVwcmVjYXRpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGlvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBwYXJzZSwgZm9ybWF0LCByZXNvbHZlIH0gZnJvbSBcInVybFwiO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tIFwiLi9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qc1wiO1xuY29uc3QgdXJsID0ge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4zLjBcbiAgICovXG4gIGdldCBwYXJzZSgpIHtcbiAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjMuMFwiLCBcInV0aWxzLnVybC5wYXJzZSBpcyBkZXByZWNhdGVkLCB1c2UgbmF0aXZlIFVSTCBBUEkgaW5zdGVhZC5cIiksIHBhcnNlO1xuICB9LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4zLjBcbiAgICovXG4gIGdldCBmb3JtYXQoKSB7XG4gICAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4zLjBcIiwgXCJ1dGlscy51cmwuZm9ybWF0IGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXRpdmUgVVJMIEFQSSBpbnN0ZWFkLlwiKSwgZm9ybWF0O1xuICB9LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4zLjBcbiAgICovXG4gIGdldCByZXNvbHZlKCkge1xuICAgIHJldHVybiBkZXByZWNhdGlvbihcIjcuMy4wXCIsIFwidXRpbHMudXJsLnJlc29sdmUgaXMgZGVwcmVjYXRlZCwgdXNlIG5hdGl2ZSBVUkwgQVBJIGluc3RlYWQuXCIpLCByZXNvbHZlO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgdXJsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgyKSB7XG4gIGlmICh0eXBlb2YgcGF0aDIgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkocGF0aDIpfWApO1xufVxuZnVuY3Rpb24gcmVtb3ZlVXJsUGFyYW1zKHVybCkge1xuICByZXR1cm4gdXJsLnNwbGl0KFwiP1wiKVswXS5zcGxpdChcIiNcIilbMF07XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChzdHIsIGZpbmQsIHJlcGxhY2UpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGZpbmQpLCBcImdcIiksIHJlcGxhY2UpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aDIsIGFsbG93QWJvdmVSb290KSB7XG4gIGxldCByZXMgPSBcIlwiLCBsYXN0U2VnbWVudExlbmd0aCA9IDAsIGxhc3RTbGFzaCA9IC0xLCBkb3RzID0gMCwgY29kZSA9IC0xO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXRoMi5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aDIubGVuZ3RoKVxuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29kZSA9IDQ3O1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgIGlmICghKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkpXG4gICAgICAgIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2KSB7XG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNsYXNoSW5kZXggPT09IC0xID8gKHJlcyA9IFwiXCIsIGxhc3RTZWdtZW50TGVuZ3RoID0gMCkgOiAocmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KSwgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZihcIi9cIikpLCBsYXN0U2xhc2ggPSBpLCBkb3RzID0gMDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmVzID0gXCJcIiwgbGFzdFNlZ21lbnRMZW5ndGggPSAwLCBsYXN0U2xhc2ggPSBpLCBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFsbG93QWJvdmVSb290ICYmIChyZXMubGVuZ3RoID4gMCA/IHJlcyArPSBcIi8uLlwiIDogcmVzID0gXCIuLlwiLCBsYXN0U2VnbWVudExlbmd0aCA9IDIpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXMubGVuZ3RoID4gMCA/IHJlcyArPSBgLyR7cGF0aDIuc2xpY2UobGFzdFNsYXNoICsgMSwgaSl9YCA6IHJlcyA9IHBhdGgyLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpLCBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgbGFzdFNsYXNoID0gaSwgZG90cyA9IDA7XG4gICAgfSBlbHNlXG4gICAgICBjb2RlID09PSA0NiAmJiBkb3RzICE9PSAtMSA/ICsrZG90cyA6IGRvdHMgPSAtMTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuY29uc3QgcGF0aCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcGF0aCB0byBwb3NpeCBmb3JtYXQuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY29udmVydCB0byBwb3NpeFxuICAgKi9cbiAgdG9Qb3NpeChwYXRoMikge1xuICAgIHJldHVybiByZXBsYWNlQWxsKHBhdGgyLCBcIlxcXFxcIiwgXCIvXCIpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGlzIGEgVVJMIGUuZy4gaHR0cDovLywgaHR0cHM6Ly9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaXNVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gL15odHRwcz86Ly50ZXN0KHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGlzIGEgZGF0YSBVUkxcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaXNEYXRhVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16MC05LS4hIyQlKisue318fmBdKz1bYS16MC05LS4hIyQlKisue30oKV98fmBdKykqKT8oO2Jhc2U2NCk/LChbYS16MC05ISQmJywoKSorOz1cXC0uX346QFxcLz8lXFxzPD5dKj8pJC9pLnRlc3QocGF0aDIpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGlzIGEgYmxvYiBVUkxcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaXNCbG9iVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIHBhdGgyLnN0YXJ0c1dpdGgoXCJibG9iOlwiKTtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGF0aCBoYXMgYSBwcm90b2NvbCBlLmcuIGh0dHA6Ly8sIGh0dHBzOi8vLCBmaWxlOi8vLywgZGF0YTosIGJsb2I6LCBDOi9cbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciB3aW5kb3dzIGZpbGUgcGF0aHNcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVja1xuICAgKi9cbiAgaGFzUHJvdG9jb2wocGF0aDIpIHtcbiAgICByZXR1cm4gL15bXi86XSs6Ly50ZXN0KHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvdG9jb2wgb2YgdGhlIHBhdGggZS5nLiBodHRwOi8vLCBodHRwczovLywgZmlsZTovLy8sIGRhdGE6LCBibG9iOiwgQzovXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gZ2V0IHRoZSBwcm90b2NvbCBmcm9tXG4gICAqL1xuICBnZXRQcm90b2NvbChwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpLCBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgY29uc3QgbWF0Y2hGaWxlID0gL15maWxlOlxcL1xcL1xcLy8uZXhlYyhwYXRoMik7XG4gICAgaWYgKG1hdGNoRmlsZSlcbiAgICAgIHJldHVybiBtYXRjaEZpbGVbMF07XG4gICAgY29uc3QgbWF0Y2hQcm90b2NvbCA9IC9eW14vOl0rOlxcL3swLDJ9Ly5leGVjKHBhdGgyKTtcbiAgICByZXR1cm4gbWF0Y2hQcm90b2NvbCA/IG1hdGNoUHJvdG9jb2xbMF0gOiBcIlwiO1xuICB9LFxuICAvKipcbiAgICogQ29udmVydHMgVVJMIHRvIGFuIGFic29sdXRlIHBhdGguXG4gICAqIFdoZW4gbG9hZGluZyBmcm9tIGEgV2ViIFdvcmtlciwgd2UgbXVzdCB1c2UgYWJzb2x1dGUgcGF0aHMuXG4gICAqIElmIHRoZSBVUkwgaXMgYWxyZWFkeSBhYnNvbHV0ZSB3ZSByZXR1cm4gaXQgYXMgaXNcbiAgICogSWYgaXQncyBub3QsIHdlIGNvbnZlcnQgaXRcbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gdGVzdFxuICAgKiBAcGFyYW0gY3VzdG9tQmFzZVVybCAtIFRoZSBiYXNlIFVSTCB0byB1c2VcbiAgICogQHBhcmFtIGN1c3RvbVJvb3RVcmwgLSBUaGUgcm9vdCBVUkwgdG8gdXNlXG4gICAqL1xuICB0b0Fic29sdXRlKHVybCwgY3VzdG9tQmFzZVVybCwgY3VzdG9tUm9vdFVybCkge1xuICAgIGlmIChhc3NlcnRQYXRoKHVybCksIHRoaXMuaXNEYXRhVXJsKHVybCkgfHwgdGhpcy5pc0Jsb2JVcmwodXJsKSlcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgYmFzZVVybCA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgoY3VzdG9tQmFzZVVybCA/PyBzZXR0aW5ncy5BREFQVEVSLmdldEJhc2VVcmwoKSkpLCByb290VXJsID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChjdXN0b21Sb290VXJsID8/IHRoaXMucm9vdG5hbWUoYmFzZVVybCkpKTtcbiAgICByZXR1cm4gdXJsID0gdGhpcy50b1Bvc2l4KHVybCksIHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IHBhdGguam9pbihyb290VXJsLCB1cmwuc2xpY2UoMSkpIDogdGhpcy5pc0Fic29sdXRlKHVybCkgPyB1cmwgOiB0aGlzLmpvaW4oYmFzZVVybCwgdXJsKTtcbiAgfSxcbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGgsIHJlc29sdmluZyAnLi4nIGFuZCAnLicgc2VnbWVudHNcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBub3JtYWxpemVcbiAgICovXG4gIG5vcm1hbGl6ZShwYXRoMikge1xuICAgIGlmIChhc3NlcnRQYXRoKHBhdGgyKSwgcGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIGlmICh0aGlzLmlzRGF0YVVybChwYXRoMikgfHwgdGhpcy5pc0Jsb2JVcmwocGF0aDIpKVxuICAgICAgcmV0dXJuIHBhdGgyO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBsZXQgcHJvdG9jb2wgPSBcIlwiO1xuICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoMi5zdGFydHNXaXRoKFwiL1wiKTtcbiAgICB0aGlzLmhhc1Byb3RvY29sKHBhdGgyKSAmJiAocHJvdG9jb2wgPSB0aGlzLnJvb3RuYW1lKHBhdGgyKSwgcGF0aDIgPSBwYXRoMi5zbGljZShwcm90b2NvbC5sZW5ndGgpKTtcbiAgICBjb25zdCB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGgyLmVuZHNXaXRoKFwiL1wiKTtcbiAgICByZXR1cm4gcGF0aDIgPSBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoMiwgITEpLCBwYXRoMi5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yICYmIChwYXRoMiArPSBcIi9cIiksIGlzQWJzb2x1dGUgPyBgLyR7cGF0aDJ9YCA6IHByb3RvY29sICsgcGF0aDI7XG4gIH0sXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHBhdGggaXMgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICogQWJzb2x1dGUgcGF0aHMgY2FuIGJlIHVybHMsIGRhdGEgdXJscywgb3IgcGF0aHMgb24gZGlza1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRlc3RcbiAgICovXG4gIGlzQWJzb2x1dGUocGF0aDIpIHtcbiAgICByZXR1cm4gYXNzZXJ0UGF0aChwYXRoMiksIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKSwgdGhpcy5oYXNQcm90b2NvbChwYXRoMikgPyAhMCA6IHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpO1xuICB9LFxuICAvKipcbiAgICogSm9pbnMgYWxsIGdpdmVuIHBhdGggc2VnbWVudHMgdG9nZXRoZXIgdXNpbmcgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHNlcGFyYXRvciBhcyBhIGRlbGltaXRlcixcbiAgICogdGhlbiBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aFxuICAgKiBAcGFyYW0gc2VnbWVudHMgLSBUaGUgc2VnbWVudHMgb2YgdGhlIHBhdGggdG8gam9pblxuICAgKi9cbiAgam9pbiguLi5zZWdtZW50cykge1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgbGV0IGpvaW5lZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBhcmcgPSBzZWdtZW50c1tpXTtcbiAgICAgIGlmIChhc3NlcnRQYXRoKGFyZyksIGFyZy5sZW5ndGggPiAwKVxuICAgICAgICBpZiAoam9pbmVkID09PSB2b2lkIDApXG4gICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmV2QXJnID0gc2VnbWVudHNbaSAtIDFdID8/IFwiXCI7XG4gICAgICAgICAgdGhpcy5qb2luRXh0ZW5zaW9ucy5pbmNsdWRlcyh0aGlzLmV4dG5hbWUocHJldkFyZykudG9Mb3dlckNhc2UoKSkgPyBqb2luZWQgKz0gYC8uLi8ke2FyZ31gIDogam9pbmVkICs9IGAvJHthcmd9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gam9pbmVkID09PSB2b2lkIDAgPyBcIi5cIiA6IHRoaXMubm9ybWFsaXplKGpvaW5lZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgbmFtZSBvZiBhIHBhdGhcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgZGlybmFtZShwYXRoMikge1xuICAgIGlmIChhc3NlcnRQYXRoKHBhdGgyKSwgcGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBsZXQgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgaGFzUm9vdCA9IGNvZGUgPT09IDQ3O1xuICAgIGxldCBlbmQgPSAtMSwgbWF0Y2hlZFNsYXNoID0gITA7XG4gICAgY29uc3QgcHJvdG8gPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKSwgb3JpZ3BhdGggPSBwYXRoMjtcbiAgICBwYXRoMiA9IHBhdGgyLnNsaWNlKHByb3RvLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKVxuICAgICAgaWYgKGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpLCBjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXRjaGVkU2xhc2ggPSAhMTtcbiAgICByZXR1cm4gZW5kID09PSAtMSA/IGhhc1Jvb3QgPyBcIi9cIiA6IHRoaXMuaXNVcmwob3JpZ3BhdGgpID8gcHJvdG8gKyBwYXRoMiA6IHByb3RvIDogaGFzUm9vdCAmJiBlbmQgPT09IDEgPyBcIi8vXCIgOiBwcm90byArIHBhdGgyLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG9mIHRoZSBwYXRoIGUuZy4gLywgQzovLCBmaWxlOi8vLywgaHR0cDovL2RvbWFpbi5jb20vXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcGFyc2VcbiAgICovXG4gIHJvb3RuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMiksIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBsZXQgcm9vdCA9IFwiXCI7XG4gICAgaWYgKHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpID8gcm9vdCA9IFwiL1wiIDogcm9vdCA9IHRoaXMuZ2V0UHJvdG9jb2wocGF0aDIpLCB0aGlzLmlzVXJsKHBhdGgyKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXRoMi5pbmRleE9mKFwiL1wiLCByb290Lmxlbmd0aCk7XG4gICAgICBpbmRleCAhPT0gLTEgPyByb290ID0gcGF0aDIuc2xpY2UoMCwgaW5kZXgpIDogcm9vdCA9IHBhdGgyLCByb290LmVuZHNXaXRoKFwiL1wiKSB8fCAocm9vdCArPSBcIi9cIik7XG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBwb3J0aW9uIG9mIGEgcGF0aFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRlc3RcbiAgICogQHBhcmFtIGV4dCAtIE9wdGlvbmFsIGV4dGVuc2lvbiB0byByZW1vdmVcbiAgICovXG4gIGJhc2VuYW1lKHBhdGgyLCBleHQpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKSwgZXh0ICYmIGFzc2VydFBhdGgoZXh0KSwgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IHN0YXJ0ID0gMCwgZW5kID0gLTEsIG1hdGNoZWRTbGFzaCA9ICEwLCBpO1xuICAgIGlmIChleHQgIT09IHZvaWQgMCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgyLmxlbmd0aCkge1xuICAgICAgaWYgKGV4dC5sZW5ndGggPT09IHBhdGgyLmxlbmd0aCAmJiBleHQgPT09IHBhdGgyKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGxldCBleHRJZHggPSBleHQubGVuZ3RoIC0gMSwgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID09PSAtMSAmJiAobWF0Y2hlZFNsYXNoID0gITEsIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMSksIGV4dElkeCA+PSAwICYmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpID8gLS1leHRJZHggPT09IC0xICYmIChlbmQgPSBpKSA6IChleHRJZHggPSAtMSwgZW5kID0gZmlyc3ROb25TbGFzaEVuZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgPyBlbmQgPSBmaXJzdE5vblNsYXNoRW5kIDogZW5kID09PSAtMSAmJiAoZW5kID0gcGF0aDIubGVuZ3RoKSwgcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgaWYgKHBhdGgyLmNoYXJDb2RlQXQoaSkgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGVuZCA9PT0gLTEgJiYgKG1hdGNoZWRTbGFzaCA9ICExLCBlbmQgPSBpICsgMSk7XG4gICAgcmV0dXJuIGVuZCA9PT0gLTEgPyBcIlwiIDogcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhdGgsIGZyb20gdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiB0aGUgLiAocGVyaW9kKSBjaGFyYWN0ZXIgdG8gZW5kIG9mIHN0cmluZyBpbiB0aGUgbGFzdFxuICAgKiBwb3J0aW9uIG9mIHRoZSBwYXRoLiBJZiB0aGVyZSBpcyBubyAuIGluIHRoZSBsYXN0IHBvcnRpb24gb2YgdGhlIHBhdGgsIG9yIGlmIHRoZXJlIGFyZSBubyAuIGNoYXJhY3RlcnMgb3RoZXIgdGhhblxuICAgKiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBiYXNlbmFtZSBvZiBwYXRoLCBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcGFyc2VcbiAgICovXG4gIGV4dG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKSwgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IHN0YXJ0RG90ID0gLTEsIHN0YXJ0UGFydCA9IDAsIGVuZCA9IC0xLCBtYXRjaGVkU2xhc2ggPSAhMCwgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGVuZCA9PT0gLTEgJiYgKG1hdGNoZWRTbGFzaCA9ICExLCBlbmQgPSBpICsgMSksIGNvZGUgPT09IDQ2ID8gc3RhcnREb3QgPT09IC0xID8gc3RhcnREb3QgPSBpIDogcHJlRG90U3RhdGUgIT09IDEgJiYgKHByZURvdFN0YXRlID0gMSkgOiBzdGFydERvdCAhPT0gLTEgJiYgKHByZURvdFN0YXRlID0gLTEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHwgcHJlRG90U3RhdGUgPT09IDAgfHwgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEgPyBcIlwiIDogcGF0aDIuc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBwYXRoIGludG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlICdyb290JywgYGRpcmAsIGBiYXNlYCwgYGV4dGAsIGFuZCBgbmFtZWAgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgcGFyc2UocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBjb25zdCByZXQgPSB7IHJvb3Q6IFwiXCIsIGRpcjogXCJcIiwgYmFzZTogXCJcIiwgZXh0OiBcIlwiLCBuYW1lOiBcIlwiIH07XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiByZXQ7XG4gICAgcGF0aDIgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gICAgbGV0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGlzQWJzb2x1dGUgPSB0aGlzLmlzQWJzb2x1dGUocGF0aDIpO1xuICAgIGxldCBzdGFydDtcbiAgICBjb25zdCBwcm90b2NvbCA9IFwiXCI7XG4gICAgcmV0LnJvb3QgPSB0aGlzLnJvb3RuYW1lKHBhdGgyKSwgaXNBYnNvbHV0ZSB8fCB0aGlzLmhhc1Byb3RvY29sKHBhdGgyKSA/IHN0YXJ0ID0gMSA6IHN0YXJ0ID0gMDtcbiAgICBsZXQgc3RhcnREb3QgPSAtMSwgc3RhcnRQYXJ0ID0gMCwgZW5kID0gLTEsIG1hdGNoZWRTbGFzaCA9ICEwLCBpID0gcGF0aDIubGVuZ3RoIC0gMSwgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgIGlmIChjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKSwgY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGVuZCA9PT0gLTEgJiYgKG1hdGNoZWRTbGFzaCA9ICExLCBlbmQgPSBpICsgMSksIGNvZGUgPT09IDQ2ID8gc3RhcnREb3QgPT09IC0xID8gc3RhcnREb3QgPSBpIDogcHJlRG90U3RhdGUgIT09IDEgJiYgKHByZURvdFN0YXRlID0gMSkgOiBzdGFydERvdCAhPT0gLTEgJiYgKHByZURvdFN0YXRlID0gLTEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHwgcHJlRG90U3RhdGUgPT09IDAgfHwgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEgPyBlbmQgIT09IC0xICYmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSA/IHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBlbmQpIDogcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgZW5kKSkgOiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUgPyAocmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBzdGFydERvdCksIHJldC5iYXNlID0gcGF0aDIuc2xpY2UoMSwgZW5kKSkgOiAocmV0Lm5hbWUgPSBwYXRoMi5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KSwgcmV0LmJhc2UgPSBwYXRoMi5zbGljZShzdGFydFBhcnQsIGVuZCkpLCByZXQuZXh0ID0gcGF0aDIuc2xpY2Uoc3RhcnREb3QsIGVuZCkpLCByZXQuZGlyID0gdGhpcy5kaXJuYW1lKHBhdGgyKSwgcHJvdG9jb2wgJiYgKHJldC5kaXIgPSBwcm90b2NvbCArIHJldC5kaXIpLCByZXQ7XG4gIH0sXG4gIHNlcDogXCIvXCIsXG4gIGRlbGltaXRlcjogXCI6XCIsXG4gIGpvaW5FeHRlbnNpb25zOiBbXCIuaHRtbFwiXVxufTtcbmV4cG9ydCB7XG4gIHBhdGhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xubGV0IHByb21pc2U7XG5hc3luYyBmdW5jdGlvbiBkZXRlY3RWaWRlb0FscGhhTW9kZSgpIHtcbiAgcmV0dXJuIHByb21pc2UgPz8gKHByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGdsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG4gICAgaWYgKCFnbClcbiAgICAgIHJldHVybiBBTFBIQV9NT0RFUy5VTlBBQ0s7XG4gICAgY29uc3QgdmlkZW8gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgdmlkZW8yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgdmlkZW8yLm9ubG9hZGVkZGF0YSA9ICgpID0+IHJlc29sdmUodmlkZW8yKSwgdmlkZW8yLm9uZXJyb3IgPSAoKSA9PiByZXNvbHZlKG51bGwpLCB2aWRlbzIuYXV0b3BsYXkgPSAhMSwgdmlkZW8yLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIiwgdmlkZW8yLnByZWxvYWQgPSBcImF1dG9cIiwgdmlkZW8yLnNyYyA9IFwiZGF0YTp2aWRlby93ZWJtO2Jhc2U2NCxHa1hmbzU5Q2hvRUJRdmVCQVVMeWdRUkM4NEVJUW9LRWQyVmliVUtIZ1FKQ2hZRUNHRk9BWndFQUFBQUFBQUhURVUyYmRMcE51NHRUcTRRVlNhbG1VNnlCb1UyN2kxT3JoQlpVcm10VHJJSEdUYnVNVTZ1RUVsVERaMU9zZ2dFWFRidU1VNnVFSEZPN2ExT3NnZ0c5N0FFQUFBQUFBQUJaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFWU2FsbW9DclhzWU1QUWtCTmdJUk1ZWFptVjBHRVRHRjJaa1NKaUVCRUFBQUFBQUFBRmxTdWE4eXVBUUFBQUFBQUFFUFhnUUZ6eFlnQUFBQUFBQUFBQVp5QkFDSzFuSU4xYm1TSWdRQ0doVlpmVmxBNWc0RUJJK09EaEFKaVdnRGdsTENCQXJxQkFwcUJBbFBBZ1FGVnNJUlZ1WUVCRWxURFo5VnpjOUpqd0l0anhZZ0FBQUFBQUFBQUFXZkluRVdqaDBWT1EwOUVSVkpFaDQ5TVlYWmpJR3hwWW5ad2VDMTJjRGxueUtKRm80aEVWVkpCVkVsUFRrU0hsREF3T2pBd09qQXdMakEwTURBd01EQXdNQUFBSDBPMmRjZm5nUUNnd3FHZ2dRQUFBSUpKZzBJQUFCQUFGZ0E0SkJ3WVNnQUFJQ0FBRWIvLy80citBQUIxb1oybW0rNkJBYVdXZ2ttRFFnQUFFQUFXQURna0hCaEtBQUFnSUFCSVFCeFR1MnVSdTQremdRQzNpdmVCQWZHQ0FYSHdnUU09XCIsIHZpZGVvMi5sb2FkKCk7XG4gICAgfSk7XG4gICAgaWYgKCF2aWRlbylcbiAgICAgIHJldHVybiBBTFBIQV9NT0RFUy5VTlBBQ0s7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciksIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0ZXh0dXJlLFxuICAgICAgMFxuICAgICksIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgITEpLCBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBnbC5OT05FKSwgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB2aWRlbyk7XG4gICAgY29uc3QgcGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbCksIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSwgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKSwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpPy5sb3NlQ29udGV4dCgpLCBwaXhlbFswXSA8PSBwaXhlbFszXSA/IEFMUEhBX01PREVTLlBNQSA6IEFMUEhBX01PREVTLlVOUEFDSztcbiAgfSkoKSksIHByb21pc2U7XG59XG5leHBvcnQge1xuICBkZXRlY3RWaWRlb0FscGhhTW9kZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFZpZGVvQWxwaGFNb2RlLm1qcy5tYXBcbiIsImltcG9ydCB7IGRlcHJlY2F0aW9uIH0gZnJvbSBcIi4uL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzXCI7XG5mdW5jdGlvbiBza2lwSGVsbG8oKSB7XG4gIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJza2lwSGVsbG8gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBzZXR0aW5ncy5SRU5ERVJfT1BUSU9OUy5oZWxsb1wiKTtcbn1cbmZ1bmN0aW9uIHNheUhlbGxvKCkge1xuICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIGBzYXlIZWxsbyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFJlbmRlcmVyJ3MgXCJoZWxsb1wiIG9wdGlvbmApO1xufVxuZXhwb3J0IHtcbiAgc2F5SGVsbG8sXG4gIHNraXBIZWxsb1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbGxvLm1qcy5tYXBcbiIsImltcG9ydCBcIi4uL3NldHRpbmdzLm1qc1wiO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmxldCBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHN1cHBvcnRlZCA+IFwidVwiICYmIChzdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgIHN0ZW5jaWw6ICEwLFxuICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogc2V0dGluZ3MuRkFJTF9JRl9NQUpPUl9QRVJGT1JNQU5DRV9DQVZFQVRcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXNldHRpbmdzLkFEQVBURVIuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIGNvbnRleHRPcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICBjb25zdCBzdWNjZXNzID0gISFnbD8uZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKT8uc3RlbmNpbDtcbiAgICAgIGlmIChnbCkge1xuICAgICAgICBjb25zdCBsb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcbiAgICAgICAgbG9zZUNvbnRleHQgJiYgbG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnbCA9IG51bGwsIHN1Y2Nlc3M7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9KCkpLCBzdXBwb3J0ZWQ7XG59XG5leHBvcnQge1xuICBpc1dlYkdMU3VwcG9ydGVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNXZWJHTFN1cHBvcnRlZC5tanMubWFwXG4iLCJ2YXIgcj17Z3JhZDouOSx0dXJuOjM2MCxyYWQ6MzYwLygyKk1hdGguUEkpfSx0PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP3IubGVuZ3RoPjA6XCJudW1iZXJcIj09dHlwZW9mIHJ9LG49ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj1NYXRoLnBvdygxMCx0KSksTWF0aC5yb3VuZChuKnIpL24rMH0sZT1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PW4mJihuPTEpLHI+bj9uOnI+dD9yOnR9LHU9ZnVuY3Rpb24ocil7cmV0dXJuKHI9aXNGaW5pdGUocik/ciUzNjA6MCk+MD9yOnIrMzYwfSxhPWZ1bmN0aW9uKHIpe3JldHVybntyOmUoci5yLDAsMjU1KSxnOmUoci5nLDAsMjU1KSxiOmUoci5iLDAsMjU1KSxhOmUoci5hKX19LG89ZnVuY3Rpb24ocil7cmV0dXJue3I6bihyLnIpLGc6bihyLmcpLGI6bihyLmIpLGE6bihyLmEsMyl9fSxpPS9eIyhbMC05YS1mXXszLDh9KSQvaSxzPWZ1bmN0aW9uKHIpe3ZhciB0PXIudG9TdHJpbmcoMTYpO3JldHVybiB0Lmxlbmd0aDwyP1wiMFwiK3Q6dH0saD1mdW5jdGlvbihyKXt2YXIgdD1yLnIsbj1yLmcsZT1yLmIsdT1yLmEsYT1NYXRoLm1heCh0LG4sZSksbz1hLU1hdGgubWluKHQsbixlKSxpPW8/YT09PXQ/KG4tZSkvbzphPT09bj8yKyhlLXQpL286NCsodC1uKS9vOjA7cmV0dXJue2g6NjAqKGk8MD9pKzY6aSksczphP28vYSoxMDA6MCx2OmEvMjU1KjEwMCxhOnV9fSxiPWZ1bmN0aW9uKHIpe3ZhciB0PXIuaCxuPXIucyxlPXIudix1PXIuYTt0PXQvMzYwKjYsbi89MTAwLGUvPTEwMDt2YXIgYT1NYXRoLmZsb29yKHQpLG89ZSooMS1uKSxpPWUqKDEtKHQtYSkqbikscz1lKigxLSgxLXQrYSkqbiksaD1hJTY7cmV0dXJue3I6MjU1KltlLGksbyxvLHMsZV1baF0sZzoyNTUqW3MsZSxlLGksbyxvXVtoXSxiOjI1NSpbbyxvLHMsZSxlLGldW2hdLGE6dX19LGc9ZnVuY3Rpb24ocil7cmV0dXJue2g6dShyLmgpLHM6ZShyLnMsMCwxMDApLGw6ZShyLmwsMCwxMDApLGE6ZShyLmEpfX0sZD1mdW5jdGlvbihyKXtyZXR1cm57aDpuKHIuaCksczpuKHIucyksbDpuKHIubCksYTpuKHIuYSwzKX19LGY9ZnVuY3Rpb24ocil7cmV0dXJuIGIoKG49KHQ9cikucyx7aDp0Lmgsczoobio9KChlPXQubCk8NTA/ZToxMDAtZSkvMTAwKT4wPzIqbi8oZStuKSoxMDA6MCx2OmUrbixhOnQuYX0pKTt2YXIgdCxuLGV9LGM9ZnVuY3Rpb24ocil7cmV0dXJue2g6KHQ9aChyKSkuaCxzOih1PSgyMDAtKG49dC5zKSkqKGU9dC52KS8xMDApPjAmJnU8MjAwP24qZS8xMDAvKHU8PTEwMD91OjIwMC11KSoxMDA6MCxsOnUvMixhOnQuYX07dmFyIHQsbixlLHV9LGw9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKyklXFxzKig/OixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKT9cXCkkL2kscD0vXmhzbGE/XFwoXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoZGVnfHJhZHxncmFkfHR1cm4pP1xccysoWystXT9cXGQqXFwuP1xcZCspJVxccysoWystXT9cXGQqXFwuP1xcZCspJVxccyooPzpcXC9cXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKT9cXCkkL2ksdj0vXnJnYmE/XFwoXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLG09L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccysoWystXT9cXGQqXFwuP1xcZCspKCUpP1xccysoWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyooPzpcXC9cXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKT9cXCkkL2kseT17c3RyaW5nOltbZnVuY3Rpb24ocil7dmFyIHQ9aS5leGVjKHIpO3JldHVybiB0PyhyPXRbMV0pLmxlbmd0aDw9ND97cjpwYXJzZUludChyWzBdK3JbMF0sMTYpLGc6cGFyc2VJbnQoclsxXStyWzFdLDE2KSxiOnBhcnNlSW50KHJbMl0rclsyXSwxNiksYTo0PT09ci5sZW5ndGg/bihwYXJzZUludChyWzNdK3JbM10sMTYpLzI1NSwyKToxfTo2PT09ci5sZW5ndGh8fDg9PT1yLmxlbmd0aD97cjpwYXJzZUludChyLnN1YnN0cigwLDIpLDE2KSxnOnBhcnNlSW50KHIuc3Vic3RyKDIsMiksMTYpLGI6cGFyc2VJbnQoci5zdWJzdHIoNCwyKSwxNiksYTo4PT09ci5sZW5ndGg/bihwYXJzZUludChyLnN1YnN0cig2LDIpLDE2KS8yNTUsMik6MX06bnVsbDpudWxsfSxcImhleFwiXSxbZnVuY3Rpb24ocil7dmFyIHQ9di5leGVjKHIpfHxtLmV4ZWMocik7cmV0dXJuIHQ/dFsyXSE9PXRbNF18fHRbNF0hPT10WzZdP251bGw6YSh7cjpOdW1iZXIodFsxXSkvKHRbMl0/MTAwLzI1NToxKSxnOk51bWJlcih0WzNdKS8odFs0XT8xMDAvMjU1OjEpLGI6TnVtYmVyKHRbNV0pLyh0WzZdPzEwMC8yNTU6MSksYTp2b2lkIDA9PT10WzddPzE6TnVtYmVyKHRbN10pLyh0WzhdPzEwMDoxKX0pOm51bGx9LFwicmdiXCJdLFtmdW5jdGlvbih0KXt2YXIgbj1sLmV4ZWModCl8fHAuZXhlYyh0KTtpZighbilyZXR1cm4gbnVsbDt2YXIgZSx1LGE9Zyh7aDooZT1uWzFdLHU9blsyXSx2b2lkIDA9PT11JiYodT1cImRlZ1wiKSxOdW1iZXIoZSkqKHJbdV18fDEpKSxzOk51bWJlcihuWzNdKSxsOk51bWJlcihuWzRdKSxhOnZvaWQgMD09PW5bNV0/MTpOdW1iZXIobls1XSkvKG5bNl0/MTAwOjEpfSk7cmV0dXJuIGYoYSl9LFwiaHNsXCJdXSxvYmplY3Q6W1tmdW5jdGlvbihyKXt2YXIgbj1yLnIsZT1yLmcsdT1yLmIsbz1yLmEsaT12b2lkIDA9PT1vPzE6bztyZXR1cm4gdChuKSYmdChlKSYmdCh1KT9hKHtyOk51bWJlcihuKSxnOk51bWJlcihlKSxiOk51bWJlcih1KSxhOk51bWJlcihpKX0pOm51bGx9LFwicmdiXCJdLFtmdW5jdGlvbihyKXt2YXIgbj1yLmgsZT1yLnMsdT1yLmwsYT1yLmEsbz12b2lkIDA9PT1hPzE6YTtpZighdChuKXx8IXQoZSl8fCF0KHUpKXJldHVybiBudWxsO3ZhciBpPWcoe2g6TnVtYmVyKG4pLHM6TnVtYmVyKGUpLGw6TnVtYmVyKHUpLGE6TnVtYmVyKG8pfSk7cmV0dXJuIGYoaSl9LFwiaHNsXCJdLFtmdW5jdGlvbihyKXt2YXIgbj1yLmgsYT1yLnMsbz1yLnYsaT1yLmEscz12b2lkIDA9PT1pPzE6aTtpZighdChuKXx8IXQoYSl8fCF0KG8pKXJldHVybiBudWxsO3ZhciBoPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSx2OmUoci52LDAsMTAwKSxhOmUoci5hKX19KHtoOk51bWJlcihuKSxzOk51bWJlcihhKSx2Ok51bWJlcihvKSxhOk51bWJlcihzKX0pO3JldHVybiBiKGgpfSxcImhzdlwiXV19LE49ZnVuY3Rpb24ocix0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGU9dFtuXVswXShyKTtpZihlKXJldHVybltlLHRbbl1bMV1dfXJldHVybltudWxsLHZvaWQgMF19LHg9ZnVuY3Rpb24ocil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHI/TihyLnRyaW0oKSx5LnN0cmluZyk6XCJvYmplY3RcIj09dHlwZW9mIHImJm51bGwhPT1yP04ocix5Lm9iamVjdCk6W251bGwsdm9pZCAwXX0sST1mdW5jdGlvbihyKXtyZXR1cm4geChyKVsxXX0sTT1mdW5jdGlvbihyLHQpe3ZhciBuPWMocik7cmV0dXJue2g6bi5oLHM6ZShuLnMrMTAwKnQsMCwxMDApLGw6bi5sLGE6bi5hfX0sSD1mdW5jdGlvbihyKXtyZXR1cm4oMjk5KnIucis1ODcqci5nKzExNCpyLmIpLzFlMy8yNTV9LCQ9ZnVuY3Rpb24ocix0KXt2YXIgbj1jKHIpO3JldHVybntoOm4uaCxzOm4ucyxsOmUobi5sKzEwMCp0LDAsMTAwKSxhOm4uYX19LGo9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHIpe3RoaXMucGFyc2VkPXgocilbMF0sdGhpcy5yZ2JhPXRoaXMucGFyc2VkfHx7cjowLGc6MCxiOjAsYToxfX1yZXR1cm4gci5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5wYXJzZWR9LHIucHJvdG90eXBlLmJyaWdodG5lc3M9ZnVuY3Rpb24oKXtyZXR1cm4gbihIKHRoaXMucmdiYSksMil9LHIucHJvdG90eXBlLmlzRGFyaz1mdW5jdGlvbigpe3JldHVybiBIKHRoaXMucmdiYSk8LjV9LHIucHJvdG90eXBlLmlzTGlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gSCh0aGlzLnJnYmEpPj0uNX0sci5wcm90b3R5cGUudG9IZXg9ZnVuY3Rpb24oKXtyZXR1cm4gcj1vKHRoaXMucmdiYSksdD1yLnIsZT1yLmcsdT1yLmIsaT0oYT1yLmEpPDE/cyhuKDI1NSphKSk6XCJcIixcIiNcIitzKHQpK3MoZSkrcyh1KStpO3ZhciByLHQsZSx1LGEsaX0sci5wcm90b3R5cGUudG9SZ2I9ZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLnJnYmEpfSxyLnByb3RvdHlwZS50b1JnYlN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPW8odGhpcy5yZ2JhKSx0PXIucixuPXIuZyxlPXIuYiwodT1yLmEpPDE/XCJyZ2JhKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIsIFwiK3UrXCIpXCI6XCJyZ2IoXCIrdCtcIiwgXCIrbitcIiwgXCIrZStcIilcIjt2YXIgcix0LG4sZSx1fSxyLnByb3RvdHlwZS50b0hzbD1mdW5jdGlvbigpe3JldHVybiBkKGModGhpcy5yZ2JhKSl9LHIucHJvdG90eXBlLnRvSHNsU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHI9ZChjKHRoaXMucmdiYSkpLHQ9ci5oLG49ci5zLGU9ci5sLCh1PXIuYSk8MT9cImhzbGEoXCIrdCtcIiwgXCIrbitcIiUsIFwiK2UrXCIlLCBcIit1K1wiKVwiOlwiaHNsKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSlcIjt2YXIgcix0LG4sZSx1fSxyLnByb3RvdHlwZS50b0hzdj1mdW5jdGlvbigpe3JldHVybiByPWgodGhpcy5yZ2JhKSx7aDpuKHIuaCksczpuKHIucyksdjpuKHIudiksYTpuKHIuYSwzKX07dmFyIHJ9LHIucHJvdG90eXBlLmludmVydD1mdW5jdGlvbigpe3JldHVybiB3KHtyOjI1NS0ocj10aGlzLnJnYmEpLnIsZzoyNTUtci5nLGI6MjU1LXIuYixhOnIuYX0pO3ZhciByfSxyLnByb3RvdHlwZS5zYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoTSh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kZXNhdHVyYXRlPWZ1bmN0aW9uKHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMSksdyhNKHRoaXMucmdiYSwtcikpfSxyLnByb3RvdHlwZS5ncmF5c2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdyhNKHRoaXMucmdiYSwtMSkpfSxyLnByb3RvdHlwZS5saWdodGVuPWZ1bmN0aW9uKHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMSksdygkKHRoaXMucmdiYSxyKSl9LHIucHJvdG90eXBlLmRhcmtlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoJCh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0xNSksdGhpcy5odWUodGhpcy5odWUoKStyKX0sci5wcm90b3R5cGUuYWxwaGE9ZnVuY3Rpb24ocil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/dyh7cjoodD10aGlzLnJnYmEpLnIsZzp0LmcsYjp0LmIsYTpyfSk6bih0aGlzLnJnYmEuYSwzKTt2YXIgdH0sci5wcm90b3R5cGUuaHVlPWZ1bmN0aW9uKHIpe3ZhciB0PWModGhpcy5yZ2JhKTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2Ygcj93KHtoOnIsczp0LnMsbDp0LmwsYTp0LmF9KTpuKHQuaCl9LHIucHJvdG90eXBlLmlzRXF1YWw9ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMudG9IZXgoKT09PXcocikudG9IZXgoKX0scn0oKSx3PWZ1bmN0aW9uKHIpe3JldHVybiByIGluc3RhbmNlb2Ygaj9yOm5ldyBqKHIpfSxTPVtdLGs9ZnVuY3Rpb24ocil7ci5mb3JFYWNoKGZ1bmN0aW9uKHIpe1MuaW5kZXhPZihyKTwwJiYocihqLHkpLFMucHVzaChyKSl9KX0sRT1mdW5jdGlvbigpe3JldHVybiBuZXcgaih7cjoyNTUqTWF0aC5yYW5kb20oKSxnOjI1NSpNYXRoLnJhbmRvbSgpLGI6MjU1Kk1hdGgucmFuZG9tKCl9KX07ZXhwb3J0e2ogYXMgQ29sb3JkLHcgYXMgY29sb3JkLGsgYXMgZXh0ZW5kLEkgYXMgZ2V0Rm9ybWF0LEUgYXMgcmFuZG9tfTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGUsZil7dmFyIGE9e3doaXRlOlwiI2ZmZmZmZlwiLGJpc3F1ZTpcIiNmZmU0YzRcIixibHVlOlwiIzAwMDBmZlwiLGNhZGV0Ymx1ZTpcIiM1ZjllYTBcIixjaGFydHJldXNlOlwiIzdmZmYwMFwiLGNob2NvbGF0ZTpcIiNkMjY5MWVcIixjb3JhbDpcIiNmZjdmNTBcIixhbnRpcXVld2hpdGU6XCIjZmFlYmQ3XCIsYXF1YTpcIiMwMGZmZmZcIixhenVyZTpcIiNmMGZmZmZcIix3aGl0ZXNtb2tlOlwiI2Y1ZjVmNVwiLHBhcGF5YXdoaXA6XCIjZmZlZmQ1XCIscGx1bTpcIiNkZGEwZGRcIixibGFuY2hlZGFsbW9uZDpcIiNmZmViY2RcIixibGFjazpcIiMwMDAwMDBcIixnb2xkOlwiI2ZmZDcwMFwiLGdvbGRlbnJvZDpcIiNkYWE1MjBcIixnYWluc2Jvcm86XCIjZGNkY2RjXCIsY29ybnNpbGs6XCIjZmZmOGRjXCIsY29ybmZsb3dlcmJsdWU6XCIjNjQ5NWVkXCIsYnVybHl3b29kOlwiI2RlYjg4N1wiLGFxdWFtYXJpbmU6XCIjN2ZmZmQ0XCIsYmVpZ2U6XCIjZjVmNWRjXCIsY3JpbXNvbjpcIiNkYzE0M2NcIixjeWFuOlwiIzAwZmZmZlwiLGRhcmtibHVlOlwiIzAwMDA4YlwiLGRhcmtjeWFuOlwiIzAwOGI4YlwiLGRhcmtnb2xkZW5yb2Q6XCIjYjg4NjBiXCIsZGFya2toYWtpOlwiI2JkYjc2YlwiLGRhcmtncmF5OlwiI2E5YTlhOVwiLGRhcmtncmVlbjpcIiMwMDY0MDBcIixkYXJrZ3JleTpcIiNhOWE5YTlcIixwZWFjaHB1ZmY6XCIjZmZkYWI5XCIsZGFya21hZ2VudGE6XCIjOGIwMDhiXCIsZGFya3JlZDpcIiM4YjAwMDBcIixkYXJrb3JjaGlkOlwiIzk5MzJjY1wiLGRhcmtvcmFuZ2U6XCIjZmY4YzAwXCIsZGFya3NsYXRlYmx1ZTpcIiM0ODNkOGJcIixncmF5OlwiIzgwODA4MFwiLGRhcmtzbGF0ZWdyYXk6XCIjMmY0ZjRmXCIsZGFya3NsYXRlZ3JleTpcIiMyZjRmNGZcIixkZWVwcGluazpcIiNmZjE0OTNcIixkZWVwc2t5Ymx1ZTpcIiMwMGJmZmZcIix3aGVhdDpcIiNmNWRlYjNcIixmaXJlYnJpY2s6XCIjYjIyMjIyXCIsZmxvcmFsd2hpdGU6XCIjZmZmYWYwXCIsZ2hvc3R3aGl0ZTpcIiNmOGY4ZmZcIixkYXJrdmlvbGV0OlwiIzk0MDBkM1wiLG1hZ2VudGE6XCIjZmYwMGZmXCIsZ3JlZW46XCIjMDA4MDAwXCIsZG9kZ2VyYmx1ZTpcIiMxZTkwZmZcIixncmV5OlwiIzgwODA4MFwiLGhvbmV5ZGV3OlwiI2YwZmZmMFwiLGhvdHBpbms6XCIjZmY2OWI0XCIsYmx1ZXZpb2xldDpcIiM4YTJiZTJcIixmb3Jlc3RncmVlbjpcIiMyMjhiMjJcIixsYXduZ3JlZW46XCIjN2NmYzAwXCIsaW5kaWFucmVkOlwiI2NkNWM1Y1wiLGluZGlnbzpcIiM0YjAwODJcIixmdWNoc2lhOlwiI2ZmMDBmZlwiLGJyb3duOlwiI2E1MmEyYVwiLG1hcm9vbjpcIiM4MDAwMDBcIixtZWRpdW1ibHVlOlwiIzAwMDBjZFwiLGxpZ2h0Y29yYWw6XCIjZjA4MDgwXCIsZGFya3R1cnF1b2lzZTpcIiMwMGNlZDFcIixsaWdodGN5YW46XCIjZTBmZmZmXCIsaXZvcnk6XCIjZmZmZmYwXCIsbGlnaHR5ZWxsb3c6XCIjZmZmZmUwXCIsbGlnaHRzYWxtb246XCIjZmZhMDdhXCIsbGlnaHRzZWFncmVlbjpcIiMyMGIyYWFcIixsaW5lbjpcIiNmYWYwZTZcIixtZWRpdW1hcXVhbWFyaW5lOlwiIzY2Y2RhYVwiLGxlbW9uY2hpZmZvbjpcIiNmZmZhY2RcIixsaW1lOlwiIzAwZmYwMFwiLGtoYWtpOlwiI2YwZTY4Y1wiLG1lZGl1bXNlYWdyZWVuOlwiIzNjYjM3MVwiLGxpbWVncmVlbjpcIiMzMmNkMzJcIixtZWRpdW1zcHJpbmdncmVlbjpcIiMwMGZhOWFcIixsaWdodHNreWJsdWU6XCIjODdjZWZhXCIsbGlnaHRibHVlOlwiI2FkZDhlNlwiLG1pZG5pZ2h0Ymx1ZTpcIiMxOTE5NzBcIixsaWdodHBpbms6XCIjZmZiNmMxXCIsbWlzdHlyb3NlOlwiI2ZmZTRlMVwiLG1vY2Nhc2luOlwiI2ZmZTRiNVwiLG1pbnRjcmVhbTpcIiNmNWZmZmFcIixsaWdodHNsYXRlZ3JheTpcIiM3Nzg4OTlcIixsaWdodHNsYXRlZ3JleTpcIiM3Nzg4OTlcIixuYXZham93aGl0ZTpcIiNmZmRlYWRcIixuYXZ5OlwiIzAwMDA4MFwiLG1lZGl1bXZpb2xldHJlZDpcIiNjNzE1ODVcIixwb3dkZXJibHVlOlwiI2IwZTBlNlwiLHBhbGVnb2xkZW5yb2Q6XCIjZWVlOGFhXCIsb2xkbGFjZTpcIiNmZGY1ZTZcIixwYWxldHVycXVvaXNlOlwiI2FmZWVlZVwiLG1lZGl1bXR1cnF1b2lzZTpcIiM0OGQxY2NcIixtZWRpdW1vcmNoaWQ6XCIjYmE1NWQzXCIscmViZWNjYXB1cnBsZTpcIiM2NjMzOTlcIixsaWdodHN0ZWVsYmx1ZTpcIiNiMGM0ZGVcIixtZWRpdW1zbGF0ZWJsdWU6XCIjN2I2OGVlXCIsdGhpc3RsZTpcIiNkOGJmZDhcIix0YW46XCIjZDJiNDhjXCIsb3JjaGlkOlwiI2RhNzBkNlwiLG1lZGl1bXB1cnBsZTpcIiM5MzcwZGJcIixwdXJwbGU6XCIjODAwMDgwXCIscGluazpcIiNmZmMwY2JcIixza3libHVlOlwiIzg3Y2VlYlwiLHNwcmluZ2dyZWVuOlwiIzAwZmY3ZlwiLHBhbGVncmVlbjpcIiM5OGZiOThcIixyZWQ6XCIjZmYwMDAwXCIseWVsbG93OlwiI2ZmZmYwMFwiLHNsYXRlYmx1ZTpcIiM2YTVhY2RcIixsYXZlbmRlcmJsdXNoOlwiI2ZmZjBmNVwiLHBlcnU6XCIjY2Q4NTNmXCIscGFsZXZpb2xldHJlZDpcIiNkYjcwOTNcIix2aW9sZXQ6XCIjZWU4MmVlXCIsdGVhbDpcIiMwMDgwODBcIixzbGF0ZWdyYXk6XCIjNzA4MDkwXCIsc2xhdGVncmV5OlwiIzcwODA5MFwiLGFsaWNlYmx1ZTpcIiNmMGY4ZmZcIixkYXJrc2VhZ3JlZW46XCIjOGZiYzhmXCIsZGFya29saXZlZ3JlZW46XCIjNTU2YjJmXCIsZ3JlZW55ZWxsb3c6XCIjYWRmZjJmXCIsc2VhZ3JlZW46XCIjMmU4YjU3XCIsc2Vhc2hlbGw6XCIjZmZmNWVlXCIsdG9tYXRvOlwiI2ZmNjM0N1wiLHNpbHZlcjpcIiNjMGMwYzBcIixzaWVubmE6XCIjYTA1MjJkXCIsbGF2ZW5kZXI6XCIjZTZlNmZhXCIsbGlnaHRncmVlbjpcIiM5MGVlOTBcIixvcmFuZ2U6XCIjZmZhNTAwXCIsb3JhbmdlcmVkOlwiI2ZmNDUwMFwiLHN0ZWVsYmx1ZTpcIiM0NjgyYjRcIixyb3lhbGJsdWU6XCIjNDE2OWUxXCIsdHVycXVvaXNlOlwiIzQwZTBkMFwiLHllbGxvd2dyZWVuOlwiIzlhY2QzMlwiLHNhbG1vbjpcIiNmYTgwNzJcIixzYWRkbGVicm93bjpcIiM4YjQ1MTNcIixzYW5keWJyb3duOlwiI2Y0YTQ2MFwiLHJvc3licm93bjpcIiNiYzhmOGZcIixkYXJrc2FsbW9uOlwiI2U5OTY3YVwiLGxpZ2h0Z29sZGVucm9keWVsbG93OlwiI2ZhZmFkMlwiLHNub3c6XCIjZmZmYWZhXCIsbGlnaHRncmV5OlwiI2QzZDNkM1wiLGxpZ2h0Z3JheTpcIiNkM2QzZDNcIixkaW1ncmF5OlwiIzY5Njk2OVwiLGRpbWdyZXk6XCIjNjk2OTY5XCIsb2xpdmVkcmFiOlwiIzZiOGUyM1wiLG9saXZlOlwiIzgwODAwMFwifSxyPXt9O2Zvcih2YXIgZCBpbiBhKXJbYVtkXV09ZDt2YXIgbD17fTtlLnByb3RvdHlwZS50b05hbWU9ZnVuY3Rpb24oZil7aWYoISh0aGlzLnJnYmEuYXx8dGhpcy5yZ2JhLnJ8fHRoaXMucmdiYS5nfHx0aGlzLnJnYmEuYikpcmV0dXJuXCJ0cmFuc3BhcmVudFwiO3ZhciBkLGksbj1yW3RoaXMudG9IZXgoKV07aWYobilyZXR1cm4gbjtpZihudWxsPT1mP3ZvaWQgMDpmLmNsb3Nlc3Qpe3ZhciBvPXRoaXMudG9SZ2IoKSx0PTEvMCxiPVwiYmxhY2tcIjtpZighbC5sZW5ndGgpZm9yKHZhciBjIGluIGEpbFtjXT1uZXcgZShhW2NdKS50b1JnYigpO2Zvcih2YXIgZyBpbiBhKXt2YXIgdT0oZD1vLGk9bFtnXSxNYXRoLnBvdyhkLnItaS5yLDIpK01hdGgucG93KGQuZy1pLmcsMikrTWF0aC5wb3coZC5iLWkuYiwyKSk7dTx0JiYodD11LGI9Zyl9cmV0dXJuIGJ9fTtmLnN0cmluZy5wdXNoKFtmdW5jdGlvbihmKXt2YXIgcj1mLnRvTG93ZXJDYXNlKCksZD1cInRyYW5zcGFyZW50XCI9PT1yP1wiIzAwMDBcIjphW3JdO3JldHVybiBkP25ldyBlKGQpLnRvUmdiKCk6bnVsbH0sXCJuYW1lXCJdKX1cbiIsImltcG9ydCB7IGV4dGVuZCwgY29sb3JkIH0gZnJvbSBcIkBwaXhpL2NvbG9yZFwiO1xuaW1wb3J0IG5hbWVzUGx1Z2luIGZyb20gXCJAcGl4aS9jb2xvcmQvcGx1Z2lucy9uYW1lc1wiO1xuZXh0ZW5kKFtuYW1lc1BsdWdpbl0pO1xuY29uc3QgX0NvbG9yID0gY2xhc3MgX0NvbG9yMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuQ29sb3JTb3VyY2V9IHZhbHVlIC0gT3B0aW9uYWwgdmFsdWUgdG8gdXNlLCBpZiBub3QgcHJvdmlkZWQsIHdoaXRlIGlzIHVzZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSA9IDE2Nzc3MjE1KSB7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsLCB0aGlzLl9jb21wb25lbnRzID0gbmV3IEZsb2F0MzJBcnJheSg0KSwgdGhpcy5fY29tcG9uZW50cy5maWxsKDEpLCB0aGlzLl9pbnQgPSAxNjc3NzIxNSwgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBHZXQgcmVkIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCByZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF07XG4gIH1cbiAgLyoqIEdldCBncmVlbiBjb21wb25lbnQgKDAgLSAxKSAqL1xuICBnZXQgZ3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMV07XG4gIH1cbiAgLyoqIEdldCBibHVlIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCBibHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzJdO1xuICB9XG4gIC8qKiBHZXQgYWxwaGEgY29tcG9uZW50ICgwIC0gMSkgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzNdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmdcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBzZWUgUElYSS5Db2xvci52YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHZhbHVlLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBjb2xvciBzb3VyY2UuXG4gICAqXG4gICAqIFdoZW4gc2V0dGluZzpcbiAgICogLSBTZXR0aW5nIHRvIGFuIGluc3RhbmNlIG9mIGBDb2xvcmAgd2lsbCBjb3B5IGl0cyBjb2xvciBzb3VyY2UgYW5kIGNvbXBvbmVudHMuXG4gICAqIC0gT3RoZXJ3aXNlLCBgQ29sb3JgIHdpbGwgdHJ5IHRvIG5vcm1hbGl6ZSB0aGUgY29sb3Igc291cmNlIGFuZCBzZXQgdGhlIGNvbXBvbmVudHMuXG4gICAqICAgSWYgdGhlIGNvbG9yIHNvdXJjZSBpcyBpbnZhbGlkLCBhbiBgRXJyb3JgIHdpbGwgYmUgdGhyb3duIGFuZCB0aGUgYENvbG9yYCB3aWxsIGxlZnQgdW5jaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG51bGxgIGluIHRoZSBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZSBpcyBhZGRlZCB0byBtYXRjaCB0aGUgVHlwZVNjcmlwdCBydWxlOiByZXR1cm4gdHlwZSBvZiBnZXR0ZXJcbiAgICogbXVzdCBiZSBhc3NpZ25hYmxlIHRvIGl0cyBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZS4gU2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYCB3aWxsIHRocm93IGFuIGBFcnJvcmAuXG4gICAqXG4gICAqIFdoZW4gZ2V0dGluZzpcbiAgICogLSBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBvdmVycmlkZGVuIChlLmcuLCB7QGxpbmsgUElYSS5Db2xvci5tdWx0aXBseSBtdWx0aXBseX0sXG4gICAqICAge0BsaW5rIFBJWEkuQ29sb3IucHJlbXVsdGlwbHkgcHJlbXVsdGlwbHl9IG9yIHtAbGluayBQSVhJLkNvbG9yLnJvdW5kIHJvdW5kfSkuXG4gICAqIC0gT3RoZXJ3aXNlLCB0aGUgY29sb3Igc291cmNlIHVzZWQgd2hlbiBzZXR0aW5nIGlzIHJldHVybmVkLlxuICAgKiBAdHlwZSB7UElYSS5Db2xvclNvdXJjZX1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9Db2xvcjIpXG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmVTb3VyY2UodmFsdWUuX3ZhbHVlKSwgdGhpcy5faW50ID0gdmFsdWUuX2ludCwgdGhpcy5fY29tcG9uZW50cy5zZXQodmFsdWUuX2NvbXBvbmVudHMpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IFBJWEkuQ29sb3IjdmFsdWUgdG8gbnVsbFwiKTtcbiAgICAgICh0aGlzLl92YWx1ZSA9PT0gbnVsbCB8fCAhdGhpcy5pc1NvdXJjZUVxdWFsKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpICYmICh0aGlzLm5vcm1hbGl6ZSh2YWx1ZSksIHRoaXMuX3ZhbHVlID0gdGhpcy5jbG9uZVNvdXJjZSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3B5IGEgY29sb3Igc291cmNlIGludGVybmFsbHkuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIENvbG9yIHNvdXJjZVxuICAgKi9cbiAgY2xvbmVTb3VyY2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgPT09IG51bGwgPyB2YWx1ZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgwKSA6IHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrIGZvciBjb2xvciBzb3VyY2VzLlxuICAgKiBAcGFyYW0gdmFsdWUxIC0gRmlyc3QgY29sb3Igc291cmNlXG4gICAqIEBwYXJhbSB2YWx1ZTIgLSBTZWNvbmQgY29sb3Igc291cmNlXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sb3Igc291cmNlcyBhcmUgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTb3VyY2VFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGNvbnN0IHR5cGUxID0gdHlwZW9mIHZhbHVlMTtcbiAgICBpZiAodHlwZTEgIT09IHR5cGVvZiB2YWx1ZTIpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHR5cGUxID09PSBcIm51bWJlclwiIHx8IHR5cGUxID09PSBcInN0cmluZ1wiIHx8IHZhbHVlMSBpbnN0YW5jZW9mIE51bWJlcilcbiAgICAgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZTEpICYmIEFycmF5LmlzQXJyYXkodmFsdWUyKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUxKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUyKSlcbiAgICAgIHJldHVybiB2YWx1ZTEubGVuZ3RoICE9PSB2YWx1ZTIubGVuZ3RoID8gITEgOiB2YWx1ZTEuZXZlcnkoKHYsIGkpID0+IHYgPT09IHZhbHVlMltpXSk7XG4gICAgaWYgKHZhbHVlMSAhPT0gbnVsbCAmJiB2YWx1ZTIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXModmFsdWUxKSwga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZTIpO1xuICAgICAgcmV0dXJuIGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoID8gITEgOiBrZXlzMS5ldmVyeSgoa2V5KSA9PiB2YWx1ZTFba2V5XSA9PT0gdmFsdWUyW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBSR0JBIGNvbG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvUmdiKCk7IC8vIHJldHVybnMgeyByOiAxLCBnOiAxLCBiOiAxLCBhOiAxIH1cbiAgICovXG4gIHRvUmdiYSgpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIFJHQiBjb2xvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b1JnYigpOyAvLyByZXR1cm5zIHsgcjogMSwgZzogMSwgYjogMSB9XG4gICAqL1xuICB0b1JnYigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgfVxuICAvKiogQ29udmVydCB0byBhIENTUy1zdHlsZSByZ2JhIHN0cmluZzogYHJnYmEoMjU1LDI1NSwyNTUsMS4wKWAuICovXG4gIHRvUmdiYVN0cmluZygpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCR7Z30sJHtifSwke3RoaXMuYWxwaGF9KWA7XG4gIH1cbiAgdG9VaW50OFJnYkFycmF5KG91dCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIG91dCA9IG91dCA/PyBbXSwgb3V0WzBdID0gTWF0aC5yb3VuZChyICogMjU1KSwgb3V0WzFdID0gTWF0aC5yb3VuZChnICogMjU1KSwgb3V0WzJdID0gTWF0aC5yb3VuZChiICogMjU1KSwgb3V0O1xuICB9XG4gIHRvUmdiQXJyYXkob3V0KSB7XG4gICAgb3V0ID0gb3V0ID8/IFtdO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIG91dFswXSA9IHIsIG91dFsxXSA9IGcsIG91dFsyXSA9IGIsIG91dDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvTnVtYmVyKCk7IC8vIHJldHVybnMgMTY3NzcyMTVcbiAgICovXG4gIHRvTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIgaW4gbGl0dGxlIGVuZGlhbiBmb3JtYXQgKGUuZy4sIEJCR0dSUikuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcigweGZmY2M5OSkudG9MaXR0bGVFbmRpYW5OdW1iZXIoKTsgLy8gcmV0dXJucyAweDk5Y2NmZlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjb2xvciBhcyBhIG51bWJlciBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cbiAgICovXG4gIHRvTGl0dGxlRW5kaWFuTnVtYmVyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5faW50O1xuICAgIHJldHVybiAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgNjUyODApICsgKCh2YWx1ZSAmIDI1NSkgPDwgMTYpO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSB3aXRoIGFub3RoZXIgY29sb3IuIFRoaXMgYWN0aW9uIGlzIGRlc3RydWN0aXZlLCBhbmQgd2lsbFxuICAgKiBvdmVycmlkZSB0aGUgcHJldmlvdXMgYHZhbHVlYCBwcm9wZXJ0eSB0byBiZSBgbnVsbGAuXG4gICAqIEBwYXJhbSB7UElYSS5Db2xvclNvdXJjZX0gdmFsdWUgLSBUaGUgY29sb3IgdG8gbXVsdGlwbHkgYnkuXG4gICAqL1xuICBtdWx0aXBseSh2YWx1ZSkge1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IF9Db2xvcjIudGVtcC5zZXRWYWx1ZSh2YWx1ZSkuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF0gKj0gciwgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBnLCB0aGlzLl9jb21wb25lbnRzWzJdICo9IGIsIHRoaXMuX2NvbXBvbmVudHNbM10gKj0gYSwgdGhpcy5yZWZyZXNoSW50KCksIHRoaXMuX3ZhbHVlID0gbnVsbCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgY29sb3IgdG8gYSBwcmVtdWx0aXBsaWVkIGFscGhhIGZvcm1hdC4gVGhpcyBhY3Rpb24gaXMgZGVzdHJ1Y3RpdmUsIGFuZCB3aWxsXG4gICAqIG92ZXJyaWRlIHRoZSBwcmV2aW91cyBgdmFsdWVgIHByb3BlcnR5IHRvIGJlIGBudWxsYC5cbiAgICogQHBhcmFtIGFscGhhIC0gVGhlIGFscGhhIHRvIG11bHRpcGx5IGJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcHBseVRvUkdCPXRydWVdIC0gV2hldGhlciB0byBwcmVtdWx0aXBseSBSR0IgY2hhbm5lbHMuXG4gICAqIEByZXR1cm5zIHtQSVhJLkNvbG9yfSAtIEl0c2VsZi5cbiAgICovXG4gIHByZW11bHRpcGx5KGFscGhhLCBhcHBseVRvUkdCID0gITApIHtcbiAgICByZXR1cm4gYXBwbHlUb1JHQiAmJiAodGhpcy5fY29tcG9uZW50c1swXSAqPSBhbHBoYSwgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBhbHBoYSwgdGhpcy5fY29tcG9uZW50c1syXSAqPSBhbHBoYSksIHRoaXMuX2NvbXBvbmVudHNbM10gPSBhbHBoYSwgdGhpcy5yZWZyZXNoSW50KCksIHRoaXMuX3ZhbHVlID0gbnVsbCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUHJlbXVsdGlwbGllcyBhbHBoYSB3aXRoIGN1cnJlbnQgY29sb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIFRoZSBhbHBoYSB0byBtdWx0aXBseSBieS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXBwbHlUb1JHQj10cnVlXSAtIFdoZXRoZXIgdG8gcHJlbXVsdGlwbHkgUkdCIGNoYW5uZWxzLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aW50IG11bHRpcGxpZWQgYnkgYWxwaGFcbiAgICovXG4gIHRvUHJlbXVsdGlwbGllZChhbHBoYSwgYXBwbHlUb1JHQiA9ICEwKSB7XG4gICAgaWYgKGFscGhhID09PSAxKVxuICAgICAgcmV0dXJuICgyNTUgPDwgMjQpICsgdGhpcy5faW50O1xuICAgIGlmIChhbHBoYSA9PT0gMClcbiAgICAgIHJldHVybiBhcHBseVRvUkdCID8gMCA6IHRoaXMuX2ludDtcbiAgICBsZXQgciA9IHRoaXMuX2ludCA+PiAxNiAmIDI1NSwgZyA9IHRoaXMuX2ludCA+PiA4ICYgMjU1LCBiID0gdGhpcy5faW50ICYgMjU1O1xuICAgIHJldHVybiBhcHBseVRvUkdCICYmIChyID0gciAqIGFscGhhICsgMC41IHwgMCwgZyA9IGcgKiBhbHBoYSArIDAuNSB8IDAsIGIgPSBiICogYWxwaGEgKyAwLjUgfCAwKSwgKGFscGhhICogMjU1IDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGlkZWNpbWFsIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvSGV4KCk7IC8vIHJldHVybnMgXCIjZmZmZmZmXCJcbiAgICovXG4gIHRvSGV4KCkge1xuICAgIGNvbnN0IGhleFN0cmluZyA9IHRoaXMuX2ludC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGAjJHtcIjAwMDAwMFwiLnN1YnN0cmluZygwLCA2IC0gaGV4U3RyaW5nLmxlbmd0aCkgKyBoZXhTdHJpbmd9YDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGlkZWNpbWFsIHN0cmluZyB3aXRoIGFscGhhLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9IZXhhKCk7IC8vIHJldHVybnMgXCIjZmZmZmZmZmZcIlxuICAgKi9cbiAgdG9IZXhhKCkge1xuICAgIGNvbnN0IGFscGhhU3RyaW5nID0gTWF0aC5yb3VuZCh0aGlzLl9jb21wb25lbnRzWzNdICogMjU1KS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIFwiMDBcIi5zdWJzdHJpbmcoMCwgMiAtIGFscGhhU3RyaW5nLmxlbmd0aCkgKyBhbHBoYVN0cmluZztcbiAgfVxuICAvKipcbiAgICogU2V0IGFscGhhLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBwYXJhbSBhbHBoYVxuICAgKi9cbiAgc2V0QWxwaGEoYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1szXSA9IHRoaXMuX2NsYW1wKGFscGhhKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUm91bmRzIHRoZSBzcGVjaWZpZWQgY29sb3IgYWNjb3JkaW5nIHRvIHRoZSBzdGVwLiBUaGlzIGFjdGlvbiBpcyBkZXN0cnVjdGl2ZSwgYW5kIHdpbGxcbiAgICogb3ZlcnJpZGUgdGhlIHByZXZpb3VzIGB2YWx1ZWAgcHJvcGVydHkgdG8gYmUgYG51bGxgLiBUaGUgYWxwaGEgY29tcG9uZW50IGlzIG5vdCByb3VuZGVkLlxuICAgKiBAcGFyYW0gc3RlcHMgLSBOdW1iZXIgb2Ygc3RlcHMgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgY2FwIHdoZW4gcm91bmRpbmcgY29sb3JzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMy4wXG4gICAqL1xuICByb3VuZChzdGVwcykge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF0gPSBNYXRoLnJvdW5kKHIgKiBzdGVwcykgLyBzdGVwcywgdGhpcy5fY29tcG9uZW50c1sxXSA9IE1hdGgucm91bmQoZyAqIHN0ZXBzKSAvIHN0ZXBzLCB0aGlzLl9jb21wb25lbnRzWzJdID0gTWF0aC5yb3VuZChiICogc3RlcHMpIC8gc3RlcHMsIHRoaXMucmVmcmVzaEludCgpLCB0aGlzLl92YWx1ZSA9IG51bGwsIHRoaXM7XG4gIH1cbiAgdG9BcnJheShvdXQpIHtcbiAgICBvdXQgPSBvdXQgPz8gW107XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICByZXR1cm4gb3V0WzBdID0gciwgb3V0WzFdID0gZywgb3V0WzJdID0gYiwgb3V0WzNdID0gYSwgb3V0O1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHZhbHVlIGludG8gcmdiYVxuICAgKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZVxuICAgKi9cbiAgbm9ybWFsaXplKHZhbHVlKSB7XG4gICAgbGV0IHIsIGcsIGIsIGE7XG4gICAgaWYgKCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxNjc3NzIxNSkge1xuICAgICAgY29uc3QgaW50ID0gdmFsdWU7XG4gICAgICByID0gKGludCA+PiAxNiAmIDI1NSkgLyAyNTUsIGcgPSAoaW50ID4+IDggJiAyNTUpIC8gMjU1LCBiID0gKGludCAmIDI1NSkgLyAyNTUsIGEgPSAxO1xuICAgIH0gZWxzZSBpZiAoKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPj0gMyAmJiB2YWx1ZS5sZW5ndGggPD0gNClcbiAgICAgIHZhbHVlID0gdGhpcy5fY2xhbXAodmFsdWUpLCBbciwgZywgYiwgYSA9IDFdID0gdmFsdWU7XG4gICAgZWxzZSBpZiAoKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPj0gMyAmJiB2YWx1ZS5sZW5ndGggPD0gNClcbiAgICAgIHZhbHVlID0gdGhpcy5fY2xhbXAodmFsdWUsIDAsIDI1NSksIFtyLCBnLCBiLCBhID0gMjU1XSA9IHZhbHVlLCByIC89IDI1NSwgZyAvPSAyNTUsIGIgLz0gMjU1LCBhIC89IDI1NTtcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gX0NvbG9yMi5IRVhfUEFUVEVSTi5leGVjKHZhbHVlKTtcbiAgICAgICAgbWF0Y2ggJiYgKHZhbHVlID0gYCMke21hdGNoWzJdfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcmQodmFsdWUpO1xuICAgICAgY29sb3IuaXNWYWxpZCgpICYmICh7IHIsIGcsIGIsIGEgfSA9IGNvbG9yLnJnYmEsIHIgLz0gMjU1LCBnIC89IDI1NSwgYiAvPSAyNTUpO1xuICAgIH1cbiAgICBpZiAociAhPT0gdm9pZCAwKVxuICAgICAgdGhpcy5fY29tcG9uZW50c1swXSA9IHIsIHRoaXMuX2NvbXBvbmVudHNbMV0gPSBnLCB0aGlzLl9jb21wb25lbnRzWzJdID0gYiwgdGhpcy5fY29tcG9uZW50c1szXSA9IGEsIHRoaXMucmVmcmVzaEludCgpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgY29sb3IgJHt2YWx1ZX1gKTtcbiAgfVxuICAvKiogUmVmcmVzaCB0aGUgaW50ZXJuYWwgY29sb3IgcmdiIG51bWJlciAqL1xuICByZWZyZXNoSW50KCkge1xuICAgIHRoaXMuX2NsYW1wKHRoaXMuX2NvbXBvbmVudHMpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdGhpcy5faW50ID0gKHIgKiAyNTUgPDwgMTYpICsgKGcgKiAyNTUgPDwgOCkgKyAoYiAqIDI1NSB8IDApO1xuICB9XG4gIC8qKlxuICAgKiBDbGFtcHMgdmFsdWVzIHRvIGEgcmFuZ2UuIFdpbGwgb3ZlcnJpZGUgb3JpZ2luYWwgdmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlKHMpIHRvIGNsYW1wXG4gICAqIEBwYXJhbSBtaW4gLSBNaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSBtYXggLSBNYXhpbXVtIHZhbHVlXG4gICAqL1xuICBfY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KSA6ICh2YWx1ZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICB2YWx1ZVtpXSA9IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG4gICAgfSksIHZhbHVlKTtcbiAgfVxufTtcbl9Db2xvci5zaGFyZWQgPSBuZXcgX0NvbG9yKCksIC8qKlxuKiBUZW1wb3JhcnkgQ29sb3Igb2JqZWN0IGZvciBzdGF0aWMgdXNlcyBpbnRlcm5hbGx5LlxuKiBBcyB0byBub3QgY29uZmxpY3Qgd2l0aCBDb2xvci5zaGFyZWQuXG4qIEBpZ25vcmVcbiovXG5fQ29sb3IudGVtcCA9IG5ldyBfQ29sb3IoKSwgLyoqIFBhdHRlcm4gZm9yIGhleCBzdHJpbmdzICovXG5fQ29sb3IuSEVYX1BBVFRFUk4gPSAvXigjfDB4KT8oKFthLWYwLTldezN9KXsxLDJ9KFthLWYwLTldezJ9KT8pJC9pO1xubGV0IENvbG9yID0gX0NvbG9yO1xuZXhwb3J0IHtcbiAgQ29sb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvci5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuL0NvbG9yLm1qc1wiO1xuZXhwb3J0IHtcbiAgQ29sb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gXCJAcGl4aS9jb2xvclwiO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tIFwiLi4vbG9nZ2luZy9kZXByZWNhdGlvbi5tanNcIjtcbmZ1bmN0aW9uIGhleDJyZ2IoaGV4LCBvdXQgPSBbXSkge1xuICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLmhleDJyZ2IgaXMgZGVwcmVjYXRlZCwgdXNlIENvbG9yI3RvUmdiQXJyYXkgaW5zdGVhZFwiKSwgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGhleCkudG9SZ2JBcnJheShvdXQpO1xufVxuZnVuY3Rpb24gaGV4MnN0cmluZyhoZXgpIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5oZXgyc3RyaW5nIGlzIGRlcHJlY2F0ZWQsIHVzZSBDb2xvciN0b0hleCBpbnN0ZWFkXCIpLCBDb2xvci5zaGFyZWQuc2V0VmFsdWUoaGV4KS50b0hleCgpO1xufVxuZnVuY3Rpb24gc3RyaW5nMmhleChzdHJpbmcpIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5zdHJpbmcyaGV4IGlzIGRlcHJlY2F0ZWQsIHVzZSBDb2xvciN0b051bWJlciBpbnN0ZWFkXCIpLCBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3RyaW5nKS50b051bWJlcigpO1xufVxuZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5yZ2IyaGV4IGlzIGRlcHJlY2F0ZWQsIHVzZSBDb2xvciN0b051bWJlciBpbnN0ZWFkXCIpLCBDb2xvci5zaGFyZWQuc2V0VmFsdWUocmdiKS50b051bWJlcigpO1xufVxuZXhwb3J0IHtcbiAgaGV4MnJnYixcbiAgaGV4MnN0cmluZyxcbiAgcmdiMmhleCxcbiAgc3RyaW5nMmhleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gXCJAcGl4aS9jb2xvclwiO1xuaW1wb3J0IHsgQkxFTkRfTU9ERVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gXCIuLi9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qc1wiO1xuZnVuY3Rpb24gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKSB7XG4gIGNvbnN0IHBtID0gW10sIG5wbSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgcG1baV0gPSBpLCBucG1baV0gPSBpO1xuICBwbVtCTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IEJMRU5EX01PREVTLk5PUk1BTCwgcG1bQkxFTkRfTU9ERVMuQUREX05QTV0gPSBCTEVORF9NT0RFUy5BREQsIHBtW0JMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gQkxFTkRfTU9ERVMuU0NSRUVOLCBucG1bQkxFTkRfTU9ERVMuTk9STUFMXSA9IEJMRU5EX01PREVTLk5PUk1BTF9OUE0sIG5wbVtCTEVORF9NT0RFUy5BRERdID0gQkxFTkRfTU9ERVMuQUREX05QTSwgbnBtW0JMRU5EX01PREVTLlNDUkVFTl0gPSBCTEVORF9NT0RFUy5TQ1JFRU5fTlBNO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICByZXR1cm4gYXJyYXkucHVzaChucG0pLCBhcnJheS5wdXNoKHBtKSwgYXJyYXk7XG59XG5jb25zdCBwcmVtdWx0aXBseUJsZW5kTW9kZSA9IG1hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzKCk7XG5mdW5jdGlvbiBjb3JyZWN0QmxlbmRNb2RlKGJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCkge1xuICByZXR1cm4gcHJlbXVsdGlwbHlCbGVuZE1vZGVbcHJlbXVsdGlwbGllZCA/IDEgOiAwXVtibGVuZE1vZGVdO1xufVxuZnVuY3Rpb24gcHJlbXVsdGlwbHlSZ2JhKHJnYiwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkgPSAhMCkge1xuICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLnByZW11bHRpcGx5UmdiYSBoYXMgbW92ZWQgdG8gQ29sb3IucHJlbXVsdGlwbHlcIiksIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShyZ2IpLnByZW11bHRpcGx5KGFscGhhLCBwcmVtdWx0aXBseSkudG9BcnJheShvdXQgPz8gbmV3IEZsb2F0MzJBcnJheSg0KSk7XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVRpbnQodGludCwgYWxwaGEpIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5wcmVtdWx0aXBseVRpbnQgaGFzIG1vdmVkIHRvIENvbG9yLnRvUHJlbXVsdGlwbGllZFwiKSwgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRpbnQpLnRvUHJlbXVsdGlwbGllZChhbHBoYSk7XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVRpbnRUb1JnYmEodGludCwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkgPSAhMCkge1xuICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBcInV0aWxzLnByZW11bHRpcGx5VGludFRvUmdiYSBoYXMgbW92ZWQgdG8gQ29sb3IucHJlbXVsdGlwbHlcIiksIENvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aW50KS5wcmVtdWx0aXBseShhbHBoYSwgcHJlbXVsdGlwbHkpLnRvQXJyYXkob3V0ID8/IG5ldyBGbG9hdDMyQXJyYXkoNCkpO1xufVxuZXhwb3J0IHtcbiAgY29ycmVjdEJsZW5kTW9kZSxcbiAgcHJlbXVsdGlwbHlCbGVuZE1vZGUsXG4gIHByZW11bHRpcGx5UmdiYSxcbiAgcHJlbXVsdGlwbHlUaW50LFxuICBwcmVtdWx0aXBseVRpbnRUb1JnYmFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVtdWx0aXBseS5tanMubWFwXG4iLCJjb25zdCBEQVRBX1VSSSA9IC9eXFxzKmRhdGE6KD86KFtcXHctXSspXFwvKFtcXHcrLi1dKykpPyg/OjtjaGFyc2V0PShbXFx3LV0rKSk/KD86OyhiYXNlNjQpKT8sKC4qKS9pO1xuZXhwb3J0IHtcbiAgREFUQV9VUklcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJmdW5jdGlvbiBjcmVhdGVJbmRpY2VzRm9yUXVhZHMoc2l6ZSwgb3V0QnVmZmVyID0gbnVsbCkge1xuICBjb25zdCB0b3RhbEluZGljZXMgPSBzaXplICogNjtcbiAgaWYgKG91dEJ1ZmZlciA9IG91dEJ1ZmZlciB8fCBuZXcgVWludDE2QXJyYXkodG90YWxJbmRpY2VzKSwgb3V0QnVmZmVyLmxlbmd0aCAhPT0gdG90YWxJbmRpY2VzKVxuICAgIHRocm93IG5ldyBFcnJvcihgT3V0IGJ1ZmZlciBsZW5ndGggaXMgaW5jb3JyZWN0LCBnb3QgJHtvdXRCdWZmZXIubGVuZ3RofSBhbmQgZXhwZWN0ZWQgJHt0b3RhbEluZGljZXN9YCk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAgb3V0QnVmZmVyW2kgKyAwXSA9IGogKyAwLCBvdXRCdWZmZXJbaSArIDFdID0gaiArIDEsIG91dEJ1ZmZlcltpICsgMl0gPSBqICsgMiwgb3V0QnVmZmVyW2kgKyAzXSA9IGogKyAwLCBvdXRCdWZmZXJbaSArIDRdID0gaiArIDIsIG91dEJ1ZmZlcltpICsgNV0gPSBqICsgMztcbiAgcmV0dXJuIG91dEJ1ZmZlcjtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUluZGljZXNGb3JRdWFkc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUluZGljZXNGb3JRdWFkcy5tanMubWFwXG4iLCJmdW5jdGlvbiBnZXRCdWZmZXJUeXBlKGFycmF5KSB7XG4gIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNClcbiAgICByZXR1cm4gYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBcIkZsb2F0MzJBcnJheVwiIDogYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/IFwiVWludDMyQXJyYXlcIiA6IFwiSW50MzJBcnJheVwiO1xuICBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlcbiAgICAgIHJldHVybiBcIlVpbnQxNkFycmF5XCI7XG4gIH0gZWxzZSBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDEgJiYgYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybiBcIlVpbnQ4QXJyYXlcIjtcbiAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQge1xuICBnZXRCdWZmZXJUeXBlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QnVmZmVyVHlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSBcIi4vZ2V0QnVmZmVyVHlwZS5tanNcIjtcbmNvbnN0IG1hcCA9IHsgRmxvYXQzMkFycmF5LCBVaW50MzJBcnJheSwgSW50MzJBcnJheSwgVWludDhBcnJheSB9O1xuZnVuY3Rpb24gaW50ZXJsZWF2ZVR5cGVkQXJyYXlzKGFycmF5cywgc2l6ZXMpIHtcbiAgbGV0IG91dFNpemUgPSAwLCBzdHJpZGUgPSAwO1xuICBjb25zdCB2aWV3cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKylcbiAgICBzdHJpZGUgKz0gc2l6ZXNbaV0sIG91dFNpemUgKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG91dFNpemUgKiA0KTtcbiAgbGV0IG91dCA9IG51bGwsIGxpdHRsZU9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNpemVzW2ldLCBhcnJheSA9IGFycmF5c1tpXSwgdHlwZSA9IGdldEJ1ZmZlclR5cGUoYXJyYXkpO1xuICAgIHZpZXdzW3R5cGVdIHx8ICh2aWV3c1t0eXBlXSA9IG5ldyBtYXBbdHlwZV0oYnVmZmVyKSksIG91dCA9IHZpZXdzW3R5cGVdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSAoaiAvIHNpemUgfCAwKSAqIHN0cmlkZSArIGxpdHRsZU9mZnNldCwgaW5kZXggPSBqICUgc2l6ZTtcbiAgICAgIG91dFtpbmRleFN0YXJ0ICsgaW5kZXhdID0gYXJyYXlbal07XG4gICAgfVxuICAgIGxpdHRsZU9mZnNldCArPSBzaXplO1xuICB9XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG59XG5leHBvcnQge1xuICBpbnRlcmxlYXZlVHlwZWRBcnJheXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzLm1hcFxuIiwiZnVuY3Rpb24gbmV4dFBvdzIodikge1xuICByZXR1cm4gdiArPSB2ID09PSAwID8gMSA6IDAsIC0tdiwgdiB8PSB2ID4+PiAxLCB2IHw9IHYgPj4+IDIsIHYgfD0gdiA+Pj4gNCwgdiB8PSB2ID4+PiA4LCB2IHw9IHYgPj4+IDE2LCB2ICsgMTtcbn1cbmZ1bmN0aW9uIGlzUG93Mih2KSB7XG4gIHJldHVybiAhKHYgJiB2IC0gMSkgJiYgISF2O1xufVxuZnVuY3Rpb24gbG9nMih2KSB7XG4gIGxldCByID0gKHYgPiA2NTUzNSA/IDEgOiAwKSA8PCA0O1xuICB2ID4+Pj0gcjtcbiAgbGV0IHNoaWZ0ID0gKHYgPiAyNTUgPyAxIDogMCkgPDwgMztcbiAgcmV0dXJuIHYgPj4+PSBzaGlmdCwgciB8PSBzaGlmdCwgc2hpZnQgPSAodiA+IDE1ID8gMSA6IDApIDw8IDIsIHYgPj4+PSBzaGlmdCwgciB8PSBzaGlmdCwgc2hpZnQgPSAodiA+IDMgPyAxIDogMCkgPDwgMSwgdiA+Pj49IHNoaWZ0LCByIHw9IHNoaWZ0LCByIHwgdiA+PiAxO1xufVxuZXhwb3J0IHtcbiAgaXNQb3cyLFxuICBsb2cyLFxuICBuZXh0UG93MlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvdzIubWpzLm1hcFxuIiwiZnVuY3Rpb24gcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgbGV0IGk7XG4gIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApXG4gICAgcmV0dXJuO1xuICByZW1vdmVDb3VudCA9IHN0YXJ0SWR4ICsgcmVtb3ZlQ291bnQgPiBsZW5ndGggPyBsZW5ndGggLSBzdGFydElkeCA6IHJlbW92ZUNvdW50O1xuICBjb25zdCBsZW4gPSBsZW5ndGggLSByZW1vdmVDb3VudDtcbiAgZm9yIChpID0gc3RhcnRJZHg7IGkgPCBsZW47ICsraSlcbiAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgYXJyLmxlbmd0aCA9IGxlbjtcbn1cbmV4cG9ydCB7XG4gIHJlbW92ZUl0ZW1zXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlSXRlbXMubWpzLm1hcFxuIiwiZnVuY3Rpb24gc2lnbihuKSB7XG4gIHJldHVybiBuID09PSAwID8gMCA6IG4gPCAwID8gLTEgOiAxO1xufVxuZXhwb3J0IHtcbiAgc2lnblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ24ubWpzLm1hcFxuIiwibGV0IG5leHRVaWQgPSAwO1xuZnVuY3Rpb24gdWlkKCkge1xuICByZXR1cm4gKytuZXh0VWlkO1xufVxuZXhwb3J0IHtcbiAgdWlkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWlkLm1qcy5tYXBcbiIsImNvbnN0IF9Cb3VuZGluZ0JveCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBsZWZ0IC0gVGhlIGxlZnQgY29vcmRpbmF0ZSB2YWx1ZSBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgKiBAcGFyYW0gdG9wIC0gVGhlIHRvcCBjb29yZGluYXRlIHZhbHVlIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAqIEBwYXJhbSByaWdodCAtIFRoZSByaWdodCBjb29yZGluYXRlIHZhbHVlIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAqIEBwYXJhbSBib3R0b20gLSBUaGUgYm90dG9tIGNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgIHRoaXMubGVmdCA9IGxlZnQsIHRoaXMudG9wID0gdG9wLCB0aGlzLnJpZ2h0ID0gcmlnaHQsIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIGJveC4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyBib3guICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XG4gIH1cbiAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgQm91bmRpbmdCb3ggaXMgZW1wdHkuICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdCA9PT0gdGhpcy5yaWdodCB8fCB0aGlzLnRvcCA9PT0gdGhpcy5ib3R0b207XG4gIH1cbn07XG5fQm91bmRpbmdCb3guRU1QVFkgPSBuZXcgX0JvdW5kaW5nQm94KDAsIDAsIDAsIDApO1xubGV0IEJvdW5kaW5nQm94ID0gX0JvdW5kaW5nQm94O1xuZXhwb3J0IHtcbiAgQm91bmRpbmdCb3hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZGluZ0JveC5tanMubWFwXG4iLCJjb25zdCBQcm9ncmFtQ2FjaGUgPSB7fSwgVGV4dHVyZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIEJhc2VUZXh0dXJlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGRlc3Ryb3lUZXh0dXJlQ2FjaGUoKSB7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIFRleHR1cmVDYWNoZSlcbiAgICBUZXh0dXJlQ2FjaGVba2V5XS5kZXN0cm95KCk7XG4gIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpXG4gICAgQmFzZVRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbn1cbmZ1bmN0aW9uIGNsZWFyVGV4dHVyZUNhY2hlKCkge1xuICBsZXQga2V5O1xuICBmb3IgKGtleSBpbiBUZXh0dXJlQ2FjaGUpXG4gICAgZGVsZXRlIFRleHR1cmVDYWNoZVtrZXldO1xuICBmb3IgKGtleSBpbiBCYXNlVGV4dHVyZUNhY2hlKVxuICAgIGRlbGV0ZSBCYXNlVGV4dHVyZUNhY2hlW2tleV07XG59XG5leHBvcnQge1xuICBCYXNlVGV4dHVyZUNhY2hlLFxuICBQcm9ncmFtQ2FjaGUsXG4gIFRleHR1cmVDYWNoZSxcbiAgY2xlYXJUZXh0dXJlQ2FjaGUsXG4gIGRlc3Ryb3lUZXh0dXJlQ2FjaGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZXMubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmNsYXNzIENhbnZhc1JlbmRlclRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICAgKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbj1QSVhJLnNldHRpbmdzLlJFU09MVVRJT05dIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgIHRoaXMuX2NhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCksIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHNldHRpbmdzLlJFU09MVVRJT04sIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhbnZhcyB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBDYW52YXNSZW5kZXJUYXJnZXQgY2xhc3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpLCB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKSwgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAgICogQHBhcmFtIGRlc2lyZWRXaWR0aCAtIHRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIGRlc2lyZWRIZWlnaHQgLSB0aGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCksIHRoaXMuX2NhbnZhcy53aWR0aCA9IE1hdGgucm91bmQoZGVzaXJlZFdpZHRoICogdGhpcy5yZXNvbHV0aW9uKSwgdGhpcy5fY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoZGVzaXJlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgY2FudmFzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsLCB0aGlzLl9jYW52YXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyBidWZmZXIgaW4gcGl4ZWxzLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrRGVzdHJveWVkKCksIHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY2FudmFzLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCksIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cbiAgLyoqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc1JlbmRlclRhcmdldC4gKi9cbiAgZ2V0IGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY2FudmFzO1xuICB9XG4gIC8qKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LiAqL1xuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY29udGV4dDtcbiAgfVxuICBfY2hlY2tEZXN0cm95ZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhbnZhcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXCIpO1xuICB9XG59XG5leHBvcnQge1xuICBDYW52YXNSZW5kZXJUYXJnZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZW5kZXJUYXJnZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tIFwiLi9Cb3VuZGluZ0JveC5tanNcIjtcbmZ1bmN0aW9uIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB5KSB7XG4gIGZvciAobGV0IHggPSAwLCBpbmRleCA9IDQgKiB5ICogd2lkdGg7IHggPCB3aWR0aDsgKyt4LCBpbmRleCArPSA0KVxuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCB4LCB0b3AsIGJvdHRvbSkge1xuICBjb25zdCBzdHJpZGUgPSA0ICogd2lkdGg7XG4gIGZvciAobGV0IHkgPSB0b3AsIGluZGV4ID0gdG9wICogc3RyaWRlICsgNCAqIHg7IHkgPD0gYm90dG9tOyArK3ksIGluZGV4ICs9IHN0cmlkZSlcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXMsIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gIH0pO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgY29uc3QgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gIGxldCBsZWZ0ID0gMCwgdG9wID0gMCwgcmlnaHQgPSB3aWR0aCAtIDEsIGJvdHRvbSA9IGhlaWdodCAtIDE7XG4gIGZvciAoOyB0b3AgPCBoZWlnaHQgJiYgY2hlY2tSb3coZGF0YSwgd2lkdGgsIHRvcCk7IClcbiAgICArK3RvcDtcbiAgaWYgKHRvcCA9PT0gaGVpZ2h0KVxuICAgIHJldHVybiBCb3VuZGluZ0JveC5FTVBUWTtcbiAgZm9yICg7IGNoZWNrUm93KGRhdGEsIHdpZHRoLCBib3R0b20pOyApXG4gICAgLS1ib3R0b207XG4gIGZvciAoOyBjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgbGVmdCwgdG9wLCBib3R0b20pOyApXG4gICAgKytsZWZ0O1xuICBmb3IgKDsgY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHJpZ2h0LCB0b3AsIGJvdHRvbSk7IClcbiAgICAtLXJpZ2h0O1xuICByZXR1cm4gKytyaWdodCwgKytib3R0b20sIG5ldyBCb3VuZGluZ0JveChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pO1xufVxuZXhwb3J0IHtcbiAgZ2V0Q2FudmFzQm91bmRpbmdCb3hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDYW52YXNCb3VuZGluZ0JveC5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gXCIuL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qc1wiO1xuZnVuY3Rpb24gdHJpbUNhbnZhcyhjYW52YXMpIHtcbiAgY29uc3QgYm91bmRpbmdCb3ggPSBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpLCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kaW5nQm94O1xuICBsZXQgZGF0YSA9IG51bGw7XG4gIGlmICghYm91bmRpbmdCb3guaXNFbXB0eSgpKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoXG4gICAgICBib3VuZGluZ0JveC5sZWZ0LFxuICAgICAgYm91bmRpbmdCb3gudG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICApO1xuICB9XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIGRhdGEgfTtcbn1cbmV4cG9ydCB7XG4gIHRyaW1DYW52YXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltQ2FudmFzLm1qcy5tYXBcbiIsImltcG9ydCB7IERBVEFfVVJJIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaShkYXRhVXJpKSB7XG4gIGNvbnN0IGRhdGFVcmlNYXRjaCA9IERBVEFfVVJJLmV4ZWMoZGF0YVVyaSk7XG4gIGlmIChkYXRhVXJpTWF0Y2gpXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogZGF0YVVyaU1hdGNoWzFdID8gZGF0YVVyaU1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiB2b2lkIDAsXG4gICAgICBzdWJUeXBlOiBkYXRhVXJpTWF0Y2hbMl0gPyBkYXRhVXJpTWF0Y2hbMl0udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIGNoYXJzZXQ6IGRhdGFVcmlNYXRjaFszXSA/IGRhdGFVcmlNYXRjaFszXS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgZW5jb2Rpbmc6IGRhdGFVcmlNYXRjaFs0XSA/IGRhdGFVcmlNYXRjaFs0XS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgZGF0YTogZGF0YVVyaU1hdGNoWzVdXG4gICAgfTtcbn1cbmV4cG9ydCB7XG4gIGRlY29tcG9zZURhdGFVcmlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvbXBvc2VEYXRhVXJpLm1qcy5tYXBcbiIsImZ1bmN0aW9uIGRldGVybWluZUNyb3NzT3JpZ2luKHVybCwgbG9jID0gZ2xvYmFsVGhpcy5sb2NhdGlvbikge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSlcbiAgICByZXR1cm4gXCJcIjtcbiAgbG9jID0gbG9jIHx8IGdsb2JhbFRoaXMubG9jYXRpb247XG4gIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsLCBkb2N1bWVudC5iYXNlVVJJKTtcbiAgcmV0dXJuIHBhcnNlZFVybC5ob3N0bmFtZSAhPT0gbG9jLmhvc3RuYW1lIHx8IHBhcnNlZFVybC5wb3J0ICE9PSBsb2MucG9ydCB8fCBwYXJzZWRVcmwucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCA/IFwiYW5vbnltb3VzXCIgOiBcIlwiO1xufVxuZXhwb3J0IHtcbiAgZGV0ZXJtaW5lQ3Jvc3NPcmlnaW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlcm1pbmVDcm9zc09yaWdpbi5tanMubWFwXG4iLCJpbXBvcnQgXCIuLi9zZXR0aW5ncy5tanNcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5mdW5jdGlvbiBnZXRSZXNvbHV0aW9uT2ZVcmwodXJsLCBkZWZhdWx0VmFsdWUgPSAxKSB7XG4gIGNvbnN0IHJlc29sdXRpb24gPSBzZXR0aW5ncy5SRVRJTkFfUFJFRklYPy5leGVjKHVybCk7XG4gIHJldHVybiByZXNvbHV0aW9uID8gcGFyc2VGbG9hdChyZXNvbHV0aW9uWzFdKSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmV4cG9ydCB7XG4gIGdldFJlc29sdXRpb25PZlVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlc29sdXRpb25PZlVybC5tanMubWFwXG4iLCJpbXBvcnQgXCIuL3NldHRpbmdzLm1qc1wiO1xuaW1wb3J0IHsgaXNNb2JpbGUgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBkZWZhdWx0MyB9IGZyb20gXCJlYXJjdXRcIjtcbmltcG9ydCB7IHVybCB9IGZyb20gXCIuL3VybC5tanNcIjtcbmltcG9ydCB7IHBhdGggfSBmcm9tIFwiLi9wYXRoLm1qc1wiO1xuaW1wb3J0IHsgZGV0ZWN0VmlkZW9BbHBoYU1vZGUgfSBmcm9tIFwiLi9icm93c2VyL2RldGVjdFZpZGVvQWxwaGFNb2RlLm1qc1wiO1xuaW1wb3J0IHsgc2F5SGVsbG8sIHNraXBIZWxsbyB9IGZyb20gXCIuL2Jyb3dzZXIvaGVsbG8ubWpzXCI7XG5pbXBvcnQgeyBpc1dlYkdMU3VwcG9ydGVkIH0gZnJvbSBcIi4vYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qc1wiO1xuaW1wb3J0IHsgaGV4MnJnYiwgaGV4MnN0cmluZywgcmdiMmhleCwgc3RyaW5nMmhleCB9IGZyb20gXCIuL2NvbG9yL2hleC5tanNcIjtcbmltcG9ydCB7IGNvcnJlY3RCbGVuZE1vZGUsIHByZW11bHRpcGx5QmxlbmRNb2RlLCBwcmVtdWx0aXBseVJnYmEsIHByZW11bHRpcGx5VGludCwgcHJlbXVsdGlwbHlUaW50VG9SZ2JhIH0gZnJvbSBcIi4vY29sb3IvcHJlbXVsdGlwbHkubWpzXCI7XG5pbXBvcnQgeyBEQVRBX1VSSSB9IGZyb20gXCIuL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgY3JlYXRlSW5kaWNlc0ZvclF1YWRzIH0gZnJvbSBcIi4vZGF0YS9jcmVhdGVJbmRpY2VzRm9yUXVhZHMubWpzXCI7XG5pbXBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSBcIi4vZGF0YS9nZXRCdWZmZXJUeXBlLm1qc1wiO1xuaW1wb3J0IHsgaW50ZXJsZWF2ZVR5cGVkQXJyYXlzIH0gZnJvbSBcIi4vZGF0YS9pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzXCI7XG5pbXBvcnQgeyBpc1BvdzIsIGxvZzIsIG5leHRQb3cyIH0gZnJvbSBcIi4vZGF0YS9wb3cyLm1qc1wiO1xuaW1wb3J0IHsgcmVtb3ZlSXRlbXMgfSBmcm9tIFwiLi9kYXRhL3JlbW92ZUl0ZW1zLm1qc1wiO1xuaW1wb3J0IHsgc2lnbiB9IGZyb20gXCIuL2RhdGEvc2lnbi5tanNcIjtcbmltcG9ydCB7IHVpZCB9IGZyb20gXCIuL2RhdGEvdWlkLm1qc1wiO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tIFwiLi9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qc1wiO1xuaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tIFwiLi9tZWRpYS9Cb3VuZGluZ0JveC5tanNcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlQ2FjaGUsIFByb2dyYW1DYWNoZSwgVGV4dHVyZUNhY2hlLCBjbGVhclRleHR1cmVDYWNoZSwgZGVzdHJveVRleHR1cmVDYWNoZSB9IGZyb20gXCIuL21lZGlhL2NhY2hlcy5tanNcIjtcbmltcG9ydCB7IENhbnZhc1JlbmRlclRhcmdldCB9IGZyb20gXCIuL21lZGlhL0NhbnZhc1JlbmRlclRhcmdldC5tanNcIjtcbmltcG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH0gZnJvbSBcIi4vbWVkaWEvZ2V0Q2FudmFzQm91bmRpbmdCb3gubWpzXCI7XG5pbXBvcnQgeyB0cmltQ2FudmFzIH0gZnJvbSBcIi4vbWVkaWEvdHJpbUNhbnZhcy5tanNcIjtcbmltcG9ydCB7IGRlY29tcG9zZURhdGFVcmkgfSBmcm9tIFwiLi9uZXR3b3JrL2RlY29tcG9zZURhdGFVcmkubWpzXCI7XG5pbXBvcnQgeyBkZXRlcm1pbmVDcm9zc09yaWdpbiB9IGZyb20gXCIuL25ldHdvcmsvZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4ubWpzXCI7XG5pbXBvcnQgeyBnZXRSZXNvbHV0aW9uT2ZVcmwgfSBmcm9tIFwiLi9uZXR3b3JrL2dldFJlc29sdXRpb25PZlVybC5tanNcIjtcbmltcG9ydCBcIi4vdHlwZXMvaW5kZXgubWpzXCI7XG5leHBvcnQge1xuICBCYXNlVGV4dHVyZUNhY2hlLFxuICBCb3VuZGluZ0JveCxcbiAgQ2FudmFzUmVuZGVyVGFyZ2V0LFxuICBEQVRBX1VSSSxcbiAgZGVmYXVsdDIgYXMgRXZlbnRFbWl0dGVyLFxuICBQcm9ncmFtQ2FjaGUsXG4gIFRleHR1cmVDYWNoZSxcbiAgY2xlYXJUZXh0dXJlQ2FjaGUsXG4gIGNvcnJlY3RCbGVuZE1vZGUsXG4gIGNyZWF0ZUluZGljZXNGb3JRdWFkcyxcbiAgZGVjb21wb3NlRGF0YVVyaSxcbiAgZGVwcmVjYXRpb24sXG4gIGRlc3Ryb3lUZXh0dXJlQ2FjaGUsXG4gIGRldGVjdFZpZGVvQWxwaGFNb2RlLFxuICBkZXRlcm1pbmVDcm9zc09yaWdpbixcbiAgZGVmYXVsdDMgYXMgZWFyY3V0LFxuICBnZXRCdWZmZXJUeXBlLFxuICBnZXRDYW52YXNCb3VuZGluZ0JveCxcbiAgZ2V0UmVzb2x1dGlvbk9mVXJsLFxuICBoZXgycmdiLFxuICBoZXgyc3RyaW5nLFxuICBpbnRlcmxlYXZlVHlwZWRBcnJheXMsXG4gIGlzTW9iaWxlLFxuICBpc1BvdzIsXG4gIGlzV2ViR0xTdXBwb3J0ZWQsXG4gIGxvZzIsXG4gIG5leHRQb3cyLFxuICBwYXRoLFxuICBwcmVtdWx0aXBseUJsZW5kTW9kZSxcbiAgcHJlbXVsdGlwbHlSZ2JhLFxuICBwcmVtdWx0aXBseVRpbnQsXG4gIHByZW11bHRpcGx5VGludFRvUmdiYSxcbiAgcmVtb3ZlSXRlbXMsXG4gIHJnYjJoZXgsXG4gIHNheUhlbGxvLFxuICBzaWduLFxuICBza2lwSGVsbG8sXG4gIHN0cmluZzJoZXgsXG4gIHRyaW1DYW52YXMsXG4gIHVpZCxcbiAgdXJsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIEV4dGVuc2lvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFeHRlbnNpb25UeXBlMikgPT4gKEV4dGVuc2lvblR5cGUyLlJlbmRlcmVyID0gXCJyZW5kZXJlclwiLCBFeHRlbnNpb25UeXBlMi5BcHBsaWNhdGlvbiA9IFwiYXBwbGljYXRpb25cIiwgRXh0ZW5zaW9uVHlwZTIuUmVuZGVyZXJTeXN0ZW0gPSBcInJlbmRlcmVyLXdlYmdsLXN5c3RlbVwiLCBFeHRlbnNpb25UeXBlMi5SZW5kZXJlclBsdWdpbiA9IFwicmVuZGVyZXItd2ViZ2wtcGx1Z2luXCIsIEV4dGVuc2lvblR5cGUyLkNhbnZhc1JlbmRlcmVyU3lzdGVtID0gXCJyZW5kZXJlci1jYW52YXMtc3lzdGVtXCIsIEV4dGVuc2lvblR5cGUyLkNhbnZhc1JlbmRlcmVyUGx1Z2luID0gXCJyZW5kZXJlci1jYW52YXMtcGx1Z2luXCIsIEV4dGVuc2lvblR5cGUyLkFzc2V0ID0gXCJhc3NldFwiLCBFeHRlbnNpb25UeXBlMi5Mb2FkUGFyc2VyID0gXCJsb2FkLXBhcnNlclwiLCBFeHRlbnNpb25UeXBlMi5SZXNvbHZlUGFyc2VyID0gXCJyZXNvbHZlLXBhcnNlclwiLCBFeHRlbnNpb25UeXBlMi5DYWNoZVBhcnNlciA9IFwiY2FjaGUtcGFyc2VyXCIsIEV4dGVuc2lvblR5cGUyLkRldGVjdGlvblBhcnNlciA9IFwiZGV0ZWN0aW9uLXBhcnNlclwiLCBFeHRlbnNpb25UeXBlMikpKEV4dGVuc2lvblR5cGUgfHwge30pO1xuY29uc3Qgbm9ybWFsaXplRXh0ZW5zaW9uID0gKGV4dCkgPT4ge1xuICBpZiAodHlwZW9mIGV4dCA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGV4dCA9PSBcIm9iamVjdFwiICYmIGV4dC5leHRlbnNpb24pIHtcbiAgICBpZiAoIWV4dC5leHRlbnNpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gY2xhc3MgbXVzdCBoYXZlIGFuIGV4dGVuc2lvbiBvYmplY3RcIik7XG4gICAgZXh0ID0geyAuLi50eXBlb2YgZXh0LmV4dGVuc2lvbiAhPSBcIm9iamVjdFwiID8geyB0eXBlOiBleHQuZXh0ZW5zaW9uIH0gOiBleHQuZXh0ZW5zaW9uLCByZWY6IGV4dCB9O1xuICB9XG4gIGlmICh0eXBlb2YgZXh0ID09IFwib2JqZWN0XCIpXG4gICAgZXh0ID0geyAuLi5leHQgfTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXh0ZW5zaW9uIHR5cGVcIik7XG4gIHJldHVybiB0eXBlb2YgZXh0LnR5cGUgPT0gXCJzdHJpbmdcIiAmJiAoZXh0LnR5cGUgPSBbZXh0LnR5cGVdKSwgZXh0O1xufSwgbm9ybWFsaXplUHJpb3JpdHkgPSAoZXh0LCBkZWZhdWx0UHJpb3JpdHkpID0+IG5vcm1hbGl6ZUV4dGVuc2lvbihleHQpLnByaW9yaXR5ID8/IGRlZmF1bHRQcmlvcml0eSwgZXh0ZW5zaW9ucyA9IHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgX2FkZEhhbmRsZXJzOiB7fSxcbiAgLyoqIEBpZ25vcmUgKi9cbiAgX3JlbW92ZUhhbmRsZXJzOiB7fSxcbiAgLyoqIEBpZ25vcmUgKi9cbiAgX3F1ZXVlOiB7fSxcbiAgLyoqXG4gICAqIFJlbW92ZSBleHRlbnNpb25zIGZyb20gUGl4aUpTLlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyAtIEV4dGVuc2lvbnMgdG8gYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybnMge1BJWEkuZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVtb3ZlKC4uLmV4dGVuc2lvbnMyKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4gdGhpcy5fcmVtb3ZlSGFuZGxlcnNbdHlwZV0/LihleHQpKTtcbiAgICB9KSwgdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIG5ldyBleHRlbnNpb25zIHdpdGggUGl4aUpTLlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyAtIFRoZSBzcHJlYWQgb2YgZXh0ZW5zaW9ucyB0byBhZGQgdG8gUGl4aUpTLlxuICAgKiBAcmV0dXJucyB7UElYSS5leHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGQoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uczIubWFwKG5vcm1hbGl6ZUV4dGVuc2lvbikuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICBleHQudHlwZS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5fYWRkSGFuZGxlcnMsIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgICAgIGhhbmRsZXJzW3R5cGVdID8gaGFuZGxlcnNbdHlwZV0oZXh0KSA6IChxdWV1ZVt0eXBlXSA9IHF1ZXVlW3R5cGVdIHx8IFtdLCBxdWV1ZVt0eXBlXS5wdXNoKGV4dCkpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGV4dGVuc2lvbnMgYnkgbmFtZS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXh0ZW5zaW9uIHR5cGUuXG4gICAqIEBwYXJhbSBvbkFkZCAgLSBGdW5jdGlvbiBmb3IgaGFuZGxpbmcgd2hlbiBleHRlbnNpb25zIGFyZSBhZGRlZC9yZWdpc3RlcmVkIHBhc3NlcyB7QGxpbmsgUElYSS5FeHRlbnNpb25Gb3JtYXR9LlxuICAgKiBAcGFyYW0gb25SZW1vdmUgIC0gRnVuY3Rpb24gZm9yIGhhbmRsaW5nIHdoZW4gZXh0ZW5zaW9ucyBhcmUgcmVtb3ZlZC91bnJlZ2lzdGVyZWQgcGFzc2VzIHtAbGluayBQSVhJLkV4dGVuc2lvbkZvcm1hdH0uXG4gICAqIEByZXR1cm5zIHtQSVhJLmV4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZSh0eXBlLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBhZGRIYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzLCByZW1vdmVIYW5kbGVycyA9IHRoaXMuX3JlbW92ZUhhbmRsZXJzO1xuICAgIGlmIChhZGRIYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVIYW5kbGVyc1t0eXBlXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXh0ZW5zaW9uIHR5cGUgJHt0eXBlfSBhbHJlYWR5IGhhcyBhIGhhbmRsZXJgKTtcbiAgICBhZGRIYW5kbGVyc1t0eXBlXSA9IG9uQWRkLCByZW1vdmVIYW5kbGVyc1t0eXBlXSA9IG9uUmVtb3ZlO1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgcmV0dXJuIHF1ZXVlW3R5cGVdICYmIChxdWV1ZVt0eXBlXS5mb3JFYWNoKChleHQpID0+IG9uQWRkKGV4dCkpLCBkZWxldGUgcXVldWVbdHlwZV0pLCB0aGlzO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbWFwIGJ5IGBuYW1lYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIGV4dGVuc2lvbiB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBtYXAgLSBUaGUgb2JqZWN0IG1hcCBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyB7UElYSS5leHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICBoYW5kbGVCeU1hcCh0eXBlLCBtYXApIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGUoXG4gICAgICB0eXBlLFxuICAgICAgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBtYXBbZXh0ZW5zaW9uLm5hbWVdID0gZXh0ZW5zaW9uLnJlZjtcbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBtYXBbZXh0ZW5zaW9uLm5hbWVdO1xuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0eXBlLCBidXQgdXNpbmcgYSBsaXN0IG9mIGV4dGVuc2lvbnMuXG4gICAqIEBwYXJhbSB0eXBlIC0gVHlwZSBvZiBleHRlbnNpb24gdG8gaGFuZGxlLlxuICAgKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IG9mIGV4dGVuc2lvbnMuXG4gICAqIEBwYXJhbSBkZWZhdWx0UHJpb3JpdHkgLSBUaGUgZGVmYXVsdCBwcmlvcml0eSB0byB1c2UgaWYgbm9uZSBpcyBzcGVjaWZpZWQuXG4gICAqIEByZXR1cm5zIHtQSVhJLmV4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZUJ5TGlzdCh0eXBlLCBsaXN0LCBkZWZhdWx0UHJpb3JpdHkgPSAtMSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZShcbiAgICAgIHR5cGUsXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGxpc3QuaW5jbHVkZXMoZXh0ZW5zaW9uLnJlZikgfHwgKGxpc3QucHVzaChleHRlbnNpb24ucmVmKSwgbGlzdC5zb3J0KChhLCBiKSA9PiBub3JtYWxpemVQcmlvcml0eShiLCBkZWZhdWx0UHJpb3JpdHkpIC0gbm9ybWFsaXplUHJpb3JpdHkoYSwgZGVmYXVsdFByaW9yaXR5KSkpO1xuICAgICAgfSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0LmluZGV4T2YoZXh0ZW5zaW9uLnJlZik7XG4gICAgICAgIGluZGV4ICE9PSAtMSAmJiBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEV4dGVuc2lvblR5cGUsXG4gIGV4dGVuc2lvbnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjbGFzcyBWaWV3YWJsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHNpemVPckJ1ZmZlcikge1xuICAgIHR5cGVvZiBzaXplT3JCdWZmZXIgPT0gXCJudW1iZXJcIiA/IHRoaXMucmF3QmluYXJ5RGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihzaXplT3JCdWZmZXIpIDogc2l6ZU9yQnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlci5idWZmZXIgOiB0aGlzLnJhd0JpbmFyeURhdGEgPSBzaXplT3JCdWZmZXIsIHRoaXMudWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpLCB0aGlzLmZsb2F0MzJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50OEFycmF5YC4gKi9cbiAgZ2V0IGludDhWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9pbnQ4VmlldyB8fCAodGhpcy5faW50OFZpZXcgPSBuZXcgSW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSkpLCB0aGlzLl9pbnQ4VmlldztcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYFVpbnQ4QXJyYXlgLiAqL1xuICBnZXQgdWludDhWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl91aW50OFZpZXcgfHwgKHRoaXMuX3VpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSkpLCB0aGlzLl91aW50OFZpZXc7XG4gIH1cbiAgLyoqICBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50MTZBcnJheWAuICovXG4gIGdldCBpbnQxNlZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludDE2VmlldyB8fCAodGhpcy5faW50MTZWaWV3ID0gbmV3IEludDE2QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKSksIHRoaXMuX2ludDE2VmlldztcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYFVpbnQxNkFycmF5YC4gKi9cbiAgZ2V0IHVpbnQxNlZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpbnQxNlZpZXcgfHwgKHRoaXMuX3VpbnQxNlZpZXcgPSBuZXcgVWludDE2QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKSksIHRoaXMuX3VpbnQxNlZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBJbnQzMkFycmF5YC4gKi9cbiAgZ2V0IGludDMyVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5faW50MzJWaWV3IHx8ICh0aGlzLl9pbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpKSwgdGhpcy5faW50MzJWaWV3O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2aWV3IG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgKiBAcGFyYW0gdHlwZSAtIE9uZSBvZiBgaW50OGAsIGB1aW50OGAsIGBpbnQxNmAsXG4gICAqICAgIGB1aW50MTZgLCBgaW50MzJgLCBgdWludDMyYCwgYW5kIGBmbG9hdDMyYC5cbiAgICogQHJldHVybnMgLSB0eXBlZCBhcnJheSBvZiBnaXZlbiB0eXBlXG4gICAqL1xuICB2aWV3KHR5cGUpIHtcbiAgICByZXR1cm4gdGhpc1tgJHt0eXBlfVZpZXdgXTtcbiAgfVxuICAvKiogRGVzdHJveXMgYWxsIGJ1ZmZlciByZWZlcmVuY2VzLiBEbyBub3QgdXNlIGFmdGVyIGNhbGxpbmcgdGhpcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBudWxsLCB0aGlzLl9pbnQ4VmlldyA9IG51bGwsIHRoaXMuX3VpbnQ4VmlldyA9IG51bGwsIHRoaXMuX2ludDE2VmlldyA9IG51bGwsIHRoaXMuX3VpbnQxNlZpZXcgPSBudWxsLCB0aGlzLl9pbnQzMlZpZXcgPSBudWxsLCB0aGlzLnVpbnQzMlZpZXcgPSBudWxsLCB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgc2l6ZU9mKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzbid0IGEgdmFsaWQgdmlldyB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBWaWV3YWJsZUJ1ZmZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdhYmxlQnVmZmVyLm1qcy5tYXBcbiIsImNvbnN0IGZyYWdUZW1wbGF0ZSA9IFtcbiAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcbiAgXCJ2b2lkIG1haW4odm9pZCl7XCIsXG4gIFwiZmxvYXQgdGVzdCA9IDAuMTtcIixcbiAgXCIlZm9ybG9vcCVcIixcbiAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XCIsXG4gIFwifVwiXG5dLmpvaW4oYFxuYCk7XG5mdW5jdGlvbiBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpIHtcbiAgbGV0IHNyYyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SWZzOyArK2kpXG4gICAgaSA+IDAgJiYgKHNyYyArPSBgXG5lbHNlIGApLCBpIDwgbWF4SWZzIC0gMSAmJiAoc3JjICs9IGBpZih0ZXN0ID09ICR7aX0uMCl7fWApO1xuICByZXR1cm4gc3JjO1xufVxuZnVuY3Rpb24gY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XG4gIGlmIChtYXhJZnMgPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBvZiBgMGAgcGFzc2VkIHRvIGBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyYFwiKTtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gIGZvciAoOyA7ICkge1xuICAgIGNvbnN0IGZyYWdtZW50U3JjID0gZnJhZ1RlbXBsYXRlLnJlcGxhY2UoLyVmb3Jsb29wJS9naSwgZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSk7XG4gICAgaWYgKGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGZyYWdtZW50U3JjKSwgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpLCAhZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgICAgbWF4SWZzID0gbWF4SWZzIC8gMiB8IDA7XG4gICAgZWxzZVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG1heElmcztcbn1cbmV4cG9ydCB7XG4gIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEJMRU5EX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuY29uc3QgQkxFTkQgPSAwLCBPRkZTRVQgPSAxLCBDVUxMSU5HID0gMiwgREVQVEhfVEVTVCA9IDMsIFdJTkRJTkcgPSA0LCBERVBUSF9NQVNLID0gNTtcbmNsYXNzIFN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYXRhID0gMCwgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUwsIHRoaXMucG9seWdvbk9mZnNldCA9IDAsIHRoaXMuYmxlbmQgPSAhMCwgdGhpcy5kZXB0aE1hc2sgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGJsZW5kaW5nIG9mIHRoZSBjb21wdXRlZCBmcmFnbWVudCBjb2xvciB2YWx1ZXMuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGdldCBibGVuZCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCk7XG4gIH1cbiAgc2V0IGJsZW5kKHZhbHVlKSB7XG4gICAgISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCkgIT09IHZhbHVlICYmICh0aGlzLmRhdGEgXj0gMSA8PCBCTEVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhZGRpbmcgYW4gb2Zmc2V0IHRvIGRlcHRoIHZhbHVlcyBvZiBwb2x5Z29uJ3MgZnJhZ21lbnRzXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgb2Zmc2V0cygpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBPRkZTRVQpO1xuICB9XG4gIHNldCBvZmZzZXRzKHZhbHVlKSB7XG4gICAgISEodGhpcy5kYXRhICYgMSA8PCBPRkZTRVQpICE9PSB2YWx1ZSAmJiAodGhpcy5kYXRhIF49IDEgPDwgT0ZGU0VUKTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGN1bGxpbmcgb2YgcG9seWdvbnMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgY3VsbGluZygpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBDVUxMSU5HKTtcbiAgfVxuICBzZXQgY3VsbGluZyh2YWx1ZSkge1xuICAgICEhKHRoaXMuZGF0YSAmIDEgPDwgQ1VMTElORykgIT09IHZhbHVlICYmICh0aGlzLmRhdGEgXj0gMSA8PCBDVUxMSU5HKTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGRlcHRoIGNvbXBhcmlzb25zIGFuZCB1cGRhdGVzIHRvIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgZGVwdGhUZXN0KCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX1RFU1QpO1xuICB9XG4gIHNldCBkZXB0aFRlc3QodmFsdWUpIHtcbiAgICAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX1RFU1QpICE9PSB2YWx1ZSAmJiAodGhpcy5kYXRhIF49IDEgPDwgREVQVEhfVEVTVCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgd3JpdGluZyB0byB0aGUgZGVwdGggYnVmZmVyLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnZXQgZGVwdGhNYXNrKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spO1xuICB9XG4gIHNldCBkZXB0aE1hc2sodmFsdWUpIHtcbiAgICAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spICE9PSB2YWx1ZSAmJiAodGhpcy5kYXRhIF49IDEgPDwgREVQVEhfTUFTSyk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCBmcm9udCBvciBiYWNrLWZhY2luZyBwb2x5Z29ucyBjYW4gYmUgY3VsbGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZ2V0IGNsb2Nrd2lzZUZyb250RmFjZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBXSU5ESU5HKTtcbiAgfVxuICBzZXQgY2xvY2t3aXNlRnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgISEodGhpcy5kYXRhICYgMSA8PCBXSU5ESU5HKSAhPT0gdmFsdWUgJiYgKHRoaXMuZGF0YSBePSAxIDw8IFdJTkRJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHdoZW4gdGhpcyBzdGF0ZSBpcyBzZXQuIEFwcGx5IGEgdmFsdWUgb2YgYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICogU2V0dGluZyB0aGlzIG1vZGUgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiBOT19CTEVORCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIGJsZW5kaW5nIG9uLlxuICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmJsZW5kID0gdmFsdWUgIT09IEJMRU5EX01PREVTLk5PTkUsIHRoaXMuX2JsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcG9seWdvbiBvZmZzZXQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBhbnl0aGluZyBvdGhlciB0aGFuIDAgd2lsbCBhdXRvbWF0aWNhbGx5IGVuYWJsZSBwb2x5Z29uIG9mZnNldCBmaWxsLlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgcG9seWdvbk9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9seWdvbk9mZnNldDtcbiAgfVxuICBzZXQgcG9seWdvbk9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMub2Zmc2V0cyA9ICEhdmFsdWUsIHRoaXMuX3BvbHlnb25PZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgZm9yMmQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICByZXR1cm4gc3RhdGUuZGVwdGhUZXN0ID0gITEsIHN0YXRlLmJsZW5kID0gITAsIHN0YXRlO1xuICB9XG59XG5TdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvY29yZTpTdGF0ZSBibGVuZE1vZGU9JHt0aGlzLmJsZW5kTW9kZX0gY2xvY2t3aXNlRnJvbnRGYWNlPSR7dGhpcy5jbG9ja3dpc2VGcm9udEZhY2V9IGN1bGxpbmc9JHt0aGlzLmN1bGxpbmd9IGRlcHRoTWFzaz0ke3RoaXMuZGVwdGhNYXNrfSBwb2x5Z29uT2Zmc2V0PSR7dGhpcy5wb2x5Z29uT2Zmc2V0fV1gO1xufTtcbmV4cG9ydCB7XG4gIFN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGUubWpzLm1hcFxuIiwiY29uc3QgSU5TVEFMTEVEID0gW107XG5mdW5jdGlvbiBhdXRvRGV0ZWN0UmVzb3VyY2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghc291cmNlKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgZXh0ZW5zaW9uID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHJlc3VsdCA9IC9cXC4oXFx3ezMsNH0pKD86JHxcXD98IykvaS5leGVjKHNvdXJjZSk7XG4gICAgcmVzdWx0ICYmIChleHRlbnNpb24gPSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IElOU1RBTExFRC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IFJlc291cmNlUGx1Z2luID0gSU5TVEFMTEVEW2ldO1xuICAgIGlmIChSZXNvdXJjZVBsdWdpbi50ZXN0ICYmIFJlc291cmNlUGx1Z2luLnRlc3Qoc291cmNlLCBleHRlbnNpb24pKVxuICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBsdWdpbihzb3VyY2UsIG9wdGlvbnMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBzb3VyY2UgdHlwZSB0byBhdXRvLWRldGVjdCBSZXNvdXJjZVwiKTtcbn1cbmV4cG9ydCB7XG4gIElOU1RBTExFRCxcbiAgYXV0b0RldGVjdFJlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b0RldGVjdFJlc291cmNlLm1qcy5tYXBcbiIsImNsYXNzIFJ1bm5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBmdW5jdGlvbiBuYW1lIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBvbiB0aGUgbGlzdGVuZXJzIGFkZGVkIHRvIHRoaXMgUnVubmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMuaXRlbXMgPSBbXSwgdGhpcy5fbmFtZSA9IG5hbWUsIHRoaXMuX2FsaWFzQ291bnQgPSAwO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtcGFyYW0sIGpzZG9jL2NoZWNrLXBhcmFtLW5hbWVzICovXG4gIC8qKlxuICAgKiBEaXNwYXRjaC9Ccm9hZGNhc3QgUnVubmVyIHRvIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKiBAcGFyYW0gey4uLmFueX0gcGFyYW1zIC0gKG9wdGlvbmFsKSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gZWFjaCBsaXN0ZW5lclxuICAgKi9cbiAgLyogIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1wYXJhbSwganNkb2MvY2hlY2stcGFyYW0tbmFtZXMgKi9cbiAgZW1pdChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggYXJndW1lbnRzIHJlYWNoZWRcIik7XG4gICAgY29uc3QgeyBuYW1lLCBpdGVtcyB9ID0gdGhpcztcbiAgICB0aGlzLl9hbGlhc0NvdW50Kys7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgaXRlbXNbaV1bbmFtZV0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcbiAgICByZXR1cm4gaXRlbXMgPT09IHRoaXMuaXRlbXMgJiYgdGhpcy5fYWxpYXNDb3VudC0tLCB0aGlzO1xuICB9XG4gIGVuc3VyZU5vbkFsaWFzZWRJdGVtcygpIHtcbiAgICB0aGlzLl9hbGlhc0NvdW50ID4gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDEgJiYgKHRoaXMuX2FsaWFzQ291bnQgPSAwLCB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSBSdW5uZXJcbiAgICpcbiAgICogUnVubmVycyBkbyBub3QgbmVlZCB0byBoYXZlIHNjb3BlIG9yIGZ1bmN0aW9ucyBwYXNzZWQgdG8gdGhlbS5cbiAgICogQWxsIHRoYXQgaXMgcmVxdWlyZWQgaXMgdG8gcGFzcyB0aGUgbGlzdGVuaW5nIG9iamVjdCBhbmQgZW5zdXJlIHRoYXQgaXQgaGFzIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBoYXMgdGhlIHNhbWUgbmFtZVxuICAgKiBhcyB0aGUgbmFtZSBwcm92aWRlZCB0byB0aGUgUnVubmVyIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEUuZy4gQSBsaXN0ZW5lciBwYXNzZWQgdG8gdGhpcyBSdW5uZXIgd2lsbCByZXF1aXJlIGEgJ2NvbXBsZXRlJyBmdW5jdGlvbi5cbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnQHBpeGkvcnVubmVyJztcbiAgICpcbiAgICogY29uc3QgY29tcGxldGUgPSBuZXcgUnVubmVyKCdjb21wbGV0ZScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHNjb3BlIHVzZWQgd2lsbCBiZSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBsaXN0ZW5pbmcuXG4gICAqL1xuICBhZGQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX25hbWVdICYmICh0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpLCB0aGlzLnJlbW92ZShpdGVtKSwgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgc2luZ2xlIGxpc3RlbmVyIGZyb20gdGhlIGRpc3BhdGNoIHF1ZXVlLlxuICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBsaXN0ZW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgcmV0dXJuIGluZGV4ICE9PSAtMSAmJiAodGhpcy5lbnN1cmVOb25BbGlhc2VkSXRlbXMoKSwgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBpcyBhbHJlYWR5IGluIHRoZSBSdW5uZXJcbiAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuZXIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byBjaGVjay5cbiAgICovXG4gIGNvbnRhaW5zKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmNsdWRlcyhpdGVtKTtcbiAgfVxuICAvKiogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgUnVubmVyICovXG4gIHJlbW92ZUFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVOb25BbGlhc2VkSXRlbXMoKSwgdGhpcy5pdGVtcy5sZW5ndGggPSAwLCB0aGlzO1xuICB9XG4gIC8qKiBSZW1vdmUgYWxsIHJlZmVyZW5jZXMsIGRvbid0IHVzZSBhZnRlciB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsKCksIHRoaXMuaXRlbXMgPSBudWxsLCB0aGlzLl9uYW1lID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogYHRydWVgIGlmIHRoZXJlIGFyZSBubyB0aGlzIFJ1bm5lciBjb250YWlucyBubyBsaXN0ZW5lcnNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcnVubmVyLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSdW5uZXIucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYGVtaXRgXG4gICAqIEBtZW1iZXJvZiBQSVhJLlJ1bm5lciNcbiAgICogQG1ldGhvZCBkaXNwYXRjaFxuICAgKiBAc2VlIFBJWEkuUnVubmVyI2VtaXRcbiAgICovXG4gIGRpc3BhdGNoOiB7IHZhbHVlOiBSdW5uZXIucHJvdG90eXBlLmVtaXQgfSxcbiAgLyoqXG4gICAqIEFsaWFzIGZvciBgZW1pdGBcbiAgICogQG1lbWJlcm9mIFBJWEkuUnVubmVyI1xuICAgKiBAbWV0aG9kIHJ1blxuICAgKiBAc2VlIFBJWEkuUnVubmVyI2VtaXRcbiAgICovXG4gIHJ1bjogeyB2YWx1ZTogUnVubmVyLnByb3RvdHlwZS5lbWl0IH1cbn0pO1xuZXhwb3J0IHtcbiAgUnVubmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UnVubmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCIuL1J1bm5lci5tanNcIjtcbmV4cG9ydCB7XG4gIFJ1bm5lclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJAcGl4aS9ydW5uZXJcIjtcbmNsYXNzIFJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aCwgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0LCB0aGlzLmRlc3Ryb3llZCA9ICExLCB0aGlzLmludGVybmFsID0gITEsIHRoaXMub25SZXNpemUgPSBuZXcgUnVubmVyKFwic2V0UmVhbFNpemVcIiksIHRoaXMub25VcGRhdGUgPSBuZXcgUnVubmVyKFwidXBkYXRlXCIpLCB0aGlzLm9uRXJyb3IgPSBuZXcgUnVubmVyKFwib25FcnJvclwiKTtcbiAgfVxuICAvKipcbiAgICogQmluZCB0byBhIHBhcmVudCBCYXNlVGV4dHVyZVxuICAgKiBAcGFyYW0gYmFzZVRleHR1cmUgLSBQYXJlbnQgdGV4dHVyZVxuICAgKi9cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHRoaXMub25SZXNpemUuYWRkKGJhc2VUZXh0dXJlKSwgdGhpcy5vblVwZGF0ZS5hZGQoYmFzZVRleHR1cmUpLCB0aGlzLm9uRXJyb3IuYWRkKGJhc2VUZXh0dXJlKSwgKHRoaXMuX3dpZHRoIHx8IHRoaXMuX2hlaWdodCkgJiYgdGhpcy5vblJlc2l6ZS5lbWl0KHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBVbmJpbmQgdG8gYSBwYXJlbnQgQmFzZVRleHR1cmVcbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlIC0gUGFyZW50IHRleHR1cmVcbiAgICovXG4gIHVuYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHRoaXMub25SZXNpemUucmVtb3ZlKGJhc2VUZXh0dXJlKSwgdGhpcy5vblVwZGF0ZS5yZW1vdmUoYmFzZVRleHR1cmUpLCB0aGlzLm9uRXJyb3IucmVtb3ZlKGJhc2VUZXh0dXJlKTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhIHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0gd2lkdGggLSBYIGRpbWVuc2lvblxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gWSBkaW1lbnNpb25cbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgKHdpZHRoICE9PSB0aGlzLl93aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuX2hlaWdodCkgJiYgKHRoaXMuX3dpZHRoID0gd2lkdGgsIHRoaXMuX2hlaWdodCA9IGhlaWdodCwgdGhpcy5vblJlc2l6ZS5lbWl0KHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogSGFzIGJlZW4gdmFsaWRhdGVkXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3dpZHRoICYmICEhdGhpcy5faGVpZ2h0O1xuICB9XG4gIC8qKiBIYXMgYmVlbiB1cGRhdGVkIHRyaWdnZXIgZXZlbnQuICovXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCB8fCB0aGlzLm9uVXBkYXRlLmVtaXQoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiB0byBzdGFydCBwcmVsb2FkaW5nIGEgcmVzb3VyY2VcbiAgICogb3IgZG8gYW55IG90aGVyIHByZXBhcmUgc3RlcC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJucyBIYW5kbGUgdGhlIHZhbGlkYXRlIGV2ZW50XG4gICAqL1xuICBsb2FkKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgcmVzb3VyY2UuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVzb3VyY2UuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0eWxlLCBvcHRpb25hbCB0byBvdmVycmlkZVxuICAgKiBAcGFyYW0gX3JlbmRlcmVyIC0geWVhaCwgcmVuZGVyZXIhXG4gICAqIEBwYXJhbSBfYmFzZVRleHR1cmUgLSB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0gX2dsVGV4dHVyZSAtIHRleHR1cmUgaW5zdGFuY2UgZm9yIHRoaXMgd2ViZ2wgY29udGV4dFxuICAgKiBAcmV0dXJucyAtIGB0cnVlYCBpcyBzdWNjZXNzXG4gICAqL1xuICBzdHlsZShfcmVuZGVyZXIsIF9iYXNlVGV4dHVyZSwgX2dsVGV4dHVyZSkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKiogQ2xlYW4gdXAgYW55dGhpbmcsIHRoaXMgaGFwcGVucyB3aGVuIGRlc3Ryb3lpbmcgaXMgcmVhZHkuICovXG4gIGRpc3Bvc2UoKSB7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgd2hlbiBkZXN0cm95aW5nIHJlc291cmNlLCB1bmJpbmQgYW55IEJhc2VUZXh0dXJlIG9iamVjdFxuICAgKiBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCwgYXMgcmVmZXJlbmNlIGNvdW50cyBhcmUgbWFpbnRhaW5lZFxuICAgKiBpbnRlcm5hbGx5LlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCB8fCAodGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5kaXNwb3NlKCksIHRoaXMub25FcnJvci5yZW1vdmVBbGwoKSwgdGhpcy5vbkVycm9yID0gbnVsbCwgdGhpcy5vblJlc2l6ZS5yZW1vdmVBbGwoKSwgdGhpcy5vblJlc2l6ZSA9IG51bGwsIHRoaXMub25VcGRhdGUucmVtb3ZlQWxsKCksIHRoaXMub25VcGRhdGUgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQWJzdHJhY3QsIHVzZWQgdG8gYXV0by1kZXRlY3QgcmVzb3VyY2UgdHlwZS5cbiAgICogQHBhcmFtIHsqfSBfc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9leHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XG4gICAqL1xuICBzdGF0aWMgdGVzdChfc291cmNlLCBfZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5leHBvcnQge1xuICBSZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tIFwiLi9SZXNvdXJjZS5tanNcIjtcbmNsYXNzIEJ1ZmZlclJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZSAtIFNvdXJjZSBidWZmZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLndpZHRoIC0gV2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7MXwyfDR8OH0gW29wdGlvbnMudW5wYWNrQWxpZ25tZW50PTRdIC0gVGhlIGFsaWdubWVudCBvZiB0aGUgcGl4ZWwgcm93cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJSZXNvdXJjZSB3aWR0aCBvciBoZWlnaHQgaW52YWxpZFwiKTtcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KSwgdGhpcy5kYXRhID0gc291cmNlLCB0aGlzLnVucGFja0FsaWdubWVudCA9IG9wdGlvbnMudW5wYWNrQWxpZ25tZW50ID8/IDQ7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBVcGxvYWQgdG8gdGhlIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIFJlZmVyZW5jZSB0byBwYXJlbnQgdGV4dHVyZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlIC0gZ2xUZXh0dXJlXG4gICAqIEByZXR1cm5zIC0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAqL1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIHRoaXMudW5wYWNrQWxpZ25tZW50KSwgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLlVOUEFDSyk7XG4gICAgY29uc3Qgd2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGgsIGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgcmV0dXJuIGdsVGV4dHVyZS53aWR0aCA9PT0gd2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gaGVpZ2h0ID8gZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgIGJhc2VUZXh0dXJlLnRhcmdldCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYmFzZVRleHR1cmUuZm9ybWF0LFxuICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICB0aGlzLmRhdGFcbiAgICApIDogKGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoLCBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0LCBnbC50ZXhJbWFnZTJEKFxuICAgICAgYmFzZVRleHR1cmUudGFyZ2V0LFxuICAgICAgMCxcbiAgICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgMCxcbiAgICAgIGJhc2VUZXh0dXJlLmZvcm1hdCxcbiAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgdGhpcy5kYXRhXG4gICAgKSksICEwO1xuICB9XG4gIC8qKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgYnVmZmVyIHNvdXJjZVxuICAgKi9cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8IHNvdXJjZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5O1xuICB9XG59XG5leHBvcnQge1xuICBCdWZmZXJSZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IFNDQUxFX01PREVTLCBBTFBIQV9NT0RFUywgRk9STUFUUywgVFlQRVMsIE1JUE1BUF9NT0RFUywgV1JBUF9NT0RFUywgVEFSR0VUUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIHVpZCwgaXNQb3cyLCBCYXNlVGV4dHVyZUNhY2hlLCBUZXh0dXJlQ2FjaGUgfSBmcm9tIFwiQHBpeGkvdXRpbHNcIjtcbmltcG9ydCB7IGF1dG9EZXRlY3RSZXNvdXJjZSB9IGZyb20gXCIuL3Jlc291cmNlcy9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gXCIuL3Jlc291cmNlcy9CdWZmZXJSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSBcIi4vcmVzb3VyY2VzL1Jlc291cmNlLm1qc1wiO1xuY29uc3QgZGVmYXVsdEJ1ZmZlck9wdGlvbnMgPSB7XG4gIHNjYWxlTW9kZTogU0NBTEVfTU9ERVMuTkVBUkVTVCxcbiAgYWxwaGFNb2RlOiBBTFBIQV9NT0RFUy5OUE1cbn0sIF9CYXNlVGV4dHVyZSA9IGNsYXNzIF9CYXNlVGV4dHVyZTIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLlJlc291cmNlfEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxJbWFnZUJpdG1hcHxJQ2FudmFzfHN0cmluZ30gW3Jlc291cmNlPW51bGxdIC1cbiAgICogICAgICAgIFRoZSBjdXJyZW50IHJlc291cmNlIHRvIHVzZSwgZm9yIHRoaW5ncyB0aGF0IGFyZW4ndCBSZXNvdXJjZSBvYmplY3RzLCB3aWxsIGJlIGNvbnZlcnRlZFxuICAgKiAgICAgICAgaW50byBhIFJlc291cmNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbGxlY3Rpb24gb2Ygb3B0aW9ucywgZGVmYXVsdCBvcHRpb25zIGluaGVyaXRlZCBmcm9tIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zfS5cbiAgICogQHBhcmFtIHtQSVhJLk1JUE1BUF9NT0RFU30gW29wdGlvbnMubWlwbWFwXSAtIElmIG1pcG1hcHBpbmcgaXMgZW5hYmxlZCBmb3IgdGV4dHVyZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYW5pc290cm9waWNMZXZlbF0gLSBBbmlzb3Ryb3BpYyBmaWx0ZXJpbmcgbGV2ZWwgb2YgdGV4dHVyZVxuICAgKiBAcGFyYW0ge1BJWEkuV1JBUF9NT0RFU30gW29wdGlvbnMud3JhcE1vZGVdIC0gV3JhcCBtb2RlIGZvciB0ZXh0dXJlc1xuICAgKiBAcGFyYW0ge1BJWEkuU0NBTEVfTU9ERVN9IFtvcHRpb25zLnNjYWxlTW9kZV0gLSBEZWZhdWx0IHNjYWxlIG1vZGUsIGxpbmVhciwgbmVhcmVzdFxuICAgKiBAcGFyYW0ge1BJWEkuRk9STUFUU30gW29wdGlvbnMuZm9ybWF0XSAtIEdMIGZvcm1hdCB0eXBlXG4gICAqIEBwYXJhbSB7UElYSS5UWVBFU30gW29wdGlvbnMudHlwZV0gLSBHTCBkYXRhIHR5cGVcbiAgICogQHBhcmFtIHtQSVhJLlRBUkdFVFN9IFtvcHRpb25zLnRhcmdldF0gLSBHTCB0ZXh0dXJlIHRhcmdldFxuICAgKiBAcGFyYW0ge1BJWEkuQUxQSEFfTU9ERVN9IFtvcHRpb25zLmFscGhhTW9kZV0gLSBQcmUgbXVsdGlwbHkgdGhlIGltYWdlIGFscGhhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD0wXSAtIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MF0gLSBIZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249UElYSS5zZXR0aW5ncy5SRVNPTFVUSU9OXSAtIFJlc29sdXRpb24gb2YgdGhlIGJhc2UgdGV4dHVyZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucmVzb3VyY2VPcHRpb25zXSAtIE9wdGlvbmFsIHJlc291cmNlIG9wdGlvbnMsXG4gICAqICAgICAgICBzZWUge0BsaW5rIFBJWEkuYXV0b0RldGVjdFJlc291cmNlIGF1dG9EZXRlY3RSZXNvdXJjZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc291cmNlID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBzdXBlcigpLCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgX0Jhc2VUZXh0dXJlMi5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgYWxwaGFNb2RlLFxuICAgICAgbWlwbWFwLFxuICAgICAgYW5pc290cm9waWNMZXZlbCxcbiAgICAgIHNjYWxlTW9kZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd3JhcE1vZGUsXG4gICAgICBmb3JtYXQsXG4gICAgICB0eXBlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHJlc291cmNlT3B0aW9uc1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHJlc291cmNlICYmICEocmVzb3VyY2UgaW5zdGFuY2VvZiBSZXNvdXJjZSkgJiYgKHJlc291cmNlID0gYXV0b0RldGVjdFJlc291cmNlKHJlc291cmNlLCByZXNvdXJjZU9wdGlvbnMpLCByZXNvdXJjZS5pbnRlcm5hbCA9ICEwKSwgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBzZXR0aW5ncy5SRVNPTFVUSU9OLCB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCgod2lkdGggfHwgMCkgKiB0aGlzLnJlc29sdXRpb24pIC8gdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQoKGhlaWdodCB8fCAwKSAqIHRoaXMucmVzb2x1dGlvbikgLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX21pcG1hcCA9IG1pcG1hcCwgdGhpcy5hbmlzb3Ryb3BpY0xldmVsID0gYW5pc290cm9waWNMZXZlbCwgdGhpcy5fd3JhcE1vZGUgPSB3cmFwTW9kZSwgdGhpcy5fc2NhbGVNb2RlID0gc2NhbGVNb2RlLCB0aGlzLmZvcm1hdCA9IGZvcm1hdCwgdGhpcy50eXBlID0gdHlwZSwgdGhpcy50YXJnZXQgPSB0YXJnZXQsIHRoaXMuYWxwaGFNb2RlID0gYWxwaGFNb2RlLCB0aGlzLnVpZCA9IHVpZCgpLCB0aGlzLnRvdWNoZWQgPSAwLCB0aGlzLmlzUG93ZXJPZlR3byA9ICExLCB0aGlzLl9yZWZyZXNoUE9UKCksIHRoaXMuX2dsVGV4dHVyZXMgPSB7fSwgdGhpcy5kaXJ0eUlkID0gMCwgdGhpcy5kaXJ0eVN0eWxlSWQgPSAwLCB0aGlzLmNhY2hlSWQgPSBudWxsLCB0aGlzLnZhbGlkID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDAsIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gW10sIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMucmVzb3VyY2UgPSBudWxsLCB0aGlzLl9iYXRjaEVuYWJsZWQgPSAwLCB0aGlzLl9iYXRjaExvY2F0aW9uID0gMCwgdGhpcy5wYXJlbnRUZXh0dXJlQXJyYXkgPSBudWxsLCB0aGlzLnNldFJlc291cmNlKHJlc291cmNlKTtcbiAgfVxuICAvKipcbiAgICogUGl4ZWwgd2lkdGggb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhbFdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBQaXhlbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhbEhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIE1pcG1hcCBtb2RlIG9mIHRoZSB0ZXh0dXJlLCBhZmZlY3RzIGRvd25zY2FsZWQgaW1hZ2VzXG4gICAqIEBkZWZhdWx0IFBJWEkuTUlQTUFQX01PREVTLlBPVzJcbiAgICovXG4gIGdldCBtaXBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pcG1hcDtcbiAgfVxuICBzZXQgbWlwbWFwKHZhbHVlKSB7XG4gICAgdGhpcy5fbWlwbWFwICE9PSB2YWx1ZSAmJiAodGhpcy5fbWlwbWFwID0gdmFsdWUsIHRoaXMuZGlydHlTdHlsZUlkKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXG4gICAqIEBkZWZhdWx0IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSXG4gICAqL1xuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZU1vZGU7XG4gIH1cbiAgc2V0IHNjYWxlTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX3NjYWxlTW9kZSAhPT0gdmFsdWUgJiYgKHRoaXMuX3NjYWxlTW9kZSA9IHZhbHVlLCB0aGlzLmRpcnR5U3R5bGVJZCsrKTtcbiAgfVxuICAvKipcbiAgICogSG93IHRoZSB0ZXh0dXJlIHdyYXBzXG4gICAqIEBkZWZhdWx0IFBJWEkuV1JBUF9NT0RFUy5DTEFNUFxuICAgKi9cbiAgZ2V0IHdyYXBNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwTW9kZTtcbiAgfVxuICBzZXQgd3JhcE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl93cmFwTW9kZSAhPT0gdmFsdWUgJiYgKHRoaXMuX3dyYXBNb2RlID0gdmFsdWUsIHRoaXMuZGlydHlTdHlsZUlkKyspO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHN0eWxlIG9wdGlvbnMgb2YgQmFzZVRleHR1cmVcbiAgICogQHBhcmFtIHNjYWxlTW9kZSAtIFBpeGkgc2NhbGVtb2RlXG4gICAqIEBwYXJhbSBtaXBtYXAgLSBlbmFibGUgbWlwbWFwc1xuICAgKiBAcmV0dXJucyAtIHRoaXNcbiAgICovXG4gIHNldFN0eWxlKHNjYWxlTW9kZSwgbWlwbWFwKSB7XG4gICAgbGV0IGRpcnR5O1xuICAgIHJldHVybiBzY2FsZU1vZGUgIT09IHZvaWQgMCAmJiBzY2FsZU1vZGUgIT09IHRoaXMuc2NhbGVNb2RlICYmICh0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSwgZGlydHkgPSAhMCksIG1pcG1hcCAhPT0gdm9pZCAwICYmIG1pcG1hcCAhPT0gdGhpcy5taXBtYXAgJiYgKHRoaXMubWlwbWFwID0gbWlwbWFwLCBkaXJ0eSA9ICEwKSwgZGlydHkgJiYgdGhpcy5kaXJ0eVN0eWxlSWQrKywgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB3L2gvcmVzb2x1dGlvbi4gVGV4dHVyZSBiZWNvbWVzIHZhbGlkIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICAgKiBAcGFyYW0gZGVzaXJlZFdpZHRoIC0gRGVzaXJlZCB2aXN1YWwgd2lkdGhcbiAgICogQHBhcmFtIGRlc2lyZWRIZWlnaHQgLSBEZXNpcmVkIHZpc3VhbCBoZWlnaHRcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBPcHRpb25hbGx5IHNldCByZXNvbHV0aW9uXG4gICAqIEByZXR1cm5zIC0gdGhpc1xuICAgKi9cbiAgc2V0U2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uLCB0aGlzLnNldFJlYWxTaXplKGRlc2lyZWRXaWR0aCAqIHJlc29sdXRpb24sIGRlc2lyZWRIZWlnaHQgKiByZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyByZWFsIHNpemUgb2YgYmFzZVRleHR1cmUsIHByZXNlcnZlcyBjdXJyZW50IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSByZWFsV2lkdGggLSBGdWxsIHJlbmRlcmVkIHdpZHRoXG4gICAqIEBwYXJhbSByZWFsSGVpZ2h0IC0gRnVsbCByZW5kZXJlZCBoZWlnaHRcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBPcHRpb25hbGx5IHNldCByZXNvbHV0aW9uXG4gICAqIEByZXR1cm5zIC0gdGhpc1xuICAgKi9cbiAgc2V0UmVhbFNpemUocmVhbFdpZHRoLCByZWFsSGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uLCB0aGlzLndpZHRoID0gTWF0aC5yb3VuZChyZWFsV2lkdGgpIC8gdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQocmVhbEhlaWdodCkgLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX3JlZnJlc2hQT1QoKSwgdGhpcy51cGRhdGUoKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVmcmVzaCBjaGVjayBmb3IgaXNQb3dlck9mVHdvIHRleHR1cmUgYmFzZWQgb24gc2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZnJlc2hQT1QoKSB7XG4gICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBpc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIGlzUG93Mih0aGlzLnJlYWxIZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHJlc29sdXRpb25cbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSByZXNcbiAgICogQHJldHVybnMgLSB0aGlzXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBjb25zdCBvbGRSZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJldHVybiBvbGRSZXNvbHV0aW9uID09PSByZXNvbHV0aW9uID8gdGhpcyA6ICh0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uLCB0aGlzLnZhbGlkICYmICh0aGlzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogb2xkUmVzb2x1dGlvbikgLyByZXNvbHV0aW9uLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBvbGRSZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKSksIHRoaXMuX3JlZnJlc2hQT1QoKSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc291cmNlIGlmIGl0IHdhc24ndCBzZXQuIFRocm93cyBlcnJvciBpZiByZXNvdXJjZSBhbHJlYWR5IHByZXNlbnRcbiAgICogQHBhcmFtIHJlc291cmNlIC0gdGhhdCBpcyBtYW5hZ2luZyB0aGlzIEJhc2VUZXh0dXJlXG4gICAqIEByZXR1cm5zIC0gdGhpc1xuICAgKi9cbiAgc2V0UmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZXNvdXJjZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc291cmNlIGNhbiBiZSBzZXQgb25seSBvbmNlXCIpO1xuICAgIHJldHVybiByZXNvdXJjZS5iaW5kKHRoaXMpLCB0aGlzLnJlc291cmNlID0gcmVzb3VyY2UsIHRoaXM7XG4gIH1cbiAgLyoqIEludmFsaWRhdGVzIHRoZSBvYmplY3QuIFRleHR1cmUgYmVjb21lcyB2YWxpZCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVyby4gKi9cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMudmFsaWQgPyAodGhpcy5kaXJ0eUlkKyssIHRoaXMuZGlydHlTdHlsZUlkKyssIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKSkgOiB0aGlzLndpZHRoID4gMCAmJiB0aGlzLmhlaWdodCA+IDAgJiYgKHRoaXMudmFsaWQgPSAhMCwgdGhpcy5lbWl0KFwibG9hZGVkXCIsIHRoaXMpLCB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZXJyb3JzIHdpdGggcmVzb3VyY2VzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgLSBFcnJvciBldmVudCBlbWl0dGVkLlxuICAgKi9cbiAgb25FcnJvcihldmVudCkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHRoaXMsIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmUuXG4gICAqIFRoZSBtZXRob2Qgc3RvcHMgaWYgcmVzb3VyY2UgZG9lc24ndCB3YW50IHRoaXMgdGV4dHVyZSB0byBiZSBkZXN0cm95ZWQuXG4gICAqIFJlbW92ZXMgdGV4dHVyZSBmcm9tIGFsbCBjYWNoZXMuXG4gICAqIEBmaXJlcyBQSVhJLkJhc2VUZXh0dXJlI2Rlc3Ryb3llZFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc291cmNlICYmICh0aGlzLnJlc291cmNlLnVuYmluZCh0aGlzKSwgdGhpcy5yZXNvdXJjZS5pbnRlcm5hbCAmJiB0aGlzLnJlc291cmNlLmRlc3Ryb3koKSwgdGhpcy5yZXNvdXJjZSA9IG51bGwpLCB0aGlzLmNhY2hlSWQgJiYgKGRlbGV0ZSBCYXNlVGV4dHVyZUNhY2hlW3RoaXMuY2FjaGVJZF0sIGRlbGV0ZSBUZXh0dXJlQ2FjaGVbdGhpcy5jYWNoZUlkXSwgdGhpcy5jYWNoZUlkID0gbnVsbCksIHRoaXMudmFsaWQgPSAhMSwgdGhpcy5kaXNwb3NlKCksIF9CYXNlVGV4dHVyZTIucmVtb3ZlRnJvbUNhY2hlKHRoaXMpLCB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IG51bGwsIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMuZW1pdChcImRlc3Ryb3llZFwiLCB0aGlzKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogRnJlZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXG4gICAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXG4gICAqIG1lbW9yeSBhZ2Fpbi5cbiAgICogQGZpcmVzIFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkaXNwb3NlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBCYXNlVGV4dHVyZXxUZXh0dXJlIGNhc3QuICovXG4gIGNhc3RUb0Jhc2VUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gaW1hZ2UgdXJsLCBpbWFnZSBlbGVtZW50LCBjYW52YXMgZWxlbWVudC4gSWYgdGhlXG4gICAqIHNvdXJjZSBpcyBhbiBpbWFnZSB1cmwgb3IgYW4gaW1hZ2UgZWxlbWVudCBhbmQgbm90IGluIHRoZSBiYXNlIHRleHR1cmVcbiAgICogY2FjaGUsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc3xzdHJpbmd8c3RyaW5nW119IHNvdXJjZSAtIFRoZVxuICAgKiAgICAgICAgc291cmNlIHRvIGNyZWF0ZSBiYXNlIHRleHR1cmUgZnJvbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waXhpSWRQcmVmaXg9cGl4aWlkXSAtIElmIGEgc291cmNlIGhhcyBubyBpZCwgdGhpcyBpcyB0aGUgcHJlZml4IG9mIHRoZSBnZW5lcmF0ZWQgaWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0XSAtIEVuZm9yY2Ugc3RyaWN0LW1vZGUsIHNlZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRX0uXG4gICAqIEByZXR1cm5zIHtQSVhJLkJhc2VUZXh0dXJlfSBUaGUgbmV3IGJhc2UgdGV4dHVyZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucywgc3RyaWN0ID0gc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUpIHtcbiAgICBjb25zdCBpc0ZyYW1lID0gdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiO1xuICAgIGxldCBjYWNoZUlkID0gbnVsbDtcbiAgICBpZiAoaXNGcmFtZSlcbiAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXNvdXJjZS5fcGl4aUlkKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnM/LnBpeGlJZFByZWZpeCB8fCBcInBpeGlpZFwiO1xuICAgICAgICBzb3VyY2UuX3BpeGlJZCA9IGAke3ByZWZpeH1fJHt1aWQoKX1gO1xuICAgICAgfVxuICAgICAgY2FjaGVJZCA9IHNvdXJjZS5fcGl4aUlkO1xuICAgIH1cbiAgICBsZXQgYmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgIGlmIChpc0ZyYW1lICYmIHN0cmljdCAmJiAhYmFzZVRleHR1cmUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYWNoZUlkIFwiJHtjYWNoZUlkfVwiIGRvZXMgbm90IGV4aXN0IGluIEJhc2VUZXh0dXJlQ2FjaGUuYCk7XG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlIHx8IChiYXNlVGV4dHVyZSA9IG5ldyBfQmFzZVRleHR1cmUyKHNvdXJjZSwgb3B0aW9ucyksIGJhc2VUZXh0dXJlLmNhY2hlSWQgPSBjYWNoZUlkLCBfQmFzZVRleHR1cmUyLmFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGNhY2hlSWQpKSwgYmFzZVRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBUZXh0dXJlIHdpdGggYSBCdWZmZXJSZXNvdXJjZSBmcm9tIGEgdHlwZWQgYXJyYXkuXG4gICAqIEBwYXJhbSBidWZmZXIgLSBUaGUgb3B0aW9uYWwgYXJyYXkgdG8gdXNlLiBJZiBubyBkYXRhIGlzIHByb3ZpZGVkLCBhIG5ldyBGbG9hdDMyQXJyYXkgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlc291cmNlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxuICAgKiAgICAgICAgRGVmYXVsdCBwcm9wZXJ0aWVzIGFyZSBkaWZmZXJlbnQgZnJvbSB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtQSVhJLkZPUk1BVFN9IFtvcHRpb25zLmZvcm1hdF0gLSBUaGUgZm9ybWF0IGlzIG5vdCBnaXZlbiwgdGhlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICogICAgICAgIHR5cGUgb2YgdGhlIGJ1ZmZlcjogYFJHQkFgIGlmIEZsb2F0MzJBcnJheSwgSW50OEFycmF5LCBVaW50OEFycmF5LCBvciBVaW50OENsYW1wZWRBcnJheSxcbiAgICogICAgICAgIG90aGVyd2lzZSBgUkdCQV9JTlRFR0VSYC5cbiAgICogQHBhcmFtIHtQSVhJLlRZUEVTfSBbb3B0aW9ucy50eXBlXSAtIFRoZSB0eXBlIGlzIG5vdCBnaXZlbiwgdGhlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICogICAgICAgIHR5cGUgb2YgdGhlIGJ1ZmZlci4gTWFwcyBGbG9hdDMyQXJyYXkgdG8gYEZMT0FUYCwgSW50MzJBcnJheSB0byBgSU5UYCwgVWludDMyQXJyYXkgdG9cbiAgICogICAgICAgIGBVTlNJR05FRF9JTlRgLCBJbnQxNkFycmF5IHRvIGBTSE9SVGAsIFVpbnQxNkFycmF5IHRvIGBVTlNJR05FRF9TSE9SVGAsIEludDhBcnJheSB0byBgQllURWAsXG4gICAqICAgICAgICBVaW50OEFycmF5L1VpbnQ4Q2xhbXBlZEFycmF5IHRvIGBVTlNJR05FRF9CWVRFYC5cbiAgICogQHBhcmFtIHtQSVhJLkFMUEhBX01PREVTfSBbb3B0aW9ucy5hbHBoYU1vZGU9UElYSS5BTFBIQV9NT0RFUy5OUE1dXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW29wdGlvbnMuc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuTkVBUkVTVF1cbiAgICogQHJldHVybnMgLSBUaGUgcmVzdWx0aW5nIG5ldyBCYXNlVGV4dHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBCdWZmZXJSZXNvdXJjZShidWZmZXIsIHsgd2lkdGgsIGhlaWdodCwgLi4ub3B0aW9ucz8ucmVzb3VyY2VPcHRpb25zIH0pO1xuICAgIGxldCBmb3JtYXQsIHR5cGU7XG4gICAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IChmb3JtYXQgPSBGT1JNQVRTLlJHQkEsIHR5cGUgPSBUWVBFUy5GTE9BVCkgOiBidWZmZXIgaW5zdGFuY2VvZiBJbnQzMkFycmF5ID8gKGZvcm1hdCA9IEZPUk1BVFMuUkdCQV9JTlRFR0VSLCB0eXBlID0gVFlQRVMuSU5UKSA6IGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ID8gKGZvcm1hdCA9IEZPUk1BVFMuUkdCQV9JTlRFR0VSLCB0eXBlID0gVFlQRVMuVU5TSUdORURfSU5UKSA6IGJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkgPyAoZm9ybWF0ID0gRk9STUFUUy5SR0JBX0lOVEVHRVIsIHR5cGUgPSBUWVBFUy5TSE9SVCkgOiBidWZmZXIgaW5zdGFuY2VvZiBVaW50MTZBcnJheSA/IChmb3JtYXQgPSBGT1JNQVRTLlJHQkFfSU5URUdFUiwgdHlwZSA9IFRZUEVTLlVOU0lHTkVEX1NIT1JUKSA6IGJ1ZmZlciBpbnN0YW5jZW9mIEludDhBcnJheSA/IChmb3JtYXQgPSBGT1JNQVRTLlJHQkEsIHR5cGUgPSBUWVBFUy5CWVRFKSA6IChmb3JtYXQgPSBGT1JNQVRTLlJHQkEsIHR5cGUgPSBUWVBFUy5VTlNJR05FRF9CWVRFKSwgcmVzb3VyY2UuaW50ZXJuYWwgPSAhMCwgbmV3IF9CYXNlVGV4dHVyZTIocmVzb3VyY2UsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRCdWZmZXJPcHRpb25zLCB7IHR5cGUsIGZvcm1hdCB9LCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBCYXNlVGV4dHVyZSB0byB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyB0aGUgd2hvbGUgUElYSSBvYmplY3QuXG4gICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgQmFzZVRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRoYXQgdGhlIEJhc2VUZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGFnYWluc3QuXG4gICAqL1xuICBzdGF0aWMgYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgaWQpIHtcbiAgICBpZCAmJiAoYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluY2x1ZGVzKGlkKSB8fCBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMucHVzaChpZCksIEJhc2VUZXh0dXJlQ2FjaGVbaWRdICYmIEJhc2VUZXh0dXJlQ2FjaGVbaWRdICE9PSBiYXNlVGV4dHVyZSAmJiBjb25zb2xlLndhcm4oYEJhc2VUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFske2lkfV0gdGhhdCBhbHJlYWR5IGhhZCBhbiBlbnRyeWApLCBCYXNlVGV4dHVyZUNhY2hlW2lkXSA9IGJhc2VUZXh0dXJlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgQmFzZVRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFBJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gaWQgb2YgYSBCYXNlVGV4dHVyZSB0byBiZSByZW1vdmVkLCBvciBhIEJhc2VUZXh0dXJlIGluc3RhbmNlIGl0c2VsZi5cbiAgICogQHJldHVybnMge1BJWEkuQmFzZVRleHR1cmV8bnVsbH0gVGhlIEJhc2VUZXh0dXJlIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlRnJvbUNhY2hlKGJhc2VUZXh0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiBiYXNlVGV4dHVyZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBiYXNlVGV4dHVyZUZyb21DYWNoZSA9IEJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xuICAgICAgaWYgKGJhc2VUZXh0dXJlRnJvbUNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoYmFzZVRleHR1cmUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSAmJiBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKSwgZGVsZXRlIEJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdLCBiYXNlVGV4dHVyZUZyb21DYWNoZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJhc2VUZXh0dXJlPy50ZXh0dXJlQ2FjaGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aDsgKytpKVxuICAgICAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dO1xuICAgICAgcmV0dXJuIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwLCBiYXNlVGV4dHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5fQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBJZiBtaXBtYXBwaW5nIGlzIGVuYWJsZWQgZm9yIHRleHR1cmUuXG4gICAqIEB0eXBlIHtQSVhJLk1JUE1BUF9NT0RFU31cbiAgICogQGRlZmF1bHQgUElYSS5NSVBNQVBfTU9ERVMuUE9XMlxuICAgKi9cbiAgbWlwbWFwOiBNSVBNQVBfTU9ERVMuUE9XMixcbiAgLyoqIEFuaXNvdHJvcGljIGZpbHRlcmluZyBsZXZlbCBvZiB0ZXh0dXJlICovXG4gIGFuaXNvdHJvcGljTGV2ZWw6IDAsXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNjYWxlIG1vZGUsIGxpbmVhciwgbmVhcmVzdC5cbiAgICogQHR5cGUge1BJWEkuU0NBTEVfTU9ERVN9XG4gICAqIEBkZWZhdWx0IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSXG4gICAqL1xuICBzY2FsZU1vZGU6IFNDQUxFX01PREVTLkxJTkVBUixcbiAgLyoqXG4gICAqIFdyYXAgbW9kZSBmb3IgdGV4dHVyZXMuXG4gICAqIEB0eXBlIHtQSVhJLldSQVBfTU9ERVN9XG4gICAqIEBkZWZhdWx0IFBJWEkuV1JBUF9NT0RFUy5DTEFNUFxuICAgKi9cbiAgd3JhcE1vZGU6IFdSQVBfTU9ERVMuQ0xBTVAsXG4gIC8qKlxuICAgKiBQcmUgbXVsdGlwbHkgdGhlIGltYWdlIGFscGhhXG4gICAqIEB0eXBlIHtQSVhJLkFMUEhBX01PREVTfVxuICAgKiBAZGVmYXVsdCBQSVhJLkFMUEhBX01PREVTLlVOUEFDS1xuICAgKi9cbiAgYWxwaGFNb2RlOiBBTFBIQV9NT0RFUy5VTlBBQ0ssXG4gIC8qKlxuICAgKiBHTCB0ZXh0dXJlIHRhcmdldFxuICAgKiBAdHlwZSB7UElYSS5UQVJHRVRTfVxuICAgKiBAZGVmYXVsdCBQSVhJLlRBUkdFVFMuVEVYVFVSRV8yRFxuICAgKi9cbiAgdGFyZ2V0OiBUQVJHRVRTLlRFWFRVUkVfMkQsXG4gIC8qKlxuICAgKiBHTCBmb3JtYXQgdHlwZVxuICAgKiBAdHlwZSB7UElYSS5GT1JNQVRTfVxuICAgKiBAZGVmYXVsdCBQSVhJLkZPUk1BVFMuUkdCQVxuICAgKi9cbiAgZm9ybWF0OiBGT1JNQVRTLlJHQkEsXG4gIC8qKlxuICAgKiBHTCBkYXRhIHR5cGVcbiAgICogQHR5cGUge1BJWEkuVFlQRVN9XG4gICAqIEBkZWZhdWx0IFBJWEkuVFlQRVMuVU5TSUdORURfQllURVxuICAgKi9cbiAgdHlwZTogVFlQRVMuVU5TSUdORURfQllURVxufSwgLyoqIEdsb2JhbCBudW1iZXIgb2YgdGhlIHRleHR1cmUgYmF0Y2gsIHVzZWQgYnkgbXVsdGktdGV4dHVyZSByZW5kZXJlcnMuICovXG5fQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gMDtcbmxldCBCYXNlVGV4dHVyZSA9IF9CYXNlVGV4dHVyZTtcbmV4cG9ydCB7XG4gIEJhc2VUZXh0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRFJBV19NT0RFUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmNsYXNzIEJhdGNoRHJhd0NhbGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRleEFycmF5ID0gbnVsbCwgdGhpcy5ibGVuZCA9IDAsIHRoaXMudHlwZSA9IERSQVdfTU9ERVMuVFJJQU5HTEVTLCB0aGlzLnN0YXJ0ID0gMCwgdGhpcy5zaXplID0gMCwgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQmF0Y2hEcmF3Q2FsbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoRHJhd0NhbGwubWpzLm1hcFxuIiwiaW1wb3J0IHsgQlVGRkVSX1RZUEUgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBSdW5uZXIgfSBmcm9tIFwiQHBpeGkvcnVubmVyXCI7XG5sZXQgVUlEID0gMDtcbmNsYXNzIEJ1ZmZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuSUFycmF5QnVmZmVyfSBkYXRhIC0gdGhlIGRhdGEgdG8gc3RvcmUgaW4gdGhlIGJ1ZmZlci5cbiAgICogQHBhcmFtIF9zdGF0aWMgLSBgdHJ1ZWAgZm9yIHN0YXRpYyBidWZmZXJcbiAgICogQHBhcmFtIGluZGV4IC0gYHRydWVgIGZvciBpbmRleCBidWZmZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIF9zdGF0aWMgPSAhMCwgaW5kZXggPSAhMSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbmV3IEZsb2F0MzJBcnJheSgxKSwgdGhpcy5fZ2xCdWZmZXJzID0ge30sIHRoaXMuX3VwZGF0ZUlEID0gMCwgdGhpcy5pbmRleCA9IGluZGV4LCB0aGlzLnN0YXRpYyA9IF9zdGF0aWMsIHRoaXMuaWQgPSBVSUQrKywgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcihcImRpc3Bvc2VCdWZmZXJcIik7XG4gIH1cbiAgLy8gVE9ETyBjb3VsZCBleHBsb3JlIGZsYWdnaW5nIG9ubHkgYSBwYXJ0aWFsIHVwbG9hZD9cbiAgLyoqXG4gICAqIEZsYWdzIHRoaXMgYnVmZmVyIGFzIHJlcXVpcmluZyBhbiB1cGxvYWQgdG8gdGhlIEdQVS5cbiAgICogQHBhcmFtIHtQSVhJLklBcnJheUJ1ZmZlcnxudW1iZXJbXX0gW2RhdGFdIC0gdGhlIGRhdGEgdG8gdXBkYXRlIGluIHRoZSBidWZmZXIuXG4gICAqL1xuICB1cGRhdGUoZGF0YSkge1xuICAgIGRhdGEgaW5zdGFuY2VvZiBBcnJheSAmJiAoZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSkpLCB0aGlzLmRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YSwgdGhpcy5fdXBkYXRlSUQrKztcbiAgfVxuICAvKiogRGlzcG9zZXMgV2ViR0wgcmVzb3VyY2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGlzIGdlb21ldHJ5LiAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5lbWl0KHRoaXMsICExKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIGJ1ZmZlci4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKSwgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogRmxhZ3Mgd2hldGhlciB0aGlzIGlzIGFuIGluZGV4IGJ1ZmZlci5cbiAgICpcbiAgICogSW5kZXggYnVmZmVycyBhcmUgb2YgdHlwZSBgRUxFTUVOVF9BUlJBWV9CVUZGRVJgLiBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIHdpbGwgbWFrZVxuICAgKiB0aGUgYnVmZmVyIG9mIHR5cGUgYEFSUkFZX0JVRkZFUmAuXG4gICAqXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIHNldCBpbmRleCh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlID8gQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBCVUZGRVJfVFlQRS5BUlJBWV9CVUZGRVI7XG4gIH1cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGJhc2VkIG9uIGFuIGFycmF5IG9yIFR5cGVkQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXcgfCBudW1iZXJbXX0gZGF0YSAtIHRoZSBUeXBlZEFycmF5IHRoYXQgdGhlIGJ1ZmZlciB3aWxsIHN0b3JlLiBJZiB0aGlzIGlzIGEgcmVndWxhciBBcnJheSBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIEZsb2F0MzJBcnJheS5cbiAgICogQHJldHVybnMgLSBBIG5ldyBCdWZmZXIgYmFzZWQgb24gdGhlIGRhdGEgcHJvdmlkZWQuXG4gICAqL1xuICBzdGF0aWMgZnJvbShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheSAmJiAoZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSkpLCBuZXcgQnVmZmVyKGRhdGEpO1xuICB9XG59XG5leHBvcnQge1xuICBCdWZmZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgVFlQRVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5jbGFzcyBBdHRyaWJ1dGUge1xuICAvKipcbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBpZCBvZiB0aGUgYnVmZmVyIHRoYXQgdGhpcyBhdHRyaWJ1dGUgd2lsbCBsb29rIGZvclxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUuIElmIHlvdSBoYXZlIDIgZmxvYXRzIHBlciB2ZXJ0ZXggKGVnIHBvc2l0aW9uIHggYW5kIHkpIHRoaXMgd291bGQgYmUgMi5cbiAgICogQHBhcmFtIG5vcm1hbGl6ZWQgLSBzaG91bGQgdGhlIGRhdGEgYmUgbm9ybWFsaXplZC5cbiAgICogQHBhcmFtIHtQSVhJLlRZUEVTfSBbdHlwZT1QSVhJLlRZUEVTLkZMT0FUXSAtIHdoYXQgdHlwZSBvZiBudW1iZXIgaXMgdGhlIGF0dHJpYnV0ZS4gQ2hlY2sge0BsaW5rIFBJWEkuVFlQRVN9IHRvIHNlZSB0aGUgb25lcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIFtzdHJpZGU9MF0gLSBIb3cgZmFyIGFwYXJ0LCBpbiBieXRlcywgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcbiAgICogQHBhcmFtIFtzdGFydD0wXSAtIEhvdyBmYXIgaW50byB0aGUgYXJyYXkgdG8gc3RhcnQgcmVhZGluZyB2YWx1ZXMgKHVzZWQgZm9yIGludGVybGVhdmluZyBkYXRhKVxuICAgKiBAcGFyYW0gW2luc3RhbmNlPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGdlb21ldHJ5IGlzIGluc3RhbmNlZC5cbiAgICogQHBhcmFtIFtkaXZpc29yPTFdIC0gRGl2aXNvciB0byB1c2Ugd2hlbiBkb2luZyBpbnN0YW5jZWQgcmVuZGVyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvcihidWZmZXIsIHNpemUgPSAwLCBub3JtYWxpemVkID0gITEsIHR5cGUgPSBUWVBFUy5GTE9BVCwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UsIGRpdmlzb3IgPSAxKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIsIHRoaXMuc2l6ZSA9IHNpemUsIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQsIHRoaXMudHlwZSA9IHR5cGUsIHRoaXMuc3RyaWRlID0gc3RyaWRlLCB0aGlzLnN0YXJ0ID0gc3RhcnQsIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZSwgdGhpcy5kaXZpc29yID0gZGl2aXNvcjtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEF0dHJpYnV0ZS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gQXR0cmlidXRlIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZFxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIGlkIG9mIHRoZSBidWZmZXIgdGhhdCB0aGlzIGF0dHJpYnV0ZSB3aWxsIGxvb2sgZm9yXG4gICAqIEBwYXJhbSBbc2l6ZT0wXSAtIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUuIElmIHlvdSBoYXZlIDIgZmxvYXRzIHBlciB2ZXJ0ZXggKGVnIHBvc2l0aW9uIHggYW5kIHkpIHRoaXMgd291bGQgYmUgMlxuICAgKiBAcGFyYW0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gc2hvdWxkIHRoZSBkYXRhIGJlIG5vcm1hbGl6ZWQuXG4gICAqIEBwYXJhbSBbdHlwZT1QSVhJLlRZUEVTLkZMT0FUXSAtIHdoYXQgdHlwZSBvZiBudW1iZXIgaXMgdGhlIGF0dHJpYnV0ZS4gQ2hlY2sge0BsaW5rIFBJWEkuVFlQRVN9IHRvIHNlZSB0aGUgb25lcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIFtzdHJpZGU9MF0gLSBIb3cgZmFyIGFwYXJ0LCBpbiBieXRlcywgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcbiAgICogQHJldHVybnMgLSBBIG5ldyB7QGxpbmsgUElYSS5BdHRyaWJ1dGV9IGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZFxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlLCBzdHJpZGUpIHtcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEF0dHJpYnV0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZS5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSBcIkBwaXhpL3V0aWxzXCI7XG5jb25zdCBtYXAgPSB7XG4gIEZsb2F0MzJBcnJheSxcbiAgVWludDMyQXJyYXksXG4gIEludDMyQXJyYXksXG4gIFVpbnQ4QXJyYXlcbn07XG5mdW5jdGlvbiBpbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcykge1xuICBsZXQgb3V0U2l6ZSA9IDAsIHN0cmlkZSA9IDA7XG4gIGNvbnN0IHZpZXdzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKVxuICAgIHN0cmlkZSArPSBzaXplc1tpXSwgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3V0U2l6ZSAqIDQpO1xuICBsZXQgb3V0ID0gbnVsbCwgbGl0dGxlT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaXplID0gc2l6ZXNbaV0sIGFycmF5ID0gYXJyYXlzW2ldLCB0eXBlID0gZ2V0QnVmZmVyVHlwZShhcnJheSk7XG4gICAgdmlld3NbdHlwZV0gfHwgKHZpZXdzW3R5cGVdID0gbmV3IG1hcFt0eXBlXShidWZmZXIpKSwgb3V0ID0gdmlld3NbdHlwZV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgaW5kZXhTdGFydCA9IChqIC8gc2l6ZSB8IDApICogc3RyaWRlICsgbGl0dGxlT2Zmc2V0LCBpbmRleCA9IGogJSBzaXplO1xuICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcbiAgICB9XG4gICAgbGl0dGxlT2Zmc2V0ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbn1cbmV4cG9ydCB7XG4gIGludGVybGVhdmVUeXBlZEFycmF5c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybGVhdmVUeXBlZEFycmF5cy5tanMubWFwXG4iLCJpbXBvcnQgeyBCVUZGRVJfVFlQRSB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJAcGl4aS9ydW5uZXJcIjtcbmltcG9ydCB7IGdldEJ1ZmZlclR5cGUgfSBmcm9tIFwiQHBpeGkvdXRpbHNcIjtcbmltcG9ydCB7IEF0dHJpYnV0ZSB9IGZyb20gXCIuL0F0dHJpYnV0ZS5tanNcIjtcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gXCIuL0J1ZmZlci5tanNcIjtcbmltcG9ydCB7IGludGVybGVhdmVUeXBlZEFycmF5cyB9IGZyb20gXCIuL3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5tanNcIjtcbmNvbnN0IGJ5dGVTaXplTWFwID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XG5sZXQgVUlEID0gMDtcbmNvbnN0IG1hcCA9IHtcbiAgRmxvYXQzMkFycmF5LFxuICBVaW50MzJBcnJheSxcbiAgSW50MzJBcnJheSxcbiAgVWludDhBcnJheSxcbiAgVWludDE2QXJyYXlcbn07XG5jbGFzcyBHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYnVmZmVycyAtIEFuIGFycmF5IG9mIGJ1ZmZlcnMuIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9mIHRoZSBnZW9tZXRyeSwgb3B0aW9uYWwgc3RydWN0dXJlIG9mIHRoZSBhdHRyaWJ1dGVzIGxheW91dFxuICAgKi9cbiAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzLCB0aGlzLmluZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcywgdGhpcy5nbFZlcnRleEFycmF5T2JqZWN0cyA9IHt9LCB0aGlzLmlkID0gVUlEKyssIHRoaXMuaW5zdGFuY2VkID0gITEsIHRoaXMuaW5zdGFuY2VDb3VudCA9IDEsIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoXCJkaXNwb3NlR2VvbWV0cnlcIiksIHRoaXMucmVmQ291bnQgPSAwO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBBZGRzIGFuIGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnlcbiAgICogTm90ZTogYHN0cmlkZWAgYW5kIGBzdGFydGAgc2hvdWxkIGJlIGB1bmRlZmluZWRgIGlmIHlvdSBkb250IGtub3cgdGhlbSwgbm90IDAhXG4gICAqIEBwYXJhbSBpZCAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgKG1hdGNoaW5nIHVwIHRvIGEgc2hhZGVyKVxuICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfG51bWJlcltdfSBidWZmZXIgLSB0aGUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIGRhdGEgb2YgdGhlIGF0dHJpYnV0ZSAuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIEFycmF5IGFuZCBhIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBpdC5cbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB5b3UgaGF2ZSAyIGZsb2F0cyBwZXIgdmVydGV4IChlZyBwb3NpdGlvbiB4IGFuZCB5KSB0aGlzIHdvdWxkIGJlIDJcbiAgICogQHBhcmFtIG5vcm1hbGl6ZWQgLSBzaG91bGQgdGhlIGRhdGEgYmUgbm9ybWFsaXplZC5cbiAgICogQHBhcmFtIFt0eXBlPVBJWEkuVFlQRVMuRkxPQVRdIC0gd2hhdCB0eXBlIG9mIG51bWJlciBpcyB0aGUgYXR0cmlidXRlLiBDaGVjayB7QGxpbmsgUElYSS5UWVBFU30gdG8gc2VlIHRoZSBvbmVzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gW3N0cmlkZT0wXSAtIEhvdyBmYXIgYXBhcnQsIGluIGJ5dGVzLCB0aGUgc3RhcnQgb2YgZWFjaCB2YWx1ZSBpcy4gKHVzZWQgZm9yIGludGVybGVhdmluZyBkYXRhKVxuICAgKiBAcGFyYW0gW3N0YXJ0PTBdIC0gSG93IGZhciBpbnRvIHRoZSBhcnJheSB0byBzdGFydCByZWFkaW5nIHZhbHVlcyAodXNlZCBmb3IgaW50ZXJsZWF2aW5nIGRhdGEpXG4gICAqIEBwYXJhbSBpbnN0YW5jZSAtIEluc3RhbmNpbmcgZmxhZ1xuICAgKiBAcmV0dXJucyAtIFJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZEF0dHJpYnV0ZShpZCwgYnVmZmVyLCBzaXplID0gMCwgbm9ybWFsaXplZCA9ICExLCB0eXBlLCBzdHJpZGUsIHN0YXJ0LCBpbnN0YW5jZSA9ICExKSB7XG4gICAgaWYgKCFidWZmZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgYnVmZmVyIHdoZW4gY3JlYXRpbmcgYW4gYXR0cmlidXRlXCIpO1xuICAgIGJ1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlciB8fCAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkgJiYgKGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSksIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKSk7XG4gICAgY29uc3QgaWRzID0gaWQuc3BsaXQoXCJ8XCIpO1xuICAgIGlmIChpZHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKGlkc1tpXSwgYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXQgYnVmZmVySW5kZXggPSB0aGlzLmJ1ZmZlcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXJJbmRleCA9PT0gLTEgJiYgKHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlciksIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmxlbmd0aCAtIDEpLCB0aGlzLmF0dHJpYnV0ZXNbaWRdID0gbmV3IEF0dHJpYnV0ZShidWZmZXJJbmRleCwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UpLCB0aGlzLmluc3RhbmNlZCA9IHRoaXMuaW5zdGFuY2VkIHx8IGluc3RhbmNlLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXF1ZXN0ZWQgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHJlcXVpcmVkXG4gICAqIEByZXR1cm5zIC0gVGhlIGF0dHJpYnV0ZSByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2lkXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVxdWVzdGVkIGJ1ZmZlci5cbiAgICogQHBhcmFtIGlkIC0gVGhlIG5hbWUgb2YgdGhlIGJ1ZmZlciByZXF1aXJlZC5cbiAgICogQHJldHVybnMgLSBUaGUgYnVmZmVyIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldEJ1ZmZlcihpZCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbdGhpcy5nZXRBdHRyaWJ1dGUoaWQpLmJ1ZmZlcl07XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEFkZHMgYW4gaW5kZXggYnVmZmVyIHRvIHRoZSBnZW9tZXRyeVxuICAgKiBUaGUgaW5kZXggYnVmZmVyIGNvbnRhaW5zIGludGVnZXJzLCB0aHJlZSBmb3IgZWFjaCB0cmlhbmdsZSBpbiB0aGUgZ2VvbWV0cnksIHdoaWNoIHJlZmVyZW5jZSB0aGUgdmFyaW91cyBhdHRyaWJ1dGUgYnVmZmVycyAocG9zaXRpb24sIGNvbG91ciwgVVYgY29vcmRpbmF0ZXMsIG90aGVyIFVWIGNvb3JkaW5hdGVzLCBub3JtYWwsIOKApikuIFRoZXJlIGlzIG9ubHkgT05FIGluZGV4IGJ1ZmZlci5cbiAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcnxudW1iZXJbXX0gW2J1ZmZlcl0gLSBUaGUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIGRhdGEgb2YgdGhlIGluZGV4IGJ1ZmZlci4gWW91IGNhbiBhbHNvIHByb3ZpZGUgYW4gQXJyYXkgYW5kIGEgYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBmcm9tIGl0LlxuICAgKiBAcmV0dXJucyAtIFJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZEluZGV4KGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5ICYmIChidWZmZXIgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKSksIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKSksIGJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIgPSBidWZmZXIsIHRoaXMuYnVmZmVycy5pbmNsdWRlcyhidWZmZXIpIHx8IHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlciksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IGJ1ZmZlclxuICAgKiBAcmV0dXJucyAtIFRoZSBpbmRleCBidWZmZXIuXG4gICAqL1xuICBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGUgc3RydWN0dXJlIHNvIHRoYXQgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBiZWNvbWUgaW50ZXJsZWF2ZWQgaW50byBhIHNpbmdsZSBidWZmZXJcbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdXIgbW9kZWwgcmVtYWlucyBzdGF0aWMgYXMgaXQgb2ZmZXJzIGEgbGl0dGxlIHBlcmZvcm1hbmNlIGJvb3N0XG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBzZWxmLCB1c2VmdWwgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaW50ZXJsZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMSB8fCB0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAyICYmIHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBhcnJheXMgPSBbXSwgc2l6ZXMgPSBbXSwgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgQnVmZmVyKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldLCBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbYXR0cmlidXRlLmJ1ZmZlcl07XG4gICAgICBhcnJheXMucHVzaChidWZmZXIuZGF0YSksIHNpemVzLnB1c2goYXR0cmlidXRlLnNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV0gLyA0KSwgYXR0cmlidXRlLmJ1ZmZlciA9IDA7XG4gICAgfVxuICAgIGZvciAoaW50ZXJsZWF2ZWRCdWZmZXIuZGF0YSA9IGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSwgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlcnNbaV0gIT09IHRoaXMuaW5kZXhCdWZmZXIgJiYgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzID0gW2ludGVybGVhdmVkQnVmZmVyXSwgdGhpcy5pbmRleEJ1ZmZlciAmJiB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKSwgdGhpcztcbiAgfVxuICAvKiogR2V0IHRoZSBzaXplIG9mIHRoZSBnZW9tZXRyaWVzLCBpbiB2ZXJ0aWNlcy4gKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICByZXR1cm4gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqIERpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeS4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCAhMSk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBnZW9tZXRyeS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKSwgdGhpcy5idWZmZXJzID0gbnVsbCwgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm5zIC0gQSBuZXcgY2xvbmUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICBnZW9tZXRyeS5idWZmZXJzW2ldID0gbmV3IEJ1ZmZlcih0aGlzLmJ1ZmZlcnNbaV0uZGF0YS5zbGljZSgwKSk7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlc1tpXSA9IG5ldyBBdHRyaWJ1dGUoXG4gICAgICAgIGF0dHJpYi5idWZmZXIsXG4gICAgICAgIGF0dHJpYi5zaXplLFxuICAgICAgICBhdHRyaWIubm9ybWFsaXplZCxcbiAgICAgICAgYXR0cmliLnR5cGUsXG4gICAgICAgIGF0dHJpYi5zdHJpZGUsXG4gICAgICAgIGF0dHJpYi5zdGFydCxcbiAgICAgICAgYXR0cmliLmluc3RhbmNlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlciAmJiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeS5idWZmZXJzW3RoaXMuYnVmZmVycy5pbmRleE9mKHRoaXMuaW5kZXhCdWZmZXIpXSwgZ2VvbWV0cnkuaW5kZXhCdWZmZXIudHlwZSA9IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSKSwgZ2VvbWV0cnk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlcyBhbiBhcnJheSBvZiBnZW9tZXRyaWVzIGludG8gYSBuZXcgc2luZ2xlIG9uZS5cbiAgICpcbiAgICogR2VvbWV0cnkgYXR0cmlidXRlIHN0eWxlcyBtdXN0IG1hdGNoIGZvciB0aGlzIG9wZXJhdGlvbiB0byB3b3JrLlxuICAgKiBAcGFyYW0gZ2VvbWV0cmllcyAtIGFycmF5IG9mIGdlb21ldHJpZXMgdG8gbWVyZ2VcbiAgICogQHJldHVybnMgLSBTaGlueSBuZXcgZ2VvbWV0cnkhXG4gICAqL1xuICBzdGF0aWMgbWVyZ2UoZ2VvbWV0cmllcykge1xuICAgIGNvbnN0IGdlb21ldHJ5T3V0ID0gbmV3IEdlb21ldHJ5KCksIGFycmF5cyA9IFtdLCBzaXplcyA9IFtdLCBvZmZzZXRzID0gW107XG4gICAgbGV0IGdlb21ldHJ5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaisrKVxuICAgICAgICBzaXplc1tqXSA9IHNpemVzW2pdIHx8IDAsIHNpemVzW2pdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YS5sZW5ndGgsIG9mZnNldHNbal0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICBhcnJheXNbaV0gPSBuZXcgbWFwW2dldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpXS5kYXRhKV0oc2l6ZXNbaV0pLCBnZW9tZXRyeU91dC5idWZmZXJzW2ldID0gbmV3IEJ1ZmZlcihhcnJheXNbaV0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaisrKVxuICAgICAgICBhcnJheXNbal0uc2V0KGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YSwgb2Zmc2V0c1tqXSksIG9mZnNldHNbal0gKz0gZ2VvbWV0cnkuYnVmZmVyc1tqXS5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5T3V0LmF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLCBnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeU91dC5idWZmZXJzW2dlb21ldHJ5LmJ1ZmZlcnMuaW5kZXhPZihnZW9tZXRyeS5pbmRleEJ1ZmZlcildLCBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgICBsZXQgb2Zmc2V0ID0gMCwgc3RyaWRlID0gMCwgb2Zmc2V0MiA9IDAsIGJ1ZmZlckluZGV4VG9Db3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChnZW9tZXRyeS5idWZmZXJzW2ldICE9PSBnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlckluZGV4VG9Db3VudCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIChhdHRyaWJ1dGUuYnVmZmVyIHwgMCkgPT09IGJ1ZmZlckluZGV4VG9Db3VudCAmJiAoc3RyaWRlICs9IGF0dHJpYnV0ZS5zaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdIC8gNCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXJEYXRhID0gZ2VvbWV0cmllc1tpXS5pbmRleEJ1ZmZlci5kYXRhO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7IGorKylcbiAgICAgICAgICBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlci5kYXRhW2ogKyBvZmZzZXQyXSArPSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCArPSBnZW9tZXRyaWVzW2ldLmJ1ZmZlcnNbYnVmZmVySW5kZXhUb0NvdW50XS5kYXRhLmxlbmd0aCAvIHN0cmlkZSwgb2Zmc2V0MiArPSBpbmRleEJ1ZmZlckRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnlPdXQ7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEdlb21ldHJ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgVFlQRVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiLi4vZ2VvbWV0cnkvQnVmZmVyLm1qc1wiO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tIFwiLi4vZ2VvbWV0cnkvR2VvbWV0cnkubWpzXCI7XG5jbGFzcyBCYXRjaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBbX3N0YXRpYz1mYWxzZV0gLSBPcHRpbWl6YXRpb24gZmxhZywgd2hlcmUgYGZhbHNlYFxuICAgKiAgICAgICAgaXMgdXBkYXRlZCBldmVyeSBmcmFtZSwgYHRydWVgIGRvZXNuJ3QgY2hhbmdlIGZyYW1lLXRvLWZyYW1lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoX3N0YXRpYyA9ICExKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcihudWxsLCBfc3RhdGljLCAhMSksIHRoaXMuX2luZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihudWxsLCBfc3RhdGljLCAhMCksIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIHRoaXMuX2J1ZmZlciwgMiwgITEsIFRZUEVTLkZMT0FUKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUNvb3JkXCIsIHRoaXMuX2J1ZmZlciwgMiwgITEsIFRZUEVTLkZMT0FUKS5hZGRBdHRyaWJ1dGUoXCJhQ29sb3JcIiwgdGhpcy5fYnVmZmVyLCA0LCAhMCwgVFlQRVMuVU5TSUdORURfQllURSkuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVJZFwiLCB0aGlzLl9idWZmZXIsIDEsICEwLCBUWVBFUy5GTE9BVCkuYWRkSW5kZXgodGhpcy5faW5kZXhCdWZmZXIpO1xuICB9XG59XG5leHBvcnQge1xuICBCYXRjaEdlb21ldHJ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5tanMubWFwXG4iLCJjb25zdCBQSV8yID0gTWF0aC5QSSAqIDIsIFJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJLCBERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcbnZhciBTSEFQRVMgPSAvKiBAX19QVVJFX18gKi8gKChTSEFQRVMyKSA9PiAoU0hBUEVTMltTSEFQRVMyLlBPTFkgPSAwXSA9IFwiUE9MWVwiLCBTSEFQRVMyW1NIQVBFUzIuUkVDVCA9IDFdID0gXCJSRUNUXCIsIFNIQVBFUzJbU0hBUEVTMi5DSVJDID0gMl0gPSBcIkNJUkNcIiwgU0hBUEVTMltTSEFQRVMyLkVMSVAgPSAzXSA9IFwiRUxJUFwiLCBTSEFQRVMyW1NIQVBFUzIuUlJFQyA9IDRdID0gXCJSUkVDXCIsIFNIQVBFUzIpKShTSEFQRVMgfHwge30pO1xuZXhwb3J0IHtcbiAgREVHX1RPX1JBRCxcbiAgUElfMixcbiAgUkFEX1RPX0RFRyxcbiAgU0hBUEVTXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIiwiY2xhc3MgUG9pbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgUG9pbnRgXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLnggPSAwLCB0aGlzLnkgPSAwLCB0aGlzLnggPSB4LCB0aGlzLnkgPSB5O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludFxuICAgKiBAcmV0dXJucyBBIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYHhgIGFuZCBgeWAgZnJvbSB0aGUgZ2l2ZW4gcG9pbnQgaW50byB0aGlzIHBvaW50XG4gICAqIEBwYXJhbSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgZnJvbVxuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBjb3B5RnJvbShwKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KHAueCwgcC55KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9pbnQncyB4IGFuZCB5IGludG8gdGhlIGdpdmVuIHBvaW50IChgcGApLlxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IHRvLiBDYW4gYmUgYW55IG9mIHR5cGUgdGhhdCBpcyBvciBleHRlbmRzIGBJUG9pbnREYXRhYFxuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgKGBwYCkgd2l0aCB2YWx1ZXMgdXBkYXRlZFxuICAgKi9cbiAgY29weVRvKHApIHtcbiAgICByZXR1cm4gcC5zZXQodGhpcy54LCB0aGlzLnkpLCBwO1xuICB9XG4gIC8qKlxuICAgKiBBY2NlcHRzIGFub3RoZXIgcG9pbnQgKGBwYCkgYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAqIEBwYXJhbSBwIC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGJvdGggYHhgIGFuZCBgeWAgYXJlIGVxdWFsXG4gICAqL1xuICBlcXVhbHMocCkge1xuICAgIHJldHVybiBwLnggPT09IHRoaXMueCAmJiBwLnkgPT09IHRoaXMueTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgYHhgIGFuZCBgeWAgcG9zaXRpb24uXG4gICAqIElmIGB5YCBpcyBvbWl0dGVkLCBib3RoIGB4YCBhbmQgYHlgIHdpbGwgYmUgc2V0IHRvIGB4YC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSBgeGAgYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9eF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIGB5YCBheGlzXG4gICAqIEByZXR1cm5zIFRoZSBwb2ludCBpbnN0YW5jZSBpdHNlbGZcbiAgICovXG4gIHNldCh4ID0gMCwgeSA9IHgpIHtcbiAgICByZXR1cm4gdGhpcy54ID0geCwgdGhpcy55ID0geSwgdGhpcztcbiAgfVxufVxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6UG9pbnQgeD0ke3RoaXMueH0geT0ke3RoaXMueX1dYDtcbn07XG5leHBvcnQge1xuICBQb2ludFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gXCIuLi9jb25zdC5tanNcIjtcbmltcG9ydCB7IFBvaW50IH0gZnJvbSBcIi4uL1BvaW50Lm1qc1wiO1xuY29uc3QgdGVtcFBvaW50cyA9IFtuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCBuZXcgUG9pbnQoKV07XG5jbGFzcyBSZWN0YW5nbGUge1xuICAvKipcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSBOdW1iZXIoeCksIHRoaXMueSA9IE51bWJlcih5KSwgdGhpcy53aWR0aCA9IE51bWJlcih3aWR0aCksIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCksIHRoaXMudHlwZSA9IFNIQVBFUy5SRUNUO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLiAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGUuICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMueTtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqIEEgY29uc3RhbnQgZW1wdHkgcmVjdGFuZ2xlLiAqL1xuICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGVcbiAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHJlY3RhbmdsZSkge1xuICAgIHJldHVybiB0aGlzLnggPSByZWN0YW5nbGUueCwgdGhpcy55ID0gcmVjdGFuZ2xlLnksIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGgsIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcmVjdGFuZ2xlIHRvIGFub3RoZXIgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhyZWN0YW5nbGUpIHtcbiAgICByZXR1cm4gcmVjdGFuZ2xlLnggPSB0aGlzLngsIHJlY3RhbmdsZS55ID0gdGhpcy55LCByZWN0YW5nbGUud2lkdGggPSB0aGlzLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHJlY3RhbmdsZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgKi9cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCA/ICExIDogeCA+PSB0aGlzLnggJiYgeCA8IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGBvdGhlcmAgUmVjdGFuZ2xlIHRyYW5zZm9ybWVkIGJ5IGB0cmFuc2Zvcm1gIGludGVyc2VjdHMgd2l0aCBgdGhpc2AgUmVjdGFuZ2xlIG9iamVjdC5cbiAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGFyZWEgb2YgdGhlIGludGVyc2VjdGlvbiBpcyA+MCwgdGhpcyBtZWFucyB0aGF0IFJlY3RhbmdsZXNcbiAgICogc2hhcmluZyBhIHNpZGUgYXJlIG5vdCBvdmVybGFwcGluZy4gQW5vdGhlciBzaWRlIGVmZmVjdCBpcyB0aGF0IGFuIGFyZWFsZXNzIHJlY3RhbmdsZVxuICAgKiAod2lkdGggb3IgaGVpZ2h0IGVxdWFsIHRvIHplcm8pIGNhbid0IGludGVyc2VjdCBhbnkgb3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gb3RoZXIgLSBUaGUgUmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIGB0aGlzYC5cbiAgICogQHBhcmFtIHtNYXRyaXh9IHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgYG90aGVyYC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IEEgdmFsdWUgb2YgYHRydWVgIGlmIHRoZSB0cmFuc2Zvcm1lZCBgb3RoZXJgIFJlY3RhbmdsZSBpbnRlcnNlY3RzIHdpdGggYHRoaXNgOyBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIGludGVyc2VjdHMob3RoZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCB4MDIgPSB0aGlzLnggPCBvdGhlci54ID8gb3RoZXIueCA6IHRoaXMueDtcbiAgICAgIGlmICgodGhpcy5yaWdodCA+IG90aGVyLnJpZ2h0ID8gb3RoZXIucmlnaHQgOiB0aGlzLnJpZ2h0KSA8PSB4MDIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHkwMiA9IHRoaXMueSA8IG90aGVyLnkgPyBvdGhlci55IDogdGhpcy55O1xuICAgICAgcmV0dXJuICh0aGlzLmJvdHRvbSA+IG90aGVyLmJvdHRvbSA/IG90aGVyLmJvdHRvbSA6IHRoaXMuYm90dG9tKSA+IHkwMjtcbiAgICB9XG4gICAgY29uc3QgeDAgPSB0aGlzLmxlZnQsIHgxID0gdGhpcy5yaWdodCwgeTAgPSB0aGlzLnRvcCwgeTEgPSB0aGlzLmJvdHRvbTtcbiAgICBpZiAoeDEgPD0geDAgfHwgeTEgPD0geTApXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbHQgPSB0ZW1wUG9pbnRzWzBdLnNldChvdGhlci5sZWZ0LCBvdGhlci50b3ApLCBsYiA9IHRlbXBQb2ludHNbMV0uc2V0KG90aGVyLmxlZnQsIG90aGVyLmJvdHRvbSksIHJ0ID0gdGVtcFBvaW50c1syXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLnRvcCksIHJiID0gdGVtcFBvaW50c1szXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLmJvdHRvbSk7XG4gICAgaWYgKHJ0LnggPD0gbHQueCB8fCBsYi55IDw9IGx0LnkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcyA9IE1hdGguc2lnbih0cmFuc2Zvcm0uYSAqIHRyYW5zZm9ybS5kIC0gdHJhbnNmb3JtLmIgKiB0cmFuc2Zvcm0uYyk7XG4gICAgaWYgKHMgPT09IDAgfHwgKHRyYW5zZm9ybS5hcHBseShsdCwgbHQpLCB0cmFuc2Zvcm0uYXBwbHkobGIsIGxiKSwgdHJhbnNmb3JtLmFwcGx5KHJ0LCBydCksIHRyYW5zZm9ybS5hcHBseShyYiwgcmIpLCBNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KSA8PSB4MCB8fCBNYXRoLm1pbihsdC54LCBsYi54LCBydC54LCByYi54KSA+PSB4MSB8fCBNYXRoLm1heChsdC55LCBsYi55LCBydC55LCByYi55KSA8PSB5MCB8fCBNYXRoLm1pbihsdC55LCBsYi55LCBydC55LCByYi55KSA+PSB5MSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbnggPSBzICogKGxiLnkgLSBsdC55KSwgbnkgPSBzICogKGx0LnggLSBsYi54KSwgbjAwID0gbnggKiB4MCArIG55ICogeTAsIG4xMCA9IG54ICogeDEgKyBueSAqIHkwLCBuMDEgPSBueCAqIHgwICsgbnkgKiB5MSwgbjExID0gbnggKiB4MSArIG55ICogeTE7XG4gICAgaWYgKE1hdGgubWF4KG4wMCwgbjEwLCBuMDEsIG4xMSkgPD0gbnggKiBsdC54ICsgbnkgKiBsdC55IHx8IE1hdGgubWluKG4wMCwgbjEwLCBuMDEsIG4xMSkgPj0gbnggKiByYi54ICsgbnkgKiByYi55KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG14ID0gcyAqIChsdC55IC0gcnQueSksIG15ID0gcyAqIChydC54IC0gbHQueCksIG0wMCA9IG14ICogeDAgKyBteSAqIHkwLCBtMTAgPSBteCAqIHgxICsgbXkgKiB5MCwgbTAxID0gbXggKiB4MCArIG15ICogeTEsIG0xMSA9IG14ICogeDEgKyBteSAqIHkxO1xuICAgIHJldHVybiAhKE1hdGgubWF4KG0wMCwgbTEwLCBtMDEsIG0xMSkgPD0gbXggKiBsdC54ICsgbXkgKiBsdC55IHx8IE1hdGgubWluKG0wMCwgbTEwLCBtMDEsIG0xMSkgPj0gbXggKiByYi54ICsgbXkgKiByYi55KTtcbiAgfVxuICAvKipcbiAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKiBJZiBwYWRkaW5nWSBpcyBvbWl0dGVkLCBib3RoIHBhZGRpbmdYIGFuZCBwYWRkaW5nWSB3aWxsIGJlIHNldCB0byBwYWRkaW5nWC5cbiAgICogQHBhcmFtIHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwYXJhbSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgcmV0dXJuIHRoaXMueCAtPSBwYWRkaW5nWCwgdGhpcy55IC09IHBhZGRpbmdZLCB0aGlzLndpZHRoICs9IHBhZGRpbmdYICogMiwgdGhpcy5oZWlnaHQgKz0gcGFkZGluZ1kgKiAyLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBGaXRzIHRoaXMgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgcGFzc2VkIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gZml0LlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGZpdChyZWN0YW5nbGUpIHtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdGFuZ2xlLngpLCB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKSwgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3RhbmdsZS55KSwgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy54ID0geDEsIHRoaXMud2lkdGggPSBNYXRoLm1heCh4MiAtIHgxLCAwKSwgdGhpcy55ID0geTEsIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoeTIgLSB5MSwgMCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEVubGFyZ2VzIHJlY3RhbmdsZSB0aGF0IHdheSBpdHMgY29ybmVycyBsaWUgb24gZ3JpZFxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIHJlc29sdXRpb25cbiAgICogQHBhcmFtIGVwcyAtIHByZWNpc2lvblxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNlaWwocmVzb2x1dGlvbiA9IDEsIGVwcyA9IDFlLTMpIHtcbiAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgodGhpcy54ICsgdGhpcy53aWR0aCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGguZmxvb3IoKHRoaXMueCArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHRoaXMueSA9IE1hdGguZmxvb3IoKHRoaXMueSArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueCwgdGhpcy5oZWlnaHQgPSB5MiAtIHRoaXMueSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBlbmxhcmdlKHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCksIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpLCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpLCB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgIHJldHVybiB0aGlzLnggPSB4MSwgdGhpcy53aWR0aCA9IHgyIC0geDEsIHRoaXMueSA9IHkxLCB0aGlzLmhlaWdodCA9IHkyIC0geTEsIHRoaXM7XG4gIH1cbn1cblJlY3RhbmdsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvbWF0aDpSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX0gd2lkdGg9JHt0aGlzLndpZHRofSBoZWlnaHQ9JHt0aGlzLmhlaWdodH1dYDtcbn07XG5leHBvcnQge1xuICBSZWN0YW5nbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4vUmVjdGFuZ2xlLm1qc1wiO1xuY2xhc3MgQ2lyY2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgIHRoaXMueCA9IHgsIHRoaXMueSA9IHksIHRoaXMucmFkaXVzID0gcmFkaXVzLCB0aGlzLnR5cGUgPSBTSEFQRVMuQ0lSQztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGUgQ2lyY2xlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIGxldCBkeCA9IHRoaXMueCAtIHgsIGR5ID0gdGhpcy55IC0geTtcbiAgICByZXR1cm4gZHggKj0gZHgsIGR5ICo9IGR5LCBkeCArIGR5IDw9IHIyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLnJhZGl1cywgdGhpcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyKTtcbiAgfVxufVxuQ2lyY2xlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9tYXRoOkNpcmNsZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbn07XG5leHBvcnQge1xuICBDaXJjbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaXJjbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4vUmVjdGFuZ2xlLm1qc1wiO1xuY2xhc3MgRWxsaXBzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSBoYWxmV2lkdGggLSBUaGUgaGFsZiB3aWR0aCBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIGhhbGZIZWlnaHQgLSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhpcyBlbGxpcHNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIGhhbGZXaWR0aCA9IDAsIGhhbGZIZWlnaHQgPSAwKSB7XG4gICAgdGhpcy54ID0geCwgdGhpcy55ID0geSwgdGhpcy53aWR0aCA9IGhhbGZXaWR0aCwgdGhpcy5oZWlnaHQgPSBoYWxmSGVpZ2h0LCB0aGlzLnR5cGUgPSBTSEFQRVMuRUxJUDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7UElYSS5FbGxpcHNlfSBBIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBub3JteCA9ICh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIG5vcm15ID0gKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG5vcm14ICo9IG5vcm14LCBub3JteSAqPSBub3JteSwgbm9ybXggKyBub3JteSA8PSAxO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgZWxsaXBzZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gdGhpcy53aWR0aCwgdGhpcy55IC0gdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxufVxuRWxsaXBzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvbWF0aDpFbGxpcHNlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG59O1xuZXhwb3J0IHtcbiAgRWxsaXBzZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsbGlwc2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuY2xhc3MgUG9seWdvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50RGF0YVtdfG51bWJlcltdfSBwb2ludHMgLSBUaGlzIGNhbiBiZSBhbiBhcnJheSBvZiBQb2ludHNcbiAgICogIHRoYXQgZm9ybSB0aGUgcG9seWdvbiwgYSBmbGF0IGFycmF5IG9mIG51bWJlcnMgdGhhdCB3aWxsIGJlIGludGVycHJldGVkIGFzIFt4LHksIHgseSwgLi4uXSwgb3JcbiAgICogIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuXG4gICAqICBgbmV3IFBvbHlnb24obmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCAuLi4pYCwgb3IgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGZsYXRcbiAgICogIHgseSB2YWx1ZXMgZS5nLiBgbmV3IFBvbHlnb24oeCx5LCB4LHksIHgseSwgLi4uKWAgd2hlcmUgYHhgIGFuZCBgeWAgYXJlIE51bWJlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi5wb2ludHMpIHtcbiAgICBsZXQgZmxhdCA9IEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSA/IHBvaW50c1swXSA6IHBvaW50cztcbiAgICBpZiAodHlwZW9mIGZsYXRbMF0gIT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZmxhdC5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICBwLnB1c2goZmxhdFtpXS54LCBmbGF0W2ldLnkpO1xuICAgICAgZmxhdCA9IHA7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzID0gZmxhdCwgdGhpcy50eXBlID0gU0hBUEVTLlBPTFksIHRoaXMuY2xvc2VTdHJva2UgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9seWdvbi5cbiAgICogQHJldHVybnMgLSBBIGNvcHkgb2YgdGhlIHBvbHlnb24uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cy5zbGljZSgpLCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICByZXR1cm4gcG9seWdvbi5jbG9zZVN0cm9rZSA9IHRoaXMuY2xvc2VTdHJva2UsIHBvbHlnb247XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uLlxuICAgKi9cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGxldCBpbnNpZGUgPSAhMTtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgY29uc3QgeGkgPSB0aGlzLnBvaW50c1tpICogMl0sIHlpID0gdGhpcy5wb2ludHNbaSAqIDIgKyAxXSwgeGogPSB0aGlzLnBvaW50c1tqICogMl0sIHlqID0gdGhpcy5wb2ludHNbaiAqIDIgKyAxXTtcbiAgICAgIHlpID4geSAhPSB5aiA+IHkgJiYgeCA8ICh4aiAtIHhpKSAqICgoeSAtIHlpKSAvICh5aiAtIHlpKSkgKyB4aSAmJiAoaW5zaWRlID0gIWluc2lkZSk7XG4gICAgfVxuICAgIHJldHVybiBpbnNpZGU7XG4gIH1cbn1cblBvbHlnb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6UG9seWdvbmNsb3NlU3Ryb2tlPSR7dGhpcy5jbG9zZVN0cm9rZX1wb2ludHM9JHt0aGlzLnBvaW50cy5yZWR1Y2UoKHBvaW50c0Rlc2MsIGN1cnJlbnRQb2ludCkgPT4gYCR7cG9pbnRzRGVzY30sICR7Y3VycmVudFBvaW50fWAsIFwiXCIpfV1gO1xufTtcbmV4cG9ydCB7XG4gIFBvbHlnb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gXCIuLi9jb25zdC5tanNcIjtcbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICAvKipcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIENvbnRyb2xzIHRoZSByYWRpdXMgb2YgdGhlIHJvdW5kZWQgY29ybmVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAsIHJhZGl1cyA9IDIwKSB7XG4gICAgdGhpcy54ID0geCwgdGhpcy55ID0geSwgdGhpcy53aWR0aCA9IHdpZHRoLCB0aGlzLmhlaWdodCA9IGhlaWdodCwgdGhpcy5yYWRpdXMgPSByYWRpdXMsIHRoaXMudHlwZSA9IFNIQVBFUy5SUkVDO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSb3VuZGVkIFJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgLSBBIGNvcHkgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSb3VuZGVkUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGUuXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodCkge1xuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5yYWRpdXMsIE1hdGgubWluKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDIpKTtcbiAgICAgIGlmICh5ID49IHRoaXMueSArIHJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzIHx8IHggPj0gdGhpcy54ICsgcmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHJhZGl1cylcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgbGV0IGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpLCBkeSA9IHkgLSAodGhpcy55ICsgcmFkaXVzKTtcbiAgICAgIGNvbnN0IHJhZGl1czIgPSByYWRpdXMgKiByYWRpdXM7XG4gICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMiB8fCAoZHggPSB4IC0gKHRoaXMueCArIHRoaXMud2lkdGggLSByYWRpdXMpLCBkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB8fCAoZHkgPSB5IC0gKHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzKSwgZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikgfHwgKGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpLCBkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbn1cblJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6Um91bmRlZFJlY3RhbmdsZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fXdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9IHJhZGl1cz0ke3RoaXMucmFkaXVzfV1gO1xufTtcbmV4cG9ydCB7XG4gIFJvdW5kZWRSZWN0YW5nbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3VuZGVkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IFBJXzIgfSBmcm9tIFwiLi9jb25zdC5tanNcIjtcbmltcG9ydCB7IFBvaW50IH0gZnJvbSBcIi4vUG9pbnQubWpzXCI7XG5jbGFzcyBNYXRyaXgge1xuICAvKipcbiAgICogQHBhcmFtIGEgLSB4IHNjYWxlXG4gICAqIEBwYXJhbSBiIC0geSBza2V3XG4gICAqIEBwYXJhbSBjIC0geCBza2V3XG4gICAqIEBwYXJhbSBkIC0geSBzY2FsZVxuICAgKiBAcGFyYW0gdHggLSB4IHRyYW5zbGF0aW9uXG4gICAqIEBwYXJhbSB0eSAtIHkgdHJhbnNsYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xuICAgIHRoaXMuYXJyYXkgPSBudWxsLCB0aGlzLmEgPSBhLCB0aGlzLmIgPSBiLCB0aGlzLmMgPSBjLCB0aGlzLmQgPSBkLCB0aGlzLnR4ID0gdHgsIHRoaXMudHkgPSB0eTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBhID0gYXJyYXlbMF1cbiAgICogYiA9IGFycmF5WzFdXG4gICAqIGMgPSBhcnJheVszXVxuICAgKiBkID0gYXJyYXlbNF1cbiAgICogdHggPSBhcnJheVsyXVxuICAgKiB0eSA9IGFycmF5WzVdXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBwb3B1bGF0ZWQgZnJvbS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuYSA9IGFycmF5WzBdLCB0aGlzLmIgPSBhcnJheVsxXSwgdGhpcy5jID0gYXJyYXlbM10sIHRoaXMuZCA9IGFycmF5WzRdLCB0aGlzLnR4ID0gYXJyYXlbMl0sIHRoaXMudHkgPSBhcnJheVs1XTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF0cml4IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBhIC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gYiAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIGMgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEBwYXJhbSBkIC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gdHggLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEBwYXJhbSB0eSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHNldChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICByZXR1cm4gdGhpcy5hID0gYSwgdGhpcy5iID0gYiwgdGhpcy5jID0gYywgdGhpcy5kID0gZCwgdGhpcy50eCA9IHR4LCB0aGlzLnR5ID0gdHksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgZnJvbSB0aGUgY3VycmVudCBNYXRyaXggb2JqZWN0LlxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIC0gV2hldGhlciB3ZSBuZWVkIHRvIHRyYW5zcG9zZSB0aGUgbWF0cml4IG9yIG5vdFxuICAgKiBAcGFyYW0gW291dD1uZXcgRmxvYXQzMkFycmF5KDkpXSAtIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIHRvIG91dFxuICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XG4gICAqL1xuICB0b0FycmF5KHRyYW5zcG9zZSwgb3V0KSB7XG4gICAgdGhpcy5hcnJheSB8fCAodGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSkpO1xuICAgIGNvbnN0IGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XG4gICAgcmV0dXJuIHRyYW5zcG9zZSA/IChhcnJheVswXSA9IHRoaXMuYSwgYXJyYXlbMV0gPSB0aGlzLmIsIGFycmF5WzJdID0gMCwgYXJyYXlbM10gPSB0aGlzLmMsIGFycmF5WzRdID0gdGhpcy5kLCBhcnJheVs1XSA9IDAsIGFycmF5WzZdID0gdGhpcy50eCwgYXJyYXlbN10gPSB0aGlzLnR5LCBhcnJheVs4XSA9IDEpIDogKGFycmF5WzBdID0gdGhpcy5hLCBhcnJheVsxXSA9IHRoaXMuYywgYXJyYXlbMl0gPSB0aGlzLnR4LCBhcnJheVszXSA9IHRoaXMuYiwgYXJyYXlbNF0gPSB0aGlzLmQsIGFycmF5WzVdID0gdGhpcy50eSwgYXJyYXlbNl0gPSAwLCBhcnJheVs3XSA9IDAsIGFycmF5WzhdID0gMSksIGFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlIHRvIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiByZW5kZXJpbmcpXG4gICAqIEBwYXJhbSBwb3MgLSBUaGUgb3JpZ2luXG4gICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQSVhJLlBvaW50fSBUaGUgbmV3IHBvaW50LCB0cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAqL1xuICBhcHBseShwb3MsIG5ld1Bvcykge1xuICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgUG9pbnQoKTtcbiAgICBjb25zdCB4ID0gcG9zLngsIHkgPSBwb3MueTtcbiAgICByZXR1cm4gbmV3UG9zLnggPSB0aGlzLmEgKiB4ICsgdGhpcy5jICogeSArIHRoaXMudHgsIG5ld1Bvcy55ID0gdGhpcy5iICogeCArIHRoaXMuZCAqIHkgKyB0aGlzLnR5LCBuZXdQb3M7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UgdG8gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIGlucHV0KVxuICAgKiBAcGFyYW0gcG9zIC0gVGhlIG9yaWdpblxuICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxuICAgKiBAcmV0dXJucyB7UElYSS5Qb2ludH0gVGhlIG5ldyBwb2ludCwgaW52ZXJzZS10cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAqL1xuICBhcHBseUludmVyc2UocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgaWQgPSAxIC8gKHRoaXMuYSAqIHRoaXMuZCArIHRoaXMuYyAqIC10aGlzLmIpLCB4ID0gcG9zLngsIHkgPSBwb3MueTtcbiAgICByZXR1cm4gbmV3UG9zLnggPSB0aGlzLmQgKiBpZCAqIHggKyAtdGhpcy5jICogaWQgKiB5ICsgKHRoaXMudHkgKiB0aGlzLmMgLSB0aGlzLnR4ICogdGhpcy5kKSAqIGlkLCBuZXdQb3MueSA9IHRoaXMuYSAqIGlkICogeSArIC10aGlzLmIgKiBpZCAqIHggKyAoLXRoaXMudHkgKiB0aGlzLmEgKyB0aGlzLnR4ICogdGhpcy5iKSAqIGlkLCBuZXdQb3M7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgdGhlIG1hdHJpeCBvbiB0aGUgeCBhbmQgeS5cbiAgICogQHBhcmFtIHggLSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeCBieVxuICAgKiBAcGFyYW0geSAtIEhvdyBtdWNoIHRvIHRyYW5zbGF0ZSB5IGJ5XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnR4ICs9IHgsIHRoaXMudHkgKz0geSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG4gICAqIEBwYXJhbSB4IC0gVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcbiAgICogQHBhcmFtIHkgLSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHlcbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHNjYWxlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hICo9IHgsIHRoaXMuZCAqPSB5LCB0aGlzLmMgKj0geCwgdGhpcy5iICo9IHksIHRoaXMudHggKj0geCwgdGhpcy50eSAqPSB5LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICByb3RhdGUoYW5nbGUpIHtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKSwgYTEgPSB0aGlzLmEsIGMxID0gdGhpcy5jLCB0eDEgPSB0aGlzLnR4O1xuICAgIHJldHVybiB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbiwgdGhpcy5iID0gYTEgKiBzaW4gKyB0aGlzLmIgKiBjb3MsIHRoaXMuYyA9IGMxICogY29zIC0gdGhpcy5kICogc2luLCB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcywgdGhpcy50eCA9IHR4MSAqIGNvcyAtIHRoaXMudHkgKiBzaW4sIHRoaXMudHkgPSB0eDEgKiBzaW4gKyB0aGlzLnR5ICogY29zLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIGFwcGVuZChtYXRyaXgpIHtcbiAgICBjb25zdCBhMSA9IHRoaXMuYSwgYjEgPSB0aGlzLmIsIGMxID0gdGhpcy5jLCBkMSA9IHRoaXMuZDtcbiAgICByZXR1cm4gdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzEsIHRoaXMuYiA9IG1hdHJpeC5hICogYjEgKyBtYXRyaXguYiAqIGQxLCB0aGlzLmMgPSBtYXRyaXguYyAqIGExICsgbWF0cml4LmQgKiBjMSwgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDEsIHRoaXMudHggPSBtYXRyaXgudHggKiBhMSArIG1hdHJpeC50eSAqIGMxICsgdGhpcy50eCwgdGhpcy50eSA9IG1hdHJpeC50eCAqIGIxICsgbWF0cml4LnR5ICogZDEgKyB0aGlzLnR5LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXRyaXggYmFzZWQgb24gYWxsIHRoZSBhdmFpbGFibGUgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geCAtIFBvc2l0aW9uIG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHkgLSBQb3NpdGlvbiBvbiB0aGUgeSBheGlzXG4gICAqIEBwYXJhbSBwaXZvdFggLSBQaXZvdCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSBwaXZvdFkgLSBQaXZvdCBvbiB0aGUgeSBheGlzXG4gICAqIEBwYXJhbSBzY2FsZVggLSBTY2FsZSBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSBzY2FsZVkgLSBTY2FsZSBvbiB0aGUgeSBheGlzXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIFJvdGF0aW9uIGluIHJhZGlhbnNcbiAgICogQHBhcmFtIHNrZXdYIC0gU2tldyBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSBza2V3WSAtIFNrZXcgb24gdGhlIHkgYXhpc1xuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgc2V0VHJhbnNmb3JtKHgsIHksIHBpdm90WCwgcGl2b3RZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSkge1xuICAgIHJldHVybiB0aGlzLmEgPSBNYXRoLmNvcyhyb3RhdGlvbiArIHNrZXdZKSAqIHNjYWxlWCwgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVgsIHRoaXMuYyA9IC1NYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWSwgdGhpcy5kID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVksIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyksIHRoaXMudHkgPSB5IC0gKHBpdm90WCAqIHRoaXMuYiArIHBpdm90WSAqIHRoaXMuZCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIHByZXBlbmRcbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHByZXBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICBpZiAobWF0cml4LmEgIT09IDEgfHwgbWF0cml4LmIgIT09IDAgfHwgbWF0cml4LmMgIT09IDAgfHwgbWF0cml4LmQgIT09IDEpIHtcbiAgICAgIGNvbnN0IGExID0gdGhpcy5hLCBjMSA9IHRoaXMuYztcbiAgICAgIHRoaXMuYSA9IGExICogbWF0cml4LmEgKyB0aGlzLmIgKiBtYXRyaXguYywgdGhpcy5iID0gYTEgKiBtYXRyaXguYiArIHRoaXMuYiAqIG1hdHJpeC5kLCB0aGlzLmMgPSBjMSAqIG1hdHJpeC5hICsgdGhpcy5kICogbWF0cml4LmMsIHRoaXMuZCA9IGMxICogbWF0cml4LmIgKyB0aGlzLmQgKiBtYXRyaXguZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHggPSB0eDEgKiBtYXRyaXguYSArIHRoaXMudHkgKiBtYXRyaXguYyArIG1hdHJpeC50eCwgdGhpcy50eSA9IHR4MSAqIG1hdHJpeC5iICsgdGhpcy50eSAqIG1hdHJpeC5kICsgbWF0cml4LnR5LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvbXBvc2VzIHRoZSBtYXRyaXggKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBhbmQgcm90YXRpb24pIGFuZCBzZXRzIHRoZSBwcm9wZXJ0aWVzIG9uIHRvIGEgdHJhbnNmb3JtLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSB0byBhcHBseSB0aGUgcHJvcGVydGllcyB0by5cbiAgICogQHJldHVybnMgVGhlIHRyYW5zZm9ybSB3aXRoIHRoZSBuZXdseSBhcHBsaWVkIHByb3BlcnRpZXNcbiAgICovXG4gIGRlY29tcG9zZSh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jLCBkID0gdGhpcy5kLCBwaXZvdCA9IHRyYW5zZm9ybS5waXZvdCwgc2tld1ggPSAtTWF0aC5hdGFuMigtYywgZCksIHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKSwgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcbiAgICByZXR1cm4gZGVsdGEgPCAxZS01IHx8IE1hdGguYWJzKFBJXzIgLSBkZWx0YSkgPCAxZS01ID8gKHRyYW5zZm9ybS5yb3RhdGlvbiA9IHNrZXdZLCB0cmFuc2Zvcm0uc2tldy54ID0gdHJhbnNmb3JtLnNrZXcueSA9IDApIDogKHRyYW5zZm9ybS5yb3RhdGlvbiA9IDAsIHRyYW5zZm9ybS5za2V3LnggPSBza2V3WCwgdHJhbnNmb3JtLnNrZXcueSA9IHNrZXdZKSwgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksIHRyYW5zZm9ybS5zY2FsZS55ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpLCB0cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHRoaXMudHggKyAocGl2b3QueCAqIGEgKyBwaXZvdC55ICogYyksIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdGhpcy50eSArIChwaXZvdC54ICogYiArIHBpdm90LnkgKiBkKSwgdHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoaXMgbWF0cml4XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpbnZlcnQoKSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmEsIGIxID0gdGhpcy5iLCBjMSA9IHRoaXMuYywgZDEgPSB0aGlzLmQsIHR4MSA9IHRoaXMudHgsIG4gPSBhMSAqIGQxIC0gYjEgKiBjMTtcbiAgICByZXR1cm4gdGhpcy5hID0gZDEgLyBuLCB0aGlzLmIgPSAtYjEgLyBuLCB0aGlzLmMgPSAtYzEgLyBuLCB0aGlzLmQgPSBhMSAvIG4sIHRoaXMudHggPSAoYzEgKiB0aGlzLnR5IC0gZDEgKiB0eDEpIC8gbiwgdGhpcy50eSA9IC0oYTEgKiB0aGlzLnR5IC0gYjEgKiB0eDEpIC8gbiwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgTWF0cml4IHRvIGFuIGlkZW50aXR5IChkZWZhdWx0KSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5hID0gMSwgdGhpcy5iID0gMCwgdGhpcy5jID0gMCwgdGhpcy5kID0gMSwgdGhpcy50eCA9IDAsIHRoaXMudHkgPSAwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHJldHVybiBtYXRyaXguYSA9IHRoaXMuYSwgbWF0cml4LmIgPSB0aGlzLmIsIG1hdHJpeC5jID0gdGhpcy5jLCBtYXRyaXguZCA9IHRoaXMuZCwgbWF0cml4LnR4ID0gdGhpcy50eCwgbWF0cml4LnR5ID0gdGhpcy50eSwgbWF0cml4O1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IGdpdmVuIGluIHBhcmFtZXRlciB3aXRoIGl0cyB2YWx1ZXMgdXBkYXRlZC5cbiAgICovXG4gIGNvcHlUbyhtYXRyaXgpIHtcbiAgICByZXR1cm4gbWF0cml4LmEgPSB0aGlzLmEsIG1hdHJpeC5iID0gdGhpcy5iLCBtYXRyaXguYyA9IHRoaXMuYywgbWF0cml4LmQgPSB0aGlzLmQsIG1hdHJpeC50eCA9IHRoaXMudHgsIG1hdHJpeC50eSA9IHRoaXMudHksIG1hdHJpeDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gZ2l2ZW4gbWF0cml4XG4gICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyB7UElYSS5NYXRyaXh9IHRoaXNcbiAgICovXG4gIGNvcHlGcm9tKG1hdHJpeCkge1xuICAgIHJldHVybiB0aGlzLmEgPSBtYXRyaXguYSwgdGhpcy5iID0gbWF0cml4LmIsIHRoaXMuYyA9IG1hdHJpeC5jLCB0aGlzLmQgPSBtYXRyaXguZCwgdGhpcy50eCA9IG1hdHJpeC50eCwgdGhpcy50eSA9IG1hdHJpeC50eSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQSBkZWZhdWx0IChpZGVudGl0eSkgbWF0cml4XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICB9XG4gIC8qKlxuICAgKiBBIHRlbXAgbWF0cml4XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBURU1QX01BVFJJWCgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICB9XG59XG5NYXRyaXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6TWF0cml4IGE9JHt0aGlzLmF9IGI9JHt0aGlzLmJ9IGM9JHt0aGlzLmN9IGQ9JHt0aGlzLmR9IHR4PSR7dGhpcy50eH0gdHk9JHt0aGlzLnR5fV1gO1xufTtcbmV4cG9ydCB7XG4gIE1hdHJpeFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdHJpeC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9NYXRyaXgubWpzXCI7XG5jb25zdCB1eCA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxXSwgdXkgPSBbMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV0sIHZ4ID0gWzAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdLCB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXSwgcm90YXRpb25DYXlsZXkgPSBbXSwgcm90YXRpb25NYXRyaWNlcyA9IFtdLCBzaWdudW0gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBpbml0KCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICByb3RhdGlvbkNheWxleS5wdXNoKHJvdyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICBjb25zdCBfdXggPSBzaWdudW0odXhbaV0gKiB1eFtqXSArIHZ4W2ldICogdXlbal0pLCBfdXkgPSBzaWdudW0odXlbaV0gKiB1eFtqXSArIHZ5W2ldICogdXlbal0pLCBfdnggPSBzaWdudW0odXhbaV0gKiB2eFtqXSArIHZ4W2ldICogdnlbal0pLCBfdnkgPSBzaWdudW0odXlbaV0gKiB2eFtqXSArIHZ5W2ldICogdnlbal0pO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAxNjsgaysrKVxuICAgICAgICBpZiAodXhba10gPT09IF91eCAmJiB1eVtrXSA9PT0gX3V5ICYmIHZ4W2tdID09PSBfdnggJiYgdnlba10gPT09IF92eSkge1xuICAgICAgICAgIHJvdy5wdXNoKGspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICBtYXQuc2V0KHV4W2ldLCB1eVtpXSwgdnhbaV0sIHZ5W2ldLCAwLCAwKSwgcm90YXRpb25NYXRyaWNlcy5wdXNoKG1hdCk7XG4gIH1cbn1cbmluaXQoKTtcbmNvbnN0IGdyb3VwRDggPSB7XG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgMMKwICAgICAgIHwgRWFzdCAgICAgIHxcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBFOiAwLFxuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDQ1wrDihrsgICAgIHwgU291dGhlYXN0IHxcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBTRTogMSxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCA5MMKw4oa7ICAgICB8IFNvdXRoICAgICB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgUzogMixcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAxMzXCsOKGuyAgICB8IFNvdXRod2VzdCB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgU1c6IDMsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgMTgwwrAgICAgIHwgV2VzdCAgICAgIHxcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBXOiA0LFxuICAvKipcbiAgICogfCBSb3RhdGlvbiAgICB8IERpcmVjdGlvbiAgICB8XG4gICAqIHwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfFxuICAgKiB8IC0xMzXCsC8yMjXCsOKGuyB8IE5vcnRod2VzdCAgICB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgTlc6IDUsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uICAgIHwgRGlyZWN0aW9uICAgIHxcbiAgICogfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS18XG4gICAqIHwgLTkwwrAvMjcwwrDihrsgIHwgTm9ydGggICAgICAgIHxcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBOOiA2LFxuICAvKipcbiAgICogfCBSb3RhdGlvbiAgICB8IERpcmVjdGlvbiAgICB8XG4gICAqIHwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfFxuICAgKiB8IC00NcKwLzMxNcKw4oa7ICB8IE5vcnRoZWFzdCAgICB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgTkU6IDcsXG4gIC8qKlxuICAgKiBSZWZsZWN0aW9uIGFib3V0IFktYXhpcy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBNSVJST1JfVkVSVElDQUw6IDgsXG4gIC8qKlxuICAgKiBSZWZsZWN0aW9uIGFib3V0IHRoZSBtYWluIGRpYWdvbmFsLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIE1BSU5fRElBR09OQUw6IDEwLFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCBYLWF4aXMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCByZXZlcnNlIGRpYWdvbmFsLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIFJFVkVSU0VfRElBR09OQUw6IDE0LFxuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBUaGUgWC1jb21wb25lbnQgb2YgdGhlIFUtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHVYOiAoaW5kKSA9PiB1eFtpbmRdLFxuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBUaGUgWS1jb21wb25lbnQgb2YgdGhlIFUtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHVZOiAoaW5kKSA9PiB1eVtpbmRdLFxuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBUaGUgWC1jb21wb25lbnQgb2YgdGhlIFYtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHZYOiAoaW5kKSA9PiB2eFtpbmRdLFxuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBUaGUgWS1jb21wb25lbnQgb2YgdGhlIFYtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHZZOiAoaW5kKSA9PiB2eVtpbmRdLFxuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIHN5bW1ldHJ5IHdob3NlIG9wcG9zaXRlXG4gICAqICAgaXMgbmVlZGVkLiBPbmx5IHJvdGF0aW9ucyBoYXZlIG9wcG9zaXRlIHN5bW1ldHJpZXMgd2hpbGVcbiAgICogICByZWZsZWN0aW9ucyBkb24ndC5cbiAgICogQHJldHVybnMge1BJWEkuR0Q4U3ltbWV0cnl9IFRoZSBvcHBvc2l0ZSBzeW1tZXRyeSBvZiBgcm90YXRpb25gXG4gICAqL1xuICBpbnY6IChyb3RhdGlvbikgPT4gcm90YXRpb24gJiA4ID8gcm90YXRpb24gJiAxNSA6IC1yb3RhdGlvbiAmIDcsXG4gIC8qKlxuICAgKiBDb21wb3NlcyB0aGUgdHdvIEQ4IG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIFRha2luZyBgXmAgYXMgcmVmbGVjdGlvbjpcbiAgICpcbiAgICogfCAgICAgICB8IEU9MCB8IFM9MiB8IFc9NCB8IE49NiB8IEVePTggfCBTXj0xMCB8IFdePTEyIHwgTl49MTQgfFxuICAgKiB8LS0tLS0tLXwtLS0tLXwtLS0tLXwtLS0tLXwtLS0tLXwtLS0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICAqIHwgRT0wICAgfCBFICAgfCBTICAgfCBXICAgfCBOICAgfCBFXiAgIHwgU14gICAgfCBXXiAgICB8IE5eICAgIHxcbiAgICogfCBTPTIgICB8IFMgICB8IFcgICB8IE4gICB8IEUgICB8IFNeICAgfCBXXiAgICB8IE5eICAgIHwgRV4gICAgfFxuICAgKiB8IFc9NCAgIHwgVyAgIHwgTiAgIHwgRSAgIHwgUyAgIHwgV14gICB8IE5eICAgIHwgRV4gICAgfCBTXiAgICB8XG4gICAqIHwgTj02ICAgfCBOICAgfCBFICAgfCBTICAgfCBXICAgfCBOXiAgIHwgRV4gICAgfCBTXiAgICB8IFdeICAgIHxcbiAgICogfCBFXj04ICB8IEVeICB8IE5eICB8IFdeICB8IFNeICB8IEUgICAgfCBOICAgICB8IFcgICAgIHwgUyAgICAgfFxuICAgKiB8IFNePTEwIHwgU14gIHwgRV4gIHwgTl4gIHwgV14gIHwgUyAgICB8IEUgICAgIHwgTiAgICAgfCBXICAgICB8XG4gICAqIHwgV149MTIgfCBXXiAgfCBTXiAgfCBFXiAgfCBOXiAgfCBXICAgIHwgUyAgICAgfCBFICAgICB8IE4gICAgIHxcbiAgICogfCBOXj0xNCB8IE5eICB8IFdeICB8IFNeICB8IEVeICB8IE4gICAgfCBXICAgICB8IFMgICAgIHwgRSAgICAgfFxuICAgKlxuICAgKiBbVGhpcyBpcyBhIENheWxleSB0YWJsZV17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F5bGV5X3RhYmxlfVxuICAgKiBAcGFyYW0ge1BJWEkuR0Q4U3ltbWV0cnl9IHJvdGF0aW9uU2Vjb25kIC0gU2Vjb25kIG9wZXJhdGlvbiwgd2hpY2hcbiAgICogICBpcyB0aGUgcm93IGluIHRoZSBhYm92ZSBjYXlsZXkgdGFibGUuXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gcm90YXRpb25GaXJzdCAtIEZpcnN0IG9wZXJhdGlvbiwgd2hpY2hcbiAgICogICBpcyB0aGUgY29sdW1uIGluIHRoZSBhYm92ZSBjYXlsZXkgdGFibGUuXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBDb21wb3NlZCBvcGVyYXRpb25cbiAgICovXG4gIGFkZDogKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSA9PiByb3RhdGlvbkNheWxleVtyb3RhdGlvblNlY29uZF1bcm90YXRpb25GaXJzdF0sXG4gIC8qKlxuICAgKiBSZXZlcnNlIG9mIGBhZGRgLlxuICAgKiBAcGFyYW0ge1BJWEkuR0Q4U3ltbWV0cnl9IHJvdGF0aW9uU2Vjb25kIC0gU2Vjb25kIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge1BJWEkuR0Q4U3ltbWV0cnl9IHJvdGF0aW9uRmlyc3QgLSBGaXJzdCBvcGVyYXRpb25cbiAgICogQHJldHVybnMge1BJWEkuR0Q4U3ltbWV0cnl9IFJlc3VsdFxuICAgKi9cbiAgc3ViOiAocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpID0+IHJvdGF0aW9uQ2F5bGV5W3JvdGF0aW9uU2Vjb25kXVtncm91cEQ4Lmludihyb3RhdGlvbkZpcnN0KV0sXG4gIC8qKlxuICAgKiBBZGRzIDE4MCBkZWdyZWVzIHRvIHJvdGF0aW9uLCB3aGljaCBpcyBhIGNvbW11dGF0aXZlXG4gICAqIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIG51bWJlciB0byByb3RhdGUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJvdGF0ZWQgbnVtYmVyXG4gICAqL1xuICByb3RhdGUxODA6IChyb3RhdGlvbikgPT4gcm90YXRpb24gXiA0LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSByb3RhdGlvbiBhbmdsZSBpcyB2ZXJ0aWNhbCwgaS5lLiBzb3V0aFxuICAgKiBvciBub3J0aC4gSXQgZG9lc24ndCB3b3JrIGZvciByZWZsZWN0aW9ucy5cbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiAocm90YXRpb24pID0+IChyb3RhdGlvbiAmIDMpID09PSAyLFxuICAvLyByb3RhdGlvbiAlIDQgPT09IDJcbiAgLyoqXG4gICAqIEFwcHJveGltYXRlcyB0aGUgdmVjdG9yIGBWKGR4LGR5KWAgaW50byBvbmUgb2YgdGhlXG4gICAqIGVpZ2h0IGRpcmVjdGlvbnMgcHJvdmlkZWQgYnkgYGdyb3VwRDhgLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBYLWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIFktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAgICogQHJldHVybnMge1BJWEkuR0Q4U3ltbWV0cnl9IEFwcHJveGltYXRpb24gb2YgdGhlIHZlY3RvciBpbnRvXG4gICAqICBvbmUgb2YgdGhlIGVpZ2h0IHN5bW1ldHJpZXMuXG4gICAqL1xuICBieURpcmVjdGlvbjogKGR4LCBkeSkgPT4gTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkgPyBkeSA+PSAwID8gZ3JvdXBEOC5TIDogZ3JvdXBEOC5OIDogTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkgPyBkeCA+IDAgPyBncm91cEQ4LkUgOiBncm91cEQ4LlcgOiBkeSA+IDAgPyBkeCA+IDAgPyBncm91cEQ4LlNFIDogZ3JvdXBEOC5TVyA6IGR4ID4gMCA/IGdyb3VwRDguTkUgOiBncm91cEQ4Lk5XLFxuICAvKipcbiAgICogSGVscHMgc3ByaXRlIHRvIGNvbXBlbnNhdGUgdGV4dHVyZSBwYWNrZXIgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIHNwcml0ZSB3b3JsZCBtYXRyaXhcbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBmYWN0b3IgdG8gdXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHggLSBzcHJpdGUgYW5jaG9yaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAtIHNwcml0ZSBhbmNob3JpbmdcbiAgICovXG4gIG1hdHJpeEFwcGVuZFJvdGF0aW9uSW52OiAobWF0cml4LCByb3RhdGlvbiwgdHggPSAwLCB0eSA9IDApID0+IHtcbiAgICBjb25zdCBtYXQgPSByb3RhdGlvbk1hdHJpY2VzW2dyb3VwRDguaW52KHJvdGF0aW9uKV07XG4gICAgbWF0LnR4ID0gdHgsIG1hdC50eSA9IHR5LCBtYXRyaXguYXBwZW5kKG1hdCk7XG4gIH1cbn07XG5leHBvcnQge1xuICBncm91cEQ4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBEOC5tanMubWFwXG4iLCJjbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgT2JzZXJ2YWJsZVBvaW50YFxuICAgKiBAcGFyYW0gY2IgLSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiBgeGAgYW5kL29yIGB5YCBhcmUgY2hhbmdlZFxuICAgKiBAcGFyYW0gc2NvcGUgLSBvd25lciBvZiBjYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2IsIHNjb3BlLCB4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHksIHRoaXMuY2IgPSBjYiwgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludC5cbiAgICogVGhlIGNhbGxiYWNrIGFuZCBzY29wZSBwYXJhbXMgY2FuIGJlIG92ZXJyaWRkZW4gb3RoZXJ3aXNlIHRoZXkgd2lsbCBkZWZhdWx0XG4gICAqIHRvIHRoZSBjbG9uZSBvYmplY3QncyB2YWx1ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0gY2IgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gYHhgIGFuZC9vciBgeWAgYXJlIGNoYW5nZWRcbiAgICogQHBhcmFtIHNjb3BlIC0gVGhlIG93bmVyIG9mIHRoZSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBvYnNlcnZhYmxlIHBvaW50XG4gICAqL1xuICBjbG9uZShjYiA9IHRoaXMuY2IsIHNjb3BlID0gdGhpcy5zY29wZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVBvaW50KGNiLCBzY29wZSwgdGhpcy5feCwgdGhpcy5feSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IGB4YCBhbmQgYHlgIHBvc2l0aW9uLlxuICAgKiBJZiBgeWAgaXMgb21pdHRlZCwgYm90aCBgeGAgYW5kIGB5YCB3aWxsIGJlIHNldCB0byBgeGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT14XSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZhYmxlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgc2V0KHggPSAwLCB5ID0geCkge1xuICAgIHJldHVybiAodGhpcy5feCAhPT0geCB8fCB0aGlzLl95ICE9PSB5KSAmJiAodGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5LCB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSkpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludCAoYHBgKVxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb20uIENhbiBiZSBhbnkgb2YgdHlwZSB0aGF0IGlzIG9yIGV4dGVuZHMgYElQb2ludERhdGFgXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZhYmxlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgY29weUZyb20ocCkge1xuICAgIHJldHVybiAodGhpcy5feCAhPT0gcC54IHx8IHRoaXMuX3kgIT09IHAueSkgJiYgKHRoaXMuX3ggPSBwLngsIHRoaXMuX3kgPSBwLnksIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHBvaW50J3MgeCBhbmQgeSBpbnRvIHRoYXQgb2YgdGhlIGdpdmVuIHBvaW50IChgcGApXG4gICAqIEBwYXJhbSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgdG8uIENhbiBiZSBhbnkgb2YgdHlwZSB0aGF0IGlzIG9yIGV4dGVuZHMgYElQb2ludERhdGFgXG4gICAqIEByZXR1cm5zIFRoZSBwb2ludCAoYHBgKSB3aXRoIHZhbHVlcyB1cGRhdGVkXG4gICAqL1xuICBjb3B5VG8ocCkge1xuICAgIHJldHVybiBwLnNldCh0aGlzLl94LCB0aGlzLl95KSwgcDtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhbm90aGVyIHBvaW50IChgcGApIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGB4YCBhbmQgYHlgIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLl94ICYmIHAueSA9PT0gdGhpcy5feTtcbiAgfVxuICAvKiogUG9zaXRpb24gb2YgdGhlIG9ic2VydmFibGUgcG9pbnQgb24gdGhlIHggYXhpcy4gKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLl94ICE9PSB2YWx1ZSAmJiAodGhpcy5feCA9IHZhbHVlLCB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSkpO1xuICB9XG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBwb2ludCBvbiB0aGUgeSBheGlzLiAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5feTtcbiAgfVxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMuX3kgIT09IHZhbHVlICYmICh0aGlzLl95ID0gdmFsdWUsIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKSk7XG4gIH1cbn1cbk9ic2VydmFibGVQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvbWF0aDpPYnNlcnZhYmxlUG9pbnQgeD0ke3RoaXMueH0geT0ke3RoaXMueX0gc2NvcGU9JHt0aGlzLnNjb3BlfV1gO1xufTtcbmV4cG9ydCB7XG4gIE9ic2VydmFibGVQb2ludFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVQb2ludC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9NYXRyaXgubWpzXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlUG9pbnQgfSBmcm9tIFwiLi9PYnNlcnZhYmxlUG9pbnQubWpzXCI7XG5jb25zdCBfVHJhbnNmb3JtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpLCB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpLCB0aGlzLnBvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKSwgdGhpcy5zY2FsZSA9IG5ldyBPYnNlcnZhYmxlUG9pbnQodGhpcy5vbkNoYW5nZSwgdGhpcywgMSwgMSksIHRoaXMucGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMub25DaGFuZ2UsIHRoaXMsIDAsIDApLCB0aGlzLnNrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMudXBkYXRlU2tldywgdGhpcywgMCwgMCksIHRoaXMuX3JvdGF0aW9uID0gMCwgdGhpcy5fY3ggPSAxLCB0aGlzLl9zeCA9IDAsIHRoaXMuX2N5ID0gMCwgdGhpcy5fc3kgPSAxLCB0aGlzLl9sb2NhbElEID0gMCwgdGhpcy5fY3VycmVudExvY2FsSUQgPSAwLCB0aGlzLl93b3JsZElEID0gMCwgdGhpcy5fcGFyZW50SUQgPSAwO1xuICB9XG4gIC8qKiBDYWxsZWQgd2hlbiBhIHZhbHVlIGNoYW5nZXMuICovXG4gIG9uQ2hhbmdlKCkge1xuICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICAvKiogQ2FsbGVkIHdoZW4gdGhlIHNrZXcgb3IgdGhlIHJvdGF0aW9uIGNoYW5nZXMuICovXG4gIHVwZGF0ZVNrZXcoKSB7XG4gICAgdGhpcy5fY3ggPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy55KSwgdGhpcy5fc3ggPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy55KSwgdGhpcy5fY3kgPSAtTWF0aC5zaW4odGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcueCksIHRoaXMuX3N5ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcueCksIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4LiAqL1xuICB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgdGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQgJiYgKGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUueCwgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS54LCBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnksIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUueSwgbHQudHggPSB0aGlzLnBvc2l0aW9uLnggLSAodGhpcy5waXZvdC54ICogbHQuYSArIHRoaXMucGl2b3QueSAqIGx0LmMpLCBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCksIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRCwgdGhpcy5fcGFyZW50SUQgPSAtMSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxvY2FsIGFuZCB0aGUgd29ybGQgdHJhbnNmb3JtYXRpb24gbWF0cmljZXMuXG4gICAqIEBwYXJhbSBwYXJlbnRUcmFuc2Zvcm0gLSBUaGUgcGFyZW50IHRyYW5zZm9ybVxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtKHBhcmVudFRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcbiAgICBpZiAodGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQgJiYgKGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUueCwgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS54LCBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnksIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUueSwgbHQudHggPSB0aGlzLnBvc2l0aW9uLnggLSAodGhpcy5waXZvdC54ICogbHQuYSArIHRoaXMucGl2b3QueSAqIGx0LmMpLCBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCksIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRCwgdGhpcy5fcGFyZW50SUQgPSAtMSksIHRoaXMuX3BhcmVudElEICE9PSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgIGNvbnN0IHB0ID0gcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICB3dC5hID0gbHQuYSAqIHB0LmEgKyBsdC5iICogcHQuYywgd3QuYiA9IGx0LmEgKiBwdC5iICsgbHQuYiAqIHB0LmQsIHd0LmMgPSBsdC5jICogcHQuYSArIGx0LmQgKiBwdC5jLCB3dC5kID0gbHQuYyAqIHB0LmIgKyBsdC5kICogcHQuZCwgd3QudHggPSBsdC50eCAqIHB0LmEgKyBsdC50eSAqIHB0LmMgKyBwdC50eCwgd3QudHkgPSBsdC50eCAqIHB0LmIgKyBsdC50eSAqIHB0LmQgKyBwdC50eSwgdGhpcy5fcGFyZW50SUQgPSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQsIHRoaXMuX3dvcmxkSUQrKztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlY29tcG9zZXMgYSBtYXRyaXggYW5kIHNldHMgdGhlIHRyYW5zZm9ybXMgcHJvcGVydGllcyBiYXNlZCBvbiBpdC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gZGVjb21wb3NlXG4gICAqL1xuICBzZXRGcm9tTWF0cml4KG1hdHJpeCkge1xuICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyksIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICAvKiogVGhlIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gcmFkaWFucy4gKi9cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgfVxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9yb3RhdGlvbiAhPT0gdmFsdWUgJiYgKHRoaXMuX3JvdGF0aW9uID0gdmFsdWUsIHRoaXMudXBkYXRlU2tldygpKTtcbiAgfVxufTtcbl9UcmFuc2Zvcm0uSURFTlRJVFkgPSBuZXcgX1RyYW5zZm9ybSgpO1xubGV0IFRyYW5zZm9ybSA9IF9UcmFuc2Zvcm07XG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6VHJhbnNmb3JtIHBvc2l0aW9uPSgke3RoaXMucG9zaXRpb24ueH0sICR7dGhpcy5wb3NpdGlvbi55fSkgcm90YXRpb249JHt0aGlzLnJvdGF0aW9ufSBzY2FsZT0oJHt0aGlzLnNjYWxlLnh9LCAke3RoaXMuc2NhbGUueX0pIHNrZXc9KCR7dGhpcy5za2V3Lnh9LCAke3RoaXMuc2tldy55fSkgXWA7XG59O1xuZXhwb3J0IHtcbiAgVHJhbnNmb3JtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtLm1qcy5tYXBcbiIsImltcG9ydCB7IENpcmNsZSB9IGZyb20gXCIuL3NoYXBlcy9DaXJjbGUubWpzXCI7XG5pbXBvcnQgeyBFbGxpcHNlIH0gZnJvbSBcIi4vc2hhcGVzL0VsbGlwc2UubWpzXCI7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSBcIi4vc2hhcGVzL1BvbHlnb24ubWpzXCI7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi9zaGFwZXMvUmVjdGFuZ2xlLm1qc1wiO1xuaW1wb3J0IHsgUm91bmRlZFJlY3RhbmdsZSB9IGZyb20gXCIuL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLm1qc1wiO1xuaW1wb3J0IHsgZ3JvdXBEOCB9IGZyb20gXCIuL2dyb3VwRDgubWpzXCI7XG5pbXBvcnQgXCIuL0lQb2ludC5tanNcIjtcbmltcG9ydCBcIi4vSVBvaW50RGF0YS5tanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuL01hdHJpeC5tanNcIjtcbmltcG9ydCB7IE9ic2VydmFibGVQb2ludCB9IGZyb20gXCIuL09ic2VydmFibGVQb2ludC5tanNcIjtcbmltcG9ydCB7IFBvaW50IH0gZnJvbSBcIi4vUG9pbnQubWpzXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwiLi9UcmFuc2Zvcm0ubWpzXCI7XG5pbXBvcnQgeyBERUdfVE9fUkFELCBQSV8yLCBSQURfVE9fREVHLCBTSEFQRVMgfSBmcm9tIFwiLi9jb25zdC5tanNcIjtcbmV4cG9ydCB7XG4gIENpcmNsZSxcbiAgREVHX1RPX1JBRCxcbiAgRWxsaXBzZSxcbiAgTWF0cml4LFxuICBPYnNlcnZhYmxlUG9pbnQsXG4gIFBJXzIsXG4gIFBvaW50LFxuICBQb2x5Z29uLFxuICBSQURfVE9fREVHLFxuICBSZWN0YW5nbGUsXG4gIFJvdW5kZWRSZWN0YW5nbGUsXG4gIFNIQVBFUyxcbiAgVHJhbnNmb3JtLFxuICBncm91cEQ4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGRlZmF1bHRGcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbnZvaWQgbWFpbih2b2lkKXtcbiAgIGdsX0ZyYWdDb2xvciAqPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xufWA7XG5leHBvcnQge1xuICBkZWZhdWx0RnJhZ21lbnQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtLmZyYWcubWpzLm1hcFxuIiwidmFyIGRlZmF1bHRWZXJ0ZXggPSBgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZCl7XG4gICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbiAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xufVxuYDtcbmV4cG9ydCB7XG4gIGRlZmF1bHRWZXJ0ZXggYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtLnZlcnQubWpzLm1hcFxuIiwiY29uc3QgdW5pZm9ybVBhcnNlcnMgPSBbXG4gIC8vIGEgZmxvYXQgY2FjaGUgbGF5ZXJcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwiZmxvYXRcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgaWYodXZbXCIke25hbWV9XCJdICE9PSB1ZFtcIiR7bmFtZX1cIl0udmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdWRbXCIke25hbWV9XCJdLnZhbHVlID0gdXZbXCIke25hbWV9XCJdXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdXZbXCIke25hbWV9XCJdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICB9LFxuICAvLyBoYW5kbGluZyBzYW1wbGVyc1xuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuLG5vLWVxLW51bGwsZXFlcWVxXG4gICAgICAoZGF0YS50eXBlID09PSBcInNhbXBsZXIyRFwiIHx8IGRhdGEudHlwZSA9PT0gXCJzYW1wbGVyQ3ViZVwiIHx8IGRhdGEudHlwZSA9PT0gXCJzYW1wbGVyMkRBcnJheVwiKSAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiAodW5pZm9ybSA9PSBudWxsIHx8IHVuaWZvcm0uY2FzdFRvQmFzZVRleHR1cmUgIT09IHZvaWQgMClcbiAgICApLFxuICAgIGNvZGU6IChuYW1lKSA9PiBgdCA9IHN5bmNEYXRhLnRleHR1cmVDb3VudCsrO1xuXG4gICAgICAgICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQodXZbXCIke25hbWV9XCJdLCB0KTtcblxuICAgICAgICAgICAgaWYodWRbXCIke25hbWV9XCJdLnZhbHVlICE9PSB0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVkW1wiJHtuYW1lfVwiXS52YWx1ZSA9IHQ7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdCk7XG47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgfWBcbiAgfSxcbiAgLy8gdXBsb2FkaW5nIHBpeGkgbWF0cml4IG9iamVjdCB0byBtYXQzXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcIm1hdDNcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLmEgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gKFxuICAgICAgLy8gVE9ETyBhbmQgc29tZSBzbWFydCBjYWNoaW5nIGRpcnR5IGlkcyBoZXJlIVxuICAgICAgYFxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIGZhbHNlLCB1dltcIiR7bmFtZX1cIl0udG9BcnJheSh0cnVlKSk7XG4gICAgICAgICAgICBgXG4gICAgKSxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIHZhciAke25hbWV9X21hdHJpeCA9IHV2LiR7bmFtZX0udG9BcnJheSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9ICR7bmFtZX1fbWF0cml4WzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gJHtuYW1lfV9tYXRyaXhbMV07XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSAke25hbWV9X21hdHJpeFsyXTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA0XSA9ICR7bmFtZX1fbWF0cml4WzNdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNV0gPSAke25hbWV9X21hdHJpeFs0XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDZdID0gJHtuYW1lfV9tYXRyaXhbNV07XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPSAke25hbWV9X21hdHJpeFs2XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDldID0gJHtuYW1lfV9tYXRyaXhbN107XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxMF0gPSAke25hbWV9X21hdHJpeFs4XTtcbiAgICAgICAgICAgIGBcbiAgfSxcbiAgLy8gdXBsb2FkaW5nIGEgcGl4aSBwb2ludCBhcyBhIHZlYzIgd2l0aCBjYWNoaW5nIGxheWVyXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcInZlYzJcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLnggIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYueCwgdi55KTtcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi54O1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi55O1xuICAgICAgICAgICAgYFxuICB9LFxuICAvLyBjYWNoaW5nIGxheWVyIGZvciBhIHZlYzJcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjMlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5LFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgfSxcbiAgLy8gdXBsb2FkIGEgcGl4aSByZWN0YW5nbGUgYXMgYSB2ZWM0IHdpdGggY2FjaGluZyBsYXllclxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS53aWR0aCAhPT0gdm9pZCAwLFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSB8fCBjdlsyXSAhPT0gdi53aWR0aCB8fCBjdlszXSAhPT0gdi5oZWlnaHQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdi53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY3ZbM10gPSB2LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi54LCB2LnksIHYud2lkdGgsIHYuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIH1gLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2Lnk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdi53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrM10gPSB2LmhlaWdodDtcbiAgICAgICAgICAgICAgICBgXG4gIH0sXG4gIC8vIHVwbG9hZCBhIHBpeGkgY29sb3IgYXMgdmVjNCB3aXRoIGNhY2hpbmcgbGF5ZXJcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ucmVkICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYucmVkIHx8IGN2WzFdICE9PSB2LmdyZWVuIHx8IGN2WzJdICE9PSB2LmJsdWUgfHwgY3ZbM10gIT09IHYuYWxwaGEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYucmVkO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdi5ibHVlO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHYuYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYucmVkLCB2LmdyZWVuLCB2LmJsdWUsIHYuYWxwaGEpXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzNdID0gdi5hbHBoYTtcbiAgICAgICAgICAgICAgICBgXG4gIH0sXG4gIC8vIHVwbG9hZCBhIHBpeGkgY29sb3IgYXMgYSB2ZWMzIHdpdGggY2FjaGluZyBsYXllclxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWMzXCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS5yZWQgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi5yZWQgfHwgY3ZbMV0gIT09IHYuZ3JlZW4gfHwgY3ZbMl0gIT09IHYuYmx1ZSB8fCBjdlszXSAhPT0gdi5hKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2LnJlZDtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBjdlsyXSA9IHYuYmx1ZTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi5yZWQsIHYuZ3JlZW4sIHYuYmx1ZSlcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2LnJlZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgICAgICBgXG4gIH0sXG4gIC8vIGEgY2FjaGluZyBsYXllciBmb3IgdmVjNCB1cGxvYWRpbmdcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5LFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pXG4gICAgICAgICAgICAgICAgfWBcbiAgfVxuXTtcbmV4cG9ydCB7XG4gIHVuaWZvcm1QYXJzZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pZm9ybVBhcnNlcnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tIFwiLi91bmlmb3JtUGFyc2Vycy5tanNcIjtcbmNvbnN0IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEID0ge1xuICBmbG9hdDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcbiAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2KTtcbiAgICB9YCxcbiAgdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdlswXSwgdlsxXSlcbiAgICB9YCxcbiAgdmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKVxuICAgIH1gLFxuICB2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgfWAsXG4gIGludDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcblxuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBpdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgfWAsXG4gIGl2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIH1gLFxuICBpdmVjNDogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgIGN2WzNdID0gdlszXTtcblxuICAgICAgICBnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICB1aW50OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xdWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICB1dmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0ydWkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICB1dmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTN1aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgfWAsXG4gIHV2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00dWkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICBib29sOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBidmVjMjogYFxuICAgIGlmIChjdlswXSAhPSB2WzBdIHx8IGN2WzFdICE9IHZbMV0pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcblxuICAgICAgICBnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICBidmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICB9YCxcbiAgYnZlYzQ6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgICB9YCxcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgc2FtcGxlcjJEOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXJDdWJlOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXIyREFycmF5OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWBcbn0sIEdMU0xfVE9fQVJSQVlfU0VUVEVSUyA9IHtcbiAgZmxvYXQ6IFwiZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdilcIixcbiAgdmVjMjogXCJnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2KVwiLFxuICB2ZWMzOiBcImdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHYpXCIsXG4gIHZlYzQ6IFwiZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgaW50OiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWMyOiBcImdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWMzOiBcImdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWM0OiBcImdsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpXCIsXG4gIHVpbnQ6IFwiZ2wudW5pZm9ybTF1aXYobG9jYXRpb24sIHYpXCIsXG4gIHV2ZWMyOiBcImdsLnVuaWZvcm0ydWl2KGxvY2F0aW9uLCB2KVwiLFxuICB1dmVjMzogXCJnbC51bmlmb3JtM3Vpdihsb2NhdGlvbiwgdilcIixcbiAgdXZlYzQ6IFwiZ2wudW5pZm9ybTR1aXYobG9jYXRpb24sIHYpXCIsXG4gIGJvb2w6IFwiZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzI6IFwiZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzM6IFwiZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzQ6IFwiZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdilcIixcbiAgc2FtcGxlcjJEOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXJDdWJlOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXIyREFycmF5OiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCJcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgY29uc3QgZnVuY0ZyYWdtZW50cyA9IFtgXG4gICAgICAgIHZhciB2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1ID0gbnVsbDtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBgXTtcbiAgZm9yIChjb25zdCBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgY29uc3QgZGF0YSA9IHVuaWZvcm1EYXRhW2ldO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZ3JvdXAudW5pZm9ybXNbaV0/Lmdyb3VwID09PSAhMCAmJiAoZ3JvdXAudW5pZm9ybXNbaV0udWJvID8gZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUJ1ZmZlckdyb3VwKHV2LiR7aX0sICcke2l9Jyk7XG4gICAgICAgICAgICAgICAgICAgIGApIDogZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUdyb3VwKHV2LiR7aX0sIHN5bmNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1tpXTtcbiAgICBsZXQgcGFyc2VkID0gITE7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKylcbiAgICAgIGlmICh1bmlmb3JtUGFyc2Vyc1tqXS50ZXN0KGRhdGEsIHVuaWZvcm0pKSB7XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaCh1bmlmb3JtUGFyc2Vyc1tqXS5jb2RlKGksIHVuaWZvcm0pKSwgcGFyc2VkID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IChkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSA/IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEIDogR0xTTF9UT19BUlJBWV9TRVRURVJTKVtkYXRhLnR5cGVdLnJlcGxhY2UoXCJsb2NhdGlvblwiLCBgdWRbXCIke2l9XCJdLmxvY2F0aW9uYCk7XG4gICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgY3UgPSB1ZFtcIiR7aX1cIl07XG4gICAgICAgICAgICBjdiA9IGN1LnZhbHVlO1xuICAgICAgICAgICAgdiA9IHV2W1wiJHtpfVwiXTtcbiAgICAgICAgICAgICR7dGVtcGxhdGV9O2ApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidWRcIiwgXCJ1dlwiLCBcInJlbmRlcmVyXCIsIFwic3luY0RhdGFcIiwgZnVuY0ZyYWdtZW50cy5qb2luKGBcbmApKTtcbn1cbmV4cG9ydCB7XG4gIGdlbmVyYXRlVW5pZm9ybXNTeW5jXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmNvbnN0IHVua25vd25Db250ZXh0ID0ge307XG5sZXQgY29udGV4dCA9IHVua25vd25Db250ZXh0O1xuZnVuY3Rpb24gZ2V0VGVzdENvbnRleHQoKSB7XG4gIGlmIChjb250ZXh0ID09PSB1bmtub3duQ29udGV4dCB8fCBjb250ZXh0Py5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICBjb25zdCBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgIGxldCBnbDtcbiAgICBzZXR0aW5ncy5QUkVGRVJfRU5WID49IEVOVi5XRUJHTDIgJiYgKGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwge30pKSwgZ2wgfHwgKGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7fSkgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwge30pLCBnbCA/IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSA6IGdsID0gbnVsbCksIGNvbnRleHQgPSBnbDtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmV4cG9ydCB7XG4gIGdldFRlc3RDb250ZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGVzdENvbnRleHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgUFJFQ0lTSU9OIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0VGVzdENvbnRleHQgfSBmcm9tIFwiLi9nZXRUZXN0Q29udGV4dC5tanNcIjtcbmxldCBtYXhGcmFnbWVudFByZWNpc2lvbjtcbmZ1bmN0aW9uIGdldE1heEZyYWdtZW50UHJlY2lzaW9uKCkge1xuICBpZiAoIW1heEZyYWdtZW50UHJlY2lzaW9uKSB7XG4gICAgbWF4RnJhZ21lbnRQcmVjaXNpb24gPSBQUkVDSVNJT04uTUVESVVNO1xuICAgIGNvbnN0IGdsID0gZ2V0VGVzdENvbnRleHQoKTtcbiAgICBpZiAoZ2wgJiYgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KSB7XG4gICAgICBjb25zdCBzaGFkZXJGcmFnbWVudCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpO1xuICAgICAgc2hhZGVyRnJhZ21lbnQgJiYgKG1heEZyYWdtZW50UHJlY2lzaW9uID0gc2hhZGVyRnJhZ21lbnQucHJlY2lzaW9uID8gUFJFQ0lTSU9OLkhJR0ggOiBQUkVDSVNJT04uTUVESVVNKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heEZyYWdtZW50UHJlY2lzaW9uO1xufVxuZXhwb3J0IHtcbiAgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5tanMubWFwXG4iLCJjb25zdCBHTFNMX1RPX1NJWkUgPSB7XG4gIGZsb2F0OiAxLFxuICB2ZWMyOiAyLFxuICB2ZWMzOiAzLFxuICB2ZWM0OiA0LFxuICBpbnQ6IDEsXG4gIGl2ZWMyOiAyLFxuICBpdmVjMzogMyxcbiAgaXZlYzQ6IDQsXG4gIHVpbnQ6IDEsXG4gIHV2ZWMyOiAyLFxuICB1dmVjMzogMyxcbiAgdXZlYzQ6IDQsXG4gIGJvb2w6IDEsXG4gIGJ2ZWMyOiAyLFxuICBidmVjMzogMyxcbiAgYnZlYzQ6IDQsXG4gIG1hdDI6IDQsXG4gIG1hdDM6IDksXG4gIG1hdDQ6IDE2LFxuICBzYW1wbGVyMkQ6IDFcbn07XG5mdW5jdGlvbiBtYXBTaXplKHR5cGUpIHtcbiAgcmV0dXJuIEdMU0xfVE9fU0laRVt0eXBlXTtcbn1cbmV4cG9ydCB7XG4gIG1hcFNpemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBTaXplLm1qcy5tYXBcbiIsImxldCBHTF9UQUJMRSA9IG51bGw7XG5jb25zdCBHTF9UT19HTFNMX1RZUEVTID0ge1xuICBGTE9BVDogXCJmbG9hdFwiLFxuICBGTE9BVF9WRUMyOiBcInZlYzJcIixcbiAgRkxPQVRfVkVDMzogXCJ2ZWMzXCIsXG4gIEZMT0FUX1ZFQzQ6IFwidmVjNFwiLFxuICBJTlQ6IFwiaW50XCIsXG4gIElOVF9WRUMyOiBcIml2ZWMyXCIsXG4gIElOVF9WRUMzOiBcIml2ZWMzXCIsXG4gIElOVF9WRUM0OiBcIml2ZWM0XCIsXG4gIFVOU0lHTkVEX0lOVDogXCJ1aW50XCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMyOiBcInV2ZWMyXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMzOiBcInV2ZWMzXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUM0OiBcInV2ZWM0XCIsXG4gIEJPT0w6IFwiYm9vbFwiLFxuICBCT09MX1ZFQzI6IFwiYnZlYzJcIixcbiAgQk9PTF9WRUMzOiBcImJ2ZWMzXCIsXG4gIEJPT0xfVkVDNDogXCJidmVjNFwiLFxuICBGTE9BVF9NQVQyOiBcIm1hdDJcIixcbiAgRkxPQVRfTUFUMzogXCJtYXQzXCIsXG4gIEZMT0FUX01BVDQ6IFwibWF0NFwiLFxuICBTQU1QTEVSXzJEOiBcInNhbXBsZXIyRFwiLFxuICBJTlRfU0FNUExFUl8yRDogXCJzYW1wbGVyMkRcIixcbiAgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQ6IFwic2FtcGxlcjJEXCIsXG4gIFNBTVBMRVJfQ1VCRTogXCJzYW1wbGVyQ3ViZVwiLFxuICBJTlRfU0FNUExFUl9DVUJFOiBcInNhbXBsZXJDdWJlXCIsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkU6IFwic2FtcGxlckN1YmVcIixcbiAgU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBJTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiXG59O1xuZnVuY3Rpb24gbWFwVHlwZShnbCwgdHlwZSkge1xuICBpZiAoIUdMX1RBQkxFKSB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG4gICAgR0xfVEFCTEUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICBHTF9UQUJMRVtnbFt0bl1dID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgfVxuICB9XG4gIHJldHVybiBHTF9UQUJMRVt0eXBlXTtcbn1cbmV4cG9ydCB7XG4gIG1hcFR5cGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBUeXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IFBSRUNJU0lPTiB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmZ1bmN0aW9uIHNldFByZWNpc2lvbihzcmMsIHJlcXVlc3RlZFByZWNpc2lvbiwgbWF4U3VwcG9ydGVkUHJlY2lzaW9uKSB7XG4gIGlmIChzcmMuc3Vic3RyaW5nKDAsIDkpICE9PSBcInByZWNpc2lvblwiKSB7XG4gICAgbGV0IHByZWNpc2lvbiA9IHJlcXVlc3RlZFByZWNpc2lvbjtcbiAgICByZXR1cm4gcmVxdWVzdGVkUHJlY2lzaW9uID09PSBQUkVDSVNJT04uSElHSCAmJiBtYXhTdXBwb3J0ZWRQcmVjaXNpb24gIT09IFBSRUNJU0lPTi5ISUdIICYmIChwcmVjaXNpb24gPSBQUkVDSVNJT04uTUVESVVNKSwgYHByZWNpc2lvbiAke3ByZWNpc2lvbn0gZmxvYXQ7XG4ke3NyY31gO1xuICB9IGVsc2UgaWYgKG1heFN1cHBvcnRlZFByZWNpc2lvbiAhPT0gUFJFQ0lTSU9OLkhJR0ggJiYgc3JjLnN1YnN0cmluZygwLCAxNSkgPT09IFwicHJlY2lzaW9uIGhpZ2hwXCIpXG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKFwicHJlY2lzaW9uIGhpZ2hwXCIsIFwicHJlY2lzaW9uIG1lZGl1bXBcIik7XG4gIHJldHVybiBzcmM7XG59XG5leHBvcnQge1xuICBzZXRQcmVjaXNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRQcmVjaXNpb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gXCIuL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzXCI7XG5pbXBvcnQgeyBjb21waWxlU2hhZGVyIH0gZnJvbSBcIi4vY29tcGlsZVNoYWRlci5tanNcIjtcbmltcG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5tanNcIjtcbmltcG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSBcIi4vZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzXCI7XG5pbXBvcnQgeyBnZXRNYXhGcmFnbWVudFByZWNpc2lvbiB9IGZyb20gXCIuL2dldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qc1wiO1xuaW1wb3J0IHsgZ2V0VGVzdENvbnRleHQgfSBmcm9tIFwiLi9nZXRUZXN0Q29udGV4dC5tanNcIjtcbmltcG9ydCB7IGxvZ1Byb2dyYW1FcnJvciB9IGZyb20gXCIuL2xvZ1Byb2dyYW1FcnJvci5tanNcIjtcbmltcG9ydCB7IG1hcFNpemUgfSBmcm9tIFwiLi9tYXBTaXplLm1qc1wiO1xuaW1wb3J0IHsgbWFwVHlwZSB9IGZyb20gXCIuL21hcFR5cGUubWpzXCI7XG5pbXBvcnQgeyBzZXRQcmVjaXNpb24gfSBmcm9tIFwiLi9zZXRQcmVjaXNpb24ubWpzXCI7XG5pbXBvcnQgeyB1bmlmb3JtUGFyc2VycyB9IGZyb20gXCIuL3VuaWZvcm1QYXJzZXJzLm1qc1wiO1xuaW1wb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gXCIuL3Vuc2FmZUV2YWxTdXBwb3J0ZWQubWpzXCI7XG5leHBvcnQge1xuICBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLFxuICBjb21waWxlU2hhZGVyLFxuICBkZWZhdWx0VmFsdWUsXG4gIGdlbmVyYXRlVW5pZm9ybXNTeW5jLFxuICBnZXRNYXhGcmFnbWVudFByZWNpc2lvbixcbiAgZ2V0VGVzdENvbnRleHQsXG4gIGxvZ1Byb2dyYW1FcnJvcixcbiAgbWFwU2l6ZSxcbiAgbWFwVHlwZSxcbiAgc2V0UHJlY2lzaW9uLFxuICB1bmlmb3JtUGFyc2VycyxcbiAgdW5zYWZlRXZhbFN1cHBvcnRlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBSRUNJU0lPTiB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IFByb2dyYW1DYWNoZSwgaXNNb2JpbGUgfSBmcm9tIFwiQHBpeGkvdXRpbHNcIjtcbmltcG9ydCBkZWZhdWx0RnJhZ21lbnQgZnJvbSBcIi4vZGVmYXVsdFByb2dyYW0uZnJhZy5tanNcIjtcbmltcG9ydCBkZWZhdWx0VmVydGV4IGZyb20gXCIuL2RlZmF1bHRQcm9ncmFtLnZlcnQubWpzXCI7XG5pbXBvcnQgXCIuL3V0aWxzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgc2V0UHJlY2lzaW9uIH0gZnJvbSBcIi4vdXRpbHMvc2V0UHJlY2lzaW9uLm1qc1wiO1xuaW1wb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfSBmcm9tIFwiLi91dGlscy9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5tanNcIjtcbmxldCBVSUQgPSAwO1xuY29uc3QgbmFtZUNhY2hlID0ge30sIF9Qcm9ncmFtID0gY2xhc3MgX1Byb2dyYW0yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB2ZXJ0ZXhTcmMgLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAcGFyYW0gZnJhZ21lbnRTcmMgLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBmb3Igc2hhZGVyXG4gICAqIEBwYXJhbSBleHRyYSAtIEV4dHJhIGRhdGEgZm9yIHNoYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSA9IFwicGl4aS1zaGFkZXJcIiwgZXh0cmEgPSB7fSkge1xuICAgIHRoaXMuZXh0cmEgPSB7fSwgdGhpcy5pZCA9IFVJRCsrLCB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBfUHJvZ3JhbTIuZGVmYXVsdFZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IF9Qcm9ncmFtMi5kZWZhdWx0RnJhZ21lbnRTcmMsIHRoaXMudmVydGV4U3JjID0gdGhpcy52ZXJ0ZXhTcmMudHJpbSgpLCB0aGlzLmZyYWdtZW50U3JjID0gdGhpcy5mcmFnbWVudFNyYy50cmltKCksIHRoaXMuZXh0cmEgPSBleHRyYSwgdGhpcy52ZXJ0ZXhTcmMuc3Vic3RyaW5nKDAsIDgpICE9PSBcIiN2ZXJzaW9uXCIgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgXCItXCIpLCBuYW1lQ2FjaGVbbmFtZV0gPyAobmFtZUNhY2hlW25hbWVdKyssIG5hbWUgKz0gYC0ke25hbWVDYWNoZVtuYW1lXX1gKSA6IG5hbWVDYWNoZVtuYW1lXSA9IDEsIHRoaXMudmVydGV4U3JjID0gYCNkZWZpbmUgU0hBREVSX05BTUUgJHtuYW1lfVxuJHt0aGlzLnZlcnRleFNyY31gLCB0aGlzLmZyYWdtZW50U3JjID0gYCNkZWZpbmUgU0hBREVSX05BTUUgJHtuYW1lfVxuJHt0aGlzLmZyYWdtZW50U3JjfWAsIHRoaXMudmVydGV4U3JjID0gc2V0UHJlY2lzaW9uKFxuICAgICAgdGhpcy52ZXJ0ZXhTcmMsXG4gICAgICBfUHJvZ3JhbTIuZGVmYXVsdFZlcnRleFByZWNpc2lvbixcbiAgICAgIFBSRUNJU0lPTi5ISUdIXG4gICAgKSwgdGhpcy5mcmFnbWVudFNyYyA9IHNldFByZWNpc2lvbihcbiAgICAgIHRoaXMuZnJhZ21lbnRTcmMsXG4gICAgICBfUHJvZ3JhbTIuZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uLFxuICAgICAgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24oKVxuICAgICkpLCB0aGlzLmdsUHJvZ3JhbXMgPSB7fSwgdGhpcy5zeW5jVW5pZm9ybXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHNvdXJjZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWZXJ0ZXg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2UuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGcmFnbWVudDtcbiAgfVxuICAvKipcbiAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHByb2dyYW0gYmFzZWQgb2YgYSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlci5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGNhY2hlZCBwcm9ncmFtLlxuICAgKiBAcGFyYW0gdmVydGV4U3JjIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICogQHBhcmFtIGZyYWdtZW50U3JjIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgZm9yIHNoYWRlclxuICAgKiBAcmV0dXJucyBBIHNoaW55IG5ldyBQaXhpSlMgc2hhZGVyIHByb2dyYW0hXG4gICAqL1xuICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKSB7XG4gICAgY29uc3Qga2V5ID0gdmVydGV4U3JjICsgZnJhZ21lbnRTcmM7XG4gICAgbGV0IHByb2dyYW0gPSBQcm9ncmFtQ2FjaGVba2V5XTtcbiAgICByZXR1cm4gcHJvZ3JhbSB8fCAoUHJvZ3JhbUNhY2hlW2tleV0gPSBwcm9ncmFtID0gbmV3IF9Qcm9ncmFtMih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKSksIHByb2dyYW07XG4gIH1cbn07XG5fUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uID0gUFJFQ0lTSU9OLkhJR0gsIC8qKlxuKiBEZWZhdWx0IHNwZWNpZnkgZmxvYXQgcHJlY2lzaW9uIGluIGZyYWdtZW50IHNoYWRlci5cbiogaU9TIGlzIGJlc3Qgc2V0IGF0IGhpZ2hwIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGlqcy9pc3N1ZXMvMzc0MlxuKiBAc3RhdGljXG4qIEB0eXBlIHtQSVhJLlBSRUNJU0lPTn1cbiogQGRlZmF1bHQgUElYSS5QUkVDSVNJT04uTUVESVVNXG4qL1xuX1Byb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uID0gaXNNb2JpbGUuYXBwbGUuZGV2aWNlID8gUFJFQ0lTSU9OLkhJR0ggOiBQUkVDSVNJT04uTUVESVVNO1xubGV0IFByb2dyYW0gPSBfUHJvZ3JhbTtcbmV4cG9ydCB7XG4gIFByb2dyYW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmFtLm1qcy5tYXBcbiIsImltcG9ydCB7IEJVRkZFUl9UWVBFIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcIi4uL2dlb21ldHJ5L0J1ZmZlci5tanNcIjtcbmxldCBVSUQgPSAwO1xuY2xhc3MgVW5pZm9ybUdyb3VwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0IHwgQnVmZmVyfSBbdW5pZm9ybXNdIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLiBPciBhIHBpeGkgYnVmZmVyLlxuICAgKiBAcGFyYW0gaXNTdGF0aWMgLSBVbmlmb3JtcyB3b250IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAqIEBwYXJhbSBpc1VibyAtIElmIHRydWUsIHdpbGwgdHJlYXQgdGhpcyB1bmlmb3JtIGdyb3VwIGFzIGEgdW5pZm9ybSBidWZmZXIgb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IodW5pZm9ybXMsIGlzU3RhdGljLCBpc1Vibykge1xuICAgIHRoaXMuZ3JvdXAgPSAhMCwgdGhpcy5zeW5jVW5pZm9ybXMgPSB7fSwgdGhpcy5kaXJ0eUlkID0gMCwgdGhpcy5pZCA9IFVJRCsrLCB0aGlzLnN0YXRpYyA9ICEhaXNTdGF0aWMsIHRoaXMudWJvID0gISFpc1VibywgdW5pZm9ybXMgaW5zdGFuY2VvZiBCdWZmZXIgPyAodGhpcy5idWZmZXIgPSB1bmlmb3JtcywgdGhpcy5idWZmZXIudHlwZSA9IEJVRkZFUl9UWVBFLlVOSUZPUk1fQlVGRkVSLCB0aGlzLmF1dG9NYW5hZ2UgPSAhMSwgdGhpcy51Ym8gPSAhMCkgOiAodGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zLCB0aGlzLnVibyAmJiAodGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyKG5ldyBGbG9hdDMyQXJyYXkoMSkpLCB0aGlzLmJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuVU5JRk9STV9CVUZGRVIsIHRoaXMuYXV0b01hbmFnZSA9ICEwKSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuZGlydHlJZCsrLCAhdGhpcy5hdXRvTWFuYWdlICYmIHRoaXMuYnVmZmVyICYmIHRoaXMuYnVmZmVyLnVwZGF0ZSgpO1xuICB9XG4gIGFkZChuYW1lLCB1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIGlmICghdGhpcy51Ym8pXG4gICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gbmV3IFVuaWZvcm1Hcm91cCh1bmlmb3JtcywgX3N0YXRpYyk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1VuaWZvcm1Hcm91cF0gdW5pZm9ybSBncm91cHMgaW4gdWJvIG1vZGUgY2Fubm90IGJlIG1vZGlmaWVkLCBvciBoYXZlIHVuaWZvcm0gZ3JvdXBzIG5lc3RlZCBpbiB0aGVtXCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tKHVuaWZvcm1zLCBfc3RhdGljLCBfdWJvKSB7XG4gICAgcmV0dXJuIG5ldyBVbmlmb3JtR3JvdXAodW5pZm9ybXMsIF9zdGF0aWMsIF91Ym8pO1xuICB9XG4gIC8qKlxuICAgKiBBIHNob3J0IGhhbmQgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgc3RhdGljIFVCTyBVbmlmb3JtR3JvdXAuXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIHRoZSB1Ym8gaXRlbVxuICAgKiBAcGFyYW0gX3N0YXRpYyAtIHNob3VsZCB0aGlzIGJlIHVwZGF0ZWQgZWFjaCB0aW1lIGl0IGlzIHVzZWQ/IGRlZmF1bHRzIHRvIHRydWUgaGVyZSFcbiAgICovXG4gIHN0YXRpYyB1Ym9Gcm9tKHVuaWZvcm1zLCBfc3RhdGljKSB7XG4gICAgcmV0dXJuIG5ldyBVbmlmb3JtR3JvdXAodW5pZm9ybXMsIF9zdGF0aWMgPz8gITAsICEwKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVW5pZm9ybUdyb3VwXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5pZm9ybUdyb3VwLm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJAcGl4aS9ydW5uZXJcIjtcbmltcG9ydCB7IFByb2dyYW0gfSBmcm9tIFwiLi9Qcm9ncmFtLm1qc1wiO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSBcIi4vVW5pZm9ybUdyb3VwLm1qc1wiO1xuY2xhc3MgU2hhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gVGhlIHByb2dyYW0gdGhlIHNoYWRlciB3aWxsIHVzZS5cbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybXMpIHtcbiAgICB0aGlzLnVuaWZvcm1CaW5kQ291bnQgPSAwLCB0aGlzLnByb2dyYW0gPSBwcm9ncmFtLCB1bmlmb3JtcyA/IHVuaWZvcm1zIGluc3RhbmNlb2YgVW5pZm9ybUdyb3VwID8gdGhpcy51bmlmb3JtR3JvdXAgPSB1bmlmb3JtcyA6IHRoaXMudW5pZm9ybUdyb3VwID0gbmV3IFVuaWZvcm1Hcm91cCh1bmlmb3JtcykgOiB0aGlzLnVuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXAoe30pLCB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKFwiZGlzcG9zZVNoYWRlclwiKTtcbiAgfVxuICAvLyBUT0RPIG1vdmUgdG8gc2hhZGVyIHN5c3RlbS4uXG4gIGNoZWNrVW5pZm9ybUV4aXN0cyhuYW1lLCBncm91cCkge1xuICAgIGlmIChncm91cC51bmlmb3Jtc1tuYW1lXSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gZ3JvdXAudW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1tpXTtcbiAgICAgIGlmICh1bmlmb3JtLmdyb3VwID09PSAhMCAmJiB0aGlzLmNoZWNrVW5pZm9ybUV4aXN0cyhuYW1lLCB1bmlmb3JtKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG51bGwsIHRoaXMuZGlzcG9zZVJ1bm5lci5lbWl0KHRoaXMpLCB0aGlzLmRpc3Bvc2VSdW5uZXIuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBTaGFkZXIgdW5pZm9ybSB2YWx1ZXMsIHNob3J0Y3V0IGZvciBgdW5pZm9ybUdyb3VwLnVuaWZvcm1zYC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zO1xuICB9XG4gIC8qKlxuICAgKiBBIHNob3J0IGhhbmQgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2hhZGVyIGJhc2VkIG9mIGEgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIuXG4gICAqIEBwYXJhbSB2ZXJ0ZXhTcmMgLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAcGFyYW0gZnJhZ21lbnRTcmMgLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIEN1c3RvbSB1bmlmb3JtcyB0byB1c2UgdG8gYXVnbWVudCB0aGUgYnVpbHQtaW4gb25lcy5cbiAgICogQHJldHVybnMgQSBzaGlueSBuZXcgUGl4aUpTIHNoYWRlciFcbiAgICovXG4gIHN0YXRpYyBmcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IFByb2dyYW0uZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICByZXR1cm4gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFNoYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYWRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiQHBpeGkvbWF0aFwiO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gXCIuLi9zaGFkZXIvUHJvZ3JhbS5tanNcIjtcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuLi9zaGFkZXIvU2hhZGVyLm1qc1wiO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSBcIi4uL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzXCI7XG5jbGFzcyBCYXRjaFNoYWRlckdlbmVyYXRvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdmVydGV4U3JjIC0gVmVydGV4IHNoYWRlclxuICAgKiBAcGFyYW0gZnJhZ1RlbXBsYXRlIC0gRnJhZ21lbnQgc2hhZGVyIHRlbXBsYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdUZW1wbGF0ZSkge1xuICAgIGlmICh0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYywgdGhpcy5mcmFnVGVtcGxhdGUgPSBmcmFnVGVtcGxhdGUsIHRoaXMucHJvZ3JhbUNhY2hlID0ge30sIHRoaXMuZGVmYXVsdEdyb3VwQ2FjaGUgPSB7fSwgIWZyYWdUZW1wbGF0ZS5pbmNsdWRlcyhcIiVjb3VudCVcIikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYWdtZW50IHRlbXBsYXRlIG11c3QgY29udGFpbiBcIiVjb3VudCVcIi4nKTtcbiAgICBpZiAoIWZyYWdUZW1wbGF0ZS5pbmNsdWRlcyhcIiVmb3Jsb29wJVwiKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhZ21lbnQgdGVtcGxhdGUgbXVzdCBjb250YWluIFwiJWZvcmxvb3AlXCIuJyk7XG4gIH1cbiAgZ2VuZXJhdGVTaGFkZXIobWF4VGV4dHVyZXMpIHtcbiAgICBpZiAoIXRoaXMucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSkge1xuICAgICAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkobWF4VGV4dHVyZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKVxuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xuICAgICAgdGhpcy5kZWZhdWx0R3JvdXBDYWNoZVttYXhUZXh0dXJlc10gPSBVbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sICEwKTtcbiAgICAgIGxldCBmcmFnbWVudFNyYyA9IHRoaXMuZnJhZ1RlbXBsYXRlO1xuICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lY291bnQlL2dpLCBgJHttYXhUZXh0dXJlc31gKSwgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIHRoaXMuZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpKSwgdGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdID0gbmV3IFByb2dyYW0odGhpcy52ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICB0aW50OiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXG4gICAgICB0cmFuc2xhdGlvbk1hdHJpeDogbmV3IE1hdHJpeCgpLFxuICAgICAgZGVmYXVsdDogdGhpcy5kZWZhdWx0R3JvdXBDYWNoZVttYXhUZXh0dXJlc11cbiAgICB9O1xuICAgIHJldHVybiBuZXcgU2hhZGVyKHRoaXMucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSwgdW5pZm9ybXMpO1xuICB9XG4gIGdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSB7XG4gICAgbGV0IHNyYyA9IFwiXCI7XG4gICAgc3JjICs9IGBcbmAsIHNyYyArPSBgXG5gO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKylcbiAgICAgIGkgPiAwICYmIChzcmMgKz0gYFxuZWxzZSBgKSwgaSA8IG1heFRleHR1cmVzIC0gMSAmJiAoc3JjICs9IGBpZih2VGV4dHVyZUlkIDwgJHtpfS41KWApLCBzcmMgKz0gYFxue2AsIHNyYyArPSBgXG5cdGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyc1ske2l9XSwgdlRleHR1cmVDb29yZCk7YCwgc3JjICs9IGBcbn1gO1xuICAgIHJldHVybiBzcmMgKz0gYFxuYCwgc3JjICs9IGBcbmAsIHNyYztcbiAgfVxufVxuZXhwb3J0IHtcbiAgQmF0Y2hTaGFkZXJHZW5lcmF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFNoYWRlckdlbmVyYXRvci5tanMubWFwXG4iLCJjbGFzcyBCYXRjaFRleHR1cmVBcnJheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXSwgdGhpcy5pZHMgPSBbXSwgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpKyspXG4gICAgICB0aGlzLmVsZW1lbnRzW2ldID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQmF0Y2hUZXh0dXJlQXJyYXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFRleHR1cmVBcnJheS5tanMubWFwXG4iLCJpbXBvcnQgeyBpc01vYmlsZSB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuZnVuY3Rpb24gY2FuVXBsb2FkU2FtZUJ1ZmZlcigpIHtcbiAgcmV0dXJuICFpc01vYmlsZS5hcHBsZS5kZXZpY2U7XG59XG5leHBvcnQge1xuICBjYW5VcGxvYWRTYW1lQnVmZmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuVXBsb2FkU2FtZUJ1ZmZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncywgaXNNb2JpbGUgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmZ1bmN0aW9uIG1heFJlY29tbWVuZGVkVGV4dHVyZXMobWF4KSB7XG4gIGxldCBhbGxvd01heCA9ICEwO1xuICBjb25zdCBuYXZpZ2F0b3IgPSBzZXR0aW5ncy5BREFQVEVSLmdldE5hdmlnYXRvcigpO1xuICBpZiAoaXNNb2JpbGUudGFibGV0IHx8IGlzTW9iaWxlLnBob25lKSB7XG4gICAgaWYgKGlzTW9iaWxlLmFwcGxlLmRldmljZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9PUyAoXFxkKylfKFxcZCspPy8pO1xuICAgICAgbWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSA8IDExICYmIChhbGxvd01heCA9ICExKTtcbiAgICB9XG4gICAgaWYgKGlzTW9iaWxlLmFuZHJvaWQuZGV2aWNlKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWRcXHMoWzAtOS5dKikvKTtcbiAgICAgIG1hdGNoICYmIHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgPCA3ICYmIChhbGxvd01heCA9ICExKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbG93TWF4ID8gbWF4IDogNDtcbn1cbmV4cG9ydCB7XG4gIG1heFJlY29tbWVuZGVkVGV4dHVyZXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcy5tYXBcbiIsImNsYXNzIE9iamVjdFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqIFN0dWIgbWV0aG9kIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZW1wdHkgdGhlIGN1cnJlbnQgYmF0Y2ggYnkgcmVuZGVyaW5nIG9iamVjdHMgbm93LiAqL1xuICBmbHVzaCgpIHtcbiAgfVxuICAvKiogR2VuZXJpYyBkZXN0cnVjdGlvbiBtZXRob2QgdGhhdCBmcmVlcyBhbGwgcmVzb3VyY2VzLiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYnkgc3ViY2xhc3Nlcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU3R1YiBtZXRob2QgdGhhdCBpbml0aWFsaXplcyBhbnkgc3RhdGUgcmVxdWlyZWQgYmVmb3JlXG4gICAqIHJlbmRlcmluZyBzdGFydHMuIEl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBgcHJlcmVuZGVyYFxuICAgKiBzaWduYWwsIHdoaWNoIG9jY3VycyBldmVyeSBmcmFtZSwgaW4gdGhhdCBpdCBpcyBjYWxsZWRcbiAgICogd2hlbmV2ZXIgYW4gb2JqZWN0IHJlcXVlc3RzIF90aGlzXyByZW5kZXJlciBzcGVjaWZpY2FsbHkuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgfVxuICAvKiogU3RvcHMgdGhlIHJlbmRlcmVyLiBJdCBzaG91bGQgZnJlZSB1cCBhbnkgc3RhdGUgYW5kIGJlY29tZSBkb3JtYW50LiAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxuICAvKipcbiAgICogS2VlcHMgdGhlIG9iamVjdCB0byByZW5kZXIuIEl0IGRvZXNuJ3QgaGF2ZSB0byBiZVxuICAgKiByZW5kZXJlZCBpbW1lZGlhdGVseS5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IF9vYmplY3QgLSBUaGUgb2JqZWN0IHRvIHJlbmRlci5cbiAgICovXG4gIHJlbmRlcihfb2JqZWN0KSB7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIE9iamVjdFJlbmRlcmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0UmVuZGVyZXIubWpzLm1hcFxuIiwidmFyIGRlZmF1bHRGcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSWQ7XG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcnNbJWNvdW50JV07XG5cbnZvaWQgbWFpbih2b2lkKXtcbiAgICB2ZWM0IGNvbG9yO1xuICAgICVmb3Jsb29wJVxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogdkNvbG9yO1xufVxuYDtcbmV4cG9ydCB7XG4gIGRlZmF1bHRGcmFnbWVudCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS5mcmFnLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0VmVydGV4ID0gYHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG5hdHRyaWJ1dGUgZmxvYXQgYVRleHR1cmVJZDtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XG51bmlmb3JtIHZlYzQgdGludDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xuXG52b2lkIG1haW4odm9pZCl7XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcblxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgIHZUZXh0dXJlSWQgPSBhVGV4dHVyZUlkO1xuICAgIHZDb2xvciA9IGFDb2xvciAqIHRpbnQ7XG59XG5gO1xuZXhwb3J0IHtcbiAgZGVmYXVsdFZlcnRleCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS52ZXJ0Lm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSBcIkBwaXhpL2NvbG9yXCI7XG5pbXBvcnQgeyBFTlYgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgcHJlbXVsdGlwbHlCbGVuZE1vZGUsIG5leHRQb3cyLCBsb2cyIH0gZnJvbSBcIkBwaXhpL3V0aWxzXCI7XG5pbXBvcnQgeyBWaWV3YWJsZUJ1ZmZlciB9IGZyb20gXCIuLi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5tanNcIjtcbmltcG9ydCB7IGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgfSBmcm9tIFwiLi4vc2hhZGVyL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIubWpzXCI7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gXCIuLi9zdGF0ZS9TdGF0ZS5tanNcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcIi4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgQmF0Y2hEcmF3Q2FsbCB9IGZyb20gXCIuL0JhdGNoRHJhd0NhbGwubWpzXCI7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSBcIi4vQmF0Y2hHZW9tZXRyeS5tanNcIjtcbmltcG9ydCB7IEJhdGNoU2hhZGVyR2VuZXJhdG9yIH0gZnJvbSBcIi4vQmF0Y2hTaGFkZXJHZW5lcmF0b3IubWpzXCI7XG5pbXBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gXCIuL0JhdGNoVGV4dHVyZUFycmF5Lm1qc1wiO1xuaW1wb3J0IHsgY2FuVXBsb2FkU2FtZUJ1ZmZlciB9IGZyb20gXCIuL2NhblVwbG9hZFNhbWVCdWZmZXIubWpzXCI7XG5pbXBvcnQgeyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzIH0gZnJvbSBcIi4vbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanNcIjtcbmltcG9ydCB7IE9iamVjdFJlbmRlcmVyIH0gZnJvbSBcIi4vT2JqZWN0UmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgZGVmYXVsdEZyYWdtZW50IGZyb20gXCIuL3RleHR1cmUuZnJhZy5tanNcIjtcbmltcG9ydCBkZWZhdWx0VmVydGV4IGZyb20gXCIuL3RleHR1cmUudmVydC5tanNcIjtcbmNvbnN0IF9CYXRjaFJlbmRlcmVyID0gY2xhc3MgX0JhdGNoUmVuZGVyZXIyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIge1xuICAvKipcbiAgICogVGhpcyB3aWxsIGhvb2sgb250byB0aGUgcmVuZGVyZXIncyBgY29udGV4dENoYW5nZWBcbiAgICogYW5kIGBwcmVyZW5kZXJgIHNpZ25hbHMuXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKSwgdGhpcy5zZXRTaGFkZXJHZW5lcmF0b3IoKSwgdGhpcy5nZW9tZXRyeUNsYXNzID0gQmF0Y2hHZW9tZXRyeSwgdGhpcy52ZXJ0ZXhTaXplID0gNiwgdGhpcy5zdGF0ZSA9IFN0YXRlLmZvcjJkKCksIHRoaXMuc2l6ZSA9IF9CYXRjaFJlbmRlcmVyMi5kZWZhdWx0QmF0Y2hTaXplICogNCwgdGhpcy5fdmVydGV4Q291bnQgPSAwLCB0aGlzLl9pbmRleENvdW50ID0gMCwgdGhpcy5fYnVmZmVyZWRFbGVtZW50cyA9IFtdLCB0aGlzLl9idWZmZXJlZFRleHR1cmVzID0gW10sIHRoaXMuX2J1ZmZlclNpemUgPSAwLCB0aGlzLl9zaGFkZXIgPSBudWxsLCB0aGlzLl9wYWNrZWRHZW9tZXRyaWVzID0gW10sIHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemUgPSAyLCB0aGlzLl9mbHVzaElkID0gMCwgdGhpcy5fYUJ1ZmZlcnMgPSB7fSwgdGhpcy5faUJ1ZmZlcnMgPSB7fSwgdGhpcy5tYXhUZXh0dXJlcyA9IDEsIHRoaXMucmVuZGVyZXIub24oXCJwcmVyZW5kZXJcIiwgdGhpcy5vblByZXJlbmRlciwgdGhpcyksIHJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5hZGQodGhpcyksIHRoaXMuX2RjSW5kZXggPSAwLCB0aGlzLl9hSW5kZXggPSAwLCB0aGlzLl9pSW5kZXggPSAwLCB0aGlzLl9hdHRyaWJ1dGVCdWZmZXIgPSBudWxsLCB0aGlzLl9pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuX3RlbXBCb3VuZFRleHR1cmVzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHRleHR1cmVzIHRoYXQgdGhpcyBkZXZpY2Ugc3VwcG9ydHMuXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgMzJcbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE1heFRleHR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0TWF4VGV4dHVyZXMgPSB0aGlzLl9kZWZhdWx0TWF4VGV4dHVyZXMgPz8gbWF4UmVjb21tZW5kZWRUZXh0dXJlcygzMiksIHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcztcbiAgfVxuICBzdGF0aWMgc2V0IGRlZmF1bHRNYXhUZXh0dXJlcyh2YWx1ZSkge1xuICAgIHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYW4gd2UgdXBsb2FkIHRoZSBzYW1lIGJ1ZmZlciBpbiBhIHNpbmdsZSBmcmFtZT9cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGdldCBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyID0gdGhpcy5fY2FuVXBsb2FkU2FtZUJ1ZmZlciA/PyBjYW5VcGxvYWRTYW1lQnVmZmVyKCksIHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXI7XG4gIH1cbiAgc3RhdGljIHNldCBjYW5VcGxvYWRTYW1lQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fY2FuVXBsb2FkU2FtZUJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIFBJWEkuQmF0Y2hSZW5kZXJlciNtYXhUZXh0dXJlc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBNQVhfVEVYVFVSRVMoKSB7XG4gICAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJCYXRjaFJlbmRlcmVyI01BWF9URVhUVVJFUyByZW5hbWVkIHRvIEJhdGNoUmVuZGVyZXIjbWF4VGV4dHVyZXNcIiksIHRoaXMubWF4VGV4dHVyZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgIHJldHVybiBkZWZhdWx0VmVydGV4O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBmcmFnbWVudCBzaGFkZXIgc291cmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZyYWdtZW50O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHNoYWRlciBnZW5lcmF0b3IuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZlcnRleD1QSVhJLkJhdGNoUmVuZGVyZXIuZGVmYXVsdFZlcnRleFNyY10gLSBWZXJ0ZXggc2hhZGVyIHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZnJhZ21lbnQ9UElYSS5CYXRjaFJlbmRlcmVyLmRlZmF1bHRGcmFnbWVudFRlbXBsYXRlXSAtIEZyYWdtZW50IHNoYWRlciB0ZW1wbGF0ZVxuICAgKi9cbiAgc2V0U2hhZGVyR2VuZXJhdG9yKHtcbiAgICB2ZXJ0ZXggPSBfQmF0Y2hSZW5kZXJlcjIuZGVmYXVsdFZlcnRleFNyYyxcbiAgICBmcmFnbWVudCA9IF9CYXRjaFJlbmRlcmVyMi5kZWZhdWx0RnJhZ21lbnRUZW1wbGF0ZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLnNoYWRlckdlbmVyYXRvciA9IG5ldyBCYXRjaFNoYWRlckdlbmVyYXRvcih2ZXJ0ZXgsIGZyYWdtZW50KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgYGNvbnRleHRDaGFuZ2VgIHNpZ25hbC5cbiAgICpcbiAgICogSXQgY2FsY3VsYXRlcyBgdGhpcy5tYXhUZXh0dXJlc2AgYW5kIGFsbG9jYXRpbmcgdGhlIHBhY2tlZC1nZW9tZXRyeSBvYmplY3QgcG9vbC5cbiAgICovXG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHNldHRpbmdzLlBSRUZFUl9FTlYgPT09IEVOVi5XRUJHTF9MRUdBQ1kgPyB0aGlzLm1heFRleHR1cmVzID0gMSA6ICh0aGlzLm1heFRleHR1cmVzID0gTWF0aC5taW4oXG4gICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgICAgX0JhdGNoUmVuZGVyZXIyLmRlZmF1bHRNYXhUZXh0dXJlc1xuICAgICksIHRoaXMubWF4VGV4dHVyZXMgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyKFxuICAgICAgdGhpcy5tYXhUZXh0dXJlcyxcbiAgICAgIGdsXG4gICAgKSksIHRoaXMuX3NoYWRlciA9IHRoaXMuc2hhZGVyR2VuZXJhdG9yLmdlbmVyYXRlU2hhZGVyKHRoaXMubWF4VGV4dHVyZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZTsgaSsrKVxuICAgICAgdGhpcy5fcGFja2VkR2VvbWV0cmllc1tpXSA9IG5ldyB0aGlzLmdlb21ldHJ5Q2xhc3MoKTtcbiAgICB0aGlzLmluaXRGbHVzaEJ1ZmZlcnMoKTtcbiAgfVxuICAvKiogTWFrZXMgc3VyZSB0aGF0IHN0YXRpYyBhbmQgZHluYW1pYyBmbHVzaCBwb29sZWQgb2JqZWN0cyBoYXZlIGNvcnJlY3QgZGltZW5zaW9ucy4gKi9cbiAgaW5pdEZsdXNoQnVmZmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd0NhbGxQb29sLFxuICAgICAgX3RleHR1cmVBcnJheVBvb2xcbiAgICB9ID0gX0JhdGNoUmVuZGVyZXIyLCBNQVhfU1BSSVRFUyA9IHRoaXMuc2l6ZSAvIDQsIE1BWF9UQSA9IE1hdGguZmxvb3IoTUFYX1NQUklURVMgLyB0aGlzLm1heFRleHR1cmVzKSArIDE7XG4gICAgZm9yICg7IF9kcmF3Q2FsbFBvb2wubGVuZ3RoIDwgTUFYX1NQUklURVM7IClcbiAgICAgIF9kcmF3Q2FsbFBvb2wucHVzaChuZXcgQmF0Y2hEcmF3Q2FsbCgpKTtcbiAgICBmb3IgKDsgX3RleHR1cmVBcnJheVBvb2wubGVuZ3RoIDwgTUFYX1RBOyApXG4gICAgICBfdGV4dHVyZUFycmF5UG9vbC5wdXNoKG5ldyBCYXRjaFRleHR1cmVBcnJheSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4VGV4dHVyZXM7IGkrKylcbiAgICAgIHRoaXMuX3RlbXBCb3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgfVxuICAvKiogSGFuZGxlcyB0aGUgYHByZXJlbmRlcmAgc2lnbmFsLiBJdCBlbnN1cmVzIHRoYXQgZmx1c2hlcyBzdGFydCBmcm9tIHRoZSBmaXJzdCBnZW9tZXRyeSBvYmplY3QgYWdhaW4uICovXG4gIG9uUHJlcmVuZGVyKCkge1xuICAgIHRoaXMuX2ZsdXNoSWQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBCdWZmZXJzIHRoZSBcImJhdGNoYWJsZVwiIG9iamVjdC4gSXQgbmVlZCBub3QgYmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gcmVuZGVyIHdoZW5cbiAgICogICAgdXNpbmcgdGhpcyByZW5kZXJlclxuICAgKi9cbiAgcmVuZGVyKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50Ll90ZXh0dXJlLnZhbGlkICYmICh0aGlzLl92ZXJ0ZXhDb3VudCArIGVsZW1lbnQudmVydGV4RGF0YS5sZW5ndGggLyAyID4gdGhpcy5zaXplICYmIHRoaXMuZmx1c2goKSwgdGhpcy5fdmVydGV4Q291bnQgKz0gZWxlbWVudC52ZXJ0ZXhEYXRhLmxlbmd0aCAvIDIsIHRoaXMuX2luZGV4Q291bnQgKz0gZWxlbWVudC5pbmRpY2VzLmxlbmd0aCwgdGhpcy5fYnVmZmVyZWRUZXh0dXJlc1t0aGlzLl9idWZmZXJTaXplXSA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUsIHRoaXMuX2J1ZmZlcmVkRWxlbWVudHNbdGhpcy5fYnVmZmVyU2l6ZSsrXSA9IGVsZW1lbnQpO1xuICB9XG4gIGJ1aWxkVGV4dHVyZXNBbmREcmF3Q2FsbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2J1ZmZlcmVkVGV4dHVyZXM6IHRleHR1cmVzLFxuICAgICAgbWF4VGV4dHVyZXNcbiAgICB9ID0gdGhpcywgdGV4dHVyZUFycmF5cyA9IF9CYXRjaFJlbmRlcmVyMi5fdGV4dHVyZUFycmF5UG9vbCwgYmF0Y2ggPSB0aGlzLnJlbmRlcmVyLmJhdGNoLCBib3VuZFRleHR1cmVzID0gdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXMsIHRvdWNoID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG4gICAgbGV0IFRJQ0sgPSArK0Jhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCwgY291bnRUZXhBcnJheXMgPSAwLCB0ZXhBcnJheSA9IHRleHR1cmVBcnJheXNbMF0sIHN0YXJ0ID0gMDtcbiAgICBiYXRjaC5jb3B5Qm91bmRUZXh0dXJlcyhib3VuZFRleHR1cmVzLCBtYXhUZXh0dXJlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJTaXplOyArK2kpIHtcbiAgICAgIGNvbnN0IHRleCA9IHRleHR1cmVzW2ldO1xuICAgICAgdGV4dHVyZXNbaV0gPSBudWxsLCB0ZXguX2JhdGNoRW5hYmxlZCAhPT0gVElDSyAmJiAodGV4QXJyYXkuY291bnQgPj0gbWF4VGV4dHVyZXMgJiYgKGJhdGNoLmJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIFRJQ0ssIG1heFRleHR1cmVzKSwgdGhpcy5idWlsZERyYXdDYWxscyh0ZXhBcnJheSwgc3RhcnQsIGkpLCBzdGFydCA9IGksIHRleEFycmF5ID0gdGV4dHVyZUFycmF5c1srK2NvdW50VGV4QXJyYXlzXSwgKytUSUNLKSwgdGV4Ll9iYXRjaEVuYWJsZWQgPSBUSUNLLCB0ZXgudG91Y2hlZCA9IHRvdWNoLCB0ZXhBcnJheS5lbGVtZW50c1t0ZXhBcnJheS5jb3VudCsrXSA9IHRleCk7XG4gICAgfVxuICAgIHRleEFycmF5LmNvdW50ID4gMCAmJiAoYmF0Y2guYm91bmRBcnJheSh0ZXhBcnJheSwgYm91bmRUZXh0dXJlcywgVElDSywgbWF4VGV4dHVyZXMpLCB0aGlzLmJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgdGhpcy5fYnVmZmVyU2l6ZSksICsrY291bnRUZXhBcnJheXMsICsrVElDSyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKVxuICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gVElDSztcbiAgfVxuICAvKipcbiAgICogUG9wdWxhdGluZyBkcmF3Y2FsbHMgZm9yIHJlbmRlcmluZ1xuICAgKiBAcGFyYW0gdGV4QXJyYXlcbiAgICogQHBhcmFtIHN0YXJ0XG4gICAqIEBwYXJhbSBmaW5pc2hcbiAgICovXG4gIGJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgZmluaXNoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2J1ZmZlcmVkRWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgX2F0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgIF9pbmRleEJ1ZmZlcixcbiAgICAgIHZlcnRleFNpemVcbiAgICB9ID0gdGhpcywgZHJhd0NhbGxzID0gX0JhdGNoUmVuZGVyZXIyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGRjSW5kZXggPSB0aGlzLl9kY0luZGV4LCBhSW5kZXggPSB0aGlzLl9hSW5kZXgsIGlJbmRleCA9IHRoaXMuX2lJbmRleCwgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbZGNJbmRleF07XG4gICAgZHJhd0NhbGwuc3RhcnQgPSB0aGlzLl9pSW5kZXgsIGRyYXdDYWxsLnRleEFycmF5ID0gdGV4QXJyYXk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZmluaXNoOyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGVsZW1lbnRzW2ldLCB0ZXggPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmUsIHNwcml0ZUJsZW5kTW9kZSA9IHByZW11bHRpcGx5QmxlbmRNb2RlW3RleC5hbHBoYU1vZGUgPyAxIDogMF1bc3ByaXRlLmJsZW5kTW9kZV07XG4gICAgICBlbGVtZW50c1tpXSA9IG51bGwsIHN0YXJ0IDwgaSAmJiBkcmF3Q2FsbC5ibGVuZCAhPT0gc3ByaXRlQmxlbmRNb2RlICYmIChkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQsIHN0YXJ0ID0gaSwgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbKytkY0luZGV4XSwgZHJhd0NhbGwudGV4QXJyYXkgPSB0ZXhBcnJheSwgZHJhd0NhbGwuc3RhcnQgPSBpSW5kZXgpLCB0aGlzLnBhY2tJbnRlcmxlYXZlZEdlb21ldHJ5KHNwcml0ZSwgX2F0dHJpYnV0ZUJ1ZmZlciwgX2luZGV4QnVmZmVyLCBhSW5kZXgsIGlJbmRleCksIGFJbmRleCArPSBzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyICogdmVydGV4U2l6ZSwgaUluZGV4ICs9IHNwcml0ZS5pbmRpY2VzLmxlbmd0aCwgZHJhd0NhbGwuYmxlbmQgPSBzcHJpdGVCbGVuZE1vZGU7XG4gICAgfVxuICAgIHN0YXJ0IDwgZmluaXNoICYmIChkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQsICsrZGNJbmRleCksIHRoaXMuX2RjSW5kZXggPSBkY0luZGV4LCB0aGlzLl9hSW5kZXggPSBhSW5kZXgsIHRoaXMuX2lJbmRleCA9IGlJbmRleDtcbiAgfVxuICAvKipcbiAgICogQmluZCB0ZXh0dXJlcyBmb3IgY3VycmVudCByZW5kZXJpbmdcbiAgICogQHBhcmFtIHRleEFycmF5XG4gICAqL1xuICBiaW5kQW5kQ2xlYXJUZXhBcnJheSh0ZXhBcnJheSkge1xuICAgIGNvbnN0IHRleHR1cmVTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXhBcnJheS5jb3VudDsgaisrKVxuICAgICAgdGV4dHVyZVN5c3RlbS5iaW5kKHRleEFycmF5LmVsZW1lbnRzW2pdLCB0ZXhBcnJheS5pZHNbal0pLCB0ZXhBcnJheS5lbGVtZW50c1tqXSA9IG51bGw7XG4gICAgdGV4QXJyYXkuY291bnQgPSAwO1xuICB9XG4gIHVwZGF0ZUdlb21ldHJ5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9wYWNrZWRHZW9tZXRyaWVzOiBwYWNrZWRHZW9tZXRyaWVzLFxuICAgICAgX2F0dHJpYnV0ZUJ1ZmZlcjogYXR0cmlidXRlQnVmZmVyLFxuICAgICAgX2luZGV4QnVmZmVyOiBpbmRleEJ1ZmZlclxuICAgIH0gPSB0aGlzO1xuICAgIF9CYXRjaFJlbmRlcmVyMi5jYW5VcGxvYWRTYW1lQnVmZmVyID8gKHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2J1ZmZlci51cGRhdGUoYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEpLCBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9pbmRleEJ1ZmZlci51cGRhdGUoaW5kZXhCdWZmZXIpLCB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKSkgOiAodGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA8PSB0aGlzLl9mbHVzaElkICYmICh0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplKyssIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0gPSBuZXcgdGhpcy5nZW9tZXRyeUNsYXNzKCkpLCBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9idWZmZXIudXBkYXRlKGF0dHJpYnV0ZUJ1ZmZlci5yYXdCaW5hcnlEYXRhKSwgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyKSwgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS5iaW5kKHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0pLCB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKSwgdGhpcy5fZmx1c2hJZCsrKTtcbiAgfVxuICBkcmF3QmF0Y2hlcygpIHtcbiAgICBjb25zdCBkY0NvdW50ID0gdGhpcy5fZGNJbmRleCwgeyBnbCwgc3RhdGU6IHN0YXRlU3lzdGVtIH0gPSB0aGlzLnJlbmRlcmVyLCBkcmF3Q2FsbHMgPSBfQmF0Y2hSZW5kZXJlcjIuX2RyYXdDYWxsUG9vbDtcbiAgICBsZXQgY3VyVGV4QXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHRleEFycmF5LCB0eXBlLCBzaXplLCBzdGFydCwgYmxlbmQgfSA9IGRyYXdDYWxsc1tpXTtcbiAgICAgIGN1clRleEFycmF5ICE9PSB0ZXhBcnJheSAmJiAoY3VyVGV4QXJyYXkgPSB0ZXhBcnJheSwgdGhpcy5iaW5kQW5kQ2xlYXJUZXhBcnJheSh0ZXhBcnJheSkpLCB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGJsZW5kLCBzdGF0ZVN5c3RlbS5zZXQodGhpcy5zdGF0ZSksIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnQgKiAyKTtcbiAgICB9XG4gIH1cbiAgLyoqIFJlbmRlcnMgdGhlIGNvbnRlbnQgX25vd18gYW5kIGVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2guICovXG4gIGZsdXNoKCkge1xuICAgIHRoaXMuX3ZlcnRleENvdW50ICE9PSAwICYmICh0aGlzLl9hdHRyaWJ1dGVCdWZmZXIgPSB0aGlzLmdldEF0dHJpYnV0ZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhDb3VudCksIHRoaXMuX2luZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleEJ1ZmZlcih0aGlzLl9pbmRleENvdW50KSwgdGhpcy5fYUluZGV4ID0gMCwgdGhpcy5faUluZGV4ID0gMCwgdGhpcy5fZGNJbmRleCA9IDAsIHRoaXMuYnVpbGRUZXh0dXJlc0FuZERyYXdDYWxscygpLCB0aGlzLnVwZGF0ZUdlb21ldHJ5KCksIHRoaXMuZHJhd0JhdGNoZXMoKSwgdGhpcy5fYnVmZmVyU2l6ZSA9IDAsIHRoaXMuX3ZlcnRleENvdW50ID0gMCwgdGhpcy5faW5kZXhDb3VudCA9IDApO1xuICB9XG4gIC8qKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLiAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKSwgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmVuc3VyZVNhbXBsZXJUeXBlKHRoaXMubWF4VGV4dHVyZXMpLCB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuX3NoYWRlciksIF9CYXRjaFJlbmRlcmVyMi5jYW5VcGxvYWRTYW1lQnVmZmVyICYmIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgfVxuICAvKiogU3RvcHMgYW5kIGZsdXNoZXMgdGhlIGN1cnJlbnQgYmF0Y2guICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIGBCYXRjaFJlbmRlcmVyYC4gSXQgY2Fubm90IGJlIHVzZWQgYWdhaW4uICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplOyBpKyspXG4gICAgICB0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW2ldICYmIHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0uZGVzdHJveSgpO1xuICAgIHRoaXMucmVuZGVyZXIub2ZmKFwicHJlcmVuZGVyXCIsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpLCB0aGlzLl9hQnVmZmVycyA9IG51bGwsIHRoaXMuX2lCdWZmZXJzID0gbnVsbCwgdGhpcy5fcGFja2VkR2VvbWV0cmllcyA9IG51bGwsIHRoaXMuX2F0dHJpYnV0ZUJ1ZmZlciA9IG51bGwsIHRoaXMuX2luZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5fc2hhZGVyICYmICh0aGlzLl9zaGFkZXIuZGVzdHJveSgpLCB0aGlzLl9zaGFkZXIgPSBudWxsKSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGFuIGF0dHJpYnV0ZSBidWZmZXIgZnJvbSBgdGhpcy5fYUJ1ZmZlcnNgIHRoYXQgY2FuIGhvbGQgYXRsZWFzdCBgc2l6ZWAgZmxvYXRzLlxuICAgKiBAcGFyYW0gc2l6ZSAtIG1pbmltdW0gY2FwYWNpdHkgcmVxdWlyZWRcbiAgICogQHJldHVybnMgLSBidWZmZXIgdGhhbiBjYW4gaG9sZCBhdGxlYXN0IGBzaXplYCBmbG9hdHNcbiAgICovXG4gIGdldEF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XG4gICAgY29uc3Qgcm91bmRlZFAyID0gbmV4dFBvdzIoTWF0aC5jZWlsKHNpemUgLyA4KSksIHJvdW5kZWRTaXplSW5kZXggPSBsb2cyKHJvdW5kZWRQMiksIHJvdW5kZWRTaXplID0gcm91bmRlZFAyICogODtcbiAgICB0aGlzLl9hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCAmJiAodGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDEpO1xuICAgIGxldCBidWZmZXIgPSB0aGlzLl9hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XG4gICAgcmV0dXJuIGJ1ZmZlciB8fCAodGhpcy5fYUJ1ZmZlcnNbcm91bmRlZFNpemVdID0gYnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKHJvdW5kZWRTaXplICogdGhpcy52ZXJ0ZXhTaXplICogNCkpLCBidWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYW4gaW5kZXggYnVmZmVyIGZyb20gYHRoaXMuX2lCdWZmZXJzYCB0aGF0IGNhblxuICAgKiBoYXZlIGF0IGxlYXN0IGBzaXplYCBjYXBhY2l0eS5cbiAgICogQHBhcmFtIHNpemUgLSBtaW5pbXVtIHJlcXVpcmVkIGNhcGFjaXR5XG4gICAqIEByZXR1cm5zIC0gYnVmZmVyIHRoYXQgY2FuIGZpdCBgc2l6ZWAgaW5kaWNlcy5cbiAgICovXG4gIGdldEluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCByb3VuZGVkUDIgPSBuZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDEyKSksIHJvdW5kZWRTaXplSW5kZXggPSBsb2cyKHJvdW5kZWRQMiksIHJvdW5kZWRTaXplID0gcm91bmRlZFAyICogMTI7XG4gICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoIDw9IHJvdW5kZWRTaXplSW5kZXggJiYgKHRoaXMuX2lCdWZmZXJzLmxlbmd0aCA9IHJvdW5kZWRTaXplSW5kZXggKyAxKTtcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF07XG4gICAgcmV0dXJuIGJ1ZmZlciB8fCAodGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF0gPSBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkocm91bmRlZFNpemUpKSwgYnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgZm91ciBiYXRjaGluZyBwYXJhbWV0ZXJzIG9mIGBlbGVtZW50YCwgaW50ZXJsZWF2ZXNcbiAgICogYW5kIHB1c2hlcyB0aGVtIGludG8gdGhlIGJhdGNoaW5nIGF0dHJpYnV0ZS9pbmRleCBidWZmZXJzIGdpdmVuLlxuICAgKlxuICAgKiBJdCB1c2VzIHRoZXNlIHByb3BlcnRpZXM6IGB2ZXJ0ZXhEYXRhYCBgdXZzYCwgYHRleHR1cmVJZGAgYW5kXG4gICAqIGBpbmRpY2llc2AuIEl0IGFsc28gdXNlcyB0aGUgXCJ0aW50XCIgb2YgdGhlIGJhc2UtdGV4dHVyZSwgaWZcbiAgICogcHJlc2VudC5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGVsZW1lbnQgLSBlbGVtZW50IGJlaW5nIHJlbmRlcmVkXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVCdWZmZXIgLSBhdHRyaWJ1dGUgYnVmZmVyLlxuICAgKiBAcGFyYW0gaW5kZXhCdWZmZXIgLSBpbmRleCBidWZmZXJcbiAgICogQHBhcmFtIGFJbmRleCAtIG51bWJlciBvZiBmbG9hdHMgYWxyZWFkeSBpbiB0aGUgYXR0cmlidXRlIGJ1ZmZlclxuICAgKiBAcGFyYW0gaUluZGV4IC0gbnVtYmVyIG9mIGluZGljZXMgYWxyZWFkeSBpbiBgaW5kZXhCdWZmZXJgXG4gICAqL1xuICBwYWNrSW50ZXJsZWF2ZWRHZW9tZXRyeShlbGVtZW50LCBhdHRyaWJ1dGVCdWZmZXIsIGluZGV4QnVmZmVyLCBhSW5kZXgsIGlJbmRleCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVpbnQzMlZpZXcsXG4gICAgICBmbG9hdDMyVmlld1xuICAgIH0gPSBhdHRyaWJ1dGVCdWZmZXIsIHBhY2tlZFZlcnRpY2VzID0gYUluZGV4IC8gdGhpcy52ZXJ0ZXhTaXplLCB1dnMgPSBlbGVtZW50LnV2cywgaW5kaWNpZXMgPSBlbGVtZW50LmluZGljZXMsIHZlcnRleERhdGEgPSBlbGVtZW50LnZlcnRleERhdGEsIHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2JhdGNoTG9jYXRpb24sIGFscGhhID0gTWF0aC5taW4oZWxlbWVudC53b3JsZEFscGhhLCAxKSwgYXJnYiA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShlbGVtZW50Ll90aW50UkdCKS50b1ByZW11bHRpcGxpZWQoYWxwaGEsIGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaSArPSAyKVxuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdmVydGV4RGF0YVtpXSwgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdmVydGV4RGF0YVtpICsgMV0sIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHV2c1tpXSwgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2kgKyAxXSwgdWludDMyVmlld1thSW5kZXgrK10gPSBhcmdiLCBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB0ZXh0dXJlSWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2llcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4QnVmZmVyW2lJbmRleCsrXSA9IHBhY2tlZFZlcnRpY2VzICsgaW5kaWNpZXNbaV07XG4gIH1cbn07XG5fQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplID0gNDA5NiwgLyoqIEBpZ25vcmUgKi9cbl9CYXRjaFJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJiYXRjaFwiLFxuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyUGx1Z2luXG59LCAvKipcbiogUG9vbCBvZiBgQmF0Y2hEcmF3Q2FsbGAgb2JqZWN0cyB0aGF0IGBmbHVzaGAgdXNlZFxuKiB0byBjcmVhdGUgXCJiYXRjaGVzXCIgb2YgdGhlIG9iamVjdHMgYmVpbmcgcmVuZGVyZWQuXG4qXG4qIFRoZXNlIGFyZSBuZXZlciByZS1hbGxvY2F0ZWQgYWdhaW4uXG4qIFNoYXJlZCBiZXR3ZWVuIGFsbCBiYXRjaCByZW5kZXJlcnMgYmVjYXVzZSBpdCBjYW4gYmUgb25seSBvbmUgXCJmbHVzaFwiIHdvcmtpbmcgYXQgdGhlIG1vbWVudC5cbiogQG1lbWJlciB7UElYSS5CYXRjaERyYXdDYWxsW119XG4qL1xuX0JhdGNoUmVuZGVyZXIuX2RyYXdDYWxsUG9vbCA9IFtdLCAvKipcbiogUG9vbCBvZiBgQmF0Y2hEcmF3Q2FsbGAgb2JqZWN0cyB0aGF0IGBmbHVzaGAgdXNlZFxuKiB0byBjcmVhdGUgXCJiYXRjaGVzXCIgb2YgdGhlIG9iamVjdHMgYmVpbmcgcmVuZGVyZWQuXG4qXG4qIFRoZXNlIGFyZSBuZXZlciByZS1hbGxvY2F0ZWQgYWdhaW4uXG4qIFNoYXJlZCBiZXR3ZWVuIGFsbCBiYXRjaCByZW5kZXJlcnMgYmVjYXVzZSBpdCBjYW4gYmUgb25seSBvbmUgXCJmbHVzaFwiIHdvcmtpbmcgYXQgdGhlIG1vbWVudC5cbiogQG1lbWJlciB7UElYSS5CYXRjaFRleHR1cmVBcnJheVtdfVxuKi9cbl9CYXRjaFJlbmRlcmVyLl90ZXh0dXJlQXJyYXlQb29sID0gW107XG5sZXQgQmF0Y2hSZW5kZXJlciA9IF9CYXRjaFJlbmRlcmVyO1xuZXh0ZW5zaW9ucy5hZGQoQmF0Y2hSZW5kZXJlcik7XG5leHBvcnQge1xuICBCYXRjaFJlbmRlcmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hSZW5kZXJlci5tanMubWFwXG4iLCJ2YXIgZGVmYXVsdEZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblxudm9pZCBtYWluKHZvaWQpe1xuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbn1cbmA7XG5leHBvcnQge1xuICBkZWZhdWx0RnJhZ21lbnQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRGaWx0ZXIuZnJhZy5tanMubWFwXG4iLCJ2YXIgZGVmYXVsdFZlcnRleCA9IGBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcblxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXG57XG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XG5cbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG59XG5cbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcbntcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcbn1cblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcbn1cbmA7XG5leHBvcnQge1xuICBkZWZhdWx0VmVydGV4IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RmlsdGVyLnZlcnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gXCIuLi9zaGFkZXIvUHJvZ3JhbS5tanNcIjtcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuLi9zaGFkZXIvU2hhZGVyLm1qc1wiO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tIFwiLi4vc3RhdGUvU3RhdGUubWpzXCI7XG5pbXBvcnQgZGVmYXVsdEZyYWdtZW50IGZyb20gXCIuL2RlZmF1bHRGaWx0ZXIuZnJhZy5tanNcIjtcbmltcG9ydCBkZWZhdWx0VmVydGV4IGZyb20gXCIuL2RlZmF1bHRGaWx0ZXIudmVydC5tanNcIjtcbmNvbnN0IF9GaWx0ZXIgPSBjbGFzcyBfRmlsdGVyMiBleHRlbmRzIFNoYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdmVydGV4U3JjIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICogQHBhcmFtIGZyYWdtZW50U3JjIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKiBAcGFyYW0gdW5pZm9ybXMgLSBDdXN0b20gdW5pZm9ybXMgdG8gdXNlIHRvIGF1Z21lbnQgdGhlIGJ1aWx0LWluIG9uZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3Jtcykge1xuICAgIGNvbnN0IHByb2dyYW0gPSBQcm9ncmFtLmZyb20oXG4gICAgICB2ZXJ0ZXhTcmMgfHwgX0ZpbHRlcjIuZGVmYXVsdFZlcnRleFNyYyxcbiAgICAgIGZyYWdtZW50U3JjIHx8IF9GaWx0ZXIyLmRlZmF1bHRGcmFnbWVudFNyY1xuICAgICk7XG4gICAgc3VwZXIocHJvZ3JhbSwgdW5pZm9ybXMpLCB0aGlzLnBhZGRpbmcgPSAwLCB0aGlzLnJlc29sdXRpb24gPSBfRmlsdGVyMi5kZWZhdWx0UmVzb2x1dGlvbiwgdGhpcy5tdWx0aXNhbXBsZSA9IF9GaWx0ZXIyLmRlZmF1bHRNdWx0aXNhbXBsZSwgdGhpcy5lbmFibGVkID0gITAsIHRoaXMuYXV0b0ZpdCA9ICEwLCB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxuICAgKiBAcGFyYW0ge1BJWEkuQ0xFQVJfTU9ERVN9IFtjbGVhck1vZGVdIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gW19jdXJyZW50U3RhdGVdIC0gSXQncyBjdXJyZW50IHN0YXRlIG9mIGZpbHRlci5cbiAgICogICAgICAgIFRoZXJlIGFyZSBzb21lIHVzZWZ1bCBwcm9wZXJ0aWVzIGluIHRoZSBjdXJyZW50U3RhdGUgOlxuICAgKiAgICAgICAgdGFyZ2V0LCBmaWx0ZXJzLCBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyVGFyZ2V0LCByZXNvbHV0aW9uXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUsIF9jdXJyZW50U3RhdGUpIHtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJsZW5kIG1vZGUgb2YgdGhlIGZpbHRlci5cbiAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICovXG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgZmlsdGVyLiBTZXR0aW5nIHRoaXMgdG8gYmUgbG93ZXIgd2lsbCBsb3dlciB0aGUgcXVhbGl0eSBidXRcbiAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAqIElmIHNldCB0byBgbnVsbGAgb3IgYDBgLCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IGlzIHVzZWQuXG4gICAqIEBkZWZhdWx0IFBJWEkuRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uXG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdmVydGV4IHNoYWRlciBzb3VyY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWZXJ0ZXg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFNyYygpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZyYWdtZW50O1xuICB9XG59O1xuX0ZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiA9IDEsIC8qKlxuKiBEZWZhdWx0IGZpbHRlciBzYW1wbGVzIGZvciBhbnkgZmlsdGVyLlxuKiBAc3RhdGljXG4qIEB0eXBlIHtQSVhJLk1TQUFfUVVBTElUWXxudWxsfVxuKiBAZGVmYXVsdCBQSVhJLk1TQUFfUVVBTElUWS5OT05FXG4qL1xuX0ZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbmxldCBGaWx0ZXIgPSBfRmlsdGVyO1xuZXhwb3J0IHtcbiAgRmlsdGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSBcIkBwaXhpL2NvbG9yXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmNsYXNzIEJhY2tncm91bmRTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gITAsIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwKSwgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgLyoqXG4gICAqIGluaXRpYXRlcyB0aGUgYmFja2dyb3VuZCBzeXN0ZW1cbiAgICogQHBhcmFtIHtQSVhJLklSZW5kZXJlck9wdGlvbnN9IG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3IgdGhlIGJhY2tncm91bmQgY29sb3JzXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcjtcbiAgICBjb25zdCB7IGJhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZCwgYmFja2dyb3VuZEFscGhhIH0gPSBvcHRpb25zLCBjb2xvciA9IGJhY2tncm91bmQgPz8gYmFja2dyb3VuZENvbG9yO1xuICAgIGNvbG9yICE9PSB2b2lkIDAgJiYgKHRoaXMuY29sb3IgPSBjb2xvciksIHRoaXMuYWxwaGEgPSBiYWNrZ3JvdW5kQWxwaGE7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGZpbGwgaWYgbm90IHRyYW5zcGFyZW50LlxuICAgKiBAbWVtYmVyIHtQSVhJLkNvbG9yU291cmNlfVxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhY2tncm91bmQgY29sb3IgYWxwaGEuIFNldHRpbmcgdGhpcyB0byAwIHdpbGwgbWFrZSB0aGUgY2FudmFzIHRyYW5zcGFyZW50LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvci5hbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3Iuc2V0QWxwaGEodmFsdWUpO1xuICB9XG4gIC8qKiBUaGUgYmFja2dyb3VuZCBjb2xvciBvYmplY3QuICovXG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGF9XG4gICAqIEBkZWZhdWx0IDFcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGJhY2tncm91bmRBbHBoYTogMSxcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMuYmFja2dyb3VuZENvbG9yfVxuICAgKiBAZGVmYXVsdCAweDAwMDAwMFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgYmFja2dyb3VuZENvbG9yOiAwLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgY2xlYXJCZWZvcmVSZW5kZXI6ICEwXG59LCAvKiogQGlnbm9yZSAqL1xuQmFja2dyb3VuZFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJiYWNrZ3JvdW5kXCJcbn07XG5leHRlbnNpb25zLmFkZChCYWNrZ3JvdW5kU3lzdGVtKTtcbmV4cG9ydCB7XG4gIEJhY2tncm91bmRTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIgfSBmcm9tIFwiLi9PYmplY3RSZW5kZXJlci5tanNcIjtcbmNsYXNzIEJhdGNoU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5lbXB0eVJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyKSwgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSB0aGlzLmVtcHR5UmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIG9iamVjdFJlbmRlcmVyIC0gVGhlIG9iamVjdCByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICBzZXRPYmplY3RSZW5kZXJlcihvYmplY3RSZW5kZXJlcikge1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyICE9PSBvYmplY3RSZW5kZXJlciAmJiAodGhpcy5jdXJyZW50UmVuZGVyZXIuc3RvcCgpLCB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyLCB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGlmIHlvdSB3aXNoIHRvIGRvIHNvbWUgY3VzdG9tIHJlbmRlcmluZ1xuICAgKiBJdCB3aWxsIGJhc2ljYWxseSByZW5kZXIgYW55dGhpbmcgdGhhdCBtYXkgYmUgYmF0Y2hlZCB1cCBzdWNoIGFzIHNwcml0ZXNcbiAgICovXG4gIGZsdXNoKCkge1xuICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcbiAgfVxuICAvKiogUmVzZXQgdGhlIHN5c3RlbSB0byBhbiBlbXB0eSByZW5kZXJlciAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmR5IGZ1bmN0aW9uIGZvciBiYXRjaCByZW5kZXJlcnM6IGNvcGllcyBib3VuZCB0ZXh0dXJlcyBpbiBmaXJzdCBtYXhUZXh0dXJlcyBsb2NhdGlvbnMgdG8gYXJyYXlcbiAgICogc2V0cyBhY3R1YWwgX2JhdGNoTG9jYXRpb24gZm9yIHRoZW1cbiAgICogQHBhcmFtIGFyciAtIGFyciBjb3B5IGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSBtYXhUZXh0dXJlcyAtIG51bWJlciBvZiBjb3BpZWQgZWxlbWVudHNcbiAgICovXG4gIGNvcHlCb3VuZFRleHR1cmVzKGFyciwgbWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGJvdW5kVGV4dHVyZXMgfSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICBmb3IgKGxldCBpID0gbWF4VGV4dHVyZXMgLSAxOyBpID49IDA7IC0taSlcbiAgICAgIGFycltpXSA9IGJvdW5kVGV4dHVyZXNbaV0gfHwgbnVsbCwgYXJyW2ldICYmIChhcnJbaV0uX2JhdGNoTG9jYXRpb24gPSBpKTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBiYXRjaCBsb2NhdGlvbnMgdG8gdGV4dHVyZXMgaW4gYXJyYXkgYmFzZWQgb24gYm91bmRUZXh0dXJlcyBzdGF0ZS5cbiAgICogQWxsIHRleHR1cmVzIGluIHRleEFycmF5IHNob3VsZCBoYXZlIGBfYmF0Y2hFbmFibGVkID0gX2JhdGNoSWRgLFxuICAgKiBhbmQgdGhlaXIgY291bnQgc2hvdWxkIGJlIGxlc3MgdGhhbiBgbWF4VGV4dHVyZXNgLlxuICAgKiBAcGFyYW0gdGV4QXJyYXkgLSB0ZXh0dXJlcyB0byBib3VuZFxuICAgKiBAcGFyYW0gYm91bmRUZXh0dXJlcyAtIGN1cnJlbnQgc3RhdGUgb2YgYm91bmQgdGV4dHVyZXNcbiAgICogQHBhcmFtIGJhdGNoSWQgLSBtYXJrZXIgZm9yIF9iYXRjaEVuYWJsZWQgcGFyYW0gb2YgdGV4dHVyZXMgaW4gdGV4QXJyYXlcbiAgICogQHBhcmFtIG1heFRleHR1cmVzIC0gbnVtYmVyIG9mIHRleHR1cmUgbG9jYXRpb25zIHRvIG1hbmlwdWxhdGVcbiAgICovXG4gIGJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIGJhdGNoSWQsIG1heFRleHR1cmVzKSB7XG4gICAgY29uc3QgeyBlbGVtZW50cywgaWRzLCBjb3VudCB9ID0gdGV4QXJyYXk7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4ID0gZWxlbWVudHNbaV0sIGxvYyA9IHRleC5fYmF0Y2hMb2NhdGlvbjtcbiAgICAgIGlmIChsb2MgPj0gMCAmJiBsb2MgPCBtYXhUZXh0dXJlcyAmJiBib3VuZFRleHR1cmVzW2xvY10gPT09IHRleCkge1xuICAgICAgICBpZHNbaV0gPSBsb2M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBtYXhUZXh0dXJlczsgKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gYm91bmRUZXh0dXJlc1tqXTtcbiAgICAgICAgaWYgKGJvdW5kICYmIGJvdW5kLl9iYXRjaEVuYWJsZWQgPT09IGJhdGNoSWQgJiYgYm91bmQuX2JhdGNoTG9jYXRpb24gPT09IGopIHtcbiAgICAgICAgICBqKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2ldID0gaiwgdGV4Ll9iYXRjaExvY2F0aW9uID0gaiwgYm91bmRUZXh0dXJlc1tqXSA9IHRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5CYXRjaFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiYmF0Y2hcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEJhdGNoU3lzdGVtKTtcbmV4cG9ydCB7XG4gIEJhdGNoU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xubGV0IENPTlRFWFRfVUlEX0NPVU5URVIgPSAwO1xuY2xhc3MgQ29udGV4dFN5c3RlbSB7XG4gIC8qKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLiAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy53ZWJHTFZlcnNpb24gPSAxLCB0aGlzLmV4dGVuc2lvbnMgPSB7fSwgdGhpcy5zdXBwb3J0cyA9IHtcbiAgICAgIHVpbnQzMkluZGljZXM6ICExXG4gICAgfSwgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IHRoaXMuaGFuZGxlQ29udGV4dExvc3QuYmluZCh0aGlzKSwgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBgdHJ1ZWAgaWYgdGhlIGNvbnRleHQgaXMgbG9zdFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpc0xvc3QoKSB7XG4gICAgcmV0dXJuICF0aGlzLmdsIHx8IHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjb250ZXh0IGNoYW5nZSBldmVudC5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gTmV3IFdlYkdMIGNvbnRleHQuXG4gICAqL1xuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsLCB0aGlzLnJlbmRlcmVyLmdsID0gZ2wsIHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQgPSBDT05URVhUX1VJRF9DT1VOVEVSKys7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuY29udGV4dClcbiAgICAgIHRoaXMuaW5pdEZyb21Db250ZXh0KG9wdGlvbnMuY29udGV4dCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBhbHBoYSA9IHRoaXMucmVuZGVyZXIuYmFja2dyb3VuZC5hbHBoYSA8IDEsIHByZW11bHRpcGxpZWRBbHBoYSA9IG9wdGlvbnMucHJlbXVsdGlwbGllZEFscGhhO1xuICAgICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlciwgdGhpcy51c2VDb250ZXh0QWxwaGEgPSBvcHRpb25zLnVzZUNvbnRleHRBbHBoYSwgdGhpcy5wb3dlclByZWZlcmVuY2UgPSBvcHRpb25zLnBvd2VyUHJlZmVyZW5jZSwgdGhpcy5pbml0RnJvbU9wdGlvbnMoe1xuICAgICAgICBhbHBoYSxcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhLFxuICAgICAgICBhbnRpYWxpYXM6IG9wdGlvbnMuYW50aWFsaWFzLFxuICAgICAgICBzdGVuY2lsOiAhMCxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcixcbiAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiBvcHRpb25zLnBvd2VyUHJlZmVyZW5jZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29udGV4dC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBXZWJHTCBjb250ZXh0XG4gICAqL1xuICBpbml0RnJvbUNvbnRleHQoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2wsIHRoaXMudmFsaWRhdGVDb250ZXh0KGdsKSwgdGhpcy5yZW5kZXJlci5nbCA9IGdsLCB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSURfQ09VTlRFUisrLCB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5lbWl0KGdsKTtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5yZW5kZXJlci52aWV3O1xuICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdm9pZCAwICYmICh2aWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsICExKSwgdmlldy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQsICExKSk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgZnJvbSBjb250ZXh0IG9wdGlvbnNcbiAgICogQHByb3RlY3RlZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY29udGV4dCBhdHRyaWJ1dGVzXG4gICAqL1xuICBpbml0RnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jcmVhdGVDb250ZXh0KHRoaXMucmVuZGVyZXIudmlldywgb3B0aW9ucyk7XG4gICAgdGhpcy5pbml0RnJvbUNvbnRleHQoZ2wpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgV2ViR0wgQ29udGV4dFxuICAgKiBAcGFyYW0gY2FudmFzIC0gdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgd2Ugd2lsbCBnZXQgdGhlIGNvbnRleHQgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgZ2V0cyBwYXNzZWQgaW4gdG8gdGhlIGNhbnZhcyBlbGVtZW50IGNvbnRhaW5pbmcgdGhlXG4gICAqICAgIGNvbnRleHQgYXR0cmlidXRlc1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XG4gICAqIEByZXR1cm5zIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBXZWJHTCBjb250ZXh0XG4gICAqL1xuICBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0aW9ucykge1xuICAgIGxldCBnbDtcbiAgICBpZiAoc2V0dGluZ3MuUFJFRkVSX0VOViA+PSBFTlYuV0VCR0wyICYmIChnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIG9wdGlvbnMpKSwgZ2wpXG4gICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDI7XG4gICAgZWxzZSBpZiAodGhpcy53ZWJHTFZlcnNpb24gPSAxLCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgb3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgb3B0aW9ucyksICFnbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlclwiKTtcbiAgICByZXR1cm4gdGhpcy5nbCA9IGdsLCB0aGlzLmdldEV4dGVuc2lvbnMoKSwgdGhpcy5nbDtcbiAgfVxuICAvKiogQXV0by1wb3B1bGF0ZSB0aGUge0BsaW5rIFBJWEkuQ29udGV4dFN5c3RlbS5leHRlbnNpb25zIGV4dGVuc2lvbnN9LiAqL1xuICBnZXRFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMsIGNvbW1vbiA9IHtcbiAgICAgIGxvc2VDb250ZXh0OiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIiksXG4gICAgICBhbmlzb3Ryb3BpY0ZpbHRlcmluZzogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpLFxuICAgICAgZmxvYXRUZXh0dXJlTGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiksXG4gICAgICBzM3RjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSxcbiAgICAgIHMzdGNfc1JHQjogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYlwiKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICBldGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGNcIiksXG4gICAgICBldGMxOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxcbiAgICAgIHB2cnRjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSxcbiAgICAgIGF0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0Y1wiKSxcbiAgICAgIGFzdGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpXG4gICAgfTtcbiAgICB0aGlzLndlYkdMVmVyc2lvbiA9PT0gMSA/IE9iamVjdC5hc3NpZ24odGhpcy5leHRlbnNpb25zLCBjb21tb24sIHtcbiAgICAgIGRyYXdCdWZmZXJzOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIiksXG4gICAgICBkZXB0aFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RlcHRoX3RleHR1cmVcIiksXG4gICAgICB2ZXJ0ZXhBcnJheU9iamVjdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpIHx8IGdsLmdldEV4dGVuc2lvbihcIldFQktJVF9PRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSxcbiAgICAgIHVpbnQzMkVsZW1lbnRJbmRleDogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKSxcbiAgICAgIC8vIEZsb2F0cyBhbmQgaGFsZi1mbG9hdHNcbiAgICAgIGZsb2F0VGV4dHVyZTogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksXG4gICAgICBmbG9hdFRleHR1cmVMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSxcbiAgICAgIHRleHR1cmVIYWxmRmxvYXQ6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksXG4gICAgICB0ZXh0dXJlSGFsZkZsb2F0TGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhclwiKVxuICAgIH0pIDogdGhpcy53ZWJHTFZlcnNpb24gPT09IDIgJiYgT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIGNvbW1vbiwge1xuICAgICAgLy8gRmxvYXRzIGFuZCBoYWxmLWZsb2F0c1xuICAgICAgY29sb3JCdWZmZXJGbG9hdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbG9zdCB3ZWJnbCBjb250ZXh0XG4gICAqIEBwYXJhbSB7V2ViR0xDb250ZXh0RXZlbnR9IGV2ZW50IC0gVGhlIGNvbnRleHQgbG9zdCBldmVudC5cbiAgICovXG4gIGhhbmRsZUNvbnRleHRMb3N0KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmdsLmlzQ29udGV4dExvc3QoKSAmJiB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQgJiYgdGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0LiAqL1xuICBoYW5kbGVDb250ZXh0UmVzdG9yZWQoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuZW1pdCh0aGlzLmdsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnJlbmRlcmVyLnZpZXc7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGwsIHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPT0gdm9pZCAwICYmICh2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QpLCB2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCkpLCB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCksIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dCAmJiB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgfVxuICAvKiogSGFuZGxlIHRoZSBwb3N0LXJlbmRlciBydW5uZXIgZXZlbnQuICovXG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5vYmplY3RSZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbiAmJiB0aGlzLmdsLmZsdXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFJlbmRlciBjb250ZXh0LlxuICAgKi9cbiAgdmFsaWRhdGVDb250ZXh0KGdsKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCksIGlzV2ViR2wyID0gXCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0XCIgaW4gZ2xvYmFsVGhpcyAmJiBnbCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICBpc1dlYkdsMiAmJiAodGhpcy53ZWJHTFZlcnNpb24gPSAyKSwgYXR0cmlidXRlcyAmJiAhYXR0cmlidXRlcy5zdGVuY2lsICYmIGNvbnNvbGUud2FybihcIlByb3ZpZGVkIFdlYkdMIGNvbnRleHQgZG9lcyBub3QgaGF2ZSBhIHN0ZW5jaWwgYnVmZmVyLCBtYXNrcyBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHlcIik7XG4gICAgY29uc3QgaGFzdWludDMyID0gaXNXZWJHbDIgfHwgISFnbC5nZXRFeHRlbnNpb24oXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpO1xuICAgIHRoaXMuc3VwcG9ydHMudWludDMySW5kaWNlcyA9IGhhc3VpbnQzMiwgaGFzdWludDMyIHx8IGNvbnNvbGUud2FybihcIlByb3ZpZGVkIFdlYkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCAzMiBpbmRleCBidWZmZXIsIGNvbXBsZXggZ3JhcGhpY3MgbWF5IG5vdCByZW5kZXIgY29ycmVjdGx5XCIpO1xuICB9XG59XG5Db250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5jb250ZXh0fVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TXG4gICAqL1xuICBjb250ZXh0OiBudWxsLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5hbnRpYWxpYXN9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TXG4gICAqL1xuICBhbnRpYWxpYXM6ICExLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGF9XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIHByZW11bHRpcGxpZWRBbHBoYTogITAsXG4gIC8qKlxuICAgKiB7QGxpbmsgUElYSS5JUmVuZGVyZXJPcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogITEsXG4gIC8qKlxuICAgKiB7QGxpbmsgUElYSS5JUmVuZGVyZXJPcHRpb25zLnBvd2VyUHJlZmVyZW5jZX1cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgcG93ZXJQcmVmZXJlbmNlOiBcImRlZmF1bHRcIlxufSwgLyoqIEBpZ25vcmUgKi9cbkNvbnRleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImNvbnRleHRcIlxufTtcbmV4dGVuc2lvbnMuYWRkKENvbnRleHRTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgQ29udGV4dFN5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZLCBTQ0FMRV9NT0RFUywgTUlQTUFQX01PREVTLCBGT1JNQVRTLCBUWVBFUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJAcGl4aS9ydW5uZXJcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcIi4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qc1wiO1xuY2xhc3MgRnJhbWVidWZmZXIge1xuICAvKipcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSBidWZmZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy53aWR0aCA9IE1hdGgucm91bmQod2lkdGgpLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KSwgIXRoaXMud2lkdGggfHwgIXRoaXMuaGVpZ2h0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWVidWZmZXIgd2lkdGggb3IgaGVpZ2h0IGlzIHplcm9cIik7XG4gICAgdGhpcy5zdGVuY2lsID0gITEsIHRoaXMuZGVwdGggPSAhMSwgdGhpcy5kaXJ0eUlkID0gMCwgdGhpcy5kaXJ0eUZvcm1hdCA9IDAsIHRoaXMuZGlydHlTaXplID0gMCwgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsLCB0aGlzLmNvbG9yVGV4dHVyZXMgPSBbXSwgdGhpcy5nbEZyYW1lYnVmZmVycyA9IHt9LCB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKFwiZGlzcG9zZUZyYW1lYnVmZmVyXCIpLCB0aGlzLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgY29sb3JUZXh0dXJlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjb2xvclRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlc1swXTtcbiAgfVxuICAvKipcbiAgICogQWRkIHRleHR1cmUgdG8gdGhlIGNvbG9yVGV4dHVyZSBhcnJheS5cbiAgICogQHBhcmFtIGluZGV4IC0gSW5kZXggb2YgdGhlIGFycmF5IHRvIGFkZCB0aGUgdGV4dHVyZSB0b1xuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBhcnJheVxuICAgKi9cbiAgYWRkQ29sb3JUZXh0dXJlKGluZGV4ID0gMCwgdGV4dHVyZSkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yVGV4dHVyZXNbaW5kZXhdID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmUobnVsbCwge1xuICAgICAgc2NhbGVNb2RlOiBTQ0FMRV9NT0RFUy5ORUFSRVNULFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIG1pcG1hcDogTUlQTUFQX01PREVTLk9GRixcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH0pLCB0aGlzLmRpcnR5SWQrKywgdGhpcy5kaXJ0eUZvcm1hdCsrLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBkZXB0aCB0ZXh0dXJlIHRvIHRoZSBmcmFtZSBidWZmZXIuXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBhZGQuXG4gICAqL1xuICBhZGREZXB0aFRleHR1cmUodGV4dHVyZSkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoVGV4dHVyZSA9IHRleHR1cmUgfHwgbmV3IEJhc2VUZXh0dXJlKG51bGwsIHtcbiAgICAgIHNjYWxlTW9kZTogU0NBTEVfTU9ERVMuTkVBUkVTVCxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBtaXBtYXA6IE1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICBmb3JtYXQ6IEZPUk1BVFMuREVQVEhfQ09NUE9ORU5ULFxuICAgICAgdHlwZTogVFlQRVMuVU5TSUdORURfU0hPUlRcbiAgICB9KSwgdGhpcy5kaXJ0eUlkKyssIHRoaXMuZGlydHlGb3JtYXQrKywgdGhpcztcbiAgfVxuICAvKiogRW5hYmxlIGRlcHRoIG9uIHRoZSBmcmFtZSBidWZmZXIuICovXG4gIGVuYWJsZURlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoID0gITAsIHRoaXMuZGlydHlJZCsrLCB0aGlzLmRpcnR5Rm9ybWF0KyssIHRoaXM7XG4gIH1cbiAgLyoqIEVuYWJsZSBzdGVuY2lsIG9uIHRoZSBmcmFtZSBidWZmZXIuICovXG4gIGVuYWJsZVN0ZW5jaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlbmNpbCA9ICEwLCB0aGlzLmRpcnR5SWQrKywgdGhpcy5kaXJ0eUZvcm1hdCsrLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGZyYW1lIGJ1ZmZlclxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgZnJhbWUgYnVmZmVyIHRvIHJlc2l6ZSB0b1xuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSBidWZmZXIgdG8gcmVzaXplIHRvXG4gICAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpLCBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCksICF3aWR0aCB8fCAhaGVpZ2h0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWVidWZmZXIgd2lkdGggYW5kIGhlaWdodCBtdXN0IG5vdCBiZSB6ZXJvXCIpO1xuICAgIGlmICghKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGgsIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0LCB0aGlzLmRpcnR5SWQrKywgdGhpcy5kaXJ0eVNpemUrKztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbG9yVGV4dHVyZXNbaV0sIHJlc29sdXRpb24gPSB0ZXh0dXJlLnJlc29sdXRpb247XG4gICAgICAgIHRleHR1cmUuc2V0U2l6ZSh3aWR0aCAvIHJlc29sdXRpb24sIGhlaWdodCAvIHJlc29sdXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmRlcHRoVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBEaXNwb3NlcyBXZWJHTCByZXNvdXJjZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoaXMgZ2VvbWV0cnkuICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgITEpO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbmQgcmVtb3ZlcyB0aGUgZGVwdGggdGV4dHVyZSBhZGRlZCB0byB0aGlzIGZyYW1lYnVmZmVyLiAqL1xuICBkZXN0cm95RGVwdGhUZXh0dXJlKCkge1xuICAgIHRoaXMuZGVwdGhUZXh0dXJlICYmICh0aGlzLmRlcHRoVGV4dHVyZS5kZXN0cm95KCksIHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbCwgKyt0aGlzLmRpcnR5SWQsICsrdGhpcy5kaXJ0eUZvcm1hdCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEZyYW1lYnVmZmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVidWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiQHBpeGkvY29sb3JcIjtcbmltcG9ydCB7IE1TQUFfUVVBTElUWSwgTUlQTUFQX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tIFwiLi4vZnJhbWVidWZmZXIvRnJhbWVidWZmZXIubWpzXCI7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gXCIuLi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5tanNcIjtcbmNsYXNzIEJhc2VSZW5kZXJUZXh0dXJlIGV4dGVuZHMgQmFzZVRleHR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTEwMF0gLSBUaGUgd2lkdGggb2YgdGhlIGJhc2UgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW29wdGlvbnMuc2NhbGVNb2RlPVBJWEkuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU31cbiAgICogICBmb3IgcG9zc2libGUgdmFsdWVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1QSVhJLnNldHRpbmdzLlJFU09MVVRJT05dIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW9cbiAgICogICBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWQuXG4gICAqIEBwYXJhbSB7UElYSS5NU0FBX1FVQUxJVFl9IFtvcHRpb25zLm11bHRpc2FtcGxlPVBJWEkuTVNBQV9RVUFMSVRZLk5PTkVdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIG9mIHRoZSBmcmFtZSBidWZmZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgd2lkdGggPSBhcmd1bWVudHNbMF0sIGhlaWdodCA9IGFyZ3VtZW50c1sxXSwgc2NhbGVNb2RlID0gYXJndW1lbnRzWzJdLCByZXNvbHV0aW9uID0gYXJndW1lbnRzWzNdO1xuICAgICAgb3B0aW9ucyA9IHsgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uIH07XG4gICAgfVxuICAgIG9wdGlvbnMud2lkdGggPSBvcHRpb25zLndpZHRoID8/IDEwMCwgb3B0aW9ucy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCA/PyAxMDAsIG9wdGlvbnMubXVsdGlzYW1wbGUgPz8gKG9wdGlvbnMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORSksIHN1cGVyKG51bGwsIG9wdGlvbnMpLCB0aGlzLm1pcG1hcCA9IE1JUE1BUF9NT0RFUy5PRkYsIHRoaXMudmFsaWQgPSAhMCwgdGhpcy5fY2xlYXIgPSBuZXcgQ29sb3IoWzAsIDAsIDAsIDBdKSwgdGhpcy5mcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcih0aGlzLnJlYWxXaWR0aCwgdGhpcy5yZWFsSGVpZ2h0KS5hZGRDb2xvclRleHR1cmUoMCwgdGhpcyksIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGUgPSBvcHRpb25zLm11bHRpc2FtcGxlLCB0aGlzLm1hc2tTdGFjayA9IFtdLCB0aGlzLmZpbHRlclN0YWNrID0gW3t9XTtcbiAgfVxuICAvKiogQ29sb3Igd2hlbiBjbGVhcm5pbmcgdGhlIHRleHR1cmUuICovXG4gIHNldCBjbGVhckNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fY2xlYXIuc2V0VmFsdWUodmFsdWUpO1xuICB9XG4gIGdldCBjbGVhckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGVhci52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29sb3Igb2JqZWN0IHdoZW4gY2xlYXJuaW5nIHRoZSB0ZXh0dXJlLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHNpbmNlIDcuMi4wXG4gICAqL1xuICBnZXQgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsZWFyO1xuICB9XG4gIC8qKlxuICAgKiBTaG9ydGN1dCB0byBgdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZWAuXG4gICAqIEBkZWZhdWx0IFBJWEkuTVNBQV9RVUFMSVRZLk5PTkVcbiAgICovXG4gIGdldCBtdWx0aXNhbXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZTtcbiAgfVxuICBzZXQgbXVsdGlzYW1wbGUodmFsdWUpIHtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLm11bHRpc2FtcGxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIEJhc2VSZW5kZXJUZXh0dXJlLlxuICAgKiBAcGFyYW0gZGVzaXJlZFdpZHRoIC0gVGhlIGRlc2lyZWQgd2lkdGggdG8gcmVzaXplIHRvLlxuICAgKiBAcGFyYW0gZGVzaXJlZEhlaWdodCAtIFRoZSBkZXNpcmVkIGhlaWdodCB0byByZXNpemUgdG8uXG4gICAqL1xuICByZXNpemUoZGVzaXJlZFdpZHRoLCBkZXNpcmVkSGVpZ2h0KSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5yZXNpemUoZGVzaXJlZFdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBkZXNpcmVkSGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKSwgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLmZyYW1lYnVmZmVyLndpZHRoLCB0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIEZyZWVzIHRoZSB0ZXh0dXJlIGFuZCBmcmFtZWJ1ZmZlciBmcm9tIFdlYkdMIG1lbW9yeSB3aXRob3V0IGRlc3Ryb3lpbmcgdGhpcyB0ZXh0dXJlIG9iamVjdC5cbiAgICogVGhpcyBtZWFucyB5b3UgY2FuIHN0aWxsIHVzZSB0aGUgdGV4dHVyZSBsYXRlciB3aGljaCB3aWxsIHVwbG9hZCBpdCB0byBHUFVcbiAgICogbWVtb3J5IGFnYWluLlxuICAgKiBAZmlyZXMgUElYSS5CYXNlVGV4dHVyZSNkaXNwb3NlXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIuZGlzcG9zZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCksIHRoaXMuZnJhbWVidWZmZXIuZGVzdHJveURlcHRoVGV4dHVyZSgpLCB0aGlzLmZyYW1lYnVmZmVyID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQmFzZVJlbmRlclRleHR1cmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlUmVuZGVyVGV4dHVyZS5tanMubWFwXG4iLCJpbXBvcnQgeyBBTFBIQV9NT0RFUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IGRldGVybWluZUNyb3NzT3JpZ2luIH0gZnJvbSBcIkBwaXhpL3V0aWxzXCI7XG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gXCIuL1Jlc291cmNlLm1qc1wiO1xuY2xhc3MgQmFzZUltYWdlUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxJbWFnZUJpdG1hcHxQSVhJLklDYW52YXN9IHNvdXJjZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgY29uc3Qgc291cmNlQW55ID0gc291cmNlLCB3aWR0aCA9IHNvdXJjZUFueS5uYXR1cmFsV2lkdGggfHwgc291cmNlQW55LnZpZGVvV2lkdGggfHwgc291cmNlQW55LndpZHRoLCBoZWlnaHQgPSBzb3VyY2VBbnkubmF0dXJhbEhlaWdodCB8fCBzb3VyY2VBbnkudmlkZW9IZWlnaHQgfHwgc291cmNlQW55LmhlaWdodDtcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KSwgdGhpcy5zb3VyY2UgPSBzb3VyY2UsIHRoaXMubm9TdWJJbWFnZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgY3Jvc3Mgb3JpZ2luIGJhc2VkIGRldGVjdGluZyB0aGUgdXJsIGFuZCB0aGUgY3Jvc3NvcmlnaW5cbiAgICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IGNyb3NzT3JpZ2luXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gY2hlY2tcbiAgICogQHBhcmFtIGNyb3Nzb3JpZ2luIC0gQ3Jvc3Mgb3JpZ2luIHZhbHVlIHRvIHVzZVxuICAgKi9cbiAgc3RhdGljIGNyb3NzT3JpZ2luKGVsZW1lbnQsIHVybCwgY3Jvc3NvcmlnaW4pIHtcbiAgICBjcm9zc29yaWdpbiA9PT0gdm9pZCAwICYmICF1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpID8gZWxlbWVudC5jcm9zc09yaWdpbiA9IGRldGVybWluZUNyb3NzT3JpZ2luKHVybCkgOiBjcm9zc29yaWdpbiAhPT0gITEgJiYgKGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0eXBlb2YgY3Jvc3NvcmlnaW4gPT0gXCJzdHJpbmdcIiA/IGNyb3Nzb3JpZ2luIDogXCJhbm9ueW1vdXNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBVcGxvYWQgdG8gdGhlIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIFJlZmVyZW5jZSB0byBwYXJlbnQgdGV4dHVyZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc30gW3NvdXJjZV0gLSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIC0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAqL1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2wsIHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoLCBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgIGlmIChzb3VyY2UgPSBzb3VyY2UgfHwgdGhpcy5zb3VyY2UsIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50IDwgXCJ1XCIgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgaWYgKCFzb3VyY2UuY29tcGxldGUgfHwgc291cmNlLm5hdHVyYWxXaWR0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgPCBcInVcIiAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIHNvdXJjZS5yZWFkeVN0YXRlIDw9IDEpXG4gICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUuYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5VTlBBQ0spLCAhdGhpcy5ub1N1YkltYWdlICYmIGJhc2VUZXh0dXJlLnRhcmdldCA9PT0gZ2wuVEVYVFVSRV8yRCAmJiBnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCA/IGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKSA6IChnbFRleHR1cmUud2lkdGggPSB3aWR0aCwgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodCwgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKSksICEwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc291cmNlIHdpZHRoL2hlaWdodCB3YXMgY2hhbmdlZCwgcmVzaXplIGNhbiBjYXVzZSBleHRyYSBiYXNlVGV4dHVyZSB1cGRhdGUuXG4gICAqIFRyaWdnZXJzIG9uZSB1cGRhdGUgaW4gYW55IGNhc2UuXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLCB3aWR0aCA9IHNvdXJjZS5uYXR1cmFsV2lkdGggfHwgc291cmNlLnZpZGVvV2lkdGggfHwgc291cmNlLndpZHRoLCBoZWlnaHQgPSBzb3VyY2UubmF0dXJhbEhlaWdodCB8fCBzb3VyY2UudmlkZW9IZWlnaHQgfHwgc291cmNlLmhlaWdodDtcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSwgc3VwZXIudXBkYXRlKCk7XG4gIH1cbiAgLyoqIERlc3Ryb3kgdGhpcyB7QGxpbmsgUElYSS5CYXNlSW1hZ2VSZXNvdXJjZX0gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEJhc2VJbWFnZVJlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUltYWdlUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgQUxQSEFfTU9ERVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgQmFzZUltYWdlUmVzb3VyY2UgfSBmcm9tIFwiLi9CYXNlSW1hZ2VSZXNvdXJjZS5tanNcIjtcbmNsYXNzIEltYWdlUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc291cmNlIC0gaW1hZ2Ugc291cmNlIG9yIFVSTFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9Mb2FkPXRydWVdIC0gc3RhcnQgbG9hZGluZyBwcm9jZXNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3JlYXRlQml0bWFwPVBJWEkuc2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUF0gLSB3aGV0aGVyIGl0cyByZXF1aXJlZCB0byBjcmVhdGVcbiAgICogICAgICAgIGEgYml0bWFwIGJlZm9yZSB1cGxvYWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc29yaWdpbj10cnVlXSAtIExvYWQgaW1hZ2UgdXNpbmcgY3Jvc3Mgb3JpZ2luXG4gICAqIEBwYXJhbSB7UElYSS5BTFBIQV9NT0RFU30gW29wdGlvbnMuYWxwaGFNb2RlPVBJWEkuQUxQSEFfTU9ERVMuVU5QQUNLXSAtIFByZW11bHRpcGx5IGltYWdlIGFscGhhIGluIGJpdG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9LCB0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4oaW1hZ2VFbGVtZW50LCBzb3VyY2UsIG9wdGlvbnMuY3Jvc3NvcmlnaW4pLCBpbWFnZUVsZW1lbnQuc3JjID0gc291cmNlLCBzb3VyY2UgPSBpbWFnZUVsZW1lbnQ7XG4gICAgfVxuICAgIHN1cGVyKHNvdXJjZSksICFzb3VyY2UuY29tcGxldGUgJiYgdGhpcy5fd2lkdGggJiYgdGhpcy5faGVpZ2h0ICYmICh0aGlzLl93aWR0aCA9IDAsIHRoaXMuX2hlaWdodCA9IDApLCB0aGlzLnVybCA9IHNvdXJjZS5zcmMsIHRoaXMuX3Byb2Nlc3MgPSBudWxsLCB0aGlzLnByZXNlcnZlQml0bWFwID0gITEsIHRoaXMuY3JlYXRlQml0bWFwID0gKG9wdGlvbnMuY3JlYXRlQml0bWFwID8/IHNldHRpbmdzLkNSRUFURV9JTUFHRV9CSVRNQVApICYmICEhZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCwgdGhpcy5hbHBoYU1vZGUgPSB0eXBlb2Ygb3B0aW9ucy5hbHBoYU1vZGUgPT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYWxwaGFNb2RlIDogbnVsbCwgdGhpcy5iaXRtYXAgPSBudWxsLCB0aGlzLl9sb2FkID0gbnVsbCwgb3B0aW9ucy5hdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHdoZW4gaW1hZ2Ugd2lsbCBiZSBsb2FkZWQgYW5kIHByb2Nlc3NlZC5cbiAgICogQHBhcmFtIGNyZWF0ZUJpdG1hcCAtIHdoZXRoZXIgcHJvY2VzcyBpbWFnZSBpbnRvIGJpdG1hcFxuICAgKi9cbiAgbG9hZChjcmVhdGVCaXRtYXApIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCA/IHRoaXMuX2xvYWQgOiAoY3JlYXRlQml0bWFwICE9PSB2b2lkIDAgJiYgKHRoaXMuY3JlYXRlQml0bWFwID0gY3JlYXRlQml0bWFwKSwgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgdGhpcy51cmwgPSBzb3VyY2Uuc3JjO1xuICAgICAgY29uc3QgY29tcGxldGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCB8fCAoc291cmNlLm9ubG9hZCA9IG51bGwsIHNvdXJjZS5vbmVycm9yID0gbnVsbCwgdGhpcy51cGRhdGUoKSwgdGhpcy5fbG9hZCA9IG51bGwsIHRoaXMuY3JlYXRlQml0bWFwID8gcmVzb2x2ZSh0aGlzLnByb2Nlc3MoKSkgOiByZXNvbHZlKHRoaXMpKTtcbiAgICAgIH07XG4gICAgICBzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYyA/IGNvbXBsZXRlZCgpIDogKHNvdXJjZS5vbmxvYWQgPSBjb21wbGV0ZWQsIHNvdXJjZS5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHJlamVjdChldmVudCksIHRoaXMub25FcnJvci5lbWl0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLl9sb2FkKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gd2UgbmVlZCB0byBjb252ZXJ0IGltYWdlIGludG8gQml0bWFwSW1hZ2UuXG4gICAqIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHJlYWwgcHJvbWlzZSBpcyBjYWNoZWQgaW5zaWRlLlxuICAgKiBAcmV0dXJucyAtIENhY2hlZCBwcm9taXNlIHRvIGZpbGwgdGhhdCBiaXRtYXBcbiAgICovXG4gIHByb2Nlc3MoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3MgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcbiAgICBpZiAodGhpcy5iaXRtYXAgIT09IG51bGwgfHwgIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIGNvbnN0IGNyZWF0ZUltYWdlQml0bWFwID0gZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCwgY29ycyA9ICFzb3VyY2UuY3Jvc3NPcmlnaW4gfHwgc291cmNlLmNyb3NzT3JpZ2luID09PSBcImFub255bW91c1wiO1xuICAgIHJldHVybiB0aGlzLl9wcm9jZXNzID0gZmV0Y2goXG4gICAgICBzb3VyY2Uuc3JjLFxuICAgICAge1xuICAgICAgICBtb2RlOiBjb3JzID8gXCJjb3JzXCIgOiBcIm5vLWNvcnNcIlxuICAgICAgfVxuICAgICkudGhlbigocikgPT4gci5ibG9iKCkpLnRoZW4oKGJsb2IpID0+IGNyZWF0ZUltYWdlQml0bWFwKFxuICAgICAgYmxvYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgc291cmNlLndpZHRoLFxuICAgICAgc291cmNlLmhlaWdodCxcbiAgICAgIHtcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdGhpcy5hbHBoYU1vZGUgPT09IG51bGwgfHwgdGhpcy5hbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLlVOUEFDSyA/IFwicHJlbXVsdGlwbHlcIiA6IFwibm9uZVwiXG4gICAgICB9XG4gICAgKSkudGhlbigoYml0bWFwKSA9PiB0aGlzLmRlc3Ryb3llZCA/IFByb21pc2UucmVqZWN0KCkgOiAodGhpcy5iaXRtYXAgPSBiaXRtYXAsIHRoaXMudXBkYXRlKCksIHRoaXMuX3Byb2Nlc3MgPSBudWxsLCBQcm9taXNlLnJlc29sdmUodGhpcykpKSwgdGhpcy5fcHJvY2VzcztcbiAgfVxuICAvKipcbiAgICogVXBsb2FkIHRoZSBpbWFnZSByZXNvdXJjZSB0byBHUFUuXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIHVwbG9hZCB0b1xuICAgKiBAcGFyYW0gYmFzZVRleHR1cmUgLSBCYXNlVGV4dHVyZSBmb3IgdGhpcyByZXNvdXJjZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlIC0gR0xUZXh0dXJlIHRvIHVzZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAqL1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuYWxwaGFNb2RlID09IFwibnVtYmVyXCIgJiYgKGJhc2VUZXh0dXJlLmFscGhhTW9kZSA9IHRoaXMuYWxwaGFNb2RlKSwgIXRoaXMuY3JlYXRlQml0bWFwKVxuICAgICAgcmV0dXJuIHN1cGVyLnVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSk7XG4gICAgaWYgKCF0aGlzLmJpdG1hcCAmJiAodGhpcy5wcm9jZXNzKCksICF0aGlzLmJpdG1hcCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHN1cGVyLnVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSwgdGhpcy5iaXRtYXApLCAhdGhpcy5wcmVzZXJ2ZUJpdG1hcCkge1xuICAgICAgbGV0IGZsYWcgPSAhMDtcbiAgICAgIGNvbnN0IGdsVGV4dHVyZXMgPSBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcztcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGdsVGV4dHVyZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJUZXggPSBnbFRleHR1cmVzW2tleV07XG4gICAgICAgIGlmIChvdGhlclRleCAhPT0gZ2xUZXh0dXJlICYmIG90aGVyVGV4LmRpcnR5SWQgIT09IGJhc2VUZXh0dXJlLmRpcnR5SWQpIHtcbiAgICAgICAgICBmbGFnID0gITE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsYWcgJiYgKHRoaXMuYml0bWFwLmNsb3NlICYmIHRoaXMuYml0bWFwLmNsb3NlKCksIHRoaXMuYml0bWFwID0gbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyByZXNvdXJjZS4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNvdXJjZS5vbmxvYWQgPSBudWxsLCB0aGlzLnNvdXJjZS5vbmVycm9yID0gbnVsbCwgc3VwZXIuZGlzcG9zZSgpLCB0aGlzLmJpdG1hcCAmJiAodGhpcy5iaXRtYXAuY2xvc2UoKSwgdGhpcy5iaXRtYXAgPSBudWxsKSwgdGhpcy5fcHJvY2VzcyA9IG51bGwsIHRoaXMuX2xvYWQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0IEhUTUxJbWFnZUVsZW1lbnQsIGFuZCBzb3VyY2UgaXMgc3RyaW5nIG9yIEhUTUxJbWFnZUVsZW1lbnRcbiAgICovXG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCA8IFwidVwiICYmICh0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIgfHwgc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEltYWdlUmVzb3VyY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IGdyb3VwRDggfSBmcm9tIFwiQHBpeGkvbWF0aFwiO1xuY2xhc3MgVGV4dHVyZVV2cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueDAgPSAwLCB0aGlzLnkwID0gMCwgdGhpcy54MSA9IDEsIHRoaXMueTEgPSAwLCB0aGlzLngyID0gMSwgdGhpcy55MiA9IDEsIHRoaXMueDMgPSAwLCB0aGlzLnkzID0gMSwgdGhpcy51dnNGbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0gYmFzZUZyYW1lIC0gVGhlIGJhc2UgZnJhbWUgb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHJvdGF0ZSAtIFJvdGF0aW9uIG9mIGZyYW1lLCBzZWUge0BsaW5rIFBJWEkuZ3JvdXBEOH1cbiAgICovXG4gIHNldChmcmFtZSwgYmFzZUZyYW1lLCByb3RhdGUpIHtcbiAgICBjb25zdCB0dyA9IGJhc2VGcmFtZS53aWR0aCwgdGggPSBiYXNlRnJhbWUuaGVpZ2h0O1xuICAgIGlmIChyb3RhdGUpIHtcbiAgICAgIGNvbnN0IHcyID0gZnJhbWUud2lkdGggLyAyIC8gdHcsIGgyID0gZnJhbWUuaGVpZ2h0IC8gMiAvIHRoLCBjWCA9IGZyYW1lLnggLyB0dyArIHcyLCBjWSA9IGZyYW1lLnkgLyB0aCArIGgyO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCBncm91cEQ4Lk5XKSwgdGhpcy54MCA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSksIHRoaXMueTAgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpLCByb3RhdGUgPSBncm91cEQ4LmFkZChyb3RhdGUsIDIpLCB0aGlzLngxID0gY1ggKyB3MiAqIGdyb3VwRDgudVgocm90YXRlKSwgdGhpcy55MSA9IGNZICsgaDIgKiBncm91cEQ4LnVZKHJvdGF0ZSksIHJvdGF0ZSA9IGdyb3VwRDguYWRkKHJvdGF0ZSwgMiksIHRoaXMueDIgPSBjWCArIHcyICogZ3JvdXBEOC51WChyb3RhdGUpLCB0aGlzLnkyID0gY1kgKyBoMiAqIGdyb3VwRDgudVkocm90YXRlKSwgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKSwgdGhpcy54MyA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSksIHRoaXMueTMgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dywgdGhpcy55MCA9IGZyYW1lLnkgLyB0aCwgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHcsIHRoaXMueTEgPSBmcmFtZS55IC8gdGgsIHRoaXMueDIgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3LCB0aGlzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGgsIHRoaXMueDMgPSBmcmFtZS54IC8gdHcsIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbMF0gPSB0aGlzLngwLCB0aGlzLnV2c0Zsb2F0MzJbMV0gPSB0aGlzLnkwLCB0aGlzLnV2c0Zsb2F0MzJbMl0gPSB0aGlzLngxLCB0aGlzLnV2c0Zsb2F0MzJbM10gPSB0aGlzLnkxLCB0aGlzLnV2c0Zsb2F0MzJbNF0gPSB0aGlzLngyLCB0aGlzLnV2c0Zsb2F0MzJbNV0gPSB0aGlzLnkyLCB0aGlzLnV2c0Zsb2F0MzJbNl0gPSB0aGlzLngzLCB0aGlzLnV2c0Zsb2F0MzJbN10gPSB0aGlzLnkzO1xuICB9XG59XG5UZXh0dXJlVXZzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9jb3JlOlRleHR1cmVVdnMgeDA9JHt0aGlzLngwfSB5MD0ke3RoaXMueTB9IHgxPSR7dGhpcy54MX0geTE9JHt0aGlzLnkxfSB4Mj0ke3RoaXMueDJ9IHkyPSR7dGhpcy55Mn0geDM9JHt0aGlzLngzfSB5Mz0ke3RoaXMueTN9XWA7XG59O1xuZXhwb3J0IHtcbiAgVGV4dHVyZVV2c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVVdnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlLCBQb2ludCB9IGZyb20gXCJAcGl4aS9tYXRoXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBUZXh0dXJlQ2FjaGUsIHVpZCwgZ2V0UmVzb2x1dGlvbk9mVXJsIH0gZnJvbSBcIkBwaXhpL3V0aWxzXCI7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gXCIuL0Jhc2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgVGV4dHVyZVV2cyB9IGZyb20gXCIuL1RleHR1cmVVdnMubWpzXCI7XG5jb25zdCBERUZBVUxUX1VWUyA9IG5ldyBUZXh0dXJlVXZzKCk7XG5mdW5jdGlvbiByZW1vdmVBbGxIYW5kbGVycyh0ZXgpIHtcbiAgdGV4LmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgfSwgdGV4Lm9uID0gZnVuY3Rpb24oKSB7XG4gIH0sIHRleC5vbmNlID0gZnVuY3Rpb24oKSB7XG4gIH0sIHRleC5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIH07XG59XG5jbGFzcyBUZXh0dXJlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIFRoZSBiYXNlIHRleHR1cmUgc291cmNlIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZSBmcm9tXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSByZWN0YW5nbGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2hvd1xuICAgKiBAcGFyYW0gb3JpZyAtIFRoZSBhcmVhIG9mIG9yaWdpbmFsIHRleHR1cmVcbiAgICogQHBhcmFtIHRyaW0gLSBUcmltbWVkIHJlY3RhbmdsZSBvZiBvcmlnaW5hbCB0ZXh0dXJlXG4gICAqIEBwYXJhbSByb3RhdGUgLSBpbmRpY2F0ZXMgaG93IHRoZSB0ZXh0dXJlIHdhcyByb3RhdGVkIGJ5IHRleHR1cmUgcGFja2VyLiBTZWUge0BsaW5rIFBJWEkuZ3JvdXBEOH1cbiAgICogQHBhcmFtIGFuY2hvciAtIERlZmF1bHQgYW5jaG9yIHBvaW50IHVzZWQgZm9yIHNwcml0ZSBwbGFjZW1lbnQgLyByb3RhdGlvblxuICAgKiBAcGFyYW0gYm9yZGVycyAtIERlZmF1bHQgYm9yZGVycyB1c2VkIGZvciA5LXNsaWNlIHNjYWxpbmcuIFNlZSB7QGxpbmsgUElYSS5OaW5lU2xpY2VQbGFuZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgcm90YXRlLCBhbmNob3IsIGJvcmRlcnMpIHtcbiAgICBpZiAoc3VwZXIoKSwgdGhpcy5ub0ZyYW1lID0gITEsIGZyYW1lIHx8ICh0aGlzLm5vRnJhbWUgPSAhMCwgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpKSwgYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlICYmIChiYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmJhc2VUZXh0dXJlKSwgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlLCB0aGlzLl9mcmFtZSA9IGZyYW1lLCB0aGlzLnRyaW0gPSB0cmltLCB0aGlzLnZhbGlkID0gITEsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuX3V2cyA9IERFRkFVTFRfVVZTLCB0aGlzLnV2TWF0cml4ID0gbnVsbCwgdGhpcy5vcmlnID0gb3JpZyB8fCBmcmFtZSwgdGhpcy5fcm90YXRlID0gTnVtYmVyKHJvdGF0ZSB8fCAwKSwgcm90YXRlID09PSAhMClcbiAgICAgIHRoaXMuX3JvdGF0ZSA9IDI7XG4gICAgZWxzZSBpZiAodGhpcy5fcm90YXRlICUgMiAhPT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHQgdG8gdXNlIGRpYW1vbmQtc2hhcGVkIFVWcy4gSWYgeW91IGFyZSBzdXJlLCBzZXQgcm90YXRpb24gbWFudWFsbHlcIik7XG4gICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gYW5jaG9yID8gbmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSkgOiBuZXcgUG9pbnQoMCwgMCksIHRoaXMuZGVmYXVsdEJvcmRlcnMgPSBib3JkZXJzLCB0aGlzLl91cGRhdGVJRCA9IDAsIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gW10sIGJhc2VUZXh0dXJlLnZhbGlkID8gdGhpcy5ub0ZyYW1lID8gYmFzZVRleHR1cmUudmFsaWQgJiYgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZChiYXNlVGV4dHVyZSkgOiB0aGlzLmZyYW1lID0gZnJhbWUgOiBiYXNlVGV4dHVyZS5vbmNlKFwibG9hZGVkXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpLCB0aGlzLm5vRnJhbWUgJiYgYmFzZVRleHR1cmUub24oXCJ1cGRhdGVcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyB0ZXh0dXJlIG9uIHRoZSBncHUuXG4gICAqXG4gICAqIENhbGxzIHRoZSBUZXh0dXJlUmVzb3VyY2UgdXBkYXRlLlxuICAgKlxuICAgKiBJZiB5b3UgYWRqdXN0ZWQgYGZyYW1lYCBtYW51YWxseSwgcGxlYXNlIGNhbGwgYHVwZGF0ZVV2cygpYCBpbnN0ZWFkLlxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuYmFzZVRleHR1cmUucmVzb3VyY2UgJiYgdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZS51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyB1cGRhdGVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlIC0gVGhlIGJhc2UgdGV4dHVyZS5cbiAgICovXG4gIG9uQmFzZVRleHR1cmVVcGRhdGVkKGJhc2VUZXh0dXJlKSB7XG4gICAgaWYgKHRoaXMubm9GcmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmJhc2VUZXh0dXJlLnZhbGlkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9mcmFtZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoLCB0aGlzLl9mcmFtZS5oZWlnaHQgPSBiYXNlVGV4dHVyZS5oZWlnaHQsIHRoaXMudmFsaWQgPSAhMCwgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLl9mcmFtZTtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICAgKiBAcGFyYW0gW2Rlc3Ryb3lCYXNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAgICogQGZpcmVzIFBJWEkuVGV4dHVyZSNkZXN0cm95ZWRcbiAgICovXG4gIGRlc3Ryb3koZGVzdHJveUJhc2UpIHtcbiAgICBpZiAodGhpcy5iYXNlVGV4dHVyZSkge1xuICAgICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb3VyY2UgfSA9IHRoaXMuYmFzZVRleHR1cmU7XG4gICAgICAgIHJlc291cmNlPy51cmwgJiYgVGV4dHVyZUNhY2hlW3Jlc291cmNlLnVybF0gJiYgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUocmVzb3VyY2UudXJsKSwgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZihcImxvYWRlZFwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKSwgdGhpcy5iYXNlVGV4dHVyZS5vZmYoXCJ1cGRhdGVcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyksIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9mcmFtZSA9IG51bGwsIHRoaXMuX3V2cyA9IG51bGwsIHRoaXMudHJpbSA9IG51bGwsIHRoaXMub3JpZyA9IG51bGwsIHRoaXMudmFsaWQgPSAhMSwgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyksIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbCwgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5lbWl0KFwiZGVzdHJveWVkXCIsIHRoaXMpLCB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRleHR1cmUgb2JqZWN0IHRoYXQgYWN0cyB0aGUgc2FtZSBhcyB0aGlzIG9uZS5cbiAgICogQHJldHVybnMgLSBUaGUgbmV3IHRleHR1cmVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lZEZyYW1lID0gdGhpcy5fZnJhbWUuY2xvbmUoKSwgY2xvbmVkT3JpZyA9IHRoaXMuX2ZyYW1lID09PSB0aGlzLm9yaWcgPyBjbG9uZWRGcmFtZSA6IHRoaXMub3JpZy5jbG9uZSgpLCBjbG9uZWRUZXh0dXJlID0gbmV3IFRleHR1cmUoXG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLFxuICAgICAgIXRoaXMubm9GcmFtZSAmJiBjbG9uZWRGcmFtZSxcbiAgICAgIGNsb25lZE9yaWcsXG4gICAgICB0aGlzLnRyaW0/LmNsb25lKCksXG4gICAgICB0aGlzLnJvdGF0ZSxcbiAgICAgIHRoaXMuZGVmYXVsdEFuY2hvcixcbiAgICAgIHRoaXMuZGVmYXVsdEJvcmRlcnNcbiAgICApO1xuICAgIHJldHVybiB0aGlzLm5vRnJhbWUgJiYgKGNsb25lZFRleHR1cmUuX2ZyYW1lID0gY2xvbmVkRnJhbWUpLCBjbG9uZWRUZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS4gVXNlIGl0IGFmdGVyIHlvdSBjaGFuZ2UgYGZyYW1lYCBvciBgdHJpbWAgb2YgdGhlIHRleHR1cmUuXG4gICAqIENhbGwgaXQgYWZ0ZXIgY2hhbmdpbmcgdGhlIGZyYW1lXG4gICAqL1xuICB1cGRhdGVVdnMoKSB7XG4gICAgdGhpcy5fdXZzID09PSBERUZBVUxUX1VWUyAmJiAodGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnMoKSksIHRoaXMuX3V2cy5zZXQodGhpcy5fZnJhbWUsIHRoaXMuYmFzZVRleHR1cmUsIHRoaXMucm90YXRlKSwgdGhpcy5fdXBkYXRlSUQrKztcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlIHVybCwgdmlkZW8gdXJsLCBjYW52YXMgZWxlbWVudCwgdmlkZW8gZWxlbWVudCwgYmFzZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7c3RyaW5nfFBJWEkuQmFzZVRleHR1cmV8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc30gc291cmNlIC1cbiAgICogICAgICAgIFNvdXJjZSBvciBhcnJheSBvZiBzb3VyY2VzIHRvIGNyZWF0ZSB0ZXh0dXJlIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waXhpSWRQcmVmaXg9cGl4aWlkXSAtIElmIGEgc291cmNlIGhhcyBubyBpZCwgdGhpcyBpcyB0aGUgcHJlZml4IG9mIHRoZSBnZW5lcmF0ZWQgaWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0XSAtIEVuZm9yY2Ugc3RyaWN0LW1vZGUsIHNlZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRX0uXG4gICAqIEByZXR1cm5zIHtQSVhJLlRleHR1cmV9IFRoZSBuZXdseSBjcmVhdGVkIHRleHR1cmVcbiAgICovXG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucyA9IHt9LCBzdHJpY3QgPSBzZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRSkge1xuICAgIGNvbnN0IGlzRnJhbWUgPSB0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCI7XG4gICAgbGV0IGNhY2hlSWQgPSBudWxsO1xuICAgIGlmIChpc0ZyYW1lKVxuICAgICAgY2FjaGVJZCA9IHNvdXJjZTtcbiAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSkge1xuICAgICAgaWYgKCFzb3VyY2UuY2FjaGVJZCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zPy5waXhpSWRQcmVmaXggfHwgXCJwaXhpaWRcIjtcbiAgICAgICAgc291cmNlLmNhY2hlSWQgPSBgJHtwcmVmaXh9LSR7dWlkKCl9YCwgQmFzZVRleHR1cmUuYWRkVG9DYWNoZShzb3VyY2UsIHNvdXJjZS5jYWNoZUlkKTtcbiAgICAgIH1cbiAgICAgIGNhY2hlSWQgPSBzb3VyY2UuY2FjaGVJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zPy5waXhpSWRQcmVmaXggfHwgXCJwaXhpaWRcIjtcbiAgICAgICAgc291cmNlLl9waXhpSWQgPSBgJHtwcmVmaXh9XyR7dWlkKCl9YDtcbiAgICAgIH1cbiAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICB9XG4gICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlQ2FjaGVbY2FjaGVJZF07XG4gICAgaWYgKGlzRnJhbWUgJiYgc3RyaWN0ICYmICF0ZXh0dXJlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY2FjaGVJZCBcIiR7Y2FjaGVJZH1cIiBkb2VzIG5vdCBleGlzdCBpbiBUZXh0dXJlQ2FjaGUuYCk7XG4gICAgcmV0dXJuICF0ZXh0dXJlICYmICEoc291cmNlIGluc3RhbmNlb2YgQmFzZVRleHR1cmUpID8gKG9wdGlvbnMucmVzb2x1dGlvbiB8fCAob3B0aW9ucy5yZXNvbHV0aW9uID0gZ2V0UmVzb2x1dGlvbk9mVXJsKHNvdXJjZSkpLCB0ZXh0dXJlID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlKHNvdXJjZSwgb3B0aW9ucykpLCB0ZXh0dXJlLmJhc2VUZXh0dXJlLmNhY2hlSWQgPSBjYWNoZUlkLCBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUuYmFzZVRleHR1cmUsIGNhY2hlSWQpLCBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCkpIDogIXRleHR1cmUgJiYgc291cmNlIGluc3RhbmNlb2YgQmFzZVRleHR1cmUgJiYgKHRleHR1cmUgPSBuZXcgVGV4dHVyZShzb3VyY2UpLCBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCkpLCB0ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBVc2VmdWwgZm9yIGxvYWRpbmcgdGV4dHVyZXMgdmlhIFVSTHMuIFVzZSBpbnN0ZWFkIG9mIGBUZXh0dXJlLmZyb21gIGJlY2F1c2VcbiAgICogaXQgZG9lcyBhIGJldHRlciBqb2Igb2YgaGFuZGxpbmcgZmFpbGVkIFVSTHMgbW9yZSBlZmZlY3RpdmVseS4gVGhpcyBhbHNvIGlnbm9yZXNcbiAgICogYFBJWEkuc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEVgLiBXb3JrcyBmb3IgVmlkZW9zLCBTVkdzLCBJbWFnZXMuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgcmVtb3RlIFVSTCBvciBhcnJheSBvZiBVUkxzIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyB0byBpbmNsdWRlXG4gICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBUZXh0dXJlLlxuICAgKi9cbiAgc3RhdGljIGZyb21VUkwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzb3VyY2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGF1dG9Mb2FkOiAhMSB9LCBvcHRpb25zPy5yZXNvdXJjZU9wdGlvbnMpLCB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tKHVybCwgT2JqZWN0LmFzc2lnbih7IHJlc291cmNlT3B0aW9ucyB9LCBvcHRpb25zKSwgITEpLCByZXNvdXJjZSA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb3VyY2U7XG4gICAgcmV0dXJuIHRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQgPyBQcm9taXNlLnJlc29sdmUodGV4dHVyZSkgOiByZXNvdXJjZS5sb2FkKCkudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUodGV4dHVyZSkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVGV4dHVyZSB3aXRoIGEgQnVmZmVyUmVzb3VyY2UgZnJvbSBhIHR5cGVkIGFycmF5LlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gVGhlIG9wdGlvbmFsIGFycmF5IHRvIHVzZS4gSWYgbm8gZGF0YSBpcyBwcm92aWRlZCwgYSBuZXcgRmxvYXQzMkFycmF5IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cbiAgICogICAgICAgIERlZmF1bHQgcHJvcGVydGllcyBhcmUgZGlmZmVyZW50IGZyb20gdGhlIGNvbnN0cnVjdG9yJ3MgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7UElYSS5GT1JNQVRTfSBbb3B0aW9ucy5mb3JtYXRdIC0gVGhlIGZvcm1hdCBpcyBub3QgZ2l2ZW4sIHRoZSB0eXBlIGlzIGluZmVycmVkIGZyb20gdGhlXG4gICAqICAgICAgICB0eXBlIG9mIHRoZSBidWZmZXI6IGBSR0JBYCBpZiBGbG9hdDMyQXJyYXksIEludDhBcnJheSwgVWludDhBcnJheSwgb3IgVWludDhDbGFtcGVkQXJyYXksXG4gICAqICAgICAgICBvdGhlcndpc2UgYFJHQkFfSU5URUdFUmAuXG4gICAqIEBwYXJhbSB7UElYSS5UWVBFU30gW29wdGlvbnMudHlwZV0gLSBUaGUgdHlwZSBpcyBub3QgZ2l2ZW4sIHRoZSB0eXBlIGlzIGluZmVycmVkIGZyb20gdGhlXG4gICAqICAgICAgICB0eXBlIG9mIHRoZSBidWZmZXIuIE1hcHMgRmxvYXQzMkFycmF5IHRvIGBGTE9BVGAsIEludDMyQXJyYXkgdG8gYElOVGAsIFVpbnQzMkFycmF5IHRvXG4gICAqICAgICAgICBgVU5TSUdORURfSU5UYCwgSW50MTZBcnJheSB0byBgU0hPUlRgLCBVaW50MTZBcnJheSB0byBgVU5TSUdORURfU0hPUlRgLCBJbnQ4QXJyYXkgdG8gYEJZVEVgLFxuICAgKiAgICAgICAgVWludDhBcnJheS9VaW50OENsYW1wZWRBcnJheSB0byBgVU5TSUdORURfQllURWAuXG4gICAqIEBwYXJhbSB7UElYSS5BTFBIQV9NT0RFU30gW29wdGlvbnMuYWxwaGFNb2RlPVBJWEkuQUxQSEFfTU9ERVMuTlBNXVxuICAgKiBAcGFyYW0ge1BJWEkuU0NBTEVfTU9ERVN9IFtvcHRpb25zLnNjYWxlTW9kZT1QSVhJLlNDQUxFX01PREVTLk5FQVJFU1RdXG4gICAqIEByZXR1cm5zIC0gVGhlIHJlc3VsdGluZyBuZXcgQmFzZVRleHR1cmVcbiAgICovXG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGV4dHVyZShCYXNlVGV4dHVyZS5mcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0ZXh0dXJlIGZyb20gYSBzb3VyY2UgYW5kIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc3xzdHJpbmd9IHNvdXJjZSAtIFRoZSBpbnB1dCBzb3VyY2UuXG4gICAqIEBwYXJhbSBpbWFnZVVybCAtIEZpbGUgbmFtZSBvZiB0ZXh0dXJlLCBmb3IgY2FjaGUgYW5kIHJlc29sdmluZyByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0gbmFtZSAtIEh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSB0ZXh0dXJlIGNhY2hlLiBJZiBubyBuYW1lIGlzXG4gICAqICAgICAgICBzcGVjaWZpZWQsIG9ubHkgYGltYWdlVXJsYCB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIElELlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyAtIE91dHB1dCB0ZXh0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbUxvYWRlcihzb3VyY2UsIGltYWdlVXJsLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoc291cmNlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIHNjYWxlTW9kZTogQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlLFxuICAgICAgcmVzb2x1dGlvbjogZ2V0UmVzb2x1dGlvbk9mVXJsKGltYWdlVXJsKVxuICAgIH0sIG9wdGlvbnMpKSwgeyByZXNvdXJjZSB9ID0gYmFzZVRleHR1cmU7XG4gICAgcmVzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZVJlc291cmNlICYmIChyZXNvdXJjZS51cmwgPSBpbWFnZVVybCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKTtcbiAgICByZXR1cm4gbmFtZSB8fCAobmFtZSA9IGltYWdlVXJsKSwgQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBuYW1lKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIG5hbWUpLCBuYW1lICE9PSBpbWFnZVVybCAmJiAoQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbWFnZVVybCksIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBpbWFnZVVybCkpLCB0ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkID8gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUub25jZShcImxvYWRlZFwiLCAoKSA9PiByZXNvbHZlKHRleHR1cmUpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIFRleHR1cmUgdG8gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyB0aGUgd2hvbGUgUElYSSBvYmplY3QuXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIGlkIHRoYXQgdGhlIFRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cbiAgICovXG4gIHN0YXRpYyBhZGRUb0NhY2hlKHRleHR1cmUsIGlkKSB7XG4gICAgaWQgJiYgKHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluY2x1ZGVzKGlkKSB8fCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKSwgVGV4dHVyZUNhY2hlW2lkXSAmJiBUZXh0dXJlQ2FjaGVbaWRdICE9PSB0ZXh0dXJlICYmIGNvbnNvbGUud2FybihgVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbJHtpZH1dIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlgKSwgVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBUZXh0dXJlIGZyb20gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gaWQgb2YgYSBUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgVGV4dHVyZSBpbnN0YW5jZSBpdHNlbGZcbiAgICogQHJldHVybnMgLSBUaGUgVGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlRnJvbUNhY2hlKHRleHR1cmUpIHtcbiAgICBpZiAodHlwZW9mIHRleHR1cmUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdGV4dHVyZUZyb21DYWNoZSA9IFRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcbiAgICAgIGlmICh0ZXh0dXJlRnJvbUNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZih0ZXh0dXJlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgJiYgdGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKSwgZGVsZXRlIFRleHR1cmVDYWNoZVt0ZXh0dXJlXSwgdGV4dHVyZUZyb21DYWNoZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRleHR1cmU/LnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSlcbiAgICAgICAgVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXSA9PT0gdGV4dHVyZSAmJiBkZWxldGUgVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgIHJldHVybiB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwLCB0ZXh0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyByZXNvbHV0aW9uIG9mIGJhc2VUZXh0dXJlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICogUGxlYXNlIGNhbGwgYHVwZGF0ZVV2cygpYCBhZnRlciB5b3UgY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGBmcmFtZWAgbWFudWFsbHkuXG4gICAqL1xuICBnZXQgZnJhbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xuICB9XG4gIHNldCBmcmFtZShmcmFtZSkge1xuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWUsIHRoaXMubm9GcmFtZSA9ICExO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZnJhbWUsIHhOb3RGaXQgPSB4ICsgd2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoLCB5Tm90Rml0ID0geSArIGhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgIGlmICh4Tm90Rml0IHx8IHlOb3RGaXQpIHtcbiAgICAgIGNvbnN0IHJlbGF0aW9uc2hpcCA9IHhOb3RGaXQgJiYgeU5vdEZpdCA/IFwiYW5kXCIgOiBcIm9yXCIsIGVycm9yWCA9IGBYOiAke3h9ICsgJHt3aWR0aH0gPSAke3ggKyB3aWR0aH0gPiAke3RoaXMuYmFzZVRleHR1cmUud2lkdGh9YCwgZXJyb3JZID0gYFk6ICR7eX0gKyAke2hlaWdodH0gPSAke3kgKyBoZWlnaHR9ID4gJHt0aGlzLmJhc2VUZXh0dXJlLmhlaWdodH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJHtlcnJvclh9ICR7cmVsYXRpb25zaGlwfSAke2Vycm9yWX1gKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnZhbGlkLCAhdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSAmJiAodGhpcy5vcmlnID0gZnJhbWUpLCB0aGlzLnZhbGlkICYmIHRoaXMudXBkYXRlVXZzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xuICAgKiBzZXQgdG8gMiB0byBjb21wZW5zYXRlIGZvciB0ZXh0dXJlIHBhY2tlciByb3RhdGlvblxuICAgKiBzZXQgdG8gNiB0byBjb21wZW5zYXRlIGZvciBzcGluZSBwYWNrZXIgcm90YXRpb25cbiAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXG4gICAqIFNlZSB7QGxpbmsgUElYSS5ncm91cEQ4fSBmb3IgZXhwbGFuYXRpb25cbiAgICovXG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0ZTtcbiAgfVxuICBzZXQgcm90YXRlKHJvdGF0ZSkge1xuICAgIHRoaXMuX3JvdGF0ZSA9IHJvdGF0ZSwgdGhpcy52YWxpZCAmJiB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLiAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy53aWR0aDtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy5oZWlnaHQ7XG4gIH1cbiAgLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIEJhc2VUZXh0dXJlfFRleHR1cmUgY2FzdC4gKi9cbiAgY2FzdFRvQmFzZVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmU7XG4gIH1cbiAgLyoqIEFuIGVtcHR5IHRleHR1cmUsIHVzZWQgb2Z0ZW4gdG8gbm90IGhhdmUgdG8gY3JlYXRlIG11bHRpcGxlIGVtcHR5IHRleHR1cmVzLiBDYW4gbm90IGJlIGRlc3Ryb3llZC4gKi9cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICByZXR1cm4gVGV4dHVyZS5fRU1QVFkgfHwgKFRleHR1cmUuX0VNUFRZID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlKCkpLCByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9FTVBUWSksIHJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuX0VNUFRZLmJhc2VUZXh0dXJlKSksIFRleHR1cmUuX0VNUFRZO1xuICB9XG4gIC8qKiBBIHdoaXRlIHRleHR1cmUgb2YgMTZ4MTYgc2l6ZSwgdXNlZCBmb3IgZ3JhcGhpY3MgYW5kIG90aGVyIHRoaW5ncyBDYW4gbm90IGJlIGRlc3Ryb3llZC4gKi9cbiAgc3RhdGljIGdldCBXSElURSgpIHtcbiAgICBpZiAoIVRleHR1cmUuX1dISVRFKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygxNiwgMTYpLCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDE2LCBjYW52YXMuaGVpZ2h0ID0gMTYsIGNvbnRleHQuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiLCBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDE2LCAxNiksIFRleHR1cmUuX1dISVRFID0gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbShjYW52YXMpKSwgcmVtb3ZlQWxsSGFuZGxlcnMoVGV4dHVyZS5fV0hJVEUpLCByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9XSElURS5iYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0dXJlLl9XSElURTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVGV4dHVyZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gXCIuLi90ZXh0dXJlcy9UZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgQmFzZVJlbmRlclRleHR1cmUgfSBmcm9tIFwiLi9CYXNlUmVuZGVyVGV4dHVyZS5tanNcIjtcbmNsYXNzIFJlbmRlclRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBiYXNlUmVuZGVyVGV4dHVyZSAtIFRoZSBiYXNlIHRleHR1cmUgb2JqZWN0IHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSByZWN0YW5nbGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2hvdy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSkge1xuICAgIHN1cGVyKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSksIHRoaXMudmFsaWQgPSAhMCwgdGhpcy5maWx0ZXJGcmFtZSA9IG51bGwsIHRoaXMuZmlsdGVyUG9vbEtleSA9IG51bGwsIHRoaXMudXBkYXRlVXZzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIGB0aGlzLmJhc2VUZXh0dXJlLmZyYW1lYnVmZmVyYCwgc2F2ZXMgYmFzZVRleHR1cmUgY2FzdC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZnJhbWVidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmUuZnJhbWVidWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIGB0aGlzLmZyYW1lYnVmZmVyLm11bHRpc2FtcGxlYC5cbiAgICogQGRlZmF1bHQgUElYSS5NU0FBX1FVQUxJVFkuTk9ORVxuICAgKi9cbiAgZ2V0IG11bHRpc2FtcGxlKCkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lYnVmZmVyLm11bHRpc2FtcGxlO1xuICB9XG4gIHNldCBtdWx0aXNhbXBsZSh2YWx1ZSkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgUmVuZGVyVGV4dHVyZS5cbiAgICogQHBhcmFtIGRlc2lyZWRXaWR0aCAtIFRoZSBkZXNpcmVkIHdpZHRoIHRvIHJlc2l6ZSB0by5cbiAgICogQHBhcmFtIGRlc2lyZWRIZWlnaHQgLSBUaGUgZGVzaXJlZCBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgKiBAcGFyYW0gcmVzaXplQmFzZVRleHR1cmUgLSBTaG91bGQgdGhlIGJhc2VUZXh0dXJlLndpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIGJlIHJlc2l6ZWQgYXMgd2VsbD9cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIHJlc2l6ZUJhc2VUZXh0dXJlID0gITApIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uLCB3aWR0aCA9IE1hdGgucm91bmQoZGVzaXJlZFdpZHRoICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uLCBoZWlnaHQgPSBNYXRoLnJvdW5kKGRlc2lyZWRIZWlnaHQgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwLCB0aGlzLl9mcmFtZS53aWR0aCA9IHRoaXMub3JpZy53aWR0aCA9IHdpZHRoLCB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLm9yaWcuaGVpZ2h0ID0gaGVpZ2h0LCByZXNpemVCYXNlVGV4dHVyZSAmJiB0aGlzLmJhc2VUZXh0dXJlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSwgdGhpcy51cGRhdGVVdnMoKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgcmVzb2x1dGlvbiBvZiBiYXNlVGV4dHVyZSwgYnV0IGRvZXMgbm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzaXplLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSBuZXcgcmVzb2x1dGlvbiB0byBhcHBseSB0byBSZW5kZXJUZXh0dXJlXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBjb25zdCB7IGJhc2VUZXh0dXJlIH0gPSB0aGlzO1xuICAgIGJhc2VUZXh0dXJlLnJlc29sdXRpb24gIT09IHJlc29sdXRpb24gJiYgKGJhc2VUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbiksIHRoaXMucmVzaXplKGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsICExKSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD0xMDBdIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTEwMF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgKiBAcGFyYW0ge1BJWEkuU0NBTEVfTU9ERVN9IFtvcHRpb25zLnNjYWxlTW9kZT1QSVhJLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLnNjYWxlTW9kZV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9XG4gICAqICAgIGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249UElYSS5zZXR0aW5ncy5SRVNPTFVUSU9OXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSB0ZXh0dXJlXG4gICAqICAgIGJlaW5nIGdlbmVyYXRlZFxuICAgKiBAcGFyYW0ge1BJWEkuTVNBQV9RVUFMSVRZfSBbb3B0aW9ucy5tdWx0aXNhbXBsZT1QSVhJLk1TQUFfUVVBTElUWS5OT05FXSAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgcmVuZGVyIHRleHR1cmVcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVuZGVyVGV4dHVyZShuZXcgQmFzZVJlbmRlclRleHR1cmUob3B0aW9ucykpO1xuICB9XG59XG5leHBvcnQge1xuICBSZW5kZXJUZXh0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyVGV4dHVyZS5tanMubWFwXG4iLCJpbXBvcnQgeyBNU0FBX1FVQUxJVFkgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBuZXh0UG93MiB9IGZyb20gXCJAcGl4aS91dGlsc1wiO1xuaW1wb3J0IHsgQmFzZVJlbmRlclRleHR1cmUgfSBmcm9tIFwiLi9CYXNlUmVuZGVyVGV4dHVyZS5tanNcIjtcbmltcG9ydCB7IFJlbmRlclRleHR1cmUgfSBmcm9tIFwiLi9SZW5kZXJUZXh0dXJlLm1qc1wiO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVBvb2wge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmVPcHRpb25zIC0gb3B0aW9ucyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIEJhc2VSZW5kZXJUZXh0dXJlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW3RleHR1cmVPcHRpb25zLnNjYWxlTW9kZV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlT3B0aW9ucykge1xuICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fSwgdGhpcy50ZXh0dXJlT3B0aW9ucyA9IHRleHR1cmVPcHRpb25zIHx8IHt9LCB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSAhMSwgdGhpcy5fcGl4ZWxzV2lkdGggPSAwLCB0aGlzLl9waXhlbHNIZWlnaHQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHR1cmUgd2l0aCBwYXJhbXMgdGhhdCB3ZXJlIHNwZWNpZmllZCBpbiBwb29sIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gcmVhbFdpZHRoIC0gV2lkdGggb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSByZWFsSGVpZ2h0IC0gSGVpZ2h0IG9mIHRleHR1cmUgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0gbXVsdGlzYW1wbGUgLSBOdW1iZXIgb2Ygc2FtcGxlcyBvZiB0aGUgZnJhbWVidWZmZXIuXG4gICAqL1xuICBjcmVhdGVUZXh0dXJlKHJlYWxXaWR0aCwgcmVhbEhlaWdodCwgbXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORSkge1xuICAgIGNvbnN0IGJhc2VSZW5kZXJUZXh0dXJlID0gbmV3IEJhc2VSZW5kZXJUZXh0dXJlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgd2lkdGg6IHJlYWxXaWR0aCxcbiAgICAgIGhlaWdodDogcmVhbEhlaWdodCxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBtdWx0aXNhbXBsZVxuICAgIH0sIHRoaXMudGV4dHVyZU9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV3IFJlbmRlclRleHR1cmUoYmFzZVJlbmRlclRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxuICAgKiBAcGFyYW0gbWluV2lkdGggLSBUaGUgbWluaW11bSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIG11bHRpc2FtcGxlIC0gTnVtYmVyIG9mIHNhbXBsZXMgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0T3B0aW1hbFRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiA9IDEsIG11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkUpIHtcbiAgICBsZXQga2V5O1xuICAgIG1pbldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKG1pbldpZHRoICogcmVzb2x1dGlvbiAtIDFlLTYpLCAxKSwgbWluSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKG1pbkhlaWdodCAqIHJlc29sdXRpb24gLSAxZS02KSwgMSksICF0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gfHwgbWluV2lkdGggIT09IHRoaXMuX3BpeGVsc1dpZHRoIHx8IG1pbkhlaWdodCAhPT0gdGhpcy5fcGl4ZWxzSGVpZ2h0ID8gKG1pbldpZHRoID0gbmV4dFBvdzIobWluV2lkdGgpLCBtaW5IZWlnaHQgPSBuZXh0UG93MihtaW5IZWlnaHQpLCBrZXkgPSAoKG1pbldpZHRoICYgNjU1MzUpIDw8IDE2IHwgbWluSGVpZ2h0ICYgNjU1MzUpID4+PiAwLCBtdWx0aXNhbXBsZSA+IDEgJiYgKGtleSArPSBtdWx0aXNhbXBsZSAqIDQyOTQ5NjcyOTYpKSA6IGtleSA9IG11bHRpc2FtcGxlID4gMSA/IC1tdWx0aXNhbXBsZSA6IC0xLCB0aGlzLnRleHR1cmVQb29sW2tleV0gfHwgKHRoaXMudGV4dHVyZVBvb2xba2V5XSA9IFtdKTtcbiAgICBsZXQgcmVuZGVyVGV4dHVyZSA9IHRoaXMudGV4dHVyZVBvb2xba2V5XS5wb3AoKTtcbiAgICByZXR1cm4gcmVuZGVyVGV4dHVyZSB8fCAocmVuZGVyVGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCBtdWx0aXNhbXBsZSkpLCByZW5kZXJUZXh0dXJlLmZpbHRlclBvb2xLZXkgPSBrZXksIHJlbmRlclRleHR1cmUuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSwgcmVuZGVyVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBleHRyYSB0ZXh0dXJlIG9mIHRoZSBzYW1lIHNpemUgYXMgaW5wdXQgcmVuZGVyVGV4dHVyZVxuICAgKlxuICAgKiBgZ2V0RmlsdGVyVGV4dHVyZShpbnB1dCwgMC41KWAgb3IgYGdldEZpbHRlclRleHR1cmUoMC41LCBpbnB1dClgXG4gICAqIEBwYXJhbSBpbnB1dCAtIHJlbmRlclRleHR1cmUgZnJvbSB3aGljaCBzaXplIGFuZCByZXNvbHV0aW9uIHdpbGwgYmUgY29waWVkXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gb3ZlcnJpZGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyVGV4dHVyZVxuICAgKiAgSXQgb3ZlcnJpZGVzLCBpdCBkb2VzIG5vdCBtdWx0aXBseVxuICAgKiBAcGFyYW0gbXVsdGlzYW1wbGUgLSBudW1iZXIgb2Ygc2FtcGxlcyBvZiB0aGUgcmVuZGVyVGV4dHVyZVxuICAgKi9cbiAgZ2V0RmlsdGVyVGV4dHVyZShpbnB1dCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpIHtcbiAgICBjb25zdCBmaWx0ZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgIGlucHV0LndpZHRoLFxuICAgICAgaW5wdXQuaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbiB8fCBpbnB1dC5yZXNvbHV0aW9uLFxuICAgICAgbXVsdGlzYW1wbGUgfHwgTVNBQV9RVUFMSVRZLk5PTkVcbiAgICApO1xuICAgIHJldHVybiBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gaW5wdXQuZmlsdGVyRnJhbWUsIGZpbHRlclRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFBsYWNlIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXJUZXh0dXJlIHRvIGZyZWVcbiAgICovXG4gIHJldHVyblRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgIGNvbnN0IGtleSA9IHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleTtcbiAgICByZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gbnVsbCwgdGhpcy50ZXh0dXJlUG9vbFtrZXldLnB1c2gocmVuZGVyVGV4dHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciByZXR1cm5UZXh0dXJlLCB0byBiZSBjb21wbGlhbnQgd2l0aCBGaWx0ZXJTeXN0ZW0gaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0gcmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXJUZXh0dXJlIHRvIGZyZWVcbiAgICovXG4gIHJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgIHRoaXMucmV0dXJuVGV4dHVyZShyZW5kZXJUZXh0dXJlKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gZGVzdHJveVRleHR1cmVzIC0gRGVzdHJveSBhbGwgc3RvcmVkIHRleHR1cmVzLlxuICAgKi9cbiAgY2xlYXIoZGVzdHJveVRleHR1cmVzKSB7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlcyA9IGRlc3Ryb3lUZXh0dXJlcyAhPT0gITEsIGRlc3Ryb3lUZXh0dXJlcylcbiAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnRleHR1cmVQb29sKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVzID0gdGhpcy50ZXh0dXJlUG9vbFtpXTtcbiAgICAgICAgaWYgKHRleHR1cmVzKVxuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KCEwKTtcbiAgICAgIH1cbiAgICB0aGlzLnRleHR1cmVQb29sID0ge307XG4gIH1cbiAgLyoqXG4gICAqIElmIHNjcmVlbiBzaXplIHdhcyBjaGFuZ2VkLCBkcm9wcyBhbGwgc2NyZWVuLXNpemVkIHRleHR1cmVzLFxuICAgKiBzZXRzIG5ldyBzY3JlZW4gc2l6ZSwgc2V0cyBgZW5hYmxlRnVsbFNjcmVlbmAgdG8gdHJ1ZVxuICAgKlxuICAgKiBTaXplIGlzIG1lYXN1cmVkIGluIHBpeGVscywgYHJlbmRlcmVyLnZpZXdgIGNhbiBiZSBwYXNzZWQgaGVyZSwgbm90IGByZW5kZXJlci5zY3JlZW5gXG4gICAqIEBwYXJhbSBzaXplIC0gSW5pdGlhbCBzaXplIG9mIHNjcmVlbi5cbiAgICovXG4gIHNldFNjcmVlblNpemUoc2l6ZSkge1xuICAgIGlmICghKHNpemUud2lkdGggPT09IHRoaXMuX3BpeGVsc1dpZHRoICYmIHNpemUuaGVpZ2h0ID09PSB0aGlzLl9waXhlbHNIZWlnaHQpKSB7XG4gICAgICB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSBzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDA7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlUG9vbCkge1xuICAgICAgICBpZiAoIShOdW1iZXIoaSkgPCAwKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW2ldO1xuICAgICAgICBpZiAodGV4dHVyZXMpXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIHRleHR1cmVzW2pdLmRlc3Ryb3koITApO1xuICAgICAgICB0aGlzLnRleHR1cmVQb29sW2ldID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9waXhlbHNXaWR0aCA9IHNpemUud2lkdGgsIHRoaXMuX3BpeGVsc0hlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgfVxufVxuUmVuZGVyVGV4dHVyZVBvb2wuU0NSRUVOX0tFWSA9IC0xO1xuZXhwb3J0IHtcbiAgUmVuZGVyVGV4dHVyZVBvb2xcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlUG9vbC5tanMubWFwXG4iLCJpbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCIuLi9nZW9tZXRyeS9HZW9tZXRyeS5tanNcIjtcbmNsYXNzIFF1YWQgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICBdKSkuYWRkSW5kZXgoWzAsIDEsIDMsIDJdKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUXVhZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcIi4uL2dlb21ldHJ5L0J1ZmZlci5tanNcIjtcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSBcIi4uL2dlb21ldHJ5L0dlb21ldHJ5Lm1qc1wiO1xuY2xhc3MgUXVhZFV2IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAtMSxcbiAgICAgIDFcbiAgICBdKSwgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgXSksIHRoaXMudmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzLnZlcnRpY2VzKSwgdGhpcy51dkJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy51dnMpLCB0aGlzLmFkZEF0dHJpYnV0ZShcImFWZXJ0ZXhQb3NpdGlvblwiLCB0aGlzLnZlcnRleEJ1ZmZlcikuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB0aGlzLnV2QnVmZmVyKS5hZGRJbmRleChbMCwgMSwgMiwgMCwgMiwgM10pO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHR3byBSZWN0YW5nbGUgdG8gdGhlIHF1YWQuXG4gICAqIEBwYXJhbSB0YXJnZXRUZXh0dXJlRnJhbWUgLSBUaGUgZmlyc3QgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIHNlY29uZCByZWN0YW5nbGVcbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIG1hcCh0YXJnZXRUZXh0dXJlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICBsZXQgeCA9IDAsIHkgPSAwO1xuICAgIHJldHVybiB0aGlzLnV2c1swXSA9IHgsIHRoaXMudXZzWzFdID0geSwgdGhpcy51dnNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aCwgdGhpcy51dnNbM10gPSB5LCB0aGlzLnV2c1s0XSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoLCB0aGlzLnV2c1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQsIHRoaXMudXZzWzZdID0geCwgdGhpcy51dnNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0LCB4ID0gZGVzdGluYXRpb25GcmFtZS54LCB5ID0gZGVzdGluYXRpb25GcmFtZS55LCB0aGlzLnZlcnRpY2VzWzBdID0geCwgdGhpcy52ZXJ0aWNlc1sxXSA9IHksIHRoaXMudmVydGljZXNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCwgdGhpcy52ZXJ0aWNlc1szXSA9IHksIHRoaXMudmVydGljZXNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aCwgdGhpcy52ZXJ0aWNlc1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCwgdGhpcy52ZXJ0aWNlc1s2XSA9IHgsIHRoaXMudmVydGljZXNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQsIHRoaXMuaW52YWxpZGF0ZSgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBMZWdhY3kgdXBsb2FkIG1ldGhvZCwganVzdCBtYXJrcyBidWZmZXJzIGRpcnR5LlxuICAgKiBAcmV0dXJucyAtIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhCdWZmZXIuX3VwZGF0ZUlEKyssIHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEKyssIHRoaXM7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFF1YWRVdlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWRVdi5tanMubWFwXG4iLCJpbXBvcnQgeyBNU0FBX1FVQUxJVFkgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiQHBpeGkvbWF0aFwiO1xuY2xhc3MgRmlsdGVyU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsLCB0aGlzLnRhcmdldCA9IG51bGwsIHRoaXMubGVnYWN5ID0gITEsIHRoaXMucmVzb2x1dGlvbiA9IDEsIHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORSwgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBSZWN0YW5nbGUoKSwgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbmV3IFJlY3RhbmdsZSgpLCB0aGlzLmJpbmRpbmdTb3VyY2VGcmFtZSA9IG5ldyBSZWN0YW5nbGUoKSwgdGhpcy5iaW5kaW5nRGVzdGluYXRpb25GcmFtZSA9IG5ldyBSZWN0YW5nbGUoKSwgdGhpcy5maWx0ZXJzID0gW10sIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgfVxuICAvKiogQ2xlYXJzIHRoZSBzdGF0ZSAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnRhcmdldCA9IG51bGwsIHRoaXMuZmlsdGVycyA9IG51bGwsIHRoaXMucmVuZGVyVGV4dHVyZSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEZpbHRlclN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyU3RhdGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ0xFQVJfTU9ERVMsIERSQVdfTU9ERVMsIE1TQUFfUVVBTElUWSB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgUG9pbnQsIE1hdHJpeCwgUmVjdGFuZ2xlIH0gZnJvbSBcIkBwaXhpL21hdGhcIjtcbmltcG9ydCB7IFJlbmRlclRleHR1cmVQb29sIH0gZnJvbSBcIi4uL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVBvb2wubWpzXCI7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tIFwiLi4vc2hhZGVyL1VuaWZvcm1Hcm91cC5tanNcIjtcbmltcG9ydCB7IFF1YWQgfSBmcm9tIFwiLi4vdXRpbHMvUXVhZC5tanNcIjtcbmltcG9ydCB7IFF1YWRVdiB9IGZyb20gXCIuLi91dGlscy9RdWFkVXYubWpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJTdGF0ZSB9IGZyb20gXCIuL0ZpbHRlclN0YXRlLm1qc1wiO1xuY29uc3QgdGVtcFBvaW50cyA9IFtuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCBuZXcgUG9pbnQoKV0sIHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBGaWx0ZXJTeXN0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjayA9IFt7fV0sIHRoaXMudGV4dHVyZVBvb2wgPSBuZXcgUmVuZGVyVGV4dHVyZVBvb2woKSwgdGhpcy5zdGF0ZVBvb2wgPSBbXSwgdGhpcy5xdWFkID0gbmV3IFF1YWQoKSwgdGhpcy5xdWFkVXYgPSBuZXcgUXVhZFV2KCksIHRoaXMudGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKCksIHRoaXMuYWN0aXZlU3RhdGUgPSB7fSwgdGhpcy5nbG9iYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgb3V0cHV0RnJhbWU6IG5ldyBSZWN0YW5nbGUoKSxcbiAgICAgIGlucHV0U2l6ZTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIGlucHV0UGl4ZWw6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICBpbnB1dENsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIC8vIGxlZ2FjeSB2YXJpYWJsZXNcbiAgICAgIGZpbHRlckFyZWE6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICBmaWx0ZXJDbGFtcDogbmV3IEZsb2F0MzJBcnJheSg0KVxuICAgIH0sICEwKSwgdGhpcy5mb3JjZUNsZWFyID0gITEsIHRoaXMudXNlTWF4UGFkZGluZyA9ICExO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5zZXRTY3JlZW5TaXplKHRoaXMucmVuZGVyZXIudmlldyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2hlcyBhIHNldCBvZiBmaWx0ZXJzIHRvIGJlIGFwcGxpZWQgbGF0ZXIgdG8gdGhlIHN5c3RlbS4gVGhpcyB3aWxsIHJlZGlyZWN0IGZ1cnRoZXIgcmVuZGVyaW5nIGludG8gYW5cbiAgICogaW5wdXQgcmVuZGVyLXRleHR1cmUgZm9yIHRoZSByZXN0IG9mIHRoZSBmaWx0ZXJpbmcgcGlwZWxpbmUuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9mIHRoZSBmaWx0ZXIgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5LlxuICAgKi9cbiAgcHVzaCh0YXJnZXQsIGZpbHRlcnMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsIGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2ssIHN0YXRlID0gdGhpcy5zdGF0ZVBvb2wucG9wKCkgfHwgbmV3IEZpbHRlclN0YXRlKCksIHJlbmRlclRleHR1cmVTeXN0ZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlO1xuICAgIGxldCBjdXJyZW50UmVzb2x1dGlvbiwgY3VycmVudE11bHRpc2FtcGxlO1xuICAgIGlmIChyZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQ7XG4gICAgICBjdXJyZW50UmVzb2x1dGlvbiA9IHJlbmRlclRleHR1cmUucmVzb2x1dGlvbiwgY3VycmVudE11bHRpc2FtcGxlID0gcmVuZGVyVGV4dHVyZS5tdWx0aXNhbXBsZTtcbiAgICB9IGVsc2VcbiAgICAgIGN1cnJlbnRSZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgY3VycmVudE11bHRpc2FtcGxlID0gcmVuZGVyZXIubXVsdGlzYW1wbGU7XG4gICAgbGV0IHJlc29sdXRpb24gPSBmaWx0ZXJzWzBdLnJlc29sdXRpb24gfHwgY3VycmVudFJlc29sdXRpb24sIG11bHRpc2FtcGxlID0gZmlsdGVyc1swXS5tdWx0aXNhbXBsZSA/PyBjdXJyZW50TXVsdGlzYW1wbGUsIHBhZGRpbmcgPSBmaWx0ZXJzWzBdLnBhZGRpbmcsIGF1dG9GaXQgPSBmaWx0ZXJzWzBdLmF1dG9GaXQsIGxlZ2FjeSA9IGZpbHRlcnNbMF0ubGVnYWN5ID8/ICEwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBmaWx0ZXIucmVzb2x1dGlvbiB8fCBjdXJyZW50UmVzb2x1dGlvbiksIG11bHRpc2FtcGxlID0gTWF0aC5taW4obXVsdGlzYW1wbGUsIGZpbHRlci5tdWx0aXNhbXBsZSA/PyBjdXJyZW50TXVsdGlzYW1wbGUpLCBwYWRkaW5nID0gdGhpcy51c2VNYXhQYWRkaW5nID8gTWF0aC5tYXgocGFkZGluZywgZmlsdGVyLnBhZGRpbmcpIDogcGFkZGluZyArIGZpbHRlci5wYWRkaW5nLCBhdXRvRml0ID0gYXV0b0ZpdCAmJiBmaWx0ZXIuYXV0b0ZpdCwgbGVnYWN5ID0gbGVnYWN5IHx8IChmaWx0ZXIubGVnYWN5ID8/ICEwKTtcbiAgICB9XG4gICAgZmlsdGVyU3RhY2subGVuZ3RoID09PSAxICYmICh0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1swXS5yZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50KSwgZmlsdGVyU3RhY2sucHVzaChzdGF0ZSksIHN0YXRlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uLCBzdGF0ZS5tdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlLCBzdGF0ZS5sZWdhY3kgPSBsZWdhY3ksIHN0YXRlLnRhcmdldCA9IHRhcmdldCwgc3RhdGUuc291cmNlRnJhbWUuY29weUZyb20odGFyZ2V0LmZpbHRlckFyZWEgfHwgdGFyZ2V0LmdldEJvdW5kcyghMCkpLCBzdGF0ZS5zb3VyY2VGcmFtZS5wYWQocGFkZGluZyk7XG4gICAgY29uc3Qgc291cmNlRnJhbWVQcm9qZWN0ZWQgPSB0aGlzLnRlbXBSZWN0LmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUpO1xuICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtICYmIHRoaXMudHJhbnNmb3JtQUFCQihcbiAgICAgIHRlbXBNYXRyaXguY29weUZyb20ocmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pLmludmVydCgpLFxuICAgICAgc291cmNlRnJhbWVQcm9qZWN0ZWRcbiAgICApLCBhdXRvRml0ID8gKHN0YXRlLnNvdXJjZUZyYW1lLmZpdChzb3VyY2VGcmFtZVByb2plY3RlZCksIChzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCA8PSAwIHx8IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCA8PSAwKSAmJiAoc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgPSAwKSkgOiBzdGF0ZS5zb3VyY2VGcmFtZS5pbnRlcnNlY3RzKHNvdXJjZUZyYW1lUHJvamVjdGVkKSB8fCAoc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgPSAwKSwgdGhpcy5yb3VuZEZyYW1lKFxuICAgICAgc3RhdGUuc291cmNlRnJhbWUsXG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQgPyByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQucmVzb2x1dGlvbiA6IHJlbmRlcmVyLnJlc29sdXRpb24sXG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lLFxuICAgICAgcmVuZGVyVGV4dHVyZVN5c3RlbS5kZXN0aW5hdGlvbkZyYW1lLFxuICAgICAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm1cbiAgICApLCBzdGF0ZS5yZW5kZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShcbiAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLFxuICAgICAgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIG11bHRpc2FtcGxlXG4gICAgKSwgc3RhdGUuZmlsdGVycyA9IGZpbHRlcnMsIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5yZW5kZXJUZXh0dXJlLndpZHRoLCBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHN0YXRlLnJlbmRlclRleHR1cmUuaGVpZ2h0O1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRnJhbWUgPSB0aGlzLnRlbXBSZWN0O1xuICAgIGRlc3RpbmF0aW9uRnJhbWUueCA9IDAsIGRlc3RpbmF0aW9uRnJhbWUueSA9IDAsIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHN0YXRlLnJlbmRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBzdGF0ZS5zb3VyY2VGcmFtZSwgc3RhdGUuYmluZGluZ1NvdXJjZUZyYW1lLmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUpLCBzdGF0ZS5iaW5kaW5nRGVzdGluYXRpb25GcmFtZS5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUpLCBzdGF0ZS50cmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSwgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsLCByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoc3RhdGUucmVuZGVyVGV4dHVyZSwgc3RhdGUuc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpLCByZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcigwLCAwLCAwLCAwKTtcbiAgfVxuICAvKiogUG9wcyBvZmYgdGhlIGZpbHRlciBhbmQgYXBwbGllcyBpdC4gKi9cbiAgcG9wKCkge1xuICAgIGNvbnN0IGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2ssIHN0YXRlID0gZmlsdGVyU3RhY2sucG9wKCksIGZpbHRlcnMgPSBzdGF0ZS5maWx0ZXJzO1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBzdGF0ZTtcbiAgICBjb25zdCBnbG9iYWxVbmlmb3JtcyA9IHRoaXMuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgZ2xvYmFsVW5pZm9ybXMub3V0cHV0RnJhbWUgPSBzdGF0ZS5zb3VyY2VGcmFtZSwgZ2xvYmFsVW5pZm9ybXMucmVzb2x1dGlvbiA9IHN0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgaW5wdXRTaXplID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRTaXplLCBpbnB1dFBpeGVsID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRQaXhlbCwgaW5wdXRDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgaWYgKGlucHV0U2l6ZVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGgsIGlucHV0U2l6ZVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0LCBpbnB1dFNpemVbMl0gPSAxIC8gaW5wdXRTaXplWzBdLCBpbnB1dFNpemVbM10gPSAxIC8gaW5wdXRTaXplWzFdLCBpbnB1dFBpeGVsWzBdID0gTWF0aC5yb3VuZChpbnB1dFNpemVbMF0gKiBzdGF0ZS5yZXNvbHV0aW9uKSwgaW5wdXRQaXhlbFsxXSA9IE1hdGgucm91bmQoaW5wdXRTaXplWzFdICogc3RhdGUucmVzb2x1dGlvbiksIGlucHV0UGl4ZWxbMl0gPSAxIC8gaW5wdXRQaXhlbFswXSwgaW5wdXRQaXhlbFszXSA9IDEgLyBpbnB1dFBpeGVsWzFdLCBpbnB1dENsYW1wWzBdID0gMC41ICogaW5wdXRQaXhlbFsyXSwgaW5wdXRDbGFtcFsxXSA9IDAuNSAqIGlucHV0UGl4ZWxbM10sIGlucHV0Q2xhbXBbMl0gPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSAtIDAuNSAqIGlucHV0UGl4ZWxbMl0sIGlucHV0Q2xhbXBbM10gPSBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10gLSAwLjUgKiBpbnB1dFBpeGVsWzNdLCBzdGF0ZS5sZWdhY3kpIHtcbiAgICAgIGNvbnN0IGZpbHRlckFyZWEgPSBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJBcmVhO1xuICAgICAgZmlsdGVyQXJlYVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGgsIGZpbHRlckFyZWFbMV0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCwgZmlsdGVyQXJlYVsyXSA9IHN0YXRlLnNvdXJjZUZyYW1lLngsIGZpbHRlckFyZWFbM10gPSBzdGF0ZS5zb3VyY2VGcmFtZS55LCBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgfVxuICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gZmlsdGVyU3RhY2tbZmlsdGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmxpdCgpLCBmaWx0ZXJzLmxlbmd0aCA9PT0gMSlcbiAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcywgc3RhdGUucmVuZGVyVGV4dHVyZSwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIENMRUFSX01PREVTLkJMRU5ELCBzdGF0ZSksIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShzdGF0ZS5yZW5kZXJUZXh0dXJlKTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBmbGlwID0gc3RhdGUucmVuZGVyVGV4dHVyZSwgZmxvcCA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUoXG4gICAgICAgIGZsaXAud2lkdGgsXG4gICAgICAgIGZsaXAuaGVpZ2h0LFxuICAgICAgICBzdGF0ZS5yZXNvbHV0aW9uXG4gICAgICApO1xuICAgICAgZmxvcC5maWx0ZXJGcmFtZSA9IGZsaXAuZmlsdGVyRnJhbWU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgaSA9PT0gMSAmJiBzdGF0ZS5tdWx0aXNhbXBsZSA+IDEgJiYgKGZsb3AgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKFxuICAgICAgICAgIGZsaXAud2lkdGgsXG4gICAgICAgICAgZmxpcC5oZWlnaHQsXG4gICAgICAgICAgc3RhdGUucmVzb2x1dGlvblxuICAgICAgICApLCBmbG9wLmZpbHRlckZyYW1lID0gZmxpcC5maWx0ZXJGcmFtZSksIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgQ0xFQVJfTU9ERVMuQ0xFQVIsIHN0YXRlKTtcbiAgICAgICAgY29uc3QgdCA9IGZsaXA7XG4gICAgICAgIGZsaXAgPSBmbG9wLCBmbG9wID0gdDtcbiAgICAgIH1cbiAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIENMRUFSX01PREVTLkJMRU5ELCBzdGF0ZSksIGkgPiAxICYmIHN0YXRlLm11bHRpc2FtcGxlID4gMSAmJiB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoc3RhdGUucmVuZGVyVGV4dHVyZSksIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbGlwKSwgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKGZsb3ApO1xuICAgIH1cbiAgICBzdGF0ZS5jbGVhcigpLCB0aGlzLnN0YXRlUG9vbC5wdXNoKHN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgYSByZW5kZXJUZXh0dXJlIHdpdGggY29ycmVzcG9uZGluZyBgZmlsdGVyRnJhbWVgLCBjbGVhcnMgaXQgaWYgbW9kZSBjb3JyZXNwb25kcy5cbiAgICogQHBhcmFtIGZpbHRlclRleHR1cmUgLSByZW5kZXJUZXh0dXJlIHRvIGJpbmQsIHNob3VsZCBiZWxvbmcgdG8gZmlsdGVyIHBvb2wgb3IgZmlsdGVyIHN0YWNrXG4gICAqIEBwYXJhbSBjbGVhck1vZGUgLSBjbGVhck1vZGUsIGJ5IGRlZmF1bHQgaXRzIENMRUFSL1lFUy4gU2VlIHtAbGluayBQSVhJLkNMRUFSX01PREVTfVxuICAgKi9cbiAgYmluZEFuZENsZWFyKGZpbHRlclRleHR1cmUsIGNsZWFyTW9kZSA9IENMRUFSX01PREVTLkNMRUFSKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyVGV4dHVyZTogcmVuZGVyVGV4dHVyZVN5c3RlbSxcbiAgICAgIHN0YXRlOiBzdGF0ZVN5c3RlbVxuICAgIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmIChmaWx0ZXJUZXh0dXJlID09PSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1t0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjay5sZW5ndGggLSAxXS5yZW5kZXJUZXh0dXJlID8gdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IHRoaXMuYWN0aXZlU3RhdGUudHJhbnNmb3JtIDogdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IG51bGwsIGZpbHRlclRleHR1cmU/LmZpbHRlckZyYW1lKSB7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkZyYW1lID0gdGhpcy50ZW1wUmVjdDtcbiAgICAgIGRlc3RpbmF0aW9uRnJhbWUueCA9IDAsIGRlc3RpbmF0aW9uRnJhbWUueSA9IDAsIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lLndpZHRoLCBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUuaGVpZ2h0LCByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoZmlsdGVyVGV4dHVyZSwgZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZSwgZGVzdGluYXRpb25GcmFtZSk7XG4gICAgfSBlbHNlXG4gICAgICBmaWx0ZXJUZXh0dXJlICE9PSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1t0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjay5sZW5ndGggLSAxXS5yZW5kZXJUZXh0dXJlID8gcmVuZGVyVGV4dHVyZVN5c3RlbS5iaW5kKGZpbHRlclRleHR1cmUpIDogdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoXG4gICAgICAgIGZpbHRlclRleHR1cmUsXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGUuYmluZGluZ1NvdXJjZUZyYW1lLFxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlLmJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lXG4gICAgICApO1xuICAgIGNvbnN0IGF1dG9DbGVhciA9IHN0YXRlU3lzdGVtLnN0YXRlSWQgJiAxIHx8IHRoaXMuZm9yY2VDbGVhcjtcbiAgICAoY2xlYXJNb2RlID09PSBDTEVBUl9NT0RFUy5DTEVBUiB8fCBjbGVhck1vZGUgPT09IENMRUFSX01PREVTLkJMSVQgJiYgYXV0b0NsZWFyKSAmJiB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmNsZWFyKDAsIDAsIDAsIDApO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGZpbHRlciB1c2luZyB0aGUgZGVmYXVsdCByZW5kZXJpbmcgcHJvY2Vzcy5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIG9ubHkgYnkge0BsaW5rIFBJWEkuRmlsdGVyI2FwcGx5fS5cbiAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgdG8gZHJhdy5cbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICogQHBhcmFtIGNsZWFyTW9kZSAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdFxuICAgKi9cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KGZpbHRlci5zdGF0ZSksIHRoaXMuYmluZEFuZENsZWFyKG91dHB1dCwgY2xlYXJNb2RlKSwgZmlsdGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gaW5wdXQsIGZpbHRlci51bmlmb3Jtcy5maWx0ZXJHbG9iYWxzID0gdGhpcy5nbG9iYWxVbmlmb3JtcywgcmVuZGVyZXIuc2hhZGVyLmJpbmQoZmlsdGVyKSwgZmlsdGVyLmxlZ2FjeSA9ICEhZmlsdGVyLnByb2dyYW0uYXR0cmlidXRlRGF0YS5hVGV4dHVyZUNvb3JkLCBmaWx0ZXIubGVnYWN5ID8gKHRoaXMucXVhZFV2Lm1hcChpbnB1dC5fZnJhbWUsIGlucHV0LmZpbHRlckZyYW1lKSwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWRVdiksIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoRFJBV19NT0RFUy5UUklBTkdMRVMpKSA6IChyZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMucXVhZCksIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoRFJBV19NT0RFUy5UUklBTkdMRV9TVFJJUCkpO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSBfaW5wdXQgbm9ybWFsaXplZCBjb29yZGluYXRlc18gdG8gdGhpcyBtYXRyaXggdG8gZ2V0IF9zcHJpdGUgdGV4dHVyZSBub3JtYWxpemVkIGNvb3JkaW5hdGVzXy5cbiAgICpcbiAgICogVXNlIGBvdXRwdXRNYXRyaXggKiB2VGV4dHVyZUNvb3JkYCBpbiB0aGUgc2hhZGVyLlxuICAgKiBAcGFyYW0gb3V0cHV0TWF0cml4IC0gVGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IHNwcml0ZSAtIFRoZSBzcHJpdGUgdG8gbWFwIHRvLlxuICAgKiBAcmV0dXJucyBUaGUgbWFwcGVkIG1hdHJpeC5cbiAgICovXG4gIGNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIHNwcml0ZSkge1xuICAgIGNvbnN0IHsgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUgfSA9IHRoaXMuYWN0aXZlU3RhdGUsIHsgb3JpZyB9ID0gc3ByaXRlLl90ZXh0dXJlLCBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KFxuICAgICAgZGVzdGluYXRpb25GcmFtZS53aWR0aCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQsXG4gICAgICBzb3VyY2VGcmFtZS54LFxuICAgICAgc291cmNlRnJhbWUueVxuICAgICksIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHlUbyhNYXRyaXguVEVNUF9NQVRSSVgpO1xuICAgIHJldHVybiB3b3JsZFRyYW5zZm9ybS5pbnZlcnQoKSwgbWFwcGVkTWF0cml4LnByZXBlbmQod29ybGRUcmFuc2Zvcm0pLCBtYXBwZWRNYXRyaXguc2NhbGUoMSAvIG9yaWcud2lkdGgsIDEgLyBvcmlnLmhlaWdodCksIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpLCBtYXBwZWRNYXRyaXg7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgRmlsdGVyIFN5c3RlbS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbCwgdGhpcy50ZXh0dXJlUG9vbC5jbGVhcighMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBQb3dlci1vZi1Ud28gcmVuZGVyIHRleHR1cmUgb3IgZnVsbFNjcmVlbiB0ZXh0dXJlXG4gICAqIEBwYXJhbSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZSBpbiByZWFsIHBpeGVscy5cbiAgICogQHBhcmFtIG1pbkhlaWdodCAtIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmUgaW4gcmVhbCBwaXhlbHMuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gbXVsdGlzYW1wbGUgLSBOdW1iZXIgb2Ygc2FtcGxlcyBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEByZXR1cm5zIC0gVGhlIG5ldyByZW5kZXIgdGV4dHVyZS5cbiAgICovXG4gIGdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24gPSAxLCBtdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGV4dHJhIHJlbmRlciB0ZXh0dXJlIHRvIHVzZSBpbnNpZGUgY3VycmVudCBmaWx0ZXJcbiAgICogVG8gYmUgY29tcGxpYW50IHdpdGggb2xkZXIgZmlsdGVycywgeW91IGNhbiB1c2UgcGFyYW1zIGluIGFueSBvcmRlclxuICAgKiBAcGFyYW0gaW5wdXQgLSByZW5kZXJUZXh0dXJlIGZyb20gd2hpY2ggc2l6ZSBhbmQgcmVzb2x1dGlvbiB3aWxsIGJlIGNvcGllZFxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIG92ZXJyaWRlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlclRleHR1cmVcbiAgICogQHBhcmFtIG11bHRpc2FtcGxlIC0gbnVtYmVyIG9mIHNhbXBsZXMgb2YgdGhlIHJlbmRlclRleHR1cmVcbiAgICovXG4gIGdldEZpbHRlclRleHR1cmUoaW5wdXQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBzd2FwID0gaW5wdXQ7XG4gICAgICBpbnB1dCA9IHJlc29sdXRpb24sIHJlc29sdXRpb24gPSBzd2FwO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0IHx8IHRoaXMuYWN0aXZlU3RhdGUucmVuZGVyVGV4dHVyZTtcbiAgICBjb25zdCBmaWx0ZXJUZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgIGlucHV0LndpZHRoLFxuICAgICAgaW5wdXQuaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbiB8fCBpbnB1dC5yZXNvbHV0aW9uLFxuICAgICAgbXVsdGlzYW1wbGUgfHwgTVNBQV9RVUFMSVRZLk5PTkVcbiAgICApO1xuICAgIHJldHVybiBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gaW5wdXQuZmlsdGVyRnJhbWUsIGZpbHRlclRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIEZyZWVzIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXJUYXJnZXQgdG8gZnJlZVxuICAgKi9cbiAgcmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKHJlbmRlclRleHR1cmUpO1xuICB9XG4gIC8qKiBFbXB0aWVzIHRoZSB0ZXh0dXJlIHBvb2wuICovXG4gIGVtcHR5UG9vbCgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLmNsZWFyKCEwKTtcbiAgfVxuICAvKiogQ2FsbHMgYHRleHR1cmVQb29sLnJlc2l6ZSgpYCwgYWZmZWN0cyBmdWxsU2NyZWVuIHJlbmRlclRleHR1cmVzLiAqL1xuICByZXNpemUoKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5zZXRTY3JlZW5TaXplKHRoaXMucmVuZGVyZXIudmlldyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBtYXRyaXggLSBmaXJzdCBwYXJhbVxuICAgKiBAcGFyYW0gcmVjdCAtIHNlY29uZCBwYXJhbVxuICAgKi9cbiAgdHJhbnNmb3JtQUFCQihtYXRyaXgsIHJlY3QpIHtcbiAgICBjb25zdCBsdCA9IHRlbXBQb2ludHNbMF0sIGxiID0gdGVtcFBvaW50c1sxXSwgcnQgPSB0ZW1wUG9pbnRzWzJdLCByYiA9IHRlbXBQb2ludHNbM107XG4gICAgbHQuc2V0KHJlY3QubGVmdCwgcmVjdC50b3ApLCBsYi5zZXQocmVjdC5sZWZ0LCByZWN0LmJvdHRvbSksIHJ0LnNldChyZWN0LnJpZ2h0LCByZWN0LnRvcCksIHJiLnNldChyZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSksIG1hdHJpeC5hcHBseShsdCwgbHQpLCBtYXRyaXguYXBwbHkobGIsIGxiKSwgbWF0cml4LmFwcGx5KHJ0LCBydCksIG1hdHJpeC5hcHBseShyYiwgcmIpO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4obHQueCwgbGIueCwgcnQueCwgcmIueCksIHkwID0gTWF0aC5taW4obHQueSwgbGIueSwgcnQueSwgcmIueSksIHgxID0gTWF0aC5tYXgobHQueCwgbGIueCwgcnQueCwgcmIueCksIHkxID0gTWF0aC5tYXgobHQueSwgbGIueSwgcnQueSwgcmIueSk7XG4gICAgcmVjdC54ID0geDAsIHJlY3QueSA9IHkwLCByZWN0LndpZHRoID0geDEgLSB4MCwgcmVjdC5oZWlnaHQgPSB5MSAtIHkwO1xuICB9XG4gIHJvdW5kRnJhbWUoZnJhbWUsIHJlc29sdXRpb24sIGJpbmRpbmdTb3VyY2VGcmFtZSwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUsIHRyYW5zZm9ybSkge1xuICAgIGlmICghKGZyYW1lLndpZHRoIDw9IDAgfHwgZnJhbWUuaGVpZ2h0IDw9IDAgfHwgYmluZGluZ1NvdXJjZUZyYW1lLndpZHRoIDw9IDAgfHwgYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodCA8PSAwKSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IHRyYW5zZm9ybTtcbiAgICAgICAgaWYgKChNYXRoLmFicyhiKSA+IDFlLTQgfHwgTWF0aC5hYnMoYykgPiAxZS00KSAmJiAoTWF0aC5hYnMoYSkgPiAxZS00IHx8IE1hdGguYWJzKGQpID4gMWUtNCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtID8gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pIDogdGVtcE1hdHJpeC5pZGVudGl0eSgpLCB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShcbiAgICAgICAgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUud2lkdGggLyBiaW5kaW5nU291cmNlRnJhbWUud2lkdGgsXG4gICAgICAgIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIGJpbmRpbmdTb3VyY2VGcmFtZS5oZWlnaHRcbiAgICAgICkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpLCB0aGlzLnRyYW5zZm9ybUFBQkIodHJhbnNmb3JtLCBmcmFtZSksIGZyYW1lLmNlaWwocmVzb2x1dGlvbiksIHRoaXMudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0uaW52ZXJ0KCksIGZyYW1lKTtcbiAgICB9XG4gIH1cbn1cbkZpbHRlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiZmlsdGVyXCJcbn07XG5leHRlbnNpb25zLmFkZChGaWx0ZXJTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgRmlsdGVyU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IE1TQUFfUVVBTElUWSB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmNsYXNzIEdMRnJhbWVidWZmZXIge1xuICBjb25zdHJ1Y3RvcihmcmFtZWJ1ZmZlcikge1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlciwgdGhpcy5zdGVuY2lsID0gbnVsbCwgdGhpcy5kaXJ0eUlkID0gLTEsIHRoaXMuZGlydHlGb3JtYXQgPSAtMSwgdGhpcy5kaXJ0eVNpemUgPSAtMSwgdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FLCB0aGlzLm1zYWFCdWZmZXIgPSBudWxsLCB0aGlzLmJsaXRGcmFtZWJ1ZmZlciA9IG51bGwsIHRoaXMubWlwTGV2ZWwgPSAwO1xuICB9XG59XG5leHBvcnQge1xuICBHTEZyYW1lYnVmZmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xGcmFtZWJ1ZmZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBFTlYsIEJVRkZFUl9CSVRTLCBNU0FBX1FVQUxJVFkgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gXCJAcGl4aS9tYXRoXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tIFwiLi9GcmFtZWJ1ZmZlci5tanNcIjtcbmltcG9ydCB7IEdMRnJhbWVidWZmZXIgfSBmcm9tIFwiLi9HTEZyYW1lYnVmZmVyLm1qc1wiO1xuY29uc3QgdGVtcFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcbmNsYXNzIEZyYW1lYnVmZmVyU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzID0gW10sIHRoaXMudW5rbm93bkZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyKDEwLCAxMCksIHRoaXMubXNhYVNhbXBsZXMgPSBudWxsO1xuICB9XG4gIC8qKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy4gKi9cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VBbGwoITApO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgaWYgKHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlELCB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlciwgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGUoKSwgdGhpcy5oYXNNUlQgPSAhMCwgdGhpcy53cml0ZURlcHRoVGV4dHVyZSA9ICEwLCB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBsZXQgbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycywgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZGVwdGhUZXh0dXJlO1xuICAgICAgc2V0dGluZ3MuUFJFRkVSX0VOViA9PT0gRU5WLldFQkdMX0xFR0FDWSAmJiAobmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24gPSBudWxsLCBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gPSBudWxsKSwgbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24gPyBnbC5kcmF3QnVmZmVycyA9IChhY3RpdmVUZXh0dXJlcykgPT4gbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24uZHJhd0J1ZmZlcnNXRUJHTChhY3RpdmVUZXh0dXJlcykgOiAodGhpcy5oYXNNUlQgPSAhMSwgZ2wuZHJhd0J1ZmZlcnMgPSAoKSA9PiB7XG4gICAgICB9KSwgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uIHx8ICh0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gITEpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5tc2FhU2FtcGxlcyA9IGdsLmdldEludGVybmFsZm9ybWF0UGFyYW1ldGVyKGdsLlJFTkRFUkJVRkZFUiwgZ2wuUkdCQTgsIGdsLlNBTVBMRVMpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kIGEgZnJhbWVidWZmZXIuXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0gZnJhbWUgLSBmcmFtZSwgZGVmYXVsdCBpcyBmcmFtZWJ1ZmZlciBzaXplXG4gICAqIEBwYXJhbSBtaXBMZXZlbCAtIG9wdGlvbmFsIG1pcCBsZXZlbCB0byBzZXQgb24gdGhlIGZyYW1lYnVmZmVyIC0gZGVmYXVsdHMgdG8gMFxuICAgKi9cbiAgYmluZChmcmFtZWJ1ZmZlciwgZnJhbWUsIG1pcExldmVsID0gMCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBjb25zdCBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICB0aGlzLmN1cnJlbnQgIT09IGZyYW1lYnVmZmVyICYmICh0aGlzLmN1cnJlbnQgPSBmcmFtZWJ1ZmZlciwgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8uZnJhbWVidWZmZXIpKSwgZmJvLm1pcExldmVsICE9PSBtaXBMZXZlbCAmJiAoZnJhbWVidWZmZXIuZGlydHlJZCsrLCBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCsrLCBmYm8ubWlwTGV2ZWwgPSBtaXBMZXZlbCksIGZiby5kaXJ0eUlkICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUlkICYmIChmYm8uZGlydHlJZCA9IGZyYW1lYnVmZmVyLmRpcnR5SWQsIGZiby5kaXJ0eUZvcm1hdCAhPT0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQgPyAoZmJvLmRpcnR5Rm9ybWF0ID0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQsIGZiby5kaXJ0eVNpemUgPSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUsIHRoaXMudXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIG1pcExldmVsKSkgOiBmYm8uZGlydHlTaXplICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUgJiYgKGZiby5kaXJ0eVNpemUgPSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUsIHRoaXMucmVzaXplRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4ID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1tpXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZCh0ZXgucGFyZW50VGV4dHVyZUFycmF5IHx8IHRleCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlICYmIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSwgZnJhbWUpIHtcbiAgICAgICAgY29uc3QgbWlwV2lkdGggPSBmcmFtZS53aWR0aCA+PiBtaXBMZXZlbCwgbWlwSGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ID4+IG1pcExldmVsLCBzY2FsZSA9IG1pcFdpZHRoIC8gZnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoXG4gICAgICAgICAgZnJhbWUueCAqIHNjYWxlLFxuICAgICAgICAgIGZyYW1lLnkgKiBzY2FsZSxcbiAgICAgICAgICBtaXBXaWR0aCxcbiAgICAgICAgICBtaXBIZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pcFdpZHRoID0gZnJhbWVidWZmZXIud2lkdGggPj4gbWlwTGV2ZWwsIG1pcEhlaWdodCA9IGZyYW1lYnVmZmVyLmhlaWdodCA+PiBtaXBMZXZlbDtcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCgwLCAwLCBtaXBXaWR0aCwgbWlwSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuY3VycmVudCAmJiAodGhpcy5jdXJyZW50ID0gbnVsbCwgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKSksIGZyYW1lID8gdGhpcy5zZXRWaWV3cG9ydChmcmFtZS54LCBmcmFtZS55LCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KSA6IHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgdGhpcy5yZW5kZXJlci53aWR0aCwgdGhpcy5yZW5kZXJlci5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCdzIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0geCAtIFggcG9zaXRpb24gb2Ygdmlld3BvcnRcbiAgICogQHBhcmFtIHkgLSBZIHBvc2l0aW9uIG9mIHZpZXdwb3J0XG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2Ygdmlld3BvcnRcbiAgICovXG4gIHNldFZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB2ID0gdGhpcy52aWV3cG9ydDtcbiAgICB4ID0gTWF0aC5yb3VuZCh4KSwgeSA9IE1hdGgucm91bmQoeSksIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCksIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KSwgKHYud2lkdGggIT09IHdpZHRoIHx8IHYuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdi54ICE9PSB4IHx8IHYueSAhPT0geSkgJiYgKHYueCA9IHgsIHYueSA9IHksIHYud2lkdGggPSB3aWR0aCwgdi5oZWlnaHQgPSBoZWlnaHQsIHRoaXMuZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBvYmplY3Qgd2l0aCBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB2YWx1ZXMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCA/IHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMuY3VycmVudC53aWR0aCwgaGVpZ2h0OiB0aGlzLmN1cnJlbnQuaGVpZ2h0IH0gOiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB0aGlzLnJlbmRlcmVyLndpZHRoLCBoZWlnaHQ6IHRoaXMucmVuZGVyZXIuaGVpZ2h0IH07XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBjb2xvciBvZiB0aGUgY29udGV4dFxuICAgKiBAcGFyYW0gciAtIFJlZCB2YWx1ZSBmcm9tIDAgdG8gMVxuICAgKiBAcGFyYW0gZyAtIEdyZWVuIHZhbHVlIGZyb20gMCB0byAxXG4gICAqIEBwYXJhbSBiIC0gQmx1ZSB2YWx1ZSBmcm9tIDAgdG8gMVxuICAgKiBAcGFyYW0gYSAtIEFscGhhIHZhbHVlIGZyb20gMCB0byAxXG4gICAqIEBwYXJhbSB7UElYSS5CVUZGRVJfQklUU30gW21hc2s9QlVGRkVSX0JJVFMuQ09MT1IgfCBCVUZGRVJfQklUUy5ERVBUSF0gLSBCaXR3aXNlIE9SIG9mIG1hc2tzXG4gICAqICB0aGF0IGluZGljYXRlIHRoZSBidWZmZXJzIHRvIGJlIGNsZWFyZWQsIGJ5IGRlZmF1bHQgQ09MT1IgYW5kIERFUFRIIGJ1ZmZlcnMuXG4gICAqL1xuICBjbGVhcihyLCBnLCBiLCBhLCBtYXNrID0gQlVGRkVSX0JJVFMuQ09MT1IgfCBCVUZGRVJfQklUUy5ERVBUSCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKSwgZ2wuY2xlYXIobWFzayk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgZnJhbWVidWZmZXIgZm9yIHRoaXMgY29udGV4dFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlclxuICAgKiBAcmV0dXJucyAtIGNyZWF0ZWQgR0xGcmFtZWJ1ZmZlclxuICAgKi9cbiAgaW5pdEZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgZmJvID0gbmV3IEdMRnJhbWVidWZmZXIoZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSk7XG4gICAgcmV0dXJuIGZiby5tdWx0aXNhbXBsZSA9IHRoaXMuZGV0ZWN0U2FtcGxlcyhmcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSksIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdID0gZmJvLCB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMucHVzaChmcmFtZWJ1ZmZlciksIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpLCBmYm87XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgZnJhbWVidWZmZXJcbiAgICogQHBhcmFtIGZyYW1lYnVmZmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlc2l6ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKGZiby5zdGVuY2lsKSB7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgICAgbGV0IHN0ZW5jaWxGb3JtYXQ7XG4gICAgICB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxID8gc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIX1NURU5DSUwgOiBmcmFtZWJ1ZmZlci5kZXB0aCAmJiBmcmFtZWJ1ZmZlci5zdGVuY2lsID8gc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIMjRfU1RFTkNJTDggOiBmcmFtZWJ1ZmZlci5kZXB0aCA/IHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSF9DT01QT05FTlQyNCA6IHN0ZW5jaWxGb3JtYXQgPSBnbC5TVEVOQ0lMX0lOREVYOCwgZmJvLm1zYWFCdWZmZXIgPyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoXG4gICAgICAgIGdsLlJFTkRFUkJVRkZFUixcbiAgICAgICAgZmJvLm11bHRpc2FtcGxlLFxuICAgICAgICBzdGVuY2lsRm9ybWF0LFxuICAgICAgICBmcmFtZWJ1ZmZlci53aWR0aCxcbiAgICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0XG4gICAgICApIDogZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWxGb3JtYXQsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcbiAgICBsZXQgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcbiAgICBnbC5kcmF3QnVmZmVycyB8fCAoY291bnQgPSBNYXRoLm1pbihjb3VudCwgMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbG9yVGV4dHVyZXNbaV0sIHBhcmVudFRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSB8fCB0ZXh0dXJlO1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQocGFyZW50VGV4dHVyZSwgMCksIGkgPT09IDAgJiYgZmJvLm1zYWFCdWZmZXIgJiYgKGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXNhYUJ1ZmZlciksIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShcbiAgICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgICBmYm8ubXVsdGlzYW1wbGUsXG4gICAgICAgIHBhcmVudFRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0uaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIGZyYW1lYnVmZmVyLndpZHRoLFxuICAgICAgICBmcmFtZWJ1ZmZlci5oZWlnaHRcbiAgICAgICkpO1xuICAgIH1cbiAgICBmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUgJiYgdGhpcy53cml0ZURlcHRoVGV4dHVyZSAmJiB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUsIDApO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZyYW1lYnVmZmVyXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0gbWlwTGV2ZWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIG1pcExldmVsKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0sIGNvbG9yVGV4dHVyZXMgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzO1xuICAgIGxldCBjb3VudCA9IGNvbG9yVGV4dHVyZXMubGVuZ3RoO1xuICAgIGdsLmRyYXdCdWZmZXJzIHx8IChjb3VudCA9IE1hdGgubWluKGNvdW50LCAxKSksIGZiby5tdWx0aXNhbXBsZSA+IDEgJiYgdGhpcy5jYW5NdWx0aXNhbXBsZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSA/IGZiby5tc2FhQnVmZmVyID0gZmJvLm1zYWFCdWZmZXIgfHwgZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCkgOiBmYm8ubXNhYUJ1ZmZlciAmJiAoZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5tc2FhQnVmZmVyKSwgZmJvLm1zYWFCdWZmZXIgPSBudWxsLCBmYm8uYmxpdEZyYW1lYnVmZmVyICYmIChmYm8uYmxpdEZyYW1lYnVmZmVyLmRpc3Bvc2UoKSwgZmJvLmJsaXRGcmFtZWJ1ZmZlciA9IG51bGwpKTtcbiAgICBjb25zdCBhY3RpdmVUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbG9yVGV4dHVyZXNbaV0sIHBhcmVudFRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSB8fCB0ZXh0dXJlO1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQocGFyZW50VGV4dHVyZSwgMCksIGkgPT09IDAgJiYgZmJvLm1zYWFCdWZmZXIgPyAoZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKSwgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKFxuICAgICAgICBnbC5SRU5ERVJCVUZGRVIsXG4gICAgICAgIGZiby5tdWx0aXNhbXBsZSxcbiAgICAgICAgcGFyZW50VGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgZnJhbWVidWZmZXIud2lkdGgsXG4gICAgICAgIGZyYW1lYnVmZmVyLmhlaWdodFxuICAgICAgKSwgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKSkgOiAoZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksXG4gICAgICAgIHRleHR1cmUudGFyZ2V0LFxuICAgICAgICBwYXJlbnRUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsXG4gICAgICAgIG1pcExldmVsXG4gICAgICApLCBhY3RpdmVUZXh0dXJlcy5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSkpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlVGV4dHVyZXMubGVuZ3RoID4gMSAmJiBnbC5kcmF3QnVmZmVycyhhY3RpdmVUZXh0dXJlcyksIGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSAmJiB0aGlzLndyaXRlRGVwdGhUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXB0aFRleHR1cmUgPSBmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmU7XG4gICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChkZXB0aFRleHR1cmUsIDApLCBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkRFUFRIX0FUVEFDSE1FTlQsXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIGRlcHRoVGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlLFxuICAgICAgICBtaXBMZXZlbFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKChmcmFtZWJ1ZmZlci5zdGVuY2lsIHx8IGZyYW1lYnVmZmVyLmRlcHRoKSAmJiAhKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSAmJiB0aGlzLndyaXRlRGVwdGhUZXh0dXJlKSkge1xuICAgICAgZmJvLnN0ZW5jaWwgPSBmYm8uc3RlbmNpbCB8fCBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgIGxldCBzdGVuY2lsQXR0YWNobWVudCwgc3RlbmNpbEZvcm1hdDtcbiAgICAgIHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDEgPyAoc3RlbmNpbEF0dGFjaG1lbnQgPSBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSF9TVEVOQ0lMKSA6IGZyYW1lYnVmZmVyLmRlcHRoICYmIGZyYW1lYnVmZmVyLnN0ZW5jaWwgPyAoc3RlbmNpbEF0dGFjaG1lbnQgPSBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSDI0X1NURU5DSUw4KSA6IGZyYW1lYnVmZmVyLmRlcHRoID8gKHN0ZW5jaWxBdHRhY2htZW50ID0gZ2wuREVQVEhfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDI0KSA6IChzdGVuY2lsQXR0YWNobWVudCA9IGdsLlNURU5DSUxfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLlNURU5DSUxfSU5ERVg4KSwgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKSwgZmJvLm1zYWFCdWZmZXIgPyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoXG4gICAgICAgIGdsLlJFTkRFUkJVRkZFUixcbiAgICAgICAgZmJvLm11bHRpc2FtcGxlLFxuICAgICAgICBzdGVuY2lsRm9ybWF0LFxuICAgICAgICBmcmFtZWJ1ZmZlci53aWR0aCxcbiAgICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0XG4gICAgICApIDogZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWxGb3JtYXQsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpLCBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgc3RlbmNpbEF0dGFjaG1lbnQsIGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgIH0gZWxzZVxuICAgICAgZmJvLnN0ZW5jaWwgJiYgKGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCksIGZiby5zdGVuY2lsID0gbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZnJhbWUgYnVmZmVyIGNhbiBiZSBtdWx0aXNhbXBsZWQuXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlclxuICAgKi9cbiAgY2FuTXVsdGlzYW1wbGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uICE9PSAxICYmIGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXMubGVuZ3RoIDw9IDEgJiYgIWZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogRGV0ZWN0cyBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIG5vdCBtb3JlIHRoYW4gYSBwYXJhbSBidXQgYXMgY2xvc2UgdG8gaXQgYXMgcG9zc2libGVcbiAgICogQHBhcmFtIHNhbXBsZXMgLSBudW1iZXIgb2Ygc2FtcGxlc1xuICAgKiBAcmV0dXJucyAtIHJlY29tbWVuZGVkIG51bWJlciBvZiBzYW1wbGVzXG4gICAqL1xuICBkZXRlY3RTYW1wbGVzKHNhbXBsZXMpIHtcbiAgICBjb25zdCB7IG1zYWFTYW1wbGVzIH0gPSB0aGlzO1xuICAgIGxldCByZXMgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbiAgICBpZiAoc2FtcGxlcyA8PSAxIHx8IG1zYWFTYW1wbGVzID09PSBudWxsKVxuICAgICAgcmV0dXJuIHJlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zYWFTYW1wbGVzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKG1zYWFTYW1wbGVzW2ldIDw9IHNhbXBsZXMpIHtcbiAgICAgICAgcmVzID0gbXNhYVNhbXBsZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHJldHVybiByZXMgPT09IDEgJiYgKHJlcyA9IE1TQUFfUVVBTElUWS5OT05FKSwgcmVzO1xuICB9XG4gIC8qKlxuICAgKiBPbmx5IHdvcmtzIHdpdGggV2ViR0wyXG4gICAqXG4gICAqIGJsaXRzIGZyYW1lYnVmZmVyIHRvIGFub3RoZXIgb2YgdGhlIHNhbWUgb3IgYmlnZ2VyIHNpemVcbiAgICogYWZ0ZXIgdGhhdCB0YXJnZXQgZnJhbWVidWZmZXIgaXMgYm91bmRcbiAgICpcbiAgICogRmFpbHMgd2l0aCBXZWJHTCB3YXJuaW5nIGlmIGJsaXRzIG11bHRpc2FtcGxlIGZyYW1lYnVmZmVyIHRvIGRpZmZlcmVudCBzaXplXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlciAtIGJ5IGRlZmF1bHQgaXQgYmxpdHMgXCJpbnRvIGl0c2VsZlwiLCBmcm9tIHJlbmRlckJ1ZmZlciB0byB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gc291cmNlUGl4ZWxzIC0gc291cmNlIHJlY3RhbmdsZSBpbiBwaXhlbHNcbiAgICogQHBhcmFtIGRlc3RQaXhlbHMgLSBkZXN0IHJlY3RhbmdsZSBpbiBwaXhlbHMsIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWUgYXMgc291cmNlUGl4ZWxzXG4gICAqL1xuICBibGl0KGZyYW1lYnVmZmVyLCBzb3VyY2VQaXhlbHMsIGRlc3RQaXhlbHMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnQsIHJlbmRlcmVyLCBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uICE9PSAyIHx8ICFjdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZibyA9IGN1cnJlbnQuZ2xGcmFtZWJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICAgIGlmICghZmJvKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghZnJhbWVidWZmZXIpIHtcbiAgICAgIGlmICghZmJvLm1zYWFCdWZmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGNvbG9yVGV4dHVyZSA9IGN1cnJlbnQuY29sb3JUZXh0dXJlc1swXTtcbiAgICAgIGlmICghY29sb3JUZXh0dXJlKVxuICAgICAgICByZXR1cm47XG4gICAgICBmYm8uYmxpdEZyYW1lYnVmZmVyIHx8IChmYm8uYmxpdEZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyKGN1cnJlbnQud2lkdGgsIGN1cnJlbnQuaGVpZ2h0KSwgZmJvLmJsaXRGcmFtZWJ1ZmZlci5hZGRDb2xvclRleHR1cmUoMCwgY29sb3JUZXh0dXJlKSksIGZyYW1lYnVmZmVyID0gZmJvLmJsaXRGcmFtZWJ1ZmZlciwgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1swXSAhPT0gY29sb3JUZXh0dXJlICYmIChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzWzBdID0gY29sb3JUZXh0dXJlLCBmcmFtZWJ1ZmZlci5kaXJ0eUlkKyssIGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0KyspLCAoZnJhbWVidWZmZXIud2lkdGggIT09IGN1cnJlbnQud2lkdGggfHwgZnJhbWVidWZmZXIuaGVpZ2h0ICE9PSBjdXJyZW50LmhlaWdodCkgJiYgKGZyYW1lYnVmZmVyLndpZHRoID0gY3VycmVudC53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0ID0gY3VycmVudC5oZWlnaHQsIGZyYW1lYnVmZmVyLmRpcnR5SWQrKywgZnJhbWVidWZmZXIuZGlydHlTaXplKyspO1xuICAgIH1cbiAgICBzb3VyY2VQaXhlbHMgfHwgKHNvdXJjZVBpeGVscyA9IHRlbXBSZWN0YW5nbGUsIHNvdXJjZVBpeGVscy53aWR0aCA9IGN1cnJlbnQud2lkdGgsIHNvdXJjZVBpeGVscy5oZWlnaHQgPSBjdXJyZW50LmhlaWdodCksIGRlc3RQaXhlbHMgfHwgKGRlc3RQaXhlbHMgPSBzb3VyY2VQaXhlbHMpO1xuICAgIGNvbnN0IHNhbWVTaXplID0gc291cmNlUGl4ZWxzLndpZHRoID09PSBkZXN0UGl4ZWxzLndpZHRoICYmIHNvdXJjZVBpeGVscy5oZWlnaHQgPT09IGRlc3RQaXhlbHMuaGVpZ2h0O1xuICAgIHRoaXMuYmluZChmcmFtZWJ1ZmZlciksIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCBmYm8uZnJhbWVidWZmZXIpLCBnbC5ibGl0RnJhbWVidWZmZXIoXG4gICAgICBzb3VyY2VQaXhlbHMubGVmdCxcbiAgICAgIHNvdXJjZVBpeGVscy50b3AsXG4gICAgICBzb3VyY2VQaXhlbHMucmlnaHQsXG4gICAgICBzb3VyY2VQaXhlbHMuYm90dG9tLFxuICAgICAgZGVzdFBpeGVscy5sZWZ0LFxuICAgICAgZGVzdFBpeGVscy50b3AsXG4gICAgICBkZXN0UGl4ZWxzLnJpZ2h0LFxuICAgICAgZGVzdFBpeGVscy5ib3R0b20sXG4gICAgICBnbC5DT0xPUl9CVUZGRVJfQklULFxuICAgICAgc2FtZVNpemUgPyBnbC5ORUFSRVNUIDogZ2wuTElORUFSXG4gICAgKSwgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdLmZyYW1lYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgZnJhbWVidWZmZXIuXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlciAtIGZyYW1lYnVmZmVyIHRoYXQgaGFzIHRvIGJlIGRpc3Bvc2VkIG9mXG4gICAqIEBwYXJhbSBjb250ZXh0TG9zdCAtIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGFsbCBkZWxldGUgZnVuY3Rpb24gY2FsbHNcbiAgICovXG4gIGRpc3Bvc2VGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlciwgY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSwgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghZmJvKVxuICAgICAgcmV0dXJuO1xuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5pbmRleE9mKGZyYW1lYnVmZmVyKTtcbiAgICBpbmRleCA+PSAwICYmIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5zcGxpY2UoaW5kZXgsIDEpLCBmcmFtZWJ1ZmZlci5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKSwgY29udGV4dExvc3QgfHwgKGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZiby5mcmFtZWJ1ZmZlciksIGZiby5tc2FhQnVmZmVyICYmIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8ubXNhYUJ1ZmZlciksIGZiby5zdGVuY2lsICYmIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCkpLCBmYm8uYmxpdEZyYW1lYnVmZmVyICYmIHRoaXMuZGlzcG9zZUZyYW1lYnVmZmVyKGZiby5ibGl0RnJhbWVidWZmZXIsIGNvbnRleHRMb3N0KTtcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgYWxsIGZyYW1lYnVmZmVycywgYnV0IG5vdCB0ZXh0dXJlcyBib3VuZCB0byB0aGVtLlxuICAgKiBAcGFyYW0gW2NvbnRleHRMb3N0PWZhbHNlXSAtIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGFsbCBkZWxldGUgZnVuY3Rpb24gY2FsbHNcbiAgICovXG4gIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzO1xuICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuZGlzcG9zZUZyYW1lYnVmZmVyKGxpc3RbaV0sIGNvbnRleHRMb3N0KTtcbiAgfVxuICAvKipcbiAgICogRm9yY2luZyBjcmVhdGlvbiBvZiBzdGVuY2lsIGJ1ZmZlciBmb3IgY3VycmVudCBmcmFtZWJ1ZmZlciwgaWYgaXQgd2Fzbid0IGRvbmUgYmVmb3JlLlxuICAgKiBVc2VkIGJ5IE1hc2tTeXN0ZW0sIHdoZW4gaXRzIHRpbWUgdG8gdXNlIHN0ZW5jaWwgbWFzayBmb3IgR3JhcGhpY3MgZWxlbWVudC5cbiAgICpcbiAgICogSXRzIGFuIGFsdGVybmF0aXZlIGZvciBwdWJsaWMgbGF6eSBgZnJhbWVidWZmZXIuZW5hYmxlU3RlbmNpbGAsIGluIGNhc2Ugd2UgbmVlZCBzdGVuY2lsIHdpdGhvdXQgcmViaW5kLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9yY2VTdGVuY2lsKCkge1xuICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZnJhbWVidWZmZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKCFmYm8gfHwgZmJvLnN0ZW5jaWwgJiYgZnJhbWVidWZmZXIuc3RlbmNpbClcbiAgICAgIHJldHVybjtcbiAgICBmcmFtZWJ1ZmZlci5zdGVuY2lsID0gITA7XG4gICAgY29uc3QgdyA9IGZyYW1lYnVmZmVyLndpZHRoLCBoID0gZnJhbWVidWZmZXIuaGVpZ2h0LCBnbCA9IHRoaXMuZ2wsIHN0ZW5jaWwgPSBmYm8uc3RlbmNpbCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBzdGVuY2lsKTtcbiAgICBsZXQgc3RlbmNpbEF0dGFjaG1lbnQsIHN0ZW5jaWxGb3JtYXQ7XG4gICAgdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSA/IChzdGVuY2lsQXR0YWNobWVudCA9IGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIX1NURU5DSUwpIDogZnJhbWVidWZmZXIuZGVwdGggPyAoc3RlbmNpbEF0dGFjaG1lbnQgPSBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSDI0X1NURU5DSUw4KSA6IChzdGVuY2lsQXR0YWNobWVudCA9IGdsLlNURU5DSUxfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLlNURU5DSUxfSU5ERVg4KSwgZmJvLm1zYWFCdWZmZXIgPyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXVsdGlzYW1wbGUsIHN0ZW5jaWxGb3JtYXQsIHcsIGgpIDogZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWxGb3JtYXQsIHcsIGgpLCBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgc3RlbmNpbEF0dGFjaG1lbnQsIGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XG4gIH1cbiAgLyoqIFJlc2V0cyBmcmFtZWJ1ZmZlciBzdG9yZWQgc3RhdGUsIGJpbmRzIHNjcmVlbiBmcmFtZWJ1ZmZlci4gU2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgcmVuZGVyVGV4dHVyZSByZXNldCgpLiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlciwgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5GcmFtZWJ1ZmZlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiZnJhbWVidWZmZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEZyYW1lYnVmZmVyU3lzdGVtKTtcbmV4cG9ydCB7XG4gIEZyYW1lYnVmZmVyU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVidWZmZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WLCBCVUZGRVJfVFlQRSB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmNvbnN0IGJ5dGVTaXplTWFwID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XG5jbGFzcyBHZW9tZXRyeVN5c3RlbSB7XG4gIC8qKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLiAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsLCB0aGlzLl9hY3RpdmVWYW8gPSBudWxsLCB0aGlzLmhhc1ZhbyA9ICEwLCB0aGlzLmhhc0luc3RhbmNlID0gITAsIHRoaXMuY2FuVXNlVUludDMyRWxlbWVudEluZGV4ID0gITEsIHRoaXMubWFuYWdlZEdlb21ldHJpZXMgPSB7fTtcbiAgfVxuICAvKiogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuICovXG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlQWxsKCEwKTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsLCBjb250ZXh0ID0gdGhpcy5yZW5kZXJlci5jb250ZXh0O1xuICAgIGlmICh0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCwgY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgIGxldCBuYXRpdmVWYW9FeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy52ZXJ0ZXhBcnJheU9iamVjdDtcbiAgICAgIHNldHRpbmdzLlBSRUZFUl9FTlYgPT09IEVOVi5XRUJHTF9MRUdBQ1kgJiYgKG5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGwpLCBuYXRpdmVWYW9FeHRlbnNpb24gPyAoZ2wuY3JlYXRlVmVydGV4QXJyYXkgPSAoKSA9PiBuYXRpdmVWYW9FeHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKSwgZ2wuYmluZFZlcnRleEFycmF5ID0gKHZhbykgPT4gbmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8pLCBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9ICh2YW8pID0+IG5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pKSA6ICh0aGlzLmhhc1ZhbyA9ICExLCBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGwsIGdsLmJpbmRWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGwsIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgY29uc3QgaW5zdGFuY2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgaW5zdGFuY2VFeHQgPyAoZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IChhLCBiKSA9PiBpbnN0YW5jZUV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYSwgYiksIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCA9IChhLCBiLCBjLCBkLCBlKSA9PiBpbnN0YW5jZUV4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkLCBlKSwgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCA9IChhLCBiLCBjLCBkKSA9PiBpbnN0YW5jZUV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCkpIDogdGhpcy5oYXNJbnN0YW5jZSA9ICExO1xuICAgIH1cbiAgICB0aGlzLmNhblVzZVVJbnQzMkVsZW1lbnRJbmRleCA9IGNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyIHx8ICEhY29udGV4dC5leHRlbnNpb25zLnVpbnQzMkVsZW1lbnRJbmRleDtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZ2VvbWV0cnkgc28gdGhhdCBpcyBjYW4gYmUgZHJhd24uIENyZWF0aW5nIGEgVmFvIGlmIHJlcXVpcmVkXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIEluc3RhbmNlIG9mIGdlb21ldHJ5IHRvIGJpbmQuXG4gICAqIEBwYXJhbSBzaGFkZXIgLSBJbnN0YW5jZSBvZiBzaGFkZXIgdG8gdXNlIHZhbyBmb3IuXG4gICAqL1xuICBiaW5kKGdlb21ldHJ5LCBzaGFkZXIpIHtcbiAgICBzaGFkZXIgPSBzaGFkZXIgfHwgdGhpcy5yZW5kZXJlci5zaGFkZXIuc2hhZGVyO1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgbGV0IHZhb3MgPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXSwgaW5jUmVmQ291bnQgPSAhMTtcbiAgICB2YW9zIHx8ICh0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSA9IGdlb21ldHJ5LCBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKSwgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF0gPSB2YW9zID0ge30sIGluY1JlZkNvdW50ID0gITApO1xuICAgIGNvbnN0IHZhbyA9IHZhb3Nbc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBzaGFkZXIsIGluY1JlZkNvdW50KTtcbiAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IGdlb21ldHJ5LCB0aGlzLl9hY3RpdmVWYW8gIT09IHZhbyAmJiAodGhpcy5fYWN0aXZlVmFvID0gdmFvLCB0aGlzLmhhc1ZhbyA/IGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pIDogdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pKSwgdGhpcy51cGRhdGVCdWZmZXJzKCk7XG4gIH1cbiAgLyoqIFJlc2V0IGFuZCB1bmJpbmQgYW55IGFjdGl2ZSBWQU8gYW5kIGdlb21ldHJ5LiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIC8qKiBVcGRhdGUgYnVmZmVycyBvZiB0aGUgY3VycmVudGx5IGJvdW5kIGdlb21ldHJ5LiAqL1xuICB1cGRhdGVCdWZmZXJzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnksIGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlclN5c3RlbS51cGRhdGUoYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBhIGdlb21ldHJ5IGFuZCBhIHByb2dyYW1cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gUHJvZ3JhbSBpbnN0YW5jZS5cbiAgICovXG4gIGNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMsIHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgZm9yIChjb25zdCBqIGluIHNoYWRlckF0dHJpYnV0ZXMpXG4gICAgICBpZiAoIWdlb21ldHJ5QXR0cmlidXRlc1tqXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaGFkZXIgYW5kIGdlb21ldHJ5IGluY29tcGF0aWJsZSwgZ2VvbWV0cnkgbWlzc2luZyB0aGUgXCIke2p9XCIgYXR0cmlidXRlYCk7XG4gIH1cbiAgLyoqXG4gICAqIFRha2VzIGEgZ2VvbWV0cnkgYW5kIHByb2dyYW0gYW5kIGdlbmVyYXRlcyBhIHVuaXF1ZSBzaWduYXR1cmUgZm9yIHRoZW0uXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIFRvIGdldCBzaWduYXR1cmUgZnJvbS5cbiAgICogQHBhcmFtIHByb2dyYW0gLSBUbyB0ZXN0IGdlb21ldHJ5IGFnYWluc3QuXG4gICAqIEByZXR1cm5zIC0gVW5pcXVlIHNpZ25hdHVyZSBvZiB0aGUgZ2VvbWV0cnkgYW5kIHByb2dyYW1cbiAgICovXG4gIGdldFNpZ25hdHVyZShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGF0dHJpYnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLCBzaGFkZXJBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhLCBzdHJpbmdzID0gW1wiZ1wiLCBnZW9tZXRyeS5pZF07XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnMpXG4gICAgICBzaGFkZXJBdHRyaWJ1dGVzW2ldICYmIHN0cmluZ3MucHVzaChpLCBzaGFkZXJBdHRyaWJ1dGVzW2ldLmxvY2F0aW9uKTtcbiAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiLVwiKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvciBnZXRzIFZhbyB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBhcyB0aGUgZ2VvbWV0cnkgYW5kIHN0b3JlcyBpdCBvbiB0aGUgZ2VvbWV0cnkuXG4gICAqIElmIHZhbyBpcyBjcmVhdGVkLCBpdCBpcyBib3VuZCBhdXRvbWF0aWNhbGx5LiBXZSB1c2UgYSBzaGFkZXIgdG8gaW5mZXIgd2hhdCBhbmQgaG93IHRvIHNldCB1cCB0aGVcbiAgICogYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gSW5zdGFuY2Ugb2YgZ2VvbWV0cnkgdG8gdG8gZ2VuZXJhdGUgVmFvIGZvci5cbiAgICogQHBhcmFtIHNoYWRlciAtIEluc3RhbmNlIG9mIHRoZSBzaGFkZXIuXG4gICAqIEBwYXJhbSBpbmNSZWZDb3VudCAtIEluY3JlbWVudCByZWZDb3VudCBvZiBhbGwgZ2VvbWV0cnkgYnVmZmVycy5cbiAgICovXG4gIGluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLCBpbmNSZWZDb3VudCA9ICEwKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsLCBDT05URVhUX1VJRCA9IHRoaXMuQ09OVEVYVF9VSUQsIGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyLCBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XG4gICAgcHJvZ3JhbS5nbFByb2dyYW1zW0NPTlRFWFRfVUlEXSB8fCB0aGlzLnJlbmRlcmVyLnNoYWRlci5nZW5lcmF0ZVByb2dyYW0oc2hhZGVyKSwgdGhpcy5jaGVja0NvbXBhdGliaWxpdHkoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSwgdmFvT2JqZWN0SGFzaCA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGxldCB2YW8gPSB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV07XG4gICAgaWYgKHZhbylcbiAgICAgIHJldHVybiB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvLCB2YW87XG4gICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnMsIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLCB0ZW1wU3RyaWRlID0ge30sIHRlbXBTdGFydCA9IHt9O1xuICAgIGZvciAoY29uc3QgaiBpbiBidWZmZXJzKVxuICAgICAgdGVtcFN0cmlkZVtqXSA9IDAsIHRlbXBTdGFydFtqXSA9IDA7XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpXG4gICAgICAhYXR0cmlidXRlc1tqXS5zaXplICYmIHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSA/IGF0dHJpYnV0ZXNbal0uc2l6ZSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXS5zaXplIDogYXR0cmlidXRlc1tqXS5zaXplIHx8IGNvbnNvbGUud2FybihgUElYSSBHZW9tZXRyeSBhdHRyaWJ1dGUgJyR7an0nIHNpemUgY2Fubm90IGJlIGRldGVybWluZWQgKGxpa2VseSB0aGUgYm91bmQgc2hhZGVyIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZSlgKSwgdGVtcFN0cmlkZVthdHRyaWJ1dGVzW2pdLmJ1ZmZlcl0gKz0gYXR0cmlidXRlc1tqXS5zaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlc1tqXS50eXBlXTtcbiAgICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXSwgYXR0cmliU2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgYXR0cmlidXRlLnN0cmlkZSA9PT0gdm9pZCAwICYmICh0ZW1wU3RyaWRlW2F0dHJpYnV0ZS5idWZmZXJdID09PSBhdHRyaWJTaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdID8gYXR0cmlidXRlLnN0cmlkZSA9IDAgOiBhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXSksIGF0dHJpYnV0ZS5zdGFydCA9PT0gdm9pZCAwICYmIChhdHRyaWJ1dGUuc3RhcnQgPSB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl0sIHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyXSArPSBhdHRyaWJTaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKTtcbiAgICB9XG4gICAgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKSwgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoYnVmZmVyKSwgaW5jUmVmQ291bnQgJiYgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLnJlZkNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlVmFvKGdlb21ldHJ5LCBwcm9ncmFtKSwgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbywgdmFvT2JqZWN0SGFzaFtzaWduYXR1cmVdID0gdmFvLCBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCksIGJ1ZmZlclN5c3RlbS51bmJpbmQoQlVGRkVSX1RZUEUuQVJSQVlfQlVGRkVSKSwgdmFvO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gR2VvbWV0cnkgd2l0aCBidWZmZXJzLiBPbmx5IFZBTyB3aWxsIGJlIGRpc3Bvc2VkXG4gICAqIEBwYXJhbSBbY29udGV4dExvc3Q9ZmFsc2VdIC0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgZGVsZXRlVmVydGV4QXJyYXlcbiAgICovXG4gIGRpc3Bvc2VHZW9tZXRyeShnZW9tZXRyeSwgY29udGV4dExvc3QpIHtcbiAgICBpZiAoIXRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdKVxuICAgICAgcmV0dXJuO1xuICAgIGRlbGV0ZSB0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXTtcbiAgICBjb25zdCB2YW9zID0gZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF0sIGdsID0gdGhpcy5nbCwgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnMsIGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXI/LmJ1ZmZlcjtcbiAgICBpZiAoZ2VvbWV0cnkuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyksICEhdmFvcykge1xuICAgICAgaWYgKGJ1ZmZlclN5c3RlbSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyc1tpXS5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICAgIGJ1ZiAmJiAoYnVmLnJlZkNvdW50LS0sIGJ1Zi5yZWZDb3VudCA9PT0gMCAmJiAhY29udGV4dExvc3QgJiYgYnVmZmVyU3lzdGVtLmRpc3Bvc2UoYnVmZmVyc1tpXSwgY29udGV4dExvc3QpKTtcbiAgICAgICAgfVxuICAgICAgaWYgKCFjb250ZXh0TG9zdCkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhb0lkIGluIHZhb3MpXG4gICAgICAgICAgaWYgKHZhb0lkWzBdID09PSBcImdcIikge1xuICAgICAgICAgICAgY29uc3QgdmFvID0gdmFvc1t2YW9JZF07XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPT09IHZhbyAmJiB0aGlzLnVuYmluZCgpLCBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2UgYWxsIFdlYkdMIHJlc291cmNlcyBvZiBhbGwgbWFuYWdlZCBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0gW2NvbnRleHRMb3N0PWZhbHNlXSAtIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGBnbC5kZWxldGVgIGNhbGxzXG4gICAqL1xuICBkaXNwb3NlQWxsKGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgYWxsID0gT2JqZWN0LmtleXModGhpcy5tYW5hZ2VkR2VvbWV0cmllcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmRpc3Bvc2VHZW9tZXRyeSh0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2FsbFtpXV0sIGNvbnRleHRMb3N0KTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGUgdmVydGV4IGFycmF5IG9iamVjdC5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gU2hhZGVyIHByb2dyYW0gaW5zdGFuY2UuXG4gICAqL1xuICBhY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCwgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlELCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLmJ1ZmZlciwgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnMsIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyICYmIGJ1ZmZlclN5c3RlbS5iaW5kKGdlb21ldHJ5LmluZGV4QnVmZmVyKTtcbiAgICBsZXQgbGFzdEJ1ZmZlciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal0sIGJ1ZmZlciA9IGJ1ZmZlcnNbYXR0cmlidXRlLmJ1ZmZlcl0sIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICAgICAgaWYgKHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSkge1xuICAgICAgICBsYXN0QnVmZmVyICE9PSBnbEJ1ZmZlciAmJiAoYnVmZmVyU3lzdGVtLmJpbmQoYnVmZmVyKSwgbGFzdEJ1ZmZlciA9IGdsQnVmZmVyKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0ubG9jYXRpb247XG4gICAgICAgIGlmIChnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbiksIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgYXR0cmlidXRlLnNpemUsXG4gICAgICAgICAgYXR0cmlidXRlLnR5cGUgfHwgZ2wuRkxPQVQsXG4gICAgICAgICAgYXR0cmlidXRlLm5vcm1hbGl6ZWQsXG4gICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSxcbiAgICAgICAgICBhdHRyaWJ1dGUuc3RhcnRcbiAgICAgICAgKSwgYXR0cmlidXRlLmluc3RhbmNlKVxuICAgICAgICAgIGlmICh0aGlzLmhhc0luc3RhbmNlKVxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgYXR0cmlidXRlLmRpdmlzb3IpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdlb21ldHJ5IGVycm9yLCBHUFUgSW5zdGFuY2luZyBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRHJhd3MgdGhlIGN1cnJlbnRseSBib3VuZCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBwcmltaXRpdmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWQuIElmIG5vdCBzcGVjaWZpZWQsIGFsbCB2ZXJ0aWNlcyBhZnRlciB0aGVcbiAgICogIHN0YXJ0aW5nIHZlcnRleCB3aWxsIGJlIGRyYXduLlxuICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnRpbmcgdmVydGV4IGluIHRoZSBnZW9tZXRyeSB0byBzdGFydCBkcmF3aW5nIGZyb20uIElmIG5vdCBzcGVjaWZpZWQsXG4gICAqICBkcmF3aW5nIHdpbGwgc3RhcnQgZnJvbSB0aGUgZmlyc3QgdmVydGV4LlxuICAgKiBAcGFyYW0gaW5zdGFuY2VDb3VudCAtIFRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzZXQgb2YgZWxlbWVudHMgdG8gZXhlY3V0ZS4gSWYgbm90IHNwZWNpZmllZCxcbiAgICogIGFsbCBpbnN0YW5jZXMgd2lsbCBiZSBkcmF3bi5cbiAgICovXG4gIGRyYXcodHlwZSwgc2l6ZSwgc3RhcnQsIGluc3RhbmNlQ291bnQpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLCBnZW9tZXRyeSA9IHRoaXMuX2FjdGl2ZUdlb21ldHJ5O1xuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgY29uc3QgYnl0ZVNpemUgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLkJZVEVTX1BFUl9FTEVNRU5ULCBnbFR5cGUgPSBieXRlU2l6ZSA9PT0gMiA/IGdsLlVOU0lHTkVEX1NIT1JUIDogZ2wuVU5TSUdORURfSU5UO1xuICAgICAgYnl0ZVNpemUgPT09IDIgfHwgYnl0ZVNpemUgPT09IDQgJiYgdGhpcy5jYW5Vc2VVSW50MzJFbGVtZW50SW5kZXggPyBnZW9tZXRyeS5pbnN0YW5jZWQgPyBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQodHlwZSwgc2l6ZSB8fCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCwgZ2xUeXBlLCAoc3RhcnQgfHwgMCkgKiBieXRlU2l6ZSwgaW5zdGFuY2VDb3VudCB8fCAxKSA6IGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplKSA6IGNvbnNvbGUud2FybihcInVuc3VwcG9ydGVkIGluZGV4IGJ1ZmZlciB0eXBlOiB1aW50MzJcIik7XG4gICAgfSBlbHNlXG4gICAgICBnZW9tZXRyeS5pbnN0YW5jZWQgPyBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKHR5cGUsIHN0YXJ0LCBzaXplIHx8IGdlb21ldHJ5LmdldFNpemUoKSwgaW5zdGFuY2VDb3VudCB8fCAxKSA6IGdsLmRyYXdBcnJheXModHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogVW5iaW5kL3Jlc2V0IGV2ZXJ5dGhpbmcuICovXG4gIHVuYmluZCgpIHtcbiAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKSwgdGhpcy5fYWN0aXZlVmFvID0gbnVsbCwgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkdlb21ldHJ5U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJnZW9tZXRyeVwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoR2VvbWV0cnlTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgR2VvbWV0cnlTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW9tZXRyeVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiQHBpeGkvbWF0aFwiO1xuY29uc3QgdGVtcE1hdCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIFRleHR1cmVNYXRyaXgge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmUgLSBvYnNlcnZlZCB0ZXh0dXJlXG4gICAqIEBwYXJhbSBjbGFtcE1hcmdpbiAtIENoYW5nZXMgZnJhbWUgY2xhbXBpbmcsIDAuNSBieSBkZWZhdWx0LiBVc2UgLTAuNSBmb3IgZXh0cmEgYm9yZGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgY2xhbXBNYXJnaW4pIHtcbiAgICB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZSwgdGhpcy5tYXBDb29yZCA9IG5ldyBNYXRyaXgoKSwgdGhpcy51Q2xhbXBGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCksIHRoaXMudUNsYW1wT2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgdGhpcy5fdGV4dHVyZUlEID0gLTEsIHRoaXMuX3VwZGF0ZUlEID0gMCwgdGhpcy5jbGFtcE9mZnNldCA9IDAsIHRoaXMuY2xhbXBNYXJnaW4gPSB0eXBlb2YgY2xhbXBNYXJnaW4gPiBcInVcIiA/IDAuNSA6IGNsYW1wTWFyZ2luLCB0aGlzLmlzU2ltcGxlID0gITE7XG4gIH1cbiAgLyoqIFRleHR1cmUgcHJvcGVydHkuICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlLCB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgfVxuICAvKipcbiAgICogTXVsdGlwbGllcyB1dnMgYXJyYXkgdG8gdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB1dnMgLSBtZXNoIHV2c1xuICAgKiBAcGFyYW0gW291dD11dnNdIC0gb3V0cHV0XG4gICAqIEByZXR1cm5zIC0gb3V0cHV0XG4gICAqL1xuICBtdWx0aXBseVV2cyh1dnMsIG91dCkge1xuICAgIG91dCA9PT0gdm9pZCAwICYmIChvdXQgPSB1dnMpO1xuICAgIGNvbnN0IG1hdCA9IHRoaXMubWFwQ29vcmQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB1dnNbaV0sIHkgPSB1dnNbaSArIDFdO1xuICAgICAgb3V0W2ldID0geCAqIG1hdC5hICsgeSAqIG1hdC5jICsgbWF0LnR4LCBvdXRbaSArIDFdID0geCAqIG1hdC5iICsgeSAqIG1hdC5kICsgbWF0LnR5O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIG1hdHJpY2VzIGlmIHRleHR1cmUgd2FzIGNoYW5nZWQuXG4gICAqIEBwYXJhbSBbZm9yY2VVcGRhdGU9ZmFsc2VdIC0gaWYgdHJ1ZSwgbWF0cmljZXMgd2lsbCBiZSB1cGRhdGVkIGFueSBjYXNlXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciBvciBub3QgaXQgd2FzIHVwZGF0ZWRcbiAgICovXG4gIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xuICAgIGNvbnN0IHRleCA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKCF0ZXggfHwgIXRleC52YWxpZCB8fCAhZm9yY2VVcGRhdGUgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0ZXguX3VwZGF0ZUlEKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRleC5fdXBkYXRlSUQsIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgY29uc3QgdXZzID0gdGV4Ll91dnM7XG4gICAgdGhpcy5tYXBDb29yZC5zZXQodXZzLngxIC0gdXZzLngwLCB1dnMueTEgLSB1dnMueTAsIHV2cy54MyAtIHV2cy54MCwgdXZzLnkzIC0gdXZzLnkwLCB1dnMueDAsIHV2cy55MCk7XG4gICAgY29uc3Qgb3JpZyA9IHRleC5vcmlnLCB0cmltID0gdGV4LnRyaW07XG4gICAgdHJpbSAmJiAodGVtcE1hdC5zZXQoXG4gICAgICBvcmlnLndpZHRoIC8gdHJpbS53aWR0aCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgb3JpZy5oZWlnaHQgLyB0cmltLmhlaWdodCxcbiAgICAgIC10cmltLnggLyB0cmltLndpZHRoLFxuICAgICAgLXRyaW0ueSAvIHRyaW0uaGVpZ2h0XG4gICAgKSwgdGhpcy5tYXBDb29yZC5hcHBlbmQodGVtcE1hdCkpO1xuICAgIGNvbnN0IHRleEJhc2UgPSB0ZXguYmFzZVRleHR1cmUsIGZyYW1lID0gdGhpcy51Q2xhbXBGcmFtZSwgbWFyZ2luID0gdGhpcy5jbGFtcE1hcmdpbiAvIHRleEJhc2UucmVzb2x1dGlvbiwgb2Zmc2V0ID0gdGhpcy5jbGFtcE9mZnNldDtcbiAgICByZXR1cm4gZnJhbWVbMF0gPSAodGV4Ll9mcmFtZS54ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGgsIGZyYW1lWzFdID0gKHRleC5fZnJhbWUueSArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodCwgZnJhbWVbMl0gPSAodGV4Ll9mcmFtZS54ICsgdGV4Ll9mcmFtZS53aWR0aCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoLCBmcmFtZVszXSA9ICh0ZXguX2ZyYW1lLnkgKyB0ZXguX2ZyYW1lLmhlaWdodCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodCwgdGhpcy51Q2xhbXBPZmZzZXRbMF0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxXaWR0aCwgdGhpcy51Q2xhbXBPZmZzZXRbMV0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxIZWlnaHQsIHRoaXMuaXNTaW1wbGUgPSB0ZXguX2ZyYW1lLndpZHRoID09PSB0ZXhCYXNlLndpZHRoICYmIHRleC5fZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodCAmJiB0ZXgucm90YXRlID09PSAwLCAhMDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVGV4dHVyZU1hdHJpeFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVNYXRyaXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2TWFza0Nvb3JkO1xudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XG51bmlmb3JtIGZsb2F0IG5wbUFscGhhO1xudW5pZm9ybSB2ZWM0IG1hc2tDbGFtcDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC54LCB2TWFza0Nvb3JkLngpICtcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueSwgdk1hc2tDb29yZC55KSArXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC54LCBtYXNrQ2xhbXAueikgK1xuICAgICAgICBzdGVwKHZNYXNrQ29vcmQueSwgbWFza0NsYW1wLncpKTtcblxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlMkQobWFzaywgdk1hc2tDb29yZCk7XG4gICAgZmxvYXQgYWxwaGFNdWwgPSAxLjAgLSBucG1BbHBoYSAqICgxLjAgLSBtYXNreS5hKTtcblxuICAgIG9yaWdpbmFsICo9IChhbHBoYU11bCAqIG1hc2t5LnIgKiBhbHBoYSAqIGNsaXApO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gb3JpZ2luYWw7XG59XG5gO1xuZXhwb3J0IHtcbiAgZnJhZ21lbnQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZU1hc2tGaWx0ZXIuZnJhZy5tanMubWFwXG4iLCJ2YXIgdmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIG90aGVyTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcblxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcbn1cbmA7XG5leHBvcnQge1xuICB2ZXJ0ZXggYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZU1hc2tGaWx0ZXIudmVydC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiQHBpeGkvbWF0aFwiO1xuaW1wb3J0IHsgVGV4dHVyZU1hdHJpeCB9IGZyb20gXCIuLi8uLi90ZXh0dXJlcy9UZXh0dXJlTWF0cml4Lm1qc1wiO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSBcIi4uL0ZpbHRlci5tanNcIjtcbmltcG9ydCBmcmFnbWVudCBmcm9tIFwiLi9zcHJpdGVNYXNrRmlsdGVyLmZyYWcubWpzXCI7XG5pbXBvcnQgdmVydGV4IGZyb20gXCIuL3Nwcml0ZU1hc2tGaWx0ZXIudmVydC5tanNcIjtcbmNsYXNzIFNwcml0ZU1hc2tGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3Jtcykge1xuICAgIGxldCBzcHJpdGUgPSBudWxsO1xuICAgIHR5cGVvZiB2ZXJ0ZXhTcmMgIT0gXCJzdHJpbmdcIiAmJiBmcmFnbWVudFNyYyA9PT0gdm9pZCAwICYmIHVuaWZvcm1zID09PSB2b2lkIDAgJiYgKHNwcml0ZSA9IHZlcnRleFNyYywgdmVydGV4U3JjID0gdm9pZCAwLCBmcmFnbWVudFNyYyA9IHZvaWQgMCwgdW5pZm9ybXMgPSB2b2lkIDApLCBzdXBlcih2ZXJ0ZXhTcmMgfHwgdmVydGV4LCBmcmFnbWVudFNyYyB8fCBmcmFnbWVudCwgdW5pZm9ybXMpLCB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGUsIHRoaXMubWFza01hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgfVxuICAvKipcbiAgICogU3ByaXRlIG1hc2tcbiAgICogQHR5cGUge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICovXG4gIGdldCBtYXNrU3ByaXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXNrU3ByaXRlO1xuICB9XG4gIHNldCBtYXNrU3ByaXRlKHZhbHVlKSB7XG4gICAgdGhpcy5fbWFza1Nwcml0ZSA9IHZhbHVlLCB0aGlzLl9tYXNrU3ByaXRlICYmICh0aGlzLl9tYXNrU3ByaXRlLnJlbmRlcmFibGUgPSAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gZmlsdGVyTWFuYWdlciAtIFRoZSByZW5kZXJlciB0byByZXRyaWV2ZSB0aGUgZmlsdGVyIGZyb21cbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICogQHBhcmFtIGNsZWFyTW9kZSAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdC5cbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGNvbnN0IG1hc2tTcHJpdGUgPSB0aGlzLl9tYXNrU3ByaXRlLCB0ZXggPSBtYXNrU3ByaXRlLl90ZXh0dXJlO1xuICAgIHRleC52YWxpZCAmJiAodGV4LnV2TWF0cml4IHx8ICh0ZXgudXZNYXRyaXggPSBuZXcgVGV4dHVyZU1hdHJpeCh0ZXgsIDApKSwgdGV4LnV2TWF0cml4LnVwZGF0ZSgpLCB0aGlzLnVuaWZvcm1zLm5wbUFscGhhID0gdGV4LmJhc2VUZXh0dXJlLmFscGhhTW9kZSA/IDAgOiAxLCB0aGlzLnVuaWZvcm1zLm1hc2sgPSB0ZXgsIHRoaXMudW5pZm9ybXMub3RoZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIG1hc2tTcHJpdGUpLnByZXBlbmQodGV4LnV2TWF0cml4Lm1hcENvb3JkKSwgdGhpcy51bmlmb3Jtcy5hbHBoYSA9IG1hc2tTcHJpdGUud29ybGRBbHBoYSwgdGhpcy51bmlmb3Jtcy5tYXNrQ2xhbXAgPSB0ZXgudXZNYXRyaXgudUNsYW1wRnJhbWUsIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFNwcml0ZU1hc2tGaWx0ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGVNYXNrRmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IE1BU0tfVFlQRVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tIFwiLi4vZmlsdGVycy9GaWx0ZXIubWpzXCI7XG5jbGFzcyBNYXNrRGF0YSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgTWFza0RhdGFcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IFttYXNrT2JqZWN0PW51bGxdIC0gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBtYXNrXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXNrT2JqZWN0ID0gbnVsbCkge1xuICAgIHRoaXMudHlwZSA9IE1BU0tfVFlQRVMuTk9ORSwgdGhpcy5hdXRvRGV0ZWN0ID0gITAsIHRoaXMubWFza09iamVjdCA9IG1hc2tPYmplY3QgfHwgbnVsbCwgdGhpcy5wb29sZWQgPSAhMSwgdGhpcy5pc01hc2tEYXRhID0gITAsIHRoaXMucmVzb2x1dGlvbiA9IG51bGwsIHRoaXMubXVsdGlzYW1wbGUgPSBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlLCB0aGlzLmVuYWJsZWQgPSAhMCwgdGhpcy5jb2xvck1hc2sgPSAxNSwgdGhpcy5fZmlsdGVycyA9IG51bGwsIHRoaXMuX3N0ZW5jaWxDb3VudGVyID0gMCwgdGhpcy5fc2Npc3NvckNvdW50ZXIgPSAwLCB0aGlzLl9zY2lzc29yUmVjdCA9IG51bGwsIHRoaXMuX3NjaXNzb3JSZWN0TG9jYWwgPSBudWxsLCB0aGlzLl9jb2xvck1hc2sgPSAxNSwgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVGhlIHNwcml0ZSBtYXNrIGZpbHRlci5cbiAgICogSWYgc2V0IHRvIGBudWxsYCwgdGhlIGRlZmF1bHQgc3ByaXRlIG1hc2sgZmlsdGVyIGlzIHVzZWQuXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgPyB0aGlzLl9maWx0ZXJzWzBdIDogbnVsbDtcbiAgfVxuICBzZXQgZmlsdGVyKHZhbHVlKSB7XG4gICAgdmFsdWUgPyB0aGlzLl9maWx0ZXJzID8gdGhpcy5fZmlsdGVyc1swXSA9IHZhbHVlIDogdGhpcy5fZmlsdGVycyA9IFt2YWx1ZV0gOiB0aGlzLl9maWx0ZXJzID0gbnVsbDtcbiAgfVxuICAvKiogUmVzZXRzIHRoZSBtYXNrIGRhdGEgYWZ0ZXIgcG9wTWFzaygpLiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnBvb2xlZCAmJiAodGhpcy5tYXNrT2JqZWN0ID0gbnVsbCwgdGhpcy50eXBlID0gTUFTS19UWVBFUy5OT05FLCB0aGlzLmF1dG9EZXRlY3QgPSAhMCksIHRoaXMuX3RhcmdldCA9IG51bGwsIHRoaXMuX3NjaXNzb3JSZWN0TG9jYWwgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgY291bnRlcnMgZnJvbSBtYXNrRGF0YSBhYm92ZSwgY2FsbGVkIGZyb20gcHVzaE1hc2soKS5cbiAgICogQHBhcmFtIG1hc2tBYm92ZVxuICAgKi9cbiAgY29weUNvdW50ZXJzT3JSZXNldChtYXNrQWJvdmUpIHtcbiAgICBtYXNrQWJvdmUgPyAodGhpcy5fc3RlbmNpbENvdW50ZXIgPSBtYXNrQWJvdmUuX3N0ZW5jaWxDb3VudGVyLCB0aGlzLl9zY2lzc29yQ291bnRlciA9IG1hc2tBYm92ZS5fc2Npc3NvckNvdW50ZXIsIHRoaXMuX3NjaXNzb3JSZWN0ID0gbWFza0Fib3ZlLl9zY2lzc29yUmVjdCkgOiAodGhpcy5fc3RlbmNpbENvdW50ZXIgPSAwLCB0aGlzLl9zY2lzc29yQ291bnRlciA9IDAsIHRoaXMuX3NjaXNzb3JSZWN0ID0gbnVsbCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIE1hc2tEYXRhXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza0RhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgTUFTS19UWVBFUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgU3ByaXRlTWFza0ZpbHRlciB9IGZyb20gXCIuLi9maWx0ZXJzL3Nwcml0ZU1hc2svU3ByaXRlTWFza0ZpbHRlci5tanNcIjtcbmltcG9ydCB7IE1hc2tEYXRhIH0gZnJvbSBcIi4vTWFza0RhdGEubWpzXCI7XG5jbGFzcyBNYXNrU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5lbmFibGVTY2lzc29yID0gITAsIHRoaXMuYWxwaGFNYXNrUG9vbCA9IFtdLCB0aGlzLm1hc2tEYXRhUG9vbCA9IFtdLCB0aGlzLm1hc2tTdGFjayA9IFtdLCB0aGlzLmFscGhhTWFza0luZGV4ID0gMDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgbWFzayBzdGFjayB0aGF0IGlzIHVzZWQgYnkgdGhpcyBTeXN0ZW0uXG4gICAqIEBwYXJhbSBtYXNrU3RhY2sgLSBUaGUgbWFzayBzdGFja1xuICAgKi9cbiAgc2V0TWFza1N0YWNrKG1hc2tTdGFjaykge1xuICAgIHRoaXMubWFza1N0YWNrID0gbWFza1N0YWNrLCB0aGlzLnJlbmRlcmVyLnNjaXNzb3Iuc2V0TWFza1N0YWNrKG1hc2tTdGFjayksIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5zZXRNYXNrU3RhY2sobWFza1N0YWNrKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgbWFzayBhbmQgYXBwZW5kcyBpdCB0byB0aGUgY3VycmVudCBtYXNrIHN0YWNrLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgYmF0Y2ggcmVuZGVyZXIgc2hvdWxkIGJlIGZsdXNoZWQgYmVmb3JlaGFuZCB0byBwcmV2ZW50IHBlbmRpbmcgcmVuZGVycyBmcm9tIGJlaW5nIG1hc2tlZC5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIG1hc2sgdG9cbiAgICogQHBhcmFtIHtQSVhJLk1hc2tEYXRhfFBJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N8UElYSS5EaXNwbGF5T2JqZWN0fSBtYXNrRGF0YU9yVGFyZ2V0IC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICovXG4gIHB1c2godGFyZ2V0LCBtYXNrRGF0YU9yVGFyZ2V0KSB7XG4gICAgbGV0IG1hc2tEYXRhID0gbWFza0RhdGFPclRhcmdldDtcbiAgICBpZiAoIW1hc2tEYXRhLmlzTWFza0RhdGEpIHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLm1hc2tEYXRhUG9vbC5wb3AoKSB8fCBuZXcgTWFza0RhdGEoKTtcbiAgICAgIGQucG9vbGVkID0gITAsIGQubWFza09iamVjdCA9IG1hc2tEYXRhT3JUYXJnZXQsIG1hc2tEYXRhID0gZDtcbiAgICB9XG4gICAgY29uc3QgbWFza0Fib3ZlID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoICE9PSAwID8gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGlmIChtYXNrRGF0YS5jb3B5Q291bnRlcnNPclJlc2V0KG1hc2tBYm92ZSksIG1hc2tEYXRhLl9jb2xvck1hc2sgPSBtYXNrQWJvdmUgPyBtYXNrQWJvdmUuX2NvbG9yTWFzayA6IDE1LCBtYXNrRGF0YS5hdXRvRGV0ZWN0ICYmIHRoaXMuZGV0ZWN0KG1hc2tEYXRhKSwgbWFza0RhdGEuX3RhcmdldCA9IHRhcmdldCwgbWFza0RhdGEudHlwZSAhPT0gTUFTS19UWVBFUy5TUFJJVEUgJiYgdGhpcy5tYXNrU3RhY2sucHVzaChtYXNrRGF0YSksIG1hc2tEYXRhLmVuYWJsZWQpXG4gICAgICBzd2l0Y2ggKG1hc2tEYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNQVNLX1RZUEVTLlNDSVNTT1I6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1RFTkNJTDpcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucHVzaChtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5TUFJJVEU6XG4gICAgICAgICAgbWFza0RhdGEuY29weUNvdW50ZXJzT3JSZXNldChudWxsKSwgdGhpcy5wdXNoU3ByaXRlTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5DT0xPUjpcbiAgICAgICAgICB0aGlzLnB1c2hDb2xvck1hc2sobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIG1hc2tEYXRhLnR5cGUgPT09IE1BU0tfVFlQRVMuU1BSSVRFICYmIHRoaXMubWFza1N0YWNrLnB1c2gobWFza0RhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBsYXN0IG1hc2sgZnJvbSB0aGUgbWFzayBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAqXG4gICAqIE5PVEU6IFRoZSBiYXRjaCByZW5kZXJlciBzaG91bGQgYmUgZmx1c2hlZCBiZWZvcmVoYW5kIHRvIHJlbmRlciB0aGUgbWFza2VkIGNvbnRlbnRzIGJlZm9yZSB0aGUgbWFzayBpcyByZW1vdmVkLlxuICAgKiBAcGFyYW0ge1BJWEkuSU1hc2tUYXJnZXR9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHBvcCB0aGUgbWFzayBmcm9tXG4gICAqL1xuICBwb3AodGFyZ2V0KSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFjay5wb3AoKTtcbiAgICBpZiAoISghbWFza0RhdGEgfHwgbWFza0RhdGEuX3RhcmdldCAhPT0gdGFyZ2V0KSkge1xuICAgICAgaWYgKG1hc2tEYXRhLmVuYWJsZWQpXG4gICAgICAgIHN3aXRjaCAobWFza0RhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgTUFTS19UWVBFUy5TQ0lTU09SOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnBvcChtYXNrRGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1RFTkNJTDpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5wb3AobWFza0RhdGEubWFza09iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1BSSVRFOlxuICAgICAgICAgICAgdGhpcy5wb3BTcHJpdGVNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTUFTS19UWVBFUy5DT0xPUjpcbiAgICAgICAgICAgIHRoaXMucG9wQ29sb3JNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgaWYgKG1hc2tEYXRhLnJlc2V0KCksIG1hc2tEYXRhLnBvb2xlZCAmJiB0aGlzLm1hc2tEYXRhUG9vbC5wdXNoKG1hc2tEYXRhKSwgdGhpcy5tYXNrU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IG1hc2tDdXJyZW50ID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIG1hc2tDdXJyZW50LnR5cGUgPT09IE1BU0tfVFlQRVMuU1BSSVRFICYmIG1hc2tDdXJyZW50Ll9maWx0ZXJzICYmIChtYXNrQ3VycmVudC5fZmlsdGVyc1swXS5tYXNrU3ByaXRlID0gbWFza0N1cnJlbnQubWFza09iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHR5cGUgb2YgTWFza0RhdGEgYmFzZWQgb24gaXRzIG1hc2tPYmplY3QuXG4gICAqIEBwYXJhbSBtYXNrRGF0YVxuICAgKi9cbiAgZGV0ZWN0KG1hc2tEYXRhKSB7XG4gICAgY29uc3QgbWFza09iamVjdCA9IG1hc2tEYXRhLm1hc2tPYmplY3Q7XG4gICAgbWFza09iamVjdCA/IG1hc2tPYmplY3QuaXNTcHJpdGUgPyBtYXNrRGF0YS50eXBlID0gTUFTS19UWVBFUy5TUFJJVEUgOiB0aGlzLmVuYWJsZVNjaXNzb3IgJiYgdGhpcy5yZW5kZXJlci5zY2lzc29yLnRlc3RTY2lzc29yKG1hc2tEYXRhKSA/IG1hc2tEYXRhLnR5cGUgPSBNQVNLX1RZUEVTLlNDSVNTT1IgOiBtYXNrRGF0YS50eXBlID0gTUFTS19UWVBFUy5TVEVOQ0lMIDogbWFza0RhdGEudHlwZSA9IE1BU0tfVFlQRVMuQ09MT1I7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICAgKiBAcGFyYW0gbWFza0RhdGEgLSBTcHJpdGUgdG8gYmUgdXNlZCBhcyB0aGUgbWFzay5cbiAgICovXG4gIHB1c2hTcHJpdGVNYXNrKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgeyBtYXNrT2JqZWN0IH0gPSBtYXNrRGF0YSwgdGFyZ2V0ID0gbWFza0RhdGEuX3RhcmdldDtcbiAgICBsZXQgYWxwaGFNYXNrRmlsdGVyID0gbWFza0RhdGEuX2ZpbHRlcnM7XG4gICAgYWxwaGFNYXNrRmlsdGVyIHx8IChhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF0sIGFscGhhTWFza0ZpbHRlciB8fCAoYWxwaGFNYXNrRmlsdGVyID0gdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdID0gW25ldyBTcHJpdGVNYXNrRmlsdGVyKCldKSksIGFscGhhTWFza0ZpbHRlclswXS5yZXNvbHV0aW9uID0gbWFza0RhdGEucmVzb2x1dGlvbiwgYWxwaGFNYXNrRmlsdGVyWzBdLm11bHRpc2FtcGxlID0gbWFza0RhdGEubXVsdGlzYW1wbGUsIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza09iamVjdDtcbiAgICBjb25zdCBzdGFzaEZpbHRlckFyZWEgPSB0YXJnZXQuZmlsdGVyQXJlYTtcbiAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IG1hc2tPYmplY3QuZ2V0Qm91bmRzKCEwKSwgdGhpcy5yZW5kZXJlci5maWx0ZXIucHVzaCh0YXJnZXQsIGFscGhhTWFza0ZpbHRlciksIHRhcmdldC5maWx0ZXJBcmVhID0gc3Rhc2hGaWx0ZXJBcmVhLCBtYXNrRGF0YS5fZmlsdGVycyB8fCB0aGlzLmFscGhhTWFza0luZGV4Kys7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFNwcml0ZSB0byBiZSB1c2VkIGFzIHRoZSBtYXNrLlxuICAgKi9cbiAgcG9wU3ByaXRlTWFzayhtYXNrRGF0YSkge1xuICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnBvcCgpLCBtYXNrRGF0YS5fZmlsdGVycyA/IG1hc2tEYXRhLl9maWx0ZXJzWzBdLm1hc2tTcHJpdGUgPSBudWxsIDogKHRoaXMuYWxwaGFNYXNrSW5kZXgtLSwgdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdWzBdLm1hc2tTcHJpdGUgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogUHVzaGVzIHRoZSBjb2xvciBtYXNrLlxuICAgKiBAcGFyYW0gbWFza0RhdGEgLSBUaGUgbWFzayBkYXRhXG4gICAqL1xuICBwdXNoQ29sb3JNYXNrKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgY3VyckNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2ssIG5leHRDb2xvck1hc2sgPSBtYXNrRGF0YS5fY29sb3JNYXNrID0gY3VyckNvbG9yTWFzayAmIG1hc2tEYXRhLmNvbG9yTWFzaztcbiAgICBuZXh0Q29sb3JNYXNrICE9PSBjdXJyQ29sb3JNYXNrICYmIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKFxuICAgICAgKG5leHRDb2xvck1hc2sgJiAxKSAhPT0gMCxcbiAgICAgIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsXG4gICAgICAobmV4dENvbG9yTWFzayAmIDQpICE9PSAwLFxuICAgICAgKG5leHRDb2xvck1hc2sgJiA4KSAhPT0gMFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcHMgdGhlIGNvbG9yIG1hc2suXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFRoZSBtYXNrIGRhdGFcbiAgICovXG4gIHBvcENvbG9yTWFzayhtYXNrRGF0YSkge1xuICAgIGNvbnN0IGN1cnJDb2xvck1hc2sgPSBtYXNrRGF0YS5fY29sb3JNYXNrLCBuZXh0Q29sb3JNYXNrID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoID4gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9jb2xvck1hc2sgOiAxNTtcbiAgICBuZXh0Q29sb3JNYXNrICE9PSBjdXJyQ29sb3JNYXNrICYmIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKFxuICAgICAgKG5leHRDb2xvck1hc2sgJiAxKSAhPT0gMCxcbiAgICAgIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsXG4gICAgICAobmV4dENvbG9yTWFzayAmIDQpICE9PSAwLFxuICAgICAgKG5leHRDb2xvck1hc2sgJiA4KSAhPT0gMFxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuTWFza1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwibWFza1wiXG59O1xuZXh0ZW5zaW9ucy5hZGQoTWFza1N5c3RlbSk7XG5leHBvcnQge1xuICBNYXNrU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza1N5c3RlbS5tanMubWFwXG4iLCJjbGFzcyBBYnN0cmFjdE1hc2tTeXN0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLm1hc2tTdGFjayA9IFtdLCB0aGlzLmdsQ29uc3QgPSAwO1xuICB9XG4gIC8qKiBHZXRzIGNvdW50IG9mIG1hc2tzIG9mIGNlcnRhaW4gdHlwZS4gKi9cbiAgZ2V0U3RhY2tMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFza1N0YWNrLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgbWFzayBzdGFjayB0aGF0IGlzIHVzZWQgYnkgdGhpcyBTeXN0ZW0uXG4gICAqIEBwYXJhbSB7UElYSS5NYXNrRGF0YVtdfSBtYXNrU3RhY2sgLSBUaGUgbWFzayBzdGFja1xuICAgKi9cbiAgc2V0TWFza1N0YWNrKG1hc2tTdGFjaykge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMucmVuZGVyZXIsIGN1clN0YWNrTGVuID0gdGhpcy5nZXRTdGFja0xlbmd0aCgpO1xuICAgIHRoaXMubWFza1N0YWNrID0gbWFza1N0YWNrO1xuICAgIGNvbnN0IG5ld1N0YWNrTGVuID0gdGhpcy5nZXRTdGFja0xlbmd0aCgpO1xuICAgIG5ld1N0YWNrTGVuICE9PSBjdXJTdGFja0xlbiAmJiAobmV3U3RhY2tMZW4gPT09IDAgPyBnbC5kaXNhYmxlKHRoaXMuZ2xDb25zdCkgOiAoZ2wuZW5hYmxlKHRoaXMuZ2xDb25zdCksIHRoaXMuX3VzZUN1cnJlbnQoKSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR1cCByZW5kZXJlciB0byB1c2UgdGhlIGN1cnJlbnQgbWFzayBkYXRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VzZUN1cnJlbnQoKSB7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBtYXNrIHN0YWNrLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsLCB0aGlzLm1hc2tTdGFjayA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEFic3RyYWN0TWFza1N5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TWFza1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IE1hdHJpeCwgUmVjdGFuZ2xlIH0gZnJvbSBcIkBwaXhpL21hdGhcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdE1hc2tTeXN0ZW0gfSBmcm9tIFwiLi9BYnN0cmFjdE1hc2tTeXN0ZW0ubWpzXCI7XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpLCByZWN0UG9vbCA9IFtdLCBfU2Npc3NvclN5c3RlbSA9IGNsYXNzIF9TY2lzc29yU3lzdGVtMiBleHRlbmRzIEFic3RyYWN0TWFza1N5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpLCB0aGlzLmdsQ29uc3QgPSBzZXR0aW5ncy5BREFQVEVSLmdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCgpLlNDSVNTT1JfVEVTVDtcbiAgfVxuICBnZXRTdGFja0xlbmd0aCgpIHtcbiAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBtYXNrRGF0YSA/IG1hc2tEYXRhLl9zY2lzc29yQ291bnRlciA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIGV2YWx1YXRlcyBfYm91bmRzVHJhbnNmb3JtZWQsIF9zY2lzc29yUmVjdCBmb3IgTWFza0RhdGFcbiAgICogQHBhcmFtIG1hc2tEYXRhXG4gICAqL1xuICBjYWxjU2Npc3NvclJlY3QobWFza0RhdGEpIHtcbiAgICBpZiAobWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcHJldkRhdGEgPSBtYXNrRGF0YS5fc2Npc3NvclJlY3QsIHsgbWFza09iamVjdCB9ID0gbWFza0RhdGEsIHsgcmVuZGVyZXIgfSA9IHRoaXMsIHJlbmRlclRleHR1cmVTeXN0ZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLCByZWN0ID0gbWFza09iamVjdC5nZXRCb3VuZHMoITAsIHJlY3RQb29sLnBvcCgpID8/IG5ldyBSZWN0YW5nbGUoKSk7XG4gICAgdGhpcy5yb3VuZEZyYW1lVG9QaXhlbHMoXG4gICAgICByZWN0LFxuICAgICAgcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50ID8gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50LnJlc29sdXRpb24gOiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgcmVuZGVyVGV4dHVyZVN5c3RlbS5zb3VyY2VGcmFtZSxcbiAgICAgIHJlbmRlclRleHR1cmVTeXN0ZW0uZGVzdGluYXRpb25GcmFtZSxcbiAgICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtXG4gICAgKSwgcHJldkRhdGEgJiYgcmVjdC5maXQocHJldkRhdGEpLCBtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCA9IHJlY3Q7XG4gIH1cbiAgc3RhdGljIGlzTWF0cml4Um90YXRlZChtYXRyaXgpIHtcbiAgICBpZiAoIW1hdHJpeClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IG1hdHJpeDtcbiAgICByZXR1cm4gKE1hdGguYWJzKGIpID4gMWUtNCB8fCBNYXRoLmFicyhjKSA+IDFlLTQpICYmIChNYXRoLmFicyhhKSA+IDFlLTQgfHwgTWF0aC5hYnMoZCkgPiAxZS00KTtcbiAgfVxuICAvKipcbiAgICogVGVzdCwgd2hldGhlciB0aGUgb2JqZWN0IGNhbiBiZSBzY2lzc29yIG1hc2sgd2l0aCBjdXJyZW50IHJlbmRlcmVyIHByb2plY3Rpb24uXG4gICAqIENhbGxzIFwiY2FsY1NjaXNzb3JSZWN0KClcIiBpZiBpdHMgdHJ1ZS5cbiAgICogQHBhcmFtIG1hc2tEYXRhIC0gbWFzayBkYXRhXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgV2hldGhlciB0aGUgb2JqZWN0IGNhbiBiZSBzY2lzc29yIG1hc2tcbiAgICovXG4gIHRlc3RTY2lzc29yKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgeyBtYXNrT2JqZWN0IH0gPSBtYXNrRGF0YTtcbiAgICBpZiAoIW1hc2tPYmplY3QuaXNGYXN0UmVjdCB8fCAhbWFza09iamVjdC5pc0Zhc3RSZWN0KCkgfHwgX1NjaXNzb3JTeXN0ZW0yLmlzTWF0cml4Um90YXRlZChtYXNrT2JqZWN0LndvcmxkVHJhbnNmb3JtKSB8fCBfU2Npc3NvclN5c3RlbTIuaXNNYXRyaXhSb3RhdGVkKHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRoaXMuY2FsY1NjaXNzb3JSZWN0KG1hc2tEYXRhKTtcbiAgICBjb25zdCByZWN0ID0gbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWw7XG4gICAgcmV0dXJuIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgfVxuICByb3VuZEZyYW1lVG9QaXhlbHMoZnJhbWUsIHJlc29sdXRpb24sIGJpbmRpbmdTb3VyY2VGcmFtZSwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUsIHRyYW5zZm9ybSkge1xuICAgIF9TY2lzc29yU3lzdGVtMi5pc01hdHJpeFJvdGF0ZWQodHJhbnNmb3JtKSB8fCAodHJhbnNmb3JtID0gdHJhbnNmb3JtID8gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pIDogdGVtcE1hdHJpeC5pZGVudGl0eSgpLCB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShcbiAgICAgIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gYmluZGluZ1NvdXJjZUZyYW1lLndpZHRoLFxuICAgICAgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodFxuICAgICkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpLCB0aGlzLnJlbmRlcmVyLmZpbHRlci50cmFuc2Zvcm1BQUJCKHRyYW5zZm9ybSwgZnJhbWUpLCBmcmFtZS5maXQoYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUpLCBmcmFtZS54ID0gTWF0aC5yb3VuZChmcmFtZS54ICogcmVzb2x1dGlvbiksIGZyYW1lLnkgPSBNYXRoLnJvdW5kKGZyYW1lLnkgKiByZXNvbHV0aW9uKSwgZnJhbWUud2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lLndpZHRoICogcmVzb2x1dGlvbiksIGZyYW1lLmhlaWdodCA9IE1hdGgucm91bmQoZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbikpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0ZW5jaWwgc3RhY2suXG4gICAqIEBhdXRob3IgYWx2aW5cbiAgICogQHBhcmFtIG1hc2tEYXRhIC0gVGhlIG1hc2sgZGF0YS5cbiAgICovXG4gIHB1c2gobWFza0RhdGEpIHtcbiAgICBtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCB8fCB0aGlzLmNhbGNTY2lzc29yUmVjdChtYXNrRGF0YSk7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBtYXNrRGF0YS5fc2Npc3NvclJlY3QgfHwgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCksIG1hc2tEYXRhLl9zY2lzc29yQ291bnRlcisrLCBtYXNrRGF0YS5fc2Npc3NvclJlY3QgPSBtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCwgdGhpcy5fdXNlQ3VycmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYSBtYXNrIGlzIHBvcHBlZCBvZmYgdGhlIG1hc2sgc3RhY2suIEl0IHdpbGwgcmViaW5kIHRoZSBzY2lzc29yIGJveCB0byBiZSBsYXRlc3Qgd2l0aCB0aGVcbiAgICogbGFzdCBtYXNrIGluIHRoZSBzdGFjay5cbiAgICpcbiAgICogVGhpcyBjYW4gYWxzbyBiZSBjYWxsZWQgd2hlbiB5b3UgZGlyZWN0bHkgbW9kaWZ5IHRoZSBzY2lzc29yIGJveCBhbmQgd2FudCB0byByZXN0b3JlIFBpeGlKUyBzdGF0ZS5cbiAgICogQHBhcmFtIG1hc2tEYXRhIC0gVGhlIG1hc2sgZGF0YS5cbiAgICovXG4gIHBvcChtYXNrRGF0YSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgbWFza0RhdGEgJiYgcmVjdFBvb2wucHVzaChtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCksIHRoaXMuZ2V0U3RhY2tMZW5ndGgoKSA+IDAgPyB0aGlzLl91c2VDdXJyZW50KCkgOiBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHVwIHJlbmRlcmVyIHRvIHVzZSB0aGUgY3VycmVudCBzY2lzc29yIGRhdGEuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXNlQ3VycmVudCgpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV0uX3NjaXNzb3JSZWN0O1xuICAgIGxldCB5O1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jdXJyZW50ID8geSA9IHJlY3QueSA6IHkgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCAtIHJlY3QuaGVpZ2h0IC0gcmVjdC55LCB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IocmVjdC54LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gIH1cbn07XG5fU2Npc3NvclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic2Npc3NvclwiXG59O1xubGV0IFNjaXNzb3JTeXN0ZW0gPSBfU2Npc3NvclN5c3RlbTtcbmV4dGVuc2lvbnMuYWRkKFNjaXNzb3JTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgU2Npc3NvclN5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaXNzb3JTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RNYXNrU3lzdGVtIH0gZnJvbSBcIi4vQWJzdHJhY3RNYXNrU3lzdGVtLm1qc1wiO1xuY2xhc3MgU3RlbmNpbFN5c3RlbSBleHRlbmRzIEFic3RyYWN0TWFza1N5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlciksIHRoaXMuZ2xDb25zdCA9IHNldHRpbmdzLkFEQVBURVIuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkuU1RFTkNJTF9URVNUO1xuICB9XG4gIGdldFN0YWNrTGVuZ3RoKCkge1xuICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIG1hc2tEYXRhID8gbWFza0RhdGEuX3N0ZW5jaWxDb3VudGVyIDogMDtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBzdGVuY2lsIHN0YWNrLlxuICAgKiBAcGFyYW0gbWFza0RhdGEgLSBUaGUgbWFzayBkYXRhXG4gICAqL1xuICBwdXNoKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgbWFza09iamVjdCA9IG1hc2tEYXRhLm1hc2tPYmplY3QsIHsgZ2wgfSA9IHRoaXMucmVuZGVyZXIsIHByZXZNYXNrQ291bnQgPSBtYXNrRGF0YS5fc3RlbmNpbENvdW50ZXI7XG4gICAgcHJldk1hc2tDb3VudCA9PT0gMCAmJiAodGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5mb3JjZVN0ZW5jaWwoKSwgZ2wuY2xlYXJTdGVuY2lsKDApLCBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpLCBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKSksIG1hc2tEYXRhLl9zdGVuY2lsQ291bnRlcisrO1xuICAgIGNvbnN0IGNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2s7XG4gICAgY29sb3JNYXNrICE9PSAwICYmIChtYXNrRGF0YS5fY29sb3JNYXNrID0gMCwgZ2wuY29sb3JNYXNrKCExLCAhMSwgITEsICExKSksIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCBwcmV2TWFza0NvdW50LCA0Mjk0OTY3Mjk1KSwgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1IpLCBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSAhMCwgbWFza09iamVjdC5yZW5kZXIodGhpcy5yZW5kZXJlciksIHRoaXMucmVuZGVyZXIuYmF0Y2guZmx1c2goKSwgbWFza09iamVjdC5yZW5kZXJhYmxlID0gITEsIGNvbG9yTWFzayAhPT0gMCAmJiAobWFza0RhdGEuX2NvbG9yTWFzayA9IGNvbG9yTWFzaywgZ2wuY29sb3JNYXNrKFxuICAgICAgKGNvbG9yTWFzayAmIDEpICE9PSAwLFxuICAgICAgKGNvbG9yTWFzayAmIDIpICE9PSAwLFxuICAgICAgKGNvbG9yTWFzayAmIDQpICE9PSAwLFxuICAgICAgKGNvbG9yTWFzayAmIDgpICE9PSAwXG4gICAgKSksIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgfVxuICAvKipcbiAgICogUG9wcyBzdGVuY2lsIG1hc2suIE1hc2tEYXRhIGlzIGFscmVhZHkgcmVtb3ZlZCBmcm9tIHN0YWNrXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBtYXNrT2JqZWN0IC0gb2JqZWN0IG9mIHBvcHBlZCBtYXNrIGRhdGFcbiAgICovXG4gIHBvcChtYXNrT2JqZWN0KSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIGlmICh0aGlzLmdldFN0YWNrTGVuZ3RoKCkgPT09IDApXG4gICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMubWFza1N0YWNrLmxlbmd0aCAhPT0gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdIDogbnVsbCwgY29sb3JNYXNrID0gbWFza0RhdGEgPyBtYXNrRGF0YS5fY29sb3JNYXNrIDogMTU7XG4gICAgICBjb2xvck1hc2sgIT09IDAgJiYgKG1hc2tEYXRhLl9jb2xvck1hc2sgPSAwLCBnbC5jb2xvck1hc2soITEsICExLCAhMSwgITEpKSwgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLkRFQ1IpLCBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSAhMCwgbWFza09iamVjdC5yZW5kZXIodGhpcy5yZW5kZXJlciksIHRoaXMucmVuZGVyZXIuYmF0Y2guZmx1c2goKSwgbWFza09iamVjdC5yZW5kZXJhYmxlID0gITEsIGNvbG9yTWFzayAhPT0gMCAmJiAobWFza0RhdGEuX2NvbG9yTWFzayA9IGNvbG9yTWFzaywgZ2wuY29sb3JNYXNrKFxuICAgICAgICAoY29sb3JNYXNrICYgMSkgIT09IDAsXG4gICAgICAgIChjb2xvck1hc2sgJiAyKSAhPT0gMCxcbiAgICAgICAgKGNvbG9yTWFzayAmIDQpICE9PSAwLFxuICAgICAgICAoY29sb3JNYXNrICYgOCkgIT09IDBcbiAgICAgICkpLCB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXR1cCByZW5kZXJlciB0byB1c2UgdGhlIGN1cnJlbnQgc3RlbmNpbCBkYXRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VzZUN1cnJlbnQoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCB0aGlzLmdldFN0YWNrTGVuZ3RoKCksIDQyOTQ5NjcyOTUpLCBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gIH1cbn1cblN0ZW5jaWxTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInN0ZW5jaWxcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFN0ZW5jaWxTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgU3RlbmNpbFN5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0ZW5jaWxTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gXCJAcGl4aS91dGlsc1wiO1xuY2xhc3MgUGx1Z2luU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMucGx1Z2lucyA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLnBsdWdpbnMsIHtcbiAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMuZXh0cmFjdCBoYXMgbW92ZWQgdG8gcmVuZGVyZXIuZXh0cmFjdFwiKSwgcmVuZGVyZXIuZXh0cmFjdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZXBhcmU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMucHJlcGFyZSBoYXMgbW92ZWQgdG8gcmVuZGVyZXIucHJlcGFyZVwiKSwgcmVuZGVyZXIucHJlcGFyZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGludGVyYWN0aW9uOiB7XG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5ldmVudHNcIiksIHJlbmRlcmVyLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBwbHVnaW5zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0KCkge1xuICAgIGNvbnN0IHN0YXRpY01hcCA9IHRoaXMucmVuZGVyZXJQbHVnaW5zO1xuICAgIGZvciAoY29uc3QgbyBpbiBzdGF0aWNNYXApXG4gICAgICB0aGlzLnBsdWdpbnNbb10gPSBuZXcgc3RhdGljTWFwW29dKHRoaXMucmVuZGVyZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBvIGluIHRoaXMucGx1Z2lucylcbiAgICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCksIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XG4gIH1cbn1cblBsdWdpblN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJfcGx1Z2luXCJcbn07XG5leHRlbnNpb25zLmFkZChQbHVnaW5TeXN0ZW0pO1xuZXhwb3J0IHtcbiAgUGx1Z2luU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGx1Z2luU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIkBwaXhpL21hdGhcIjtcbmNsYXNzIFByb2plY3Rpb25TeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGwsIHRoaXMuc291cmNlRnJhbWUgPSBudWxsLCB0aGlzLmRlZmF1bHRGcmFtZSA9IG51bGwsIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXgoKSwgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwcm9qZWN0aW9uLW1hdHJpeCBiYXNlZCBvbiB0aGUgc291cmNlRnJhbWUg4oaSIGRlc3RpbmF0aW9uRnJhbWUgbWFwcGluZyBwcm92aWRlZC5cbiAgICpcbiAgICogTk9URTogSXQgaXMgZXhwZWN0ZWQgeW91IGNhbGwgYHJlbmRlcmVyLmZyYW1lYnVmZmVyLnNldFZpZXdwb3J0KGRlc3RpbmF0aW9uRnJhbWUpYCBhZnRlciB0aGlzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICogdGhlIGZyYW1lYnVmZmVyIHZpZXdwb3J0IGNvbnZlcnRzIHNoYWRlciB2ZXJ0ZXggb3V0cHV0IGluIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzIHRvIHdpbmRvdyBjb29yZGluYXRlcy5cbiAgICpcbiAgICogTk9URS0yOiB7QGxpbmsgUElYSS5SZW5kZXJUZXh0dXJlU3lzdGVtI2JpbmR9IHVwZGF0ZXMgdGhlIHByb2plY3Rpb24tbWF0cml4IHdoZW4geW91IGJpbmQgYSByZW5kZXItdGV4dHVyZS5cbiAgICogSXQgaXMgZXhwZWN0ZWRcbiAgICogdGhhdCB5b3UgZGlydHkgdGhlIGN1cnJlbnQgYmluZGluZ3Mgd2hlbiBjYWxsaW5nIHRoaXMgbWFudWFsbHkuXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIHJlY3RhbmdsZSBpbiB0aGUgcmVuZGVyLXRhcmdldCB0byByZW5kZXIgdGhlIGNvbnRlbnRzIGludG8uIElmIHJlbmRlcmluZyB0byB0aGUgY2FudmFzLFxuICAgKiAgdGhlIG9yaWdpbiBpcyBvbiB0aGUgdG9wLWxlZnQ7IGlmIHJlbmRlcmluZyB0byBhIHJlbmRlci10ZXh0dXJlLCB0aGUgb3JpZ2luIGlzIG9uIHRoZSBib3R0b20tbGVmdC5cbiAgICogQHBhcmFtIHNvdXJjZUZyYW1lIC0gVGhlIHJlY3RhbmdsZSBpbiB3b3JsZCBzcGFjZSB0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50cyBiZWluZyByZW5kZXJlZC5cbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyLXRhcmdldCwgd2hpY2ggaXMgdGhlIHJhdGlvIG9mXG4gICAqICB3b3JsZC1zcGFjZSAob3IgQ1NTKSBwaXhlbHMgdG8gcGh5c2ljYWwgcGl4ZWxzLlxuICAgKiBAcGFyYW0gcm9vdCAtIFdoZXRoZXIgdGhlIHJlbmRlci10YXJnZXQgaXMgdGhlIHNjcmVlbi4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIHJlbmRlcmluZyB0byB0ZXh0dXJlc1xuICAgKiAgaXMgeS1mbGlwcGVkIChpLmUuIHVwc2lkZSBkb3duIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4pLlxuICAgKi9cbiAgdXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZWZhdWx0RnJhbWUsIHRoaXMuc291cmNlRnJhbWUgPSBzb3VyY2VGcmFtZSB8fCB0aGlzLnNvdXJjZUZyYW1lIHx8IGRlc3RpbmF0aW9uRnJhbWUsIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbih0aGlzLmRlc3RpbmF0aW9uRnJhbWUsIHRoaXMuc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpLCB0aGlzLnRyYW5zZm9ybSAmJiB0aGlzLnByb2plY3Rpb25NYXRyaXguYXBwZW5kKHRoaXMudHJhbnNmb3JtKTtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeCwgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCksIHJlbmRlcmVyLnNoYWRlci5zaGFkZXIgJiYgcmVuZGVyZXIuc2hhZGVyLnN5bmNVbmlmb3JtR3JvdXAocmVuZGVyZXIuc2hhZGVyLnNoYWRlci51bmlmb3Jtcy5nbG9iYWxzKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYHByb2plY3Rpb25NYXRyaXhgIHRvIG1hcCBwb2ludHMgaW5zaWRlIGBzb3VyY2VGcmFtZWAgdG8gaW5zaWRlIGBkZXN0aW5hdGlvbkZyYW1lYC5cbiAgICogQHBhcmFtIF9kZXN0aW5hdGlvbkZyYW1lIC0gVGhlIGRlc3RpbmF0aW9uIGZyYW1lIGluIHRoZSByZW5kZXItdGFyZ2V0LlxuICAgKiBAcGFyYW0gc291cmNlRnJhbWUgLSBUaGUgc291cmNlIGZyYW1lIGluIHdvcmxkIHNwYWNlLlxuICAgKiBAcGFyYW0gX3Jlc29sdXRpb24gLSBUaGUgcmVuZGVyLXRhcmdldCdzIHJlc29sdXRpb24sIGkuZS4gcmF0aW8gb2YgQ1NTIHRvIHBoeXNpY2FsIHBpeGVscy5cbiAgICogQHBhcmFtIHJvb3QgLSBXaGV0aGVyIHJlbmRlcmluZyBpbnRvIHRoZSBzY3JlZW4uIE90aGVyd2lzZSwgaWYgcmVuZGVyaW5nIHRvIGEgZnJhbWVidWZmZXIsIHRoZSBwcm9qZWN0aW9uXG4gICAqICBpcyB5LWZsaXBwZWQuXG4gICAqL1xuICBjYWxjdWxhdGVQcm9qZWN0aW9uKF9kZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgX3Jlc29sdXRpb24sIHJvb3QpIHtcbiAgICBjb25zdCBwbSA9IHRoaXMucHJvamVjdGlvbk1hdHJpeCwgc2lnbiA9IHJvb3QgPyAtMSA6IDE7XG4gICAgcG0uaWRlbnRpdHkoKSwgcG0uYSA9IDEgLyBzb3VyY2VGcmFtZS53aWR0aCAqIDIsIHBtLmQgPSBzaWduICogKDEgLyBzb3VyY2VGcmFtZS5oZWlnaHQgKiAyKSwgcG0udHggPSAtMSAtIHNvdXJjZUZyYW1lLnggKiBwbS5hLCBwbS50eSA9IC1zaWduIC0gc291cmNlRnJhbWUueSAqIHBtLmQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgYWN0aXZlIHJlbmRlciB0YXJnZXQgdG8gdGhlIGdpdmVuIG1hdHJpeC5cbiAgICogQHBhcmFtIF9tYXRyaXggLSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAqL1xuICBzZXRUcmFuc2Zvcm0oX21hdHJpeCkge1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cblByb2plY3Rpb25TeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInByb2plY3Rpb25cIlxufTtcbmV4dGVuc2lvbnMuYWRkKFByb2plY3Rpb25TeXN0ZW0pO1xuZXhwb3J0IHtcbiAgUHJvamVjdGlvblN5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb2plY3Rpb25TeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0sIFJlY3RhbmdsZSwgTWF0cml4IH0gZnJvbSBcIkBwaXhpL21hdGhcIjtcbmltcG9ydCB7IFJlbmRlclRleHR1cmUgfSBmcm9tIFwiLi9SZW5kZXJUZXh0dXJlLm1qc1wiO1xuY29uc3QgdGVtcFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKSwgdGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5jbGFzcyBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5fdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgfVxuICAvKipcbiAgICogQSBVc2VmdWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBvZiB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXG4gICAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3QgLSBUaGUgZGlzcGxheU9iamVjdCB0aGUgb2JqZWN0IHdpbGwgYmUgZ2VuZXJhdGVkIGZyb20uXG4gICAqIEBwYXJhbSB7SUdlbmVyYXRlVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgLSBHZW5lcmF0ZSB0ZXh0dXJlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IG9wdGlvbnMucmVnaW9uIC0gVGhlIHJlZ2lvbiBvZiB0aGUgZGlzcGxheU9iamVjdCwgdGhhdCBzaGFsbCBiZSByZW5kZXJlZCxcbiAgICogICAgICAgIGlmIG5vIHJlZ2lvbiBpcyBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uXSAtIElmIG5vdCBnaXZlbiwgdGhlIHJlbmRlcmVyJ3MgcmVzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge1BJWEkuTVNBQV9RVUFMSVRZfSBbb3B0aW9ucy5tdWx0aXNhbXBsZV0gLSBJZiBub3QgZ2l2ZW4sIHRoZSByZW5kZXJlcidzIG11bHRpc2FtcGxlIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIGEgc2hpbnkgbmV3IHRleHR1cmUgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHBhc3NlZCBpblxuICAgKi9cbiAgZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlZ2lvbjogbWFudWFsUmVnaW9uLCAuLi50ZXh0dXJlT3B0aW9ucyB9ID0gb3B0aW9ucyB8fCB7fSwgcmVnaW9uID0gbWFudWFsUmVnaW9uPy5jb3B5VG8odGVtcFJlY3QpIHx8IGRpc3BsYXlPYmplY3QuZ2V0TG9jYWxCb3VuZHModGVtcFJlY3QsICEwKSwgcmVzb2x1dGlvbiA9IHRleHR1cmVPcHRpb25zLnJlc29sdXRpb24gfHwgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIHJlZ2lvbi53aWR0aCA9IE1hdGgubWF4KHJlZ2lvbi53aWR0aCwgMSAvIHJlc29sdXRpb24pLCByZWdpb24uaGVpZ2h0ID0gTWF0aC5tYXgocmVnaW9uLmhlaWdodCwgMSAvIHJlc29sdXRpb24pLCB0ZXh0dXJlT3B0aW9ucy53aWR0aCA9IHJlZ2lvbi53aWR0aCwgdGV4dHVyZU9wdGlvbnMuaGVpZ2h0ID0gcmVnaW9uLmhlaWdodCwgdGV4dHVyZU9wdGlvbnMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24sIHRleHR1cmVPcHRpb25zLm11bHRpc2FtcGxlID8/ICh0ZXh0dXJlT3B0aW9ucy5tdWx0aXNhbXBsZSA9IHRoaXMucmVuZGVyZXIubXVsdGlzYW1wbGUpO1xuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlLmNyZWF0ZSh0ZXh0dXJlT3B0aW9ucyk7XG4gICAgdGhpcy5fdGVtcE1hdHJpeC50eCA9IC1yZWdpb24ueCwgdGhpcy5fdGVtcE1hdHJpeC50eSA9IC1yZWdpb24ueTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybTtcbiAgICByZXR1cm4gZGlzcGxheU9iamVjdC50cmFuc2Zvcm0gPSB0ZW1wVHJhbnNmb3JtLCB0aGlzLnJlbmRlcmVyLnJlbmRlcihkaXNwbGF5T2JqZWN0LCB7XG4gICAgICByZW5kZXJUZXh0dXJlLFxuICAgICAgdHJhbnNmb3JtOiB0aGlzLl90ZW1wTWF0cml4LFxuICAgICAgc2tpcFVwZGF0ZVRyYW5zZm9ybTogISFkaXNwbGF5T2JqZWN0LnBhcmVudCxcbiAgICAgIGJsaXQ6ICEwXG4gICAgfSksIGRpc3BsYXlPYmplY3QudHJhbnNmb3JtID0gdHJhbnNmb3JtLCByZW5kZXJUZXh0dXJlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cbkdlbmVyYXRlVGV4dHVyZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJ0ZXh0dXJlR2VuZXJhdG9yXCJcbn07XG5leHRlbnNpb25zLmFkZChHZW5lcmF0ZVRleHR1cmVTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgR2VuZXJhdGVUZXh0dXJlU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSBcIkBwaXhpL2NvbG9yXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gXCJAcGl4aS9tYXRoXCI7XG5jb25zdCB0ZW1wUmVjdCA9IG5ldyBSZWN0YW5nbGUoKSwgdGVtcFJlY3QyID0gbmV3IFJlY3RhbmdsZSgpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVN5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuZGVmYXVsdE1hc2tTdGFjayA9IFtdLCB0aGlzLmN1cnJlbnQgPSBudWxsLCB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IFJlY3RhbmdsZSgpLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCksIHRoaXMudmlld3BvcnRGcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLnJlbmRlcmVyPy5nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHRoaXMuX3JlbmRlcmVyUHJlbXVsdGlwbGllZEFscGhhID0gISEoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmFscGhhICYmIGF0dHJpYnV0ZXMucHJlbXVsdGlwbGllZEFscGhhKTtcbiAgfVxuICAvKipcbiAgICogQmluZCB0aGUgY3VycmVudCByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHJlbmRlclRleHR1cmUgLSBSZW5kZXJUZXh0dXJlIHRvIGJpbmQsIGJ5IGRlZmF1bHQgaXRzIGBudWxsYCAtIHRoZSBzY3JlZW4uXG4gICAqIEBwYXJhbSBzb3VyY2VGcmFtZSAtIFBhcnQgb2Ygd29ybGQgdGhhdCBpcyBtYXBwZWQgdG8gdGhlIHJlbmRlclRleHR1cmUuXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkZyYW1lIC0gUGFydCBvZiByZW5kZXJUZXh0dXJlLCBieSBkZWZhdWx0IGl0IGhhcyB0aGUgc2FtZSBzaXplIGFzIHNvdXJjZUZyYW1lLlxuICAgKi9cbiAgYmluZChyZW5kZXJUZXh0dXJlID0gbnVsbCwgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5jdXJyZW50ID0gcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgYmFzZVRleHR1cmUsIGZyYW1lYnVmZmVyLCByZXNvbHV0aW9uO1xuICAgIHJlbmRlclRleHR1cmUgPyAoYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCByZXNvbHV0aW9uID0gYmFzZVRleHR1cmUucmVzb2x1dGlvbiwgc291cmNlRnJhbWUgfHwgKHRlbXBSZWN0LndpZHRoID0gcmVuZGVyVGV4dHVyZS5mcmFtZS53aWR0aCwgdGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyVGV4dHVyZS5mcmFtZS5oZWlnaHQsIHNvdXJjZUZyYW1lID0gdGVtcFJlY3QpLCBkZXN0aW5hdGlvbkZyYW1lIHx8ICh0ZW1wUmVjdDIueCA9IHJlbmRlclRleHR1cmUuZnJhbWUueCwgdGVtcFJlY3QyLnkgPSByZW5kZXJUZXh0dXJlLmZyYW1lLnksIHRlbXBSZWN0Mi53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoLCB0ZW1wUmVjdDIuaGVpZ2h0ID0gc291cmNlRnJhbWUuaGVpZ2h0LCBkZXN0aW5hdGlvbkZyYW1lID0gdGVtcFJlY3QyKSwgZnJhbWVidWZmZXIgPSBiYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlcikgOiAocmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb24sIHNvdXJjZUZyYW1lIHx8ICh0ZW1wUmVjdC53aWR0aCA9IHJlbmRlcmVyLl92aWV3LnNjcmVlbi53aWR0aCwgdGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyZXIuX3ZpZXcuc2NyZWVuLmhlaWdodCwgc291cmNlRnJhbWUgPSB0ZW1wUmVjdCksIGRlc3RpbmF0aW9uRnJhbWUgfHwgKGRlc3RpbmF0aW9uRnJhbWUgPSB0ZW1wUmVjdCwgZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoLCBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHNvdXJjZUZyYW1lLmhlaWdodCkpO1xuICAgIGNvbnN0IHZpZXdwb3J0RnJhbWUgPSB0aGlzLnZpZXdwb3J0RnJhbWU7XG4gICAgdmlld3BvcnRGcmFtZS54ID0gZGVzdGluYXRpb25GcmFtZS54ICogcmVzb2x1dGlvbiwgdmlld3BvcnRGcmFtZS55ID0gZGVzdGluYXRpb25GcmFtZS55ICogcmVzb2x1dGlvbiwgdmlld3BvcnRGcmFtZS53aWR0aCA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiByZXNvbHV0aW9uLCB2aWV3cG9ydEZyYW1lLmhlaWdodCA9IGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbiwgcmVuZGVyVGV4dHVyZSB8fCAodmlld3BvcnRGcmFtZS55ID0gcmVuZGVyZXIudmlldy5oZWlnaHQgLSAodmlld3BvcnRGcmFtZS55ICsgdmlld3BvcnRGcmFtZS5oZWlnaHQpKSwgdmlld3BvcnRGcmFtZS5jZWlsKCksIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChmcmFtZWJ1ZmZlciwgdmlld3BvcnRGcmFtZSksIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi51cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sICFmcmFtZWJ1ZmZlciksIHJlbmRlclRleHR1cmUgPyB0aGlzLnJlbmRlcmVyLm1hc2suc2V0TWFza1N0YWNrKGJhc2VUZXh0dXJlLm1hc2tTdGFjaykgOiB0aGlzLnJlbmRlcmVyLm1hc2suc2V0TWFza1N0YWNrKHRoaXMuZGVmYXVsdE1hc2tTdGFjayksIHRoaXMuc291cmNlRnJhbWUuY29weUZyb20oc291cmNlRnJhbWUpLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuY29weUZyb20oZGVzdGluYXRpb25GcmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEVyYXNlcyB0aGUgcmVuZGVyIHRleHR1cmUgYW5kIGZpbGxzIHRoZSBkcmF3aW5nIGFyZWEgd2l0aCBhIGNvbG91ci5cbiAgICogQHBhcmFtIGNsZWFyQ29sb3IgLSBUaGUgY29sb3IgYXMgcmdiYSwgZGVmYXVsdCB0byB1c2UgdGhlIHJlbmRlcmVyIGJhY2tncm91bmRDb2xvclxuICAgKiBAcGFyYW0gW21hc2s9QlVGRkVSX0JJVFMuQ09MT1IgfCBCVUZGRVJfQklUUy5ERVBUSF0gLSBCaXR3aXNlIE9SIG9mIG1hc2tzXG4gICAqICB0aGF0IGluZGljYXRlIHRoZSBidWZmZXJzIHRvIGJlIGNsZWFyZWQsIGJ5IGRlZmF1bHQgQ09MT1IgYW5kIERFUFRIIGJ1ZmZlcnMuXG4gICAqL1xuICBjbGVhcihjbGVhckNvbG9yLCBtYXNrKSB7XG4gICAgY29uc3QgZmFsbGJhY2tDb2xvciA9IHRoaXMuY3VycmVudCA/IHRoaXMuY3VycmVudC5iYXNlVGV4dHVyZS5jbGVhciA6IHRoaXMucmVuZGVyZXIuYmFja2dyb3VuZC5iYWNrZ3JvdW5kQ29sb3IsIGNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNsZWFyQ29sb3IgfHwgZmFsbGJhY2tDb2xvcik7XG4gICAgKHRoaXMuY3VycmVudCAmJiB0aGlzLmN1cnJlbnQuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCB8fCAhdGhpcy5jdXJyZW50ICYmIHRoaXMuX3JlbmRlcmVyUHJlbXVsdGlwbGllZEFscGhhKSAmJiBjb2xvci5wcmVtdWx0aXBseShjb2xvci5hbHBoYSk7XG4gICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMuZGVzdGluYXRpb25GcmFtZSwgYmFzZUZyYW1lID0gdGhpcy5jdXJyZW50ID8gdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlIDogdGhpcy5yZW5kZXJlci5fdmlldy5zY3JlZW4sIGNsZWFyTWFzayA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggIT09IGJhc2VGcmFtZS53aWR0aCB8fCBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAhPT0gYmFzZUZyYW1lLmhlaWdodDtcbiAgICBpZiAoY2xlYXJNYXNrKSB7XG4gICAgICBsZXQgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnZpZXdwb3J0RnJhbWU7XG4gICAgICB4ID0gTWF0aC5yb3VuZCh4KSwgeSA9IE1hdGgucm91bmQoeSksIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCksIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KSwgdGhpcy5yZW5kZXJlci5nbC5lbmFibGUodGhpcy5yZW5kZXJlci5nbC5TQ0lTU09SX1RFU1QpLCB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoY29sb3IucmVkLCBjb2xvci5ncmVlbiwgY29sb3IuYmx1ZSwgY29sb3IuYWxwaGEsIG1hc2spLCBjbGVhck1hc2sgJiYgdGhpcy5yZW5kZXJlci5zY2lzc29yLnBvcCgpO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLmJpbmQobnVsbCk7XG4gIH1cbiAgLyoqIFJlc2V0cyByZW5kZXItdGV4dHVyZSBzdGF0ZS4gKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5iaW5kKG51bGwpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cblJlbmRlclRleHR1cmVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInJlbmRlclRleHR1cmVcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFJlbmRlclRleHR1cmVTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgUmVuZGVyVGV4dHVyZVN5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRleHR1cmVTeXN0ZW0ubWpzLm1hcFxuIiwiY2xhc3MgSUdMVW5pZm9ybURhdGEge1xufVxuY2xhc3MgR0xQcm9ncmFtIHtcbiAgLyoqXG4gICAqIE1ha2VzIGEgbmV3IFBpeGkgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHByb2dyYW0gLSB3ZWJnbCBwcm9ncmFtXG4gICAqIEBwYXJhbSB1bmlmb3JtRGF0YSAtIHVuaWZvcm1zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3JtRGF0YSkge1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW0sIHRoaXMudW5pZm9ybURhdGEgPSB1bmlmb3JtRGF0YSwgdGhpcy51bmlmb3JtR3JvdXBzID0ge30sIHRoaXMudW5pZm9ybURpcnR5R3JvdXBzID0ge30sIHRoaXMudW5pZm9ybUJ1ZmZlckJpbmRpbmdzID0ge307XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgcHJvZ3JhbS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gbnVsbCwgdGhpcy51bmlmb3JtR3JvdXBzID0gbnVsbCwgdGhpcy51bmlmb3JtRGlydHlHcm91cHMgPSBudWxsLCB0aGlzLnVuaWZvcm1CdWZmZXJCaW5kaW5ncyA9IG51bGwsIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEdMUHJvZ3JhbSxcbiAgSUdMVW5pZm9ybURhdGFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFByb2dyYW0ubWpzLm1hcFxuIiwiZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc3JjKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgcmV0dXJuIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyksIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKSwgc2hhZGVyO1xufVxuZXhwb3J0IHtcbiAgY29tcGlsZVNoYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVTaGFkZXIubWpzLm1hcFxuIiwiZnVuY3Rpb24gYm9vbGVhbkFycmF5KHNpemUpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgYXJyYXlbaV0gPSAhMTtcbiAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHR5cGUsIHNpemUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwidmVjMlwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJ2ZWMzXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcInZlYzRcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwiaW50XCI6XG4gICAgY2FzZSBcInVpbnRcIjpcbiAgICBjYXNlIFwic2FtcGxlcjJEXCI6XG4gICAgY2FzZSBcInNhbXBsZXIyREFycmF5XCI6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwiaXZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgyICogc2l6ZSk7XG4gICAgY2FzZSBcIml2ZWMzXCI6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJpdmVjNFwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwidXZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJ1dmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcInV2ZWM0XCI6XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuICExO1xuICAgIGNhc2UgXCJidmVjMlwiOlxuICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSgyICogc2l6ZSk7XG4gICAgY2FzZSBcImJ2ZWMzXCI6XG4gICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwiYnZlYzRcIjpcbiAgICAgIHJldHVybiBib29sZWFuQXJyYXkoNCAqIHNpemUpO1xuICAgIGNhc2UgXCJtYXQyXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJtYXQzXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJtYXQ0XCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZXhwb3J0IHtcbiAgZGVmYXVsdFZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdFZhbHVlLm1qcy5tYXBcbiIsImltcG9ydCB7IG1hcFNpemUgfSBmcm9tIFwiLi9tYXBTaXplLm1qc1wiO1xuaW1wb3J0IHsgbWFwVHlwZSB9IGZyb20gXCIuL21hcFR5cGUubWpzXCI7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVEYXRhKHByb2dyYW0sIGdsKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fSwgdG90YWxBdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxBdHRyaWJ1dGVzOyBpKyspIHtcbiAgICBjb25zdCBhdHRyaWJEYXRhID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xuICAgIGlmIChhdHRyaWJEYXRhLm5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHR5cGUgPSBtYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpLCBkYXRhID0ge1xuICAgICAgdHlwZSxcbiAgICAgIG5hbWU6IGF0dHJpYkRhdGEubmFtZSxcbiAgICAgIHNpemU6IG1hcFNpemUodHlwZSksXG4gICAgICBsb2NhdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliRGF0YS5uYW1lKVxuICAgIH07XG4gICAgYXR0cmlidXRlc1thdHRyaWJEYXRhLm5hbWVdID0gZGF0YTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmV4cG9ydCB7XG4gIGdldEF0dHJpYnV0ZURhdGFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRBdHRyaWJ1dGVEYXRhLm1qcy5tYXBcbiIsImltcG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5tanNcIjtcbmltcG9ydCB7IG1hcFR5cGUgfSBmcm9tIFwiLi9tYXBUeXBlLm1qc1wiO1xuZnVuY3Rpb24gZ2V0VW5pZm9ybURhdGEocHJvZ3JhbSwgZ2wpIHtcbiAgY29uc3QgdW5pZm9ybXMgPSB7fSwgdG90YWxVbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFVuaWZvcm1zOyBpKyspIHtcbiAgICBjb25zdCB1bmlmb3JtRGF0YSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSksIG5hbWUgPSB1bmlmb3JtRGF0YS5uYW1lLnJlcGxhY2UoL1xcWy4qP1xcXSQvLCBcIlwiKSwgaXNBcnJheSA9ICEhdW5pZm9ybURhdGEubmFtZS5tYXRjaCgvXFxbLio/XFxdJC8pLCB0eXBlID0gbWFwVHlwZShnbCwgdW5pZm9ybURhdGEudHlwZSk7XG4gICAgdW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB0eXBlLFxuICAgICAgc2l6ZTogdW5pZm9ybURhdGEuc2l6ZSxcbiAgICAgIGlzQXJyYXksXG4gICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlKHR5cGUsIHVuaWZvcm1EYXRhLnNpemUpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXM7XG59XG5leHBvcnQge1xuICBnZXRVbmlmb3JtRGF0YVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFVuaWZvcm1EYXRhLm1qcy5tYXBcbiIsImZ1bmN0aW9uIGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCBzaGFkZXIpIHtcbiAgY29uc3Qgc2hhZGVyU3JjID0gZ2wuZ2V0U2hhZGVyU291cmNlKHNoYWRlcikuc3BsaXQoYFxuYCkubWFwKChsaW5lLCBpbmRleCkgPT4gYCR7aW5kZXh9OiAke2xpbmV9YCksIHNoYWRlckxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSwgc3BsaXRTaGFkZXIgPSBzaGFkZXJMb2cuc3BsaXQoYFxuYCksIGRlZHVwZSA9IHt9LCBsaW5lTnVtYmVycyA9IHNwbGl0U2hhZGVyLm1hcCgobGluZSkgPT4gcGFyc2VGbG9hdChsaW5lLnJlcGxhY2UoL15FUlJPUlxcOiAwXFw6KFtcXGRdKylcXDouKiQvLCBcIiQxXCIpKSkuZmlsdGVyKChuKSA9PiBuICYmICFkZWR1cGVbbl0gPyAoZGVkdXBlW25dID0gITAsICEwKSA6ICExKSwgbG9nQXJncyA9IFtcIlwiXTtcbiAgbGluZU51bWJlcnMuZm9yRWFjaCgobnVtYmVyKSA9PiB7XG4gICAgc2hhZGVyU3JjW251bWJlciAtIDFdID0gYCVjJHtzaGFkZXJTcmNbbnVtYmVyIC0gMV19JWNgLCBsb2dBcmdzLnB1c2goXCJiYWNrZ3JvdW5kOiAjRkYwMDAwOyBjb2xvcjojRkZGRkZGOyBmb250LXNpemU6IDEwcHhcIiwgXCJmb250LXNpemU6IDEwcHhcIik7XG4gIH0pO1xuICBjb25zdCBmcmFnbWVudFNvdXJjZVRvTG9nID0gc2hhZGVyU3JjLmpvaW4oYFxuYCk7XG4gIGxvZ0FyZ3NbMF0gPSBmcmFnbWVudFNvdXJjZVRvTG9nLCBjb25zb2xlLmVycm9yKHNoYWRlckxvZyksIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJjbGljayB0byB2aWV3IGZ1bGwgc2hhZGVyIGNvZGVcIiksIGNvbnNvbGUud2FybiguLi5sb2dBcmdzKSwgY29uc29sZS5ncm91cEVuZCgpO1xufVxuZnVuY3Rpb24gbG9nUHJvZ3JhbUVycm9yKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpIHx8IChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgfHwgbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHZlcnRleFNoYWRlciksIGdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpIHx8IGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCBmcmFnbWVudFNoYWRlciksIGNvbnNvbGUuZXJyb3IoXCJQaXhpSlMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci5cIiksIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSBcIlwiICYmIGNvbnNvbGUud2FybihcIlBpeGlKUyBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpXCIsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKSk7XG59XG5leHBvcnQge1xuICBsb2dQcm9ncmFtRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dQcm9ncmFtRXJyb3IubWpzLm1hcFxuIiwiaW1wb3J0IHsgR0xQcm9ncmFtIH0gZnJvbSBcIi4uL0dMUHJvZ3JhbS5tanNcIjtcbmltcG9ydCB7IGNvbXBpbGVTaGFkZXIgfSBmcm9tIFwiLi9jb21waWxlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFZhbHVlIH0gZnJvbSBcIi4vZGVmYXVsdFZhbHVlLm1qc1wiO1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlRGF0YSB9IGZyb20gXCIuL2dldEF0dHJpYnV0ZURhdGEubWpzXCI7XG5pbXBvcnQgeyBnZXRVbmlmb3JtRGF0YSB9IGZyb20gXCIuL2dldFVuaWZvcm1EYXRhLm1qc1wiO1xuaW1wb3J0IHsgbG9nUHJvZ3JhbUVycm9yIH0gZnJvbSBcIi4vbG9nUHJvZ3JhbUVycm9yLm1qc1wiO1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIGNvbnN0IGdsVmVydFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHByb2dyYW0udmVydGV4U3JjKSwgZ2xGcmFnU2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBwcm9ncmFtLmZyYWdtZW50U3JjKSwgd2ViR0xQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBnbC5hdHRhY2hTaGFkZXIod2ViR0xQcm9ncmFtLCBnbFZlcnRTaGFkZXIpLCBnbC5hdHRhY2hTaGFkZXIod2ViR0xQcm9ncmFtLCBnbEZyYWdTaGFkZXIpO1xuICBjb25zdCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzID0gcHJvZ3JhbS5leHRyYT8udHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgJiYgKHR5cGVvZiBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzICE9IFwiZnVuY3Rpb25cIiA/IGNvbnNvbGUud2FybihcIlRyYW5zZm9ybUZlZWRiYWNrIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IFRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgYXJlIGdpdmVuLlwiKSA6IGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MoXG4gICAgd2ViR0xQcm9ncmFtLFxuICAgIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MubmFtZXMsXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncy5idWZmZXJNb2RlID09PSBcInNlcGFyYXRlXCIgPyBnbC5TRVBBUkFURV9BVFRSSUJTIDogZ2wuSU5URVJMRUFWRURfQVRUUklCU1xuICApKSwgZ2wubGlua1Byb2dyYW0od2ViR0xQcm9ncmFtKSwgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih3ZWJHTFByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSB8fCBsb2dQcm9ncmFtRXJyb3IoZ2wsIHdlYkdMUHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyLCBnbEZyYWdTaGFkZXIpLCBwcm9ncmFtLmF0dHJpYnV0ZURhdGEgPSBnZXRBdHRyaWJ1dGVEYXRhKHdlYkdMUHJvZ3JhbSwgZ2wpLCBwcm9ncmFtLnVuaWZvcm1EYXRhID0gZ2V0VW5pZm9ybURhdGEod2ViR0xQcm9ncmFtLCBnbCksICEvXlsgXFx0XSojWyBcXHRdKnZlcnNpb25bIFxcdF0rMzAwWyBcXHRdK2VzWyBcXHRdKiQvbS50ZXN0KHByb2dyYW0udmVydGV4U3JjKSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9ncmFtLmF0dHJpYnV0ZURhdGEpO1xuICAgIGtleXMuc29ydCgoYSwgYikgPT4gYSA+IGIgPyAxIDogLTEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgIHByb2dyYW0uYXR0cmlidXRlRGF0YVtrZXlzW2ldXS5sb2NhdGlvbiA9IGksIGdsLmJpbmRBdHRyaWJMb2NhdGlvbih3ZWJHTFByb2dyYW0sIGksIGtleXNbaV0pO1xuICAgIGdsLmxpbmtQcm9ncmFtKHdlYkdMUHJvZ3JhbSk7XG4gIH1cbiAgZ2wuZGVsZXRlU2hhZGVyKGdsVmVydFNoYWRlciksIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xuICBjb25zdCB1bmlmb3JtRGF0YSA9IHt9O1xuICBmb3IgKGNvbnN0IGkgaW4gcHJvZ3JhbS51bmlmb3JtRGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBwcm9ncmFtLnVuaWZvcm1EYXRhW2ldO1xuICAgIHVuaWZvcm1EYXRhW2ldID0ge1xuICAgICAgbG9jYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIGkpLFxuICAgICAgdmFsdWU6IGRlZmF1bHRWYWx1ZShkYXRhLnR5cGUsIGRhdGEuc2l6ZSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBuZXcgR0xQcm9ncmFtKHdlYkdMUHJvZ3JhbSwgdW5pZm9ybURhdGEpO1xufVxuZXhwb3J0IHtcbiAgZ2VuZXJhdGVQcm9ncmFtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVQcm9ncmFtLm1qcy5tYXBcbiIsImltcG9ydCBcIi4vaW5kZXgubWpzXCI7XG5pbXBvcnQgeyB1bmlmb3JtUGFyc2VycyB9IGZyb20gXCIuL3VuaWZvcm1QYXJzZXJzLm1qc1wiO1xuaW1wb3J0IHsgbWFwU2l6ZSB9IGZyb20gXCIuL21hcFNpemUubWpzXCI7XG5mdW5jdGlvbiB1Ym9VcGRhdGUoX3VkLCBfdXYsIF9yZW5kZXJlciwgX3N5bmNEYXRhLCBidWZmZXIpIHtcbiAgX3JlbmRlcmVyLmJ1ZmZlci51cGRhdGUoYnVmZmVyKTtcbn1cbmNvbnN0IFVCT19UT19TSU5HTEVfU0VUVEVSUyA9IHtcbiAgZmxvYXQ6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdjtcbiAgICBgLFxuICB2ZWMyOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICBgLFxuICB2ZWMzOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2WzJdO1xuXG4gICAgYCxcbiAgdmVjNDogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrM10gPSB2WzNdO1xuICAgIGAsXG4gIG1hdDI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0KzRdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrNV0gPSB2WzNdO1xuICAgIGAsXG4gIG1hdDM6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCsyXSA9IHZbMl07XG5cbiAgICAgICAgZGF0YVtvZmZzZXQgKyA0XSA9IHZbM107XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNV0gPSB2WzRdO1xuICAgICAgICBkYXRhW29mZnNldCArIDZdID0gdls1XTtcblxuICAgICAgICBkYXRhW29mZnNldCArIDhdID0gdls2XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA9IHZbN107XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMTBdID0gdls4XTtcbiAgICBgLFxuICBtYXQ0OiBgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIGldID0gdltpXTtcbiAgICAgICAgfVxuICAgIGBcbn0sIEdMU0xfVE9fU1RENDBfU0laRSA9IHtcbiAgZmxvYXQ6IDQsXG4gIHZlYzI6IDgsXG4gIHZlYzM6IDEyLFxuICB2ZWM0OiAxNixcbiAgaW50OiA0LFxuICBpdmVjMjogOCxcbiAgaXZlYzM6IDEyLFxuICBpdmVjNDogMTYsXG4gIHVpbnQ6IDQsXG4gIHV2ZWMyOiA4LFxuICB1dmVjMzogMTIsXG4gIHV2ZWM0OiAxNixcbiAgYm9vbDogNCxcbiAgYnZlYzI6IDgsXG4gIGJ2ZWMzOiAxMixcbiAgYnZlYzQ6IDE2LFxuICBtYXQyOiAxNiAqIDIsXG4gIG1hdDM6IDE2ICogMyxcbiAgbWF0NDogMTYgKiA0XG59O1xuZnVuY3Rpb24gY3JlYXRlVUJPRWxlbWVudHModW5pZm9ybURhdGEpIHtcbiAgY29uc3QgdWJvRWxlbWVudHMgPSB1bmlmb3JtRGF0YS5tYXAoKGRhdGEpID0+ICh7XG4gICAgZGF0YSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgZGF0YUxlbjogMCxcbiAgICBkaXJ0eTogMFxuICB9KSk7XG4gIGxldCBzaXplID0gMCwgY2h1bmtTaXplID0gMCwgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1Ym9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHVib0VsZW1lbnQgPSB1Ym9FbGVtZW50c1tpXTtcbiAgICBpZiAoc2l6ZSA9IEdMU0xfVE9fU1RENDBfU0laRVt1Ym9FbGVtZW50LmRhdGEudHlwZV0sIHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSAmJiAoc2l6ZSA9IE1hdGgubWF4KHNpemUsIDE2KSAqIHVib0VsZW1lbnQuZGF0YS5zaXplKSwgdWJvRWxlbWVudC5kYXRhTGVuID0gc2l6ZSwgY2h1bmtTaXplICUgc2l6ZSAhPT0gMCAmJiBjaHVua1NpemUgPCAxNikge1xuICAgICAgY29uc3QgbGluZVVwVmFsdWUgPSBjaHVua1NpemUgJSBzaXplICUgMTY7XG4gICAgICBjaHVua1NpemUgKz0gbGluZVVwVmFsdWUsIG9mZnNldCArPSBsaW5lVXBWYWx1ZTtcbiAgICB9XG4gICAgY2h1bmtTaXplICsgc2l6ZSA+IDE2ID8gKG9mZnNldCA9IE1hdGguY2VpbChvZmZzZXQgLyAxNikgKiAxNiwgdWJvRWxlbWVudC5vZmZzZXQgPSBvZmZzZXQsIG9mZnNldCArPSBzaXplLCBjaHVua1NpemUgPSBzaXplKSA6ICh1Ym9FbGVtZW50Lm9mZnNldCA9IG9mZnNldCwgY2h1bmtTaXplICs9IHNpemUsIG9mZnNldCArPSBzaXplKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2LCB7IHVib0VsZW1lbnRzLCBzaXplOiBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGdldFVCT0RhdGEodW5pZm9ybXMsIHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IHVzZWRVbmlmb3JtRGF0YXMgPSBbXTtcbiAgZm9yIChjb25zdCBpIGluIHVuaWZvcm1zKVxuICAgIHVuaWZvcm1EYXRhW2ldICYmIHVzZWRVbmlmb3JtRGF0YXMucHVzaCh1bmlmb3JtRGF0YVtpXSk7XG4gIHJldHVybiB1c2VkVW5pZm9ybURhdGFzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KSwgdXNlZFVuaWZvcm1EYXRhcztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XG4gIGlmICghZ3JvdXAuYXV0b01hbmFnZSlcbiAgICByZXR1cm4geyBzaXplOiAwLCBzeW5jRnVuYzogdWJvVXBkYXRlIH07XG4gIGNvbnN0IHVzZWRVbmlmb3JtRGF0YXMgPSBnZXRVQk9EYXRhKGdyb3VwLnVuaWZvcm1zLCB1bmlmb3JtRGF0YSksIHsgdWJvRWxlbWVudHMsIHNpemUgfSA9IGNyZWF0ZVVCT0VsZW1lbnRzKHVzZWRVbmlmb3JtRGF0YXMpLCBmdW5jRnJhZ21lbnRzID0gW2BcbiAgICB2YXIgdiA9IG51bGw7XG4gICAgdmFyIHYyID0gbnVsbDtcbiAgICB2YXIgY3YgPSBudWxsO1xuICAgIHZhciB0ID0gMDtcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5nbFxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGRhdGEgPSBidWZmZXIuZGF0YTtcbiAgICBgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1Ym9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHVib0VsZW1lbnQgPSB1Ym9FbGVtZW50c1tpXSwgdW5pZm9ybSA9IGdyb3VwLnVuaWZvcm1zW3Vib0VsZW1lbnQuZGF0YS5uYW1lXSwgbmFtZSA9IHVib0VsZW1lbnQuZGF0YS5uYW1lO1xuICAgIGxldCBwYXJzZWQgPSAhMTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaWZvcm1QYXJzZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCB1bmlmb3JtUGFyc2VyID0gdW5pZm9ybVBhcnNlcnNbal07XG4gICAgICBpZiAodW5pZm9ybVBhcnNlci5jb2RlVWJvICYmIHVuaWZvcm1QYXJzZXIudGVzdCh1Ym9FbGVtZW50LmRhdGEsIHVuaWZvcm0pKSB7XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChcbiAgICAgICAgICBgb2Zmc2V0ID0gJHt1Ym9FbGVtZW50Lm9mZnNldCAvIDR9O2AsXG4gICAgICAgICAgdW5pZm9ybVBhcnNlcnNbal0uY29kZVVibyh1Ym9FbGVtZW50LmRhdGEubmFtZSwgdW5pZm9ybSlcbiAgICAgICAgKSwgcGFyc2VkID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcnNlZClcbiAgICAgIGlmICh1Ym9FbGVtZW50LmRhdGEuc2l6ZSA+IDEpIHtcbiAgICAgICAgY29uc3Qgc2l6ZTIgPSBtYXBTaXplKHVib0VsZW1lbnQuZGF0YS50eXBlKSwgcm93U2l6ZSA9IE1hdGgubWF4KEdMU0xfVE9fU1RENDBfU0laRVt1Ym9FbGVtZW50LmRhdGEudHlwZV0gLyAxNiwgMSksIGVsZW1lbnRTaXplID0gc2l6ZTIgLyByb3dTaXplLCByZW1haW5kZXIgPSAoNCAtIGVsZW1lbnRTaXplICUgNCkgJSA0O1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgIGN2ID0gdWQuJHtuYW1lfS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAke3Vib0VsZW1lbnQub2Zmc2V0IC8gNH07XG5cbiAgICAgICAgICAgICAgICB0ID0gMDtcblxuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIDwgJHt1Ym9FbGVtZW50LmRhdGEuc2l6ZSAqIHJvd1NpemV9OyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgJHtlbGVtZW50U2l6ZX07IGorKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrK10gPSB2W3QrK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9ICR7cmVtYWluZGVyfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gVUJPX1RPX1NJTkdMRV9TRVRURVJTW3Vib0VsZW1lbnQuZGF0YS50eXBlXTtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkLiR7bmFtZX0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJHt1Ym9FbGVtZW50Lm9mZnNldCAvIDR9O1xuICAgICAgICAgICAgICAgICR7dGVtcGxhdGV9O1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgIHJlbmRlcmVyLmJ1ZmZlci51cGRhdGUoYnVmZmVyKTtcbiAgICBgKSwge1xuICAgIHNpemUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgc3luY0Z1bmM6IG5ldyBGdW5jdGlvbihcbiAgICAgIFwidWRcIixcbiAgICAgIFwidXZcIixcbiAgICAgIFwicmVuZGVyZXJcIixcbiAgICAgIFwic3luY0RhdGFcIixcbiAgICAgIFwiYnVmZmVyXCIsXG4gICAgICBmdW5jRnJhZ21lbnRzLmpvaW4oYFxuYClcbiAgICApXG4gIH07XG59XG5leHBvcnQge1xuICBjcmVhdGVVQk9FbGVtZW50cyxcbiAgZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyxcbiAgZ2V0VUJPRGF0YVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMubWpzLm1hcFxuIiwibGV0IHVuc2FmZUV2YWw7XG5mdW5jdGlvbiB1bnNhZmVFdmFsU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHVuc2FmZUV2YWwgPT0gXCJib29sZWFuXCIpXG4gICAgcmV0dXJuIHVuc2FmZUV2YWw7XG4gIHRyeSB7XG4gICAgdW5zYWZlRXZhbCA9IG5ldyBGdW5jdGlvbihcInBhcmFtMVwiLCBcInBhcmFtMlwiLCBcInBhcmFtM1wiLCBcInJldHVybiBwYXJhbTFbcGFyYW0yXSA9PT0gcGFyYW0zO1wiKSh7IGE6IFwiYlwiIH0sIFwiYVwiLCBcImJcIikgPT09ICEwO1xuICB9IGNhdGNoIHtcbiAgICB1bnNhZmVFdmFsID0gITE7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZUV2YWw7XG59XG5leHBvcnQge1xuICB1bnNhZmVFdmFsU3VwcG9ydGVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5zYWZlRXZhbFN1cHBvcnRlZC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmltcG9ydCBcIi4vdXRpbHMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVByb2dyYW0gfSBmcm9tIFwiLi91dGlscy9nZW5lcmF0ZVByb2dyYW0ubWpzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jIH0gZnJvbSBcIi4vdXRpbHMvZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5tanNcIjtcbmltcG9ydCB7IHVuc2FmZUV2YWxTdXBwb3J0ZWQgfSBmcm9tIFwiLi91dGlscy91bnNhZmVFdmFsU3VwcG9ydGVkLm1qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVVbmlmb3Jtc1N5bmMgfSBmcm9tIFwiLi91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanNcIjtcbmxldCBVSUQgPSAwO1xuY29uc3QgZGVmYXVsdFN5bmNEYXRhID0geyB0ZXh0dXJlQ291bnQ6IDAsIHVib0NvdW50OiAwIH07XG5jbGFzcyBTaGFkZXJTeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9ICExLCB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuc3lzdGVtQ2hlY2soKSwgdGhpcy5nbCA9IG51bGwsIHRoaXMuc2hhZGVyID0gbnVsbCwgdGhpcy5wcm9ncmFtID0gbnVsbCwgdGhpcy5jYWNoZSA9IHt9LCB0aGlzLl91Ym9DYWNoZSA9IHt9LCB0aGlzLmlkID0gVUlEKys7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlYWJsZSBmdW5jdGlvbiBieSBgQHBpeGkvdW5zYWZlLWV2YWxgIHRvIHNpbGVuY2VcbiAgICogdGhyb3dpbmcgYW4gZXJyb3IgaWYgcGxhdGZvcm0gZG9lc24ndCBzdXBwb3J0IHVuc2FmZS1ldmFscy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN5c3RlbUNoZWNrKCkge1xuICAgIGlmICghdW5zYWZlRXZhbFN1cHBvcnRlZCgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBhbGxvdyB1bnNhZmUtZXZhbCwgcGxlYXNlIHVzZSBAcGl4aS91bnNhZmUtZXZhbCBtb2R1bGUgdG8gZW5hYmxlIHN1cHBvcnQuXCIpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2wsIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzaGFkZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSBzaGFkZXIgLSB0aGUgbmV3IHNoYWRlclxuICAgKiBAcGFyYW0gZG9udFN5bmMgLSBmYWxzZSBpZiB0aGUgc2hhZGVyIHNob3VsZCBhdXRvbWF0aWNhbGx5IHN5bmMgaXRzIHVuaWZvcm1zLlxuICAgKiBAcmV0dXJucyB0aGUgZ2xQcm9ncmFtIHRoYXQgYmVsb25ncyB0byB0aGUgc2hhZGVyLlxuICAgKi9cbiAgYmluZChzaGFkZXIsIGRvbnRTeW5jKSB7XG4gICAgc2hhZGVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpLCBzaGFkZXIudW5pZm9ybXMuZ2xvYmFscyA9IHRoaXMucmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXM7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtLCBnbFByb2dyYW0gPSBwcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0gfHwgdGhpcy5nZW5lcmF0ZVByb2dyYW0oc2hhZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIgPSBzaGFkZXIsIHRoaXMucHJvZ3JhbSAhPT0gcHJvZ3JhbSAmJiAodGhpcy5wcm9ncmFtID0gcHJvZ3JhbSwgdGhpcy5nbC51c2VQcm9ncmFtKGdsUHJvZ3JhbS5wcm9ncmFtKSksIGRvbnRTeW5jIHx8IChkZWZhdWx0U3luY0RhdGEudGV4dHVyZUNvdW50ID0gMCwgZGVmYXVsdFN5bmNEYXRhLnVib0NvdW50ID0gMCwgdGhpcy5zeW5jVW5pZm9ybUdyb3VwKHNoYWRlci51bmlmb3JtR3JvdXAsIGRlZmF1bHRTeW5jRGF0YSkpLCBnbFByb2dyYW07XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIHVuaWZvcm1zIHZhbHVlcyB0byB0aGUgY3VycmVudGx5IGJvdW5kIHNoYWRlci5cbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gdGhlIHVuaWZvcm1zIHZhbHVlcyB0aGF0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2hhZGVyXG4gICAqL1xuICBzZXRVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyLnByb2dyYW0sIGdsUHJvZ3JhbSA9IHNoYWRlci5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCB1bmlmb3JtcywgdGhpcy5yZW5kZXJlcik7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlcyAqL1xuICAvKipcbiAgICogU3luY3MgdW5pZm9ybXMgb24gdGhlIGdyb3VwXG4gICAqIEBwYXJhbSBncm91cCAtIHRoZSB1bmlmb3JtIGdyb3VwIHRvIHN5bmNcbiAgICogQHBhcmFtIHN5bmNEYXRhIC0gdGhpcyBpcyBkYXRhIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBzeW5jIGZ1bmN0aW9uIGFuZCBhbnkgbmVzdGVkIHN5bmMgZnVuY3Rpb25zXG4gICAqL1xuICBzeW5jVW5pZm9ybUdyb3VwKGdyb3VwLCBzeW5jRGF0YSkge1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHRoaXMuZ2V0R2xQcm9ncmFtKCk7XG4gICAgKCFncm91cC5zdGF0aWMgfHwgZ3JvdXAuZGlydHlJZCAhPT0gZ2xQcm9ncmFtLnVuaWZvcm1EaXJ0eUdyb3Vwc1tncm91cC5pZF0pICYmIChnbFByb2dyYW0udW5pZm9ybURpcnR5R3JvdXBzW2dyb3VwLmlkXSA9IGdyb3VwLmRpcnR5SWQsIHRoaXMuc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0sIHN5bmNEYXRhKSk7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlYWJsZSBieSB0aGUgQHBpeGkvdW5zYWZlLWV2YWwgcGFja2FnZSB0byB1c2Ugc3RhdGljIHN5bmNVbmlmb3JtcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHBhcmFtIGdsUHJvZ3JhbVxuICAgKiBAcGFyYW0gc3luY0RhdGFcbiAgICovXG4gIHN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtLCBzeW5jRGF0YSkge1xuICAgIChncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jR3JvdXBzKGdyb3VwKSkoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCBncm91cC51bmlmb3JtcywgdGhpcy5yZW5kZXJlciwgc3luY0RhdGEpO1xuICB9XG4gIGNyZWF0ZVN5bmNHcm91cHMoZ3JvdXApIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhLCBcInVcIik7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVbaWRdIHx8ICh0aGlzLmNhY2hlW2lkXSA9IGdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKSksIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXSA9IHRoaXMuY2FjaGVbaWRdLCBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF07XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNzIHVuaWZvcm0gYnVmZmVyc1xuICAgKiBAcGFyYW0gZ3JvdXAgLSB0aGUgdW5pZm9ybSBidWZmZXIgZ3JvdXAgdG8gc3luY1xuICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtIGJ1ZmZlclxuICAgKi9cbiAgc3luY1VuaWZvcm1CdWZmZXJHcm91cChncm91cCwgbmFtZSkge1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHRoaXMuZ2V0R2xQcm9ncmFtKCk7XG4gICAgaWYgKCFncm91cC5zdGF0aWMgfHwgZ3JvdXAuZGlydHlJZCAhPT0gMCB8fCAhZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdKSB7XG4gICAgICBncm91cC5kaXJ0eUlkID0gMDtcbiAgICAgIGNvbnN0IHN5bmNGdW5jID0gZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdIHx8IHRoaXMuY3JlYXRlU3luY0J1ZmZlckdyb3VwKGdyb3VwLCBnbFByb2dyYW0sIG5hbWUpO1xuICAgICAgZ3JvdXAuYnVmZmVyLnVwZGF0ZSgpLCBzeW5jRnVuYyhcbiAgICAgICAgZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLFxuICAgICAgICBncm91cC51bmlmb3JtcyxcbiAgICAgICAgdGhpcy5yZW5kZXJlcixcbiAgICAgICAgZGVmYXVsdFN5bmNEYXRhLFxuICAgICAgICBncm91cC5idWZmZXJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuYnVmZmVyLmJpbmRCdWZmZXJCYXNlKGdyb3VwLmJ1ZmZlciwgZ2xQcm9ncmFtLnVuaWZvcm1CdWZmZXJCaW5kaW5nc1tuYW1lXSk7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB1cGxvYWRzIGEgdW5pZm9ybSBidWZmZXIgdXNpbmcgdGhlIFNURDE0MCBzdGFuZGFyZC5cbiAgICogVGhlIHVwbG9hZCBmdW5jdGlvbiB3aWxsIHRoZW4gYmUgY2FjaGVkIGZvciBmdXR1cmUgY2FsbHNcbiAgICogSWYgYSBncm91cCBpcyBtYW51YWxseSBtYW5hZ2VkLCB0aGVuIGEgc2ltcGxlIHVwbG9hZCBmdW5jdGlvbiBpcyBnZW5lcmF0ZWRcbiAgICogQHBhcmFtIGdyb3VwIC0gdGhlIHVuaWZvcm0gYnVmZmVyIGdyb3VwIHRvIHN5bmNcbiAgICogQHBhcmFtIGdsUHJvZ3JhbSAtIHRoZSBnbCBwcm9ncmFtIHRvIGF0dGFjaCB0aGUgdW5pZm9ybSBiaW5kaW5ncyB0b1xuICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtIGJ1ZmZlciAobXVzdCBleGlzdCBvbiB0aGUgc2hhZGVyKVxuICAgKi9cbiAgY3JlYXRlU3luY0J1ZmZlckdyb3VwKGdyb3VwLCBnbFByb2dyYW0sIG5hbWUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIuYnVmZmVyLmJpbmQoZ3JvdXAuYnVmZmVyKTtcbiAgICBjb25zdCB1bmlmb3JtQmxvY2tJbmRleCA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgoZ2xQcm9ncmFtLnByb2dyYW0sIG5hbWUpO1xuICAgIGdsUHJvZ3JhbS51bmlmb3JtQnVmZmVyQmluZGluZ3NbbmFtZV0gPSB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50LCBnbC51bmlmb3JtQmxvY2tCaW5kaW5nKGdsUHJvZ3JhbS5wcm9ncmFtLCB1bmlmb3JtQmxvY2tJbmRleCwgdGhpcy5zaGFkZXIudW5pZm9ybUJpbmRDb3VudCksIHRoaXMuc2hhZGVyLnVuaWZvcm1CaW5kQ291bnQrKztcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhLCBcInVib1wiKTtcbiAgICBsZXQgdWJvRGF0YSA9IHRoaXMuX3Vib0NhY2hlW2lkXTtcbiAgICBpZiAodWJvRGF0YSB8fCAodWJvRGF0YSA9IHRoaXMuX3Vib0NhY2hlW2lkXSA9IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEpKSwgZ3JvdXAuYXV0b01hbmFnZSkge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodWJvRGF0YS5zaXplIC8gNCk7XG4gICAgICBncm91cC5idWZmZXIudXBkYXRlKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdID0gdWJvRGF0YS5zeW5jRnVuYywgZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdO1xuICB9XG4gIC8qKlxuICAgKiBUYWtlcyBhIHVuaWZvcm0gZ3JvdXAgYW5kIGRhdGEgYW5kIGdlbmVyYXRlcyBhIHVuaXF1ZSBzaWduYXR1cmUgZm9yIHRoZW0uXG4gICAqIEBwYXJhbSBncm91cCAtIFRoZSB1bmlmb3JtIGdyb3VwIHRvIGdldCBzaWduYXR1cmUgb2ZcbiAgICogQHBhcmFtIGdyb3VwLnVuaWZvcm1zXG4gICAqIEBwYXJhbSB1bmlmb3JtRGF0YSAtIFVuaWZvcm0gaW5mb3JtYXRpb24gZ2VuZXJhdGVkIGJ5IHRoZSBzaGFkZXJcbiAgICogQHBhcmFtIHByZUZpeFxuICAgKiBAcmV0dXJucyBVbmlxdWUgc2lnbmF0dXJlIG9mIHRoZSB1bmlmb3JtIGdyb3VwXG4gICAqL1xuICBnZXRTaWduYXR1cmUoZ3JvdXAsIHVuaWZvcm1EYXRhLCBwcmVGaXgpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IGdyb3VwLnVuaWZvcm1zLCBzdHJpbmdzID0gW2Ake3ByZUZpeH0tYF07XG4gICAgZm9yIChjb25zdCBpIGluIHVuaWZvcm1zKVxuICAgICAgc3RyaW5ncy5wdXNoKGkpLCB1bmlmb3JtRGF0YVtpXSAmJiBzdHJpbmdzLnB1c2godW5pZm9ybURhdGFbaV0udHlwZSk7XG4gICAgcmV0dXJuIHN0cmluZ3Muam9pbihcIi1cIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgR0xTaGFkZSByb2YgdGhlIGN1cnJlbnRseSBib3VuZCBzaGFkZXIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIGhhbmR5IGZvciB3aGVuIHlvdSB0byBoYXZlIGEgbGl0dGxlIG1vcmUgY29udHJvbCBvdmVyIHRoZSBzZXR0aW5nIG9mIHlvdXIgdW5pZm9ybXMuXG4gICAqIEByZXR1cm5zIFRoZSBnbFByb2dyYW0gZm9yIHRoZSBjdXJyZW50bHkgYm91bmQgU2hhZGVyIGZvciB0aGlzIGNvbnRleHRcbiAgICovXG4gIGdldEdsUHJvZ3JhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIgPyB0aGlzLnNoYWRlci5wcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0gOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBnbFByb2dyYW0gdmVyc2lvbiBvZiB0aGUgU2hhZGVyIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gc2hhZGVyIC0gVGhlIHNoYWRlciB0aGF0IHRoZSBnbFByb2dyYW0gd2lsbCBiZSBiYXNlZCBvbi5cbiAgICogQHJldHVybnMgQSBzaGlueSBuZXcgZ2xQcm9ncmFtIVxuICAgKi9cbiAgZ2VuZXJhdGVQcm9ncmFtKHNoYWRlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCwgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtLCBnbFByb2dyYW0gPSBnZW5lcmF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIHJldHVybiBwcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0gPSBnbFByb2dyYW0sIGdsUHJvZ3JhbTtcbiAgfVxuICAvKiogUmVzZXRzIFNoYWRlclN5c3RlbSBzdGF0ZSwgZG9lcyBub3QgYWZmZWN0IFdlYkdMIHN0YXRlLiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsLCB0aGlzLnNoYWRlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHNoYWRlci5cbiAgICogSWYgZGlzcG9zaW5nIG9uZSBlcXVhbHMgd2l0aCBjdXJyZW50IHNoYWRlciwgc2V0IGN1cnJlbnQgYXMgbnVsbC5cbiAgICogQHBhcmFtIHNoYWRlciAtIFNoYWRlciBvYmplY3RcbiAgICovXG4gIGRpc3Bvc2VTaGFkZXIoc2hhZGVyKSB7XG4gICAgdGhpcy5zaGFkZXIgPT09IHNoYWRlciAmJiAodGhpcy5zaGFkZXIgPSBudWxsKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyBTeXN0ZW0gYW5kIHJlbW92ZXMgYWxsIGl0cyB0ZXh0dXJlcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbCwgdGhpcy5kZXN0cm95ZWQgPSAhMDtcbiAgfVxufVxuU2hhZGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzaGFkZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFNoYWRlclN5c3RlbSk7XG5leHBvcnQge1xuICBTaGFkZXJTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFkZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5jbGFzcyBTdGFydHVwU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIEl0IGFsbCBzdGFydHMgaGVyZSEgVGhpcyBpbml0aWF0ZXMgZXZlcnkgc3lzdGVtLCBwYXNzaW5nIGluIHRoZSBvcHRpb25zIGZvciBhbnkgc3lzdGVtIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHJlbmRlcmVyIGFuZCBhbGwgaXRzIHN5c3RlbXNcbiAgICovXG4gIHJ1bihvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcztcbiAgICByZW5kZXJlci5ydW5uZXJzLmluaXQuZW1pdChyZW5kZXJlci5vcHRpb25zKSwgb3B0aW9ucy5oZWxsbyAmJiBjb25zb2xlLmxvZyhgUGl4aUpTIDcuMy4zIC0gJHtyZW5kZXJlci5yZW5kZXJlckxvZ0lkfSAtIGh0dHBzOi8vcGl4aWpzLmNvbWApLCByZW5kZXJlci5yZXNpemUocmVuZGVyZXIuc2NyZWVuLndpZHRoLCByZW5kZXJlci5zY3JlZW4uaGVpZ2h0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5TdGFydHVwU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5oZWxsb31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGhlbGxvOiAhMVxufSwgLyoqIEBpZ25vcmUgKi9cblN0YXJ0dXBTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic3RhcnR1cFwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoU3RhcnR1cFN5c3RlbSk7XG5leHBvcnQge1xuICBTdGFydHVwU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhcnR1cFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBCTEVORF9NT0RFUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmZ1bmN0aW9uIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCwgYXJyYXkgPSBbXSkge1xuICByZXR1cm4gYXJyYXlbQkxFTkRfTU9ERVMuTk9STUFMXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtCTEVORF9NT0RFUy5BRERdID0gW2dsLk9ORSwgZ2wuT05FXSwgYXJyYXlbQkxFTkRfTU9ERVMuTVVMVElQTFldID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuU0NSRUVOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLk9WRVJMQVldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuTElHSFRFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLkhBUkRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLlNPRlRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLkVYQ0xVU0lPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuSFVFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtCTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtCTEVORF9NT0RFUy5DT0xPUl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuTk9ORV0gPSBbMCwgMF0sIGFycmF5W0JMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuQUREX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FXSwgYXJyYXlbQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtCTEVORF9NT0RFUy5TUkNfSU5dID0gW2dsLkRTVF9BTFBIQSwgZ2wuWkVST10sIGFycmF5W0JMRU5EX01PREVTLlNSQ19PVVRdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLlpFUk9dLCBhcnJheVtCTEVORF9NT0RFUy5TUkNfQVRPUF0gPSBbZ2wuRFNUX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuRFNUX09WRVJdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORV0sIGFycmF5W0JMRU5EX01PREVTLkRTVF9JTl0gPSBbZ2wuWkVSTywgZ2wuU1JDX0FMUEhBXSwgYXJyYXlbQkxFTkRfTU9ERVMuRFNUX09VVF0gPSBbZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W0JMRU5EX01PREVTLkRTVF9BVE9QXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5TUkNfQUxQSEFdLCBhcnJheVtCTEVORF9NT0RFUy5YT1JdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtCTEVORF9NT0RFUy5TVUJUUkFDVF0gPSBbZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1QsIGdsLkZVTkNfQUREXSwgYXJyYXk7XG59XG5leHBvcnQge1xuICBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzLm1hcFxuIiwiaW1wb3J0IHsgQkxFTkRfTU9ERVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSBcIi4vU3RhdGUubWpzXCI7XG5pbXBvcnQgeyBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkgfSBmcm9tIFwiLi91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzXCI7XG5jb25zdCBCTEVORCA9IDAsIE9GRlNFVCA9IDEsIENVTExJTkcgPSAyLCBERVBUSF9URVNUID0gMywgV0lORElORyA9IDQsIERFUFRIX01BU0sgPSA1LCBfU3RhdGVTeXN0ZW0gPSBjbGFzcyBfU3RhdGVTeXN0ZW0yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nbCA9IG51bGwsIHRoaXMuc3RhdGVJZCA9IDAsIHRoaXMucG9seWdvbk9mZnNldCA9IDAsIHRoaXMuYmxlbmRNb2RlID0gQkxFTkRfTU9ERVMuTk9ORSwgdGhpcy5fYmxlbmRFcSA9ICExLCB0aGlzLm1hcCA9IFtdLCB0aGlzLm1hcFtCTEVORF0gPSB0aGlzLnNldEJsZW5kLCB0aGlzLm1hcFtPRkZTRVRdID0gdGhpcy5zZXRPZmZzZXQsIHRoaXMubWFwW0NVTExJTkddID0gdGhpcy5zZXRDdWxsRmFjZSwgdGhpcy5tYXBbREVQVEhfVEVTVF0gPSB0aGlzLnNldERlcHRoVGVzdCwgdGhpcy5tYXBbV0lORElOR10gPSB0aGlzLnNldEZyb250RmFjZSwgdGhpcy5tYXBbREVQVEhfTUFTS10gPSB0aGlzLnNldERlcHRoTWFzaywgdGhpcy5jaGVja3MgPSBbXSwgdGhpcy5kZWZhdWx0U3RhdGUgPSBuZXcgU3RhdGUoKSwgdGhpcy5kZWZhdWx0U3RhdGUuYmxlbmQgPSAhMDtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsLCB0aGlzLmJsZW5kTW9kZXMgPSBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wpLCB0aGlzLnNldCh0aGlzLmRlZmF1bHRTdGF0ZSksIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldC5cbiAgICovXG4gIHNldChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlLCB0aGlzLnN0YXRlSWQgIT09IHN0YXRlLmRhdGEpIHtcbiAgICAgIGxldCBkaWZmID0gdGhpcy5zdGF0ZUlkIF4gc3RhdGUuZGF0YSwgaSA9IDA7XG4gICAgICBmb3IgKDsgZGlmZjsgKVxuICAgICAgICBkaWZmICYgMSAmJiB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKSwgZGlmZiA9IGRpZmYgPj4gMSwgaSsrO1xuICAgICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoZWNrcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuY2hlY2tzW2ldKHRoaXMsIHN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUsIHdoZW4gcHJldmlvdXMgc3RhdGUgaXMgdW5rbm93bi5cbiAgICogQHBhcmFtIHsqfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcbiAgICovXG4gIGZvcmNlU3RhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5jaGVja3NbaV0odGhpcywgc3RhdGUpO1xuICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBibGVuZGluZy5cbiAgICogQHBhcmFtIHZhbHVlIC0gVHVybiBvbiBvciBvZmYgV2ViR2wgYmxlbmRpbmcuXG4gICAqL1xuICBzZXRCbGVuZCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlQ2hlY2soX1N0YXRlU3lzdGVtMi5jaGVja0JsZW5kTW9kZSwgdmFsdWUpLCB0aGlzLmdsW3ZhbHVlID8gXCJlbmFibGVcIiA6IFwiZGlzYWJsZVwiXSh0aGlzLmdsLkJMRU5EKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIHBvbHlnb24gb2Zmc2V0IGZpbGwuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIHBvbHlnb24gb2Zmc2V0IHRlc3RpbmcuXG4gICAqL1xuICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZUNoZWNrKF9TdGF0ZVN5c3RlbTIuY2hlY2tQb2x5Z29uT2Zmc2V0LCB2YWx1ZSksIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBkZXB0aCB0ZXN0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBkZXB0aCB0ZXN0aW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGRlcHRoIG1hc2suXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGRlcHRoIG1hc2suXG4gICAqL1xuICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBjdWxsIGZhY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBjdWxsIGZhY2UuXG4gICAqL1xuICBzZXRDdWxsRmFjZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ2wgZnJvbnQgZmFjZS5cbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIHRydWUgaXMgY2xvY2t3aXNlIGFuZCBmYWxzZSBpcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbFt2YWx1ZSA/IFwiQ1dcIiA6IFwiQ0NXXCJdKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmxlbmQgbW9kZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGJsZW5kIG1vZGUgdG8gc2V0IHRvLlxuICAgKi9cbiAgc2V0QmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLmJsZW5kTW9kZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IHZhbHVlO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLmJsZW5kTW9kZXNbdmFsdWVdLCBnbCA9IHRoaXMuZ2w7XG4gICAgbW9kZS5sZW5ndGggPT09IDIgPyBnbC5ibGVuZEZ1bmMobW9kZVswXSwgbW9kZVsxXSkgOiBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShtb2RlWzBdLCBtb2RlWzFdLCBtb2RlWzJdLCBtb2RlWzNdKSwgbW9kZS5sZW5ndGggPT09IDYgPyAodGhpcy5fYmxlbmRFcSA9ICEwLCBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUobW9kZVs0XSwgbW9kZVs1XSkpIDogdGhpcy5fYmxlbmRFcSAmJiAodGhpcy5fYmxlbmRFcSA9ICExLCBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvbHlnb24gb2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgcG9seWdvbiBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gdGhlIHBvbHlnb24gb2Zmc2V0IHNjYWxlXG4gICAqL1xuICBzZXRQb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSkge1xuICAgIHRoaXMuZ2wucG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpO1xuICB9XG4gIC8vIHVzZWRcbiAgLyoqIFJlc2V0cyBhbGwgdGhlIGxvZ2ljIGFuZCBkaXNhYmxlcyB0aGUgVkFPcy4gKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsICExKSwgdGhpcy5mb3JjZVN0YXRlKHRoaXMuZGVmYXVsdFN0YXRlKSwgdGhpcy5fYmxlbmRFcSA9ICEwLCB0aGlzLmJsZW5kTW9kZSA9IC0xLCB0aGlzLnNldEJsZW5kTW9kZSgwKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSB3aGljaCB1cGRhdGVzIHNob3VsZCBiZSBjaGVja2VkIGJhc2VkIG9uIHdoaWNoIHNldHRpbmdzIGhhdmUgYmVlbiBhY3RpdmF0ZWQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiBibGVuZCBpcyBlbmFibGVkIHRoZW4gd2Ugc2hvdWxkIGNoZWNrIHRoZSBibGVuZCBtb2RlcyBlYWNoIHRpbWUgdGhlIHN0YXRlIGlzIGNoYW5nZWRcbiAgICogb3IgaWYgcG9seWdvbiBmaWxsIGlzIGFjdGl2YXRlZCB0aGVuIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBvbHlnb24gb2Zmc2V0IGNoYW5nZXMuXG4gICAqIFRoZSBpZGVhIGlzIHRoYXQgd2Ugb25seSBjaGVjayB3aGF0IHdlIGhhdmUgdG9vLlxuICAgKiBAcGFyYW0gZnVuYyAtIHRoZSBjaGVja2luZyBmdW5jdGlvbiB0byBhZGQgb3IgcmVtb3ZlXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHNob3VsZCB0aGUgY2hlY2sgZnVuY3Rpb24gYmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICovXG4gIHVwZGF0ZUNoZWNrKGZ1bmMsIHZhbHVlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoZWNrcy5pbmRleE9mKGZ1bmMpO1xuICAgIHZhbHVlICYmIGluZGV4ID09PSAtMSA/IHRoaXMuY2hlY2tzLnB1c2goZnVuYykgOiAhdmFsdWUgJiYgaW5kZXggIT09IC0xICYmIHRoaXMuY2hlY2tzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgcHJpdmF0ZSBsaXR0bGUgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdlIGNhbGwgdG8gY2hlY2sgdGhlIGJsZW5kIG1vZGUuXG4gICAqIEBwYXJhbSBzeXN0ZW0gLSB0aGUgU3lzdGVtIHRvIHBlcmZvcm0gdGhlIHN0YXRlIGNoZWNrIG9uXG4gICAqIEBwYXJhbSBzdGF0ZSAtIHRoZSBzdGF0ZSB0aGF0IHRoZSBibGVuZE1vZGUgd2lsbCBwdWxsZWQgZnJvbVxuICAgKi9cbiAgc3RhdGljIGNoZWNrQmxlbmRNb2RlKHN5c3RlbSwgc3RhdGUpIHtcbiAgICBzeXN0ZW0uc2V0QmxlbmRNb2RlKHN0YXRlLmJsZW5kTW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgcHJpdmF0ZSBsaXR0bGUgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdlIGNhbGwgdG8gY2hlY2sgdGhlIHBvbHlnb24gb2Zmc2V0LlxuICAgKiBAcGFyYW0gc3lzdGVtIC0gdGhlIFN5c3RlbSB0byBwZXJmb3JtIHRoZSBzdGF0ZSBjaGVjayBvblxuICAgKiBAcGFyYW0gc3RhdGUgLSB0aGUgc3RhdGUgdGhhdCB0aGUgYmxlbmRNb2RlIHdpbGwgcHVsbGVkIGZyb21cbiAgICovXG4gIHN0YXRpYyBjaGVja1BvbHlnb25PZmZzZXQoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRQb2x5Z29uT2Zmc2V0KDEsIHN0YXRlLnBvbHlnb25PZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICB9XG59O1xuX1N0YXRlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzdGF0ZVwiXG59O1xubGV0IFN0YXRlU3lzdGVtID0gX1N0YXRlU3lzdGVtO1xuZXh0ZW5zaW9ucy5hZGQoU3RhdGVTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgU3RhdGVTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBSdW5uZXIgfSBmcm9tIFwiQHBpeGkvcnVubmVyXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiQHBpeGkvdXRpbHNcIjtcbmNsYXNzIFN5c3RlbU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnJ1bm5lcnMgPSB7fSwgdGhpcy5fc3lzdGVtc0hhc2ggPSB7fTtcbiAgfVxuICAvKipcbiAgICogU2V0IHVwIGEgc3lzdGVtIHdpdGggYSBjb2xsZWN0aW9uIG9mIFN5c3RlbUNsYXNzZXMgYW5kIHJ1bm5lcnMuXG4gICAqIFN5c3RlbXMgYXJlIGF0dGFjaGVkIGR5bmFtaWNhbGx5IHRvIHRoaXMgY2xhc3Mgd2hlbiBhZGRlZC5cbiAgICogQHBhcmFtIGNvbmZpZyAtIHRoZSBjb25maWcgZm9yIHRoZSBzeXN0ZW0gbWFuYWdlclxuICAgKi9cbiAgc2V0dXAoY29uZmlnKSB7XG4gICAgdGhpcy5hZGRSdW5uZXJzKC4uLmNvbmZpZy5ydW5uZXJzKTtcbiAgICBjb25zdCBwcmlvcml0eSA9IChjb25maWcucHJpb3JpdHkgPz8gW10pLmZpbHRlcigoa2V5KSA9PiBjb25maWcuc3lzdGVtc1trZXldKSwgb3JkZXJCeVByaW9yaXR5ID0gW1xuICAgICAgLi4ucHJpb3JpdHksXG4gICAgICAuLi5PYmplY3Qua2V5cyhjb25maWcuc3lzdGVtcykuZmlsdGVyKChrZXkpID0+ICFwcmlvcml0eS5pbmNsdWRlcyhrZXkpKVxuICAgIF07XG4gICAgZm9yIChjb25zdCBpIG9mIG9yZGVyQnlQcmlvcml0eSlcbiAgICAgIHRoaXMuYWRkU3lzdGVtKGNvbmZpZy5zeXN0ZW1zW2ldLCBpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgYnVuY2ggb2YgcnVubmVycyBiYXNlZCBvZiBhIGNvbGxlY3Rpb24gb2YgaWRzXG4gICAqIEBwYXJhbSBydW5uZXJJZHMgLSB0aGUgcnVubmVyIGlkcyB0byBhZGRcbiAgICovXG4gIGFkZFJ1bm5lcnMoLi4ucnVubmVySWRzKSB7XG4gICAgcnVubmVySWRzLmZvckVhY2goKHJ1bm5lcklkKSA9PiB7XG4gICAgICB0aGlzLnJ1bm5lcnNbcnVubmVySWRdID0gbmV3IFJ1bm5lcihydW5uZXJJZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzeXN0ZW0gdG8gdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gQ2xhc3NSZWYgLSBDbGFzcyByZWZlcmVuY2VcbiAgICogQHBhcmFtIG5hbWUgLSBQcm9wZXJ0eSBuYW1lIGZvciBzeXN0ZW0sIGlmIG5vdCBzcGVjaWZpZWRcbiAgICogICAgICAgIHdpbGwgdXNlIGEgc3RhdGljIGBuYW1lYCBwcm9wZXJ0eSBvbiB0aGUgY2xhc3MgaXRzZWxmLiBUaGlzXG4gICAqICAgICAgICBuYW1lIHdpbGwgYmUgYXNzaWduZWQgYXMgcyBwcm9wZXJ0eSBvbiB0aGUgUmVuZGVyZXIgc28gbWFrZVxuICAgKiAgICAgICAgc3VyZSBpdCBkb2Vzbid0IGNvbGxpZGUgd2l0aCBwcm9wZXJ0aWVzIG9uIFJlbmRlcmVyLlxuICAgKiBAcmV0dXJucyBSZXR1cm4gaW5zdGFuY2Ugb2YgcmVuZGVyZXJcbiAgICovXG4gIGFkZFN5c3RlbShDbGFzc1JlZiwgbmFtZSkge1xuICAgIGNvbnN0IHN5c3RlbSA9IG5ldyBDbGFzc1JlZih0aGlzKTtcbiAgICBpZiAodGhpc1tuYW1lXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV2hvb3BzISBUaGUgbmFtZSBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGluIHVzZWApO1xuICAgIHRoaXNbbmFtZV0gPSBzeXN0ZW0sIHRoaXMuX3N5c3RlbXNIYXNoW25hbWVdID0gc3lzdGVtO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnJ1bm5lcnMpXG4gICAgICB0aGlzLnJ1bm5lcnNbaV0uYWRkKHN5c3RlbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biBhIHJ1bm5lciBhbmQgY2FsbCB0aGUgcnVubmVycyBmdW5jdGlvbiBidXQgcGFzcyBpbiBkaWZmZXJlbnQgb3B0aW9uc1xuICAgKiB0byBlYWNoIHN5c3RlbSBiYXNlZCBvbiB0aGVyZSBuYW1lLlxuICAgKlxuICAgKiBFLmcuIElmIHlvdSBoYXZlIHR3byBzeXN0ZW1zIGFkZGVkIGNhbGxlZCBgc3lzdGVtQWAgYW5kIGBzeXN0ZW1CYCB5b3UgY291bGQgY2FsbCBkbyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBzeXN0ZW0uZW1pdFdpdGhDdXN0b21PcHRpb25zKGluaXQsIHtcbiAgICogICAgIHN5c3RlbUE6IHsuLi5vcHRpb25zRm9yQX0sXG4gICAqICAgICBzeXN0ZW1COiB7Li4ub3B0aW9uc0ZvckJ9LFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIGBpbml0YCB3b3VsZCBiZSBjYWxsZWQgb24gc3lzdGVtIEEgcGFzc2luZyBgb3B0aW9uc0ZvckFgIGFuZCBvbiBzeXN0ZW0gQiBwYXNzaW5nIGBvcHRpb25zRm9yQmAuXG4gICAqIEBwYXJhbSBydW5uZXIgLSB0aGUgcnVubmVyIHRvIHRhcmdldFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGtleSB2YWx1ZSBvcHRpb25zIGZvciBlYWNoIHN5c3RlbVxuICAgKi9cbiAgZW1pdFdpdGhDdXN0b21PcHRpb25zKHJ1bm5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN5c3RlbUhhc2hLZXlzID0gT2JqZWN0LmtleXModGhpcy5fc3lzdGVtc0hhc2gpO1xuICAgIHJ1bm5lci5pdGVtcy5mb3JFYWNoKChzeXN0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHN5c3RlbU5hbWUgPSBzeXN0ZW1IYXNoS2V5cy5maW5kKChzeXN0ZW1JZCkgPT4gdGhpcy5fc3lzdGVtc0hhc2hbc3lzdGVtSWRdID09PSBzeXN0ZW0pO1xuICAgICAgc3lzdGVtW3J1bm5lci5uYW1lXShvcHRpb25zW3N5c3RlbU5hbWVdKTtcbiAgICB9KTtcbiAgfVxuICAvKiogZGVzdHJveSB0aGUgYWxsIHJ1bm5lcnMgYW5kIHN5c3RlbXMuIEl0cyBhcHBzIGpvYiB0byAqL1xuICBkZXN0cm95KCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5ydW5uZXJzKS5mb3JFYWNoKChydW5uZXIpID0+IHtcbiAgICAgIHJ1bm5lci5kZXN0cm95KCk7XG4gICAgfSksIHRoaXMuX3N5c3RlbXNIYXNoID0ge307XG4gIH1cbiAgLy8gVE9ETyBpbXBsZW1lbnQhXG4gIC8vIHJlbW92ZVN5c3RlbShDbGFzc1JlZjogSVN5c3RlbUNvbnN0cnVjdG9yLCBuYW1lOiBzdHJpbmcpOiB2b2lkXG4gIC8vIHtcbiAgLy8gfVxufVxuZXhwb3J0IHtcbiAgU3lzdGVtTWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5c3RlbU1hbmFnZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR0NfTU9ERVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmNvbnN0IF9UZXh0dXJlR0NTeXN0ZW0gPSBjbGFzcyBfVGV4dHVyZUdDU3lzdGVtMiB7XG4gIC8qKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLiAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5jb3VudCA9IDAsIHRoaXMuY2hlY2tDb3VudCA9IDAsIHRoaXMubWF4SWRsZSA9IF9UZXh0dXJlR0NTeXN0ZW0yLmRlZmF1bHRNYXhJZGxlLCB0aGlzLmNoZWNrQ291bnRNYXggPSBfVGV4dHVyZUdDU3lzdGVtMi5kZWZhdWx0Q2hlY2tDb3VudE1heCwgdGhpcy5tb2RlID0gX1RleHR1cmVHQ1N5c3RlbTIuZGVmYXVsdE1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgd2hlbiB0aGUgbGFzdCB0aW1lIGEgdGV4dHVyZSB3YXMgdXNlZC5cbiAgICogSWYgdGhlIHRleHR1cmUgaGFzIG5vdCBiZWVuIHVzZWQgZm9yIGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lLCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVLlxuICAgKi9cbiAgcG9zdHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLm9iamVjdFJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuICYmICh0aGlzLmNvdW50KyssIHRoaXMubW9kZSAhPT0gR0NfTU9ERVMuTUFOVUFMICYmICh0aGlzLmNoZWNrQ291bnQrKywgdGhpcy5jaGVja0NvdW50ID4gdGhpcy5jaGVja0NvdW50TWF4ICYmICh0aGlzLmNoZWNrQ291bnQgPSAwLCB0aGlzLnJ1bigpKSkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWQuXG4gICAqIElmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVS5cbiAgICovXG4gIHJ1bigpIHtcbiAgICBjb25zdCB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZSwgbWFuYWdlZFRleHR1cmVzID0gdG0ubWFuYWdlZFRleHR1cmVzO1xuICAgIGxldCB3YXNSZW1vdmVkID0gITE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBtYW5hZ2VkVGV4dHVyZXNbaV07XG4gICAgICB0ZXh0dXJlLnJlc291cmNlICYmIHRoaXMuY291bnQgLSB0ZXh0dXJlLnRvdWNoZWQgPiB0aGlzLm1heElkbGUgJiYgKHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsICEwKSwgbWFuYWdlZFRleHR1cmVzW2ldID0gbnVsbCwgd2FzUmVtb3ZlZCA9ICEwKTtcbiAgICB9XG4gICAgaWYgKHdhc1JlbW92ZWQpIHtcbiAgICAgIGxldCBqID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaV0gIT09IG51bGwgJiYgKG1hbmFnZWRUZXh0dXJlc1tqKytdID0gbWFuYWdlZFRleHR1cmVzW2ldKTtcbiAgICAgIG1hbmFnZWRUZXh0dXJlcy5sZW5ndGggPSBqO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdGhlIHRleHR1cmVzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgYW5kIGl0cyBjaGlsZHJlbiBmcm9tIHRoZSBHUFUuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gdGhlIGRpc3BsYXlPYmplY3QgdG8gcmVtb3ZlIHRoZSB0ZXh0dXJlcyBmcm9tLlxuICAgKi9cbiAgdW5sb2FkKGRpc3BsYXlPYmplY3QpIHtcbiAgICBjb25zdCB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZSwgdGV4dHVyZSA9IGRpc3BsYXlPYmplY3QuX3RleHR1cmU7XG4gICAgdGV4dHVyZSAmJiAhdGV4dHVyZS5mcmFtZWJ1ZmZlciAmJiB0bS5kZXN0cm95VGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRoaXMudW5sb2FkKGRpc3BsYXlPYmplY3QuY2hpbGRyZW5baV0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG5fVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlID0gR0NfTU9ERVMuQVVUTywgLyoqXG4qIERlZmF1bHQgbWF4aW11bSBpZGxlIGZyYW1lcyBiZWZvcmUgYSB0ZXh0dXJlIGlzIGRlc3Ryb3llZCBieSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4qIEBzdGF0aWNcbiogQGRlZmF1bHQgMzYwMFxuKiBAc2VlIFBJWEkuVGV4dHVyZUdDU3lzdGVtI21heElkbGVcbiovXG5fVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlID0gNjAgKiA2MCwgLyoqXG4qIERlZmF1bHQgZnJhbWVzIGJldHdlZW4gdHdvIGdhcmJhZ2UgY29sbGVjdGlvbnMuXG4qIEBzdGF0aWNcbiogQGRlZmF1bHQgNjAwXG4qIEBzZWUgUElYSS5UZXh0dXJlR0NTeXN0ZW0jY2hlY2tDb3VudE1heFxuKi9cbl9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXggPSA2MCAqIDEwLCAvKiogQGlnbm9yZSAqL1xuX1RleHR1cmVHQ1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwidGV4dHVyZUdDXCJcbn07XG5sZXQgVGV4dHVyZUdDU3lzdGVtID0gX1RleHR1cmVHQ1N5c3RlbTtcbmV4dGVuc2lvbnMuYWRkKFRleHR1cmVHQ1N5c3RlbSk7XG5leHBvcnQge1xuICBUZXh0dXJlR0NTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlR0NTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgVFlQRVMsIEZPUk1BVFMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5jbGFzcyBHTFRleHR1cmUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZSwgdGhpcy53aWR0aCA9IC0xLCB0aGlzLmhlaWdodCA9IC0xLCB0aGlzLmRpcnR5SWQgPSAtMSwgdGhpcy5kaXJ0eVN0eWxlSWQgPSAtMSwgdGhpcy5taXBtYXAgPSAhMSwgdGhpcy53cmFwTW9kZSA9IDMzMDcxLCB0aGlzLnR5cGUgPSBUWVBFUy5VTlNJR05FRF9CWVRFLCB0aGlzLmludGVybmFsRm9ybWF0ID0gRk9STUFUUy5SR0JBLCB0aGlzLnNhbXBsZXJUeXBlID0gMDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgR0xUZXh0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xUZXh0dXJlLm1qcy5tYXBcbiIsImltcG9ydCB7IFNBTVBMRVJfVFlQRVMgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5mdW5jdGlvbiBtYXBJbnRlcm5hbEZvcm1hdFRvU2FtcGxlclR5cGUoZ2wpIHtcbiAgbGV0IHRhYmxlO1xuICByZXR1cm4gXCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0XCIgaW4gZ2xvYmFsVGhpcyAmJiBnbCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA/IHRhYmxlID0ge1xuICAgIFtnbC5SR0JdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuQUxQSEFdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5MVU1JTkFOQ0VdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5MVU1JTkFOQ0VfQUxQSEFdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SOF06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlI4X1NOT1JNXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkc4XTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkc4X1NOT1JNXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCOF06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQjhfU05PUk1dOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0I1NjVdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBNF06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQjVfQTFdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBOF06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQkE4X1NOT1JNXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCMTBfQTJdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0IxMF9BMlVJXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuU1JHQjhdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5TUkdCOF9BTFBIQThdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SMTZGXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkcxNkZdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0IxNkZdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBMTZGXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUjMyRl06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHMzJGXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCMzJGXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCQTMyRl06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlIxMUZfRzExRl9CMTBGXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCOV9FNV06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlI4SV06IFNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SOFVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SMTZJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlIxNlVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SMzJJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlIzMlVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SRzhJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHOFVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SRzE2SV06IFNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SRzE2VUldOiBTQU1QTEVSX1RZUEVTLlVJTlQsXG4gICAgW2dsLlJHMzJJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHMzJVSV06IFNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkdCOEldOiBTQU1QTEVSX1RZUEVTLklOVCxcbiAgICBbZ2wuUkdCOFVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SR0IxNkldOiBTQU1QTEVSX1RZUEVTLklOVCxcbiAgICBbZ2wuUkdCMTZVSV06IFNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkdCMzJJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHQjMyVUldOiBTQU1QTEVSX1RZUEVTLlVJTlQsXG4gICAgW2dsLlJHQkE4SV06IFNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SR0JBOFVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SR0JBMTZJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHQkExNlVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SR0JBMzJJXTogU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHQkEzMlVJXTogU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5ERVBUSF9DT01QT05FTlQxNl06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkRFUFRIX0NPTVBPTkVOVDI0XTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuREVQVEhfQ09NUE9ORU5UMzJGXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuREVQVEhfU1RFTkNJTF06IFNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkRFUFRIMjRfU1RFTkNJTDhdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5ERVBUSDMyRl9TVEVOQ0lMOF06IFNBTVBMRVJfVFlQRVMuRkxPQVRcbiAgfSA6IHRhYmxlID0ge1xuICAgIFtnbC5SR0JdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBXTogU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuQUxQSEFdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5MVU1JTkFOQ0VdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5MVU1JTkFOQ0VfQUxQSEFdOiBTQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5ERVBUSF9TVEVOQ0lMXTogU0FNUExFUl9UWVBFUy5GTE9BVFxuICB9LCB0YWJsZTtcbn1cbmV4cG9ydCB7XG4gIG1hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUWVBFUywgRk9STUFUUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmZ1bmN0aW9uIG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0KGdsKSB7XG4gIGxldCB0YWJsZTtcbiAgcmV0dXJuIFwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dFwiIGluIGdsb2JhbFRoaXMgJiYgZ2wgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYkdMMlJlbmRlcmluZ0NvbnRleHQgPyB0YWJsZSA9IHtcbiAgICBbVFlQRVMuVU5TSUdORURfQllURV06IHtcbiAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBOCxcbiAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQjgsXG4gICAgICBbRk9STUFUUy5SR106IGdsLlJHOCxcbiAgICAgIFtGT1JNQVRTLlJFRF06IGdsLlI4LFxuICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQThVSSxcbiAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOFVJLFxuICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHOFVJLFxuICAgICAgW0ZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SOFVJLFxuICAgICAgW0ZPUk1BVFMuQUxQSEFdOiBnbC5BTFBIQSxcbiAgICAgIFtGT1JNQVRTLkxVTUlOQU5DRV06IGdsLkxVTUlOQU5DRSxcbiAgICAgIFtGT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgIH0sXG4gICAgW1RZUEVTLkJZVEVdOiB7XG4gICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQThfU05PUk0sXG4gICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0I4X1NOT1JNLFxuICAgICAgW0ZPUk1BVFMuUkddOiBnbC5SRzhfU05PUk0sXG4gICAgICBbRk9STUFUUy5SRURdOiBnbC5SOF9TTk9STSxcbiAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkE4SSxcbiAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOEksXG4gICAgICBbRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkc4SSxcbiAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjhJXG4gICAgfSxcbiAgICBbVFlQRVMuVU5TSUdORURfU0hPUlRdOiB7XG4gICAgICBbRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBMTZVSSxcbiAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCMTZVSSxcbiAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzE2VUksXG4gICAgICBbRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlIxNlVJLFxuICAgICAgW0ZPUk1BVFMuREVQVEhfQ09NUE9ORU5UXTogZ2wuREVQVEhfQ09NUE9ORU5UMTZcbiAgICB9LFxuICAgIFtUWVBFUy5TSE9SVF06IHtcbiAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkExNkksXG4gICAgICBbRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjE2SSxcbiAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzE2SSxcbiAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjE2SVxuICAgIH0sXG4gICAgW1RZUEVTLlVOU0lHTkVEX0lOVF06IHtcbiAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkEzMlVJLFxuICAgICAgW0ZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IzMlVJLFxuICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHMzJVSSxcbiAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjMyVUksXG4gICAgICBbRk9STUFUUy5ERVBUSF9DT01QT05FTlRdOiBnbC5ERVBUSF9DT01QT05FTlQyNFxuICAgIH0sXG4gICAgW1RZUEVTLklOVF06IHtcbiAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkEzMkksXG4gICAgICBbRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjMySSxcbiAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzMySSxcbiAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjMySVxuICAgIH0sXG4gICAgW1RZUEVTLkZMT0FUXToge1xuICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkEzMkYsXG4gICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0IzMkYsXG4gICAgICBbRk9STUFUUy5SR106IGdsLlJHMzJGLFxuICAgICAgW0ZPUk1BVFMuUkVEXTogZ2wuUjMyRixcbiAgICAgIFtGT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDMyRlxuICAgIH0sXG4gICAgW1RZUEVTLkhBTEZfRkxPQVRdOiB7XG4gICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQTE2RixcbiAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQjE2RixcbiAgICAgIFtGT1JNQVRTLlJHXTogZ2wuUkcxNkYsXG4gICAgICBbRk9STUFUUy5SRURdOiBnbC5SMTZGXG4gICAgfSxcbiAgICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNV82XzVdOiB7XG4gICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0I1NjVcbiAgICB9LFxuICAgIFtUWVBFUy5VTlNJR05FRF9TSE9SVF80XzRfNF80XToge1xuICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkE0XG4gICAgfSxcbiAgICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNV81XzVfMV06IHtcbiAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0I1X0ExXG4gICAgfSxcbiAgICBbVFlQRVMuVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXToge1xuICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQjEwX0EyLFxuICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCMTBfQTJVSVxuICAgIH0sXG4gICAgW1RZUEVTLlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZdOiB7XG4gICAgICBbRk9STUFUUy5SR0JdOiBnbC5SMTFGX0cxMUZfQjEwRlxuICAgIH0sXG4gICAgW1RZUEVTLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVl06IHtcbiAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQjlfRTVcbiAgICB9LFxuICAgIFtUWVBFUy5VTlNJR05FRF9JTlRfMjRfOF06IHtcbiAgICAgIFtGT1JNQVRTLkRFUFRIX1NURU5DSUxdOiBnbC5ERVBUSDI0X1NURU5DSUw4XG4gICAgfSxcbiAgICBbVFlQRVMuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXToge1xuICAgICAgW0ZPUk1BVFMuREVQVEhfU1RFTkNJTF06IGdsLkRFUFRIMzJGX1NURU5DSUw4XG4gICAgfVxuICB9IDogdGFibGUgPSB7XG4gICAgW1RZUEVTLlVOU0lHTkVEX0JZVEVdOiB7XG4gICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQSxcbiAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQixcbiAgICAgIFtGT1JNQVRTLkFMUEhBXTogZ2wuQUxQSEEsXG4gICAgICBbRk9STUFUUy5MVU1JTkFOQ0VdOiBnbC5MVU1JTkFOQ0UsXG4gICAgICBbRk9STUFUUy5MVU1JTkFOQ0VfQUxQSEFdOiBnbC5MVU1JTkFOQ0VfQUxQSEFcbiAgICB9LFxuICAgIFtUWVBFUy5VTlNJR05FRF9TSE9SVF81XzZfNV06IHtcbiAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlJHQlxuICAgIH0sXG4gICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiB7XG4gICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQVxuICAgIH0sXG4gICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNV81XzFdOiB7XG4gICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQVxuICAgIH1cbiAgfSwgdGFibGU7XG59XG5leHBvcnQge1xuICBtYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNBTVBMRVJfVFlQRVMsIFRZUEVTLCBNSVBNQVBfTU9ERVMsIFdSQVBfTU9ERVMsIFNDQUxFX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5pbXBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gXCJAcGl4aS91dGlsc1wiO1xuaW1wb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiLi9CYXNlVGV4dHVyZS5tanNcIjtcbmltcG9ydCB7IEdMVGV4dHVyZSB9IGZyb20gXCIuL0dMVGV4dHVyZS5tanNcIjtcbmltcG9ydCB7IG1hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZSB9IGZyb20gXCIuL3V0aWxzL21hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZS5tanNcIjtcbmltcG9ydCB7IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0IH0gZnJvbSBcIi4vdXRpbHMvbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQubWpzXCI7XG5jbGFzcyBUZXh0dXJlU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIHN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5ib3VuZFRleHR1cmVzID0gW10sIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTEsIHRoaXMubWFuYWdlZFRleHR1cmVzID0gW10sIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gITEsIHRoaXMudW5rbm93blRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoKSwgdGhpcy5oYXNJbnRlZ2VyVGV4dHVyZXMgPSAhMTtcbiAgfVxuICAvKiogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuICovXG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCwgdGhpcy53ZWJHTFZlcnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uLCB0aGlzLmludGVybmFsRm9ybWF0cyA9IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0KGdsKSwgdGhpcy5zYW1wbGVyVHlwZXMgPSBtYXBJbnRlcm5hbEZvcm1hdFRvU2FtcGxlclR5cGUoZ2wpO1xuICAgIGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoID0gbWF4VGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKVxuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICB0aGlzLmVtcHR5VGV4dHVyZXMgPSB7fTtcbiAgICBjb25zdCBlbXB0eVRleHR1cmUyRCA9IG5ldyBHTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBlbXB0eVRleHR1cmUyRC50ZXh0dXJlKSwgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBuZXcgVWludDhBcnJheSg0KSksIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXSA9IGVtcHR5VGV4dHVyZTJELCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV9DVUJFX01BUF0gPSBuZXcgR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSksIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXS50ZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUiksIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5iaW5kKG51bGwsIGkpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kIGEgdGV4dHVyZSB0byBhIHNwZWNpZmljIGxvY2F0aW9uXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIHVuYmluZCBzb21ldGhpbmcsIHBsZWFzZSB1c2UgYHVuYmluZCh0ZXh0dXJlKWAgaW5zdGVhZCBvZiBgYmluZChudWxsLCB0ZXh0dXJlTG9jYXRpb24pYFxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRleHR1cmUgdG8gYmluZFxuICAgKiBAcGFyYW0gW2xvY2F0aW9uPTBdIC0gTG9jYXRpb24gdG8gYmluZCBhdFxuICAgKi9cbiAgYmluZCh0ZXh0dXJlLCBsb2NhdGlvbiA9IDApIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGlmICh0ZXh0dXJlID0gdGV4dHVyZT8uY2FzdFRvQmFzZVRleHR1cmUoKSwgdGV4dHVyZT8udmFsaWQgJiYgIXRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5KSB7XG4gICAgICB0ZXh0dXJlLnRvdWNoZWQgPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gfHwgdGhpcy5pbml0VGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gIT09IHRleHR1cmUgJiYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbiAmJiAodGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbiwgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKSksIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCBnbFRleHR1cmUudGV4dHVyZSkpLCBnbFRleHR1cmUuZGlydHlJZCAhPT0gdGV4dHVyZS5kaXJ0eUlkID8gKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbiAmJiAodGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbiwgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKSksIHRoaXMudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKSkgOiBnbFRleHR1cmUuZGlydHlTdHlsZUlkICE9PSB0ZXh0dXJlLmRpcnR5U3R5bGVJZCAmJiB0aGlzLnVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKSwgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IHRleHR1cmU7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24gJiYgKHRoaXMuY3VycmVudExvY2F0aW9uID0gbG9jYXRpb24sIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBsb2NhdGlvbikpLCBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0udGV4dHVyZSksIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gPSBudWxsO1xuICB9XG4gIC8qKiBSZXNldHMgdGV4dHVyZSBsb2NhdGlvbiBhbmQgYm91bmQgdGV4dHVyZXMgQWN0dWFsIGBiaW5kKG51bGwsIGkpYCBjYWxscyB3aWxsIGJlIHBlcmZvcm1lZCBhdCBuZXh0IGB1bmJpbmQoKWAgY2FsbCAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9ICEwLCB0aGlzLmhhc0ludGVnZXJUZXh0dXJlcyA9ICExLCB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gdGhpcy51bmtub3duVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVW5iaW5kIGEgdGV4dHVyZS5cbiAgICogQHBhcmFtIHRleHR1cmUgLSBUZXh0dXJlIHRvIGJpbmRcbiAgICovXG4gIHVuYmluZCh0ZXh0dXJlKSB7XG4gICAgY29uc3QgeyBnbCwgYm91bmRUZXh0dXJlcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gITE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGJvdW5kVGV4dHVyZXNbaV0gPT09IHRoaXMudW5rbm93blRleHR1cmUgJiYgdGhpcy5iaW5kKG51bGwsIGkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspXG4gICAgICBib3VuZFRleHR1cmVzW2ldID09PSB0ZXh0dXJlICYmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gaSAmJiAoZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpLCB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGkpLCBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGhpcy5lbXB0eVRleHR1cmVzW3RleHR1cmUudGFyZ2V0XS50ZXh0dXJlKSwgYm91bmRUZXh0dXJlc1tpXSA9IG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgY3VycmVudCBib3VuZFRleHR1cmVzIGFsbCBoYXZlIEZMT0FUIHNhbXBsZXIgdHlwZSxcbiAgICogc2VlIHtAbGluayBQSVhJLlNBTVBMRVJfVFlQRVN9IGZvciBleHBsYW5hdGlvbi5cbiAgICogQHBhcmFtIG1heFRleHR1cmVzIC0gbnVtYmVyIG9mIGxvY2F0aW9ucyB0byBjaGVja1xuICAgKi9cbiAgZW5zdXJlU2FtcGxlclR5cGUobWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGJvdW5kVGV4dHVyZXMsIGhhc0ludGVnZXJUZXh0dXJlcywgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgaWYgKGhhc0ludGVnZXJUZXh0dXJlcylcbiAgICAgIGZvciAobGV0IGkgPSBtYXhUZXh0dXJlcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IHRleCA9IGJvdW5kVGV4dHVyZXNbaV07XG4gICAgICAgIHRleCAmJiB0ZXguX2dsVGV4dHVyZXNbQ09OVEVYVF9VSURdLnNhbXBsZXJUeXBlICE9PSBTQU1QTEVSX1RZUEVTLkZMT0FUICYmIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQodGV4KTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIHRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHRleHR1cmUgLSBUZXh0dXJlIHRvIGluaXRpYWxpemVcbiAgICovXG4gIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICByZXR1cm4gZ2xUZXh0dXJlLmRpcnR5SWQgPSAtMSwgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGdsVGV4dHVyZSwgdGhpcy5tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKSwgdGV4dHVyZS5vbihcImRpc3Bvc2VcIiwgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyksIGdsVGV4dHVyZTtcbiAgfVxuICBpbml0VGV4dHVyZVR5cGUodGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0ID0gdGhpcy5pbnRlcm5hbEZvcm1hdHNbdGV4dHVyZS50eXBlXT8uW3RleHR1cmUuZm9ybWF0XSA/PyB0ZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnNhbXBsZXJUeXBlID0gdGhpcy5zYW1wbGVyVHlwZXNbZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0XSA/PyBTQU1QTEVSX1RZUEVTLkZMT0FULCB0aGlzLndlYkdMVmVyc2lvbiA9PT0gMiAmJiB0ZXh0dXJlLnR5cGUgPT09IFRZUEVTLkhBTEZfRkxPQVQgPyBnbFRleHR1cmUudHlwZSA9IHRoaXMuZ2wuSEFMRl9GTE9BVCA6IGdsVGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgYSB0ZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gaW5pdGlhbGl6ZVxuICAgKi9cbiAgdXBkYXRlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgY29uc3QgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBpZiAoIWdsVGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKHRoaXMuaW5pdFRleHR1cmVUeXBlKHRleHR1cmUsIGdsVGV4dHVyZSksIHRleHR1cmUucmVzb3VyY2U/LnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSlcbiAgICAgIGdsVGV4dHVyZS5zYW1wbGVyVHlwZSAhPT0gU0FNUExFUl9UWVBFUy5GTE9BVCAmJiAodGhpcy5oYXNJbnRlZ2VyVGV4dHVyZXMgPSAhMCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUucmVhbFdpZHRoLCBoZWlnaHQgPSB0ZXh0dXJlLnJlYWxIZWlnaHQsIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAoZ2xUZXh0dXJlLndpZHRoICE9PSB3aWR0aCB8fCBnbFRleHR1cmUuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSAmJiAoZ2xUZXh0dXJlLndpZHRoID0gd2lkdGgsIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQsIGdsLnRleEltYWdlMkQoXG4gICAgICAgIHRleHR1cmUudGFyZ2V0LFxuICAgICAgICAwLFxuICAgICAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICBnbFRleHR1cmUudHlwZSxcbiAgICAgICAgbnVsbFxuICAgICAgKSk7XG4gICAgfVxuICAgIHRleHR1cmUuZGlydHlTdHlsZUlkICE9PSBnbFRleHR1cmUuZGlydHlTdHlsZUlkICYmIHRoaXMudXBkYXRlVGV4dHVyZVN0eWxlKHRleHR1cmUpLCBnbFRleHR1cmUuZGlydHlJZCA9IHRleHR1cmUuZGlydHlJZDtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gdGhlIHRleHR1cmUgdG8gZGVzdHJveVxuICAgKiBAcGFyYW0gW3NraXBSZW1vdmU9ZmFsc2VdIC0gV2hldGhlciB0byBza2lwIHJlbW92aW5nIHRoZSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxuICAgKi9cbiAgZGVzdHJveVRleHR1cmUodGV4dHVyZSwgc2tpcFJlbW92ZSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgaWYgKHRleHR1cmUgPSB0ZXh0dXJlLmNhc3RUb0Jhc2VUZXh0dXJlKCksIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gJiYgKHRoaXMudW5iaW5kKHRleHR1cmUpLCBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSksIHRleHR1cmUub2ZmKFwiZGlzcG9zZVwiLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKSwgZGVsZXRlIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0sICFza2lwUmVtb3ZlKSkge1xuICAgICAgY29uc3QgaSA9IHRoaXMubWFuYWdlZFRleHR1cmVzLmluZGV4T2YodGV4dHVyZSk7XG4gICAgICBpICE9PSAtMSAmJiByZW1vdmVJdGVtcyh0aGlzLm1hbmFnZWRUZXh0dXJlcywgaSwgMSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGV4dHVyZSBzdHlsZSBzdWNoIGFzIG1pcG1hcCBmbGFnXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gdXBkYXRlXG4gICAqL1xuICB1cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSkge1xuICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgZ2xUZXh0dXJlICYmICgodGV4dHVyZS5taXBtYXAgPT09IE1JUE1BUF9NT0RFUy5QT1cyIHx8IHRoaXMud2ViR0xWZXJzaW9uICE9PSAyKSAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28gPyBnbFRleHR1cmUubWlwbWFwID0gITEgOiBnbFRleHR1cmUubWlwbWFwID0gdGV4dHVyZS5taXBtYXAgPj0gMSwgdGhpcy53ZWJHTFZlcnNpb24gIT09IDIgJiYgIXRleHR1cmUuaXNQb3dlck9mVHdvID8gZ2xUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5DTEFNUCA6IGdsVGV4dHVyZS53cmFwTW9kZSA9IHRleHR1cmUud3JhcE1vZGUsIHRleHR1cmUucmVzb3VyY2U/LnN0eWxlKHRoaXMucmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkgfHwgdGhpcy5zZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpLCBnbFRleHR1cmUuZGlydHlTdHlsZUlkID0gdGV4dHVyZS5kaXJ0eVN0eWxlSWQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc3R5bGUgZm9yIHRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHRleHR1cmUgLSBUZXh0dXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlXG4gICAqL1xuICBzZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKGdsVGV4dHVyZS5taXBtYXAgJiYgdGV4dHVyZS5taXBtYXAgIT09IE1JUE1BUF9NT0RFUy5PTl9NQU5VQUwgJiYgZ2wuZ2VuZXJhdGVNaXBtYXAodGV4dHVyZS50YXJnZXQpLCBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUywgZ2xUZXh0dXJlLndyYXBNb2RlKSwgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsVGV4dHVyZS53cmFwTW9kZSksIGdsVGV4dHVyZS5taXBtYXApIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIDogZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICBjb25zdCBhbmlzb3Ryb3BpY0V4dCA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmFuaXNvdHJvcGljRmlsdGVyaW5nO1xuICAgICAgaWYgKGFuaXNvdHJvcGljRXh0ICYmIHRleHR1cmUuYW5pc290cm9waWNMZXZlbCA+IDAgJiYgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFNDQUxFX01PREVTLkxJTkVBUikge1xuICAgICAgICBjb25zdCBsZXZlbCA9IE1hdGgubWluKHRleHR1cmUuYW5pc290cm9waWNMZXZlbCwgZ2wuZ2V0UGFyYW1ldGVyKGFuaXNvdHJvcGljRXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCkpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKHRleHR1cmUudGFyZ2V0LCBhbmlzb3Ryb3BpY0V4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuVGV4dHVyZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwidGV4dHVyZVwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoVGV4dHVyZVN5c3RlbSk7XG5leHBvcnQge1xuICBUZXh0dXJlU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICAvKiogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuICovXG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2wsIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kIFRyYW5zZm9ybUZlZWRiYWNrIGFuZCBidWZmZXJzXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm1GZWVkYmFjayAtIFRyYW5zZm9ybUZlZWRiYWNrIHRvIGJpbmRcbiAgICovXG4gIGJpbmQodHJhbnNmb3JtRmVlZGJhY2spIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcywgZ2xUcmFuc2Zvcm1GZWVkYmFjayA9IHRyYW5zZm9ybUZlZWRiYWNrLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTFRyYW5zZm9ybUZlZWRiYWNrKHRyYW5zZm9ybUZlZWRiYWNrKTtcbiAgICBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBnbFRyYW5zZm9ybUZlZWRiYWNrKTtcbiAgfVxuICAvKiogVW5iaW5kIFRyYW5zZm9ybUZlZWRiYWNrICovXG4gIHVuYmluZCgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBCZWdpbiBUcmFuc2Zvcm1GZWVkYmFja1xuICAgKiBAcGFyYW0gZHJhd01vZGUgLSBEcmF3TW9kZSBmb3IgVHJhbnNmb3JtRmVlZGJhY2tcbiAgICogQHBhcmFtIHNoYWRlciAtIEEgU2hhZGVyIHVzZWQgYnkgVHJhbnNmb3JtRmVlZGJhY2suIEN1cnJlbnQgYm91bmQgc2hhZGVyIHdpbGwgYmUgdXNlZCBpZiBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBiZWdpblRyYW5zZm9ybUZlZWRiYWNrKGRyYXdNb2RlLCBzaGFkZXIpIHtcbiAgICBjb25zdCB7IGdsLCByZW5kZXJlciB9ID0gdGhpcztcbiAgICBzaGFkZXIgJiYgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKSwgZ2wuYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayhkcmF3TW9kZSk7XG4gIH1cbiAgLyoqIEVuZCBUcmFuc2Zvcm1GZWVkYmFjayAqL1xuICBlbmRUcmFuc2Zvcm1GZWVkYmFjaygpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGdsLmVuZFRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUcmFuc2Zvcm1GZWVkYmFjayBhbmQgYmluZCBidWZmZXJzXG4gICAqIEBwYXJhbSB0ZiAtIFRyYW5zZm9ybUZlZWRiYWNrXG4gICAqIEByZXR1cm5zIFdlYkdMVHJhbnNmb3JtRmVlZGJhY2tcbiAgICovXG4gIGNyZWF0ZUdMVHJhbnNmb3JtRmVlZGJhY2sodGYpIHtcbiAgICBjb25zdCB7IGdsLCByZW5kZXJlciwgQ09OVEVYVF9VSUQgfSA9IHRoaXMsIGdsVHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICAgIHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1tDT05URVhUX1VJRF0gPSBnbFRyYW5zZm9ybUZlZWRiYWNrLCBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBnbFRyYW5zZm9ybUZlZWRiYWNrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRmLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRmLmJ1ZmZlcnNbaV07XG4gICAgICBidWZmZXIgJiYgKHJlbmRlcmVyLmJ1ZmZlci51cGRhdGUoYnVmZmVyKSwgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLnJlZkNvdW50KyssIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIsIGksIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5idWZmZXIgfHwgbnVsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCksIHRmLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpLCBnbFRyYW5zZm9ybUZlZWRiYWNrO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBUcmFuc2Zyb21GZWVkYmFja1xuICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtRmVlZGJhY2t9IHRmIC0gVHJhbnNmb3JtRmVlZGJhY2tcbiAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIC0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgZGVsZXRlIFRyYW5zZm9ybUZlZWRiYWNrXG4gICAqL1xuICBkaXNwb3NlVHJhbnNmb3JtRmVlZGJhY2sodGYsIGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgZ2xURiA9IHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1t0aGlzLkNPTlRFWFRfVUlEXSwgZ2wgPSB0aGlzLmdsO1xuICAgIHRmLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGlmIChidWZmZXJTeXN0ZW0pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRmLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGYuYnVmZmVyc1tpXTtcbiAgICAgICAgaWYgKCFidWZmZXIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICBidWYgJiYgKGJ1Zi5yZWZDb3VudC0tLCBidWYucmVmQ291bnQgPT09IDAgJiYgIWNvbnRleHRMb3N0ICYmIGJ1ZmZlclN5c3RlbS5kaXNwb3NlKGJ1ZmZlciwgY29udGV4dExvc3QpKTtcbiAgICAgIH1cbiAgICBnbFRGICYmIChjb250ZXh0TG9zdCB8fCBnbC5kZWxldGVUcmFuc2Zvcm1GZWVkYmFjayhnbFRGKSwgZGVsZXRlIHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1t0aGlzLkNPTlRFWFRfVUlEXSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInRyYW5zZm9ybUZlZWRiYWNrXCJcbn07XG5leHRlbnNpb25zLmFkZChUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSk7XG5leHBvcnQge1xuICBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSBcIkBwaXhpL21hdGhcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5jbGFzcyBWaWV3U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIGluaXRpYXRlcyB0aGUgdmlldyBzeXN0ZW1cbiAgICogQHBhcmFtIHtQSVhJLlZpZXdPcHRpb25zfSBvcHRpb25zIC0gdGhlIG9wdGlvbnMgZm9yIHRoZSB2aWV3XG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpLCB0aGlzLmVsZW1lbnQgPSBvcHRpb25zLnZpZXcgfHwgc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKSwgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uIHx8IHNldHRpbmdzLlJFU09MVVRJT04sIHRoaXMuYXV0b0RlbnNpdHkgPSAhIW9wdGlvbnMuYXV0b0RlbnNpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIHNjcmVlbiBhbmQgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9ucy5cbiAgICogQHBhcmFtIGRlc2lyZWRTY3JlZW5XaWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtIGRlc2lyZWRTY3JlZW5IZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKi9cbiAgcmVzaXplVmlldyhkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQpIHtcbiAgICB0aGlzLmVsZW1lbnQud2lkdGggPSBNYXRoLnJvdW5kKGRlc2lyZWRTY3JlZW5XaWR0aCAqIHRoaXMucmVzb2x1dGlvbiksIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBNYXRoLnJvdW5kKGRlc2lyZWRTY3JlZW5IZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuICAgIGNvbnN0IHNjcmVlbldpZHRoID0gdGhpcy5lbGVtZW50LndpZHRoIC8gdGhpcy5yZXNvbHV0aW9uLCBzY3JlZW5IZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuc2NyZWVuLndpZHRoID0gc2NyZWVuV2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCA9IHNjcmVlbkhlaWdodCwgdGhpcy5hdXRvRGVuc2l0eSAmJiAodGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gYCR7c2NyZWVuV2lkdGh9cHhgLCB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7c2NyZWVuSGVpZ2h0fXB4YCksIHRoaXMucmVuZGVyZXIuZW1pdChcInJlc2l6ZVwiLCBzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSwgdGhpcy5yZW5kZXJlci5ydW5uZXJzLnJlc2l6ZS5lbWl0KHRoaXMuc2NyZWVuLndpZHRoLCB0aGlzLnNjcmVlbi5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIFN5c3RlbSBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBjYW52YXMgZnJvbSB0aGUgZG9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVWaWV3PWZhbHNlXSAtIFdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBjYW52YXMgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgZGVzdHJveShyZW1vdmVWaWV3KSB7XG4gICAgcmVtb3ZlVmlldyAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KSwgdGhpcy5yZW5kZXJlciA9IG51bGwsIHRoaXMuZWxlbWVudCA9IG51bGwsIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgfVxufVxuVmlld1N5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMud2lkdGh9XG4gICAqIEBkZWZhdWx0IDgwMFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgd2lkdGg6IDgwMCxcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMuaGVpZ2h0fVxuICAgKiBAZGVmYXVsdCA2MDBcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGhlaWdodDogNjAwLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5yZXNvbHV0aW9ufVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlJFU09MVVRJT05cbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIHJlc29sdXRpb246IHZvaWQgMCxcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMuYXV0b0RlbnNpdHl9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TXG4gICAqL1xuICBhdXRvRGVuc2l0eTogITFcbn0sIC8qKiBAaWdub3JlICovXG5WaWV3U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcIl92aWV3XCJcbn07XG5leHRlbnNpb25zLmFkZChWaWV3U3lzdGVtKTtcbmV4cG9ydCB7XG4gIFZpZXdTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEJhY2tncm91bmRTeXN0ZW0gfSBmcm9tIFwiLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBCYXRjaFN5c3RlbSB9IGZyb20gXCIuL2JhdGNoL0JhdGNoU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgQ29udGV4dFN5c3RlbSB9IGZyb20gXCIuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5tanNcIjtcbmltcG9ydCB7IEZpbHRlclN5c3RlbSB9IGZyb20gXCIuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgRnJhbWVidWZmZXJTeXN0ZW0gfSBmcm9tIFwiLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlclN5c3RlbS5tanNcIjtcbmltcG9ydCB7IEdlb21ldHJ5U3lzdGVtIH0gZnJvbSBcIi4vZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBNYXNrU3lzdGVtIH0gZnJvbSBcIi4vbWFzay9NYXNrU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgU2Npc3NvclN5c3RlbSB9IGZyb20gXCIuL21hc2svU2Npc3NvclN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFN0ZW5jaWxTeXN0ZW0gfSBmcm9tIFwiLi9tYXNrL1N0ZW5jaWxTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBQbHVnaW5TeXN0ZW0gfSBmcm9tIFwiLi9wbHVnaW4vUGx1Z2luU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgUHJvamVjdGlvblN5c3RlbSB9IGZyb20gXCIuL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5tanNcIjtcbmltcG9ydCB7IEdlbmVyYXRlVGV4dHVyZVN5c3RlbSB9IGZyb20gXCIuL3JlbmRlclRleHR1cmUvR2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgUmVuZGVyVGV4dHVyZVN5c3RlbSB9IGZyb20gXCIuL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFNoYWRlclN5c3RlbSB9IGZyb20gXCIuL3NoYWRlci9TaGFkZXJTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBTdGFydHVwU3lzdGVtIH0gZnJvbSBcIi4vc3RhcnR1cC9TdGFydHVwU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgU3RhdGVTeXN0ZW0gfSBmcm9tIFwiLi9zdGF0ZS9TdGF0ZVN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFN5c3RlbU1hbmFnZXIgfSBmcm9tIFwiLi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanNcIjtcbmltcG9ydCB7IFRleHR1cmVHQ1N5c3RlbSB9IGZyb20gXCIuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5tanNcIjtcbmltcG9ydCB7IFRleHR1cmVTeXN0ZW0gfSBmcm9tIFwiLi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gfSBmcm9tIFwiLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5tanNcIjtcbmltcG9ydCB7IFZpZXdTeXN0ZW0gfSBmcm9tIFwiLi92aWV3L1ZpZXdTeXN0ZW0ubWpzXCI7XG5leHBvcnQge1xuICBCYWNrZ3JvdW5kU3lzdGVtLFxuICBCYXRjaFN5c3RlbSxcbiAgQ29udGV4dFN5c3RlbSxcbiAgRmlsdGVyU3lzdGVtLFxuICBGcmFtZWJ1ZmZlclN5c3RlbSxcbiAgR2VuZXJhdGVUZXh0dXJlU3lzdGVtLFxuICBHZW9tZXRyeVN5c3RlbSxcbiAgTWFza1N5c3RlbSxcbiAgUGx1Z2luU3lzdGVtLFxuICBQcm9qZWN0aW9uU3lzdGVtLFxuICBSZW5kZXJUZXh0dXJlU3lzdGVtLFxuICBTY2lzc29yU3lzdGVtLFxuICBTaGFkZXJTeXN0ZW0sXG4gIFN0YXJ0dXBTeXN0ZW0sXG4gIFN0YXRlU3lzdGVtLFxuICBTdGVuY2lsU3lzdGVtLFxuICBTeXN0ZW1NYW5hZ2VyLFxuICBUZXh0dXJlR0NTeXN0ZW0sXG4gIFRleHR1cmVTeXN0ZW0sXG4gIFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLFxuICBWaWV3U3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzdGVtcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFTlYgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tIFwiQHBpeGkvdXRpbHNcIjtcbmltcG9ydCB7IEJhdGNoUmVuZGVyZXIgfSBmcm9tIFwiLi9iYXRjaC9CYXRjaFJlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSBcIi4vZmlsdGVycy9GaWx0ZXIubWpzXCI7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSBcIi4vc2hhZGVyL1Byb2dyYW0ubWpzXCI7XG5pbXBvcnQgXCIuL3N5c3RlbXMubWpzXCI7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gXCIuL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgQ29udGV4dFN5c3RlbSB9IGZyb20gXCIuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5tanNcIjtcbmltcG9ydCB7IEJhY2tncm91bmRTeXN0ZW0gfSBmcm9tIFwiLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBWaWV3U3lzdGVtIH0gZnJvbSBcIi4vdmlldy9WaWV3U3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgU3RhcnR1cFN5c3RlbSB9IGZyb20gXCIuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFRleHR1cmVHQ1N5c3RlbSB9IGZyb20gXCIuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5tanNcIjtcbnNldHRpbmdzLlBSRUZFUl9FTlYgPSBFTlYuV0VCR0wyO1xuc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUgPSAhMTtcbnNldHRpbmdzLlJFTkRFUl9PUFRJT05TID0ge1xuICAuLi5Db250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLFxuICAuLi5CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zLFxuICAuLi5WaWV3U3lzdGVtLmRlZmF1bHRPcHRpb25zLFxuICAuLi5TdGFydHVwU3lzdGVtLmRlZmF1bHRPcHRpb25zXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgV1JBUF9NT0RFXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLldSQVBfTU9ERVN9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZVxuICAgKi9cbiAgV1JBUF9NT0RFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLndyYXBNb2RlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuV1JBUF9NT0RFIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZVwiKSwgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMud3JhcE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFNDQUxFX01PREVcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuU0NBTEVfTU9ERVN9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGVcbiAgICovXG4gIFNDQUxFX01PREU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU0NBTEVfTU9ERSBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlXCIpLCBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIE1JUE1BUF9URVhUVVJFU1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5NSVBNQVBfTU9ERVN9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXBcbiAgICovXG4gIE1JUE1BUF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXA7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMgaXMgZGVwcmVjYXRlZCwgdXNlIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcFwiKSwgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMubWlwbWFwID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIE1JUE1BUF9NT0RFUy5QT1cyLFxuICB9LFxuICAvKipcbiAgICogQHN0YXRpY1xuICAgKiBAbmFtZSBBTklTT1RST1BJQ19MRVZFTFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbFxuICAgKi9cbiAgQU5JU09UUk9QSUNfTEVWRUw6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXG4gICAgICAgIFwiNy4xLjBcIixcbiAgICAgICAgXCJzZXR0aW5ncy5BTklTT1RST1BJQ19MRVZFTCBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbFwiXG4gICAgICApLCBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRGVmYXVsdCBmaWx0ZXIgcmVzb2x1dGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAbmFtZSBGSUxURVJfUkVTT0xVVElPTlxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAqIEBzZWUgUElYSS5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb25cbiAgICovXG4gIEZJTFRFUl9SRVNPTFVUSU9OOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTiBpcyBkZXByZWNhdGVkLCB1c2UgRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uXCIpLCBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb247XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIERlZmF1bHQgZmlsdGVyIHNhbXBsZXMuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgRklMVEVSX01VTFRJU0FNUExFXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEB0eXBlIHtQSVhJLk1TQUFfUVVBTElUWX1cbiAgICogQHNlZSBQSVhJLkZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGVcbiAgICovXG4gIEZJTFRFUl9NVUxUSVNBTVBMRToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuRklMVEVSX01VTFRJU0FNUExFIGlzIGRlcHJlY2F0ZWQsIHVzZSBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlXCIpLCBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGV4dHVyZXMgdGhhdCB0aGlzIGRldmljZSBzdXBwb3J0cy5cbiAgICogQHN0YXRpY1xuICAgKiBAbmFtZSBTUFJJVEVfTUFYX1RFWFRVUkVTXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXRjaFJlbmRlcmVyLmRlZmF1bHRNYXhUZXh0dXJlc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgU1BSSVRFX01BWF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLmRlZmF1bHRNYXhUZXh0dXJlcztcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMgaXMgZGVwcmVjYXRlZCwgdXNlIEJhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzXCIpLCBCYXRjaFJlbmRlcmVyLmRlZmF1bHRNYXhUZXh0dXJlcyA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHNwcml0ZSBiYXRjaCBzaXplLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBhaW1zIHRvIGJhbGFuY2UgZGVza3RvcCBhbmQgbW9iaWxlIGRldmljZXMuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgU1BSSVRFX0JBVENIX1NJWkVcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHNlZSBQSVhJLkJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgU1BSSVRFX0JBVENIX1NJWkU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU1BSSVRFX0JBVENIX1NJWkUgaXMgZGVwcmVjYXRlZCwgdXNlIEJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZVwiKSwgQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQ2FuIHdlIHVwbG9hZCB0aGUgc2FtZSBidWZmZXIgaW4gYSBzaW5nbGUgZnJhbWU/XG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUlxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAc2VlIFBJWEkuQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUjoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXI7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXJcIiksIEJhdGNoUmVuZGVyZXIuY2FuVXBsb2FkU2FtZUJ1ZmZlciA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1vZGUuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgR0NfTU9ERVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5HQ19NT0RFU31cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLlRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZVxuICAgKi9cbiAgR0NfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5HQ19NT0RFIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGVcIiksIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1heCBpZGxlLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIEdDX01BWF9JRExFXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGVcbiAgICovXG4gIEdDX01BWF9JRExFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkdDX01BWF9JRExFIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGVcIiksIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1heGltdW0gY2hlY2sgY291bnQuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgR0NfTUFYX0NIRUNLX0NPVU5UXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXhcbiAgICovXG4gIEdDX01BWF9DSEVDS19DT1VOVDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXg7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5HQ19NQVhfQ0hFQ0tfQ09VTlQgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0Q2hlY2tDb3VudE1heFwiKSwgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4ID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRGVmYXVsdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFBSRUNJU0lPTl9WRVJURVhcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuUFJFQ0lTSU9OfVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uXG4gICAqL1xuICBQUkVDSVNJT05fVkVSVEVYOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFByb2dyYW0uZGVmYXVsdFZlcnRleFByZWNpc2lvbjtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlBSRUNJU0lPTl9WRVJURVggaXMgZGVwcmVjYXRlZCwgdXNlIFByb2dyYW0uZGVmYXVsdFZlcnRleFByZWNpc2lvblwiKSwgUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRGVmYXVsdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBmcmFnbWVudCBzaGFkZXIuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgUFJFQ0lTSU9OX0ZSQUdNRU5UXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLlBSRUNJU0lPTn1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLlByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uXG4gICAqL1xuICBQUkVDSVNJT05fRlJBR01FTlQ6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRQcmVjaXNpb247XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5QUkVDSVNJT05fRlJBR01FTlQgaXMgZGVwcmVjYXRlZCwgdXNlIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uXCIpLCBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJ2YXIgVVBEQVRFX1BSSU9SSVRZID0gLyogQF9fUFVSRV9fICovICgoVVBEQVRFX1BSSU9SSVRZMikgPT4gKFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMi5JTlRFUkFDVElPTiA9IDUwXSA9IFwiSU5URVJBQ1RJT05cIiwgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyLkhJR0ggPSAyNV0gPSBcIkhJR0hcIiwgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyLk5PUk1BTCA9IDBdID0gXCJOT1JNQUxcIiwgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyLkxPVyA9IC0yNV0gPSBcIkxPV1wiLCBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTIuVVRJTElUWSA9IC01MF0gPSBcIlVUSUxJVFlcIiwgVVBEQVRFX1BSSU9SSVRZMikpKFVQREFURV9QUklPUklUWSB8fCB7fSk7XG5leHBvcnQge1xuICBVUERBVEVfUFJJT1JJVFlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJjbGFzcyBUaWNrZXJMaXN0ZW5lciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAqIEBwYXJhbSBvbmNlIC0gSWYgdGhlIGhhbmRsZXIgc2hvdWxkIGZpcmUgb25jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZm4sIGNvbnRleHQgPSBudWxsLCBwcmlvcml0eSA9IDAsIG9uY2UgPSAhMSkge1xuICAgIHRoaXMubmV4dCA9IG51bGwsIHRoaXMucHJldmlvdXMgPSBudWxsLCB0aGlzLl9kZXN0cm95ZWQgPSAhMSwgdGhpcy5mbiA9IGZuLCB0aGlzLmNvbnRleHQgPSBjb250ZXh0LCB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHksIHRoaXMub25jZSA9IG9uY2U7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXBsZSBjb21wYXJlIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgYSBmdW5jdGlvbiBhbmQgY29udGV4dCBtYXRjaC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBsaXN0ZW5lciBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAqL1xuICBtYXRjaChmbiwgY29udGV4dCA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5mbiA9PT0gZm4gJiYgdGhpcy5jb250ZXh0ID09PSBjb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGJ5IGNhbGxpbmcgdGhlIGN1cnJlbnQgZnVuY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSB0aW1lIHNpbmNlIHRoZSBsYXN0IGVtaXQuXG4gICAqIEByZXR1cm5zIE5leHQgdGlja2VyXG4gICAqL1xuICBlbWl0KGRlbHRhVGltZSkge1xuICAgIHRoaXMuZm4gJiYgKHRoaXMuY29udGV4dCA/IHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSkgOiB0aGlzLmZuKGRlbHRhVGltZSkpO1xuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIHJldHVybiB0aGlzLm9uY2UgJiYgdGhpcy5kZXN0cm95KCEwKSwgdGhpcy5fZGVzdHJveWVkICYmICh0aGlzLm5leHQgPSBudWxsKSwgcmVkaXJlY3Q7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gdGhlIGxpc3QuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBwcmV2aW91cyAtIElucHV0IG5vZGUsIHByZXZpb3VzIGxpc3RlbmVyXG4gICAqL1xuICBjb25uZWN0KHByZXZpb3VzKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzLCBwcmV2aW91cy5uZXh0ICYmIChwcmV2aW91cy5uZXh0LnByZXZpb3VzID0gdGhpcyksIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQsIHByZXZpb3VzLm5leHQgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGhhcmQgLSBgdHJ1ZWAgdG8gcmVtb3ZlIHRoZSBgbmV4dGAgcmVmZXJlbmNlLCB0aGlzXG4gICAqICAgICAgICBpcyBjb25zaWRlcmVkIGEgaGFyZCBkZXN0cm95LiBTb2Z0IGRlc3Ryb3kgbWFpbnRhaW5zIHRoZSBuZXh0IHJlZmVyZW5jZS5cbiAgICogQHJldHVybnMgVGhlIGxpc3RlbmVyIHRvIHJlZGlyZWN0IHdoaWxlIGVtaXR0aW5nIG9yIHJlbW92aW5nLlxuICAgKi9cbiAgZGVzdHJveShoYXJkID0gITEpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSAhMCwgdGhpcy5mbiA9IG51bGwsIHRoaXMuY29udGV4dCA9IG51bGwsIHRoaXMucHJldmlvdXMgJiYgKHRoaXMucHJldmlvdXMubmV4dCA9IHRoaXMubmV4dCksIHRoaXMubmV4dCAmJiAodGhpcy5uZXh0LnByZXZpb3VzID0gdGhpcy5wcmV2aW91cyk7XG4gICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG4gICAgcmV0dXJuIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3QsIHRoaXMucHJldmlvdXMgPSBudWxsLCByZWRpcmVjdDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVGlja2VyTGlzdGVuZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJMaXN0ZW5lci5tanMubWFwXG4iLCJpbXBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tIFwiLi9jb25zdC5tanNcIjtcbmltcG9ydCB7IFRpY2tlckxpc3RlbmVyIH0gZnJvbSBcIi4vVGlja2VyTGlzdGVuZXIubWpzXCI7XG5jb25zdCBfVGlja2VyID0gY2xhc3MgX1RpY2tlcjIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmF1dG9TdGFydCA9ICExLCB0aGlzLmRlbHRhVGltZSA9IDEsIHRoaXMubGFzdFRpbWUgPSAtMSwgdGhpcy5zcGVlZCA9IDEsIHRoaXMuc3RhcnRlZCA9ICExLCB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsLCB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxMDAsIHRoaXMuX21pbkVsYXBzZWRNUyA9IDAsIHRoaXMuX3Byb3RlY3RlZCA9ICExLCB0aGlzLl9sYXN0RnJhbWUgPSAtMSwgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcihudWxsLCBudWxsLCAxIC8gMCksIHRoaXMuZGVsdGFNUyA9IDEgLyBfVGlja2VyMi50YXJnZXRGUE1TLCB0aGlzLmVsYXBzZWRNUyA9IDEgLyBfVGlja2VyMi50YXJnZXRGUE1TLCB0aGlzLl90aWNrID0gKHRpbWUpID0+IHtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGwsIHRoaXMuc3RhcnRlZCAmJiAodGhpcy51cGRhdGUodGltZSksIHRoaXMuc3RhcnRlZCAmJiB0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0ICYmICh0aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljaykpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cbiAgICogSWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWxcbiAgICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVxdWVzdElmTmVlZGVkKCkge1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9PT0gbnVsbCAmJiB0aGlzLl9oZWFkLm5leHQgJiYgKHRoaXMubGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSwgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5sYXN0VGltZSwgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spKTtcbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSBjYW5jZWxzIGEgcGVuZGluZyBhbmltYXRpb24gZnJhbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FuY2VsSWZOZWVkZWQoKSB7XG4gICAgdGhpcy5fcmVxdWVzdElkICE9PSBudWxsICYmIChjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXF1ZXN0SWQpLCB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAqIElmIHRoZSB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZCBpdCBjaGVja3MgaWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHlcbiAgICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxuICAgKiBjb25kaXRpb25zIGFyZSBtZXQsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC4gSWYgdGhlIHRpY2tlciBoYXMgbm90XG4gICAqIGJlZW4gc3RhcnRlZCwgYnV0IGF1dG9TdGFydCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRpY2tlciBzdGFydHMgbm93LFxuICAgKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydElmUG9zc2libGUoKSB7XG4gICAgdGhpcy5zdGFydGVkID8gdGhpcy5fcmVxdWVzdElmTmVlZGVkKCkgOiB0aGlzLmF1dG9TdGFydCAmJiB0aGlzLnN0YXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgdGljayBldmVudHMuIENhbGxzIGNvbnRpbnVvdXNseSB1bmxlc3NcbiAgICogaXQgaXMgcmVtb3ZlZCBvciB0aGUgdGlja2VyIGlzIHN0b3BwZWQuXG4gICAqIEBwYXJhbSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3IgdXBkYXRlc1xuICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9UElYSS5VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgYWRkKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IFVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSkpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciB0aGUgdGljayBldmVudCB3aGljaCBpcyBvbmx5IGV4ZWN1dGUgb25jZS5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1QSVhJLlVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAqL1xuICBhZGRPbmNlKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IFVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgITApKTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWxseSBhZGRzIHRoZSBldmVudCBoYW5kbGVyIHNvIHRoYXQgaXQgY2FuIGJlIHNvcnRlZCBieSBwcmlvcml0eS5cbiAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cbiAgICogYmVmb3JlIHRoZSByZW5kZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEN1cnJlbnQgbGlzdGVuZXIgYmVpbmcgYWRkZWQuXG4gICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICovXG4gIF9hZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZC5uZXh0LCBwcmV2aW91cyA9IHRoaXMuX2hlYWQ7XG4gICAgaWYgKCFjdXJyZW50KVxuICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKDsgY3VycmVudDsgKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmlvcml0eSA+IGN1cnJlbnQucHJpb3JpdHkpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQsIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lci5wcmV2aW91cyB8fCBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSBoYW5kbGVycyBtYXRjaGluZyB0aGUgZnVuY3Rpb24gYW5kIGNvbnRleHQgcGFyYW1ldGVycy5cbiAgICogSWYgbm8gaGFuZGxlcnMgYXJlIGxlZnQgYWZ0ZXIgcmVtb3ZpbmcsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgcmVtb3ZlKGZuLCBjb250ZXh0KSB7XG4gICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIGZvciAoOyBsaXN0ZW5lcjsgKVxuICAgICAgbGlzdGVuZXIubWF0Y2goZm4sIGNvbnRleHQpID8gbGlzdGVuZXIgPSBsaXN0ZW5lci5kZXN0cm95KCkgOiBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQubmV4dCB8fCB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvbiB0aGlzIHRpY2tlciwgY2FsY3VsYXRlZCBieSB3YWxraW5nIHRocm91Z2ggbGlua2VkIGxpc3RcbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX2hlYWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBsZXQgY291bnQgPSAwLCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICBmb3IgKDsgY3VycmVudCA9IGN1cnJlbnQubmV4dDsgKVxuICAgICAgY291bnQrKztcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgLyoqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZCBhdCB0aGlzIHBvaW50LiAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgfHwgKHRoaXMuc3RhcnRlZCA9ICEwLCB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKSk7XG4gIH1cbiAgLyoqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZCBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC4gKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgJiYgKHRoaXMuc3RhcnRlZCA9ICExLCB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpKTtcbiAgfVxuICAvKiogRGVzdHJveSB0aGUgdGlja2VyIGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gQ2FsbGluZyB0aGlzIG1ldGhvZCByZW1vdmVzIGFsbCByZWZlcmVuY2VzIHRvIGludGVybmFsIGV2ZW50cy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuX3Byb3RlY3RlZCkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgICBmb3IgKDsgbGlzdGVuZXI7IClcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5kZXN0cm95KCEwKTtcbiAgICAgIHRoaXMuX2hlYWQuZGVzdHJveSgpLCB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAgICogY3VycmVudCB7QGxpbmsgUElYSS5UaWNrZXIjZWxhcHNlZE1TfSxcbiAgICogdGhlIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0sXG4gICAqIGludm9raW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCBjdXJyZW50IGRlbHRhVGltZSxcbiAgICogYW5kIHRoZW4gZmluYWxseSBzZXR0aW5nIHtAbGluayBQSVhJLlRpY2tlciNsYXN0VGltZX1cbiAgICogd2l0aCB0aGUgdmFsdWUgb2YgY3VycmVudFRpbWUgdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAqIGZyYW1lIGNhbGxiYWNrcyBpZiB0aGUgdGlja2VyIGluc3RhbmNlIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICogYW5kIGxpc3RlbmVycyBhcmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFRpbWU9cGVyZm9ybWFuY2Uubm93KCldIC0gdGhlIGN1cnJlbnQgdGltZSBvZiBleGVjdXRpb25cbiAgICovXG4gIHVwZGF0ZShjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgbGV0IGVsYXBzZWRNUztcbiAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICBpZiAoZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsIGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUyAmJiAoZWxhcHNlZE1TID0gdGhpcy5fbWF4RWxhcHNlZE1TKSwgZWxhcHNlZE1TICo9IHRoaXMuc3BlZWQsIHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fbGFzdEZyYW1lIHwgMDtcbiAgICAgICAgaWYgKGRlbHRhIDwgdGhpcy5fbWluRWxhcHNlZE1TKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSBkZWx0YSAlIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUywgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgKiBfVGlja2VyMi50YXJnZXRGUE1TO1xuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBsZXQgbGlzdGVuZXIgPSBoZWFkLm5leHQ7XG4gICAgICBmb3IgKDsgbGlzdGVuZXI7IClcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcbiAgICAgIGhlYWQubmV4dCB8fCB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgPSB0aGlzLmVsYXBzZWRNUyA9IDA7XG4gICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZnJhbWVzIHBlciBzZWNvbmQgYXQgd2hpY2ggdGhpcyB0aWNrZXIgaXMgcnVubmluZy5cbiAgICogVGhlIGRlZmF1bHQgaXMgYXBwcm94aW1hdGVseSA2MCBpbiBtb3N0IG1vZGVybiBicm93c2Vycy5cbiAgICogKipOb3RlOioqIFRoaXMgZG9lcyBub3QgZmFjdG9yIGluIHRoZSB2YWx1ZSBvZlxuICAgKiB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LCB3aGljaCBpcyBzcGVjaWZpY1xuICAgKiB0byBzY2FsaW5nIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IEZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5lbGFwc2VkTVM7XG4gIH1cbiAgLyoqXG4gICAqIE1hbmFnZXMgdGhlIG1heGltdW0gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyBhbGxvd2VkIHRvXG4gICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxuICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgKiBidXQgZG9lcyBub3QgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS5UaWNrZXIjRlBTfS5cbiAgICogV2hlbiBzZXR0aW5nIHRoaXMgcHJvcGVydHkgaXQgaXMgY2xhbXBlZCB0byBhIHZhbHVlIGJldHdlZW5cbiAgICogYDBgIGFuZCBgVGlja2VyLnRhcmdldEZQTVMgKiAxMDAwYC5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMFxuICAgKi9cbiAgZ2V0IG1pbkZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICB9XG4gIHNldCBtaW5GUFMoZnBzKSB7XG4gICAgY29uc3QgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyksIG1pbkZQTVMgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtaW5GUFMpIC8gMWUzLCBfVGlja2VyMi50YXJnZXRGUE1TKTtcbiAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxIC8gbWluRlBNUztcbiAgfVxuICAvKipcbiAgICogTWFuYWdlcyB0aGUgbWluaW11bSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHJlcXVpcmVkIHRvXG4gICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxuICAgKiBUaGlzIHdpbGwgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS5UaWNrZXIjRlBTfS5cbiAgICogSWYgaXQgaXMgc2V0IHRvIGAwYCwgdGhlbiB0aGVyZSBpcyBubyBsaW1pdDsgUGl4aUpTIHdpbGwgcmVuZGVyIGFzIG1hbnkgZnJhbWVzIGFzIGl0IGNhbi5cbiAgICogT3RoZXJ3aXNlIGl0IHdpbGwgYmUgYXQgbGVhc3QgYG1pbkZQU2BcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgbWF4RlBTKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5FbGFwc2VkTVMgPyBNYXRoLnJvdW5kKDFlMyAvIHRoaXMuX21pbkVsYXBzZWRNUykgOiAwO1xuICB9XG4gIHNldCBtYXhGUFMoZnBzKSB7XG4gICAgaWYgKGZwcyA9PT0gMClcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBtYXhGUFMgPSBNYXRoLm1heCh0aGlzLm1pbkZQUywgZnBzKTtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyAobWF4RlBTIC8gMWUzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuQW5pbWF0ZWRTcHJpdGV9IGFuZCBieVxuICAgKiB7QGxpbmsgUElYSS5WaWRlb1Jlc291cmNlfSB0byB1cGRhdGUgYW5pbWF0aW9uIGZyYW1lcyAvIHZpZGVvIHRleHR1cmVzLlxuICAgKlxuICAgKiBJdCBtYXkgYWxzbyBiZSB1c2VkIGJ5IHtAbGluayBQSVhJLkFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogVGhlIHByb3BlcnR5IHtAbGluayBQSVhJLlRpY2tlciNhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWAgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFRpY2tlciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCB0aWNrZXIgPSBUaWNrZXIuc2hhcmVkO1xuICAgKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAgICogLy8gQnkgZGVmYXVsdCB0aGlzIGlzIHRydWUgb25seSBmb3IgdGhlIFBJWEkuVGlja2VyLnNoYXJlZCBpbnN0YW5jZS5cbiAgICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgKlxuICAgKiAvLyBGWUksIGNhbGwgdGhpcyB0byBlbnN1cmUgdGhlIHRpY2tlciBpcyBzdG9wcGVkLiBJdCBzaG91bGQgYmUgc3RvcHBlZFxuICAgKiAvLyBpZiB5b3UgaGF2ZSBub3QgYXR0ZW1wdGVkIHRvIHJlbmRlciBhbnl0aGluZyB5ZXQuXG4gICAqIHRpY2tlci5zdG9wKCk7XG4gICAqXG4gICAqIC8vIENhbGwgdGhpcyB3aGVuIHlvdSBhcmUgcmVhZHkgZm9yIGEgcnVubmluZyBzaGFyZWQgdGlja2VyLlxuICAgKiB0aWNrZXIuc3RhcnQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgYXV0b0RldGVjdFJlbmRlcmVyLCBDb250YWluZXIgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogLy8gWW91IG1heSB1c2UgdGhlIHNoYXJlZCB0aWNrZXIgdG8gcmVuZGVyLi4uXG4gICAqIGNvbnN0IHJlbmRlcmVyID0gYXV0b0RldGVjdFJlbmRlcmVyKCk7XG4gICAqIGNvbnN0IHN0YWdlID0gbmV3IENvbnRhaW5lcigpO1xuICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLnZpZXcpO1xuICAgKiB0aWNrZXIuYWRkKCh0aW1lKSA9PiByZW5kZXJlci5yZW5kZXIoc3RhZ2UpKTtcbiAgICpcbiAgICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cbiAgICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgKiB0aWNrZXIuc3RvcCgpO1xuICAgKiBjb25zdCBhbmltYXRlID0gKHRpbWUpID0+IHtcbiAgICogICAgIHRpY2tlci51cGRhdGUodGltZSk7XG4gICAqICAgICByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICAgKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgKiB9O1xuICAgKiBhbmltYXRlKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2hhcmVkKCkge1xuICAgIGlmICghX1RpY2tlcjIuX3NoYXJlZCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gX1RpY2tlcjIuX3NoYXJlZCA9IG5ldyBfVGlja2VyMigpO1xuICAgICAgc2hhcmVkLmF1dG9TdGFydCA9ICEwLCBzaGFyZWQuX3Byb3RlY3RlZCA9ICEwO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlcjIuX3NoYXJlZDtcbiAgfVxuICAvKipcbiAgICogVGhlIHN5c3RlbSB0aWNrZXIgaW5zdGFuY2UgdXNlZCBieSB7QGxpbmsgUElYSS5CYXNlUHJlcGFyZX0gZm9yIGNvcmUgdGltaW5nXG4gICAqIGZ1bmN0aW9uYWxpdHkgdGhhdCBzaG91bGRuJ3QgdXN1YWxseSBuZWVkIHRvIGJlIHBhdXNlZCwgdW5saWtlIHRoZSBgc2hhcmVkYFxuICAgKiB0aWNrZXIgd2hpY2ggZHJpdmVzIHZpc3VhbCBhbmltYXRpb25zIGFuZCByZW5kZXJpbmcgd2hpY2ggbWF5IHdhbnQgdG8gYmUgcGF1c2VkLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgIGlmICghX1RpY2tlcjIuX3N5c3RlbSkge1xuICAgICAgY29uc3Qgc3lzdGVtID0gX1RpY2tlcjIuX3N5c3RlbSA9IG5ldyBfVGlja2VyMigpO1xuICAgICAgc3lzdGVtLmF1dG9TdGFydCA9ICEwLCBzeXN0ZW0uX3Byb3RlY3RlZCA9ICEwO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlcjIuX3N5c3RlbTtcbiAgfVxufTtcbl9UaWNrZXIudGFyZ2V0RlBNUyA9IDAuMDY7XG5sZXQgVGlja2VyID0gX1RpY2tlcjtcbmV4cG9ydCB7XG4gIFRpY2tlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpY2tlci5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgc2V0dGluZ3MgYXMgc2V0dGluZ3MyIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gXCJAcGl4aS91dGlsc1wiO1xuaW1wb3J0IHsgVGlja2VyIH0gZnJvbSBcIi4vVGlja2VyLm1qc1wiO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgLyoqXG4gICAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFRBUkdFVF9GUE1TXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5UaWNrZXIudGFyZ2V0RlBNU1xuICAgKi9cbiAgVEFSR0VUX0ZQTVM6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGlja2VyLnRhcmdldEZQTVM7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5UQVJHRVRfRlBNUyBpcyBkZXByZWNhdGVkLCB1c2UgVGlja2VyLnRhcmdldEZQTVNcIiksIFRpY2tlci50YXJnZXRGUE1TID0gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcbmV4cG9ydCB7XG4gIHNldHRpbmdzMiBhcyBzZXR0aW5nc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSBcIi4vY29uc3QubWpzXCI7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tIFwiLi9UaWNrZXIubWpzXCI7XG5jbGFzcyBUaWNrZXJQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhdXRvU3RhcnQ6ICEwLFxuICAgICAgc2hhcmVkVGlja2VyOiAhMVxuICAgIH0sIG9wdGlvbnMpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJ0aWNrZXJcIixcbiAgICAgIHtcbiAgICAgICAgc2V0KHRpY2tlcikge1xuICAgICAgICAgIHRoaXMuX3RpY2tlciAmJiB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKSwgdGhpcy5fdGlja2VyID0gdGlja2VyLCB0aWNrZXIgJiYgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcywgVVBEQVRFX1BSSU9SSVRZLkxPVyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKSwgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGlja2VyLnN0b3AoKTtcbiAgICB9LCB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGlja2VyLnN0YXJ0KCk7XG4gICAgfSwgdGhpcy5fdGlja2VyID0gbnVsbCwgdGhpcy50aWNrZXIgPSBvcHRpb25zLnNoYXJlZFRpY2tlciA/IFRpY2tlci5zaGFyZWQgOiBuZXcgVGlja2VyKCksIG9wdGlvbnMuYXV0b1N0YXJ0ICYmIHRoaXMuc3RhcnQoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIHRpY2tlciwgc2NvcGVkIHRvIGFwcGxpY2F0aW9uLlxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fdGlja2VyKSB7XG4gICAgICBjb25zdCBvbGRUaWNrZXIgPSB0aGlzLl90aWNrZXI7XG4gICAgICB0aGlzLnRpY2tlciA9IG51bGwsIG9sZFRpY2tlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG5leHBvcnQge1xuICBUaWNrZXJQbHVnaW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IFwiLi9zZXR0aW5ncy5tanNcIjtcbmltcG9ydCB7IFVQREFURV9QUklPUklUWSB9IGZyb20gXCIuL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgVGlja2VyIH0gZnJvbSBcIi4vVGlja2VyLm1qc1wiO1xuaW1wb3J0IHsgVGlja2VyUGx1Z2luIH0gZnJvbSBcIi4vVGlja2VyUGx1Z2luLm1qc1wiO1xuZXhwb3J0IHtcbiAgVGlja2VyLFxuICBUaWNrZXJQbHVnaW4sXG4gIFVQREFURV9QUklPUklUWVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuY29uc3QgcmVuZGVyZXJzID0gW107XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLlJlbmRlcmVyLCByZW5kZXJlcnMpO1xuZnVuY3Rpb24gYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBSZW5kZXJlclR5cGUgb2YgcmVuZGVyZXJzKVxuICAgIGlmIChSZW5kZXJlclR5cGUudGVzdChvcHRpb25zKSlcbiAgICAgIHJldHVybiBuZXcgUmVuZGVyZXJUeXBlKG9wdGlvbnMpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYXV0by1kZXRlY3QgYSBzdWl0YWJsZSByZW5kZXJlci5cIik7XG59XG5leHBvcnQge1xuICBhdXRvRGV0ZWN0UmVuZGVyZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvRGV0ZWN0UmVuZGVyZXIubWpzLm1hcFxuIiwidmFyICRkZWZhdWx0VmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG59YDtcbmV4cG9ydCB7XG4gICRkZWZhdWx0VmVydGV4IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LnZlcnQubWpzLm1hcFxuIiwidmFyICRkZWZhdWx0RmlsdGVyVmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xuXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcbntcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcblxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbn1cblxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxue1xuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xufVxuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xufVxuYDtcbmV4cG9ydCB7XG4gICRkZWZhdWx0RmlsdGVyVmVydGV4IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RmlsdGVyLnZlcnQubWpzLm1hcFxuIiwiaW1wb3J0ICRkZWZhdWx0VmVydGV4IGZyb20gXCIuL2RlZmF1bHQudmVydC5tanNcIjtcbmltcG9ydCAkZGVmYXVsdEZpbHRlclZlcnRleCBmcm9tIFwiLi9kZWZhdWx0RmlsdGVyLnZlcnQubWpzXCI7XG5jb25zdCBkZWZhdWx0VmVydGV4ID0gJGRlZmF1bHRWZXJ0ZXgsIGRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSAkZGVmYXVsdEZpbHRlclZlcnRleDtcbmV4cG9ydCB7XG4gIGRlZmF1bHRGaWx0ZXJWZXJ0ZXgsXG4gIGRlZmF1bHRWZXJ0ZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBNU0FBX1FVQUxJVFkgfSBmcm9tIFwiQHBpeGkvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmNsYXNzIE11bHRpc2FtcGxlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgY29udGV4dENoYW5nZShnbCkge1xuICAgIGxldCBzYW1wbGVzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmdldFBhcmFtZXRlcihnbC5GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCksIHNhbXBsZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0FNUExFUyksIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmdldFBhcmFtZXRlcihnbC5EUkFXX0ZSQU1FQlVGRkVSX0JJTkRJTkcpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwpLCBzYW1wbGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNBTVBMRVMpLCBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICBzYW1wbGVzID49IE1TQUFfUVVBTElUWS5ISUdIID8gdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5ISUdIIDogc2FtcGxlcyA+PSBNU0FBX1FVQUxJVFkuTUVESVVNID8gdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5NRURJVU0gOiBzYW1wbGVzID49IE1TQUFfUVVBTElUWS5MT1cgPyB0aGlzLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLkxPVyA6IHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5NdWx0aXNhbXBsZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiX211bHRpc2FtcGxlXCJcbn07XG5leHRlbnNpb25zLmFkZChNdWx0aXNhbXBsZVN5c3RlbSk7XG5leHBvcnQge1xuICBNdWx0aXNhbXBsZVN5c3RlbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpc2FtcGxlU3lzdGVtLm1qcy5tYXBcbiIsImNsYXNzIEdMQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIgfHwgbnVsbCwgdGhpcy51cGRhdGVJRCA9IC0xLCB0aGlzLmJ5dGVMZW5ndGggPSAtMSwgdGhpcy5yZWZDb3VudCA9IDA7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEdMQnVmZmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xCdWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9leHRlbnNpb25zXCI7XG5pbXBvcnQgeyBHTEJ1ZmZlciB9IGZyb20gXCIuL0dMQnVmZmVyLm1qc1wiO1xuY2xhc3MgQnVmZmVyU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMubWFuYWdlZEJ1ZmZlcnMgPSB7fSwgdGhpcy5ib3VuZEJ1ZmZlckJhc2VzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgLyoqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLiAqL1xuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZGlzcG9zZUFsbCghMCksIHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsLCB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgfVxuICAvKipcbiAgICogVGhpcyBiaW5kcyBzcGVjaWZpZWQgYnVmZmVyLiBPbiBmaXJzdCBydW4sIGl0IHdpbGwgY3JlYXRlIHRoZSB3ZWJHTCBidWZmZXJzIGZvciB0aGUgY29udGV4dCB0b29cbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmluZCB0byB0aGUgcmVuZGVyZXJcbiAgICovXG4gIGJpbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXMsIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyKGJ1ZmZlci50eXBlLCBnbEJ1ZmZlci5idWZmZXIpO1xuICB9XG4gIHVuYmluZCh0eXBlKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBhbiB1bmlmb3JtIGJ1ZmZlciB0byBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEEgY2FjaGUgaXMgdXNlZCBzbyBhIGJ1ZmZlciB3aWxsIG5vdCBiZSBib3VuZCBhZ2FpbiBpZiBhbHJlYWR5IGJvdW5kLlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0byBiaW5kXG4gICAqIEBwYXJhbSBpbmRleCAtIHRoZSBiYXNlIGluZGV4IHRvIGJpbmQgaXQgdG8uXG4gICAqL1xuICBiaW5kQnVmZmVyQmFzZShidWZmZXIsIGluZGV4KSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuYm91bmRCdWZmZXJCYXNlc1tpbmRleF0gIT09IGJ1ZmZlcikge1xuICAgICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgICAgdGhpcy5ib3VuZEJ1ZmZlckJhc2VzW2luZGV4XSA9IGJ1ZmZlciwgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4LCBnbEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQmluZHMgYSBidWZmZXIgd2hpbHN0IGFsc28gYmluZGluZyBpdHMgcmFuZ2UuXG4gICAqIFRoaXMgd2lsbCBtYWtlIHRoZSBidWZmZXIgc3RhcnQgZnJvbSB0aGUgb2Zmc2V0IHN1cHBsaWVkIHJhdGhlciB0aGFuIDAgd2hlbiBpdCBpcyByZWFkLlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0byBiaW5kXG4gICAqIEBwYXJhbSBpbmRleCAtIHRoZSBiYXNlIGluZGV4IHRvIGJpbmQgYXQsIGRlZmF1bHRzIHRvIDBcbiAgICogQHBhcmFtIG9mZnNldCAtIHRoZSBvZmZzZXQgdG8gYmluZCBhdCAodGhpcyBpcyBibG9ja3Mgb2YgMjU2KS4gMCA9IDAsIDEgPSAyNTYsIDIgPSA1MTIgZXRjXG4gICAqL1xuICBiaW5kQnVmZmVyUmFuZ2UoYnVmZmVyLCBpbmRleCwgb2Zmc2V0KSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXJSYW5nZShnbC5VTklGT1JNX0JVRkZFUiwgaW5kZXggfHwgMCwgZ2xCdWZmZXIuYnVmZmVyLCBvZmZzZXQgKiAyNTYsIDI1Nik7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgZW5zdXJlIHRoZSBkYXRhIGluIHRoZSBidWZmZXIgaXMgdXBsb2FkZWQgdG8gdGhlIEdQVS5cbiAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcn0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0byB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZShidWZmZXIpIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcywgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgIGlmIChidWZmZXIuX3VwZGF0ZUlEICE9PSBnbEJ1ZmZlci51cGRhdGVJRClcbiAgICAgIGlmIChnbEJ1ZmZlci51cGRhdGVJRCA9IGJ1ZmZlci5fdXBkYXRlSUQsIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGdsQnVmZmVyLmJ1ZmZlciksIGdsQnVmZmVyLmJ5dGVMZW5ndGggPj0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aClcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgMCwgYnVmZmVyLmRhdGEpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRyYXdUeXBlID0gYnVmZmVyLnN0YXRpYyA/IGdsLlNUQVRJQ19EUkFXIDogZ2wuRFlOQU1JQ19EUkFXO1xuICAgICAgICBnbEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aCwgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnVmZmVyLmRhdGEsIGRyYXdUeXBlKTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgYnVmZmVyXG4gICAqIEBwYXJhbSB7UElYSS5CdWZmZXJ9IGJ1ZmZlciAtIGJ1ZmZlciB3aXRoIGRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIC0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgZGVsZXRlVmVydGV4QXJyYXlcbiAgICovXG4gIGRpc3Bvc2UoYnVmZmVyLCBjb250ZXh0TG9zdCkge1xuICAgIGlmICghdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdKVxuICAgICAgcmV0dXJuO1xuICAgIGRlbGV0ZSB0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF07XG4gICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSwgZ2wgPSB0aGlzLmdsO1xuICAgIGJ1ZmZlci5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKSwgZ2xCdWZmZXIgJiYgKGNvbnRleHRMb3N0IHx8IGdsLmRlbGV0ZUJ1ZmZlcihnbEJ1ZmZlci5idWZmZXIpLCBkZWxldGUgYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0pO1xuICB9XG4gIC8qKlxuICAgKiBkaXNwb3NlIGFsbCBXZWJHTCByZXNvdXJjZXMgb2YgYWxsIG1hbmFnZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gLSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBgZ2wuZGVsZXRlYCBjYWxsc1xuICAgKi9cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEJ1ZmZlcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5kaXNwb3NlKHRoaXMubWFuYWdlZEJ1ZmZlcnNbYWxsW2ldXSwgY29udGV4dExvc3QpO1xuICB9XG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuZCBhdHRhY2hlcyBhIEdMQnVmZmVyIG9iamVjdCB0aWVkIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAqIEBwYXJhbSBidWZmZXJcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlR0xCdWZmZXIoYnVmZmVyKSB7XG4gICAgY29uc3QgeyBDT05URVhUX1VJRCwgZ2wgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSA9IG5ldyBHTEJ1ZmZlcihnbC5jcmVhdGVCdWZmZXIoKSksIHRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSA9IGJ1ZmZlciwgYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpLCBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF07XG4gIH1cbn1cbkJ1ZmZlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiYnVmZmVyXCJcbn07XG5leHRlbnNpb25zLmFkZChCdWZmZXJTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgQnVmZmVyU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuY2xhc3MgT2JqZWN0UmVuZGVyZXJTeXN0ZW0ge1xuICAvLyByZW5kZXJlcnMgc2NlbmUgZ3JhcGghXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gaXRzIFdlYkdMIHZpZXcuXG4gICAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSByZW5kZXJlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlcmVyXG4gICAqL1xuICByZW5kZXIoZGlzcGxheU9iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgcmVuZGVyVGV4dHVyZSwgY2xlYXIsIHRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybTtcbiAgICBpZiAob3B0aW9ucyAmJiAocmVuZGVyVGV4dHVyZSA9IG9wdGlvbnMucmVuZGVyVGV4dHVyZSwgY2xlYXIgPSBvcHRpb25zLmNsZWFyLCB0cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSA9IG9wdGlvbnMuc2tpcFVwZGF0ZVRyYW5zZm9ybSksIHRoaXMucmVuZGVyaW5nVG9TY3JlZW4gPSAhcmVuZGVyVGV4dHVyZSwgcmVuZGVyZXIucnVubmVycy5wcmVyZW5kZXIuZW1pdCgpLCByZW5kZXJlci5lbWl0KFwicHJlcmVuZGVyXCIpLCByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybSwgIXJlbmRlcmVyLmNvbnRleHQuaXNMb3N0KSB7XG4gICAgICBpZiAocmVuZGVyVGV4dHVyZSB8fCAodGhpcy5sYXN0T2JqZWN0UmVuZGVyZWQgPSBkaXNwbGF5T2JqZWN0KSwgIXNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgY2FjaGVQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LmVuYWJsZVRlbXBQYXJlbnQoKTtcbiAgICAgICAgZGlzcGxheU9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKSwgZGlzcGxheU9iamVjdC5kaXNhYmxlVGVtcFBhcmVudChjYWNoZVBhcmVudCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSksIHJlbmRlcmVyLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpLCAoY2xlYXIgPz8gcmVuZGVyZXIuYmFja2dyb3VuZC5jbGVhckJlZm9yZVJlbmRlcikgJiYgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcigpLCBkaXNwbGF5T2JqZWN0LnJlbmRlcihyZW5kZXJlciksIHJlbmRlcmVyLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpLCByZW5kZXJUZXh0dXJlICYmIChvcHRpb25zLmJsaXQgJiYgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmxpdCgpLCByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnVwZGF0ZSgpKSwgcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLmVtaXQoKSwgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsLCByZW5kZXJlci5lbWl0KFwicG9zdHJlbmRlclwiKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbCwgdGhpcy5sYXN0T2JqZWN0UmVuZGVyZWQgPSBudWxsO1xuICB9XG59XG5PYmplY3RSZW5kZXJlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwib2JqZWN0UmVuZGVyZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKE9iamVjdFJlbmRlcmVyU3lzdGVtKTtcbmV4cG9ydCB7XG4gIE9iamVjdFJlbmRlcmVyU3lzdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0UmVuZGVyZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgUkVOREVSRVJfVFlQRSB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIkBwaXhpL21hdGhcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIkBwaXhpL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgaXNXZWJHTFN1cHBvcnRlZCB9IGZyb20gXCJAcGl4aS91dGlsc1wiO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSBcIi4vc2hhZGVyL1VuaWZvcm1Hcm91cC5tanNcIjtcbmltcG9ydCB7IFN5c3RlbU1hbmFnZXIgfSBmcm9tIFwiLi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanNcIjtcbmNvbnN0IF9SZW5kZXJlciA9IGNsYXNzIF9SZW5kZXJlcjIgZXh0ZW5kcyBTeXN0ZW1NYW5hZ2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5JUmVuZGVyZXJPcHRpb25zfSBbb3B0aW9uc10gLSBTZWUge0BsaW5rIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlN9IGZvciBkZWZhdWx0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpLCB0aGlzLnR5cGUgPSBSRU5ERVJFUl9UWVBFLldFQkdMLCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MuUkVOREVSX09QVElPTlMsIG9wdGlvbnMpLCB0aGlzLmdsID0gbnVsbCwgdGhpcy5DT05URVhUX1VJRCA9IDAsIHRoaXMuZ2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IG5ldyBNYXRyaXgoKVxuICAgIH0sICEwKTtcbiAgICBjb25zdCBzeXN0ZW1Db25maWcgPSB7XG4gICAgICBydW5uZXJzOiBbXG4gICAgICAgIFwiaW5pdFwiLFxuICAgICAgICBcImRlc3Ryb3lcIixcbiAgICAgICAgXCJjb250ZXh0Q2hhbmdlXCIsXG4gICAgICAgIFwicmVzb2x1dGlvbkNoYW5nZVwiLFxuICAgICAgICBcInJlc2V0XCIsXG4gICAgICAgIFwidXBkYXRlXCIsXG4gICAgICAgIFwicG9zdHJlbmRlclwiLFxuICAgICAgICBcInByZXJlbmRlclwiLFxuICAgICAgICBcInJlc2l6ZVwiXG4gICAgICBdLFxuICAgICAgc3lzdGVtczogX1JlbmRlcmVyMi5fX3N5c3RlbXMsXG4gICAgICBwcmlvcml0eTogW1xuICAgICAgICBcIl92aWV3XCIsXG4gICAgICAgIFwidGV4dHVyZUdlbmVyYXRvclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIixcbiAgICAgICAgXCJfcGx1Z2luXCIsXG4gICAgICAgIFwic3RhcnR1cFwiLFxuICAgICAgICAvLyBsb3cgbGV2ZWwgV2ViR0wgc3lzdGVtc1xuICAgICAgICBcImNvbnRleHRcIixcbiAgICAgICAgXCJzdGF0ZVwiLFxuICAgICAgICBcInRleHR1cmVcIixcbiAgICAgICAgXCJidWZmZXJcIixcbiAgICAgICAgXCJnZW9tZXRyeVwiLFxuICAgICAgICBcImZyYW1lYnVmZmVyXCIsXG4gICAgICAgIFwidHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICAgICAgLy8gaGlnaCBsZXZlbCBwaXhpIHNwZWNpZmljIHJlbmRlcmluZ1xuICAgICAgICBcIm1hc2tcIixcbiAgICAgICAgXCJzY2lzc29yXCIsXG4gICAgICAgIFwic3RlbmNpbFwiLFxuICAgICAgICBcInByb2plY3Rpb25cIixcbiAgICAgICAgXCJ0ZXh0dXJlR0NcIixcbiAgICAgICAgXCJmaWx0ZXJcIixcbiAgICAgICAgXCJyZW5kZXJUZXh0dXJlXCIsXG4gICAgICAgIFwiYmF0Y2hcIixcbiAgICAgICAgXCJvYmplY3RSZW5kZXJlclwiLFxuICAgICAgICBcIl9tdWx0aXNhbXBsZVwiXG4gICAgICBdXG4gICAgfTtcbiAgICB0aGlzLnNldHVwKHN5c3RlbUNvbmZpZyksIFwidXNlQ29udGV4dEFscGhhXCIgaW4gb3B0aW9ucyAmJiAoZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcIm9wdGlvbnMudXNlQ29udGV4dEFscGhhIGlzIGRlcHJlY2F0ZWQsIHVzZSBvcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYSBhbmQgb3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGEgaW5zdGVhZFwiKSwgb3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBvcHRpb25zLnVzZUNvbnRleHRBbHBoYSAmJiBvcHRpb25zLnVzZUNvbnRleHRBbHBoYSAhPT0gXCJub3RNdWx0aXBsaWVkXCIsIG9wdGlvbnMuYmFja2dyb3VuZEFscGhhID0gb3B0aW9ucy51c2VDb250ZXh0QWxwaGEgPT09ICExID8gMSA6IG9wdGlvbnMuYmFja2dyb3VuZEFscGhhKSwgdGhpcy5fcGx1Z2luLnJlbmRlcmVyUGx1Z2lucyA9IF9SZW5kZXJlcjIuX19wbHVnaW5zLCB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLCB0aGlzLnN0YXJ0dXAucnVuKHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSByZW5kZXJlciBpZiBXZWJHTCBpcyBhdmFpbGFibGUuIE92ZXJyaWRlYWJsZVxuICAgKiBieSB0aGUgKipAcGl4aS9jYW52YXMtcmVuZGVyZXIqKiBwYWNrYWdlIHRvIGFsbG93IGZhbGxiYWNrLlxuICAgKiB0aHJvd3MgZXJyb3IgaWYgV2ViR0wgaXMgbm90IGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyB0ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucz8uZm9yY2VDYW52YXMgPyAhMSA6IGlzV2ViR0xTdXBwb3J0ZWQoKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIGl0cyBXZWJHTCB2aWV3LlxuICAgKiBAcGFyYW0gZGlzcGxheU9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPYmplY3QgdG8gdXNlIGZvciByZW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IFtvcHRpb25zLnJlbmRlclRleHR1cmVdIC0gVGhlIHJlbmRlciB0ZXh0dXJlIHRvIHJlbmRlciB0by5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcj10cnVlXSAtIFNob3VsZCB0aGUgY2FudmFzIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBuZXcgcmVuZGVyLlxuICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbb3B0aW9ucy50cmFuc2Zvcm1dIC0gQSB0cmFuc2Zvcm0gdG8gYXBwbHkgdG8gdGhlIHJlbmRlciB0ZXh0dXJlIGJlZm9yZSByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcFVwZGF0ZVRyYW5zZm9ybT1mYWxzZV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybSBwYXNzP1xuICAgKi9cbiAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdFJlbmRlcmVyLnJlbmRlcihkaXNwbGF5T2JqZWN0LCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgV2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuV2lkdGggLSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbkhlaWdodCAtIFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKi9cbiAgcmVzaXplKGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCkge1xuICAgIHRoaXMuX3ZpZXcucmVzaXplVmlldyhkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIFdlYkdMIHN0YXRlIHNvIHlvdSBjYW4gcmVuZGVyIHRoaW5ncyBob3dldmVyIHlvdSBmYW5jeSFcbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5uZXJzLnJlc2V0LmVtaXQoKSwgdGhpcztcbiAgfVxuICAvKiogQ2xlYXIgdGhlIGZyYW1lIGJ1ZmZlci4gKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5yZW5kZXJUZXh0dXJlLmJpbmQoKSwgdGhpcy5yZW5kZXJUZXh0dXJlLmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciAoZXZlbnQgbGlzdGVuZXJzLCBzcHJpdGViYXRjaCwgZXRjLi4uKVxuICAgKiBAcGFyYW0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKiAgU2VlOiBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGlqcy9pc3N1ZXMvMjIzM1xuICAgKi9cbiAgZGVzdHJveShyZW1vdmVWaWV3ID0gITEpIHtcbiAgICB0aGlzLnJ1bm5lcnMuZGVzdHJveS5pdGVtcy5yZXZlcnNlKCksIHRoaXMuZW1pdFdpdGhDdXN0b21PcHRpb25zKHRoaXMucnVubmVycy5kZXN0cm95LCB7XG4gICAgICBfdmlldzogcmVtb3ZlVmlld1xuICAgIH0pLCBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgLyoqIENvbGxlY3Rpb24gb2YgcGx1Z2lucyAqL1xuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2luLnBsdWdpbnM7XG4gIH1cbiAgLyoqIFRoZSBudW1iZXIgb2YgbXNhYSBzYW1wbGVzIG9mIHRoZSBjYW52YXMuICovXG4gIGdldCBtdWx0aXNhbXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXVsdGlzYW1wbGUubXVsdGlzYW1wbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgYXMgdmlldy53aWR0aCwgYWN0dWFsIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGNhbnZhcyBieSBob3Jpem9udGFsLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVmYXVsdCA4MDBcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5lbGVtZW50LndpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGFzIHZpZXcuaGVpZ2h0LCBhY3R1YWwgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgY2FudmFzIGJ5IHZlcnRpY2FsLlxuICAgKiBAZGVmYXVsdCA2MDBcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuZWxlbWVudC5oZWlnaHQ7XG4gIH1cbiAgLyoqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci4gKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3ZpZXcucmVzb2x1dGlvbiA9IHZhbHVlLCB0aGlzLnJ1bm5lcnMucmVzb2x1dGlvbkNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgfVxuICAvKiogV2hldGhlciBDU1MgZGltZW5zaW9ucyBvZiBjYW52YXMgdmlldyBzaG91bGQgYmUgcmVzaXplZCB0byBzY3JlZW4gZGltZW5zaW9ucyBhdXRvbWF0aWNhbGx5LiAqL1xuICBnZXQgYXV0b0RlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuYXV0b0RlbnNpdHk7XG4gIH1cbiAgLyoqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG8uKi9cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogTWVhc3VyZW1lbnRzIG9mIHRoZSBzY3JlZW4uICgwLCAwLCBzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KS5cbiAgICpcbiAgICogSXRzIHNhZmUgdG8gdXNlIGFzIGZpbHRlckFyZWEgb3IgaGl0QXJlYSBmb3IgdGhlIHdob2xlIHN0YWdlLlxuICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuc2NyZWVuO1xuICB9XG4gIC8qKiB0aGUgbGFzdCBvYmplY3QgcmVuZGVyZWQgYnkgdGhlIHJlbmRlcmVyLiBVc2VmdWwgZm9yIG90aGVyIHBsdWdpbnMgbGlrZSBpbnRlcmFjdGlvbiBtYW5hZ2VycyAqL1xuICBnZXQgbGFzdE9iamVjdFJlbmRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgfVxuICAvKiogRmxhZyBpZiB3ZSBhcmUgcmVuZGVyaW5nIHRvIHRoZSBzY3JlZW4gdnMgcmVuZGVyVGV4dHVyZSAqL1xuICBnZXQgcmVuZGVyaW5nVG9TY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW47XG4gIH1cbiAgLyoqIFdoZW4gbG9nZ2luZyBQaXhpIHRvIHRoZSBjb25zb2xlLCB0aGlzIGlzIHRoZSBuYW1lIHdlIHdpbGwgc2hvdyAqL1xuICBnZXQgcmVuZGVyZXJMb2dJZCgpIHtcbiAgICByZXR1cm4gYFdlYkdMICR7dGhpcy5jb250ZXh0LndlYkdMVmVyc2lvbn1gO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNldHMgd2VhdGhlciB0aGUgc2NyZWVuIGlzIHRvdGFsbHkgY2xlYXJlZCBiZXR3ZWVuIGVhY2ggZnJhbWUgd2l0aHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCBhbHBoYVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgZ2V0IGNsZWFyQmVmb3JlUmVuZGVyKCkge1xuICAgIHJldHVybiBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuY2xlYXJCZWZvcmVSZW5kZXIgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmNsZWFyQmVmb3JlUmVuZGVyIGluc3RlYWQuXCIpLCB0aGlzLmJhY2tncm91bmQuY2xlYXJCZWZvcmVSZW5kZXI7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MtdGhydSBzZXR0aW5nIGZvciB0aGUgY2FudmFzJyBjb250ZXh0IGBhbHBoYWAgcHJvcGVydHkuIFRoaXMgaXMgdHlwaWNhbGx5XG4gICAqIG5vdCBzb21ldGhpbmcgeW91IG5lZWQgdG8gZmlkZGxlIHdpdGguIElmIHlvdSB3YW50IHRyYW5zcGFyZW5jeSwgdXNlIGBiYWNrZ3JvdW5kQWxwaGFgLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHVzZUNvbnRleHRBbHBoYSgpIHtcbiAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnVzZUNvbnRleHRBbHBoYSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlcmVyLmNvbnRleHQucHJlbXVsdGlwbGllZEFscGhhIGluc3RlYWQuXCIpLCB0aGlzLmNvbnRleHQudXNlQ29udGV4dEFscGhhO1xuICB9XG4gIC8qKlxuICAgKiByZWFkb25seSBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb25cbiAgICogd2UgY2FuIG9ubHkga25vdyB0aGlzIGlmIFBpeGkgY3JlYXRlZCB0aGUgY29udGV4dFxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgZ2V0IHByZXNlcnZlRHJhd2luZ0J1ZmZlcigpIHtcbiAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnByZXNlcnZlRHJhd2luZ0J1ZmZlciBoYXMgYmVlbiBkZXByZWNhdGVkLCB3ZSBjYW5ub3QgdHJ1bHkga25vdyB0aGlzIHVubGVzcyBwaXhpIGNyZWF0ZWQgdGhlIGNvbnRleHRcIiksIHRoaXMuY29udGV4dC5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGZpbGwgaWYgbm90IHRyYW5zcGFyZW50XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuY29sb3IgaW5zdGVhZC5cIiksIHRoaXMuYmFja2dyb3VuZC5jb2xvcjtcbiAgfVxuICBzZXQgYmFja2dyb3VuZENvbG9yKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmJhY2tncm91bmRDb2xvciBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5jb2xvciBpbnN0ZWFkLlwiKSwgdGhpcy5iYWNrZ3JvdW5kLmNvbG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFscGhhLiBTZXR0aW5nIHRoaXMgdG8gMCB3aWxsIG1ha2UgdGhlIGNhbnZhcyB0cmFuc3BhcmVudC5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgZ2V0IGJhY2tncm91bmRBbHBoYSgpIHtcbiAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmJhY2tncm91bmRBbHBoYSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5hbHBoYSBpbnN0ZWFkLlwiKSwgdGhpcy5iYWNrZ3JvdW5kLmFscGhhO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgc2V0IGJhY2tncm91bmRBbHBoYSh2YWx1ZSkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQWxwaGEgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgaW5zdGVhZC5cIiksIHRoaXMuYmFja2dyb3VuZC5hbHBoYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgZ2V0IHBvd2VyUHJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBvd2VyUHJlZmVyZW5jZSBoYXMgYmVlbiBkZXByZWNhdGVkLCB3ZSBjYW4gb25seSBrbm93IHRoaXMgaWYgcGl4aSBjcmVhdGVzIHRoZSBjb250ZXh0XCIpLCB0aGlzLmNvbnRleHQucG93ZXJQcmVmZXJlbmNlO1xuICB9XG4gIC8qKlxuICAgKiBVc2VmdWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBvZiB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXG4gICAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3QgLSBUaGUgZGlzcGxheU9iamVjdCB0aGUgb2JqZWN0IHdpbGwgYmUgZ2VuZXJhdGVkIGZyb20uXG4gICAqIEBwYXJhbSB7SUdlbmVyYXRlVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgLSBHZW5lcmF0ZSB0ZXh0dXJlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IG9wdGlvbnMucmVnaW9uIC0gVGhlIHJlZ2lvbiBvZiB0aGUgZGlzcGxheU9iamVjdCwgdGhhdCBzaGFsbCBiZSByZW5kZXJlZCxcbiAgICogICAgICAgIGlmIG5vIHJlZ2lvbiBpcyBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uXSAtIElmIG5vdCBnaXZlbiwgdGhlIHJlbmRlcmVyJ3MgcmVzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge1BJWEkuTVNBQV9RVUFMSVRZfSBbb3B0aW9ucy5tdWx0aXNhbXBsZV0gLSBJZiBub3QgZ2l2ZW4sIHRoZSByZW5kZXJlcidzIG11bHRpc2FtcGxlIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIEEgdGV4dHVyZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0LlxuICAgKi9cbiAgZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlR2VuZXJhdG9yLmdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBvcHRpb25zKTtcbiAgfVxufTtcbl9SZW5kZXJlci5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXIsXG4gIHByaW9yaXR5OiAxXG59LCAvKipcbiogQ29sbGVjdGlvbiBvZiBpbnN0YWxsZWQgcGx1Z2lucy4gVGhlc2UgYXJlIGluY2x1ZGVkIGJ5IGRlZmF1bHQgaW4gUElYSSwgYnV0IGNhbiBiZSBleGNsdWRlZFxuKiBieSBjcmVhdGluZyBhIGN1c3RvbSBidWlsZC4gQ29uc3VsdCB0aGUgUkVBRE1FIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGNyZWF0aW5nIGN1c3RvbVxuKiBidWlsZHMgYW5kIGV4Y2x1ZGluZyBwbHVnaW5zLlxuKiBAcHJpdmF0ZVxuKi9cbl9SZW5kZXJlci5fX3BsdWdpbnMgPSB7fSwgLyoqXG4qIFRoZSBjb2xsZWN0aW9uIG9mIGluc3RhbGxlZCBzeXN0ZW1zLlxuKiBAcHJpdmF0ZVxuKi9cbl9SZW5kZXJlci5fX3N5c3RlbXMgPSB7fTtcbmxldCBSZW5kZXJlciA9IF9SZW5kZXJlcjtcbmV4dGVuc2lvbnMuaGFuZGxlQnlNYXAoRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpbiwgUmVuZGVyZXIuX19wbHVnaW5zKTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlNYXAoRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSwgUmVuZGVyZXIuX19zeXN0ZW1zKTtcbmV4dGVuc2lvbnMuYWRkKFJlbmRlcmVyKTtcbmV4cG9ydCB7XG4gIFJlbmRlcmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tIFwiLi4vQmFzZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0UmVzb3VyY2UgfSBmcm9tIFwiLi9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gXCIuL1Jlc291cmNlLm1qc1wiO1xuY2xhc3MgQWJzdHJhY3RNdWx0aVJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIGxlbmd0aFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gZm9yIFJlc291cmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gLSBXaWR0aCBvZiB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnMgfHwge307XG4gICAgc3VwZXIod2lkdGgsIGhlaWdodCksIHRoaXMuaXRlbXMgPSBbXSwgdGhpcy5pdGVtRGlydHlJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0VGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZSgpO1xuICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhcnRUZXh0dXJlKSwgdGhpcy5pdGVtRGlydHlJZHMucHVzaCgtMik7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoLCB0aGlzLl9sb2FkID0gbnVsbCwgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgZnJvbSBBcnJheVJlc291cmNlIGFuZCBDdWJlUmVzb3VyY2UgY29uc3RydWN0b3JzLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIC0gQ2FuIGJlIHJlc291cmNlcywgaW1hZ2UgZWxlbWVudHMsIGNhbnZhcywgZXRjLiAsXG4gICAqICBsZW5ndGggc2hvdWxkIGJlIHNhbWUgYXMgY29uc3RydWN0b3IgbGVuZ3RoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0ZWN0IG9wdGlvbnMgZm9yIHJlc291cmNlc1xuICAgKi9cbiAgaW5pdEZyb21BcnJheShyZXNvdXJjZXMsIG9wdGlvbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICByZXNvdXJjZXNbaV0gJiYgKHJlc291cmNlc1tpXS5jYXN0VG9CYXNlVGV4dHVyZSA/IHRoaXMuYWRkQmFzZVRleHR1cmVBdChyZXNvdXJjZXNbaV0uY2FzdFRvQmFzZVRleHR1cmUoKSwgaSkgOiByZXNvdXJjZXNbaV0gaW5zdGFuY2VvZiBSZXNvdXJjZSA/IHRoaXMuYWRkUmVzb3VyY2VBdChyZXNvdXJjZXNbaV0sIGkpIDogdGhpcy5hZGRSZXNvdXJjZUF0KGF1dG9EZXRlY3RSZXNvdXJjZShyZXNvdXJjZXNbaV0sIG9wdGlvbnMpLCBpKSk7XG4gIH1cbiAgLyoqIERlc3Ryb3kgdGhpcyBCYXNlSW1hZ2VSZXNvdXJjZS4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgIHRoaXMuaXRlbXNbaV0uZGVzdHJveSgpO1xuICAgIHRoaXMuaXRlbXMgPSBudWxsLCB0aGlzLml0ZW1EaXJ0eUlkcyA9IG51bGwsIHRoaXMuX2xvYWQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSByZXNvdXJjZSBieSBJRFxuICAgKiBAcGFyYW0gcmVzb3VyY2VcbiAgICogQHBhcmFtIGluZGV4IC0gWmVyby1iYXNlZCBpbmRleCBvZiByZXNvdXJjZSB0byBzZXRcbiAgICogQHJldHVybnMgLSBJbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIGFkZFJlc291cmNlQXQocmVzb3VyY2UsIGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLml0ZW1zW2luZGV4XSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kc2ApO1xuICAgIHJldHVybiByZXNvdXJjZS52YWxpZCAmJiAhdGhpcy52YWxpZCAmJiB0aGlzLnJlc2l6ZShyZXNvdXJjZS53aWR0aCwgcmVzb3VyY2UuaGVpZ2h0KSwgdGhpcy5pdGVtc1tpbmRleF0uc2V0UmVzb3VyY2UocmVzb3VyY2UpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHBhcmVudCBiYXNlIHRleHR1cmUuXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZVxuICAgKi9cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgYmFzZSB0ZXh0dXJlIHBlciBUZXh0dXJlQXJyYXkgaXMgYWxsb3dlZFwiKTtcbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLml0ZW1zW2ldLnBhcmVudFRleHR1cmVBcnJheSA9IGJhc2VUZXh0dXJlLCB0aGlzLml0ZW1zW2ldLm9uKFwidXBkYXRlXCIsIGJhc2VUZXh0dXJlLnVwZGF0ZSwgYmFzZVRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBVbnNldCB0aGUgcGFyZW50IGJhc2UgdGV4dHVyZS5cbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlXG4gICAqL1xuICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci51bmJpbmQoYmFzZVRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuaXRlbXNbaV0ucGFyZW50VGV4dHVyZUFycmF5ID0gbnVsbCwgdGhpcy5pdGVtc1tpXS5vZmYoXCJ1cGRhdGVcIiwgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgYWxsIHRoZSByZXNvdXJjZXMgc2ltdWx0YW5lb3VzbHlcbiAgICogQHJldHVybnMgLSBXaGVuIGxvYWQgaXMgcmVzb2x2ZWRcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpXG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnJlc291cmNlKS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0pLm1hcCgoaXRlbSkgPT4gaXRlbS5sb2FkKCkpO1xuICAgIHJldHVybiB0aGlzLl9sb2FkID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVhbFdpZHRoLCByZWFsSGVpZ2h0IH0gPSB0aGlzLml0ZW1zWzBdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUocmVhbFdpZHRoLCByZWFsSGVpZ2h0KSwgdGhpcy51cGRhdGUoKSwgUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgICAgfVxuICAgICksIHRoaXMuX2xvYWQ7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEFic3RyYWN0TXVsdGlSZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TXVsdGlSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUQVJHRVRTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RNdWx0aVJlc291cmNlIH0gZnJvbSBcIi4vQWJzdHJhY3RNdWx0aVJlc291cmNlLm1qc1wiO1xuY2xhc3MgQXJyYXlSZXNvdXJjZSBleHRlbmRzIEFic3RyYWN0TXVsdGlSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc291cmNlIC0gTnVtYmVyIG9mIGl0ZW1zIGluIGFycmF5IG9yIHRoZSBjb2xsZWN0aW9uXG4gICAqICAgICAgICBvZiBpbWFnZSBVUkxzIHRvIHVzZS4gQ2FuIGFsc28gYmUgcmVzb3VyY2VzLCBpbWFnZSBlbGVtZW50cywgY2FudmFzLCBldGMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBhcHBseSB0byB7QGxpbmsgUElYSS5hdXRvRGV0ZWN0UmVzb3VyY2V9XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gLSBXaWR0aCBvZiB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IHVybHMsIGxlbmd0aDtcbiAgICBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyAodXJscyA9IHNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCkgOiBsZW5ndGggPSBzb3VyY2UsIHN1cGVyKGxlbmd0aCwgeyB3aWR0aCwgaGVpZ2h0IH0pLCB1cmxzICYmIHRoaXMuaW5pdEZyb21BcnJheSh1cmxzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgYmFzZVRleHR1cmUgYnkgSUQsXG4gICAqIEFycmF5UmVzb3VyY2UganVzdCB0YWtlcyByZXNvdXJjZSBmcm9tIGl0LCBub3RoaW5nIG1vcmVcbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSBpbmRleCAtIFplcm8tYmFzZWQgaW5kZXggb2YgcmVzb3VyY2UgdG8gc2V0XG4gICAqIEByZXR1cm5zIC0gSW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqL1xuICBhZGRCYXNlVGV4dHVyZUF0KGJhc2VUZXh0dXJlLCBpbmRleCkge1xuICAgIGlmIChiYXNlVGV4dHVyZS5yZXNvdXJjZSlcbiAgICAgIHRoaXMuYWRkUmVzb3VyY2VBdChiYXNlVGV4dHVyZS5yZXNvdXJjZSwgaW5kZXgpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5UmVzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCBSZW5kZXJUZXh0dXJlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYmluZGluZ1xuICAgKiBAcGFyYW0gYmFzZVRleHR1cmVcbiAgICovXG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKSwgYmFzZVRleHR1cmUudGFyZ2V0ID0gVEFSR0VUUy5URVhUVVJFXzJEX0FSUkFZO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgdGhlIHJlc291cmNlcyB0byB0aGUgR1BVLlxuICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICogQHBhcmFtIHRleHR1cmVcbiAgICogQHBhcmFtIGdsVGV4dHVyZVxuICAgKiBAcmV0dXJucyAtIHdoZXRoZXIgdGV4dHVyZSB3YXMgdXBsb2FkZWRcbiAgICovXG4gIHVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgeyBsZW5ndGgsIGl0ZW1EaXJ0eUlkcywgaXRlbXMgfSA9IHRoaXMsIHsgZ2wgfSA9IHJlbmRlcmVyO1xuICAgIGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCAmJiBnbC50ZXhJbWFnZTNEKFxuICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgIDAsXG4gICAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsXG4gICAgICB0aGlzLl93aWR0aCxcbiAgICAgIHRoaXMuX2hlaWdodCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIDAsXG4gICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaXRlbURpcnR5SWRzW2ldIDwgaXRlbS5kaXJ0eUlkICYmIChpdGVtRGlydHlJZHNbaV0gPSBpdGVtLmRpcnR5SWQsIGl0ZW0udmFsaWQgJiYgZ2wudGV4U3ViSW1hZ2UzRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8geG9mZnNldFxuICAgICAgICAwLFxuICAgICAgICAvLyB5b2Zmc2V0XG4gICAgICAgIGksXG4gICAgICAgIC8vIHpvZmZzZXRcbiAgICAgICAgaXRlbS5yZXNvdXJjZS53aWR0aCxcbiAgICAgICAgaXRlbS5yZXNvdXJjZS5oZWlnaHQsXG4gICAgICAgIDEsXG4gICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICBnbFRleHR1cmUudHlwZSxcbiAgICAgICAgaXRlbS5yZXNvdXJjZS5zb3VyY2VcbiAgICAgICkpO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEFycmF5UmVzb3VyY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSBcIi4vQmFzZUltYWdlUmVzb3VyY2UubWpzXCI7XG5jbGFzcyBDYW52YXNSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzb3VyY2UgLSBDYW52YXMgZWxlbWVudCB0byB1c2VcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlbGVzcy1jb25zdHJ1Y3RvclxuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgc291cmNlIGlzIEhUTUxDYW52YXNFbGVtZW50IG9yIE9mZnNjcmVlbkNhbnZhc1xuICAgKi9cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgY29uc3QgeyBPZmZzY3JlZW5DYW52YXMgfSA9IGdsb2JhbFRoaXM7XG4gICAgcmV0dXJuIE9mZnNjcmVlbkNhbnZhcyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMgPyAhMCA6IGdsb2JhbFRoaXMuSFRNTENhbnZhc0VsZW1lbnQgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIENhbnZhc1Jlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEFSR0VUUyB9IGZyb20gXCJAcGl4aS9jb25zdGFudHNcIjtcbmltcG9ydCB7IEFic3RyYWN0TXVsdGlSZXNvdXJjZSB9IGZyb20gXCIuL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanNcIjtcbmNvbnN0IF9DdWJlUmVzb3VyY2UgPSBjbGFzcyBfQ3ViZVJlc291cmNlMiBleHRlbmRzIEFic3RyYWN0TXVsdGlSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xQSVhJLlJlc291cmNlPn0gW3NvdXJjZV0gLSBDb2xsZWN0aW9uIG9mIFVSTHMgb3IgcmVzb3VyY2VzXG4gICAqICAgICAgICB0byB1c2UgYXMgdGhlIHNpZGVzIG9mIHRoZSBjdWJlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEltYWdlUmVzb3VyY2Ugb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdIC0gV2lkdGggb2YgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBIZWlnaHQgb2YgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmF1dG9Mb2FkPXRydWVdIC0gV2hldGhlciB0byBhdXRvLWxvYWQgcmVzb3VyY2VzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5rQmFzZVRleHR1cmU9dHJ1ZV0gLSBJbiBjYXNlIEJhc2VUZXh0dXJlcyBhcmUgc3VwcGxpZWQsXG4gICAqICAgd2hldGhlciB0byBjb3B5IHRoZW0gb3IgdXNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGF1dG9Mb2FkLCBsaW5rQmFzZVRleHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNvdXJjZSAmJiBzb3VyY2UubGVuZ3RoICE9PSBfQ3ViZVJlc291cmNlMi5TSURFUylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZW5ndGguIEdvdCAke3NvdXJjZS5sZW5ndGh9LCBleHBlY3RlZCA2YCk7XG4gICAgc3VwZXIoNiwgeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX0N1YmVSZXNvdXJjZTIuU0lERVM7IGkrKylcbiAgICAgIHRoaXMuaXRlbXNbaV0udGFyZ2V0ID0gVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpO1xuICAgIHRoaXMubGlua0Jhc2VUZXh0dXJlID0gbGlua0Jhc2VUZXh0dXJlICE9PSAhMSwgc291cmNlICYmIHRoaXMuaW5pdEZyb21BcnJheShzb3VyY2UsIG9wdGlvbnMpLCBhdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBiaW5kaW5nLlxuICAgKiBAcGFyYW0gYmFzZVRleHR1cmUgLSBwYXJlbnQgYmFzZSB0ZXh0dXJlXG4gICAqL1xuICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSksIGJhc2VUZXh0dXJlLnRhcmdldCA9IFRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUDtcbiAgfVxuICBhZGRCYXNlVGV4dHVyZUF0KGJhc2VUZXh0dXJlLCBpbmRleCwgbGlua0Jhc2VUZXh0dXJlKSB7XG4gICAgaWYgKGxpbmtCYXNlVGV4dHVyZSA9PT0gdm9pZCAwICYmIChsaW5rQmFzZVRleHR1cmUgPSB0aGlzLmxpbmtCYXNlVGV4dHVyZSksICF0aGlzLml0ZW1zW2luZGV4XSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kc2ApO1xuICAgIGlmICghdGhpcy5saW5rQmFzZVRleHR1cmUgfHwgYmFzZVRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5IHx8IE9iamVjdC5rZXlzKGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzKS5sZW5ndGggPiAwKVxuICAgICAgaWYgKGJhc2VUZXh0dXJlLnJlc291cmNlKVxuICAgICAgICB0aGlzLmFkZFJlc291cmNlQXQoYmFzZVRleHR1cmUucmVzb3VyY2UsIGluZGV4KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ViZVJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQgY29weWluZyBvZiByZW5kZXJUZXh0dXJlLlwiKTtcbiAgICBlbHNlXG4gICAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBUQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGluZGV4LCBiYXNlVGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkgPSB0aGlzLmJhc2VUZXh0dXJlLCB0aGlzLml0ZW1zW2luZGV4XSA9IGJhc2VUZXh0dXJlO1xuICAgIHJldHVybiBiYXNlVGV4dHVyZS52YWxpZCAmJiAhdGhpcy52YWxpZCAmJiB0aGlzLnJlc2l6ZShiYXNlVGV4dHVyZS5yZWFsV2lkdGgsIGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQpLCB0aGlzLml0ZW1zW2luZGV4XSA9IGJhc2VUZXh0dXJlLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgdGhlIHJlc291cmNlXG4gICAqIEBwYXJhbSByZW5kZXJlclxuICAgKiBAcGFyYW0gX2Jhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSBnbFRleHR1cmVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgc3VjY2Vzc1xuICAgKi9cbiAgdXBsb2FkKHJlbmRlcmVyLCBfYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGNvbnN0IGRpcnR5ID0gdGhpcy5pdGVtRGlydHlJZHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfQ3ViZVJlc291cmNlMi5TSURFUzsgaSsrKSB7XG4gICAgICBjb25zdCBzaWRlID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgIChkaXJ0eVtpXSA8IHNpZGUuZGlydHlJZCB8fCBnbFRleHR1cmUuZGlydHlJZCA8IF9iYXNlVGV4dHVyZS5kaXJ0eUlkKSAmJiAoc2lkZS52YWxpZCAmJiBzaWRlLnJlc291cmNlID8gKHNpZGUucmVzb3VyY2UudXBsb2FkKHJlbmRlcmVyLCBzaWRlLCBnbFRleHR1cmUpLCBkaXJ0eVtpXSA9IHNpZGUuZGlydHlJZCkgOiBkaXJ0eVtpXSA8IC0xICYmIChyZW5kZXJlci5nbC50ZXhJbWFnZTJEKFxuICAgICAgICBzaWRlLnRhcmdldCxcbiAgICAgICAgMCxcbiAgICAgICAgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LFxuICAgICAgICBfYmFzZVRleHR1cmUucmVhbFdpZHRoLFxuICAgICAgICBfYmFzZVRleHR1cmUucmVhbEhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgX2Jhc2VUZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICksIGRpcnR5W2ldID0gLTEpKTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgc291cmNlIGlzIGFuIGFycmF5IG9mIDYgZWxlbWVudHNcbiAgICovXG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCA9PT0gX0N1YmVSZXNvdXJjZTIuU0lERVM7XG4gIH1cbn07XG5fQ3ViZVJlc291cmNlLlNJREVTID0gNjtcbmxldCBDdWJlUmVzb3VyY2UgPSBfQ3ViZVJlc291cmNlO1xuZXhwb3J0IHtcbiAgQ3ViZVJlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3ViZVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSBcIi4vQmFzZUltYWdlUmVzb3VyY2UubWpzXCI7XG5jbGFzcyBJbWFnZUJpdG1hcFJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZSAtIEltYWdlQml0bWFwIG9yIFVSTCB0byB1c2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgYmFzZVNvdXJjZSwgdXJsLCBvd25zSW1hZ2VCaXRtYXA7XG4gICAgdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiID8gKGJhc2VTb3VyY2UgPSBJbWFnZUJpdG1hcFJlc291cmNlLkVNUFRZLCB1cmwgPSBzb3VyY2UsIG93bnNJbWFnZUJpdG1hcCA9ICEwKSA6IChiYXNlU291cmNlID0gc291cmNlLCB1cmwgPSBudWxsLCBvd25zSW1hZ2VCaXRtYXAgPSAhMSksIHN1cGVyKGJhc2VTb3VyY2UpLCB0aGlzLnVybCA9IHVybCwgdGhpcy5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gPz8gITAsIHRoaXMuYWxwaGFNb2RlID0gdHlwZW9mIG9wdGlvbnMuYWxwaGFNb2RlID09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFscGhhTW9kZSA6IG51bGwsIHRoaXMub3duc0ltYWdlQml0bWFwID0gb3B0aW9ucy5vd25zSW1hZ2VCaXRtYXAgPz8gb3duc0ltYWdlQml0bWFwLCB0aGlzLl9sb2FkID0gbnVsbCwgb3B0aW9ucy5hdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCA/IHRoaXMuX2xvYWQgOiAodGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnVybCA9PT0gbnVsbCkge1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godGhpcy51cmwsIHtcbiAgICAgICAgICBtb2RlOiB0aGlzLmNyb3NzT3JpZ2luID8gXCJjb3JzXCIgOiBcIm5vLWNvcnNcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYiwge1xuICAgICAgICAgIHByZW11bHRpcGx5QWxwaGE6IHRoaXMuYWxwaGFNb2RlID09PSBudWxsIHx8IHRoaXMuYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5VTlBBQ0sgPyBcInByZW11bHRpcGx5XCIgOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgaW1hZ2VCaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBpbWFnZUJpdG1hcCwgdGhpcy51cGRhdGUoKSwgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVqZWN0KGUpLCB0aGlzLm9uRXJyb3IuZW1pdChlKTtcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5fbG9hZCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCB0aGUgaW1hZ2UgYml0bWFwIHJlc291cmNlIHRvIEdQVS5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gUmVuZGVyZXIgdG8gdXBsb2FkIHRvXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIEJhc2VUZXh0dXJlIGZvciB0aGlzIHJlc291cmNlXG4gICAqIEBwYXJhbSBnbFRleHR1cmUgLSBHTFRleHR1cmUgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcbiAgICovXG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwID8gKHR5cGVvZiB0aGlzLmFscGhhTW9kZSA9PSBcIm51bWJlclwiICYmIChiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPSB0aGlzLmFscGhhTW9kZSksIHN1cGVyLnVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkpIDogKHRoaXMubG9hZCgpLCAhMSk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgcmVzb3VyY2UuICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5vd25zSW1hZ2VCaXRtYXAgJiYgdGhpcy5zb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCAmJiB0aGlzLnNvdXJjZS5jbG9zZSgpLCBzdXBlci5kaXNwb3NlKCksIHRoaXMuX2xvYWQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0IEltYWdlQml0bWFwLCBhbmQgc291cmNlIGlzIHN0cmluZyBvciBJbWFnZUJpdG1hcFxuICAgKi9cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCAmJiB0eXBlb2YgSW1hZ2VCaXRtYXAgPCBcInVcIiAmJiAodHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKTtcbiAgfVxuICAvKipcbiAgICogSW1hZ2VCaXRtYXAgY2Fubm90IGJlIGNyZWF0ZWQgc3luY2hyb25vdXNseSwgc28gYSBlbXB0eSBwbGFjZWhvbGRlciBjYW52YXMgaXMgbmVlZGVkIHdoZW4gbG9hZGluZyBmcm9tIFVSTHMuXG4gICAqIE9ubHkgZm9yIGludGVybmFsIHVzYWdlLlxuICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIHBsYWNlaG9sZGVyIGNhbnZhcy5cbiAgICovXG4gIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgcmV0dXJuIEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZID0gSW1hZ2VCaXRtYXBSZXNvdXJjZS5fRU1QVFkgPz8gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoMCwgMCksIEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZO1xuICB9XG59XG5leHBvcnQge1xuICBJbWFnZUJpdG1hcFJlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VCaXRtYXBSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSBcIkBwaXhpL3V0aWxzXCI7XG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuL0Jhc2VJbWFnZVJlc291cmNlLm1qc1wiO1xuY29uc3QgX1NWR1Jlc291cmNlID0gY2xhc3MgX1NWR1Jlc291cmNlMiBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzb3VyY2VCYXNlNjQgLSBCYXNlNjQgZW5jb2RlZCBTVkcgZWxlbWVudCBvciBVUkwgZm9yIFNWRyBmaWxlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyB0byB1c2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNjYWxlPTFdIC0gU2NhbGUgdG8gYXBwbHkgdG8gU1ZHLiBPdmVycmlkZGVuIGJ5Li4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gLSBSYXN0ZXJpemUgU1ZHIHRoaXMgd2lkZS4gQXNwZWN0IHJhdGlvIHByZXNlcnZlZCBpZiBoZWlnaHQgbm90IHNwZWNpZmllZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBSYXN0ZXJpemUgU1ZHIHRoaXMgaGlnaC4gQXNwZWN0IHJhdGlvIHByZXNlcnZlZCBpZiB3aWR0aCBub3Qgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9Mb2FkPXRydWVdIC0gU3RhcnQgbG9hZGluZyByaWdodCBhd2F5LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlQmFzZTY0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30sIHN1cGVyKHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCkpLCB0aGlzLl93aWR0aCA9IDAsIHRoaXMuX2hlaWdodCA9IDAsIHRoaXMuc3ZnID0gc291cmNlQmFzZTY0LCB0aGlzLnNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCAxLCB0aGlzLl9vdmVycmlkZVdpZHRoID0gb3B0aW9ucy53aWR0aCwgdGhpcy5fb3ZlcnJpZGVIZWlnaHQgPSBvcHRpb25zLmhlaWdodCwgdGhpcy5fcmVzb2x2ZSA9IG51bGwsIHRoaXMuX2Nyb3Nzb3JpZ2luID0gb3B0aW9ucy5jcm9zc29yaWdpbiwgdGhpcy5fbG9hZCA9IG51bGwsIG9wdGlvbnMuYXV0b0xvYWQgIT09ICExICYmIHRoaXMubG9hZCgpO1xuICB9XG4gIGxvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQgPyB0aGlzLl9sb2FkIDogKHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc29sdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlKCksIHJlc29sdmUodGhpcyk7XG4gICAgICB9LCBfU1ZHUmVzb3VyY2UyLlNWR19YTUwudGVzdCh0aGlzLnN2Zy50cmltKCkpKSB7XG4gICAgICAgIGlmICghYnRvYSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGJhc2U2NCBjb252ZXJzaW9ucy5cIik7XG4gICAgICAgIHRoaXMuc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN2ZykpKX1gO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9hZFN2ZygpO1xuICAgIH0pLCB0aGlzLl9sb2FkKTtcbiAgfVxuICAvKiogTG9hZHMgYW4gU1ZHIGltYWdlIGZyb20gYGltYWdlVXJsYCBvciBgZGF0YSBVUkxgLiAqL1xuICBfbG9hZFN2ZygpIHtcbiAgICBjb25zdCB0ZW1wSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBCYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbih0ZW1wSW1hZ2UsIHRoaXMuc3ZnLCB0aGlzLl9jcm9zc29yaWdpbiksIHRlbXBJbWFnZS5zcmMgPSB0aGlzLnN2ZywgdGVtcEltYWdlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgJiYgKHRlbXBJbWFnZS5vbmVycm9yID0gbnVsbCwgdGhpcy5vbkVycm9yLmVtaXQoZXZlbnQpKTtcbiAgICB9LCB0ZW1wSW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzdmdXaWR0aCA9IHRlbXBJbWFnZS53aWR0aCwgc3ZnSGVpZ2h0ID0gdGVtcEltYWdlLmhlaWdodDtcbiAgICAgIGlmICghc3ZnV2lkdGggfHwgIXN2Z0hlaWdodClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFNWRyBpbWFnZSBtdXN0IGhhdmUgd2lkdGggYW5kIGhlaWdodCBkZWZpbmVkIChpbiBwaXhlbHMpLCBjYW52YXMgQVBJIG5lZWRzIHRoZW0uXCIpO1xuICAgICAgbGV0IHdpZHRoID0gc3ZnV2lkdGggKiB0aGlzLnNjYWxlLCBoZWlnaHQgPSBzdmdIZWlnaHQgKiB0aGlzLnNjYWxlO1xuICAgICAgKHRoaXMuX292ZXJyaWRlV2lkdGggfHwgdGhpcy5fb3ZlcnJpZGVIZWlnaHQpICYmICh3aWR0aCA9IHRoaXMuX292ZXJyaWRlV2lkdGggfHwgdGhpcy5fb3ZlcnJpZGVIZWlnaHQgLyBzdmdIZWlnaHQgKiBzdmdXaWR0aCwgaGVpZ2h0ID0gdGhpcy5fb3ZlcnJpZGVIZWlnaHQgfHwgdGhpcy5fb3ZlcnJpZGVXaWR0aCAvIHN2Z1dpZHRoICogc3ZnSGVpZ2h0KSwgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5zb3VyY2U7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aCwgY2FudmFzLmhlaWdodCA9IGhlaWdodCwgY2FudmFzLl9waXhpSWQgPSBgY2FudmFzXyR7dWlkKCl9YCwgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UodGVtcEltYWdlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KSwgdGhpcy5fcmVzb2x2ZSgpLCB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc2l6ZSBmcm9tIGFuIHN2ZyBzdHJpbmcgdXNpbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqIEBwYXJhbSBzdmdTdHJpbmcgLSBhIHNlcmlhbGl6ZWQgc3ZnIGVsZW1lbnRcbiAgICogQHJldHVybnMgLSBpbWFnZSBleHRlbnNpb25cbiAgICovXG4gIHN0YXRpYyBnZXRTaXplKHN2Z1N0cmluZykge1xuICAgIGNvbnN0IHNpemVNYXRjaCA9IF9TVkdSZXNvdXJjZTIuU1ZHX1NJWkUuZXhlYyhzdmdTdHJpbmcpLCBzaXplID0ge307XG4gICAgcmV0dXJuIHNpemVNYXRjaCAmJiAoc2l6ZVtzaXplTWF0Y2hbMV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFszXSkpLCBzaXplW3NpemVNYXRjaFs1XV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzddKSkpLCBzaXplO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIHRleHR1cmUuICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpLCB0aGlzLl9yZXNvbHZlID0gbnVsbCwgdGhpcy5fY3Jvc3NvcmlnaW4gPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIElmIHRoZSBzb3VyY2UgaXMgYSBTVkcgc291cmNlIG9yIGRhdGEgZmlsZVxuICAgKi9cbiAgc3RhdGljIHRlc3Qoc291cmNlLCBleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uID09PSBcInN2Z1wiIHx8IHR5cGVvZiBzb3VyY2UgPT0gXCJzdHJpbmdcIiAmJiBzb3VyY2Uuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2Uvc3ZnK3htbFwiKSB8fCB0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIgJiYgX1NWR1Jlc291cmNlMi5TVkdfWE1MLnRlc3Qoc291cmNlKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbn07XG5fU1ZHUmVzb3VyY2UuU1ZHX1hNTCA9IC9eKDxcXD94bWxbXj9dK1xcPz4pP1xccyooPCEtLVteKC0tPildKi0tPik/XFxzKlxcPHN2Zy9tLCAvKipcbiogUmVndWxhciBleHByZXNzaW9uIGZvciBTVkcgc2l6ZS5cbiogQGV4YW1wbGUgJmx0O3N2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiJmd0OyZsdDsvc3ZnJmd0O1xuKiBAcmVhZG9ubHlcbiovXG5fU1ZHUmVzb3VyY2UuU1ZHX1NJWkUgPSAvPHN2Z1tePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKig/Olxccyh3aWR0aHxoZWlnaHQpPSgnfFwiKShcXGQqKD86XFwuXFxkKyk/KSg/OnB4KT8oJ3xcIikpW14+XSo+L2k7XG5sZXQgU1ZHUmVzb3VyY2UgPSBfU1ZHUmVzb3VyY2U7XG5leHBvcnQge1xuICBTVkdSZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1Jlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IFRpY2tlciB9IGZyb20gXCJAcGl4aS90aWNrZXJcIjtcbmltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSBcIi4vQmFzZUltYWdlUmVzb3VyY2UubWpzXCI7XG5jb25zdCBfVmlkZW9SZXNvdXJjZSA9IGNsYXNzIF9WaWRlb1Jlc291cmNlMiBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudHxvYmplY3R8c3RyaW5nfEFycmF5PHN0cmluZ3xvYmplY3Q+fSBzb3VyY2UgLSBWaWRlbyBlbGVtZW50IHRvIHVzZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgdG8gdXNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0xvYWQ9dHJ1ZV0gLSBTdGFydCBsb2FkaW5nIHRoZSB2aWRlbyBpbW1lZGlhdGVseVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9QbGF5PXRydWVdIC0gU3RhcnQgcGxheWluZyB2aWRlbyBpbW1lZGlhdGVseVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudXBkYXRlRlBTPTBdIC0gSG93IG1hbnkgdGltZXMgYSBzZWNvbmQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIHZpZGVvLlxuICAgKiBMZWF2ZSBhdCAwIHRvIHVwZGF0ZSBhdCBldmVyeSByZW5kZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NvcmlnaW49dHJ1ZV0gLSBMb2FkIGltYWdlIHVzaW5nIGNyb3NzIG9yaWdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIC0gTG9vcHMgdGhlIHZpZGVvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubXV0ZWQ9ZmFsc2VdIC0gTXV0ZXMgdGhlIHZpZGVvIGF1ZGlvLCB1c2VmdWwgZm9yIGF1dG9wbGF5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGxheXNpbmxpbmU9dHJ1ZV0gLSBQcmV2ZW50cyBvcGVuaW5nIHRoZSB2aWRlbyBvbiBtb2JpbGUgZGV2aWNlc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9LCAhKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICBvcHRpb25zLmF1dG9Mb2FkICE9PSAhMSAmJiB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwicHJlbG9hZFwiLCBcImF1dG9cIiksIG9wdGlvbnMucGxheXNpbmxpbmUgIT09ICExICYmICh2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwid2Via2l0LXBsYXlzaW5saW5lXCIsIFwiXCIpLCB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIiwgXCJcIikpLCBvcHRpb25zLm11dGVkID09PSAhMCAmJiAodmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcIm11dGVkXCIsIFwiXCIpLCB2aWRlb0VsZW1lbnQubXV0ZWQgPSAhMCksIG9wdGlvbnMubG9vcCA9PT0gITAgJiYgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcImxvb3BcIiwgXCJcIiksIG9wdGlvbnMuYXV0b1BsYXkgIT09ICExICYmIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhdXRvcGxheVwiLCBcIlwiKSwgdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiICYmIChzb3VyY2UgPSBbc291cmNlXSk7XG4gICAgICBjb25zdCBmaXJzdFNyYyA9IHNvdXJjZVswXS5zcmMgfHwgc291cmNlWzBdO1xuICAgICAgQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4odmlkZW9FbGVtZW50LCBmaXJzdFNyYywgb3B0aW9ucy5jcm9zc29yaWdpbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICAgICAgbGV0IHsgc3JjLCBtaW1lIH0gPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChzcmMgPSBzcmMgfHwgc291cmNlW2ldLCBzcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpKVxuICAgICAgICAgIG1pbWUgPSBzcmMuc2xpY2UoNSwgc3JjLmluZGV4T2YoXCI7XCIpKTtcbiAgICAgICAgZWxzZSBpZiAoIXNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHtcbiAgICAgICAgICBjb25zdCBiYXNlU3JjID0gc3JjLnNwbGl0KFwiP1wiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCksIGV4dCA9IGJhc2VTcmMuc2xpY2UoYmFzZVNyYy5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICAgICAgICBtaW1lID0gbWltZSB8fCBfVmlkZW9SZXNvdXJjZTIuTUlNRV9UWVBFU1tleHRdIHx8IGB2aWRlby8ke2V4dH1gO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZUVsZW1lbnQuc3JjID0gc3JjLCBtaW1lICYmIChzb3VyY2VFbGVtZW50LnR5cGUgPSBtaW1lKSwgdmlkZW9FbGVtZW50LmFwcGVuZENoaWxkKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgc291cmNlID0gdmlkZW9FbGVtZW50O1xuICAgIH1cbiAgICBzdXBlcihzb3VyY2UpLCB0aGlzLm5vU3ViSW1hZ2UgPSAhMCwgdGhpcy5fYXV0b1VwZGF0ZSA9ICEwLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITEsIHRoaXMuX3VwZGF0ZUZQUyA9IG9wdGlvbnMudXBkYXRlRlBTIHx8IDAsIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMCwgdGhpcy5hdXRvUGxheSA9IG9wdGlvbnMuYXV0b1BsYXkgIT09ICExLCB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrID0gdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFjay5iaW5kKHRoaXMpLCB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gbnVsbCwgdGhpcy5fbG9hZCA9IG51bGwsIHRoaXMuX3Jlc29sdmUgPSBudWxsLCB0aGlzLl9yZWplY3QgPSBudWxsLCB0aGlzLl9vbkNhblBsYXkgPSB0aGlzLl9vbkNhblBsYXkuYmluZCh0aGlzKSwgdGhpcy5fb25FcnJvciA9IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSwgdGhpcy5fb25QbGF5U3RhcnQgPSB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpLCB0aGlzLl9vblBsYXlTdG9wID0gdGhpcy5fb25QbGF5U3RvcC5iaW5kKHRoaXMpLCB0aGlzLl9vblNlZWtlZCA9IHRoaXMuX29uU2Vla2VkLmJpbmQodGhpcyksIG9wdGlvbnMuYXV0b0xvYWQgIT09ICExICYmIHRoaXMubG9hZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHVwZGF0aW5nIG9mIHRoZSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gX2RlbHRhVGltZSAtIHRpbWUgZGVsdGEgc2luY2UgbGFzdCB0aWNrXG4gICAqL1xuICB1cGRhdGUoX2RlbHRhVGltZSA9IDApIHtcbiAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBpZiAodGhpcy5fdXBkYXRlRlBTKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRNUyA9IFRpY2tlci5zaGFyZWQuZWxhcHNlZE1TICogdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlO1xuICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fbXNUb05leHRVcGRhdGUgLSBlbGFwc2VkTVMpO1xuICAgICAgfVxuICAgICAgKCF0aGlzLl91cGRhdGVGUFMgfHwgdGhpcy5fbXNUb05leHRVcGRhdGUgPD0gMCkgJiYgKHN1cGVyLnVwZGF0ZShcbiAgICAgICAgLyogZGVsdGFUaW1lKi9cbiAgICAgICksIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxZTMgLyB0aGlzLl91cGRhdGVGUFMpIDogMCk7XG4gICAgfVxuICB9XG4gIF92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrKCkge1xuICAgIHRoaXMudXBkYXRlKCksIHRoaXMuZGVzdHJveWVkID8gdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGwgOiB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gdGhpcy5zb3VyY2UucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhcbiAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBwcmVsb2FkaW5nIHRoZSB2aWRlbyByZXNvdXJjZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpXG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICByZXR1cm4gKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0ICYmIChzb3VyY2UuY29tcGxldGUgPSAhMCksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydCksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcCksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX29uU2Vla2VkKSwgdGhpcy5faXNTb3VyY2VSZWFkeSgpID8gdGhpcy5fb25DYW5QbGF5KCkgOiAoc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KSwgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCAhMCkpLCB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy52YWxpZCA/IHJlc29sdmUodGhpcykgOiAodGhpcy5fcmVzb2x2ZSA9IHJlc29sdmUsIHRoaXMuX3JlamVjdCA9IHJlamVjdCwgc291cmNlLmxvYWQoKSk7XG4gICAgfSksIHRoaXMuX2xvYWQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSB2aWRlbyBlcnJvciBldmVudHMuXG4gICAqIEBwYXJhbSBldmVudFxuICAgKi9cbiAgX29uRXJyb3IoZXZlbnQpIHtcbiAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgITApLCB0aGlzLm9uRXJyb3IuZW1pdChldmVudCksIHRoaXMuX3JlamVjdCAmJiAodGhpcy5fcmVqZWN0KGV2ZW50KSwgdGhpcy5fcmVqZWN0ID0gbnVsbCwgdGhpcy5fcmVzb2x2ZSA9IG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGlzIHBsYXlpbmcuXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBwbGF5aW5nLlxuICAgKi9cbiAgX2lzU291cmNlUGxheWluZygpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICByZXR1cm4gIXNvdXJjZS5wYXVzZWQgJiYgIXNvdXJjZS5lbmRlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyByZWFkeSBmb3IgcGxheWluZy5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHJlYWR5LlxuICAgKi9cbiAgX2lzU291cmNlUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPiAyO1xuICB9XG4gIC8qKiBSdW5zIHRoZSB1cGRhdGUgbG9vcCB3aGVuIHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5LiAqL1xuICBfb25QbGF5U3RhcnQoKSB7XG4gICAgdGhpcy52YWxpZCB8fCB0aGlzLl9vbkNhblBsYXkoKSwgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICB9XG4gIC8qKiBGaXJlZCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLCBzdG9wcyB0aGUgdXBkYXRlIGxvb3AuICovXG4gIF9vblBsYXlTdG9wKCkge1xuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgfVxuICAvKiogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgY29tcGxldGVkIHNlZWtpbmcgdG8gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24uICovXG4gIF9vblNlZWtlZCgpIHtcbiAgICB0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSAmJiAodGhpcy5fbXNUb05leHRVcGRhdGUgPSAwLCB0aGlzLnVwZGF0ZSgpLCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDApO1xuICB9XG4gIC8qKiBGaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHBsYXkuICovXG4gIF9vbkNhblBsYXkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWQ7XG4gICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwLCB0aGlzLnVwZGF0ZSgpLCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDAsICF2YWxpZCAmJiB0aGlzLl9yZXNvbHZlICYmICh0aGlzLl9yZXNvbHZlKHRoaXMpLCB0aGlzLl9yZXNvbHZlID0gbnVsbCwgdGhpcy5fcmVqZWN0ID0gbnVsbCksIHRoaXMuX2lzU291cmNlUGxheWluZygpID8gdGhpcy5fb25QbGF5U3RhcnQoKSA6IHRoaXMuYXV0b1BsYXkgJiYgc291cmNlLnBsYXkoKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyB0ZXh0dXJlLiAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBzb3VyY2UgJiYgKHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydCksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcCksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX29uU2Vla2VkKSwgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KSwgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCAhMCksIHNvdXJjZS5wYXVzZSgpLCBzb3VyY2Uuc3JjID0gXCJcIiwgc291cmNlLmxvYWQoKSksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvKiogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0LiAqL1xuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlICYmICh0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWUsIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhvdyBtYW55IHRpbWVzIGEgc2Vjb25kIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSB2aWRlby4gTGVhdmUgYXQgMCB0byB1cGRhdGUgYXQgZXZlcnkgcmVuZGVyLlxuICAgKiBBIGxvd2VyIGZwcyBjYW4gaGVscCBwZXJmb3JtYW5jZSwgYXMgdXBkYXRpbmcgdGhlIHRleHR1cmUgYXQgNjBmcHMgb24gYSAzMHBzIHZpZGVvIG1heSBub3QgYmUgZWZmaWNpZW50LlxuICAgKi9cbiAgZ2V0IHVwZGF0ZUZQUygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRlBTO1xuICB9XG4gIHNldCB1cGRhdGVGUFModmFsdWUpIHtcbiAgICB2YWx1ZSAhPT0gdGhpcy5fdXBkYXRlRlBTICYmICh0aGlzLl91cGRhdGVGUFMgPSB2YWx1ZSwgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpKTtcbiAgfVxuICBfY29uZmlndXJlQXV0b1VwZGF0ZSgpIHtcbiAgICB0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzU291cmNlUGxheWluZygpID8gIXRoaXMuX3VwZGF0ZUZQUyAmJiB0aGlzLnNvdXJjZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrID8gKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgKFRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKSwgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9ICExLCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDApLCB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID09PSBudWxsICYmICh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gdGhpcy5zb3VyY2UucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhcbiAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tcbiAgICApKSkgOiAodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSAhPT0gbnVsbCAmJiAodGhpcy5zb3VyY2UuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUpLCB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gbnVsbCksIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgfHwgKFRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKSwgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9ICEwLCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDApKSA6ICh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlICE9PSBudWxsICYmICh0aGlzLnNvdXJjZS5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2sodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSksIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsKSwgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciAmJiAoVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITEsIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMCkpO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdmlkZW8gc291cmNlXG4gICAqL1xuICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxWaWRlb0VsZW1lbnQgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fCBfVmlkZW9SZXNvdXJjZTIuVFlQRVMuaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgfVxufTtcbl9WaWRlb1Jlc291cmNlLlRZUEVTID0gW1wibXA0XCIsIFwibTR2XCIsIFwid2VibVwiLCBcIm9nZ1wiLCBcIm9ndlwiLCBcImgyNjRcIiwgXCJhdmlcIiwgXCJtb3ZcIl0sIC8qKlxuKiBNYXAgb2YgdmlkZW8gTUlNRSB0eXBlcyB0aGF0IGNhbid0IGJlIGRpcmVjdGx5IGRlcml2ZWQgZnJvbSBmaWxlIGV4dGVuc2lvbnMuXG4qIEByZWFkb25seVxuKi9cbl9WaWRlb1Jlc291cmNlLk1JTUVfVFlQRVMgPSB7XG4gIG9ndjogXCJ2aWRlby9vZ2dcIixcbiAgbW92OiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBtNHY6IFwidmlkZW8vbXA0XCJcbn07XG5sZXQgVmlkZW9SZXNvdXJjZSA9IF9WaWRlb1Jlc291cmNlO1xuZXhwb3J0IHtcbiAgVmlkZW9SZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgQXJyYXlSZXNvdXJjZSB9IGZyb20gXCIuL0FycmF5UmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBJTlNUQUxMRUQgfSBmcm9tIFwiLi9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0UmVzb3VyY2UgfSBmcm9tIFwiLi9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gXCIuL0J1ZmZlclJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgQ2FudmFzUmVzb3VyY2UgfSBmcm9tIFwiLi9DYW52YXNSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IEN1YmVSZXNvdXJjZSB9IGZyb20gXCIuL0N1YmVSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IEltYWdlQml0bWFwUmVzb3VyY2UgfSBmcm9tIFwiLi9JbWFnZUJpdG1hcFJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuL0ltYWdlUmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBTVkdSZXNvdXJjZSB9IGZyb20gXCIuL1NWR1Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgVmlkZW9SZXNvdXJjZSB9IGZyb20gXCIuL1ZpZGVvUmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuL0Jhc2VJbWFnZVJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tIFwiLi9SZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IEFic3RyYWN0TXVsdGlSZXNvdXJjZSB9IGZyb20gXCIuL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanNcIjtcbklOU1RBTExFRC5wdXNoKFxuICBJbWFnZUJpdG1hcFJlc291cmNlLFxuICBJbWFnZVJlc291cmNlLFxuICBDYW52YXNSZXNvdXJjZSxcbiAgVmlkZW9SZXNvdXJjZSxcbiAgU1ZHUmVzb3VyY2UsXG4gIEJ1ZmZlclJlc291cmNlLFxuICBDdWJlUmVzb3VyY2UsXG4gIEFycmF5UmVzb3VyY2Vcbik7XG5leHBvcnQge1xuICBBYnN0cmFjdE11bHRpUmVzb3VyY2UsXG4gIEFycmF5UmVzb3VyY2UsXG4gIEJhc2VJbWFnZVJlc291cmNlLFxuICBCdWZmZXJSZXNvdXJjZSxcbiAgQ2FudmFzUmVzb3VyY2UsXG4gIEN1YmVSZXNvdXJjZSxcbiAgSU5TVEFMTEVELFxuICBJbWFnZUJpdG1hcFJlc291cmNlLFxuICBJbWFnZVJlc291cmNlLFxuICBSZXNvdXJjZSxcbiAgU1ZHUmVzb3VyY2UsXG4gIFZpZGVvUmVzb3VyY2UsXG4gIGF1dG9EZXRlY3RSZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJAcGl4aS9ydW5uZXJcIjtcbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZ2xUcmFuc2Zvcm1GZWVkYmFja3MgPSB7fSwgdGhpcy5idWZmZXJzID0gW10sIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoXCJkaXNwb3NlVHJhbnNmb3JtRmVlZGJhY2tcIik7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgYnVmZmVyIHRvIFRyYW5zZm9ybUZlZWRiYWNrXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IHRvIGJpbmRcbiAgICogQHBhcmFtIGJ1ZmZlciAtIGJ1ZmZlciB0byBiaW5kXG4gICAqL1xuICBiaW5kQnVmZmVyKGluZGV4LCBidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlcnNbaW5kZXhdID0gYnVmZmVyO1xuICB9XG4gIC8qKiBEZXN0cm95IFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBUcmFuc2Zvcm1GZWVkYmFjay4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCAhMSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFRyYW5zZm9ybUZlZWRiYWNrXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtRmVlZGJhY2subWpzLm1hcFxuIiwiaW1wb3J0IFwiLi9zZXR0aW5ncy5tanNcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9jb2xvclwiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2NvbnN0YW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2V4dGVuc2lvbnNcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9tYXRoXCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvcnVubmVyXCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvc2V0dGluZ3NcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS90aWNrZXJcIjtcbmltcG9ydCAqIGFzIHV0aWxzJDEgZnJvbSBcIkBwaXhpL3V0aWxzXCI7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIgfSBmcm9tIFwiLi9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH0gZnJvbSBcIi4vYmFja2dyb3VuZC9CYWNrZ3JvdW5kU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgQmF0Y2hEcmF3Q2FsbCB9IGZyb20gXCIuL2JhdGNoL0JhdGNoRHJhd0NhbGwubWpzXCI7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSBcIi4vYmF0Y2gvQmF0Y2hHZW9tZXRyeS5tanNcIjtcbmltcG9ydCB7IEJhdGNoUmVuZGVyZXIgfSBmcm9tIFwiLi9iYXRjaC9CYXRjaFJlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IHsgQmF0Y2hTaGFkZXJHZW5lcmF0b3IgfSBmcm9tIFwiLi9iYXRjaC9CYXRjaFNoYWRlckdlbmVyYXRvci5tanNcIjtcbmltcG9ydCB7IEJhdGNoU3lzdGVtIH0gZnJvbSBcIi4vYmF0Y2gvQmF0Y2hTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gXCIuL2JhdGNoL0JhdGNoVGV4dHVyZUFycmF5Lm1qc1wiO1xuaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIgfSBmcm9tIFwiLi9iYXRjaC9PYmplY3RSZW5kZXJlci5tanNcIjtcbmltcG9ydCB7IENvbnRleHRTeXN0ZW0gfSBmcm9tIFwiLi9jb250ZXh0L0NvbnRleHRTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tIFwiLi9maWx0ZXJzL0ZpbHRlci5tanNcIjtcbmltcG9ydCB7IEZpbHRlclN0YXRlIH0gZnJvbSBcIi4vZmlsdGVycy9GaWx0ZXJTdGF0ZS5tanNcIjtcbmltcG9ydCB7IEZpbHRlclN5c3RlbSB9IGZyb20gXCIuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qc1wiO1xuaW1wb3J0IFwiLi9maWx0ZXJzL0lGaWx0ZXJUYXJnZXQubWpzXCI7XG5pbXBvcnQgeyBTcHJpdGVNYXNrRmlsdGVyIH0gZnJvbSBcIi4vZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIubWpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0RmlsdGVyVmVydGV4LCBkZWZhdWx0VmVydGV4IH0gZnJvbSBcIi4vZnJhZ21lbnRzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tIFwiLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlci5tanNcIjtcbmltcG9ydCB7IEZyYW1lYnVmZmVyU3lzdGVtIH0gZnJvbSBcIi4vZnJhbWVidWZmZXIvRnJhbWVidWZmZXJTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBHTEZyYW1lYnVmZmVyIH0gZnJvbSBcIi4vZnJhbWVidWZmZXIvR0xGcmFtZWJ1ZmZlci5tanNcIjtcbmltcG9ydCB7IE11bHRpc2FtcGxlU3lzdGVtIH0gZnJvbSBcIi4vZnJhbWVidWZmZXIvTXVsdGlzYW1wbGVTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBBdHRyaWJ1dGUgfSBmcm9tIFwiLi9nZW9tZXRyeS9BdHRyaWJ1dGUubWpzXCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiLi9nZW9tZXRyeS9CdWZmZXIubWpzXCI7XG5pbXBvcnQgeyBCdWZmZXJTeXN0ZW0gfSBmcm9tIFwiLi9nZW9tZXRyeS9CdWZmZXJTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCIuL2dlb21ldHJ5L0dlb21ldHJ5Lm1qc1wiO1xuaW1wb3J0IHsgR2VvbWV0cnlTeXN0ZW0gfSBmcm9tIFwiLi9nZW9tZXRyeS9HZW9tZXRyeVN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFZpZXdhYmxlQnVmZmVyIH0gZnJvbSBcIi4vZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIubWpzXCI7XG5pbXBvcnQgXCIuL0lSZW5kZXJlci5tanNcIjtcbmltcG9ydCB7IE1hc2tEYXRhIH0gZnJvbSBcIi4vbWFzay9NYXNrRGF0YS5tanNcIjtcbmltcG9ydCB7IE1hc2tTeXN0ZW0gfSBmcm9tIFwiLi9tYXNrL01hc2tTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBTY2lzc29yU3lzdGVtIH0gZnJvbSBcIi4vbWFzay9TY2lzc29yU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgU3RlbmNpbFN5c3RlbSB9IGZyb20gXCIuL21hc2svU3RlbmNpbFN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFBsdWdpblN5c3RlbSB9IGZyb20gXCIuL3BsdWdpbi9QbHVnaW5TeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBQcm9qZWN0aW9uU3lzdGVtIH0gZnJvbSBcIi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXJTeXN0ZW0gfSBmcm9tIFwiLi9yZW5kZXIvT2JqZWN0UmVuZGVyZXJTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gXCIuL1JlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IHsgQmFzZVJlbmRlclRleHR1cmUgfSBmcm9tIFwiLi9yZW5kZXJUZXh0dXJlL0Jhc2VSZW5kZXJUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH0gZnJvbSBcIi4vcmVuZGVyVGV4dHVyZS9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBSZW5kZXJUZXh0dXJlIH0gZnJvbSBcIi4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgUmVuZGVyVGV4dHVyZVBvb2wgfSBmcm9tIFwiLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLm1qc1wiO1xuaW1wb3J0IHsgUmVuZGVyVGV4dHVyZVN5c3RlbSB9IGZyb20gXCIuL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5tanNcIjtcbmltcG9ydCB7IEdMUHJvZ3JhbSwgSUdMVW5pZm9ybURhdGEgfSBmcm9tIFwiLi9zaGFkZXIvR0xQcm9ncmFtLm1qc1wiO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gXCIuL3NoYWRlci9Qcm9ncmFtLm1qc1wiO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSBcIi4vc2hhZGVyL1NoYWRlci5tanNcIjtcbmltcG9ydCB7IFNoYWRlclN5c3RlbSB9IGZyb20gXCIuL3NoYWRlci9TaGFkZXJTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tIFwiLi9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qc1wiO1xuaW1wb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gXCIuL3NoYWRlci91dGlscy9jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSBcIi4vc2hhZGVyL3V0aWxzL2dlbmVyYXRlUHJvZ3JhbS5tanNcIjtcbmltcG9ydCB7IGNyZWF0ZVVCT0VsZW1lbnRzLCBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLCBnZXRVQk9EYXRhIH0gZnJvbSBcIi4vc2hhZGVyL3V0aWxzL2dlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMubWpzXCI7XG5pbXBvcnQgeyBnZXRUZXN0Q29udGV4dCB9IGZyb20gXCIuL3NoYWRlci91dGlscy9nZXRUZXN0Q29udGV4dC5tanNcIjtcbmltcG9ydCB7IHVuaWZvcm1QYXJzZXJzIH0gZnJvbSBcIi4vc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLm1qc1wiO1xuaW1wb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gXCIuL3NoYWRlci91dGlscy91bnNhZmVFdmFsU3VwcG9ydGVkLm1qc1wiO1xuaW1wb3J0IHsgU3RhcnR1cFN5c3RlbSB9IGZyb20gXCIuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSBcIi4vc3RhdGUvU3RhdGUubWpzXCI7XG5pbXBvcnQgeyBTdGF0ZVN5c3RlbSB9IGZyb20gXCIuL3N0YXRlL1N0YXRlU3lzdGVtLm1qc1wiO1xuaW1wb3J0IFwiLi9zeXN0ZW0vSVN5c3RlbS5tanNcIjtcbmltcG9ydCBcIi4vc3lzdGVtcy5tanNcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcIi4vdGV4dHVyZXMvQmFzZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgeyBHTFRleHR1cmUgfSBmcm9tIFwiLi90ZXh0dXJlcy9HTFRleHR1cmUubWpzXCI7XG5pbXBvcnQgXCIuL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5tanNcIjtcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiLi90ZXh0dXJlcy9UZXh0dXJlLm1qc1wiO1xuaW1wb3J0IHsgVGV4dHVyZUdDU3lzdGVtIH0gZnJvbSBcIi4vdGV4dHVyZXMvVGV4dHVyZUdDU3lzdGVtLm1qc1wiO1xuaW1wb3J0IHsgVGV4dHVyZU1hdHJpeCB9IGZyb20gXCIuL3RleHR1cmVzL1RleHR1cmVNYXRyaXgubWpzXCI7XG5pbXBvcnQgeyBUZXh0dXJlU3lzdGVtIH0gZnJvbSBcIi4vdGV4dHVyZXMvVGV4dHVyZVN5c3RlbS5tanNcIjtcbmltcG9ydCB7IFRleHR1cmVVdnMgfSBmcm9tIFwiLi90ZXh0dXJlcy9UZXh0dXJlVXZzLm1qc1wiO1xuaW1wb3J0IHsgVHJhbnNmb3JtRmVlZGJhY2sgfSBmcm9tIFwiLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFjay5tanNcIjtcbmltcG9ydCB7IFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtIH0gZnJvbSBcIi4vdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBRdWFkIH0gZnJvbSBcIi4vdXRpbHMvUXVhZC5tanNcIjtcbmltcG9ydCB7IFF1YWRVdiB9IGZyb20gXCIuL3V0aWxzL1F1YWRVdi5tanNcIjtcbmltcG9ydCB7IFZpZXdTeXN0ZW0gfSBmcm9tIFwiLi92aWV3L1ZpZXdTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBTeXN0ZW1NYW5hZ2VyIH0gZnJvbSBcIi4vc3lzdGVtL1N5c3RlbU1hbmFnZXIubWpzXCI7XG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuL3RleHR1cmVzL3Jlc291cmNlcy9CYXNlSW1hZ2VSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSBcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL1Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RNdWx0aVJlc291cmNlIH0gZnJvbSBcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IEFycmF5UmVzb3VyY2UgfSBmcm9tIFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvQXJyYXlSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IElOU1RBTExFRCwgYXV0b0RldGVjdFJlc291cmNlIH0gZnJvbSBcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSBcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL0J1ZmZlclJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgQ2FudmFzUmVzb3VyY2UgfSBmcm9tIFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvQ2FudmFzUmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBDdWJlUmVzb3VyY2UgfSBmcm9tIFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvQ3ViZVJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgSW1hZ2VCaXRtYXBSZXNvdXJjZSB9IGZyb20gXCIuL3RleHR1cmVzL3Jlc291cmNlcy9JbWFnZUJpdG1hcFJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuL3RleHR1cmVzL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgU1ZHUmVzb3VyY2UgfSBmcm9tIFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvU1ZHUmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBWaWRlb1Jlc291cmNlIH0gZnJvbSBcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL1ZpZGVvUmVzb3VyY2UubWpzXCI7XG5jb25zdCBWRVJTSU9OID0gXCI3LjMuM1wiO1xuZXhwb3J0IHtcbiAgQWJzdHJhY3RNdWx0aVJlc291cmNlLFxuICBBcnJheVJlc291cmNlLFxuICBBdHRyaWJ1dGUsXG4gIEJhY2tncm91bmRTeXN0ZW0sXG4gIEJhc2VJbWFnZVJlc291cmNlLFxuICBCYXNlUmVuZGVyVGV4dHVyZSxcbiAgQmFzZVRleHR1cmUsXG4gIEJhdGNoRHJhd0NhbGwsXG4gIEJhdGNoR2VvbWV0cnksXG4gIEJhdGNoUmVuZGVyZXIsXG4gIEJhdGNoU2hhZGVyR2VuZXJhdG9yLFxuICBCYXRjaFN5c3RlbSxcbiAgQmF0Y2hUZXh0dXJlQXJyYXksXG4gIEJ1ZmZlcixcbiAgQnVmZmVyUmVzb3VyY2UsXG4gIEJ1ZmZlclN5c3RlbSxcbiAgQ2FudmFzUmVzb3VyY2UsXG4gIENvbnRleHRTeXN0ZW0sXG4gIEN1YmVSZXNvdXJjZSxcbiAgRmlsdGVyLFxuICBGaWx0ZXJTdGF0ZSxcbiAgRmlsdGVyU3lzdGVtLFxuICBGcmFtZWJ1ZmZlcixcbiAgRnJhbWVidWZmZXJTeXN0ZW0sXG4gIEdMRnJhbWVidWZmZXIsXG4gIEdMUHJvZ3JhbSxcbiAgR0xUZXh0dXJlLFxuICBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0sXG4gIEdlb21ldHJ5LFxuICBHZW9tZXRyeVN5c3RlbSxcbiAgSUdMVW5pZm9ybURhdGEsXG4gIElOU1RBTExFRCxcbiAgSW1hZ2VCaXRtYXBSZXNvdXJjZSxcbiAgSW1hZ2VSZXNvdXJjZSxcbiAgTWFza0RhdGEsXG4gIE1hc2tTeXN0ZW0sXG4gIE11bHRpc2FtcGxlU3lzdGVtLFxuICBPYmplY3RSZW5kZXJlcixcbiAgT2JqZWN0UmVuZGVyZXJTeXN0ZW0sXG4gIFBsdWdpblN5c3RlbSxcbiAgUHJvZ3JhbSxcbiAgUHJvamVjdGlvblN5c3RlbSxcbiAgUXVhZCxcbiAgUXVhZFV2LFxuICBSZW5kZXJUZXh0dXJlLFxuICBSZW5kZXJUZXh0dXJlUG9vbCxcbiAgUmVuZGVyVGV4dHVyZVN5c3RlbSxcbiAgUmVuZGVyZXIsXG4gIFJlc291cmNlLFxuICBTVkdSZXNvdXJjZSxcbiAgU2Npc3NvclN5c3RlbSxcbiAgU2hhZGVyLFxuICBTaGFkZXJTeXN0ZW0sXG4gIFNwcml0ZU1hc2tGaWx0ZXIsXG4gIFN0YXJ0dXBTeXN0ZW0sXG4gIFN0YXRlLFxuICBTdGF0ZVN5c3RlbSxcbiAgU3RlbmNpbFN5c3RlbSxcbiAgU3lzdGVtTWFuYWdlcixcbiAgVGV4dHVyZSxcbiAgVGV4dHVyZUdDU3lzdGVtLFxuICBUZXh0dXJlTWF0cml4LFxuICBUZXh0dXJlU3lzdGVtLFxuICBUZXh0dXJlVXZzLFxuICBUcmFuc2Zvcm1GZWVkYmFjayxcbiAgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0sXG4gIFVuaWZvcm1Hcm91cCxcbiAgVkVSU0lPTixcbiAgVmlkZW9SZXNvdXJjZSxcbiAgVmlld1N5c3RlbSxcbiAgVmlld2FibGVCdWZmZXIsXG4gIGF1dG9EZXRlY3RSZW5kZXJlcixcbiAgYXV0b0RldGVjdFJlc291cmNlLFxuICBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLFxuICBjcmVhdGVVQk9FbGVtZW50cyxcbiAgZGVmYXVsdEZpbHRlclZlcnRleCxcbiAgZGVmYXVsdFZlcnRleCxcbiAgZ2VuZXJhdGVQcm9ncmFtLFxuICBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLFxuICBnZXRUZXN0Q29udGV4dCxcbiAgZ2V0VUJPRGF0YSxcbiAgdW5pZm9ybVBhcnNlcnMsXG4gIHVuc2FmZUV2YWxTdXBwb3J0ZWQsXG4gIHV0aWxzJDEgYXMgdXRpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuY2xhc3MgQm91bmRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5taW5YID0gMSAvIDAsIHRoaXMubWluWSA9IDEgLyAwLCB0aGlzLm1heFggPSAtMSAvIDAsIHRoaXMubWF4WSA9IC0xIC8gMCwgdGhpcy5yZWN0ID0gbnVsbCwgdGhpcy51cGRhdGVJRCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYm91bmRzIGFyZSBlbXB0eS5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WTtcbiAgfVxuICAvKiogQ2xlYXJzIHRoZSBib3VuZHMgYW5kIHJlc2V0cy4gKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5taW5YID0gMSAvIDAsIHRoaXMubWluWSA9IDEgLyAwLCB0aGlzLm1heFggPSAtMSAvIDAsIHRoaXMubWF4WSA9IC0xIC8gMDtcbiAgfVxuICAvKipcbiAgICogQ2FuIHJldHVybiBSZWN0YW5nbGUuRU1QVFkgY29uc3RhbnQsIGVpdGhlciBjb25zdHJ1Y3QgbmV3IHJlY3RhbmdsZSwgZWl0aGVyIHVzZSB5b3VyIHJlY3RhbmdsZVxuICAgKiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IGl0IHdpbGwgcmV0dXJuIHRlbXBSZWN0XG4gICAqIEBwYXJhbSByZWN0IC0gVGVtcG9yYXJ5IG9iamVjdCB3aWxsIGJlIHVzZWQgaWYgQUFCQiBpcyBub3QgZW1wdHlcbiAgICogQHJldHVybnMgLSBBIHJlY3RhbmdsZSBvZiB0aGUgYm91bmRzXG4gICAqL1xuICBnZXRSZWN0YW5nbGUocmVjdCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZID8gUmVjdGFuZ2xlLkVNUFRZIDogKHJlY3QgPSByZWN0IHx8IG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSksIHJlY3QueCA9IHRoaXMubWluWCwgcmVjdC55ID0gdGhpcy5taW5ZLCByZWN0LndpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YLCByZWN0LmhlaWdodCA9IHRoaXMubWF4WSAtIHRoaXMubWluWSwgcmVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBhZGQuXG4gICAqL1xuICBhZGRQb2ludChwb2ludCkge1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcG9pbnQueCksIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcG9pbnQueCksIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcG9pbnQueSksIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcG9pbnQueSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwb2ludCwgYWZ0ZXIgdHJhbnNmb3JtZWQuIFRoaXMgc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAqIEBwYXJhbSBtYXRyaXhcbiAgICogQHBhcmFtIHBvaW50XG4gICAqL1xuICBhZGRQb2ludE1hdHJpeChtYXRyaXgsIHBvaW50KSB7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCB0eCwgdHkgfSA9IG1hdHJpeCwgeCA9IGEgKiBwb2ludC54ICsgYyAqIHBvaW50LnkgKyB0eCwgeSA9IGIgKiBwb2ludC54ICsgZCAqIHBvaW50LnkgKyB0eTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHgpLCB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHgpLCB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpLCB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHkpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcXVhZCwgbm90IHRyYW5zZm9ybWVkXG4gICAqIEBwYXJhbSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0cyB0byBhZGQuXG4gICAqL1xuICBhZGRRdWFkKHZlcnRpY2VzKSB7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFksIHggPSB2ZXJ0aWNlc1swXSwgeSA9IHZlcnRpY2VzWzFdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YLCBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWSwgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFgsIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZLCB4ID0gdmVydGljZXNbMl0sIHkgPSB2ZXJ0aWNlc1szXSwgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblgsIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZLCBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WCwgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFksIHggPSB2ZXJ0aWNlc1s0XSwgeSA9IHZlcnRpY2VzWzVdLCBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WSwgeCA9IHZlcnRpY2VzWzZdLCB5ID0gdmVydGljZXNbN10sIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YLCBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWSwgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFgsIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZLCB0aGlzLm1pblggPSBtaW5YLCB0aGlzLm1pblkgPSBtaW5ZLCB0aGlzLm1heFggPSBtYXhYLCB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgdHJhbnNmb3JtZWQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSB0cmFuc2Zvcm0gdG8gYXBwbHlcbiAgICogQHBhcmFtIHgwIC0gbGVmdCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MCAtIHRvcCBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB4MSAtIHJpZ2h0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkxIC0gYm90dG9tIFkgb2YgZnJhbWVcbiAgICovXG4gIGFkZEZyYW1lKHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLmFkZEZyYW1lTWF0cml4KHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgbXVsdGlwbGllZCBieSBtYXRyaXhcbiAgICogQHBhcmFtIG1hdHJpeCAtIG1hdHJpeCB0byBhcHBseVxuICAgKiBAcGFyYW0geDAgLSBsZWZ0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkwIC0gdG9wIFkgb2YgZnJhbWVcbiAgICogQHBhcmFtIHgxIC0gcmlnaHQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTEgLSBib3R0b20gWSBvZiBmcmFtZVxuICAgKi9cbiAgYWRkRnJhbWVNYXRyaXgobWF0cml4LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYSwgYiA9IG1hdHJpeC5iLCBjID0gbWF0cml4LmMsIGQgPSBtYXRyaXguZCwgdHggPSBtYXRyaXgudHgsIHR5ID0gbWF0cml4LnR5O1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YLCBtaW5ZID0gdGhpcy5taW5ZLCBtYXhYID0gdGhpcy5tYXhYLCBtYXhZID0gdGhpcy5tYXhZLCB4ID0gYSAqIHgwICsgYyAqIHkwICsgdHgsIHkgPSBiICogeDAgKyBkICogeTAgKyB0eTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WSwgeCA9IGEgKiB4MSArIGMgKiB5MCArIHR4LCB5ID0gYiAqIHgxICsgZCAqIHkwICsgdHksIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YLCBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWSwgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFgsIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZLCB4ID0gYSAqIHgwICsgYyAqIHkxICsgdHgsIHkgPSBiICogeDAgKyBkICogeTEgKyB0eSwgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblgsIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZLCBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WCwgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFksIHggPSBhICogeDEgKyBjICogeTEgKyB0eCwgeSA9IGIgKiB4MSArIGQgKiB5MSArIHR5LCBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WSwgdGhpcy5taW5YID0gbWluWCwgdGhpcy5taW5ZID0gbWluWSwgdGhpcy5tYXhYID0gbWF4WCwgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzY3JlZW4gdmVydGljZXMgZnJvbSBhcnJheVxuICAgKiBAcGFyYW0gdmVydGV4RGF0YSAtIGNhbGN1bGF0ZWQgdmVydGljZXNcbiAgICogQHBhcmFtIGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBlbmQgb2Zmc2V0LCBleGNsdWRlZFxuICAgKi9cbiAgYWRkVmVydGV4RGF0YSh2ZXJ0ZXhEYXRhLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG4gICAgZm9yIChsZXQgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0ZXhEYXRhW2ldLCB5ID0gdmVydGV4RGF0YVtpICsgMV07XG4gICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWCwgdGhpcy5taW5ZID0gbWluWSwgdGhpcy5tYXhYID0gbWF4WCwgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkIGFuIGFycmF5IG9mIG1lc2ggdmVydGljZXNcbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIG1lc2ggdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB2ZXJ0aWNlcyAtIG1lc2ggY29vcmRpbmF0ZXMgaW4gYXJyYXlcbiAgICogQHBhcmFtIGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBlbmQgb2Zmc2V0LCBleGNsdWRlZFxuICAgKi9cbiAgYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHRoaXMuYWRkVmVydGljZXNNYXRyaXgodHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBhcnJheSBvZiBtZXNoIHZlcnRpY2VzLlxuICAgKiBAcGFyYW0gbWF0cml4IC0gbWVzaCBtYXRyaXhcbiAgICogQHBhcmFtIHZlcnRpY2VzIC0gbWVzaCBjb29yZGluYXRlcyBpbiBhcnJheVxuICAgKiBAcGFyYW0gYmVnaW5PZmZzZXQgLSBiZWdpbiBvZmZzZXRcbiAgICogQHBhcmFtIGVuZE9mZnNldCAtIGVuZCBvZmZzZXQsIGV4Y2x1ZGVkXG4gICAqIEBwYXJhbSBwYWRYIC0geCBwYWRkaW5nXG4gICAqIEBwYXJhbSBwYWRZIC0geSBwYWRkaW5nXG4gICAqL1xuICBhZGRWZXJ0aWNlc01hdHJpeChtYXRyaXgsIHZlcnRpY2VzLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0LCBwYWRYID0gMCwgcGFkWSA9IHBhZFgpIHtcbiAgICBjb25zdCBhID0gbWF0cml4LmEsIGIgPSBtYXRyaXguYiwgYyA9IG1hdHJpeC5jLCBkID0gbWF0cml4LmQsIHR4ID0gbWF0cml4LnR4LCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWCwgbWluWSA9IHRoaXMubWluWSwgbWF4WCA9IHRoaXMubWF4WCwgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBmb3IgKGxldCBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgcmF3WCA9IHZlcnRpY2VzW2ldLCByYXdZID0gdmVydGljZXNbaSArIDFdLCB4ID0gYSAqIHJhd1ggKyBjICogcmF3WSArIHR4LCB5ID0gZCAqIHJhd1kgKyBiICogcmF3WCArIHR5O1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHggLSBwYWRYKSwgbWF4WCA9IE1hdGgubWF4KG1heFgsIHggKyBwYWRYKSwgbWluWSA9IE1hdGgubWluKG1pblksIHkgLSBwYWRZKSwgbWF4WSA9IE1hdGgubWF4KG1heFksIHkgKyBwYWRZKTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWCwgdGhpcy5taW5ZID0gbWluWSwgdGhpcy5tYXhYID0gbWF4WCwgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvdGhlciB7QGxpbmsgUElYSS5Cb3VuZHN9LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIEJvdW5kcyB0byBiZSBhZGRlZFxuICAgKi9cbiAgYWRkQm91bmRzKGJvdW5kcykge1xuICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG4gICAgdGhpcy5taW5YID0gYm91bmRzLm1pblggPCBtaW5YID8gYm91bmRzLm1pblggOiBtaW5YLCB0aGlzLm1pblkgPSBib3VuZHMubWluWSA8IG1pblkgPyBib3VuZHMubWluWSA6IG1pblksIHRoaXMubWF4WCA9IGJvdW5kcy5tYXhYID4gbWF4WCA/IGJvdW5kcy5tYXhYIDogbWF4WCwgdGhpcy5tYXhZID0gYm91bmRzLm1heFkgPiBtYXhZID8gYm91bmRzLm1heFkgOiBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzLlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIEJvdW5kcyB0byBiZSBhZGRlZC5cbiAgICogQHBhcmFtIG1hc2sgLSBUT0RPXG4gICAqL1xuICBhZGRCb3VuZHNNYXNrKGJvdW5kcywgbWFzaykge1xuICAgIGNvbnN0IF9taW5YID0gYm91bmRzLm1pblggPiBtYXNrLm1pblggPyBib3VuZHMubWluWCA6IG1hc2subWluWCwgX21pblkgPSBib3VuZHMubWluWSA+IG1hc2subWluWSA/IGJvdW5kcy5taW5ZIDogbWFzay5taW5ZLCBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgbWFzay5tYXhYID8gYm91bmRzLm1heFggOiBtYXNrLm1heFgsIF9tYXhZID0gYm91bmRzLm1heFkgPCBtYXNrLm1heFkgPyBib3VuZHMubWF4WSA6IG1hc2subWF4WTtcbiAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblgsIHRoaXMubWluWSA9IF9taW5ZIDwgbWluWSA/IF9taW5ZIDogbWluWSwgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYLCB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbXVsdGlwbGllZCBieSBtYXRyaXguIEJvdW5kcyBzaG91bGRuJ3QgYmUgZW1wdHkuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBvdGhlciBib3VuZHNcbiAgICogQHBhcmFtIG1hdHJpeCAtIG11bHRpcGxpY2F0b3JcbiAgICovXG4gIGFkZEJvdW5kc01hdHJpeChib3VuZHMsIG1hdHJpeCkge1xuICAgIHRoaXMuYWRkRnJhbWVNYXRyaXgobWF0cml4LCBib3VuZHMubWluWCwgYm91bmRzLm1pblksIGJvdW5kcy5tYXhYLCBib3VuZHMubWF4WSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtYXNrZWQgd2l0aCBSZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUT0RPXG4gICAqIEBwYXJhbSBhcmVhIC0gVE9ET1xuICAgKi9cbiAgYWRkQm91bmRzQXJlYShib3VuZHMsIGFyZWEpIHtcbiAgICBjb25zdCBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLngsIF9taW5ZID0gYm91bmRzLm1pblkgPiBhcmVhLnkgPyBib3VuZHMubWluWSA6IGFyZWEueSwgX21heFggPSBib3VuZHMubWF4WCA8IGFyZWEueCArIGFyZWEud2lkdGggPyBib3VuZHMubWF4WCA6IGFyZWEueCArIGFyZWEud2lkdGgsIF9tYXhZID0gYm91bmRzLm1heFkgPCBhcmVhLnkgKyBhcmVhLmhlaWdodCA/IGJvdW5kcy5tYXhZIDogYXJlYS55ICsgYXJlYS5oZWlnaHQ7XG4gICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICBjb25zdCBtaW5YID0gdGhpcy5taW5YLCBtaW5ZID0gdGhpcy5taW5ZLCBtYXhYID0gdGhpcy5tYXhYLCBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YLCB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblksIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WCwgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFkcyBib3VuZHMgb2JqZWN0LCBtYWtpbmcgaXQgZ3JvdyBpbiBhbGwgZGlyZWN0aW9ucy5cbiAgICogSWYgcGFkZGluZ1kgaXMgb21pdHRlZCwgYm90aCBwYWRkaW5nWCBhbmQgcGFkZGluZ1kgd2lsbCBiZSBzZXQgdG8gcGFkZGluZ1guXG4gICAqIEBwYXJhbSBwYWRkaW5nWCAtIFRoZSBob3Jpem9udGFsIHBhZGRpbmcgYW1vdW50LlxuICAgKiBAcGFyYW0gcGFkZGluZ1kgLSBUaGUgdmVydGljYWwgcGFkZGluZyBhbW91bnQuXG4gICAqL1xuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgdGhpcy5pc0VtcHR5KCkgfHwgKHRoaXMubWluWCAtPSBwYWRkaW5nWCwgdGhpcy5tYXhYICs9IHBhZGRpbmdYLCB0aGlzLm1pblkgLT0gcGFkZGluZ1ksIHRoaXMubWF4WSArPSBwYWRkaW5nWSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgcGFkZGVkIGZyYW1lLiAoeDAsIHkwKSBzaG91bGQgYmUgc3RyaWN0bHkgbGVzcyB0aGFuICh4MSwgeTEpXG4gICAqIEBwYXJhbSB4MCAtIGxlZnQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTAgLSB0b3AgWSBvZiBmcmFtZVxuICAgKiBAcGFyYW0geDEgLSByaWdodCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MSAtIGJvdHRvbSBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSBwYWRYIC0gcGFkZGluZyBYXG4gICAqIEBwYXJhbSBwYWRZIC0gcGFkZGluZyBZXG4gICAqL1xuICBhZGRGcmFtZVBhZCh4MCwgeTAsIHgxLCB5MSwgcGFkWCwgcGFkWSkge1xuICAgIHgwIC09IHBhZFgsIHkwIC09IHBhZFksIHgxICs9IHBhZFgsIHkxICs9IHBhZFksIHRoaXMubWluWCA9IHRoaXMubWluWCA8IHgwID8gdGhpcy5taW5YIDogeDAsIHRoaXMubWF4WCA9IHRoaXMubWF4WCA+IHgxID8gdGhpcy5tYXhYIDogeDEsIHRoaXMubWluWSA9IHRoaXMubWluWSA8IHkwID8gdGhpcy5taW5ZIDogeTAsIHRoaXMubWF4WSA9IHRoaXMubWF4WSA+IHkxID8gdGhpcy5tYXhZIDogeTE7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEJvdW5kc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kcy5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscywgVHJhbnNmb3JtLCBSZWN0YW5nbGUsIFJBRF9UT19ERUcsIERFR19UT19SQUQgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSBcIi4vQm91bmRzLm1qc1wiO1xuY2xhc3MgRGlzcGxheU9iamVjdCBleHRlbmRzIHV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBudWxsLCB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKSwgdGhpcy5hbHBoYSA9IDEsIHRoaXMudmlzaWJsZSA9ICEwLCB0aGlzLnJlbmRlcmFibGUgPSAhMCwgdGhpcy5jdWxsYWJsZSA9ICExLCB0aGlzLmN1bGxBcmVhID0gbnVsbCwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLndvcmxkQWxwaGEgPSAxLCB0aGlzLl9sYXN0U29ydGVkSW5kZXggPSAwLCB0aGlzLl96SW5kZXggPSAwLCB0aGlzLmZpbHRlckFyZWEgPSBudWxsLCB0aGlzLmZpbHRlcnMgPSBudWxsLCB0aGlzLl9lbmFibGVkRmlsdGVycyA9IG51bGwsIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMoKSwgdGhpcy5fbG9jYWxCb3VuZHMgPSBudWxsLCB0aGlzLl9ib3VuZHNJRCA9IDAsIHRoaXMuX2JvdW5kc1JlY3QgPSBudWxsLCB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBudWxsLCB0aGlzLl9tYXNrID0gbnVsbCwgdGhpcy5fbWFza1JlZkNvdW50ID0gMCwgdGhpcy5fZGVzdHJveWVkID0gITEsIHRoaXMuaXNTcHJpdGUgPSAhMSwgdGhpcy5pc01hc2sgPSAhMTtcbiAgfVxuICAvKipcbiAgICogTWl4ZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBEaXNwbGF5T2JqZWN0LlxuICAgKiBAcGFyYW0gc291cmNlIC0gVGhlIHNvdXJjZSBvZiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRvIG1peCBpbi5cbiAgICovXG4gIHN0YXRpYyBtaXhpbihzb3VyY2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGtleXNbaV07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIERpc3BsYXlPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wZXJ0eU5hbWUpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGlzIERpc3BsYXlPYmplY3QgaXMgYWRkZWQgdG8gYSBDb250YWluZXIuXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZXZlbnQgYWRkZWRcbiAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciBhZGRlZCB0by5cbiAgICovXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoaXMgRGlzcGxheU9iamVjdCBpcyByZW1vdmVkIGZyb20gYSBDb250YWluZXIuXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZXZlbnQgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHJlbW92ZWQgZnJvbS5cbiAgICovXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoaXMgRGlzcGxheU9iamVjdCBpcyBkZXN0cm95ZWQuIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBvbmNlXG4gICAqIGRlc3Ryb3kgaXMgZmluaXNoZWQuXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZXZlbnQgZGVzdHJveWVkXG4gICAqL1xuICAvKiogUmVhZG9ubHkgZmxhZyBmb3IgZGVzdHJveWVkIGRpc3BsYXkgb2JqZWN0cy4gKi9cbiAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVzdHJveWVkO1xuICB9XG4gIC8qKiBSZWN1cnNpdmVseSB1cGRhdGVzIHRyYW5zZm9ybSBvZiBhbGwgb2JqZWN0cyBmcm9tIHRoZSByb290IHRvIHRoaXMgb25lIGludGVybmFsIGZ1bmN0aW9uIGZvciB0b0xvY2FsKCkgKi9cbiAgX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5wYXJlbnQgPyAodGhpcy5wYXJlbnQuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSkpIDogdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybSk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZy4gVE9ETyAtIE9wdGltaXphdGlvbiBwYXNzISAqL1xuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5fYm91bmRzSUQrKywgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSksIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSAod29ybGQpIGJvdW5kcyBvZiB0aGUgZGlzcGxheSBvYmplY3QgYXMgYSBbUmVjdGFuZ2xlXXtAbGluayBQSVhJLlJlY3RhbmdsZX0uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZSBvbiBjb250YWluZXJzIHdpdGggYSBsYXJnZSBzdWJ0cmVlIChsaWtlIHRoZSBzdGFnZSkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYm91bmRzXG4gICAqIG9mIGEgY29udGFpbmVyIGRlcGVuZCBvbiBpdHMgY2hpbGRyZW4ncyBib3VuZHMsIHdoaWNoIHJlY3Vyc2l2ZWx5IGNhdXNlcyBhbGwgYm91bmRzIGluIHRoZSBzdWJ0cmVlIHRvXG4gICAqIGJlIHJlY2FsY3VsYXRlZC4gVGhlIHVwc2lkZSwgaG93ZXZlciwgaXMgdGhhdCBjYWxsaW5nIGBnZXRCb3VuZHNgIG9uY2Ugb24gYSBjb250YWluZXIgd2lsbCBpbmRlZWQgdXBkYXRlXG4gICAqIHRoZSBib3VuZHMgb2YgYWxsIGNoaWxkcmVuICh0aGUgd2hvbGUgc3VidHJlZSwgaW4gZmFjdCkuIFRoaXMgc2lkZSBlZmZlY3Qgc2hvdWxkIGJlIGV4cGxvaXRlZCBieSB1c2luZ1xuICAgKiBgZGlzcGxheU9iamVjdC5fYm91bmRzLmdldFJlY3RhbmdsZSgpYCB3aGVuIHRyYXZlcnNpbmcgdGhyb3VnaCBhbGwgdGhlIGJvdW5kcyBpbiBhIHNjZW5lIGdyYXBoLiBPdGhlcndpc2UsXG4gICAqIGNhbGxpbmcgYGdldEJvdW5kc2Agb24gZWFjaCBvYmplY3QgaW4gYSBzdWJ0cmVlIHdpbGwgY2F1c2UgdGhlIHRvdGFsIGNvc3QgdG8gaW5jcmVhc2UgcXVhZHJhdGljYWxseSBhc1xuICAgKiBpdHMgaGVpZ2h0IGluY3JlYXNlcy5cbiAgICpcbiAgICogVGhlIHRyYW5zZm9ybXMgb2YgYWxsIG9iamVjdHMgaW4gYSBjb250YWluZXIncyAqKnN1YnRyZWUqKiBhbmQgb2YgYWxsICoqYW5jZXN0b3JzKiogYXJlIHVwZGF0ZWQuXG4gICAqIFRoZSB3b3JsZCBib3VuZHMgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyBpbiBhIGNvbnRhaW5lcidzICoqc3VidHJlZSoqIHdpbGwgYWxzbyBiZSByZWNhbGN1bGF0ZWQuXG4gICAqXG4gICAqIFRoZSBgX2JvdW5kc2Agb2JqZWN0IHN0b3JlcyB0aGUgbGFzdCBjYWxjdWxhdGlvbiBvZiB0aGUgYm91bmRzLiBZb3UgY2FuIHVzZSB0byBlbnRpcmVseSBza2lwIGJvdW5kc1xuICAgKiBjYWxjdWxhdGlvbiBpZiBuZWVkZWQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGxhc3RDYWxjdWxhdGVkQm91bmRzID0gZGlzcGxheU9iamVjdC5fYm91bmRzLmdldFJlY3RhbmdsZShvcHRpb25hbFJlY3QpO1xuICAgKiBgYGBcbiAgICpcbiAgICogRG8ga25vdyB0aGF0IHVzYWdlIG9mIGBnZXRMb2NhbEJvdW5kc2AgY2FuIGNvcnJ1cHQgdGhlIGBfYm91bmRzYCBvZiBjaGlsZHJlbiAodGhlIHdob2xlIHN1YnRyZWUsIGFjdHVhbGx5KS4gVGhpc1xuICAgKiBpcyBhIGtub3duIGlzc3VlIHRoYXQgaGFzIG5vdCBiZWVuIHNvbHZlZC4gU2VlIFtnZXRMb2NhbEJvdW5kc117QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0I2dldExvY2FsQm91bmRzfSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzLlxuICAgKlxuICAgKiBgZ2V0Qm91bmRzYCBzaG91bGQgYmUgY2FsbGVkIHdpdGggYHNraXBVcGRhdGVgIGVxdWFsIHRvIGB0cnVlYCBpbiBhIHJlbmRlcigpIGNhbGwuIFRoaXMgaXMgYmVjYXVzZSB0aGUgdHJhbnNmb3Jtc1xuICAgKiBhcmUgZ3VhcmFudGVlZCB0byBiZSB1cGRhdGUtdG8tZGF0ZS4gSW4gZmFjdCwgcmVjYWxjdWxhdGluZyBpbnNpZGUgYSByZW5kZXIoKSBjYWxsIG1heSBjYXVzZSBjb3JydXB0aW9uIGluIGNlcnRhaW5cbiAgICogY2FzZXMuXG4gICAqIEBwYXJhbSBza2lwVXBkYXRlIC0gU2V0dGluZyB0byBgdHJ1ZWAgd2lsbCBzdG9wIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBzY2VuZSBncmFwaCBmcm9tXG4gICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxuICAgKiAgbmljZSBwZXJmb3JtYW5jZSBib29zdC5cbiAgICogQHBhcmFtIHJlY3QgLSBPcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYm91bmRzIGNhbGN1bGF0aW9uLlxuICAgKiBAcmV0dXJucyAtIFRoZSBtaW5pbXVtIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgaW4gd29ybGQgc3BhY2UgdGhhdCBmaXRzIGFyb3VuZCB0aGlzIG9iamVjdC5cbiAgICovXG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgcmV0dXJuIHNraXBVcGRhdGUgfHwgKHRoaXMucGFyZW50ID8gKHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSkgOiAodGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy5wYXJlbnQgPSBudWxsKSksIHRoaXMuX2JvdW5kcy51cGRhdGVJRCAhPT0gdGhpcy5fYm91bmRzSUQgJiYgKHRoaXMuY2FsY3VsYXRlQm91bmRzKCksIHRoaXMuX2JvdW5kcy51cGRhdGVJRCA9IHRoaXMuX2JvdW5kc0lEKSwgcmVjdCB8fCAodGhpcy5fYm91bmRzUmVjdCB8fCAodGhpcy5fYm91bmRzUmVjdCA9IG5ldyBSZWN0YW5nbGUoKSksIHJlY3QgPSB0aGlzLl9ib3VuZHNSZWN0KSwgdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm5zIC0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWEuXG4gICAqL1xuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgcmVjdCB8fCAodGhpcy5fbG9jYWxCb3VuZHNSZWN0IHx8ICh0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlKCkpLCByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSwgdGhpcy5fbG9jYWxCb3VuZHMgfHwgKHRoaXMuX2xvY2FsQm91bmRzID0gbmV3IEJvdW5kcygpKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1SZWYgPSB0aGlzLnRyYW5zZm9ybSwgcGFyZW50UmVmID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC53b3JsZEFscGhhID0gcGFyZW50UmVmPy53b3JsZEFscGhhID8/IDEsIHRoaXMudHJhbnNmb3JtID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtO1xuICAgIGNvbnN0IHdvcmxkQm91bmRzID0gdGhpcy5fYm91bmRzLCB3b3JsZEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XG4gICAgdGhpcy5fYm91bmRzID0gdGhpcy5fbG9jYWxCb3VuZHM7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoITEsIHJlY3QpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA9IHBhcmVudFJlZiwgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWYsIHRoaXMuX2JvdW5kcyA9IHdvcmxkQm91bmRzLCB0aGlzLl9ib3VuZHMudXBkYXRlSUQgKz0gdGhpcy5fYm91bmRzSUQgLSB3b3JsZEJvdW5kc0lELCBib3VuZHM7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAqIEBwYXJhbSBwb2ludCAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAqL1xuICB0b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUgPSAhMSkge1xuICAgIHJldHVybiBza2lwVXBkYXRlIHx8ICh0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID8gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCkgOiAodGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID0gbnVsbCkpLCB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCByZWxhdGl2ZSB0byBhbm90aGVyIHBvaW50LlxuICAgKiBAcGFyYW0gcG9zaXRpb24gLSBUaGUgd29ybGQgb3JpZ2luIHRvIGNhbGN1bGF0ZSBmcm9tLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgZ2xvYmFsIHBvc2l0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwb2ludCAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm5zIC0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxuICAgKi9cbiAgdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcbiAgICByZXR1cm4gZnJvbSAmJiAocG9zaXRpb24gPSBmcm9tLnRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSkpLCBza2lwVXBkYXRlIHx8ICh0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID8gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCkgOiAodGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID0gbnVsbCkpLCB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHBhcmVudCBDb250YWluZXIgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIENvbnRhaW5lciB0byBhZGQgdGhpcyBEaXNwbGF5T2JqZWN0IHRvLlxuICAgKiBAcmV0dXJucyAtIFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvLlxuICAgKi9cbiAgc2V0UGFyZW50KGNvbnRhaW5lcikge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIuYWRkQ2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXJcIik7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzKSwgY29udGFpbmVyO1xuICB9XG4gIC8qKiBSZW1vdmUgdGhlIERpc3BsYXlPYmplY3QgZnJvbSBpdHMgcGFyZW50IENvbnRhaW5lci4gSWYgdGhlIERpc3BsYXlPYmplY3QgaGFzIG5vIHBhcmVudCwgZG8gbm90aGluZy4gKi9cbiAgcmVtb3ZlRnJvbVBhcmVudCgpIHtcbiAgICB0aGlzLnBhcmVudD8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldCB0aGUgcG9zaXRpb24sIHNjYWxlLCBza2V3IGFuZCBwaXZvdCBhdCBvbmNlLlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgcG9zaXRpb25cbiAgICogQHBhcmFtIHNjYWxlWCAtIFRoZSBYIHNjYWxlIHZhbHVlXG4gICAqIEBwYXJhbSBzY2FsZVkgLSBUaGUgWSBzY2FsZSB2YWx1ZVxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb25cbiAgICogQHBhcmFtIHNrZXdYIC0gVGhlIFggc2tldyB2YWx1ZVxuICAgKiBAcGFyYW0gc2tld1kgLSBUaGUgWSBza2V3IHZhbHVlXG4gICAqIEBwYXJhbSBwaXZvdFggLSBUaGUgWCBwaXZvdCB2YWx1ZVxuICAgKiBAcGFyYW0gcGl2b3RZIC0gVGhlIFkgcGl2b3QgdmFsdWVcbiAgICogQHJldHVybnMgLSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICAgKi9cbiAgc2V0VHJhbnNmb3JtKHggPSAwLCB5ID0gMCwgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgcm90YXRpb24gPSAwLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgcGl2b3RYID0gMCwgcGl2b3RZID0gMCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnggPSB4LCB0aGlzLnBvc2l0aW9uLnkgPSB5LCB0aGlzLnNjYWxlLnggPSBzY2FsZVggfHwgMSwgdGhpcy5zY2FsZS55ID0gc2NhbGVZIHx8IDEsIHRoaXMucm90YXRpb24gPSByb3RhdGlvbiwgdGhpcy5za2V3LnggPSBza2V3WCwgdGhpcy5za2V3LnkgPSBza2V3WSwgdGhpcy5waXZvdC54ID0gcGl2b3RYLCB0aGlzLnBpdm90LnkgPSBwaXZvdFksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEJhc2UgZGVzdHJveSBtZXRob2QgZm9yIGdlbmVyaWMgZGlzcGxheSBvYmplY3RzLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgKiByZW1vdmUgdGhlIGRpc3BsYXkgb2JqZWN0IGZyb20gaXRzIHBhcmVudCBDb250YWluZXIgYXMgd2VsbCBhcyByZW1vdmVcbiAgICogYWxsIGN1cnJlbnQgZXZlbnQgbGlzdGVuZXJzIGFuZCBpbnRlcm5hbCByZWZlcmVuY2VzLiBEbyBub3QgdXNlIGEgRGlzcGxheU9iamVjdFxuICAgKiBhZnRlciBjYWxsaW5nIGBkZXN0cm95KClgLlxuICAgKiBAcGFyYW0gX29wdGlvbnNcbiAgICovXG4gIGRlc3Ryb3koX29wdGlvbnMpIHtcbiAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQoKSwgdGhpcy5fZGVzdHJveWVkID0gITAsIHRoaXMudHJhbnNmb3JtID0gbnVsbCwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLl9ib3VuZHMgPSBudWxsLCB0aGlzLm1hc2sgPSBudWxsLCB0aGlzLmN1bGxBcmVhID0gbnVsbCwgdGhpcy5maWx0ZXJzID0gbnVsbCwgdGhpcy5maWx0ZXJBcmVhID0gbnVsbCwgdGhpcy5oaXRBcmVhID0gbnVsbCwgdGhpcy5ldmVudE1vZGUgPSBcImF1dG9cIiwgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gITEsIHRoaXMuZW1pdChcImRlc3Ryb3llZFwiKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAbWVtYmVyIHtQSVhJLkNvbnRhaW5lcn1cbiAgICovXG4gIGdldCBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPT09IG51bGwgJiYgKHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCgpKSwgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbiBSZW5kZXJlciwgY2FjaGVBc0JpdG1hcCBhbmQgb3RoZXIgcGxhY2VzIHdoZXJlIHlvdSBjYWxsIGFuIGB1cGRhdGVUcmFuc2Zvcm1gIG9uIHJvb3QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhY2hlUGFyZW50ID0gZWxlbS5lbmFibGVUZW1wUGFyZW50KCk7XG4gICAqIGVsZW0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAqIGVsZW0uZGlzYWJsZVRlbXBQYXJlbnQoY2FjaGVQYXJlbnQpO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgLSBDdXJyZW50IHBhcmVudFxuICAgKi9cbiAgZW5hYmxlVGVtcFBhcmVudCgpIHtcbiAgICBjb25zdCBteVBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LCBteVBhcmVudDtcbiAgfVxuICAvKipcbiAgICogUGFpciBtZXRob2QgZm9yIGBlbmFibGVUZW1wUGFyZW50YFxuICAgKiBAcGFyYW0gY2FjaGVQYXJlbnQgLSBBY3R1YWwgcGFyZW50IG9mIGVsZW1lbnRcbiAgICovXG4gIGRpc2FibGVUZW1wUGFyZW50KGNhY2hlUGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgfVxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnhcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeSBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi55XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBsb2NhbCBmYWN0b3JzOiBwb3NpdGlvbiwgc2NhbGUsIG90aGVyIHN0dWZmLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgfVxuICBzZXQgcG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZSBmYWN0b3JzIG9mIHRoaXMgb2JqZWN0IGFsb25nIHRoZSBsb2NhbCBjb29yZGluYXRlIGF4ZXMuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHNjYWxlIGlzICgxLCAxKS5cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNlbnRlciBvZiByb3RhdGlvbiwgc2NhbGluZywgYW5kIHNrZXdpbmcgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QgaW4gaXRzIGxvY2FsIHNwYWNlLiBUaGUgYHBvc2l0aW9uYFxuICAgKiBpcyB0aGUgcHJvamVjdGlvbiBvZiBgcGl2b3RgIGluIHRoZSBwYXJlbnQncyBsb2NhbCBzcGFjZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHBpdm90IGlzIHRoZSBvcmlnaW4gKDAsIDApLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwaXZvdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl2b3Q7XG4gIH1cbiAgc2V0IHBpdm90KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucGl2b3QuY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2tldyBmYWN0b3IgZm9yIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuICBnZXQgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2tldztcbiAgfVxuICBzZXQgc2tldyh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnNrZXcuY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmdsZSBvZiB0aGUgb2JqZWN0IGluIGRlZ3JlZXMuXG4gICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gKiBSQURfVE9fREVHO1xuICB9XG4gIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWUgKiBERUdfVE9fUkFEO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgekluZGV4IG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgKlxuICAgKiBJZiBhIGNvbnRhaW5lciBoYXMgdGhlIHNvcnRhYmxlQ2hpbGRyZW4gcHJvcGVydHkgc2V0IHRvIHRydWUsIGNoaWxkcmVuIHdpbGwgYmUgYXV0b21hdGljYWxseVxuICAgKiBzb3J0ZWQgYnkgekluZGV4IHZhbHVlOyBhIGhpZ2hlciB2YWx1ZSB3aWxsIG1lYW4gaXQgd2lsbCBiZSBtb3ZlZCB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIGFycmF5LFxuICAgKiBhbmQgdGh1cyByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgZGlzcGxheSBvYmplY3RzIHdpdGhpbiB0aGUgc2FtZSBjb250YWluZXIuXG4gICAqIEBzZWUgUElYSS5Db250YWluZXIjc29ydGFibGVDaGlsZHJlblxuICAgKi9cbiAgZ2V0IHpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fekluZGV4O1xuICB9XG4gIHNldCB6SW5kZXgodmFsdWUpIHtcbiAgICB0aGlzLl96SW5kZXggIT09IHZhbHVlICYmICh0aGlzLl96SW5kZXggPSB2YWx1ZSwgdGhpcy5wYXJlbnQgJiYgKHRoaXMucGFyZW50LnNvcnREaXJ0eSA9ICEwKSk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgb2JqZWN0IGlzIGdsb2JhbGx5IHZpc2libGUuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkVmlzaWJsZSgpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKCFpdGVtLnZpc2libGUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudDtcbiAgICB9IHdoaWxlIChpdGVtKTtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBtYXNrIGZvciB0aGUgZGlzcGxheU9iamVjdC4gQSBtYXNrIGlzIGFuIG9iamVjdCB0aGF0IGxpbWl0cyB0aGUgdmlzaWJpbGl0eSBvZiBhblxuICAgKiBvYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXQuIEluIFBpeGlKUyBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICoge0BsaW5rIFBJWEkuR3JhcGhpY3N9IG9yIGEge0BsaW5rIFBJWEkuU3ByaXRlfSBvYmplY3QuIFRoaXMgYWxsb3dzIGZvciBtdWNoIGZhc3RlciBtYXNraW5nIGluIGNhbnZhcyBhcyBpdFxuICAgKiB1dGlsaXRpZXMgc2hhcGUgY2xpcHBpbmcuIEZ1cnRoZXJtb3JlLCBhIG1hc2sgb2YgYW4gb2JqZWN0IG11c3QgYmUgaW4gdGhlIHN1YnRyZWUgb2YgaXRzIHBhcmVudC5cbiAgICogT3RoZXJ3aXNlLCBgZ2V0TG9jYWxCb3VuZHNgIG1heSBjYWxjdWxhdGUgaW5jb3JyZWN0IGJvdW5kcywgd2hpY2ggbWFrZXMgdGhlIGNvbnRhaW5lcidzIHdpZHRoIGFuZCBoZWlnaHQgd3JvbmcuXG4gICAqIFRvIHJlbW92ZSBhIG1hc2ssIHNldCB0aGlzIHByb3BlcnR5IHRvIGBudWxsYC5cbiAgICpcbiAgICogRm9yIHNwcml0ZSBtYXNrIGJvdGggYWxwaGEgYW5kIHJlZCBjaGFubmVsIGFyZSB1c2VkLiBCbGFjayBtYXNrIGlzIHRoZSBzYW1lIGFzIHRyYW5zcGFyZW50IG1hc2suXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEdyYXBoaWNzLCBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3QgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoKTtcbiAgICogZ3JhcGhpY3MuYmVnaW5GaWxsKDB4RkYzMzAwKTtcbiAgICogZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDI1MCwgMTAwLCAxMDApO1xuICAgKiBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5tYXNrID0gZ3JhcGhpY3M7XG4gICAqIEB0b2RvIEF0IHRoZSBtb21lbnQsIENhbnZhc1JlbmRlcmVyIGRvZXNuJ3Qgc3VwcG9ydCBTcHJpdGUgYXMgbWFzay5cbiAgICovXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICB9XG4gIHNldCBtYXNrKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX21hc2sgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICBjb25zdCBtYXNrT2JqZWN0ID0gdGhpcy5fbWFzay5pc01hc2tEYXRhID8gdGhpcy5fbWFzay5tYXNrT2JqZWN0IDogdGhpcy5fbWFzaztcbiAgICAgICAgbWFza09iamVjdCAmJiAobWFza09iamVjdC5fbWFza1JlZkNvdW50LS0sIG1hc2tPYmplY3QuX21hc2tSZWZDb3VudCA9PT0gMCAmJiAobWFza09iamVjdC5yZW5kZXJhYmxlID0gITAsIG1hc2tPYmplY3QuaXNNYXNrID0gITEpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tYXNrID0gdmFsdWUsIHRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFza09iamVjdCA9IHRoaXMuX21hc2suaXNNYXNrRGF0YSA/IHRoaXMuX21hc2subWFza09iamVjdCA6IHRoaXMuX21hc2s7XG4gICAgICAgIG1hc2tPYmplY3QgJiYgKG1hc2tPYmplY3QuX21hc2tSZWZDb3VudCA9PT0gMCAmJiAobWFza09iamVjdC5yZW5kZXJhYmxlID0gITEsIG1hc2tPYmplY3QuaXNNYXNrID0gITApLCBtYXNrT2JqZWN0Ll9tYXNrUmVmQ291bnQrKyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0IGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc29ydERpcnR5ID0gbnVsbDtcbiAgfVxufVxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IERpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcbmV4cG9ydCB7XG4gIERpc3BsYXlPYmplY3QsXG4gIFRlbXBvcmFyeURpc3BsYXlPYmplY3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXNwbGF5T2JqZWN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCwgdXRpbHMsIE1BU0tfVFlQRVMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgRGlzcGxheU9iamVjdCB9IGZyb20gXCIuL0Rpc3BsYXlPYmplY3QubWpzXCI7XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuZnVuY3Rpb24gc29ydENoaWxkcmVuKGEsIGIpIHtcbiAgcmV0dXJuIGEuekluZGV4ID09PSBiLnpJbmRleCA/IGEuX2xhc3RTb3J0ZWRJbmRleCAtIGIuX2xhc3RTb3J0ZWRJbmRleCA6IGEuekluZGV4IC0gYi56SW5kZXg7XG59XG5jb25zdCBfQ29udGFpbmVyID0gY2xhc3MgX0NvbnRhaW5lcjIgZXh0ZW5kcyBEaXNwbGF5T2JqZWN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jaGlsZHJlbiA9IFtdLCB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gPSBfQ29udGFpbmVyMi5kZWZhdWx0U29ydGFibGVDaGlsZHJlbiwgdGhpcy5zb3J0RGlydHkgPSAhMTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgYnkgQ29udGFpbmVyIHN1YmNsYXNzZXMgd2hlbmV2ZXIgdGhlIGNoaWxkcmVuIGFycmF5IGlzIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0gX2xlbmd0aFxuICAgKi9cbiAgb25DaGlsZHJlbkNoYW5nZShfbGVuZ3RoKSB7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgY2hpbGRyZW4gdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxuICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGRyZW4gLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byBhZGQgdG8gdGhlIGNvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7UElYSS5EaXNwbGF5T2JqZWN0fSAtIFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIGFkZENoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBjaGlsZC5wYXJlbnQgJiYgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKSwgY2hpbGQucGFyZW50ID0gdGhpcywgdGhpcy5zb3J0RGlydHkgPSAhMCwgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xLCB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSwgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSwgY2hpbGQuZW1pdChcImFkZGVkXCIsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogSWYgdGhlIGNoaWxkIGlzIGFscmVhZHkgaW4gdGhpcyBjb250YWluZXIsIGl0IHdpbGwgYmUgbW92ZWQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGFkZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGFic29sdXRlIGluZGV4IHdoZXJlIHRoZSBjaGlsZCB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gICAqL1xuICBhZGRDaGlsZEF0KGNoaWxkLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH1hZGRDaGlsZEF0OiBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIHJldHVybiBjaGlsZC5wYXJlbnQgJiYgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKSwgY2hpbGQucGFyZW50ID0gdGhpcywgdGhpcy5zb3J0RGlydHkgPSAhMCwgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xLCB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpLCBjaGlsZC5lbWl0KFwiYWRkZWRcIiwgdGhpcyksIHRoaXMuZW1pdChcImNoaWxkQWRkZWRcIiwgY2hpbGQsIHRoaXMsIGluZGV4KSwgY2hpbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSBjaGlsZCAtIEZpcnN0IGRpc3BsYXkgb2JqZWN0IHRvIHN3YXBcbiAgICogQHBhcmFtIGNoaWxkMiAtIFNlY29uZCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAqL1xuICBzd2FwQ2hpbGRyZW4oY2hpbGQsIGNoaWxkMikge1xuICAgIGlmIChjaGlsZCA9PT0gY2hpbGQyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4MSA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCksIGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMiwgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQsIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleDEgPCBpbmRleDIgPyBpbmRleDEgOiBpbmRleDIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBwb3NpdGlvbiBvZiBhIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgdG8gaWRlbnRpZnlcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XG4gICAqL1xuICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlclwiKTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSByZXN1bHRpbmcgaW5kZXggbnVtYmVyIGZvciB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3RcbiAgICovXG4gIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGluZGV4ICR7aW5kZXh9IHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJHt0aGlzLmNoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGN1cnJlbnRJbmRleCwgMSksIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCksIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgYXRcbiAgICogQHJldHVybnMgLSBUaGUgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBhbnkuXG4gICAqL1xuICBnZXRDaGlsZEF0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Q2hpbGRBdDogSW5kZXggKCR7aW5kZXh9KSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgb25lIG9yIG1vcmUgY2hpbGRyZW4gZnJvbSB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGRyZW4gLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byByZW1vdmVcbiAgICogQHJldHVybnMge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVDaGlsZCguLi5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdLCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGwsIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMSwgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpLCBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKSwgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICAgKiBAcmV0dXJucyBUaGUgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUNoaWxkQXQoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpbmRleCk7XG4gICAgcmV0dXJuIGNoaWxkLnBhcmVudCA9IG51bGwsIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMSwgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpLCBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKSwgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCksIGNoaWxkO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICAgKiBAcGFyYW0gYmVnaW5JbmRleCAtIFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBlbmRJbmRleCAtIFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJucyAtIExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxuICAgKi9cbiAgcmVtb3ZlQ2hpbGRyZW4oYmVnaW5JbmRleCA9IDAsIGVuZEluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBiZWdpbiA9IGJlZ2luSW5kZXgsIGVuZCA9IGVuZEluZGV4LCByYW5nZSA9IGVuZCAtIGJlZ2luO1xuICAgIGxldCByZW1vdmVkO1xuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSBudWxsLCByZW1vdmVkW2ldLnRyYW5zZm9ybSAmJiAocmVtb3ZlZFtpXS50cmFuc2Zvcm0uX3BhcmVudElEID0gLTEpO1xuICAgICAgdGhpcy5fYm91bmRzSUQrKywgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGJlZ2luSW5kZXgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKVxuICAgICAgICByZW1vdmVkW2ldLmVtaXQoXCJyZW1vdmVkXCIsIHRoaXMpLCB0aGlzLmVtaXQoXCJjaGlsZFJlbW92ZWRcIiwgcmVtb3ZlZFtpXSwgdGhpcywgaSk7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicmVtb3ZlQ2hpbGRyZW46IG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlLlwiKTtcbiAgfVxuICAvKiogU29ydHMgY2hpbGRyZW4gYnkgekluZGV4LiBQcmV2aW91cyBvcmRlciBpcyBtYWludGFpbmVkIGZvciAyIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgekluZGV4LiAqL1xuICBzb3J0Q2hpbGRyZW4oKSB7XG4gICAgbGV0IHNvcnRSZXF1aXJlZCA9ICExO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLl9sYXN0U29ydGVkSW5kZXggPSBpLCAhc29ydFJlcXVpcmVkICYmIGNoaWxkLnpJbmRleCAhPT0gMCAmJiAoc29ydFJlcXVpcmVkID0gITApO1xuICAgIH1cbiAgICBzb3J0UmVxdWlyZWQgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxICYmIHRoaXMuY2hpbGRyZW4uc29ydChzb3J0Q2hpbGRyZW4pLCB0aGlzLnNvcnREaXJ0eSA9ICExO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gb24gYWxsIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyIGZvciByZW5kZXJpbmcuICovXG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gJiYgdGhpcy5zb3J0RGlydHkgJiYgdGhpcy5zb3J0Q2hpbGRyZW4oKSwgdGhpcy5fYm91bmRzSUQrKywgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSksIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLnZpc2libGUgJiYgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIHdpbGwgYXV0b21hdGljYWxseSBmaXQgdGhlIGNoaWxkcmVuJ3MgYm91bmRzIGludG8gdGhlIGNhbGN1bGF0aW9uLiBFYWNoIGNoaWxkJ3MgYm91bmRzXG4gICAqIGlzIGxpbWl0ZWQgdG8gaXRzIG1hc2sncyBib3VuZHMgb3IgZmlsdGVyQXJlYSwgaWYgYW55IGlzIGFwcGxpZWQuXG4gICAqL1xuICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5fYm91bmRzLmNsZWFyKCksIHRoaXMuX2NhbGN1bGF0ZUJvdW5kcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKCEoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpKVxuICAgICAgICBpZiAoY2hpbGQuY2FsY3VsYXRlQm91bmRzKCksIGNoaWxkLl9tYXNrKSB7XG4gICAgICAgICAgY29uc3QgbWFza09iamVjdCA9IGNoaWxkLl9tYXNrLmlzTWFza0RhdGEgPyBjaGlsZC5fbWFzay5tYXNrT2JqZWN0IDogY2hpbGQuX21hc2s7XG4gICAgICAgICAgbWFza09iamVjdCA/IChtYXNrT2JqZWN0LmNhbGN1bGF0ZUJvdW5kcygpLCB0aGlzLl9ib3VuZHMuYWRkQm91bmRzTWFzayhjaGlsZC5fYm91bmRzLCBtYXNrT2JqZWN0Ll9ib3VuZHMpKSA6IHRoaXMuX2JvdW5kcy5hZGRCb3VuZHMoY2hpbGQuX2JvdW5kcyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNoaWxkLmZpbHRlckFyZWEgPyB0aGlzLl9ib3VuZHMuYWRkQm91bmRzQXJlYShjaGlsZC5fYm91bmRzLCBjaGlsZC5maWx0ZXJBcmVhKSA6IHRoaXMuX2JvdW5kcy5hZGRCb3VuZHMoY2hpbGQuX2JvdW5kcyk7XG4gICAgfVxuICAgIHRoaXMuX2JvdW5kcy51cGRhdGVJRCA9IHRoaXMuX2JvdW5kc0lEO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3QuXG4gICAqXG4gICAqIENhbGxpbmcgYGdldExvY2FsQm91bmRzYCBtYXkgaW52YWxpZGF0ZSB0aGUgYF9ib3VuZHNgIG9mIHRoZSB3aG9sZSBzdWJ0cmVlIGJlbG93LiBJZiB1c2luZyBpdCBpbnNpZGUgYSByZW5kZXIoKVxuICAgKiBjYWxsLCBpdCBpcyBhZHZpc2VkIHRvIGNhbGwgYGdldEJvdW5kcygpYCBpbW1lZGlhdGVseSBhZnRlciB0byByZWNhbGN1bGF0ZSB0aGUgd29ybGQgYm91bmRzIG9mIHRoZSBzdWJ0cmVlLlxuICAgKiBAcGFyYW0gcmVjdCAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAqIEBwYXJhbSBza2lwQ2hpbGRyZW5VcGRhdGUgLSBTZXR0aW5nIHRvIGB0cnVlYCB3aWxsIHN0b3AgcmUtY2FsY3VsYXRpb24gb2YgY2hpbGRyZW4gdHJhbnNmb3JtcyxcbiAgICogIGl0IHdhcyBkZWZhdWx0IGJlaGF2aW91ciBvZiBwaXhpIDQuMC01LjIgYW5kIGNhdXNlZCBtYW55IHByb2JsZW1zIHRvIHVzZXJzLlxuICAgKiBAcmV0dXJucyAtIFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhLlxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCwgc2tpcENoaWxkcmVuVXBkYXRlID0gITEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgICBpZiAoIXNraXBDaGlsZHJlblVwZGF0ZSlcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC52aXNpYmxlICYmIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2FsY3VsYXRlcyB0aGUgY29udGVudCBib3VuZHMgb2YgdGhpcyBvYmplY3QuIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRlbiB0b1xuICAgKiBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGlzIHNwZWNpZmljIG9iamVjdCAobm90IGluY2x1ZGluZyBjaGlsZHJlbikuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiB3aXRoIGN1bGxpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKi9cbiAgX3JlbmRlcldpdGhDdWxsaW5nKHJlbmRlcmVyKSB7XG4gICAgY29uc3Qgc291cmNlRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lO1xuICAgIGlmICghKHNvdXJjZUZyYW1lLndpZHRoID4gMCAmJiBzb3VyY2VGcmFtZS5oZWlnaHQgPiAwKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYm91bmRzLCB0cmFuc2Zvcm07XG4gICAgdGhpcy5jdWxsQXJlYSA/IChib3VuZHMgPSB0aGlzLmN1bGxBcmVhLCB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtKSA6IHRoaXMuX3JlbmRlciAhPT0gX0NvbnRhaW5lcjIucHJvdG90eXBlLl9yZW5kZXIgJiYgKGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCEwKSk7XG4gICAgY29uc3QgcHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICAgIGlmIChwcm9qZWN0aW9uVHJhbnNmb3JtICYmICh0cmFuc2Zvcm0gPyAodHJhbnNmb3JtID0gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pLCB0cmFuc2Zvcm0ucHJlcGVuZChwcm9qZWN0aW9uVHJhbnNmb3JtKSkgOiB0cmFuc2Zvcm0gPSBwcm9qZWN0aW9uVHJhbnNmb3JtKSwgYm91bmRzICYmIHNvdXJjZUZyYW1lLmludGVyc2VjdHMoYm91bmRzLCB0cmFuc2Zvcm0pKVxuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICBlbHNlIGlmICh0aGlzLmN1bGxBcmVhKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgY2hpbGRDdWxsYWJsZSA9IGNoaWxkLmN1bGxhYmxlO1xuICAgICAgY2hpbGQuY3VsbGFibGUgPSBjaGlsZEN1bGxhYmxlIHx8ICF0aGlzLmN1bGxBcmVhLCBjaGlsZC5yZW5kZXIocmVuZGVyZXIpLCBjaGlsZC5jdWxsYWJsZSA9IGNoaWxkQ3VsbGFibGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgKlxuICAgKiBUaGUgW19yZW5kZXJde0BsaW5rIFBJWEkuQ29udGFpbmVyI19yZW5kZXJ9IG1ldGhvZCBpcyBiZSBvdmVycmlkZW4gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudHMgb2YgdGhlXG4gICAqIGNvbnRhaW5lciBpdHNlbGYuIFRoaXMgYHJlbmRlcmAgbWV0aG9kIHdpbGwgaW52b2tlIGl0LCBhbmQgYWxzbyBpbnZva2UgdGhlIGByZW5kZXJgIG1ldGhvZHMgb2YgYWxsXG4gICAqIGNoaWxkcmVuIGFmdGVyd2FyZC5cbiAgICpcbiAgICogSWYgYHJlbmRlcmFibGVgIG9yIGB2aXNpYmxlYCBpcyBmYWxzZSBvciBpZiBgd29ybGRBbHBoYWAgaXMgbm90IHBvc2l0aXZlIG9yIGlmIGBjdWxsYWJsZWAgaXMgdHJ1ZSBhbmRcbiAgICogdGhlIGJvdW5kcyBvZiB0aGlzIG9iamVjdCBhcmUgb3V0IG9mIGZyYW1lLCB0aGlzIGltcGxlbWVudGF0aW9uIHdpbGwgZW50aXJlbHkgc2tpcCByZW5kZXJpbmcuXG4gICAqIFNlZSB7QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0fSBmb3IgY2hvb3NpbmcgYmV0d2VlbiBgcmVuZGVyYWJsZWAgb3IgYHZpc2libGVgLiBHZW5lcmFsbHksXG4gICAqIHNldHRpbmcgYWxwaGEgdG8gemVybyBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHB1cmVseSBza2lwcGluZyByZW5kZXJpbmcuXG4gICAqXG4gICAqIFdoZW4geW91ciBzY2VuZSBiZWNvbWVzIGxhcmdlIChlc3BlY2lhbGx5IHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gY2FuIGJlIHZpZXdlZCBpbiBhIHNpbmdsZSBzY3JlZW4pLCBpdCBpc1xuICAgKiBhZHZpc2VkIHRvIGVtcGxveSAqKmN1bGxpbmcqKiB0byBhdXRvbWF0aWNhbGx5IHNraXAgcmVuZGVyaW5nIG9iamVjdHMgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBzY3JlZW4uXG4gICAqIFNlZSBbY3VsbGFibGVde0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdCNjdWxsYWJsZX0gYW5kIFtjdWxsQXJlYV17QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0I2N1bGxBcmVhfS5cbiAgICogT3RoZXIgY3VsbGluZyBtZXRob2RzIG1pZ2h0IGJlIGJldHRlciBzdWl0ZWQgZm9yIGEgbGFyZ2UgbnVtYmVyIHN0YXRpYyBvYmplY3RzOyBzZWVcbiAgICogW0BwaXhpLWVzc2VudGlhbHMvY3VsbF17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHBpeGktZXNzZW50aWFscy9jdWxsfSBhbmRcbiAgICogW3BpeGktY3VsbF17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGl4aS1jdWxsfS5cbiAgICpcbiAgICogVGhlIFtyZW5kZXJBZHZhbmNlZF17QGxpbmsgUElYSS5Db250YWluZXIjcmVuZGVyQWR2YW5jZWR9IG1ldGhvZCBpcyBpbnRlcm5hbGx5IHVzZWQgd2hlbiB3aGVuIG1hc2tpbmcgb3JcbiAgICogZmlsdGVyaW5nIGlzIGFwcGxpZWQgb24gYSBjb250YWluZXIuIFRoaXMgZG9lcywgaG93ZXZlciwgYnJlYWsgYmF0Y2hpbmcgYW5kIGNhbiBhZmZlY3QgcGVyZm9ybWFuY2Ugd2hlblxuICAgKiBtYXNraW5nIGFuZCBmaWx0ZXJpbmcgaXMgYXBwbGllZCBleHRlbnNpdmVseSB0aHJvdWdob3V0IHRoZSBzY2VuZSBncmFwaC5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAoISghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpKVxuICAgICAgaWYgKHRoaXMuX21hc2sgfHwgdGhpcy5maWx0ZXJzPy5sZW5ndGgpXG4gICAgICAgIHRoaXMucmVuZGVyQWR2YW5jZWQocmVuZGVyZXIpO1xuICAgICAgZWxzZSBpZiAodGhpcy5jdWxsYWJsZSlcbiAgICAgICAgdGhpcy5fcmVuZGVyV2l0aEN1bGxpbmcocmVuZGVyZXIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgYW5kIGFkdmFuY2VkIGZlYXR1cmVzLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlckFkdmFuY2VkKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZmlsdGVycyA9IHRoaXMuZmlsdGVycywgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzIHx8ICh0aGlzLl9lbmFibGVkRmlsdGVycyA9IFtdKSwgdGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgZmlsdGVyc1tpXS5lbmFibGVkICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLnB1c2goZmlsdGVyc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IGZsdXNoID0gZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoIHx8IG1hc2sgJiYgKCFtYXNrLmlzTWFza0RhdGEgfHwgbWFzay5lbmFibGVkICYmIChtYXNrLmF1dG9EZXRlY3QgfHwgbWFzay50eXBlICE9PSBNQVNLX1RZUEVTLk5PTkUpKTtcbiAgICBpZiAoZmx1c2ggJiYgcmVuZGVyZXIuYmF0Y2guZmx1c2goKSwgZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoICYmIHJlbmRlcmVyLmZpbHRlci5wdXNoKHRoaXMsIHRoaXMuX2VuYWJsZWRGaWx0ZXJzKSwgbWFzayAmJiByZW5kZXJlci5tYXNrLnB1c2godGhpcywgdGhpcy5fbWFzayksIHRoaXMuY3VsbGFibGUpXG4gICAgICB0aGlzLl9yZW5kZXJXaXRoQ3VsbGluZyhyZW5kZXJlcik7XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICBmbHVzaCAmJiByZW5kZXJlci5iYXRjaC5mbHVzaCgpLCBtYXNrICYmIHJlbmRlcmVyLm1hc2sucG9wKHRoaXMpLCBmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzPy5sZW5ndGggJiYgcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICB9XG4gIC8qKlxuICAgKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc2VzLlxuICAgKiBAcGFyYW0gX3JlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyKF9yZW5kZXJlcikge1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIGFuZCBsaXN0ZW5lcnMgYXMgd2VsbCBhcyByZW1vdmVzIGNoaWxkcmVuIGZyb20gdGhlIGRpc3BsYXkgbGlzdC5cbiAgICogRG8gbm90IHVzZSBhIENvbnRhaW5lciBhZnRlciBjYWxsaW5nIGBkZXN0cm95YC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxuICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3koKSwgdGhpcy5zb3J0RGlydHkgPSAhMTtcbiAgICBjb25zdCBkZXN0cm95Q2hpbGRyZW4gPSB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy5jaGlsZHJlbiwgb2xkQ2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBpZiAoZGVzdHJveUNoaWxkcmVuKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbi5sZW5ndGg7ICsraSlcbiAgICAgICAgb2xkQ2hpbGRyZW5baV0uZGVzdHJveShvcHRpb25zKTtcbiAgfVxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LiAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgICB3aWR0aCAhPT0gMCA/IHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGggOiB0aGlzLnNjYWxlLnggPSAxLCB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LiAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnkgKiB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuICAgIGhlaWdodCAhPT0gMCA/IHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gaGVpZ2h0IDogdGhpcy5zY2FsZS55ID0gMSwgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbn07XG5fQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuID0gITE7XG5sZXQgQ29udGFpbmVyID0gX0NvbnRhaW5lcjtcbkNvbnRhaW5lci5wcm90b3R5cGUuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtID0gQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XG5leHBvcnQge1xuICBDb250YWluZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIHV0aWxzIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IHNldHRpbmdzIGFzIHNldHRpbmdzMiB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi9Db250YWluZXIubWpzXCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXR0aW5ncywge1xuICAvKipcbiAgICogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbnRhaW5lciBwcm9wZXJ0eSAnc29ydGFibGVDaGlsZHJlbicuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgU09SVEFCTEVfQ0hJTERSRU5cbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBzZWUgUElYSS5Db250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW5cbiAgICovXG4gIFNPUlRBQkxFX0NISUxEUkVOOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIENvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbjtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOIGlzIGRlcHJlY2F0ZWQsIHVzZSBDb250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW5cIiksIENvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbiA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5leHBvcnQge1xuICBzZXR0aW5nczIgYXMgc2V0dGluZ3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJpbXBvcnQgXCIuL3NldHRpbmdzLm1qc1wiO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSBcIi4vQm91bmRzLm1qc1wiO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4vQ29udGFpbmVyLm1qc1wiO1xuaW1wb3J0IHsgRGlzcGxheU9iamVjdCwgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCB9IGZyb20gXCIuL0Rpc3BsYXlPYmplY3QubWpzXCI7XG5leHBvcnQge1xuICBCb3VuZHMsXG4gIENvbnRhaW5lcixcbiAgRGlzcGxheU9iamVjdCxcbiAgVGVtcG9yYXJ5RGlzcGxheU9iamVjdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBPYnNlcnZhYmxlUG9pbnQsIENvbG9yLCBCTEVORF9NT0RFUywgVGV4dHVyZSwgc2V0dGluZ3MsIHV0aWxzLCBSZWN0YW5nbGUgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQ29udGFpbmVyLCBCb3VuZHMgfSBmcm9tIFwiQHBpeGkvZGlzcGxheVwiO1xuY29uc3QgdGVtcFBvaW50ID0gbmV3IFBvaW50KCksIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbmNsYXNzIFNwcml0ZSBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKiBAcGFyYW0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIGZvciB0aGlzIHNwcml0ZS4gKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2FuY2hvciA9IG5ldyBPYnNlcnZhYmxlUG9pbnQoXG4gICAgICB0aGlzLl9vbkFuY2hvclVwZGF0ZSxcbiAgICAgIHRoaXMsXG4gICAgICB0ZXh0dXJlID8gdGV4dHVyZS5kZWZhdWx0QW5jaG9yLnggOiAwLFxuICAgICAgdGV4dHVyZSA/IHRleHR1cmUuZGVmYXVsdEFuY2hvci55IDogMFxuICAgICksIHRoaXMuX3RleHR1cmUgPSBudWxsLCB0aGlzLl93aWR0aCA9IDAsIHRoaXMuX2hlaWdodCA9IDAsIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBDb2xvcigxNjc3NzIxNSksIHRoaXMuX3RpbnRSR0IgPSBudWxsLCB0aGlzLnRpbnQgPSAxNjc3NzIxNSwgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUwsIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNSwgdGhpcy51dnMgPSBudWxsLCB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IFRleHR1cmUuRU1QVFksIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCksIHRoaXMudmVydGV4VHJpbW1lZERhdGEgPSBudWxsLCB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xLCB0aGlzLl90ZXh0dXJlSUQgPSAtMSwgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTEsIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMSwgdGhpcy5pbmRpY2VzID0gaW5kaWNlcywgdGhpcy5wbHVnaW5OYW1lID0gXCJiYXRjaFwiLCB0aGlzLmlzU3ByaXRlID0gITAsIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICB9XG4gIC8qKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lLiAqL1xuICBfb25UZXh0dXJlVXBkYXRlKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xLCB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTEsIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNSwgdGhpcy5fd2lkdGggJiYgKHRoaXMuc2NhbGUueCA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS54KSAqIHRoaXMuX3dpZHRoIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoKSwgdGhpcy5faGVpZ2h0ICYmICh0aGlzLnNjYWxlLnkgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueSkgKiB0aGlzLl9oZWlnaHQgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0KTtcbiAgfVxuICAvKiogQ2FsbGVkIHdoZW4gdGhlIGFuY2hvciBwb3NpdGlvbiB1cGRhdGVzLiAqL1xuICBfb25BbmNob3JVcGRhdGUoKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMSwgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gIH1cbiAgLyoqIENhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcywgc3RvcmUgaXQgaW4gdmVydGV4RGF0YS4gKi9cbiAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlSUQgPT09IHRleHR1cmUuX3VwZGF0ZUlEKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3RleHR1cmVJRCAhPT0gdGV4dHVyZS5fdXBkYXRlSUQgJiYgKHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzIpLCB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElELCB0aGlzLl90ZXh0dXJlSUQgPSB0ZXh0dXJlLl91cGRhdGVJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBhID0gd3QuYSwgYiA9IHd0LmIsIGMgPSB3dC5jLCBkID0gd3QuZCwgdHggPSB3dC50eCwgdHkgPSB3dC50eSwgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YSwgdHJpbSA9IHRleHR1cmUudHJpbSwgb3JpZyA9IHRleHR1cmUub3JpZywgYW5jaG9yID0gdGhpcy5fYW5jaG9yO1xuICAgIGxldCB3MCA9IDAsIHcxID0gMCwgaDAgPSAwLCBoMSA9IDA7XG4gICAgaWYgKHRyaW0gPyAodzEgPSB0cmltLnggLSBhbmNob3IuX3ggKiBvcmlnLndpZHRoLCB3MCA9IHcxICsgdHJpbS53aWR0aCwgaDEgPSB0cmltLnkgLSBhbmNob3IuX3kgKiBvcmlnLmhlaWdodCwgaDAgPSBoMSArIHRyaW0uaGVpZ2h0KSA6ICh3MSA9IC1hbmNob3IuX3ggKiBvcmlnLndpZHRoLCB3MCA9IHcxICsgb3JpZy53aWR0aCwgaDEgPSAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHQsIGgwID0gaDEgKyBvcmlnLmhlaWdodCksIHZlcnRleERhdGFbMF0gPSBhICogdzEgKyBjICogaDEgKyB0eCwgdmVydGV4RGF0YVsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5LCB2ZXJ0ZXhEYXRhWzJdID0gYSAqIHcwICsgYyAqIGgxICsgdHgsIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eSwgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4LCB2ZXJ0ZXhEYXRhWzVdID0gZCAqIGgwICsgYiAqIHcwICsgdHksIHZlcnRleERhdGFbNl0gPSBhICogdzEgKyBjICogaDAgKyB0eCwgdmVydGV4RGF0YVs3XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5LCB0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHZlcnRleERhdGFbaV0gPSBNYXRoLnJvdW5kKHZlcnRleERhdGFbaV0gKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHdvcmxkVHJhbnNmb3JtICogdmVydGljZXMgZm9yIGEgbm9uIHRleHR1cmUgd2l0aCBhIHRyaW0uIHN0b3JlIGl0IGluIHZlcnRleFRyaW1tZWREYXRhLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHRydWUgd2lkdGggYW5kIGhlaWdodCBvZiBhIHRyaW1tZWQgdGV4dHVyZSBpcyByZXNwZWN0ZWQuXG4gICAqL1xuICBjYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSB7XG4gICAgaWYgKCF0aGlzLnZlcnRleFRyaW1tZWREYXRhKVxuICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgZWxzZSBpZiAodGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID09PSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlLCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSwgb3JpZyA9IHRleHR1cmUub3JpZywgYW5jaG9yID0gdGhpcy5fYW5jaG9yLCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBhID0gd3QuYSwgYiA9IHd0LmIsIGMgPSB3dC5jLCBkID0gd3QuZCwgdHggPSB3dC50eCwgdHkgPSB3dC50eSwgdzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aCwgdzAgPSB3MSArIG9yaWcud2lkdGgsIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0LCBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XG4gICAgaWYgKHZlcnRleERhdGFbMF0gPSBhICogdzEgKyBjICogaDEgKyB0eCwgdmVydGV4RGF0YVsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5LCB2ZXJ0ZXhEYXRhWzJdID0gYSAqIHcwICsgYyAqIGgxICsgdHgsIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eSwgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4LCB2ZXJ0ZXhEYXRhWzVdID0gZCAqIGgwICsgYiAqIHcwICsgdHksIHZlcnRleERhdGFbNl0gPSBhICogdzEgKyBjICogaDAgKyB0eCwgdmVydGV4RGF0YVs3XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5LCB0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHZlcnRleERhdGFbaV0gPSBNYXRoLnJvdW5kKHZlcnRleERhdGFbaV0gKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSB3ZWJnbCByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpLCByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pLCByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZS4gKi9cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCB0cmltID0gdGhpcy5fdGV4dHVyZS50cmltLCBvcmlnID0gdGhpcy5fdGV4dHVyZS5vcmlnO1xuICAgICF0cmltIHx8IHRyaW0ud2lkdGggPT09IG9yaWcud2lkdGggJiYgdHJpbS5oZWlnaHQgPT09IG9yaWcuaGVpZ2h0ID8gKHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKSwgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKSkgOiAodGhpcy5jYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSwgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAqIEBwYXJhbSByZWN0IC0gT3B0aW9uYWwgb3V0cHV0IHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGJvdW5kcy5cbiAgICovXG4gIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyAodGhpcy5fbG9jYWxCb3VuZHMgfHwgKHRoaXMuX2xvY2FsQm91bmRzID0gbmV3IEJvdW5kcygpKSwgdGhpcy5fbG9jYWxCb3VuZHMubWluWCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCAqIC10aGlzLl9hbmNob3IuX3gsIHRoaXMuX2xvY2FsQm91bmRzLm1pblkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feSwgdGhpcy5fbG9jYWxCb3VuZHMubWF4WCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KSwgdGhpcy5fbG9jYWxCb3VuZHMubWF4WSA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSksIHJlY3QgfHwgKHRoaXMuX2xvY2FsQm91bmRzUmVjdCB8fCAodGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZSgpKSwgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdCksIHRoaXMuX2xvY2FsQm91bmRzLmdldFJlY3RhbmdsZShyZWN0KSkgOiBzdXBlci5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHNwcml0ZVxuICAgKiBAcGFyYW0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIHRlbXBQb2ludCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgsIGhlaWdodCA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQsIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICBsZXQgeTEgPSAwO1xuICAgIHJldHVybiB0ZW1wUG9pbnQueCA+PSB4MSAmJiB0ZW1wUG9pbnQueCA8IHgxICsgd2lkdGggJiYgKHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLnksIHRlbXBQb2ludC55ID49IHkxICYmIHRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZSBhbmQgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgKiBAcGFyYW0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGlmIChzdXBlci5kZXN0cm95KG9wdGlvbnMpLCB0aGlzLl90ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpLCB0aGlzLl9hbmNob3IgPSBudWxsLCB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95QmFzZVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy5iYXNlVGV4dHVyZTtcbiAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSghIWRlc3Ryb3lCYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICB9XG4gIC8vIHNvbWUgaGVscGVyIGZ1bmN0aW9ucy4uXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLlRleHR1cmV8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc30gc291cmNlXG4gICAqICAgICAtIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHNwcml0ZVxuICAgKi9cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNvdXJjZSBpbnN0YW5jZW9mIFRleHR1cmUgPyBzb3VyY2UgOiBUZXh0dXJlLmZyb20oc291cmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgfVxuICAvKipcbiAgICogSWYgdHJ1ZSBQaXhpSlMgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxuICAgKiBUaGUgbWFpbiBkaXNhZHZhbnRhZ2UgaXMgbW92ZW1lbnQgb2Ygb2JqZWN0cyBtYXkgYXBwZWFyIGxlc3Mgc21vb3RoLlxuICAgKlxuICAgKiBUbyBzZXQgdGhlIGdsb2JhbCBkZWZhdWx0LCBjaGFuZ2Uge0BsaW5rIFBJWEkuc2V0dGluZ3MuUk9VTkRfUElYRUxTfS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSAmJiAodGhpcy5fdHJhbnNmb3JtSUQgPSAtMSwgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTEpLCB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICB9XG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgsIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCwgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSBzcHJpdGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRha2VuIGZyb20gdGhlIHtAbGluayBQSVhJLlRleHR1cmV8VGV4dHVyZX1cbiAgICogYW5kIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGlzIGAoMCwwKWAsIHRoaXMgbWVhbnMgdGhlIHNwcml0ZSdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnQuXG4gICAqXG4gICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byBgKDAuNSwwLjUpYCBtZWFucyB0aGUgc3ByaXRlJ3Mgb3JpZ2luIGlzIGNlbnRlcmVkLlxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgxLDEpYCB3b3VsZCBtZWFuIHRoZSBzcHJpdGUncyBvcmlnaW4gcG9pbnQgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cbiAgICpcbiAgICogSWYgeW91IHBhc3Mgb25seSBzaW5nbGUgcGFyYW1ldGVyLCBpdCB3aWxsIHNldCBib3RoIHggYW5kIHkgdG8gdGhlIHNhbWUgdmFsdWUgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUgYmVsb3cuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlKFRleHR1cmUuV0hJVEUpO1xuICAgKiBzcHJpdGUuYW5jaG9yLnNldCgwLjUpOyAvLyBUaGlzIHdpbGwgc2V0IHRoZSBvcmlnaW4gdG8gY2VudGVyLiAoMC41KSBpcyBzYW1lIGFzICgwLjUsIDAuNSkuXG4gICAqL1xuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cbiAgICpcbiAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKSwgdGhpcy5fdGludFJHQiA9IHRoaXMuX3RpbnRDb2xvci50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbnQgYXMgYSBSR0IgaW50ZWdlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZ2V0IHRpbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnRvTnVtYmVyKCk7XG4gIH1cbiAgLyoqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZy4gKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLl90ZXh0dXJlICE9PSB2YWx1ZSAmJiAodGhpcy5fdGV4dHVyZSAmJiB0aGlzLl90ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpLCB0aGlzLl90ZXh0dXJlID0gdmFsdWUgfHwgVGV4dHVyZS5FTVBUWSwgdGhpcy5fY2FjaGVkVGludCA9IDE2Nzc3MjE1LCB0aGlzLl90ZXh0dXJlSUQgPSAtMSwgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xLCB2YWx1ZSAmJiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQgPyB0aGlzLl9vblRleHR1cmVVcGRhdGUoKSA6IHZhbHVlLm9uY2UoXCJ1cGRhdGVcIiwgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKSkpO1xuICB9XG59XG5leHBvcnQge1xuICBTcHJpdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSBcIi4vU3ByaXRlLm1qc1wiO1xuZXhwb3J0IHtcbiAgU3ByaXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4LCBSZWN0YW5nbGUsIFJlbmRlclRleHR1cmUsIHV0aWxzLCBCYXNlVGV4dHVyZSwgVGV4dHVyZSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gXCJAcGl4aS9zcHJpdGVcIjtcbmNvbnN0IF90ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhY2hlQXNCaXRtYXAgPSAhMTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZURhdGEgPSBudWxsO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uID0gbnVsbDtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGUgPSBudWxsO1xuY2xhc3MgQ2FjaGVEYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZCA9IG51bGwsIHRoaXMub3JpZ2luYWxSZW5kZXIgPSBudWxsLCB0aGlzLm9yaWdpbmFsUmVuZGVyQ2FudmFzID0gbnVsbCwgdGhpcy5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IG51bGwsIHRoaXMub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IG51bGwsIHRoaXMub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsLCB0aGlzLm9yaWdpbmFsRGVzdHJveSA9IG51bGwsIHRoaXMub3JpZ2luYWxNYXNrID0gbnVsbCwgdGhpcy5vcmlnaW5hbEZpbHRlckFyZWEgPSBudWxsLCB0aGlzLm9yaWdpbmFsQ29udGFpbnNQb2ludCA9IG51bGwsIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIHRvIHVzZSBmb3IgY2FjaGVBc0JpdG1hcC4gQnkgZGVmYXVsdCB0aGlzIHdpbGwgdXNlIHRoZSByZW5kZXJlcidzIHJlc29sdXRpb25cbiAgICogYnV0IGNhbiBiZSBvdmVycmlkZW4gZm9yIHBlcmZvcm1hbmNlLiBMb3dlciB2YWx1ZXMgd2lsbCByZWR1Y2UgbWVtb3J5IHVzYWdlIGF0IHRoZSBleHBlbnNlXG4gICAqIG9mIHJlbmRlciBxdWFsaXR5LiBBIGZhbHNleSB2YWx1ZSBvZiBgbnVsbGAgb3IgYDBgIHdpbGwgZGVmYXVsdCB0byB0aGUgcmVuZGVyZXIncyByZXNvbHV0aW9uLlxuICAgKiBJZiBgY2FjaGVBc0JpdG1hcGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhpcyB3aWxsIHJlLXJlbmRlciB3aXRoIHRoZSBuZXcgcmVzb2x1dGlvbi5cbiAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IGNhY2hlQXNCaXRtYXBSZXNvbHV0aW9uXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGNhY2hlQXNCaXRtYXBSZXNvbHV0aW9uOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uO1xuICAgIH0sXG4gICAgc2V0KHJlc29sdXRpb24pIHtcbiAgICAgIHJlc29sdXRpb24gIT09IHRoaXMuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uICYmICh0aGlzLl9jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiA9IHJlc29sdXRpb24sIHRoaXMuY2FjaGVBc0JpdG1hcCAmJiAodGhpcy5jYWNoZUFzQml0bWFwID0gITEsIHRoaXMuY2FjaGVBc0JpdG1hcCA9ICEwKSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHRvIHVzZSBmb3IgY2FjaGVBc0JpdG1hcC4gSWYgc2V0IHRvIGBudWxsYCwgdGhlIHJlbmRlcmVyJ3NcbiAgICogc2FtcGxlIGNvdW50IGlzIHVzZWQuXG4gICAqIElmIGBjYWNoZUFzQml0bWFwYCBpcyBzZXQgdG8gYHRydWVgLCB0aGlzIHdpbGwgcmUtcmVuZGVyIHdpdGggdGhlIG5ldyBudW1iZXIgb2Ygc2FtcGxlcy5cbiAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IGNhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBjYWNoZUFzQml0bWFwTXVsdGlzYW1wbGU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlO1xuICAgIH0sXG4gICAgc2V0KG11bHRpc2FtcGxlKSB7XG4gICAgICBtdWx0aXNhbXBsZSAhPT0gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlICYmICh0aGlzLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGUgPSBtdWx0aXNhbXBsZSwgdGhpcy5jYWNoZUFzQml0bWFwICYmICh0aGlzLmNhY2hlQXNCaXRtYXAgPSAhMSwgdGhpcy5jYWNoZUFzQml0bWFwID0gITApKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHRoaXMgZGlzcGxheSBvYmplY3QgdG8gYmUgY2FjaGVkIGFzIGEgYml0bWFwLlxuICAgKiBUaGlzIGJhc2ljYWxseSB0YWtlcyBhIHNuYXBzaG90IG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBpdCBpcyBhdCB0aGF0IG1vbWVudC4gSXQgY2FuXG4gICAqIHByb3ZpZGUgYSBwZXJmb3JtYW5jZSBiZW5lZml0IGZvciBjb21wbGV4IHN0YXRpYyBkaXNwbGF5T2JqZWN0cy5cbiAgICogVG8gcmVtb3ZlIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgXG4gICAqXG4gICAqIElNUE9SVEFOVCBHT1RDSEEgLSBNYWtlIHN1cmUgdGhhdCBhbGwgeW91ciB0ZXh0dXJlcyBhcmUgcHJlbG9hZGVkIEJFRk9SRSBzZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gdHJ1ZVxuICAgKiBhcyBpdCB3aWxsIHRha2UgYSBzbmFwc2hvdCBvZiB3aGF0IGlzIGN1cnJlbnRseSB0aGVyZS4gSWYgdGhlIHRleHR1cmVzIGhhdmUgbm90IGxvYWRlZCB0aGVuIHRoZXkgd2lsbCBub3QgYXBwZWFyLlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgY2FjaGVBc0JpdG1hcDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcCA9PT0gdmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdmFsdWUgPyAodGhpcy5fY2FjaGVEYXRhIHx8ICh0aGlzLl9jYWNoZURhdGEgPSBuZXcgQ2FjaGVEYXRhKCkpLCBkYXRhID0gdGhpcy5fY2FjaGVEYXRhLCBkYXRhLm9yaWdpbmFsUmVuZGVyID0gdGhpcy5yZW5kZXIsIGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcywgZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtLCBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHMsIGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMsIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95LCBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludCA9IHRoaXMuY29udGFpbnNQb2ludCwgZGF0YS5vcmlnaW5hbE1hc2sgPSB0aGlzLl9tYXNrLCBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYSA9IHRoaXMuZmlsdGVyQXJlYSwgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQsIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzLCB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveSkgOiAoZGF0YSA9IHRoaXMuX2NhY2hlRGF0YSwgZGF0YS5zcHJpdGUgJiYgdGhpcy5fZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKSwgdGhpcy5yZW5kZXIgPSBkYXRhLm9yaWdpbmFsUmVuZGVyLCB0aGlzLnJlbmRlckNhbnZhcyA9IGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMsIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcywgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcywgdGhpcy5kZXN0cm95ID0gZGF0YS5vcmlnaW5hbERlc3Ryb3ksIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSwgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQsIHRoaXMuX21hc2sgPSBkYXRhLm9yaWdpbmFsTWFzaywgdGhpcy5maWx0ZXJBcmVhID0gZGF0YS5vcmlnaW5hbEZpbHRlckFyZWEpO1xuICAgIH1cbiAgfVxufSk7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlIHx8ICh0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdChyZW5kZXJlciksIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQsIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYSwgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fcmVuZGVyKHJlbmRlcmVyKSk7XG59O1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgaWYgKHRoaXMuX2NhY2hlRGF0YT8uc3ByaXRlKVxuICAgIHJldHVybjtcbiAgY29uc3QgY2FjaGVBbHBoYSA9IHRoaXMuYWxwaGE7XG4gIHRoaXMuYWxwaGEgPSAxLCByZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICBjb25zdCBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKG5ldyBSZWN0YW5nbGUoKSwgITApO1xuICBpZiAodGhpcy5maWx0ZXJzPy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5maWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgYm91bmRzLnBhZChwYWRkaW5nKTtcbiAgfVxuICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xuICBib3VuZHMuY2VpbChyZXNvbHV0aW9uKSwgYm91bmRzLndpZHRoID0gTWF0aC5tYXgoYm91bmRzLndpZHRoLCAxIC8gcmVzb2x1dGlvbiksIGJvdW5kcy5oZWlnaHQgPSBNYXRoLm1heChib3VuZHMuaGVpZ2h0LCAxIC8gcmVzb2x1dGlvbik7XG4gIGNvbnN0IGNhY2hlZFJlbmRlclRleHR1cmUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQsIGNhY2hlZFNvdXJjZUZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5zb3VyY2VGcmFtZS5jbG9uZSgpLCBjYWNoZWREZXN0aW5hdGlvbkZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5kZXN0aW5hdGlvbkZyYW1lLmNsb25lKCksIGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSwgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICB3aWR0aDogYm91bmRzLndpZHRoLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICByZXNvbHV0aW9uLFxuICAgIG11bHRpc2FtcGxlOiB0aGlzLmNhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZSA/PyByZW5kZXJlci5tdWx0aXNhbXBsZVxuICB9KSwgdGV4dHVyZUNhY2hlSWQgPSBgY2FjaGVBc0JpdG1hcF8ke3V0aWxzLnVpZCgpfWA7XG4gIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IHRleHR1cmVDYWNoZUlkLCBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgY29uc3QgbSA9IHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHlUbyhfdGVtcE1hdHJpeCkuaW52ZXJ0KCkudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcbiAgdGhpcy5yZW5kZXIgPSB0aGlzLl9jYWNoZURhdGEub3JpZ2luYWxSZW5kZXIsIHJlbmRlcmVyLnJlbmRlcih0aGlzLCB7IHJlbmRlclRleHR1cmUsIGNsZWFyOiAhMCwgdHJhbnNmb3JtOiBtLCBza2lwVXBkYXRlVHJhbnNmb3JtOiAhMSB9KSwgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmxpdCgpLCByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm0sIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChjYWNoZWRSZW5kZXJUZXh0dXJlLCBjYWNoZWRTb3VyY2VGcmFtZSwgY2FjaGVkRGVzdGluYXRpb25GcmFtZSksIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQ2FjaGVkLCB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSwgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHMsIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcywgdGhpcy5fbWFzayA9IG51bGwsIHRoaXMuZmlsdGVyQXJlYSA9IG51bGwsIHRoaXMuYWxwaGEgPSBjYWNoZUFscGhhO1xuICBjb25zdCBjYWNoZWRTcHJpdGUgPSBuZXcgU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpLCBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCksIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGEsIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzLCB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlLCB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMSwgdGhpcy5wYXJlbnQgPyB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpIDogKHRoaXMuZW5hYmxlVGVtcFBhcmVudCgpLCB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpLCB0aGlzLmRpc2FibGVUZW1wUGFyZW50KG51bGwpKSwgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYWNoZWRDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAhdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUgfHwgKHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKHJlbmRlcmVyKSwgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhLCB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpKTtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICBpZiAodGhpcy5fY2FjaGVEYXRhPy5zcHJpdGUpXG4gICAgcmV0dXJuO1xuICBjb25zdCBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKG5ldyBSZWN0YW5nbGUoKSwgITApLCBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcbiAgdGhpcy5hbHBoYSA9IDE7XG4gIGNvbnN0IGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmNhbnZhc0NvbnRleHQuYWN0aXZlQ29udGV4dCwgY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLl9wcm9qVHJhbnNmb3JtLCByZXNvbHV0aW9uID0gdGhpcy5jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xuICBib3VuZHMuY2VpbChyZXNvbHV0aW9uKSwgYm91bmRzLndpZHRoID0gTWF0aC5tYXgoYm91bmRzLndpZHRoLCAxIC8gcmVzb2x1dGlvbiksIGJvdW5kcy5oZWlnaHQgPSBNYXRoLm1heChib3VuZHMuaGVpZ2h0LCAxIC8gcmVzb2x1dGlvbik7XG4gIGNvbnN0IHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlLmNyZWF0ZSh7XG4gICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgcmVzb2x1dGlvblxuICB9KSwgdGV4dHVyZUNhY2hlSWQgPSBgY2FjaGVBc0JpdG1hcF8ke3V0aWxzLnVpZCgpfWA7XG4gIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IHRleHR1cmVDYWNoZUlkLCBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgY29uc3QgbSA9IF90ZW1wTWF0cml4O1xuICB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybS5jb3B5VG8obSksIG0uaW52ZXJ0KCksIG0udHggLT0gYm91bmRzLngsIG0udHkgLT0gYm91bmRzLnksIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzLCByZW5kZXJlci5yZW5kZXIodGhpcywgeyByZW5kZXJUZXh0dXJlLCBjbGVhcjogITAsIHRyYW5zZm9ybTogbSwgc2tpcFVwZGF0ZVRyYW5zZm9ybTogITEgfSksIHJlbmRlcmVyLmNhbnZhc0NvbnRleHQuYWN0aXZlQ29udGV4dCA9IGNhY2hlZFJlbmRlclRhcmdldCwgcmVuZGVyZXIuX3Byb2pUcmFuc2Zvcm0gPSBjYWNoZWRQcm9qZWN0aW9uVHJhbnNmb3JtLCB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcywgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0sIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzLCB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHMsIHRoaXMuX21hc2sgPSBudWxsLCB0aGlzLmZpbHRlckFyZWEgPSBudWxsLCB0aGlzLmFscGhhID0gY2FjaGVBbHBoYTtcbiAgY29uc3QgY2FjaGVkU3ByaXRlID0gbmV3IFNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBjYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKSwgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpLCBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhLCBjYWNoZWRTcHJpdGUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcywgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZSwgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTEsIHRoaXMucGFyZW50ID8gdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSA6ICh0aGlzLnBhcmVudCA9IHJlbmRlcmVyLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy5wYXJlbnQgPSBudWxsKSwgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYm91bmRzLmNsZWFyKCksIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQsIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX2NhbGN1bGF0ZUJvdW5kcygpLCB0aGlzLl9ib3VuZHMudXBkYXRlSUQgPSB0aGlzLl9ib3VuZHNJRDtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuZ2V0TG9jYWxCb3VuZHMobnVsbCk7XG59O1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3RleHR1cmUuZGVzdHJveSghMCksIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBudWxsLCBCYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKSwgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKSwgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gbnVsbDtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcERlc3Ryb3kgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuY2FjaGVBc0JpdG1hcCA9ICExLCB0aGlzLmRlc3Ryb3kob3B0aW9ucyk7XG59O1xuZXhwb3J0IHtcbiAgQ2FjaGVEYXRhXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgRGlzcGxheU9iamVjdCwgQ29udGFpbmVyIH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLm5hbWUgPSBudWxsO1xuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGRlZXApIHtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKVxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XG4gIGlmIChkZWVwKVxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmICghY2hpbGQuZ2V0Q2hpbGRCeU5hbWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hpbGQuZ2V0Q2hpbGRCeU5hbWUobmFtZSwgITApO1xuICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIHJldHVybiBudWxsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IERpc3BsYXlPYmplY3QgfSBmcm9tIFwiQHBpeGkvZGlzcGxheVwiO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0R2xvYmFsUG9zaXRpb24gPSBmdW5jdGlvbihwb2ludCA9IG5ldyBQb2ludCgpLCBza2lwVXBkYXRlID0gITEpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudG9HbG9iYWwodGhpcy5wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpIDogKHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLngsIHBvaW50LnkgPSB0aGlzLnBvc2l0aW9uLnkpLCBwb2ludDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBmbG9hdCB1QWxwaGE7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHVBbHBoYTtcbn1cbmA7XG5leHBvcnQge1xuICBmcmFnbWVudCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxwaGEuZnJhZy5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIGRlZmF1bHRWZXJ0ZXggfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gXCIuL2FscGhhLmZyYWcubWpzXCI7XG5jbGFzcyBBbHBoYUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYWxwaGEgLSBBbW91bnQgb2YgYWxwaGEgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdHJhbnNwYXJlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFscGhhID0gMSkge1xuICAgIHN1cGVyKGRlZmF1bHRWZXJ0ZXgsIGZyYWdtZW50LCB7IHVBbHBoYTogMSB9KSwgdGhpcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIC8qKlxuICAgKiBDb2VmZmljaWVudCBmb3IgYWxwaGEgbXVsdGlwbGljYXRpb25cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYSA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQge1xuICBBbHBoYUZpbHRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFscGhhRmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEFscGhhRmlsdGVyIH0gZnJvbSBcIi4vQWxwaGFGaWx0ZXIubWpzXCI7XG5leHBvcnQge1xuICBBbHBoYUZpbHRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNvbnN0IEdBVVNTSUFOX1ZBTFVFUyA9IHtcbiAgNTogWzAuMTUzMzg4LCAwLjIyMTQ2MSwgMC4yNTAzMDFdLFxuICA3OiBbMC4wNzEzMDMsIDAuMTMxNTE0LCAwLjE4OTg3OSwgMC4yMTQ2MDddLFxuICA5OiBbMC4wMjg1MzIsIDAuMDY3MjM0LCAwLjEyNDAwOSwgMC4xNzkwNDQsIDAuMjAyMzZdLFxuICAxMTogWzkzZS00LCAwLjAyODAwMiwgMC4wNjU5ODQsIDAuMTIxNzAzLCAwLjE3NTcxMywgMC4xOTg1OTZdLFxuICAxMzogWzI0MDZlLTYsIDkyNTVlLTYsIDAuMDI3ODY3LCAwLjA2NTY2NiwgMC4xMjExMTcsIDAuMTc0ODY4LCAwLjE5NzY0MV0sXG4gIDE1OiBbNDg5ZS02LCAyNDAzZS02LCA5MjQ2ZS02LCAwLjAyNzg0LCAwLjA2NTYwMiwgMC4xMjA5OTksIDAuMTc0Njk3LCAwLjE5NzQ0OF1cbn0sIGZyYWdUZW1wbGF0ZSA9IFtcbiAgXCJ2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcIixcbiAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcIixcbiAgXCJ2b2lkIG1haW4odm9pZClcIixcbiAgXCJ7XCIsXG4gIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcIixcbiAgXCIgICAgJWJsdXIlXCIsXG4gIFwifVwiXG5dLmpvaW4oYFxuYCk7XG5mdW5jdGlvbiBnZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpIHtcbiAgY29uc3Qga2VybmVsID0gR0FVU1NJQU5fVkFMVUVTW2tlcm5lbFNpemVdLCBoYWxmTGVuZ3RoID0ga2VybmVsLmxlbmd0aDtcbiAgbGV0IGZyYWdTb3VyY2UgPSBmcmFnVGVtcGxhdGUsIGJsdXJMb29wID0gXCJcIjtcbiAgY29uc3QgdGVtcGxhdGUgPSBcImdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyVpbmRleCVdKSAqICV2YWx1ZSU7XCI7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICBsZXQgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoXCIlaW5kZXglXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgdmFsdWUgPSBpLCBpID49IGhhbGZMZW5ndGggJiYgKHZhbHVlID0ga2VybmVsU2l6ZSAtIGkgLSAxKSwgYmx1ciA9IGJsdXIucmVwbGFjZShcIiV2YWx1ZSVcIiwga2VybmVsW3ZhbHVlXS50b1N0cmluZygpKSwgYmx1ckxvb3AgKz0gYmx1ciwgYmx1ckxvb3AgKz0gYFxuYDtcbiAgfVxuICByZXR1cm4gZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZShcIiVibHVyJVwiLCBibHVyTG9vcCksIGZyYWdTb3VyY2UgPSBmcmFnU291cmNlLnJlcGxhY2UoXCIlc2l6ZSVcIiwga2VybmVsU2l6ZS50b1N0cmluZygpKSwgZnJhZ1NvdXJjZTtcbn1cbmV4cG9ydCB7XG4gIGdlbmVyYXRlQmx1ckZyYWdTb3VyY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUJsdXJGcmFnU291cmNlLm1qcy5tYXBcbiIsImNvbnN0IHZlcnRUZW1wbGF0ZSA9IGBcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5cbiAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcblxuICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG4gICAgdW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xuXG4gICAgdmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXG4gICAge1xuICAgICAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcblxuICAgICAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgfVxuXG4gICAgdmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKHZvaWQpXG4gICAge1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmVjMiB0ZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcbiAgICAgICAgJWJsdXIlXG4gICAgfWA7XG5mdW5jdGlvbiBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlKGtlcm5lbFNpemUsIHgpIHtcbiAgY29uc3QgaGFsZkxlbmd0aCA9IE1hdGguY2VpbChrZXJuZWxTaXplIC8gMik7XG4gIGxldCB2ZXJ0U291cmNlID0gdmVydFRlbXBsYXRlLCBibHVyTG9vcCA9IFwiXCIsIHRlbXBsYXRlO1xuICB4ID8gdGVtcGxhdGUgPSBcInZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gIHRleHR1cmVDb29yZCArIHZlYzIoJXNhbXBsZUluZGV4JSAqIHN0cmVuZ3RoLCAwLjApO1wiIDogdGVtcGxhdGUgPSBcInZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gIHRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAlc2FtcGxlSW5kZXglICogc3RyZW5ndGgpO1wiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xuICAgIGxldCBibHVyID0gdGVtcGxhdGUucmVwbGFjZShcIiVpbmRleCVcIiwgaS50b1N0cmluZygpKTtcbiAgICBibHVyID0gYmx1ci5yZXBsYWNlKFwiJXNhbXBsZUluZGV4JVwiLCBgJHtpIC0gKGhhbGZMZW5ndGggLSAxKX0uMGApLCBibHVyTG9vcCArPSBibHVyLCBibHVyTG9vcCArPSBgXG5gO1xuICB9XG4gIHJldHVybiB2ZXJ0U291cmNlID0gdmVydFNvdXJjZS5yZXBsYWNlKFwiJWJsdXIlXCIsIGJsdXJMb29wKSwgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZShcIiVzaXplJVwiLCBrZXJuZWxTaXplLnRvU3RyaW5nKCkpLCB2ZXJ0U291cmNlO1xufVxuZXhwb3J0IHtcbiAgZ2VuZXJhdGVCbHVyVmVydFNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlQmx1clZlcnRTb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBDTEVBUl9NT0RFUyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlIH0gZnJvbSBcIi4vZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5tanNcIjtcbmltcG9ydCB7IGdlbmVyYXRlQmx1clZlcnRTb3VyY2UgfSBmcm9tIFwiLi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLm1qc1wiO1xuY2xhc3MgQmx1ckZpbHRlclBhc3MgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIGhvcml6b250YWwgLSBEbyBwYXNzIGFsb25nIHRoZSB4LWF4aXMgKGB0cnVlYCkgb3IgeS1heGlzIChgZmFsc2VgKS5cbiAgICogQHBhcmFtIHN0cmVuZ3RoIC0gVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICogQHBhcmFtIHF1YWxpdHkgLSBUaGUgcXVhbGl0eSBvZiB0aGUgYmx1ciBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFtyZXNvbHV0aW9uPVBJWEkuRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uXSAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICogQHBhcmFtIGtlcm5lbFNpemUgLSBUaGUga2VybmVsU2l6ZSBvZiB0aGUgYmx1ciBmaWx0ZXIuT3B0aW9uczogNSwgNywgOSwgMTEsIDEzLCAxNS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhvcml6b250YWwsIHN0cmVuZ3RoID0gOCwgcXVhbGl0eSA9IDQsIHJlc29sdXRpb24gPSBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24sIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgY29uc3QgdmVydFNyYyA9IGdlbmVyYXRlQmx1clZlcnRTb3VyY2Uoa2VybmVsU2l6ZSwgaG9yaXpvbnRhbCksIGZyYWdTcmMgPSBnZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpO1xuICAgIHN1cGVyKFxuICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgdmVydFNyYyxcbiAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgZnJhZ1NyY1xuICAgICksIHRoaXMuaG9yaXpvbnRhbCA9IGhvcml6b250YWwsIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24sIHRoaXMuX3F1YWxpdHkgPSAwLCB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5LCB0aGlzLmJsdXIgPSBzdHJlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0gZmlsdGVyTWFuYWdlciAtIFRoZSBtYW5hZ2VyLlxuICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXG4gICAqIEBwYXJhbSBjbGVhck1vZGUgLSBIb3cgdG8gY2xlYXJcbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGlmIChvdXRwdXQgPyB0aGlzLmhvcml6b250YWwgPyB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIG91dHB1dC53aWR0aCAqIChvdXRwdXQud2lkdGggLyBpbnB1dC53aWR0aCkgOiB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIG91dHB1dC5oZWlnaHQgKiAob3V0cHV0LmhlaWdodCAvIGlucHV0LmhlaWdodCkgOiB0aGlzLmhvcml6b250YWwgPyB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGggKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci53aWR0aCAvIGlucHV0LndpZHRoKSA6IHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAxIC8gZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQgKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpLCB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoICo9IHRoaXMuc3RyZW5ndGgsIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggLz0gdGhpcy5wYXNzZXMsIHRoaXMucGFzc2VzID09PSAxKVxuICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJUZXh0dXJlKCksIHJlbmRlcmVyID0gZmlsdGVyTWFuYWdlci5yZW5kZXJlcjtcbiAgICAgIGxldCBmbGlwID0gaW5wdXQsIGZsb3AgPSByZW5kZXJUYXJnZXQ7XG4gICAgICB0aGlzLnN0YXRlLmJsZW5kID0gITEsIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxpcCwgZmxvcCwgQ0xFQVJfTU9ERVMuQ0xFQVIpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnBhc3NlcyAtIDE7IGkrKykge1xuICAgICAgICBmaWx0ZXJNYW5hZ2VyLmJpbmRBbmRDbGVhcihmbGlwLCBDTEVBUl9NT0RFUy5CTElUKSwgdGhpcy51bmlmb3Jtcy51U2FtcGxlciA9IGZsb3A7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBmbG9wO1xuICAgICAgICBmbG9wID0gZmxpcCwgZmxpcCA9IHRlbXAsIHJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMpLCByZW5kZXJlci5nZW9tZXRyeS5kcmF3KDUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5ibGVuZCA9ICEwLCBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsb3AsIG91dHB1dCwgY2xlYXJNb2RlKSwgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxuICAgKiBAZGVmYXVsdCAxNlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLnBhZGRpbmcgPSAxICsgTWF0aC5hYnModmFsdWUpICogMiwgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGJ5IG1vZGlmeWluZyB0aGUgbnVtYmVyIG9mIHBhc3Nlcy4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyXG4gICAqIHF1YWxpdHkgYmx1cmluZyBidXQgdGhlIGxvd2VyIHRoZSBwZXJmb3JtYW5jZS5cbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1YWxpdHk7XG4gIH1cbiAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICB0aGlzLl9xdWFsaXR5ID0gdmFsdWUsIHRoaXMucGFzc2VzID0gdmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEJsdXJGaWx0ZXJQYXNzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qmx1ckZpbHRlclBhc3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBDTEVBUl9NT0RFUyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBCbHVyRmlsdGVyUGFzcyB9IGZyb20gXCIuL0JsdXJGaWx0ZXJQYXNzLm1qc1wiO1xuY2xhc3MgQmx1ckZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc3RyZW5ndGggLSBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgKiBAcGFyYW0gcXVhbGl0eSAtIFRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGZpbHRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW3Jlc29sdXRpb249UElYSS5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb25dIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgKiBAcGFyYW0ga2VybmVsU2l6ZSAtIFRoZSBrZXJuZWxTaXplIG9mIHRoZSBibHVyIGZpbHRlci5PcHRpb25zOiA1LCA3LCA5LCAxMSwgMTMsIDE1LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RyZW5ndGggPSA4LCBxdWFsaXR5ID0gNCwgcmVzb2x1dGlvbiA9IEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiwga2VybmVsU2l6ZSA9IDUpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzID0gITEsIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3MoITAsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKSwgdGhpcy5ibHVyWUZpbHRlciA9IG5ldyBCbHVyRmlsdGVyUGFzcyghMSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpLCB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uLCB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5LCB0aGlzLmJsdXIgPSBzdHJlbmd0aCwgdGhpcy5yZXBlYXRFZGdlUGl4ZWxzID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cbiAgICogQHBhcmFtIG91dHB1dCAtIFRoZSBvdXRwdXQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gY2xlYXJNb2RlIC0gSG93IHRvIGNsZWFyXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCB4U3RyZW5ndGggPSBNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKSwgeVN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCk7XG4gICAgaWYgKHhTdHJlbmd0aCAmJiB5U3RyZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpO1xuICAgICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgcmVuZGVyVGFyZ2V0LCBDTEVBUl9NT0RFUy5DTEVBUiksIHRoaXMuYmx1cllGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyTW9kZSksIGZpbHRlck1hbmFnZXIucmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICAgIH0gZWxzZVxuICAgICAgeVN0cmVuZ3RoID8gdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIDogdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIHVwZGF0ZVBhZGRpbmcoKSB7XG4gICAgdGhpcy5fcmVwZWF0RWRnZVBpeGVscyA/IHRoaXMucGFkZGluZyA9IDAgOiB0aGlzLnBhZGRpbmcgPSBNYXRoLm1heChNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKSwgTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCkpICogMjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlLCB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBhc3NlcyBmb3IgYmx1ci4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYmx1cmluZy5cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eTtcbiAgfVxuICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eSA9IHRoaXMuYmx1cllGaWx0ZXIucXVhbGl0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IGJsdXJYKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJYKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWUsIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IGJsdXJZKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJZKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWUsIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibGVuZG1vZGUgb2YgdGhlIGZpbHRlclxuICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGU7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1cllGaWx0ZXIuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIElmIHNldCB0byB0cnVlIHRoZSBlZGdlIG9mIHRoZSB0YXJnZXQgd2lsbCBiZSBjbGFtcGVkXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgcmVwZWF0RWRnZVBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0RWRnZVBpeGVscztcbiAgfVxuICBzZXQgcmVwZWF0RWRnZVBpeGVscyh2YWx1ZSkge1xuICAgIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMgPSB2YWx1ZSwgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEJsdXJGaWx0ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbHVyRmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEJsdXJGaWx0ZXIgfSBmcm9tIFwiLi9CbHVyRmlsdGVyLm1qc1wiO1xuaW1wb3J0IHsgQmx1ckZpbHRlclBhc3MgfSBmcm9tIFwiLi9CbHVyRmlsdGVyUGFzcy5tanNcIjtcbmV4cG9ydCB7XG4gIEJsdXJGaWx0ZXIsXG4gIEJsdXJGaWx0ZXJQYXNzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG51bmlmb3JtIGZsb2F0IG1bMjBdO1xudW5pZm9ybSBmbG9hdCB1QWxwaGE7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIHZlYzQgYyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG5cbiAgICBpZiAodUFscGhhID09IDAuMCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cbiAgICBpZiAoYy5hID4gMC4wKSB7XG4gICAgICBjLnJnYiAvPSBjLmE7XG4gICAgfVxuXG4gICAgdmVjNCByZXN1bHQ7XG5cbiAgICByZXN1bHQuciA9IChtWzBdICogYy5yKTtcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bMV0gKiBjLmcpO1xuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XG4gICAgICAgIHJlc3VsdC5yICs9IChtWzNdICogYy5hKTtcbiAgICAgICAgcmVzdWx0LnIgKz0gbVs0XTtcblxuICAgIHJlc3VsdC5nID0gKG1bNV0gKiBjLnIpO1xuICAgICAgICByZXN1bHQuZyArPSAobVs2XSAqIGMuZyk7XG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcbiAgICAgICAgcmVzdWx0LmcgKz0gKG1bOF0gKiBjLmEpO1xuICAgICAgICByZXN1bHQuZyArPSBtWzldO1xuXG4gICAgcmVzdWx0LmIgPSAobVsxMF0gKiBjLnIpO1xuICAgICAgIHJlc3VsdC5iICs9IChtWzExXSAqIGMuZyk7XG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcbiAgICAgICByZXN1bHQuYiArPSAobVsxM10gKiBjLmEpO1xuICAgICAgIHJlc3VsdC5iICs9IG1bMTRdO1xuXG4gICAgcmVzdWx0LmEgPSAobVsxNV0gKiBjLnIpO1xuICAgICAgIHJlc3VsdC5hICs9IChtWzE2XSAqIGMuZyk7XG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcbiAgICAgICByZXN1bHQuYSArPSAobVsxOF0gKiBjLmEpO1xuICAgICAgIHJlc3VsdC5hICs9IG1bMTldO1xuXG4gICAgdmVjMyByZ2IgPSBtaXgoYy5yZ2IsIHJlc3VsdC5yZ2IsIHVBbHBoYSk7XG5cbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cbiAgICByZ2IgKj0gcmVzdWx0LmE7XG5cbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xufVxuYDtcbmV4cG9ydCB7XG4gIGZyYWdtZW50IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvck1hdHJpeC5mcmFnLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVmYXVsdEZpbHRlclZlcnRleCwgQ29sb3IgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gXCIuL2NvbG9yTWF0cml4LmZyYWcubWpzXCI7XG5jbGFzcyBDb2xvck1hdHJpeEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgbTogbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDBcbiAgICAgIF0pLFxuICAgICAgdUFscGhhOiAxXG4gICAgfTtcbiAgICBzdXBlcihkZWZhdWx0RmlsdGVyVmVydGV4LCBmcmFnbWVudCwgdW5pZm9ybXMpLCB0aGlzLmFscGhhID0gMTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtcyBjdXJyZW50IG1hdHJpeCBhbmQgc2V0IHRoZSBuZXcgb25lXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IG1hdHJpeCAtIDV4NCBtYXRyaXhcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBfbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5ID0gITEpIHtcbiAgICBsZXQgbmV3TWF0cml4ID0gbWF0cml4O1xuICAgIG11bHRpcGx5ICYmICh0aGlzLl9tdWx0aXBseShuZXdNYXRyaXgsIHRoaXMudW5pZm9ybXMubSwgbWF0cml4KSwgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KSksIHRoaXMudW5pZm9ybXMubSA9IG5ld01hdHJpeDtcbiAgfVxuICAvKipcbiAgICogTXVsdGlwbGllcyB0d28gbWF0NSdzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBvdXQgLSA1eDQgbWF0cml4IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gICAqIEBwYXJhbSBhIC0gNXg0IG1hdHJpeCB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgKiBAcGFyYW0gYiAtIDV4NCBtYXRyaXggdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gNXg0IG1hdHJpeFxuICAgKi9cbiAgX211bHRpcGx5KG91dCwgYSwgYikge1xuICAgIHJldHVybiBvdXRbMF0gPSBhWzBdICogYlswXSArIGFbMV0gKiBiWzVdICsgYVsyXSAqIGJbMTBdICsgYVszXSAqIGJbMTVdLCBvdXRbMV0gPSBhWzBdICogYlsxXSArIGFbMV0gKiBiWzZdICsgYVsyXSAqIGJbMTFdICsgYVszXSAqIGJbMTZdLCBvdXRbMl0gPSBhWzBdICogYlsyXSArIGFbMV0gKiBiWzddICsgYVsyXSAqIGJbMTJdICsgYVszXSAqIGJbMTddLCBvdXRbM10gPSBhWzBdICogYlszXSArIGFbMV0gKiBiWzhdICsgYVsyXSAqIGJbMTNdICsgYVszXSAqIGJbMThdLCBvdXRbNF0gPSBhWzBdICogYls0XSArIGFbMV0gKiBiWzldICsgYVsyXSAqIGJbMTRdICsgYVszXSAqIGJbMTldICsgYVs0XSwgb3V0WzVdID0gYVs1XSAqIGJbMF0gKyBhWzZdICogYls1XSArIGFbN10gKiBiWzEwXSArIGFbOF0gKiBiWzE1XSwgb3V0WzZdID0gYVs1XSAqIGJbMV0gKyBhWzZdICogYls2XSArIGFbN10gKiBiWzExXSArIGFbOF0gKiBiWzE2XSwgb3V0WzddID0gYVs1XSAqIGJbMl0gKyBhWzZdICogYls3XSArIGFbN10gKiBiWzEyXSArIGFbOF0gKiBiWzE3XSwgb3V0WzhdID0gYVs1XSAqIGJbM10gKyBhWzZdICogYls4XSArIGFbN10gKiBiWzEzXSArIGFbOF0gKiBiWzE4XSwgb3V0WzldID0gYVs1XSAqIGJbNF0gKyBhWzZdICogYls5XSArIGFbN10gKiBiWzE0XSArIGFbOF0gKiBiWzE5XSArIGFbOV0sIG91dFsxMF0gPSBhWzEwXSAqIGJbMF0gKyBhWzExXSAqIGJbNV0gKyBhWzEyXSAqIGJbMTBdICsgYVsxM10gKiBiWzE1XSwgb3V0WzExXSA9IGFbMTBdICogYlsxXSArIGFbMTFdICogYls2XSArIGFbMTJdICogYlsxMV0gKyBhWzEzXSAqIGJbMTZdLCBvdXRbMTJdID0gYVsxMF0gKiBiWzJdICsgYVsxMV0gKiBiWzddICsgYVsxMl0gKiBiWzEyXSArIGFbMTNdICogYlsxN10sIG91dFsxM10gPSBhWzEwXSAqIGJbM10gKyBhWzExXSAqIGJbOF0gKyBhWzEyXSAqIGJbMTNdICsgYVsxM10gKiBiWzE4XSwgb3V0WzE0XSA9IGFbMTBdICogYls0XSArIGFbMTFdICogYls5XSArIGFbMTJdICogYlsxNF0gKyBhWzEzXSAqIGJbMTldICsgYVsxNF0sIG91dFsxNV0gPSBhWzE1XSAqIGJbMF0gKyBhWzE2XSAqIGJbNV0gKyBhWzE3XSAqIGJbMTBdICsgYVsxOF0gKiBiWzE1XSwgb3V0WzE2XSA9IGFbMTVdICogYlsxXSArIGFbMTZdICogYls2XSArIGFbMTddICogYlsxMV0gKyBhWzE4XSAqIGJbMTZdLCBvdXRbMTddID0gYVsxNV0gKiBiWzJdICsgYVsxNl0gKiBiWzddICsgYVsxN10gKiBiWzEyXSArIGFbMThdICogYlsxN10sIG91dFsxOF0gPSBhWzE1XSAqIGJbM10gKyBhWzE2XSAqIGJbOF0gKyBhWzE3XSAqIGJbMTNdICsgYVsxOF0gKiBiWzE4XSwgb3V0WzE5XSA9IGFbMTVdICogYls0XSArIGFbMTZdICogYls5XSArIGFbMTddICogYlsxNF0gKyBhWzE4XSAqIGJbMTldICsgYVsxOV0sIG91dDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRmxvYXQzMiBBcnJheSBhbmQgbm9ybWFsaXplIHRoZSBvZmZzZXQgY29tcG9uZW50IHRvIDAtMVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gNXg0IG1hdHJpeCB3aXRoIGFsbCB2YWx1ZXMgYmV0d2VlbiAwLTFcbiAgICovXG4gIF9jb2xvck1hdHJpeChtYXRyaXgpIHtcbiAgICBjb25zdCBtID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXgpO1xuICAgIHJldHVybiBtWzRdIC89IDI1NSwgbVs5XSAvPSAyNTUsIG1bMTRdIC89IDI1NSwgbVsxOV0gLz0gMjU1LCBtO1xuICB9XG4gIC8qKlxuICAgKiBBZGp1c3RzIGJyaWdodG5lc3NcbiAgICogQHBhcmFtIGIgLSB2YWx1ZSBvZiB0aGUgYnJpZ3RobmVzcyAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGJyaWdodG5lc3MoYiwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBlYWNoIGNoYW5uZWwgb24gdGhlIGRpYWdvbmFsIG9mIHRoZSBjb2xvciBtYXRyaXguXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gYWNoaWV2ZSBhIHRpbnRpbmcgZWZmZWN0IG9uIENvbnRhaW5lcnMgc2ltaWxhciB0byB0aGUgdGludCBmaWVsZCBvZiBzb21lXG4gICAqIGRpc3BsYXkgb2JqZWN0cyBsaWtlIFNwcml0ZSwgVGV4dCwgR3JhcGhpY3MsIGFuZCBNZXNoLlxuICAgKiBAcGFyYW0gY29sb3IgLSBDb2xvciBvZiB0aGUgdGludC4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICB0aW50KGNvbG9yLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb2xvcikudG9BcnJheSgpLCBtYXRyaXggPSBbXG4gICAgICByLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBnLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBtYXRyaWNlcyBpbiBncmV5IHNjYWxlc1xuICAgKiBAcGFyYW0gc2NhbGUgLSB2YWx1ZSBvZiB0aGUgZ3JleSAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGdyZXlzY2FsZShzY2FsZSwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZS5cbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBibGFja0FuZFdoaXRlKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC4zLFxuICAgICAgMC42LFxuICAgICAgMC4xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjMsXG4gICAgICAwLjYsXG4gICAgICAwLjEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMyxcbiAgICAgIDAuNixcbiAgICAgIDAuMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgaHVlIHByb3BlcnR5IG9mIHRoZSBjb2xvclxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBpbiBkZWdyZWVzXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgaHVlKHJvdGF0aW9uLCBtdWx0aXBseSkge1xuICAgIHJvdGF0aW9uID0gKHJvdGF0aW9uIHx8IDApIC8gMTgwICogTWF0aC5QSTtcbiAgICBjb25zdCBjb3NSID0gTWF0aC5jb3Mocm90YXRpb24pLCBzaW5SID0gTWF0aC5zaW4ocm90YXRpb24pLCBzcXJ0ID0gTWF0aC5zcXJ0LCB3ID0gMSAvIDMsIHNxclcgPSBzcXJ0KHcpLCBhMDAgPSBjb3NSICsgKDEgLSBjb3NSKSAqIHcsIGEwMSA9IHcgKiAoMSAtIGNvc1IpIC0gc3FyVyAqIHNpblIsIGEwMiA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblIsIGExMCA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblIsIGExMSA9IGNvc1IgKyB3ICogKDEgLSBjb3NSKSwgYTEyID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUiwgYTIwID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUiwgYTIxID0gdyAqICgxIC0gY29zUikgKyBzcXJXICogc2luUiwgYTIyID0gY29zUiArIHcgKiAoMSAtIGNvc1IpLCBtYXRyaXggPSBbXG4gICAgICBhMDAsXG4gICAgICBhMDEsXG4gICAgICBhMDIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGExMCxcbiAgICAgIGExMSxcbiAgICAgIGExMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYTIwLFxuICAgICAgYTIxLFxuICAgICAgYTIyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjb250cmFzdCBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gZGFyayBhbmQgYnJpZ2h0XG4gICAqIEluY3JlYXNlIGNvbnRyYXN0IDogc2hhZG93cyBkYXJrZXIgYW5kIGhpZ2hsaWdodHMgYnJpZ2h0ZXJcbiAgICogRGVjcmVhc2UgY29udHJhc3QgOiBicmluZyB0aGUgc2hhZG93cyB1cCBhbmQgdGhlIGhpZ2hsaWdodHMgZG93blxuICAgKiBAcGFyYW0gYW1vdW50IC0gdmFsdWUgb2YgdGhlIGNvbnRyYXN0ICgwLTEpXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgY29udHJhc3QoYW1vdW50LCBtdWx0aXBseSkge1xuICAgIGNvbnN0IHYgPSAoYW1vdW50IHx8IDApICsgMSwgbyA9IC0wLjUgKiAodiAtIDEpLCBtYXRyaXggPSBbXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgbyxcbiAgICAgIDAsXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIG8sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzYXR1cmF0aW9uIG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBjb2xvcnNcbiAgICogSW5jcmVhc2Ugc2F0dXJhdGlvbiA6IGluY3JlYXNlIGNvbnRyYXN0LCBicmlnaHRuZXNzLCBhbmQgc2hhcnBuZXNzXG4gICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgc2F0dXJhdGlvbiBhbW91bnQgKDAtMSlcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBzYXR1cmF0ZShhbW91bnQgPSAwLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IHggPSBhbW91bnQgKiAyIC8gMyArIDEsIHkgPSAoeCAtIDEpICogLTAuNSwgbWF0cml4ID0gW1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcikgQ2FsbCB0aGUgc2F0dXJhdGUgZnVuY3Rpb24gKi9cbiAgZGVzYXR1cmF0ZSgpIHtcbiAgICB0aGlzLnNhdHVyYXRlKC0xKTtcbiAgfVxuICAvKipcbiAgICogTmVnYXRpdmUgaW1hZ2UgKGludmVyc2Ugb2YgY2xhc3NpYyByZ2IgbWF0cml4KVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIG5lZ2F0aXZlKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgLTEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0xLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcGlhIGltYWdlXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgc2VwaWEobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjM5MyxcbiAgICAgIDAuNzY4OTk5OSxcbiAgICAgIDAuMTg4OTk5OTksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMzQ5LFxuICAgICAgMC42ODU5OTk5LFxuICAgICAgMC4xNjc5OTk5OSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC4yNzIsXG4gICAgICAwLjUzMzk5OTksXG4gICAgICAwLjEzMDk5OTk5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogQ29sb3IgbW90aW9uIHBpY3R1cmUgcHJvY2VzcyBpbnZlbnRlZCBpbiAxOTE2ICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHRlY2huaWNvbG9yKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMS45MTI1Mjc3ODkxNDU2MDgzLFxuICAgICAgLTAuODU0NTM0NDk3Njk1MTY0NSxcbiAgICAgIC0wLjA5MTU1NTA4NDgyNzU1NTg1LFxuICAgICAgMCxcbiAgICAgIDExLjc5MzYwMzQzNDM3NzMzNyxcbiAgICAgIC0wLjMwODc4MzMzODU5MjgwOTcsXG4gICAgICAxLjc2NTg5MDg1NTU0NTg0MjgsXG4gICAgICAtMC4xMDYwMTc0MzA3NDcyMjI0NSxcbiAgICAgIDAsXG4gICAgICAtNzAuMzUyMDUxNjE0NjEzOTgsXG4gICAgICAtMC4yMzExMDMzNzc1NDg2MTYsXG4gICAgICAtMC43NTAxODk5MTk3NDQwMjEyLFxuICAgICAgMS44NDc1OTc4MTYxMDgxODksXG4gICAgICAwLFxuICAgICAgMzAuOTUwOTQwODY5NDkxMTM4LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFBvbGFyb2lkIGZpbHRlclxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHBvbGFyb2lkKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMS40MzgsXG4gICAgICAtMC4wNjIsXG4gICAgICAtMC4wNjIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0wLjEyMixcbiAgICAgIDEuMzc4LFxuICAgICAgLTAuMTIyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC4wMTYsXG4gICAgICAtMC4wMTYsXG4gICAgICAxLjQ4MyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbHRlciB3aG8gdHJhbnNmb3JtcyA6IFJlZCAtPiBCbHVlIGFuZCBCbHVlIC0+IFJlZFxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbG9yIHJldmVyc2FsIGZpbG0gaW50cm9kdWNlZCBieSBFYXN0bWFuIEtvZGFrIGluIDE5MzUuICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGtvZGFjaHJvbWUobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLjEyODU1ODIzOTY1OTM1MjUsXG4gICAgICAtMC4zOTY3MzgyMjgzNjAxMzQ4LFxuICAgICAgLTAuMDM5OTI1NTkxNzI5MjE3OTMsXG4gICAgICAwLFxuICAgICAgNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNixcbiAgICAgIDEuMDgzNTI1MTU2NjI5MTMwNCxcbiAgICAgIC0wLjA1NDk4ODA1MTE1NjMzMTMyLFxuICAgICAgMCxcbiAgICAgIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLFxuICAgICAgLTAuNTYwMzQxNjI3NzY5NTI0OCxcbiAgICAgIDEuNjAxNDg1MDc2MTk2NDk0MyxcbiAgICAgIDAsXG4gICAgICAzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIC8qKlxuICAgKiBCcm93biBkZWxpY2lvdXMgYnJvd25pIGZpbHRlciAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBicm93bmkobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjU5OTcwMjM0OTgxNTk3MTUsXG4gICAgICAwLjM0NTUzMjQzMDQ4MzkxMjYzLFxuICAgICAgLTAuMjcwODI5ODY3NDUzODA0MixcbiAgICAgIDAsXG4gICAgICA0Ny40MzE5Mjg1NTYwMDg3MyxcbiAgICAgIC0wLjAzNzcwMzI0OTgzNzc4MzE1NyxcbiAgICAgIDAuODYwOTU3NzU4Nzk5MjY0MSxcbiAgICAgIDAuMTUwNTk1NTIzODg0NTk5MTMsXG4gICAgICAwLFxuICAgICAgLTM2Ljk2ODQxNDk4MzE5MTI3LFxuICAgICAgMC4yNDExMzYzNTEyODE1MzMzNSxcbiAgICAgIC0wLjA3NDQxMDM3OTA4NDIyNDkyLFxuICAgICAgMC40NDk3MjE4MjA2NDg3NzE1MyxcbiAgICAgIDAsXG4gICAgICAtNy41NjIwNzUyNzc1OTEyODMsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogVmludGFnZSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgdmludGFnZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuNjI3OTM0NTYzNTYwNTk5NCxcbiAgICAgIDAuMzIwMjE4MzQyMDgxOTM2NyxcbiAgICAgIC0wLjAzOTY1NDA4MjExMzEyNDUzLFxuICAgICAgMCxcbiAgICAgIDkuNjUxMjg1ODM1Mjk0MTIzLFxuICAgICAgMC4wMjU3ODM5NzcwNDgwODg2OCxcbiAgICAgIDAuNjQ0MTE4ODY0NDM3NDc3MSxcbiAgICAgIDAuMDMyNTkxMjc2MTYxNDkyOTQsXG4gICAgICAwLFxuICAgICAgNy40NjI4MjkxNzY0NzA1OTEsXG4gICAgICAwLjA0NjYwNTU1NTY3ODI3MTksXG4gICAgICAtMC4wODUxMjMyOTg3MjQ3ODkxLFxuICAgICAgMC41MjQxNjQ4MDE4NzAwNDY1LFxuICAgICAgMCxcbiAgICAgIDUuMTU5MTkwNTg4MjM1Mjk2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IGl0IGRvZXMsIGtpbmQgb2YgZ3JhZGllbnQgbWFwLCBidXQgZnVubnkgdG8gcGxheSB3aXRoIVxuICAgKiBAcGFyYW0gZGVzYXR1cmF0aW9uIC0gVG9uZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB0b25lZCAtIFRvbmUgdmFsdWVzLlxuICAgKiBAcGFyYW0gbGlnaHRDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAqIEBwYXJhbSBkYXJrQ29sb3IgLSBUb25lIHZhbHVlcywgZXhhbXBsZTogYDB4RkZFNTgwYFxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGNvbG9yVG9uZShkZXNhdHVyYXRpb24sIHRvbmVkLCBsaWdodENvbG9yLCBkYXJrQ29sb3IsIG11bHRpcGx5KSB7XG4gICAgZGVzYXR1cmF0aW9uID0gZGVzYXR1cmF0aW9uIHx8IDAuMiwgdG9uZWQgPSB0b25lZCB8fCAwLjE1LCBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAxNjc3MDQzMiwgZGFya0NvbG9yID0gZGFya0NvbG9yIHx8IDMzNzUxMDQ7XG4gICAgY29uc3QgdGVtcCA9IENvbG9yLnNoYXJlZCwgW2xSLCBsRywgbEJdID0gdGVtcC5zZXRWYWx1ZShsaWdodENvbG9yKS50b0FycmF5KCksIFtkUiwgZEcsIGRCXSA9IHRlbXAuc2V0VmFsdWUoZGFya0NvbG9yKS50b0FycmF5KCksIG1hdHJpeCA9IFtcbiAgICAgIDAuMyxcbiAgICAgIDAuNTksXG4gICAgICAwLjExLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBsUixcbiAgICAgIGxHLFxuICAgICAgbEIsXG4gICAgICBkZXNhdHVyYXRpb24sXG4gICAgICAwLFxuICAgICAgZFIsXG4gICAgICBkRyxcbiAgICAgIGRCLFxuICAgICAgdG9uZWQsXG4gICAgICAwLFxuICAgICAgbFIgLSBkUixcbiAgICAgIGxHIC0gZEcsXG4gICAgICBsQiAtIGRCLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIE5pZ2h0IGVmZmVjdFxuICAgKiBAcGFyYW0gaW50ZW5zaXR5IC0gVGhlIGludGVuc2l0eSBvZiB0aGUgbmlnaHQgZWZmZWN0LlxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIG5pZ2h0KGludGVuc2l0eSwgbXVsdGlwbHkpIHtcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIGludGVuc2l0eSAqIC0yLFxuICAgICAgLWludGVuc2l0eSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC1pbnRlbnNpdHksXG4gICAgICAwLFxuICAgICAgaW50ZW5zaXR5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgaW50ZW5zaXR5LFxuICAgICAgaW50ZW5zaXR5ICogMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZWRhdG9yIGVmZmVjdFxuICAgKlxuICAgKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyBhIG5ldyBpbmRlcGVudCBvbmVcbiAgICogQHBhcmFtIGFtb3VudCAtIGhvdyBtdWNoIHRoZSBwcmVkYXRvciBmZWVscyBoaXMgZnV0dXJlIHZpY3RpbVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHByZWRhdG9yKGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAvLyByb3cgMVxuICAgICAgMTEuMjI0MTMwNjMwNDkzMTY0ICogYW1vdW50LFxuICAgICAgLTQuNzk0NDg2OTk5NTExNzE5ICogYW1vdW50LFxuICAgICAgLTIuODc0NjExODU0NTUzMjIyNyAqIGFtb3VudCxcbiAgICAgIDAgKiBhbW91bnQsXG4gICAgICAwLjQwMzQyNDM4MjIwOTc3NzgzICogYW1vdW50LFxuICAgICAgLy8gcm93IDJcbiAgICAgIC0zLjYzMzA2OTc1MzY0Njg1MDYgKiBhbW91bnQsXG4gICAgICA5LjE5MzE1NzE5NjA0NDkyMiAqIGFtb3VudCxcbiAgICAgIC0yLjk1MTgxMDgzNjc5MTk5MiAqIGFtb3VudCxcbiAgICAgIDAgKiBhbW91bnQsXG4gICAgICAtMS4zMTYxMzUwNDg4NjYyNzIgKiBhbW91bnQsXG4gICAgICAvLyByb3cgM1xuICAgICAgLTMuMjE4NDE5NzkwMjY3OTQ0MyAqIGFtb3VudCxcbiAgICAgIC00LjIzNzUwMzA1MTc1NzgxMjUgKiBhbW91bnQsXG4gICAgICA3LjQ3NjQ0ODA1OTA4MjAzMSAqIGFtb3VudCxcbiAgICAgIDAgKiBhbW91bnQsXG4gICAgICAwLjgwNDQ0NTkyMjM3NDcyNTMgKiBhbW91bnQsXG4gICAgICAvLyByb3cgNFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIExTRCBlZmZlY3RcbiAgICpcbiAgICogTXVsdGlwbHkgdGhlIGN1cnJlbnQgbWF0cml4XG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgbHNkKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMixcbiAgICAgIC0wLjQsXG4gICAgICAwLjUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0wLjUsXG4gICAgICAyLFxuICAgICAgLTAuNCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuNCxcbiAgICAgIC0wLjUsXG4gICAgICAzLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKiogRXJhc2UgdGhlIGN1cnJlbnQgbWF0cml4IGJ5IHNldHRpbmcgdGhlIGRlZmF1bHQgb25lLiAqL1xuICByZXNldCgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsICExKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hdHJpeCBvZiB0aGUgY29sb3IgbWF0cml4IGZpbHRlclxuICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICogQGRlZmF1bHQgWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdXG4gICAqL1xuICBnZXQgbWF0cml4KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm07XG4gIH1cbiAgc2V0IG1hdHJpeCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3BhY2l0eSB2YWx1ZSB0byB1c2Ugd2hlbiBtaXhpbmcgdGhlIG9yaWdpbmFsIGFuZCByZXN1bHRhbnQgY29sb3JzLlxuICAgKlxuICAgKiBXaGVuIHRoZSB2YWx1ZSBpcyAwLCB0aGUgb3JpZ2luYWwgY29sb3IgaXMgdXNlZCB3aXRob3V0IG1vZGlmaWNhdGlvbi5cbiAgICogV2hlbiB0aGUgdmFsdWUgaXMgMSwgdGhlIHJlc3VsdCBjb2xvciBpcyB1c2VkLlxuICAgKiBXaGVuIGluIHRoZSByYW5nZSAoMCwgMSkgdGhlIGNvbG9yIGlzIGludGVycG9sYXRlZCBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBhbmQgcmVzdWx0IGJ5IHRoaXMgYW1vdW50LlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gIH1cbn1cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmF5c2NhbGUgPSBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuZ3JleXNjYWxlO1xuZXhwb3J0IHtcbiAgQ29sb3JNYXRyaXhGaWx0ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hdHJpeEZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvck1hdHJpeEZpbHRlciB9IGZyb20gXCIuL0NvbG9yTWF0cml4RmlsdGVyLm1qc1wiO1xuZXhwb3J0IHtcbiAgQ29sb3JNYXRyaXhGaWx0ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBgdmFyeWluZyB2ZWMyIHZGaWx0ZXJDb29yZDtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIHZlYzIgc2NhbGU7XG51bmlmb3JtIG1hdDIgcm90YXRpb247XG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XG5cbnVuaWZvcm0gaGlnaHAgdmVjNCBpbnB1dFNpemU7XG51bmlmb3JtIHZlYzQgaW5wdXRDbGFtcDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gIHZlYzQgbWFwID0gIHRleHR1cmUyRChtYXBTYW1wbGVyLCB2RmlsdGVyQ29vcmQpO1xuXG4gIG1hcCAtPSAwLjU7XG4gIG1hcC54eSA9IHNjYWxlICogaW5wdXRTaXplLnp3ICogKHJvdGF0aW9uICogbWFwLnh5KTtcblxuICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNsYW1wKHZlYzIodlRleHR1cmVDb29yZC54ICsgbWFwLngsIHZUZXh0dXJlQ29vcmQueSArIG1hcC55KSwgaW5wdXRDbGFtcC54eSwgaW5wdXRDbGFtcC56dykpO1xufVxuYDtcbmV4cG9ydCB7XG4gIGZyYWdtZW50IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwbGFjZW1lbnQuZnJhZy5tanMubWFwXG4iLCJ2YXIgdmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG51bmlmb3JtIG1hdDMgZmlsdGVyTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XG5cbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XG5cbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxue1xuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xuXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xufVxuXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXG57XG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XG59XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuXHRnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XG5cdHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcblx0dkZpbHRlckNvb3JkID0gKCBmaWx0ZXJNYXRyaXggKiB2ZWMzKCB2VGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xufVxuYDtcbmV4cG9ydCB7XG4gIHZlcnRleCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxhY2VtZW50LnZlcnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBNYXRyaXgsIFBvaW50IH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCBmcmFnbWVudCBmcm9tIFwiLi9kaXNwbGFjZW1lbnQuZnJhZy5tanNcIjtcbmltcG9ydCB2ZXJ0ZXggZnJvbSBcIi4vZGlzcGxhY2VtZW50LnZlcnQubWpzXCI7XG5jbGFzcyBEaXNwbGFjZW1lbnRGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gKG1ha2Ugc3VyZSBpdHMgYWRkZWQgdG8gdGhlIHNjZW5lISlcbiAgICogQHBhcmFtIHNjYWxlIC0gVGhlIHNjYWxlIG9mIHRoZSBkaXNwbGFjZW1lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwcml0ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXNrTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gITEsIHN1cGVyKHZlcnRleCwgZnJhZ21lbnQsIHtcbiAgICAgIG1hcFNhbXBsZXI6IHNwcml0ZS5fdGV4dHVyZSxcbiAgICAgIGZpbHRlck1hdHJpeDogbWFza01hdHJpeCxcbiAgICAgIHNjYWxlOiB7IHg6IDEsIHk6IDEgfSxcbiAgICAgIHJvdGF0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAxXSlcbiAgICB9KSwgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlLCB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4LCBzY2FsZSA9PSBudWxsICYmIChzY2FsZSA9IDIwKSwgdGhpcy5zY2FsZSA9IG5ldyBQb2ludChzY2FsZSwgc2NhbGUpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIG1hbmFnZXIuXG4gICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCB0YXJnZXQuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBUaGUgb3V0cHV0IHRhcmdldC5cbiAgICogQHBhcmFtIGNsZWFyTW9kZSAtIGNsZWFyTW9kZS5cbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZmlsdGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCB0aGlzLm1hc2tTcHJpdGUpLCB0aGlzLnVuaWZvcm1zLnNjYWxlLnggPSB0aGlzLnNjYWxlLngsIHRoaXMudW5pZm9ybXMuc2NhbGUueSA9IHRoaXMuc2NhbGUueTtcbiAgICBjb25zdCB3dCA9IHRoaXMubWFza1Nwcml0ZS53b3JsZFRyYW5zZm9ybSwgbGVuWCA9IE1hdGguc3FydCh3dC5hICogd3QuYSArIHd0LmIgKiB3dC5iKSwgbGVuWSA9IE1hdGguc3FydCh3dC5jICogd3QuYyArIHd0LmQgKiB3dC5kKTtcbiAgICBsZW5YICE9PSAwICYmIGxlblkgIT09IDAgJiYgKHRoaXMudW5pZm9ybXMucm90YXRpb25bMF0gPSB3dC5hIC8gbGVuWCwgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsxXSA9IHd0LmIgLyBsZW5YLCB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzJdID0gd3QuYyAvIGxlblksIHRoaXMudW5pZm9ybXMucm90YXRpb25bM10gPSB3dC5kIC8gbGVuWSksIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICAvKiogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIE11c3QgYmUgcG93ZXIgb2YgMiBzaXplZCB0ZXh0dXJlLiAqL1xuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXI7XG4gIH1cbiAgc2V0IG1hcCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlciA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQge1xuICBEaXNwbGFjZW1lbnRGaWx0ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXNwbGFjZW1lbnRGaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRGlzcGxhY2VtZW50RmlsdGVyIH0gZnJvbSBcIi4vRGlzcGxhY2VtZW50RmlsdGVyLm1qc1wiO1xuZXhwb3J0IHtcbiAgRGlzcGxhY2VtZW50RmlsdGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2X3JnYk5XO1xudmFyeWluZyB2ZWMyIHZfcmdiTkU7XG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xudmFyeWluZyB2ZWMyIHZfcmdiTTtcblxudmFyeWluZyB2ZWMyIHZGcmFnQ29vcmQ7XG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gaGlnaHAgdmVjNCBpbnB1dFNpemU7XG5cblxuLyoqXG4gQmFzaWMgRlhBQSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSB3aXRoIHRoZVxuIG1vZGlmaWNhdGlvbiB0aGF0IHRoZSB0ZXh0dXJlMkRMb2Qgc3R1ZmYgd2FzIHJlbW92ZWQgc2luY2UgaXQnc1xuIHVuc3VwcG9ydGVkIGJ5IFdlYkdMLlxuXG4gLS1cblxuIEZyb206XG4gaHR0cHM6Ly9naXRodWIuY29tL21pdHN1aGlrby93ZWJnbC1tZWluY3JhZnRcblxuIENvcHlyaWdodCAoYykgMjAxMSBieSBBcm1pbiBSb25hY2hlci5cblxuIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuIG1ldDpcblxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICogVGhlIG5hbWVzIG9mIHRoZSBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3JcbiBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcbiBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbiNpZm5kZWYgRlhBQV9SRURVQ0VfTUlOXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxuI2VuZGlmXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01VTFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgICAoMS4wIC8gOC4wKVxuI2VuZGlmXG4jaWZuZGVmIEZYQUFfU1BBTl9NQVhcbiNkZWZpbmUgRlhBQV9TUEFOX01BWCAgICAgOC4wXG4jZW5kaWZcblxuLy9vcHRpbWl6ZWQgdmVyc2lvbiBmb3IgbW9iaWxlLCB3aGVyZSBkZXBlbmRlbnRcbi8vdGV4dHVyZSByZWFkcyBjYW4gYmUgYSBib3R0bGVuZWNrXG52ZWM0IGZ4YWEoc2FtcGxlcjJEIHRleCwgdmVjMiBmcmFnQ29vcmQsIHZlYzIgaW52ZXJzZVZQLFxuICAgICAgICAgIHZlYzIgdl9yZ2JOVywgdmVjMiB2X3JnYk5FLFxuICAgICAgICAgIHZlYzIgdl9yZ2JTVywgdmVjMiB2X3JnYlNFLFxuICAgICAgICAgIHZlYzIgdl9yZ2JNKSB7XG4gICAgdmVjNCBjb2xvcjtcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JOVykueHl6O1xuICAgIHZlYzMgcmdiTkUgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5FKS54eXo7XG4gICAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU1cpLnh5ejtcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTRSkueHl6O1xuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk0pO1xuICAgIHZlYzMgcmdiTSAgPSB0ZXhDb2xvci54eXo7XG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcbiAgICBmbG9hdCBsdW1hTlcgPSBkb3QocmdiTlcsIGx1bWEpO1xuICAgIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcbiAgICBmbG9hdCBsdW1hU0UgPSBkb3QocmdiU0UsIGx1bWEpO1xuICAgIGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcbiAgICBmbG9hdCBsdW1hTWF4ID0gbWF4KGx1bWFNLCBtYXgobWF4KGx1bWFOVywgbHVtYU5FKSwgbWF4KGx1bWFTVywgbHVtYVNFKSkpO1xuXG4gICAgbWVkaXVtcCB2ZWMyIGRpcjtcbiAgICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XG4gICAgZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xuXG4gICAgZmxvYXQgZGlyUmVkdWNlID0gbWF4KChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xuXG4gICAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XG4gICAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXG4gICAgICAgICAgICAgIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksXG4gICAgICAgICAgICAgICAgICBkaXIgKiByY3BEaXJNaW4pKSAqIGludmVyc2VWUDtcblxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcbiAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqIC0wLjUpLnh5eiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogMC41KS54eXopO1xuXG4gICAgZmxvYXQgbHVtYUIgPSBkb3QocmdiQiwgbHVtYSk7XG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgdGV4Q29sb3IuYSk7XG4gICAgZWxzZVxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQiwgdGV4Q29sb3IuYSk7XG4gICAgcmV0dXJuIGNvbG9yO1xufVxuXG52b2lkIG1haW4oKSB7XG5cbiAgICAgIHZlYzQgY29sb3I7XG5cbiAgICAgIGNvbG9yID0gZnhhYSh1U2FtcGxlciwgdkZyYWdDb29yZCwgaW5wdXRTaXplLnp3LCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xuXG4gICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbn1cbmA7XG5leHBvcnQge1xuICBmcmFnbWVudCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnhhYS5mcmFnLm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBgXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xudmFyeWluZyB2ZWMyIHZfcmdiU1c7XG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcbnZhcnlpbmcgdmVjMiB2X3JnYk07XG5cbnZhcnlpbmcgdmVjMiB2RnJhZ0Nvb3JkO1xuXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xuXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcbntcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcblxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbn1cblxudm9pZCB0ZXhjb29yZHModmVjMiBmcmFnQ29vcmQsIHZlYzIgaW52ZXJzZVZQLFxuICAgICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JOVywgb3V0IHZlYzIgdl9yZ2JORSxcbiAgICAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiU1csIG91dCB2ZWMyIHZfcmdiU0UsXG4gICAgICAgICAgICAgICBvdXQgdmVjMiB2X3JnYk0pIHtcbiAgICB2X3JnYk5XID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xuICAgIHZfcmdiTkUgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIC0xLjApKSAqIGludmVyc2VWUDtcbiAgICB2X3JnYlNXID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XG4gICAgdl9yZ2JTRSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XG4gICAgdl9yZ2JNID0gdmVjMihmcmFnQ29vcmQgKiBpbnZlcnNlVlApO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuXG4gICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XG5cbiAgIHZGcmFnQ29vcmQgPSBhVmVydGV4UG9zaXRpb24gKiBvdXRwdXRGcmFtZS56dztcblxuICAgdGV4Y29vcmRzKHZGcmFnQ29vcmQsIGlucHV0U2l6ZS56dywgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcbn1cbmA7XG5leHBvcnQge1xuICB2ZXJ0ZXggYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ4YWEudmVydC5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gXCIuL2Z4YWEuZnJhZy5tanNcIjtcbmltcG9ydCB2ZXJ0ZXggZnJvbSBcIi4vZnhhYS52ZXJ0Lm1qc1wiO1xuY2xhc3MgRlhBQUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHZlcnRleCwgZnJhZ21lbnQpO1xuICB9XG59XG5leHBvcnQge1xuICBGWEFBRmlsdGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RlhBQUZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBGWEFBRmlsdGVyIH0gZnJvbSBcIi4vRlhBQUZpbHRlci5tanNcIjtcbmV4cG9ydCB7XG4gIEZYQUFGaWx0ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbnVuaWZvcm0gZmxvYXQgdU5vaXNlO1xudW5pZm9ybSBmbG9hdCB1U2VlZDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG5mbG9hdCByYW5kKHZlYzIgY28pXG57XG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XG59XG5cbnZvaWQgbWFpbigpXG57XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgZmxvYXQgcmFuZG9tVmFsdWUgPSByYW5kKGdsX0ZyYWdDb29yZC54eSAqIHVTZWVkKTtcbiAgICBmbG9hdCBkaWZmID0gKHJhbmRvbVZhbHVlIC0gMC41KSAqIHVOb2lzZTtcblxuICAgIC8vIFVuLXByZW11bHRpcGx5IGFscGhhIGJlZm9yZSBhcHBseWluZyB0aGUgY29sb3IgbWF0cml4LiBTZWUgaXNzdWUgIzM1MzkuXG4gICAgaWYgKGNvbG9yLmEgPiAwLjApIHtcbiAgICAgICAgY29sb3IucmdiIC89IGNvbG9yLmE7XG4gICAgfVxuXG4gICAgY29sb3IuciArPSBkaWZmO1xuICAgIGNvbG9yLmcgKz0gZGlmZjtcbiAgICBjb2xvci5iICs9IGRpZmY7XG5cbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cbiAgICBjb2xvci5yZ2IgKj0gY29sb3IuYTtcblxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xufVxuYDtcbmV4cG9ydCB7XG4gIGZyYWdtZW50IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2lzZS5mcmFnLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVmYXVsdEZpbHRlclZlcnRleCB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSBcIi4vbm9pc2UuZnJhZy5tanNcIjtcbmNsYXNzIE5vaXNlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9pc2U9MC41XSAtIFRoZSBub2lzZSBpbnRlbnNpdHksIHNob3VsZCBiZSBhIG5vcm1hbGl6ZWQgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCAxXS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWVkXSAtIEEgcmFuZG9tIHNlZWQgZm9yIHRoZSBub2lzZSBnZW5lcmF0aW9uLiBEZWZhdWx0IGlzIGBNYXRoLnJhbmRvbSgpYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5vaXNlID0gMC41LCBzZWVkID0gTWF0aC5yYW5kb20oKSkge1xuICAgIHN1cGVyKGRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIGZyYWdtZW50LCB7XG4gICAgICB1Tm9pc2U6IDAsXG4gICAgICB1U2VlZDogMFxuICAgIH0pLCB0aGlzLm5vaXNlID0gbm9pc2UsIHRoaXMuc2VlZCA9IHNlZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygbm9pc2UgdG8gYXBwbHksIHRoaXMgdmFsdWUgc2hvdWxkIGJlIGluIHRoZSByYW5nZSAoMCwgMV0uXG4gICAqIEBkZWZhdWx0IDAuNVxuICAgKi9cbiAgZ2V0IG5vaXNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVOb2lzZTtcbiAgfVxuICBzZXQgbm9pc2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVOb2lzZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBBIHNlZWQgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIHJhbmRvbSBub2lzZSBnZW5lcmF0aW9uLiBgTWF0aC5yYW5kb20oKWAgaXMgYSBnb29kIHZhbHVlIHRvIHVzZS4gKi9cbiAgZ2V0IHNlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNlZWQ7XG4gIH1cbiAgc2V0IHNlZWQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTZWVkID0gdmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIE5vaXNlRmlsdGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9pc2VGaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTm9pc2VGaWx0ZXIgfSBmcm9tIFwiLi9Ob2lzZUZpbHRlci5tanNcIjtcbmV4cG9ydCB7XG4gIE5vaXNlRmlsdGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQWxwaGFGaWx0ZXIgfSBmcm9tIFwiQHBpeGkvZmlsdGVyLWFscGhhXCI7XG5pbXBvcnQgeyBCbHVyRmlsdGVyLCBCbHVyRmlsdGVyUGFzcyB9IGZyb20gXCJAcGl4aS9maWx0ZXItYmx1clwiO1xuaW1wb3J0IHsgQ29sb3JNYXRyaXhGaWx0ZXIgfSBmcm9tIFwiQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeFwiO1xuaW1wb3J0IHsgRGlzcGxhY2VtZW50RmlsdGVyIH0gZnJvbSBcIkBwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnRcIjtcbmltcG9ydCB7IEZYQUFGaWx0ZXIgfSBmcm9tIFwiQHBpeGkvZmlsdGVyLWZ4YWFcIjtcbmltcG9ydCB7IE5vaXNlRmlsdGVyIH0gZnJvbSBcIkBwaXhpL2ZpbHRlci1ub2lzZVwiO1xuY29uc3QgZmlsdGVycyA9IHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5BbHBoYUZpbHRlclxuICAgKi9cbiAgQWxwaGFGaWx0ZXIsXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuQmx1ckZpbHRlclxuICAgKi9cbiAgQmx1ckZpbHRlcixcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CbHVyRmlsdGVyUGFzc1xuICAgKi9cbiAgQmx1ckZpbHRlclBhc3MsXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuQ29sb3JNYXRyaXhGaWx0ZXJcbiAgICovXG4gIENvbG9yTWF0cml4RmlsdGVyLFxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLkRpc3BsYWNlbWVudEZpbHRlclxuICAgKi9cbiAgRGlzcGxhY2VtZW50RmlsdGVyLFxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLkZYQUFGaWx0ZXJcbiAgICovXG4gIEZYQUFGaWx0ZXIsXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuTm9pc2VGaWx0ZXJcbiAgICovXG4gIE5vaXNlRmlsdGVyXG59O1xuT2JqZWN0LmVudHJpZXMoZmlsdGVycykuZm9yRWFjaCgoW2tleSwgRmlsdGVyQ2xhc3NdKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWx0ZXJzLCBrZXksIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBgZmlsdGVycy4ke2tleX0gaGFzIG1vdmVkIHRvICR7a2V5fWApLCBGaWx0ZXJDbGFzcztcbiAgICB9XG4gIH0pO1xufSk7XG5leHBvcnQge1xuICBmaWx0ZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5tanMubWFwXG4iLCJpbXBvcnQgeyBUaWNrZXIsIFVQREFURV9QUklPUklUWSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jbGFzcyBFdmVudHNUaWNrZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgPSAxMCwgdGhpcy5fZGVsdGFUaW1lID0gMCwgdGhpcy5fZGlkTW92ZSA9ICExLCB0aGlzLnRpY2tlckFkZGVkID0gITEsIHRoaXMuX3BhdXNlVXBkYXRlID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBldmVudCB0aWNrZXIuXG4gICAqIEBwYXJhbSBldmVudHMgLSBUaGUgZXZlbnQgc3lzdGVtLlxuICAgKi9cbiAgaW5pdChldmVudHMpIHtcbiAgICB0aGlzLnJlbW92ZVRpY2tlckxpc3RlbmVyKCksIHRoaXMuZXZlbnRzID0gZXZlbnRzLCB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTAsIHRoaXMuX2RlbHRhVGltZSA9IDAsIHRoaXMuX2RpZE1vdmUgPSAhMSwgdGhpcy50aWNrZXJBZGRlZCA9ICExLCB0aGlzLl9wYXVzZVVwZGF0ZSA9ICEwO1xuICB9XG4gIC8qKiBXaGV0aGVyIHRvIHBhdXNlIHRoZSB1cGRhdGUgY2hlY2tzIG9yIG5vdC4gKi9cbiAgZ2V0IHBhdXNlVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZVVwZGF0ZTtcbiAgfVxuICBzZXQgcGF1c2VVcGRhdGUocGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSBwYXVzZWQ7XG4gIH1cbiAgLyoqIEFkZHMgdGhlIHRpY2tlciBsaXN0ZW5lci4gKi9cbiAgYWRkVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgdGhpcy50aWNrZXJBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50IHx8IChUaWNrZXIuc3lzdGVtLmFkZCh0aGlzLnRpY2tlclVwZGF0ZSwgdGhpcywgVVBEQVRFX1BSSU9SSVRZLklOVEVSQUNUSU9OKSwgdGhpcy50aWNrZXJBZGRlZCA9ICEwKTtcbiAgfVxuICAvKiogUmVtb3ZlcyB0aGUgdGlja2VyIGxpc3RlbmVyLiAqL1xuICByZW1vdmVUaWNrZXJMaXN0ZW5lcigpIHtcbiAgICB0aGlzLnRpY2tlckFkZGVkICYmIChUaWNrZXIuc3lzdGVtLnJlbW92ZSh0aGlzLnRpY2tlclVwZGF0ZSwgdGhpcyksIHRoaXMudGlja2VyQWRkZWQgPSAhMSk7XG4gIH1cbiAgLyoqIFNldHMgZmxhZyB0byBub3QgZmlyZSBleHRyYSBldmVudHMgd2hlbiB0aGUgdXNlciBoYXMgYWxyZWFkeSBtb3ZlZCB0aGVyZSBtb3VzZSAqL1xuICBwb2ludGVyTW92ZWQoKSB7XG4gICAgdGhpcy5fZGlkTW92ZSA9ICEwO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzLiAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbUVsZW1lbnQgfHwgdGhpcy5fcGF1c2VVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2RpZE1vdmUpIHtcbiAgICAgIHRoaXMuX2RpZE1vdmUgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdFBvaW50ZXJFdmVudCA9IHRoaXMuZXZlbnRzLnJvb3RQb2ludGVyRXZlbnQ7XG4gICAgdGhpcy5ldmVudHMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiByb290UG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgZ2xvYmFsVGhpcy5kb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVybW92ZVwiLCB7XG4gICAgICBjbGllbnRYOiByb290UG9pbnRlckV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiByb290UG9pbnRlckV2ZW50LmNsaWVudFlcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIGludGVyYWN0aXZlIG9iamVjdHMgaWYgYXQgbGVhc3Qge0BsaW5rIFBJWEkuRXZlbnRzVGlja2VyI2ludGVyYWN0aW9uRnJlcXVlbmN5fVxuICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBwYXNzZWQgc2luY2UgdGhlIGxhc3QgaW52b2NhdGlvbi5cbiAgICpcbiAgICogSW52b2tlZCBieSBhIHRocm90dGxlZCB0aWNrZXIgdXBkYXRlIGZyb20ge0BsaW5rIFBJWEkuVGlja2VyLnN5c3RlbX0uXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSB0aW1lIGRlbHRhIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAgICovXG4gIHRpY2tlclVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICB0aGlzLl9kZWx0YVRpbWUgKz0gZGVsdGFUaW1lLCAhKHRoaXMuX2RlbHRhVGltZSA8IHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kpICYmICh0aGlzLl9kZWx0YVRpbWUgPSAwLCB0aGlzLnVwZGF0ZSgpKTtcbiAgfVxufVxuY29uc3QgRXZlbnRzVGlja2VyID0gbmV3IEV2ZW50c1RpY2tlckNsYXNzKCk7XG5leHBvcnQge1xuICBFdmVudHNUaWNrZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFRpY2tlci5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jbGFzcyBGZWRlcmF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbWFuYWdlciAtIFRoZSBldmVudCBib3VuZGFyeSB3aGljaCBtYW5hZ2VzIHRoaXMgZXZlbnQuIFByb3BhZ2F0aW9uIGNhbiBvbmx5IG9jY3VyXG4gICAqICB3aXRoaW4gdGhlIGJvdW5kYXJ5J3MganVyaXNkaWN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHRoaXMuYnViYmxlcyA9ICEwLCB0aGlzLmNhbmNlbEJ1YmJsZSA9ICEwLCB0aGlzLmNhbmNlbGFibGUgPSAhMSwgdGhpcy5jb21wb3NlZCA9ICExLCB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMSwgdGhpcy5ldmVudFBoYXNlID0gRmVkZXJhdGVkRXZlbnQucHJvdG90eXBlLk5PTkUsIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gITEsIHRoaXMucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSAhMSwgdGhpcy5sYXllciA9IG5ldyBQb2ludCgpLCB0aGlzLnBhZ2UgPSBuZXcgUG9pbnQoKSwgdGhpcy5OT05FID0gMCwgdGhpcy5DQVBUVVJJTkdfUEhBU0UgPSAxLCB0aGlzLkFUX1RBUkdFVCA9IDIsIHRoaXMuQlVCQkxJTkdfUEhBU0UgPSAzLCB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGxheWVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGxheWVyWSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IHBhZ2VYKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UueDtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBwYWdlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnk7XG4gIH1cbiAgLyoqXG4gICAqIEZhbGxiYWNrIGZvciB0aGUgZGVwcmVjYXRlZCBAY29kZXtQSVhJLkludGVyYWN0aW9uRXZlbnQuZGF0YX0uXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMC4wXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogVGhlIHByb3BhZ2F0aW9uIHBhdGggZm9yIHRoaXMgZXZlbnQuIEFsaWFzIGZvciB7QGxpbmsgUElYSS5FdmVudEJvdW5kYXJ5LnByb3BhZ2F0aW9uUGF0aH0uICovXG4gIGNvbXBvc2VkUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VyICYmICghdGhpcy5wYXRoIHx8IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0gIT09IHRoaXMudGFyZ2V0KSAmJiAodGhpcy5wYXRoID0gdGhpcy50YXJnZXQgPyB0aGlzLm1hbmFnZXIucHJvcGFnYXRpb25QYXRoKHRoaXMudGFyZ2V0KSA6IFtdKSwgdGhpcy5wYXRoO1xuICB9XG4gIC8qKlxuICAgKiBVbmltcGxlbWVudGVkIG1ldGhvZCBpbmNsdWRlZCBmb3IgaW1wbGVtZW50aW5nIHRoZSBET00gaW50ZXJmYWNlIHtAY29kZSBFdmVudH0uIEl0IHdpbGwgdGhyb3cgYW4ge0Bjb2RlIEVycm9yfS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIF90eXBlXG4gICAqIEBwYXJhbSBfYnViYmxlc1xuICAgKiBAcGFyYW0gX2NhbmNlbGFibGVcbiAgICovXG4gIGluaXRFdmVudChfdHlwZSwgX2J1YmJsZXMsIF9jYW5jZWxhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5pdEV2ZW50KCkgaXMgYSBsZWdhY3kgRE9NIEFQSS4gSXQgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSS5cIik7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW1wbGVtZW50ZWQgbWV0aG9kIGluY2x1ZGVkIGZvciBpbXBsZW1lbnRpbmcgdGhlIERPTSBpbnRlcmZhY2Uge0Bjb2RlIFVJRXZlbnR9LiBJdCB3aWxsIHRocm93IGFuIHtAY29kZSBFcnJvcn0uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBfdHlwZUFyZ1xuICAgKiBAcGFyYW0gX2J1YmJsZXNBcmdcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlQXJnXG4gICAqIEBwYXJhbSBfdmlld0FyZ1xuICAgKiBAcGFyYW0gX2RldGFpbEFyZ1xuICAgKi9cbiAgaW5pdFVJRXZlbnQoX3R5cGVBcmcsIF9idWJibGVzQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0VUlFdmVudCgpIGlzIGEgbGVnYWN5IERPTSBBUEkuIEl0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuXCIpO1xuICB9XG4gIC8qKiBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgUGl4aUpTIGFuZCB0aGUgdXNlciBhZ2VudC4gKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5uYXRpdmVFdmVudCBpbnN0YW5jZW9mIEV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuY2FuY2VsYWJsZSAmJiB0aGlzLm5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCksIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIHRoaXMgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byBhbnkgYWRkaXRpb24gbGlzdGVuZXJzLCBpbmNsdWRpbmcgb24gdGhlXG4gICAqIHtAbGluayBQSVhJLkZlZGVyYXRlZEV2ZW50VGFyZ2V0LmN1cnJlbnRUYXJnZXQgY3VycmVudFRhcmdldH0gYW5kIGFsc28gdGhlIGZvbGxvd2luZ1xuICAgKiBldmVudCB0YXJnZXRzIG9uIHRoZSBwcm9wYWdhdGlvbiBwYXRoLlxuICAgKi9cbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGlzIGV2ZW50IGZyb20gcHJvcGFnYXRpbmcgdG8gdGhlIG5leHQge0BsaW5rIFBJWEkuRmVkZXJhdGVkRXZlbnRUYXJnZXR9LiBUaGUgcmVzdCBvZiB0aGUgbGlzdGVuZXJzXG4gICAqIG9uIHRoZSB7QGxpbmsgUElYSS5GZWRlcmF0ZWRFdmVudFRhcmdldC5jdXJyZW50VGFyZ2V0IGN1cnJlbnRUYXJnZXR9IHdpbGwgc3RpbGwgYmUgbm90aWZpZWQuXG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSAhMDtcbiAgfVxufVxuZXhwb3J0IHtcbiAgRmVkZXJhdGVkRXZlbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBGZWRlcmF0ZWRFdmVudCB9IGZyb20gXCIuL0ZlZGVyYXRlZEV2ZW50Lm1qc1wiO1xuY2xhc3MgRmVkZXJhdGVkTW91c2VFdmVudCBleHRlbmRzIEZlZGVyYXRlZEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5jbGllbnQgPSBuZXcgUG9pbnQoKSwgdGhpcy5tb3ZlbWVudCA9IG5ldyBQb2ludCgpLCB0aGlzLm9mZnNldCA9IG5ldyBQb2ludCgpLCB0aGlzLmdsb2JhbCA9IG5ldyBQb2ludCgpLCB0aGlzLnNjcmVlbiA9IG5ldyBQb2ludCgpO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGNsaWVudFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgY2xpZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQueTtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBQSVhJLkZlZGVyYXRlZE1vdXNlRXZlbnQuY2xpZW50WCB0aGlzLmNsaWVudFh9LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFg7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgUElYSS5GZWRlcmF0ZWRNb3VzZUV2ZW50LmNsaWVudFkgdGhpcy5jbGllbnRZfS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRZO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG9mZnNldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgb2Zmc2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBnbG9iYWxYKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGdsb2JhbFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIHtAY29kZSBzY3JlZW4ueH0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIHtAY29kZSBzY3JlZW4ueX0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgZGlzcGxheU9iamVjdCBmb3IgdGhpcyBJbnRlcmFjdGlvbkRhdGFcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSBUaGUgRGlzcGxheU9iamVjdCB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSBsb2NhbFxuICAgKiAgY29vcmRzIG9mZlxuICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50RGF0YX0gcG9pbnQgLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsIChvdGhlcndpc2VcbiAgICogIHdpbGwgY3JlYXRlIGEgbmV3IHBvaW50KVxuICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50RGF0YX0gZ2xvYmFsUG9zIC0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB5b3VyIGN1c3RvbSBnbG9iYWwgY29vcmRzLCBvcHRpb25hbFxuICAgKiAgKG90aGVyd2lzZSB3aWxsIHVzZSB0aGUgY3VycmVudCBnbG9iYWwgY29vcmRzKVxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIEludGVyYWN0aW9uRGF0YSBwb3NpdGlvbiByZWxhdGl2ZVxuICAgKiAgdG8gdGhlIERpc3BsYXlPYmplY3RcbiAgICovXG4gIGdldExvY2FsUG9zaXRpb24oZGlzcGxheU9iamVjdCwgcG9pbnQsIGdsb2JhbFBvcykge1xuICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciB0aGUgbW9kaWZpZXIga2V5IHdhcyBwcmVzc2VkIHdoZW4gdGhpcyBldmVudCBuYXRpdmVseSBvY2N1cnJlZC5cbiAgICogQHBhcmFtIGtleSAtIFRoZSBtb2RpZmllciBrZXkuXG4gICAqL1xuICBnZXRNb2RpZmllclN0YXRlKGtleSkge1xuICAgIHJldHVybiBcImdldE1vZGlmaWVyU3RhdGVcIiBpbiB0aGlzLm5hdGl2ZUV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBOb3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0gX3R5cGVBcmdcbiAgICogQHBhcmFtIF9jYW5CdWJibGVBcmdcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlQXJnXG4gICAqIEBwYXJhbSBfdmlld0FyZ1xuICAgKiBAcGFyYW0gX2RldGFpbEFyZ1xuICAgKiBAcGFyYW0gX3NjcmVlblhBcmdcbiAgICogQHBhcmFtIF9zY3JlZW5ZQXJnXG4gICAqIEBwYXJhbSBfY2xpZW50WEFyZ1xuICAgKiBAcGFyYW0gX2NsaWVudFlBcmdcbiAgICogQHBhcmFtIF9jdHJsS2V5QXJnXG4gICAqIEBwYXJhbSBfYWx0S2V5QXJnXG4gICAqIEBwYXJhbSBfc2hpZnRLZXlBcmdcbiAgICogQHBhcmFtIF9tZXRhS2V5QXJnXG4gICAqIEBwYXJhbSBfYnV0dG9uQXJnXG4gICAqIEBwYXJhbSBfcmVsYXRlZFRhcmdldEFyZ1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgaW5pdE1vdXNlRXZlbnQoX3R5cGVBcmcsIF9jYW5CdWJibGVBcmcsIF9jYW5jZWxhYmxlQXJnLCBfdmlld0FyZywgX2RldGFpbEFyZywgX3NjcmVlblhBcmcsIF9zY3JlZW5ZQXJnLCBfY2xpZW50WEFyZywgX2NsaWVudFlBcmcsIF9jdHJsS2V5QXJnLCBfYWx0S2V5QXJnLCBfc2hpZnRLZXlBcmcsIF9tZXRhS2V5QXJnLCBfYnV0dG9uQXJnLCBfcmVsYXRlZFRhcmdldEFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG59XG5leHBvcnQge1xuICBGZWRlcmF0ZWRNb3VzZUV2ZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkTW91c2VFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSBcIi4vRmVkZXJhdGVkTW91c2VFdmVudC5tanNcIjtcbmNsYXNzIEZlZGVyYXRlZFBvaW50ZXJFdmVudCBleHRlbmRzIEZlZGVyYXRlZE1vdXNlRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLndpZHRoID0gMCwgdGhpcy5oZWlnaHQgPSAwLCB0aGlzLmlzUHJpbWFyeSA9ICExO1xuICB9XG4gIC8vIE9ubHkgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcyBmb3Igbm93XG4gIGdldENvYWxlc2NlZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBcInBvaW50ZXJtb3ZlXCIgfHwgdGhpcy50eXBlID09PSBcIm1vdXNlbW92ZVwiIHx8IHRoaXMudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiA/IFt0aGlzXSA6IFtdO1xuICB9XG4gIC8vIE9ubHkgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcyBmb3Igbm93XG4gIGdldFByZWRpY3RlZEV2ZW50cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRQcmVkaWN0ZWRFdmVudHMgaXMgbm90IHN1cHBvcnRlZCFcIik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEZlZGVyYXRlZFBvaW50ZXJFdmVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSBcIi4vRmVkZXJhdGVkTW91c2VFdmVudC5tanNcIjtcbmNsYXNzIEZlZGVyYXRlZFdoZWVsRXZlbnQgZXh0ZW5kcyBGZWRlcmF0ZWRNb3VzZUV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5ET01fREVMVEFfUElYRUwgPSAwLCB0aGlzLkRPTV9ERUxUQV9MSU5FID0gMSwgdGhpcy5ET01fREVMVEFfUEFHRSA9IDI7XG4gIH1cbn1cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMID0gMCwgLyoqIFVuaXRzIHNwZWNpZmllZCBpbiBsaW5lcy4gKi9cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPSAxLCAvKiogVW5pdHMgc3BlY2lmaWVkIGluIHBhZ2VzLiAqL1xuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfUEFHRSA9IDI7XG5leHBvcnQge1xuICBGZWRlcmF0ZWRXaGVlbEV2ZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkV2hlZWxFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCwgdXRpbHMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgRXZlbnRzVGlja2VyIH0gZnJvbSBcIi4vRXZlbnRUaWNrZXIubWpzXCI7XG5pbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSBcIi4vRmVkZXJhdGVkTW91c2VFdmVudC5tanNcIjtcbmltcG9ydCB7IEZlZGVyYXRlZFBvaW50ZXJFdmVudCB9IGZyb20gXCIuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanNcIjtcbmltcG9ydCB7IEZlZGVyYXRlZFdoZWVsRXZlbnQgfSBmcm9tIFwiLi9GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qc1wiO1xuY29uc3QgUFJPUEFHQVRJT05fTElNSVQgPSAyMDQ4LCB0ZW1wSGl0TG9jYXRpb24gPSBuZXcgUG9pbnQoKSwgdGVtcExvY2FsTWFwcGluZyA9IG5ldyBQb2ludCgpO1xuY2xhc3MgRXZlbnRCb3VuZGFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcm9vdFRhcmdldCAtIFRoZSBob2xkZXIgb2YgdGhlIGV2ZW50IGJvdW5kYXJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdFRhcmdldCkge1xuICAgIHRoaXMuZGlzcGF0Y2ggPSBuZXcgdXRpbHMuRXZlbnRFbWl0dGVyKCksIHRoaXMubW92ZU9uQWxsID0gITEsIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9ICEwLCB0aGlzLm1hcHBpbmdTdGF0ZSA9IHtcbiAgICAgIHRyYWNraW5nRGF0YToge31cbiAgICB9LCB0aGlzLmV2ZW50UG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMgPSBbXSwgdGhpcy5faGl0RWxlbWVudHMgPSBbXSwgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gITEsIHRoaXMucm9vdFRhcmdldCA9IHJvb3RUYXJnZXQsIHRoaXMuaGl0UHJ1bmVGbiA9IHRoaXMuaGl0UHJ1bmVGbi5iaW5kKHRoaXMpLCB0aGlzLmhpdFRlc3RGbiA9IHRoaXMuaGl0VGVzdEZuLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlckRvd24gPSB0aGlzLm1hcFBvaW50ZXJEb3duLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlck1vdmUgPSB0aGlzLm1hcFBvaW50ZXJNb3ZlLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlck91dCA9IHRoaXMubWFwUG9pbnRlck91dC5iaW5kKHRoaXMpLCB0aGlzLm1hcFBvaW50ZXJPdmVyID0gdGhpcy5tYXBQb2ludGVyT3Zlci5iaW5kKHRoaXMpLCB0aGlzLm1hcFBvaW50ZXJVcCA9IHRoaXMubWFwUG9pbnRlclVwLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZSA9IHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZS5iaW5kKHRoaXMpLCB0aGlzLm1hcFdoZWVsID0gdGhpcy5tYXBXaGVlbC5iaW5kKHRoaXMpLCB0aGlzLm1hcHBpbmdUYWJsZSA9IHt9LCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJkb3duXCIsIHRoaXMubWFwUG9pbnRlckRvd24pLCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJtb3ZlXCIsIHRoaXMubWFwUG9pbnRlck1vdmUpLCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJvdXRcIiwgdGhpcy5tYXBQb2ludGVyT3V0KSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5tYXBQb2ludGVyT3V0KSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVyb3ZlclwiLCB0aGlzLm1hcFBvaW50ZXJPdmVyKSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVydXBcIiwgdGhpcy5tYXBQb2ludGVyVXApLCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJ1cG91dHNpZGVcIiwgdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlKSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJ3aGVlbFwiLCB0aGlzLm1hcFdoZWVsKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBtYXBwaW5nIGZvciB0aGUgZXZlbnQgYHR5cGVgIGhhbmRsZWQgYnkgYGZuYC5cbiAgICpcbiAgICogRXZlbnQgbWFwcGluZ3MgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGFkZGl0aW9uYWwgb3IgY3VzdG9tIGV2ZW50cy4gVGhleSB0YWtlIGFuIGV2ZW50XG4gICAqIGNvbWluZyBmcm9tIHRoZSB1cHN0cmVhbSBzY2VuZSAob3IgZGlyZWN0bHkgZnJvbSB0aGUge0BsaW5rIFBJWEkuRXZlbnRTeXN0ZW19KSBhbmQgZGlzcGF0Y2ggbmV3IGRvd25zdHJlYW0gZXZlbnRzXG4gICAqIGdlbmVyYWxseSB0cmlja2xpbmcgZG93biBhbmQgYnViYmxpbmcgdXAgdG8ge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0uXG4gICAqXG4gICAqIFRvIG1vZGlmeSB0aGUgc2VtYW50aWNzIG9mIGV4aXN0aW5nIGV2ZW50cywgdGhlIGJ1aWx0LWluIG1hcHBpbmcgbWV0aG9kcyBvZiBFdmVudEJvdW5kYXJ5IHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAqIGluc3RlYWQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdXBzdHJlYW0gZXZlbnQgdG8gbWFwLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbWFwcGluZyBtZXRob2QuIFRoZSBjb250ZXh0IG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBib3VuZCBtYW51YWxseSwgaWYgZGVzaXJlZC5cbiAgICovXG4gIGFkZEV2ZW50TWFwcGluZyh0eXBlLCBmbikge1xuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdIHx8ICh0aGlzLm1hcHBpbmdUYWJsZVt0eXBlXSA9IFtdKSwgdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0ucHVzaCh7XG4gICAgICBmbixcbiAgICAgIHByaW9yaXR5OiAwXG4gICAgfSksIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgZ2l2ZW4gZXZlbnRcbiAgICogQHBhcmFtIGVcbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZSwgdHlwZSkge1xuICAgIGUucHJvcGFnYXRpb25TdG9wcGVkID0gITEsIGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSAhMSwgdGhpcy5wcm9wYWdhdGUoZSwgdHlwZSksIHRoaXMuZGlzcGF0Y2guZW1pdCh0eXBlIHx8IGUudHlwZSwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIGdpdmVuIHVwc3RyZWFtIGV2ZW50IHRocm91Z2ggdGhlIGV2ZW50IGJvdW5kYXJ5IGFuZCBwcm9wYWdhdGVzIGl0IGRvd25zdHJlYW0uXG4gICAqIEBwYXJhbSBlXG4gICAqL1xuICBtYXBFdmVudChlKSB7XG4gICAgaWYgKCF0aGlzLnJvb3RUYXJnZXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbWFwcGVycyA9IHRoaXMubWFwcGluZ1RhYmxlW2UudHlwZV07XG4gICAgaWYgKG1hcHBlcnMpXG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IG1hcHBlcnMubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICBtYXBwZXJzW2ldLmZuKGUpO1xuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUud2FybihgW0V2ZW50Qm91bmRhcnldOiBFdmVudCBtYXBwaW5nIG5vdCBkZWZpbmVkIGZvciAke2UudHlwZX1gKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIERpc3BsYXlPYmplY3QgdGhhdCBpcyB0aGUgdGFyZ2V0IG9mIGEgZXZlbnQgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBUaGUgcGFzc2VkICh4LHkpIGNvb3JkaW5hdGVzIGFyZSBpbiB0aGUgd29ybGQgc3BhY2UgYWJvdmUgdGhpcyBldmVudCBib3VuZGFyeS5cbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHlcbiAgICovXG4gIGhpdFRlc3QoeCwgeSkge1xuICAgIEV2ZW50c1RpY2tlci5wYXVzZVVwZGF0ZSA9ICEwO1xuICAgIGNvbnN0IGZuID0gdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ICYmIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA/IFwiaGl0VGVzdE1vdmVSZWN1cnNpdmVcIiA6IFwiaGl0VGVzdFJlY3Vyc2l2ZVwiLCBpbnZlcnRlZFBhdGggPSB0aGlzW2ZuXShcbiAgICAgIHRoaXMucm9vdFRhcmdldCxcbiAgICAgIHRoaXMucm9vdFRhcmdldC5ldmVudE1vZGUsXG4gICAgICB0ZW1wSGl0TG9jYXRpb24uc2V0KHgsIHkpLFxuICAgICAgdGhpcy5oaXRUZXN0Rm4sXG4gICAgICB0aGlzLmhpdFBydW5lRm5cbiAgICApO1xuICAgIHJldHVybiBpbnZlcnRlZFBhdGggJiYgaW52ZXJ0ZWRQYXRoWzBdO1xuICB9XG4gIC8qKlxuICAgKiBQcm9wYWdhdGUgdGhlIHBhc3NlZCBldmVudCBmcm9tIGZyb20ge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0gdG8gaXRzXG4gICAqIHRhcmdldCB7QGNvZGUgZS50YXJnZXR9LlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCB0byBwcm9wYWdhdGUuXG4gICAqIEBwYXJhbSB0eXBlXG4gICAqL1xuICBwcm9wYWdhdGUoZSwgdHlwZSkge1xuICAgIGlmICghZS50YXJnZXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29tcG9zZWRQYXRoID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkNBUFRVUklOR19QSEFTRTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGNvbXBvc2VkUGF0aC5sZW5ndGggLSAxOyBpIDwgajsgaSsrKVxuICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9IGNvbXBvc2VkUGF0aFtpXSwgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSksIGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZS5ldmVudFBoYXNlID0gZS5BVF9UQVJHRVQsIGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKSwgIShlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKSkge1xuICAgICAgZS5ldmVudFBoYXNlID0gZS5CVUJCTElOR19QSEFTRTtcbiAgICAgIGZvciAobGV0IGkgPSBjb21wb3NlZFBhdGgubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbaV0sIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpLCBlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBldmVudCB7QGNvZGUgZX0gdG8gYWxsIGludGVyYWN0aXZlIGRpc3BsYXkgb2JqZWN0cy4gVGhlIGV2ZW50IGlzIHByb3BhZ2F0ZWQgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlIGFsd2F5cy5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBgZ2xvYmFscG9pbnRlcm1vdmVgIGV2ZW50LlxuICAgKiBAcGFyYW0gZSAtIFRoZSBlbWl0dGVkIGV2ZW50LlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBsaXN0ZW5lcnMgdG8gbm90aWZ5LlxuICAgKiBAcGFyYW0gdGFyZ2V0cyAtIFRoZSB0YXJnZXRzIHRvIG5vdGlmeS5cbiAgICovXG4gIGFsbChlLCB0eXBlLCB0YXJnZXRzID0gdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cykge1xuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkJVQkJMSU5HX1BIQVNFO1xuICAgIGNvbnN0IGV2ZW50cyA9IEFycmF5LmlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IHRhcmdldHNbaV0sIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGV2ZW50KTtcbiAgICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgcHJvcGFnYXRpb24gcGF0aCBmcm9tIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fSB0byB0aGUgcGFzc2VkXG4gICAqIHtAY29kZSB0YXJnZXR9LiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHtAY29kZSB0YXJnZXR9LlxuICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAqL1xuICBwcm9wYWdhdGlvblBhdGgodGFyZ2V0KSB7XG4gICAgY29uc3QgcHJvcGFnYXRpb25QYXRoID0gW3RhcmdldF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9QQUdBVElPTl9MSU1JVCAmJiB0YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldDsgaSsrKSB7XG4gICAgICBpZiAoIXRhcmdldC5wYXJlbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHByb3BhZ2F0aW9uIHBhdGggdG8gZGlzY29ubmVjdGVkIHRhcmdldFwiKTtcbiAgICAgIHByb3BhZ2F0aW9uUGF0aC5wdXNoKHRhcmdldC5wYXJlbnQpLCB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGFnYXRpb25QYXRoLnJldmVyc2UoKSwgcHJvcGFnYXRpb25QYXRoO1xuICB9XG4gIGhpdFRlc3RNb3ZlUmVjdXJzaXZlKGN1cnJlbnRUYXJnZXQsIGV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbiwgaWdub3JlID0gITEpIHtcbiAgICBsZXQgc2hvdWxkUmV0dXJuID0gITE7XG4gICAgaWYgKHRoaXMuX2ludGVyYWN0aXZlUHJ1bmUoY3VycmVudFRhcmdldCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoKGN1cnJlbnRUYXJnZXQuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIiB8fCBldmVudE1vZGUgPT09IFwiZHluYW1pY1wiKSAmJiAoRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gITEpLCBjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0sIG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdE1vdmVSZWN1cnNpdmUoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpID8gZXZlbnRNb2RlIDogY2hpbGQuZXZlbnRNb2RlLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIHRlc3RGbixcbiAgICAgICAgICBwcnVuZUZuLFxuICAgICAgICAgIGlnbm9yZSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKVxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSkgJiYgKGlzSW50ZXJhY3RpdmUgJiYgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5wdXNoKGN1cnJlbnRUYXJnZXQpLCBuZXN0ZWRIaXQucHVzaChjdXJyZW50VGFyZ2V0KSksIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5faGl0RWxlbWVudHMgPSBuZXN0ZWRIaXQpLCBzaG91bGRSZXR1cm4gPSAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0ludGVyYWN0aXZlTW9kZSA9IHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSwgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIHJldHVybiBpc0ludGVyYWN0aXZlTW9kZSAmJiBpc0ludGVyYWN0aXZlVGFyZ2V0ICYmIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMucHVzaChjdXJyZW50VGFyZ2V0KSwgaWdub3JlIHx8IHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA+IDAgPyBudWxsIDogc2hvdWxkUmV0dXJuID8gdGhpcy5faGl0RWxlbWVudHMgOiBpc0ludGVyYWN0aXZlTW9kZSAmJiAhcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSA/IGlzSW50ZXJhY3RpdmVUYXJnZXQgPyBbY3VycmVudFRhcmdldF0gOiBbXSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeS5oaXRUZXN0IGhpdFRlc3R9LlxuICAgKiBAcGFyYW0gY3VycmVudFRhcmdldCAtIFRoZSBEaXNwbGF5T2JqZWN0IHRoYXQgaXMgdG8gYmUgaGl0IHRlc3RlZC5cbiAgICogQHBhcmFtIGV2ZW50TW9kZSAtIFRoZSBldmVudCBtb2RlIGZvciB0aGUgYGN1cnJlbnRUYXJnZXRgIG9yIG9uZSBvZiBpdHMgcGFyZW50cy5cbiAgICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRoYXQgaXMgYmVpbmcgdGVzdGVkIGZvciBvdmVybGFwLlxuICAgKiBAcGFyYW0gdGVzdEZuIC0gQ2FsbGJhY2sgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRhcmdldCBwYXNzZXMgaGl0IHRlc3RpbmcuIFRoaXMgY2FsbGJhY2tcbiAgICogIGNhbiBhc3N1bWUgdGhhdCBgcHJ1bmVGbmAgZmFpbGVkIHRvIHBydW5lIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICogQHBhcmFtIHBydW5lRm4gLSBDYWxsYmFjayB0aGF0IGRldGVybWluZXNzIHdoZXRoZXIgdGhlIHRhcmdldCBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlblxuICAgKiAgY2Fubm90IHBhc3MgdGhlIGhpdCB0ZXN0LiBJdCBpcyB1c2VkIGFzIGEgcHJlbGltaW5hcnkgb3B0aW1pemF0aW9uIHRvIHBydW5lIGVudGlyZSBzdWJ0cmVlc1xuICAgKiAgb2YgdGhlIHNjZW5lIGdyYXBoLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBob2xkaW5nIHRoZSBoaXQgdGVzdGluZyB0YXJnZXQgYW5kIGFsbCBpdHMgYW5jZXN0b3JzIGluIG9yZGVyLiBUaGUgZmlyc3QgZWxlbWVudFxuICAgKiAgaXMgdGhlIHRhcmdldCBpdHNlbGYgYW5kIHRoZSBsYXN0IGlzIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fS4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcbiAgICogIG9yZGVyIHcuci50LiB0aGUgcHJvcGFnYXRpb24gcGF0aC4gSWYgbm8gaGl0IHRlc3RpbmcgdGFyZ2V0IGlzIGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuICAgKi9cbiAgaGl0VGVzdFJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4pIHtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICgoY3VycmVudFRhcmdldC5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiIHx8IGV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIpICYmIChFdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSAhMSksIGN1cnJlbnRUYXJnZXQuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRUYXJnZXQuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXSwgbmVzdGVkSGl0ID0gdGhpcy5oaXRUZXN0UmVjdXJzaXZlKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSA/IGV2ZW50TW9kZSA6IGNoaWxkLmV2ZW50TW9kZSxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICB0ZXN0Rm4sXG4gICAgICAgICAgcHJ1bmVGblxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICByZXR1cm4gKG5lc3RlZEhpdC5sZW5ndGggPiAwIHx8IGlzSW50ZXJhY3RpdmUpICYmIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpLCBuZXN0ZWRIaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSksIGlzSW50ZXJhY3RpdmVUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZU1vZGUgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSA/IGlzSW50ZXJhY3RpdmVUYXJnZXQgPyBbY3VycmVudFRhcmdldF0gOiBbXSA6IG51bGw7XG4gIH1cbiAgX2lzSW50ZXJhY3RpdmUoaW50KSB7XG4gICAgcmV0dXJuIGludCA9PT0gXCJzdGF0aWNcIiB8fCBpbnQgPT09IFwiZHluYW1pY1wiO1xuICB9XG4gIF9pbnRlcmFjdGl2ZVBydW5lKGRpc3BsYXlPYmplY3QpIHtcbiAgICByZXR1cm4gISEoIWRpc3BsYXlPYmplY3QgfHwgZGlzcGxheU9iamVjdC5pc01hc2sgfHwgIWRpc3BsYXlPYmplY3QudmlzaWJsZSB8fCAhZGlzcGxheU9iamVjdC5yZW5kZXJhYmxlIHx8IGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcIm5vbmVcIiB8fCBkaXNwbGF5T2JqZWN0LmV2ZW50TW9kZSA9PT0gXCJwYXNzaXZlXCIgJiYgIWRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmVDaGlsZHJlbiB8fCBkaXNwbGF5T2JqZWN0LmlzTWFzayk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBvciBhbnkgb2YgaXRzIGNoaWxkcmVuIGNhbm5vdCBwYXNzIHRoZSBoaXQgdGVzdCBhdCBhbGwuXG4gICAqXG4gICAqIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnl9J3MgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUge0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdC5oaXRBcmVhIGhpdEFyZWF9XG4gICAqIGFuZCB7QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0Ll9tYXNrfSBmb3IgcHJ1bmluZy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqL1xuICBoaXRQcnVuZUZuKGRpc3BsYXlPYmplY3QsIGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuaGl0QXJlYSAmJiAoZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UobG9jYXRpb24sIHRlbXBMb2NhbE1hcHBpbmcpLCAhZGlzcGxheU9iamVjdC5oaXRBcmVhLmNvbnRhaW5zKHRlbXBMb2NhbE1hcHBpbmcueCwgdGVtcExvY2FsTWFwcGluZy55KSkpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2tPYmplY3QgPSBkaXNwbGF5T2JqZWN0Ll9tYXNrLmlzTWFza0RhdGEgPyBkaXNwbGF5T2JqZWN0Ll9tYXNrLm1hc2tPYmplY3QgOiBkaXNwbGF5T2JqZWN0Ll9tYXNrO1xuICAgICAgaWYgKG1hc2tPYmplY3QgJiYgIW1hc2tPYmplY3QuY29udGFpbnNQb2ludD8uKGxvY2F0aW9uKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBwYXNzZXMgaGl0IHRlc3RpbmcgZm9yIHRoZSBnaXZlbiBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciBgZGlzcGxheU9iamVjdGAgcGFzc2VzIGhpdCB0ZXN0aW5nIGZvciBgbG9jYXRpb25gLlxuICAgKi9cbiAgaGl0VGVzdEZuKGRpc3BsYXlPYmplY3QsIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcInBhc3NpdmVcIiA/ICExIDogZGlzcGxheU9iamVjdC5oaXRBcmVhID8gITAgOiBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQgPyBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQobG9jYXRpb24pIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgdGhlIGxpc3RlbmVycyB0byB0aGUgZXZlbnQncyBgY3VycmVudFRhcmdldGAuXG4gICAqXG4gICAqIElmIHRoZSBgY3VycmVudFRhcmdldGAgY29udGFpbnMgdGhlIHByb3BlcnR5IGBvbjx0eXBlPmAsIHRoZW4gaXQgaXMgY2FsbGVkIGhlcmUsXG4gICAqIHNpbXVsYXRpbmcgdGhlIGJlaGF2aW9yIGZyb20gdmVyc2lvbiA2LnggYW5kIHByaW9yLlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCBwYXNzZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIG5vdGlmeVRhcmdldChlLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgPz8gZS50eXBlO1xuICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBgb24ke3R5cGV9YDtcbiAgICBlLmN1cnJlbnRUYXJnZXRbaGFuZGxlcktleV0/LihlKTtcbiAgICBjb25zdCBrZXkgPSBlLmV2ZW50UGhhc2UgPT09IGUuQ0FQVFVSSU5HX1BIQVNFIHx8IGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQgPyBgJHt0eXBlfWNhcHR1cmVgIDogdHlwZTtcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhlLCBrZXkpLCBlLmV2ZW50UGhhc2UgPT09IGUuQVRfVEFSR0VUICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcmRvd25gIGV2ZW50cyB0byBhIGRvd25zdHJlYW0gYHBvaW50ZXJkb3duYCBldmVudC5cbiAgICpcbiAgICogYHRvdWNoc3RhcnRgLCBgcmlnaHRkb3duYCwgYG1vdXNlZG93bmAgZXZlbnRzIGFyZSBhbHNvIGRpc3BhdGNoZWQgZm9yIHNwZWNpZmljIHBvaW50ZXIgdHlwZXMuXG4gICAqIEBwYXJhbSBmcm9tXG4gICAqL1xuICBtYXBQb2ludGVyRG93bihmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJwb2ludGVyZG93blwiKSwgZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hzdGFydFwiKTtcbiAgICBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIikge1xuICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0ZG93blwiIDogXCJtb3VzZWRvd25cIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dID0gZS5jb21wb3NlZFBhdGgoKSwgdGhpcy5mcmVlRXZlbnQoZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIHVwc3RyZWFtIGBwb2ludGVybW92ZWAgdG8gZG93bnN0cmVhbSBgcG9pbnRlcm91dGAsIGBwb2ludGVyb3ZlcmAsIGFuZCBgcG9pbnRlcm1vdmVgIGV2ZW50cywgaW4gdGhhdCBvcmRlci5cbiAgICpcbiAgICogVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGhhcyBhbiB1cGRhdGVkIGBvdmVyVGFyZ2V0YC4gYG1vdXNlb3V0YCwgYG1vdXNlb3ZlcmAsXG4gICAqIGBtb3VzZW1vdmVgLCBhbmQgYHRvdWNobW92ZWAgZXZlbnRzIGFyZSBmaXJlZCBhcyB3ZWxsIGZvciBzcGVjaWZpYyBwb2ludGVyIHR5cGVzLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICAgKi9cbiAgbWFwUG9pbnRlck1vdmUoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMubGVuZ3RoID0gMCwgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID0gMCwgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gITA7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIHRoaXMuX2lzUG9pbnRlck1vdmVFdmVudCA9ICExO1xuICAgIGNvbnN0IGlzTW91c2UgPSBlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiwgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpLCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cz8ubGVuZ3RoID4gMCAmJiBvdXRUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICBjb25zdCBvdXRUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW91dFwiIDogXCJwb2ludGVyb3V0XCIsIG91dEV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgb3V0VHlwZSwgb3V0VGFyZ2V0KTtcbiAgICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwicG9pbnRlcm91dFwiKSwgaXNNb3VzZSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIiksICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG91dFRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgbGVhdmVFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcmxlYXZlXCIsIG91dFRhcmdldCk7XG4gICAgICAgIGZvciAobGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7IGxlYXZlRXZlbnQudGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGxlYXZlRXZlbnQudGFyZ2V0KTsgKVxuICAgICAgICAgIGxlYXZlRXZlbnQuY3VycmVudFRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KSwgaXNNb3VzZSAmJiB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50LCBcIm1vdXNlbGVhdmVcIiksIGxlYXZlRXZlbnQudGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQucGFyZW50O1xuICAgICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG91dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG92ZXJUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW92ZXJcIiA6IFwicG9pbnRlcm92ZXJcIiwgb3ZlckV2ZW50ID0gdGhpcy5jbG9uZVBvaW50ZXJFdmVudChlLCBvdmVyVHlwZSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3ZlckV2ZW50LCBcInBvaW50ZXJvdmVyXCIpLCBpc01vdXNlICYmIHRoaXMuZGlzcGF0Y2hFdmVudChvdmVyRXZlbnQsIFwibW91c2VvdmVyXCIpO1xuICAgICAgbGV0IG92ZXJUYXJnZXRBbmNlc3RvciA9IG91dFRhcmdldD8ucGFyZW50O1xuICAgICAgZm9yICg7IG92ZXJUYXJnZXRBbmNlc3RvciAmJiBvdmVyVGFyZ2V0QW5jZXN0b3IgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQgJiYgb3ZlclRhcmdldEFuY2VzdG9yICE9PSBlLnRhcmdldDsgKVxuICAgICAgICBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdmVyVGFyZ2V0QW5jZXN0b3IucGFyZW50O1xuICAgICAgaWYgKCFvdmVyVGFyZ2V0QW5jZXN0b3IgfHwgb3ZlclRhcmdldEFuY2VzdG9yID09PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGVudGVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwicG9pbnRlcmVudGVyXCIpO1xuICAgICAgICBmb3IgKGVudGVyRXZlbnQuZXZlbnRQaGFzZSA9IGVudGVyRXZlbnQuQVRfVEFSR0VUOyBlbnRlckV2ZW50LnRhcmdldCAmJiBlbnRlckV2ZW50LnRhcmdldCAhPT0gb3V0VGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50OyApXG4gICAgICAgICAgZW50ZXJFdmVudC5jdXJyZW50VGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQsIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQpLCBpc01vdXNlICYmIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKSwgZW50ZXJFdmVudC50YXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgICAgIHRoaXMuZnJlZUV2ZW50KGVudGVyRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmVlRXZlbnQob3ZlckV2ZW50KTtcbiAgICB9XG4gICAgY29uc3QgYWxsTWV0aG9kcyA9IFtdLCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgPSB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPz8gITA7XG4gICAgdGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnB1c2goXCJwb2ludGVybW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJtb3ZlXCIpLCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFscG9pbnRlcm1vdmVcIiksIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiAmJiAodGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcInRvdWNobW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNobW92ZVwiKSwgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbHRvdWNobW92ZVwiKSksIGlzTW91c2UgJiYgKHRoaXMubW92ZU9uQWxsID8gYWxsTWV0aG9kcy5zcGxpY2UoMSwgMCwgXCJtb3VzZW1vdmVcIikgOiB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJtb3VzZW1vdmVcIiksIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWxtb3VzZW1vdmVcIiksIHRoaXMuY3Vyc29yID0gZS50YXJnZXQ/LmN1cnNvciksIGFsbE1ldGhvZHMubGVuZ3RoID4gMCAmJiB0aGlzLmFsbChlLCBhbGxNZXRob2RzKSwgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5sZW5ndGggPSAwLCB0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPSAwLCB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpLCB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJvdmVyYCB0byBkb3duc3RyZWFtIGBwb2ludGVyb3ZlcmAgYW5kIGBwb2ludGVyZW50ZXJgIGV2ZW50cywgaW4gdGhhdCBvcmRlci5cbiAgICpcbiAgICogVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGdldHMgYSBuZXcgYG92ZXJUYXJnZXRgLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcm92ZXJgIGV2ZW50LlxuICAgKi9cbiAgbWFwUG9pbnRlck92ZXIoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKSwgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pLCBpc01vdXNlID0gZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCI7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm92ZXJcIiksIGlzTW91c2UgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwibW91c2VvdmVyXCIpLCBlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgJiYgKHRoaXMuY3Vyc29yID0gZS50YXJnZXQ/LmN1cnNvcik7XG4gICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgZm9yIChlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDsgZW50ZXJFdmVudC50YXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7IClcbiAgICAgIGVudGVyRXZlbnQuY3VycmVudFRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KSwgaXNNb3VzZSAmJiB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50LCBcIm1vdXNlZW50ZXJcIiksIGVudGVyRXZlbnQudGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQucGFyZW50O1xuICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IGUuY29tcG9zZWRQYXRoKCksIHRoaXMuZnJlZUV2ZW50KGUpLCB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJvdXRgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdXRgLCBgcG9pbnRlcmxlYXZlYCBldmVudHMsIGluIHRoYXQgb3JkZXIuXG4gICAqXG4gICAqIFRoZSB0cmFja2luZyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgcG9pbnRlciBpcyBjbGVhcmVkIG9mIGEgYG92ZXJUYXJnZXRgLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcm91dGAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyT3V0KGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cykge1xuICAgICAgY29uc3QgaXNNb3VzZSA9IGZyb20ucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBmcm9tLnBvaW50ZXJUeXBlID09PSBcInBlblwiLCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyksIG91dEV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVyb3V0XCIsIG91dFRhcmdldCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQpLCBpc01vdXNlICYmIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCwgXCJtb3VzZW91dFwiKTtcbiAgICAgIGNvbnN0IGxlYXZlRXZlbnQgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCBcInBvaW50ZXJsZWF2ZVwiLCBvdXRUYXJnZXQpO1xuICAgICAgZm9yIChsZWF2ZUV2ZW50LmV2ZW50UGhhc2UgPSBsZWF2ZUV2ZW50LkFUX1RBUkdFVDsgbGVhdmVFdmVudC50YXJnZXQgJiYgbGVhdmVFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7IClcbiAgICAgICAgbGVhdmVFdmVudC5jdXJyZW50VGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQsIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQpLCBpc01vdXNlICYmIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKSwgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBudWxsLCB0aGlzLmZyZWVFdmVudChvdXRFdmVudCksIHRoaXMuZnJlZUV2ZW50KGxlYXZlRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIHVwc3RyZWFtIGBwb2ludGVydXBgIGV2ZW50IHRvIGRvd25zdHJlYW0gYHBvaW50ZXJ1cGAsIGBwb2ludGVydXBvdXRzaWRlYCxcbiAgICogYW5kIGBjbGlja2AvYHJpZ2h0Y2xpY2tgL2Bwb2ludGVydGFwYCBldmVudHMsIGluIHRoYXQgb3JkZXIuXG4gICAqXG4gICAqIFRoZSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQgYnViYmxlcyBmcm9tIHRoZSBvcmlnaW5hbCBgcG9pbnRlcmRvd25gIHRhcmdldCB0byB0aGUgbW9zdCBzcGVjaWZpY1xuICAgKiBhbmNlc3RvciBvZiB0aGUgYHBvaW50ZXJkb3duYCBhbmQgYHBvaW50ZXJ1cGAgdGFyZ2V0cywgd2hpY2ggaXMgYWxzbyB0aGUgYGNsaWNrYCBldmVudCdzIHRhcmdldC4gYHRvdWNoZW5kYCxcbiAgICogYHJpZ2h0dXBgLCBgbW91c2V1cGAsIGB0b3VjaGVuZG91dHNpZGVgLCBgcmlnaHR1cG91dHNpZGVgLCBgbW91c2V1cG91dHNpZGVgLCBhbmQgYHRhcGAgYXJlIGZpcmVkIGFzIHdlbGwgZm9yXG4gICAqIHNwZWNpZmljIHBvaW50ZXIgdHlwZXMuXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIGBwb2ludGVydXBgIGV2ZW50LlxuICAgKi9cbiAgbWFwUG9pbnRlclVwKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKSwgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJwb2ludGVydXBcIiksIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNoZW5kXCIpO1xuICAgIGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHR1cFwiIDogXCJtb3VzZXVwXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCksIHByZXNzVGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICBsZXQgY2xpY2tUYXJnZXQgPSBwcmVzc1RhcmdldDtcbiAgICBpZiAocHJlc3NUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMocHJlc3NUYXJnZXQpKSB7XG4gICAgICBsZXQgY3VycmVudFRhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgZm9yICg7IGN1cnJlbnRUYXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMoY3VycmVudFRhcmdldCk7ICkge1xuICAgICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldCwgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJwb2ludGVydXBvdXRzaWRlXCIpLCBlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpXG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJ0b3VjaGVuZG91dHNpZGVcIik7XG4gICAgICAgIGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0dXBvdXRzaWRlXCIgOiBcIm1vdXNldXBvdXRzaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dLCBjbGlja1RhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChjbGlja1RhcmdldCkge1xuICAgICAgY29uc3QgY2xpY2tFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJjbGlja1wiKTtcbiAgICAgIGNsaWNrRXZlbnQudGFyZ2V0ID0gY2xpY2tUYXJnZXQsIGNsaWNrRXZlbnQucGF0aCA9IG51bGwsIHRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gfHwgKHRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSB7XG4gICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgIHRhcmdldDogY2xpY2tFdmVudC50YXJnZXQsXG4gICAgICAgIHRpbWVTdGFtcDogbm93XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNsaWNrSGlzdG9yeSA9IHRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgICBpZiAoY2xpY2tIaXN0b3J5LnRhcmdldCA9PT0gY2xpY2tFdmVudC50YXJnZXQgJiYgbm93IC0gY2xpY2tIaXN0b3J5LnRpbWVTdGFtcCA8IDIwMCA/ICsrY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQgOiBjbGlja0hpc3RvcnkuY2xpY2tDb3VudCA9IDEsIGNsaWNrSGlzdG9yeS50YXJnZXQgPSBjbGlja0V2ZW50LnRhcmdldCwgY2xpY2tIaXN0b3J5LnRpbWVTdGFtcCA9IG5vdywgY2xpY2tFdmVudC5kZXRhaWwgPSBjbGlja0hpc3RvcnkuY2xpY2tDb3VudCwgY2xpY2tFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBjbGlja0V2ZW50LmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0Y2xpY2tcIiA6IFwiY2xpY2tcIik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY2xpY2tFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiICYmIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBcInRhcFwiKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBcInBvaW50ZXJ0YXBcIiksIHRoaXMuZnJlZUV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJ1cG91dHNpZGVgIGV2ZW50IHRvIGEgZG93bnN0cmVhbSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQsIGJ1YmJsaW5nIGZyb20gdGhlIG9yaWdpbmFsXG4gICAqIGBwb2ludGVyZG93bmAgdGFyZ2V0IHRvIGByb290VGFyZ2V0YC5cbiAgICpcbiAgICogKFRoZSBtb3N0IHNwZWNpZmljIGFuY2VzdG9yIG9mIHRoZSBgcG9pbnRlcmRvd25gIGV2ZW50IGFuZCB0aGUgYHBvaW50ZXJ1cGAgZXZlbnQgbXVzdCB0aGVcbiAgICogYHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnl9J3Mgcm9vdCBiZWNhdXNlIHRoZSBgcG9pbnRlcnVwYCBldmVudCBvY2N1cnJlZCBvdXRzaWRlIG9mIHRoZSBib3VuZGFyeS4pXG4gICAqXG4gICAqIGB0b3VjaGVuZG91dHNpZGVgLCBgbW91c2V1cG91dHNpZGVgLCBhbmQgYHJpZ2h0dXBvdXRzaWRlYCBldmVudHMgYXJlIGZpcmVkIGFzIHdlbGwgZm9yIHNwZWNpZmljIHBvaW50ZXJcbiAgICogdHlwZXMuIFRoZSB0cmFja2luZyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgcG9pbnRlciBpcyBjbGVhcmVkIG9mIGEgYHByZXNzVGFyZ2V0YC5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHBvaW50ZXJ1cG91dHNpZGVgIGV2ZW50LlxuICAgKi9cbiAgbWFwUG9pbnRlclVwT3V0c2lkZShmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpLCBwcmVzc1RhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSksIGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICBpZiAocHJlc3NUYXJnZXQpIHtcbiAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICBmb3IgKDsgY3VycmVudFRhcmdldDsgKVxuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlLCBcInBvaW50ZXJ1cG91dHNpZGVcIiksIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiA/IHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwidG91Y2hlbmRvdXRzaWRlXCIpIDogKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSAmJiB0aGlzLm5vdGlmeVRhcmdldChlLCBlLmJ1dHRvbiA9PT0gMiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIiksIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudDtcbiAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgIH1cbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHdoZWVsYCBldmVudCB0byBhIGRvd25zdHJlYW0gYHdoZWVsYCBldmVudC5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHdoZWVsYCBldmVudC5cbiAgICovXG4gIG1hcFdoZWVsKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkV2hlZWxFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi13aGVlbCBldmVudCBhcyBhIHdoZWVsIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aGVlbEV2ZW50ID0gdGhpcy5jcmVhdGVXaGVlbEV2ZW50KGZyb20pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh3aGVlbEV2ZW50KSwgdGhpcy5mcmVlRXZlbnQod2hlZWxFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBtb3N0IHNwZWNpZmljIGV2ZW50LXRhcmdldCBpbiB0aGUgZ2l2ZW4gcHJvcGFnYXRpb24gcGF0aCB0aGF0IGlzIHN0aWxsIG1vdW50ZWQgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZmluZCB0aGUgY29ycmVjdCBgcG9pbnRlcnVwYCBhbmQgYHBvaW50ZXJvdXRgIHRhcmdldCBpbiB0aGUgY2FzZSB0aGF0IHRoZSBvcmlnaW5hbCBgcG9pbnRlcmRvd25gXG4gICAqIG9yIGBwb2ludGVyb3ZlcmAgdGFyZ2V0IHdhcyB1bm1vdW50ZWQgZnJvbSB0aGUgc2NlbmUgZ3JhcGguXG4gICAqIEBwYXJhbSBwcm9wYWdhdGlvblBhdGggLSBUaGUgcHJvcGFnYXRpb24gcGF0aCB3YXMgdmFsaWQgaW4gdGhlIHBhc3QuXG4gICAqIEByZXR1cm5zIC0gVGhlIG1vc3Qgc3BlY2lmaWMgZXZlbnQtdGFyZ2V0IHN0aWxsIG1vdW50ZWQgYXQgdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIHNjZW5lIGdyYXBoLlxuICAgKi9cbiAgZmluZE1vdW50ZWRUYXJnZXQocHJvcGFnYXRpb25QYXRoKSB7XG4gICAgaWYgKCFwcm9wYWdhdGlvblBhdGgpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY3VycmVudFRhcmdldCA9IHByb3BhZ2F0aW9uUGF0aFswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BhZ2F0aW9uUGF0aC5sZW5ndGggJiYgcHJvcGFnYXRpb25QYXRoW2ldLnBhcmVudCA9PT0gY3VycmVudFRhcmdldDsgaSsrKVxuICAgICAgY3VycmVudFRhcmdldCA9IHByb3BhZ2F0aW9uUGF0aFtpXTtcbiAgICByZXR1cm4gY3VycmVudFRhcmdldDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBldmVudCB3aG9zZSB7QGNvZGUgb3JpZ2luYWxFdmVudH0gaXMge0Bjb2RlIGZyb219LCB3aXRoIGFuIG9wdGlvbmFsIGB0eXBlYCBhbmQgYHRhcmdldGAgb3ZlcnJpZGUuXG4gICAqXG4gICAqIFRoZSBldmVudCBpcyBhbGxvY2F0ZWQgdXNpbmcge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeSNhbGxvY2F0ZUV2ZW50IHRoaXMuYWxsb2NhdGVFdmVudH0uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHtAY29kZSBvcmlnaW5hbEV2ZW50fSBmb3IgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gW3R5cGU9ZnJvbS50eXBlXSAtIFRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBldmVudC5cbiAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKi9cbiAgY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIHR5cGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29weVBvaW50ZXJEYXRhKGZyb20sIGV2ZW50KSwgdGhpcy5jb3B5TW91c2VEYXRhKGZyb20sIGV2ZW50KSwgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCksIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudCwgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20sIGV2ZW50LnRhcmdldCA9IHRhcmdldCA/PyB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KSA/PyB0aGlzLl9oaXRFbGVtZW50c1swXSwgdHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIiAmJiAoZXZlbnQudHlwZSA9IHR5cGUpLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdoZWVsIGV2ZW50IHdob3NlIHtAY29kZSBvcmlnaW5hbEV2ZW50fSBpcyB7QGNvZGUgZnJvbX0uXG4gICAqXG4gICAqIFRoZSBldmVudCBpcyBhbGxvY2F0ZWQgdXNpbmcge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeSNhbGxvY2F0ZUV2ZW50IHRoaXMuYWxsb2NhdGVFdmVudH0uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIHdoZWVsIGV2ZW50LlxuICAgKi9cbiAgY3JlYXRlV2hlZWxFdmVudChmcm9tKSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkV2hlZWxFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29weVdoZWVsRGF0YShmcm9tLCBldmVudCksIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCksIHRoaXMuY29weURhdGEoZnJvbSwgZXZlbnQpLCBldmVudC5uYXRpdmVFdmVudCA9IGZyb20ubmF0aXZlRXZlbnQsIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tLCBldmVudC50YXJnZXQgPSB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KSwgZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgZXZlbnQge0Bjb2RlIGZyb219LCB3aXRoIGFuIG9wdGlvbmFsIHtAY29kZSB0eXBlfSBvdmVycmlkZS5cbiAgICpcbiAgICogVGhlIGV2ZW50IGlzIGFsbG9jYXRlZCB1c2luZyB7QGxpbmsgUElYSS5FdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fS5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgZXZlbnQgdG8gY2xvbmUuXG4gICAqIEBwYXJhbSBbdHlwZT1mcm9tLnR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKi9cbiAgY2xvbmVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgcmV0dXJuIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudCwgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20ub3JpZ2luYWxFdmVudCwgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpLCB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpLCB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KSwgZXZlbnQudGFyZ2V0ID0gZnJvbS50YXJnZXQsIGV2ZW50LnBhdGggPSBmcm9tLmNvbXBvc2VkUGF0aCgpLnNsaWNlKCksIGV2ZW50LnR5cGUgPSB0eXBlID8/IGV2ZW50LnR5cGUsIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgd2hlZWwge0BsaW5rIFBJWEkuRmVkZXJhdGVkV2hlZWxFdmVudH0gZGF0YSBmcm9tIHtAY29kZSBmcm9tfSBpbnRvIHtAY29kZSB0b30uXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgY29waWVkOlxuICAgKiArIGRlbHRhTW9kZVxuICAgKiArIGRlbHRhWFxuICAgKiArIGRlbHRhWVxuICAgKiArIGRlbHRhWlxuICAgKiBAcGFyYW0gZnJvbVxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGNvcHlXaGVlbERhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5kZWx0YU1vZGUgPSBmcm9tLmRlbHRhTW9kZSwgdG8uZGVsdGFYID0gZnJvbS5kZWx0YVgsIHRvLmRlbHRhWSA9IGZyb20uZGVsdGFZLCB0by5kZWx0YVogPSBmcm9tLmRlbHRhWjtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHBvaW50ZXIge0BsaW5rIFBJWEkuRmVkZXJhdGVkUG9pbnRlckV2ZW50fSBkYXRhIGZyb20ge0Bjb2RlIGZyb219IGludG8ge0Bjb2RlIHRvfS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQ6XG4gICAqICsgcG9pbnRlcklkXG4gICAqICsgd2lkdGhcbiAgICogKyBoZWlnaHRcbiAgICogKyBpc1ByaW1hcnlcbiAgICogKyBwb2ludGVyVHlwZVxuICAgKiArIHByZXNzdXJlXG4gICAqICsgdGFuZ2VudGlhbFByZXNzdXJlXG4gICAqICsgdGlsdFhcbiAgICogKyB0aWx0WVxuICAgKiBAcGFyYW0gZnJvbVxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGNvcHlQb2ludGVyRGF0YShmcm9tLCB0bykge1xuICAgIGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgJiYgdG8gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgJiYgKHRvLnBvaW50ZXJJZCA9IGZyb20ucG9pbnRlcklkLCB0by53aWR0aCA9IGZyb20ud2lkdGgsIHRvLmhlaWdodCA9IGZyb20uaGVpZ2h0LCB0by5pc1ByaW1hcnkgPSBmcm9tLmlzUHJpbWFyeSwgdG8ucG9pbnRlclR5cGUgPSBmcm9tLnBvaW50ZXJUeXBlLCB0by5wcmVzc3VyZSA9IGZyb20ucHJlc3N1cmUsIHRvLnRhbmdlbnRpYWxQcmVzc3VyZSA9IGZyb20udGFuZ2VudGlhbFByZXNzdXJlLCB0by50aWx0WCA9IGZyb20udGlsdFgsIHRvLnRpbHRZID0gZnJvbS50aWx0WSwgdG8udHdpc3QgPSBmcm9tLnR3aXN0KTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIG1vdXNlIHtAbGluayBQSVhJLkZlZGVyYXRlZE1vdXNlRXZlbnR9IGRhdGEgZnJvbSB7QGNvZGUgZnJvbX0gdG8ge0Bjb2RlIHRvfS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQ6XG4gICAqICsgYWx0S2V5XG4gICAqICsgYnV0dG9uXG4gICAqICsgYnV0dG9uc1xuICAgKiArIGNsaWVudFhcbiAgICogKyBjbGllbnRZXG4gICAqICsgbWV0YUtleVxuICAgKiArIG1vdmVtZW50WFxuICAgKiArIG1vdmVtZW50WVxuICAgKiArIHBhZ2VYXG4gICAqICsgcGFnZVlcbiAgICogKyB4XG4gICAqICsgeVxuICAgKiArIHNjcmVlblxuICAgKiArIHNoaWZ0S2V5XG4gICAqICsgZ2xvYmFsXG4gICAqIEBwYXJhbSBmcm9tXG4gICAqIEBwYXJhbSB0b1xuICAgKi9cbiAgY29weU1vdXNlRGF0YShmcm9tLCB0bykge1xuICAgIGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkTW91c2VFdmVudCAmJiAodG8uYWx0S2V5ID0gZnJvbS5hbHRLZXksIHRvLmJ1dHRvbiA9IGZyb20uYnV0dG9uLCB0by5idXR0b25zID0gZnJvbS5idXR0b25zLCB0by5jbGllbnQuY29weUZyb20oZnJvbS5jbGllbnQpLCB0by5jdHJsS2V5ID0gZnJvbS5jdHJsS2V5LCB0by5tZXRhS2V5ID0gZnJvbS5tZXRhS2V5LCB0by5tb3ZlbWVudC5jb3B5RnJvbShmcm9tLm1vdmVtZW50KSwgdG8uc2NyZWVuLmNvcHlGcm9tKGZyb20uc2NyZWVuKSwgdG8uc2hpZnRLZXkgPSBmcm9tLnNoaWZ0S2V5LCB0by5nbG9iYWwuY29weUZyb20oZnJvbS5nbG9iYWwpKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGJhc2Uge0BsaW5rIFBJWEkuRmVkZXJhdGVkRXZlbnR9IGRhdGEgZnJvbSB7QGNvZGUgZnJvbX0gaW50byB7QGNvZGUgdG99LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBpc1RydXN0ZWRcbiAgICogKyBzcmNFbGVtZW50XG4gICAqICsgdGltZVN0YW1wXG4gICAqICsgdHlwZVxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjb3B5IGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIHRvIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBpbnRvLlxuICAgKi9cbiAgY29weURhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5pc1RydXN0ZWQgPSBmcm9tLmlzVHJ1c3RlZCwgdG8uc3JjRWxlbWVudCA9IGZyb20uc3JjRWxlbWVudCwgdG8udGltZVN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCksIHRvLnR5cGUgPSBmcm9tLnR5cGUsIHRvLmRldGFpbCA9IGZyb20uZGV0YWlsLCB0by52aWV3ID0gZnJvbS52aWV3LCB0by53aGljaCA9IGZyb20ud2hpY2gsIHRvLmxheWVyLmNvcHlGcm9tKGZyb20ubGF5ZXIpLCB0by5wYWdlLmNvcHlGcm9tKGZyb20ucGFnZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBwb2ludGVyIElELlxuICAgKiBAcmV0dXJucyBUaGUgdHJhY2tpbmcgZGF0YSBzdG9yZWQgZm9yIHRoZSBnaXZlbiBwb2ludGVyLiBJZiBubyBkYXRhIGV4aXN0cywgYSBibGFua1xuICAgKiAgc3RhdGUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdHJhY2tpbmdEYXRhKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0gfHwgKHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0gPSB7XG4gICAgICBwcmVzc1RhcmdldHNCeUJ1dHRvbjoge30sXG4gICAgICBjbGlja3NCeUJ1dHRvbjoge30sXG4gICAgICBvdmVyVGFyZ2V0OiBudWxsXG4gICAgfSksIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF07XG4gIH1cbiAgLyoqXG4gICAqIEFsbG9jYXRlIGEgc3BlY2lmaWMgdHlwZSBvZiBldmVudCBmcm9tIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkjZXZlbnRQb29sIHRoaXMuZXZlbnRQb29sfS5cbiAgICpcbiAgICogVGhpcyBhbGxvY2F0aW9uIGlzIGNvbnN0cnVjdG9yLWFnbm9zdGljLCBhcyBsb25nIGFzIGl0IG9ubHkgdGFrZXMgb25lIGFyZ3VtZW50IC0gdGhpcyBldmVudFxuICAgKiBib3VuZGFyeS5cbiAgICogQHBhcmFtIGNvbnN0cnVjdG9yIC0gVGhlIGV2ZW50J3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBhbGxvY2F0ZUV2ZW50KGNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5ldmVudFBvb2wuaGFzKGNvbnN0cnVjdG9yKSB8fCB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRQb29sLmdldChjb25zdHJ1Y3RvcikucG9wKCkgfHwgbmV3IGNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIHJldHVybiBldmVudC5ldmVudFBoYXNlID0gZXZlbnQuTk9ORSwgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGwsIGV2ZW50LnBhdGggPSBudWxsLCBldmVudC50YXJnZXQgPSBudWxsLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogRnJlZXMgdGhlIGV2ZW50IGFuZCBwdXRzIGl0IGJhY2sgaW50byB0aGUgZXZlbnQgcG9vbC5cbiAgICpcbiAgICogSXQgaXMgaWxsZWdhbCB0byByZXVzZSB0aGUgZXZlbnQgdW50aWwgaXQgaXMgYWxsb2NhdGVkIGFnYWluLCB1c2luZyBgdGhpcy5hbGxvY2F0ZUV2ZW50YC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBhZHZpc2VkIHRoYXQgZXZlbnRzIG5vdCBhbGxvY2F0ZWQgZnJvbSB7QGxpbmsgUElYSS5FdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fVxuICAgKiBub3QgYmUgZnJlZWQuIFRoaXMgaXMgYmVjYXVzZSBvZiB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgc2FtZSBldmVudCBpcyBmcmVlZCB0d2ljZSwgd2hpY2ggY2FuIGNhdXNlXG4gICAqIGl0IHRvIGJlIGFsbG9jYXRlZCB0d2ljZSAmIHJlc3VsdCBpbiBvdmVyd3JpdGluZy5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJlIGZyZWVkLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBldmVudCBpcyBtYW5hZ2VkIGJ5IGFub3RoZXIgZXZlbnQgYm91bmRhcnkuXG4gICAqL1xuICBmcmVlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQubWFuYWdlciAhPT0gdGhpcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGlzIGlsbGVnYWwgdG8gZnJlZSBhbiBldmVudCBub3QgbWFuYWdlZCBieSB0aGlzIEV2ZW50Qm91bmRhcnkhXCIpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZXZlbnQuY29uc3RydWN0b3I7XG4gICAgdGhpcy5ldmVudFBvb2wuaGFzKGNvbnN0cnVjdG9yKSB8fCB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKSwgdGhpcy5ldmVudFBvb2wuZ2V0KGNvbnN0cnVjdG9yKS5wdXNoKGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2ltaWxhciB0byB7QGxpbmsgUElYSS5FdmVudEVtaXR0ZXIuZW1pdH0sIGV4Y2VwdCBpdCBzdG9wcyBpZiB0aGUgYHByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkYCBmbGFnXG4gICAqIGlzIHNldCBvbiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50IHRvIGNhbGwgZWFjaCBsaXN0ZW5lciB3aXRoLlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBldmVudCBrZXkuXG4gICAqL1xuICBub3RpZnlMaXN0ZW5lcnMoZSwgdHlwZSkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGUuY3VycmVudFRhcmdldC5fZXZlbnRzW3R5cGVdO1xuICAgIGlmIChsaXN0ZW5lcnMgJiYgZS5jdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKSlcbiAgICAgIGlmIChcImZuXCIgaW4gbGlzdGVuZXJzKVxuICAgICAgICBsaXN0ZW5lcnMub25jZSAmJiBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzLmZuLCB2b2lkIDAsICEwKSwgbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGUpO1xuICAgICAgZWxzZVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBqICYmICFlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkOyBpKyspXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLm9uY2UgJiYgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXS5mbiwgdm9pZCAwLCAhMCksIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBlKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgRXZlbnRCb3VuZGFyeVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50Qm91bmRhcnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSBcIi4vRXZlbnRCb3VuZGFyeS5tanNcIjtcbmltcG9ydCB7IEV2ZW50c1RpY2tlciB9IGZyb20gXCIuL0V2ZW50VGlja2VyLm1qc1wiO1xuaW1wb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSBcIi4vRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qc1wiO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gXCIuL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzXCI7XG5jb25zdCBNT1VTRV9QT0lOVEVSX0lEID0gMSwgVE9VQ0hfVE9fUE9JTlRFUiA9IHtcbiAgdG91Y2hzdGFydDogXCJwb2ludGVyZG93blwiLFxuICB0b3VjaGVuZDogXCJwb2ludGVydXBcIixcbiAgdG91Y2hlbmRvdXRzaWRlOiBcInBvaW50ZXJ1cG91dHNpZGVcIixcbiAgdG91Y2htb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gIHRvdWNoY2FuY2VsOiBcInBvaW50ZXJjYW5jZWxcIlxufSwgX0V2ZW50U3lzdGVtID0gY2xhc3MgX0V2ZW50U3lzdGVtMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyA9IFwib250b3VjaHN0YXJ0XCIgaW4gZ2xvYmFsVGhpcywgdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIWdsb2JhbFRoaXMuUG9pbnRlckV2ZW50LCB0aGlzLmRvbUVsZW1lbnQgPSBudWxsLCB0aGlzLnJlc29sdXRpb24gPSAxLCB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMucm9vdEJvdW5kYXJ5ID0gbmV3IEV2ZW50Qm91bmRhcnkobnVsbCksIEV2ZW50c1RpY2tlci5pbml0KHRoaXMpLCB0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCA9ICEwLCB0aGlzLmV2ZW50c0FkZGVkID0gITEsIHRoaXMucm9vdFBvaW50ZXJFdmVudCA9IG5ldyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQobnVsbCksIHRoaXMucm9vdFdoZWVsRXZlbnQgPSBuZXcgRmVkZXJhdGVkV2hlZWxFdmVudChudWxsKSwgdGhpcy5jdXJzb3JTdHlsZXMgPSB7XG4gICAgICBkZWZhdWx0OiBcImluaGVyaXRcIixcbiAgICAgIHBvaW50ZXI6IFwicG9pbnRlclwiXG4gICAgfSwgdGhpcy5mZWF0dXJlcyA9IG5ldyBQcm94eSh7IC4uLl9FdmVudFN5c3RlbTIuZGVmYXVsdEV2ZW50RmVhdHVyZXMgfSwge1xuICAgICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiAoa2V5ID09PSBcImdsb2JhbE1vdmVcIiAmJiAodGhpcy5yb290Qm91bmRhcnkuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHZhbHVlKSwgdGFyZ2V0W2tleV0gPSB2YWx1ZSwgITApXG4gICAgfSksIHRoaXMub25Qb2ludGVyRG93biA9IHRoaXMub25Qb2ludGVyRG93bi5iaW5kKHRoaXMpLCB0aGlzLm9uUG9pbnRlck1vdmUgPSB0aGlzLm9uUG9pbnRlck1vdmUuYmluZCh0aGlzKSwgdGhpcy5vblBvaW50ZXJVcCA9IHRoaXMub25Qb2ludGVyVXAuYmluZCh0aGlzKSwgdGhpcy5vblBvaW50ZXJPdmVyT3V0ID0gdGhpcy5vblBvaW50ZXJPdmVyT3V0LmJpbmQodGhpcyksIHRoaXMub25XaGVlbCA9IHRoaXMub25XaGVlbC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlIGZvciBhbGwgZGlzcGxheSBvYmplY3RzLlxuICAgKiBAc2VlIFBJWEkuRGlzcGxheU9iamVjdC5ldmVudE1vZGVcbiAgICogQHR5cGUge1BJWEkuRXZlbnRNb2RlfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHNpbmNlIDcuMi4wXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRFdmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRFdmVudE1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJ1bm5lciBpbml0IGNhbGxlZCwgdmlldyBpcyBhdmFpbGFibGUgYXQgdGhpcyBwb2ludC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgY29uc3QgeyB2aWV3LCByZXNvbHV0aW9uIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh2aWV3KSwgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiwgX0V2ZW50U3lzdGVtMi5fZGVmYXVsdEV2ZW50TW9kZSA9IG9wdGlvbnMuZXZlbnRNb2RlID8/IFwiYXV0b1wiLCBPYmplY3QuYXNzaWduKHRoaXMuZmVhdHVyZXMsIG9wdGlvbnMuZXZlbnRGZWF0dXJlcyA/PyB7fSksIHRoaXMucm9vdEJvdW5kYXJ5LmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB0aGlzLmZlYXR1cmVzLmdsb2JhbE1vdmU7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2luZyByZXNvbHV0aW9uLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICByZXNvbHV0aW9uQ2hhbmdlKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBkZXRhY2hlcyB0aGUgcmVuZGVyZXIuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KG51bGwpLCB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBjdXJzb3IgbW9kZSwgaGFuZGxpbmcgYW55IGNhbGxiYWNrcyBvciBDU1Mgc3R5bGUgY2hhbmdlcy5cbiAgICogQHBhcmFtIG1vZGUgLSBjdXJzb3IgbW9kZSwgYSBrZXkgZnJvbSB0aGUgY3Vyc29yU3R5bGVzIGRpY3Rpb25hcnlcbiAgICovXG4gIHNldEN1cnNvcihtb2RlKSB7XG4gICAgbW9kZSA9IG1vZGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgbGV0IGFwcGx5U3R5bGVzID0gITA7XG4gICAgaWYgKGdsb2JhbFRoaXMuT2Zmc2NyZWVuQ2FudmFzICYmIHRoaXMuZG9tRWxlbWVudCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyAmJiAoYXBwbHlTdHlsZXMgPSAhMSksIHRoaXMuY3VycmVudEN1cnNvciA9PT0gbW9kZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmN1cnJlbnRDdXJzb3IgPSBtb2RlO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5jdXJzb3JTdHlsZXNbbW9kZV07XG4gICAgaWYgKHN0eWxlKVxuICAgICAgc3dpdGNoICh0eXBlb2Ygc3R5bGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGFwcGx5U3R5bGVzICYmICh0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBzdHlsZShtb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGFwcGx5U3R5bGVzICYmIE9iamVjdC5hc3NpZ24odGhpcy5kb21FbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgYXBwbHlTdHlsZXMgJiYgdHlwZW9mIG1vZGUgPT0gXCJzdHJpbmdcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY3Vyc29yU3R5bGVzLCBtb2RlKSAmJiAodGhpcy5kb21FbGVtZW50LnN0eWxlLmN1cnNvciA9IG1vZGUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZ2xvYmFsIHBvaW50ZXIgZXZlbnQuXG4gICAqIFVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgcG9pbnRlciBwb3NpdGlvbiB3aXRob3V0IGxpc3RlbmluZyB0byBldmVudHMuXG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKi9cbiAgZ2V0IHBvaW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdFBvaW50ZXJFdmVudDtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciBkb3duIGV2ZW50cyBvbiB7QGxpbmsgUElYSS5FdmVudFN5c3RlbSNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgbW91c2UvcG9pbnRlci90b3VjaCBldmVudC5cbiAgICovXG4gIG9uUG9pbnRlckRvd24obmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgdGhpcy5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnRzWzBdLmlzTm9ybWFsaXplZCAmJiAobmF0aXZlRXZlbnQuY2FuY2VsYWJsZSB8fCAhKFwiY2FuY2VsYWJsZVwiIGluIG5hdGl2ZUV2ZW50KSkgJiYgbmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUV2ZW50MiA9IGV2ZW50c1tpXSwgZmVkZXJhdGVkRXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbmF0aXZlRXZlbnQyKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGZlZGVyYXRlZEV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciBtb3ZlIGV2ZW50cyBvbiBvbiB7QGxpbmsgUElYSS5FdmVudFN5c3RlbSNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgbW91c2UvcG9pbnRlci90b3VjaCBldmVudHMuXG4gICAqL1xuICBvblBvaW50ZXJNb3ZlKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLm1vdmUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkLCBFdmVudHNUaWNrZXIucG9pbnRlck1vdmVkKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgdXAgZXZlbnRzIG9uIHtAbGluayBQSVhJLkV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSBtb3VzZS9wb2ludGVyL3RvdWNoIGV2ZW50LlxuICAgKi9cbiAgb25Qb2ludGVyVXAobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGxldCB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQ7XG4gICAgbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoICYmIG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpLmxlbmd0aCA+IDAgJiYgKHRhcmdldCA9IG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgICBjb25zdCBvdXRzaWRlID0gdGFyZ2V0ICE9PSB0aGlzLmRvbUVsZW1lbnQgPyBcIm91dHNpZGVcIiA6IFwiXCIsIG5vcm1hbGl6ZWRFdmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ib290c3RyYXBFdmVudCh0aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudHNbaV0pO1xuICAgICAgZXZlbnQudHlwZSArPSBvdXRzaWRlLCB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgb3ZlciAmIG91dCBldmVudHMgb24ge0BsaW5rIFBJWEkuRXZlbnRTeXN0ZW0jZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LlxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnQgLSBUaGUgbmF0aXZlIG1vdXNlL3BvaW50ZXIvdG91Y2ggZXZlbnQuXG4gICAqL1xuICBvblBvaW50ZXJPdmVyT3V0KG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmNsaWNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG5vcm1hbGl6ZWRFdmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYm9vdHN0cmFwRXZlbnQodGhpcy5yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICAvKipcbiAgICogUGFzc2l2ZSBoYW5kbGVyIGZvciBgd2hlZWxgIGV2ZW50cyBvbiB7QGxpbmsgUElYSS5FdmVudFN5c3RlbS5kb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgd2hlZWwgZXZlbnQuXG4gICAqL1xuICBvbldoZWVsKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLndoZWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLm5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQod2hlZWxFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBQSVhJLkV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgZG9tRWxlbWVudH0gYW5kIGJpbmRzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogVG8gZGVyZWdpc3RlciB0aGUgY3VycmVudCBET00gZWxlbWVudCB3aXRob3V0IHNldHRpbmcgYSBuZXcgb25lLCBwYXNzIHtAY29kZSBudWxsfS5cbiAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgbmV3IERPTSBlbGVtZW50LlxuICAgKi9cbiAgc2V0VGFyZ2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKSwgdGhpcy5kb21FbGVtZW50ID0gZWxlbWVudCwgRXZlbnRzVGlja2VyLmRvbUVsZW1lbnQgPSBlbGVtZW50LCB0aGlzLmFkZEV2ZW50cygpO1xuICB9XG4gIC8qKiBSZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgb24ge0BsaW5rIFBJWEkuUmVuZGVyZXIjZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LiAqL1xuICBhZGRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRzQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBFdmVudHNUaWNrZXIuYWRkVGlja2VyTGlzdGVuZXIoKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZG9tRWxlbWVudC5zdHlsZTtcbiAgICBzdHlsZSAmJiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCA/IChzdHlsZS5tc0NvbnRlbnRab29taW5nID0gXCJub25lXCIsIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIikgOiB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyAmJiAoc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIikpLCB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyA/IChnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sICEwKSwgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCAhMCkpIDogKGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgITApLCBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Qb2ludGVyVXAsICEwKSwgdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmICh0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblBvaW50ZXJVcCwgITApLCB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSkpLCB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgcGFzc2l2ZTogITAsXG4gICAgICBjYXB0dXJlOiAhMFxuICAgIH0pLCB0aGlzLmV2ZW50c0FkZGVkID0gITA7XG4gIH1cbiAgLyoqIFVucmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIG9uIHtAbGluayBQSVhJLkV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS4gKi9cbiAgcmVtb3ZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5ldmVudHNBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIEV2ZW50c1RpY2tlci5yZW1vdmVUaWNrZXJMaXN0ZW5lcigpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kb21FbGVtZW50LnN0eWxlO1xuICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgPyAoc3R5bGUubXNDb250ZW50Wm9vbWluZyA9IFwiXCIsIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIlwiKSA6IHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzICYmIChzdHlsZS50b3VjaEFjdGlvbiA9IFwiXCIpLCB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyA/IChnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sICEwKSwgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCAhMCkpIDogKGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgITApLCBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Qb2ludGVyVXAsICEwKSwgdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmICh0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblBvaW50ZXJVcCwgITApLCB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSkpLCB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgITApLCB0aGlzLmRvbUVsZW1lbnQgPSBudWxsLCB0aGlzLmV2ZW50c0FkZGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgeCBhbmQgeSBjb29yZHMgZnJvbSBhIERPTSBvYmplY3QgYW5kIG1hcHMgdGhlbSBjb3JyZWN0bHkgdG8gdGhlIFBpeGlKUyB2aWV3LiBUaGVcbiAgICogcmVzdWx0aW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcG9pbnQuIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoZSBmYWN0IHRoYXQgdGhlIERPTVxuICAgKiBlbGVtZW50IGNvdWxkIGJlIHNjYWxlZCBhbmQgcG9zaXRpb25lZCBhbnl3aGVyZSBvbiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gIHtQSVhJLklQb2ludERhdGF9IHBvaW50IC0gdGhlIHBvaW50IHRoYXQgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCBpblxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB0aGUgeCBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXG4gICAqIEBwYXJhbSAge251bWJlcn0geSAtIHRoZSB5IGNvb3JkIG9mIHRoZSBwb3NpdGlvbiB0byBtYXBcbiAgICovXG4gIG1hcFBvc2l0aW9uVG9Qb2ludChwb2ludCwgeCwgeSkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmRvbUVsZW1lbnQuaXNDb25uZWN0ZWQgPyB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB0aGlzLmRvbUVsZW1lbnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuZG9tRWxlbWVudC5oZWlnaHQsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfSwgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHBvaW50LnggPSAoeCAtIHJlY3QubGVmdCkgKiAodGhpcy5kb21FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkgKiByZXNvbHV0aW9uTXVsdGlwbGllciwgcG9pbnQueSA9ICh5IC0gcmVjdC50b3ApICogKHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgLyByZWN0LmhlaWdodCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBhIHJlZ3VsYXIgcG9pbnRlciBldmVudCB3b3VsZCBoYXZlXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBkYXRhIGZyb20gYSB0b3VjaCBvciBtb3VzZSBldmVudFxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGEgc2luZ2xlIG5vcm1hbGl6ZWQgcG9pbnRlciBldmVudCwgaW4gdGhlIGNhc2Ugb2YgYSBwb2ludGVyXG4gICAqICBvciBtb3VzZSBldmVudCwgb3IgYSBtdWx0aXBsZSBub3JtYWxpemVkIHBvaW50ZXIgZXZlbnRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBjaGFuZ2VkIHRvdWNoZXNcbiAgICovXG4gIG5vcm1hbGl6ZVRvUG9pbnRlckRhdGEoZXZlbnQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gW107XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGkgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIHR5cGVvZiB0b3VjaC5idXR0b24gPiBcInVcIiAmJiAodG91Y2guYnV0dG9uID0gMCksIHR5cGVvZiB0b3VjaC5idXR0b25zID4gXCJ1XCIgJiYgKHRvdWNoLmJ1dHRvbnMgPSAxKSwgdHlwZW9mIHRvdWNoLmlzUHJpbWFyeSA+IFwidVwiICYmICh0b3VjaC5pc1ByaW1hcnkgPSBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIiksIHR5cGVvZiB0b3VjaC53aWR0aCA+IFwidVwiICYmICh0b3VjaC53aWR0aCA9IHRvdWNoLnJhZGl1c1ggfHwgMSksIHR5cGVvZiB0b3VjaC5oZWlnaHQgPiBcInVcIiAmJiAodG91Y2guaGVpZ2h0ID0gdG91Y2gucmFkaXVzWSB8fCAxKSwgdHlwZW9mIHRvdWNoLnRpbHRYID4gXCJ1XCIgJiYgKHRvdWNoLnRpbHRYID0gMCksIHR5cGVvZiB0b3VjaC50aWx0WSA+IFwidVwiICYmICh0b3VjaC50aWx0WSA9IDApLCB0eXBlb2YgdG91Y2gucG9pbnRlclR5cGUgPiBcInVcIiAmJiAodG91Y2gucG9pbnRlclR5cGUgPSBcInRvdWNoXCIpLCB0eXBlb2YgdG91Y2gucG9pbnRlcklkID4gXCJ1XCIgJiYgKHRvdWNoLnBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXIgfHwgMCksIHR5cGVvZiB0b3VjaC5wcmVzc3VyZSA+IFwidVwiICYmICh0b3VjaC5wcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IDAuNSksIHR5cGVvZiB0b3VjaC50d2lzdCA+IFwidVwiICYmICh0b3VjaC50d2lzdCA9IDApLCB0eXBlb2YgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID4gXCJ1XCIgJiYgKHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDApLCB0eXBlb2YgdG91Y2gubGF5ZXJYID4gXCJ1XCIgJiYgKHRvdWNoLmxheWVyWCA9IHRvdWNoLm9mZnNldFggPSB0b3VjaC5jbGllbnRYKSwgdHlwZW9mIHRvdWNoLmxheWVyWSA+IFwidVwiICYmICh0b3VjaC5sYXllclkgPSB0b3VjaC5vZmZzZXRZID0gdG91Y2guY2xpZW50WSksIHRvdWNoLmlzTm9ybWFsaXplZCA9ICEwLCB0b3VjaC50eXBlID0gZXZlbnQudHlwZSwgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRvdWNoKTtcbiAgICAgIH1cbiAgICBlbHNlIGlmICghZ2xvYmFsVGhpcy5Nb3VzZUV2ZW50IHx8IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiAoIXRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzIHx8ICEoZXZlbnQgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlBvaW50ZXJFdmVudCkpKSB7XG4gICAgICBjb25zdCB0ZW1wRXZlbnQgPSBldmVudDtcbiAgICAgIHR5cGVvZiB0ZW1wRXZlbnQuaXNQcmltYXJ5ID4gXCJ1XCIgJiYgKHRlbXBFdmVudC5pc1ByaW1hcnkgPSAhMCksIHR5cGVvZiB0ZW1wRXZlbnQud2lkdGggPiBcInVcIiAmJiAodGVtcEV2ZW50LndpZHRoID0gMSksIHR5cGVvZiB0ZW1wRXZlbnQuaGVpZ2h0ID4gXCJ1XCIgJiYgKHRlbXBFdmVudC5oZWlnaHQgPSAxKSwgdHlwZW9mIHRlbXBFdmVudC50aWx0WCA+IFwidVwiICYmICh0ZW1wRXZlbnQudGlsdFggPSAwKSwgdHlwZW9mIHRlbXBFdmVudC50aWx0WSA+IFwidVwiICYmICh0ZW1wRXZlbnQudGlsdFkgPSAwKSwgdHlwZW9mIHRlbXBFdmVudC5wb2ludGVyVHlwZSA+IFwidVwiICYmICh0ZW1wRXZlbnQucG9pbnRlclR5cGUgPSBcIm1vdXNlXCIpLCB0eXBlb2YgdGVtcEV2ZW50LnBvaW50ZXJJZCA+IFwidVwiICYmICh0ZW1wRXZlbnQucG9pbnRlcklkID0gTU9VU0VfUE9JTlRFUl9JRCksIHR5cGVvZiB0ZW1wRXZlbnQucHJlc3N1cmUgPiBcInVcIiAmJiAodGVtcEV2ZW50LnByZXNzdXJlID0gMC41KSwgdHlwZW9mIHRlbXBFdmVudC50d2lzdCA+IFwidVwiICYmICh0ZW1wRXZlbnQudHdpc3QgPSAwKSwgdHlwZW9mIHRlbXBFdmVudC50YW5nZW50aWFsUHJlc3N1cmUgPiBcInVcIiAmJiAodGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IDApLCB0ZW1wRXZlbnQuaXNOb3JtYWxpemVkID0gITAsIG5vcm1hbGl6ZWRFdmVudHMucHVzaCh0ZW1wRXZlbnQpO1xuICAgIH0gZWxzZVxuICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICByZXR1cm4gbm9ybWFsaXplZEV2ZW50cztcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgbmF0aXZlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2ludGVyZmFjZS13aGVlbGV2ZW50IFdoZWVsRXZlbnR9LlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQge0BsaW5rIFBJWEkuRmVkZXJhdGVkV2hlZWxFdmVudH0gaXMgYSBzaGFyZWQgaW5zdGFuY2UuIEl0IHdpbGwgbm90IHBlcnNpc3QgYWNyb3NzXG4gICAqIG11bHRpcGxlIG5hdGl2ZSB3aGVlbCBldmVudHMuXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgd2hlZWwgZXZlbnQgdGhhdCBvY2N1cnJlZCBvbiB0aGUgY2FudmFzLlxuICAgKiBAcmV0dXJucyBBIGZlZGVyYXRlZCB3aGVlbCBldmVudC5cbiAgICovXG4gIG5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMucm9vdFdoZWVsRXZlbnQ7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KSwgZXZlbnQuZGVsdGFYID0gbmF0aXZlRXZlbnQuZGVsdGFYLCBldmVudC5kZWx0YVkgPSBuYXRpdmVFdmVudC5kZWx0YVksIGV2ZW50LmRlbHRhWiA9IG5hdGl2ZUV2ZW50LmRlbHRhWiwgZXZlbnQuZGVsdGFNb2RlID0gbmF0aXZlRXZlbnQuZGVsdGFNb2RlLCB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpLCBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuc2NyZWVuKSwgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbiksIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQsIGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgYG5hdGl2ZUV2ZW50YCBpbnRvIGEgZmVkZXJhdGVlZCB7QGxpbmsgUElYSS5GZWRlcmF0ZWRQb2ludGVyRXZlbnR9LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50XG4gICAqL1xuICBib290c3RyYXBFdmVudChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudCA9IG51bGwsIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQsIGV2ZW50LnBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCwgZXZlbnQud2lkdGggPSBuYXRpdmVFdmVudC53aWR0aCwgZXZlbnQuaGVpZ2h0ID0gbmF0aXZlRXZlbnQuaGVpZ2h0LCBldmVudC5pc1ByaW1hcnkgPSBuYXRpdmVFdmVudC5pc1ByaW1hcnksIGV2ZW50LnBvaW50ZXJUeXBlID0gbmF0aXZlRXZlbnQucG9pbnRlclR5cGUsIGV2ZW50LnByZXNzdXJlID0gbmF0aXZlRXZlbnQucHJlc3N1cmUsIGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IG5hdGl2ZUV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSwgZXZlbnQudGlsdFggPSBuYXRpdmVFdmVudC50aWx0WCwgZXZlbnQudGlsdFkgPSBuYXRpdmVFdmVudC50aWx0WSwgZXZlbnQudHdpc3QgPSBuYXRpdmVFdmVudC50d2lzdCwgdGhpcy50cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpLCB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpLCBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuc2NyZWVuKSwgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbiksIGV2ZW50LmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZCwgZXZlbnQudHlwZSA9PT0gXCJwb2ludGVybGVhdmVcIiAmJiAoZXZlbnQudHlwZSA9IFwicG9pbnRlcm91dFwiKSwgZXZlbnQudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIikgJiYgKGV2ZW50LnR5cGUgPSBldmVudC50eXBlLnJlcGxhY2UoXCJtb3VzZVwiLCBcInBvaW50ZXJcIikpLCBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSAmJiAoZXZlbnQudHlwZSA9IFRPVUNIX1RPX1BPSU5URVJbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZSksIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2ZlcnMgYmFzZSAmIG1vdXNlIGV2ZW50IGRhdGEgZnJvbSB0aGUge0Bjb2RlIG5hdGl2ZUV2ZW50fSB0byB0aGUgZmVkZXJhdGVkIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50XG4gICAqL1xuICB0cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBldmVudC5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQsIGV2ZW50LnNyY0VsZW1lbnQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LCBldmVudC50aW1lU3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKSwgZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGUsIGV2ZW50LmFsdEtleSA9IG5hdGl2ZUV2ZW50LmFsdEtleSwgZXZlbnQuYnV0dG9uID0gbmF0aXZlRXZlbnQuYnV0dG9uLCBldmVudC5idXR0b25zID0gbmF0aXZlRXZlbnQuYnV0dG9ucywgZXZlbnQuY2xpZW50LnggPSBuYXRpdmVFdmVudC5jbGllbnRYLCBldmVudC5jbGllbnQueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFksIGV2ZW50LmN0cmxLZXkgPSBuYXRpdmVFdmVudC5jdHJsS2V5LCBldmVudC5tZXRhS2V5ID0gbmF0aXZlRXZlbnQubWV0YUtleSwgZXZlbnQubW92ZW1lbnQueCA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnQueSA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WSwgZXZlbnQucGFnZS54ID0gbmF0aXZlRXZlbnQucGFnZVgsIGV2ZW50LnBhZ2UueSA9IG5hdGl2ZUV2ZW50LnBhZ2VZLCBldmVudC5yZWxhdGVkVGFyZ2V0ID0gbnVsbCwgZXZlbnQuc2hpZnRLZXkgPSBuYXRpdmVFdmVudC5zaGlmdEtleTtcbiAgfVxufTtcbl9FdmVudFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXZlbnRzXCIsXG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXVxufSwgLyoqXG4qIFRoZSBldmVudCBmZWF0dXJlcyB0aGF0IGFyZSBlbmFibGVkIGJ5IHRoZSBFdmVudFN5c3RlbVxuKiBUaGlzIG9wdGlvbiBvbmx5IGlzIGF2YWlsYWJsZSB3aGVuIHVzaW5nICoqQHBpeGkvZXZlbnRzKiogcGFja2FnZVxuKiAoaW5jbHVkZWQgaW4gdGhlICoqcGl4aS5qcyoqIGFuZCAqKnBpeGkuanMtbGVnYWN5KiogYnVuZGxlKSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZC5cbiogQHNpbmNlIDcuMi4wXG4qL1xuX0V2ZW50U3lzdGVtLmRlZmF1bHRFdmVudEZlYXR1cmVzID0ge1xuICBtb3ZlOiAhMCxcbiAgZ2xvYmFsTW92ZTogITAsXG4gIGNsaWNrOiAhMCxcbiAgd2hlZWw6ICEwXG59O1xubGV0IEV2ZW50U3lzdGVtID0gX0V2ZW50U3lzdGVtO1xuZXh0ZW5zaW9ucy5hZGQoRXZlbnRTeXN0ZW0pO1xuZXhwb3J0IHtcbiAgRXZlbnRTeXN0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmltcG9ydCB7IEV2ZW50U3lzdGVtIH0gZnJvbSBcIi4vRXZlbnRTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBGZWRlcmF0ZWRFdmVudCB9IGZyb20gXCIuL0ZlZGVyYXRlZEV2ZW50Lm1qc1wiO1xuZnVuY3Rpb24gY29udmVydEV2ZW50TW9kZVRvSW50ZXJhY3RpdmVNb2RlKG1vZGUpIHtcbiAgcmV0dXJuIG1vZGUgPT09IFwiZHluYW1pY1wiIHx8IG1vZGUgPT09IFwic3RhdGljXCI7XG59XG5jb25zdCBGZWRlcmF0ZWREaXNwbGF5T2JqZWN0ID0ge1xuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gY2xpY2tcbiAgICogfVxuICAgKi9cbiAgb25jbGljazogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2Vkb3duYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2Vkb3duID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gbW91c2Vkb3duXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2Vkb3duOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZWVudGVyYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2VlbnRlciA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlZW50ZXJcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZWVudGVyOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZWxlYXZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2VsZWF2ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlbGVhdmVcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZWxlYXZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZW1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZW1vdmVcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZW1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYGdsb2JhbG1vdXNlbW92ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmdsb2JhbG1vdXNlbW92ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIGdsb2JhbG1vdXNlbW92ZVxuICAgKiB9XG4gICAqL1xuICBvbmdsb2JhbG1vdXNlbW92ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2VvdXRgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZW91dCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlb3V0XG4gICAqIH1cbiAgICovXG4gIG9ubW91c2VvdXQ6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYG1vdXNlb3ZlcmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNlb3ZlciA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlb3ZlclxuICAgKiB9XG4gICAqL1xuICBvbm1vdXNlb3ZlcjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2V1cGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNldXAgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZXVwXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2V1cDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2V1cG91dHNpZGVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZXVwb3V0c2lkZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNldXBvdXRzaWRlXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2V1cG91dHNpZGU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJjYW5jZWxgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVyY2FuY2VsID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcmNhbmNlbFxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJjYW5jZWw6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJkb3duYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcmRvd24gPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVyZG93blxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJkb3duOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyZW50ZXJgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVyZW50ZXIgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVyZW50ZXJcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyZW50ZXI6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJsZWF2ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJsZWF2ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJsZWF2ZVxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJsZWF2ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVybW92ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJtb3ZlXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcm1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYGdsb2JhbHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9uZ2xvYmFscG9pbnRlcm1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBnbG9iYWxwb2ludGVybW92ZVxuICAgKiB9XG4gICAqL1xuICBvbmdsb2JhbHBvaW50ZXJtb3ZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyb3V0YCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcm91dCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJvdXRcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyb3V0OiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyb3ZlcmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJvdmVyID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcm92ZXJcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyb3ZlcjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcnRhcGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJ0YXAgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVydGFwXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcnRhcDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcnVwYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcnVwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcnVwXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcnVwOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVydXBvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcnVwb3V0c2lkZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJ1cG91dHNpZGVcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVydXBvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGByaWdodGNsaWNrYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucmlnaHRjbGljayA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHJpZ2h0Y2xpY2tcbiAgICogfVxuICAgKi9cbiAgb25yaWdodGNsaWNrOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGByaWdodGRvd25gIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25yaWdodGRvd24gPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiByaWdodGRvd25cbiAgICogfVxuICAgKi9cbiAgb25yaWdodGRvd246IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHJpZ2h0dXBgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25yaWdodHVwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcmlnaHR1cFxuICAgKiB9XG4gICAqL1xuICBvbnJpZ2h0dXA6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHJpZ2h0dXBvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucmlnaHR1cG91dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiByaWdodHVwb3V0c2lkZVxuICAgKiB9XG4gICAqL1xuICBvbnJpZ2h0dXBvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0YXBgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub250YXAgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0YXBcbiAgICogfVxuICAgKi9cbiAgb250YXA6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHRvdWNoY2FuY2VsYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9udG91Y2hjYW5jZWwgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0b3VjaGNhbmNlbFxuICAgKiB9XG4gICAqL1xuICBvbnRvdWNoY2FuY2VsOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0b3VjaGVuZGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnRvdWNoZW5kID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2hlbmRcbiAgICogfVxuICAgKi9cbiAgb250b3VjaGVuZDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdG91Y2hlbmRvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9udG91Y2hlbmRvdXRzaWRlID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2hlbmRvdXRzaWRlXG4gICAqIH1cbiAgICovXG4gIG9udG91Y2hlbmRvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0b3VjaG1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub250b3VjaG1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0b3VjaG1vdmVcbiAgICogfVxuICAgKi9cbiAgb250b3VjaG1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYGdsb2JhbHRvdWNobW92ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmdsb2JhbHRvdWNobW92ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIGdsb2JhbHRvdWNobW92ZVxuICAgKiB9XG4gICAqL1xuICBvbmdsb2JhbHRvdWNobW92ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdG91Y2hzdGFydGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnRvdWNoc3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0b3VjaHN0YXJ0XG4gICAqIH1cbiAgICovXG4gIG9udG91Y2hzdGFydDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgd2hlZWxgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub253aGVlbCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHdoZWVsXG4gICAqIH1cbiAgICovXG4gIG9ud2hlZWw6IG51bGwsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfaW50ZXJuYWxJbnRlcmFjdGl2ZTogdm9pZCAwLFxuICAvKipcbiAgICogRW5hYmxlIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgdGhlIERpc3BsYXlPYmplY3QuIFRvdWNoLCBwb2ludGVyIGFuZCBtb3VzZVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgZ2V0IGludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEludGVyYWN0aXZlID8/IGNvbnZlcnRFdmVudE1vZGVUb0ludGVyYWN0aXZlTW9kZShFdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRNb2RlKTtcbiAgfSxcbiAgc2V0IGludGVyYWN0aXZlKHZhbHVlKSB7XG4gICAgdXRpbHMuZGVwcmVjYXRpb24oXG4gICAgICBcIjcuMi4wXCIsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgXCJTZXR0aW5nIGludGVyYWN0aXZlIGlzIGRlcHJlY2F0ZWQsIHVzZSBldmVudE1vZGUgPSAnbm9uZScvJ3Bhc3NpdmUnLydhdXRvJy8nc3RhdGljJy8nZHluYW1pYycgaW5zdGVhZC5cIlxuICAgICksIHRoaXMuX2ludGVybmFsSW50ZXJhY3RpdmUgPSB2YWx1ZSwgdGhpcy5ldmVudE1vZGUgPSB2YWx1ZSA/IFwic3RhdGljXCIgOiBcImF1dG9cIjtcbiAgfSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9pbnRlcm5hbEV2ZW50TW9kZTogdm9pZCAwLFxuICAvKipcbiAgICogRW5hYmxlIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgdGhlIERpc3BsYXlPYmplY3QuIFRvdWNoLCBwb2ludGVyIGFuZCBtb3VzZS5cbiAgICogVGhpcyBub3cgcmVwbGFjZXMgdGhlIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkuXG4gICAqIFRoZXJlIGFyZSA1IHR5cGVzIG9mIGludGVyYWN0aW9uIHNldHRpbmdzOlxuICAgKiAtIGAnbm9uZSdgOiBJZ25vcmVzIGFsbCBpbnRlcmFjdGlvbiBldmVudHMsIGV2ZW4gb24gaXRzIGNoaWxkcmVuLlxuICAgKiAtIGAncGFzc2l2ZSdgOiBEb2VzIG5vdCBlbWl0IGV2ZW50cyBhbmQgaWdub3JlcyBhbGwgaGl0IHRlc3Rpbmcgb24gaXRzZWxmIGFuZCBub24taW50ZXJhY3RpdmUgY2hpbGRyZW4uXG4gICAqIEludGVyYWN0aXZlIGNoaWxkcmVuIHdpbGwgc3RpbGwgZW1pdCBldmVudHMuXG4gICAqIC0gYCdhdXRvJ2A6IERvZXMgbm90IGVtaXQgZXZlbnRzIGJ1dCBpcyBoaXQgdGVzdGVkIGlmIHBhcmVudCBpcyBpbnRlcmFjdGl2ZS4gU2FtZSBhcyBgaW50ZXJhY3RpdmUgPSBmYWxzZWAgaW4gdjdcbiAgICogLSBgJ3N0YXRpYydgOiBFbWl0IGV2ZW50cyBhbmQgaXMgaGl0IHRlc3RlZC4gU2FtZSBhcyBgaW50ZXJhY3Rpb24gPSB0cnVlYCBpbiB2N1xuICAgKiAtIGAnZHluYW1pYydgOiBFbWl0cyBldmVudHMgYW5kIGlzIGhpdCB0ZXN0ZWQgYnV0IHdpbGwgYWxzbyByZWNlaXZlIG1vY2sgaW50ZXJhY3Rpb24gZXZlbnRzIGZpcmVkIGZyb20gYSB0aWNrZXIgdG9cbiAgICogYWxsb3cgZm9yIGludGVyYWN0aW9uIHdoZW4gdGhlIG1vdXNlIGlzbid0IG1vdmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICogc3ByaXRlLmV2ZW50TW9kZSA9ICdzdGF0aWMnO1xuICAgKiBzcHJpdGUub24oJ3RhcCcsIChldmVudCkgPT4ge1xuICAgKiAgICAgLy8gSGFuZGxlIGV2ZW50XG4gICAqIH0pO1xuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAc2luY2UgNy4yLjBcbiAgICovXG4gIGdldCBldmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsRXZlbnRNb2RlID8/IEV2ZW50U3lzdGVtLmRlZmF1bHRFdmVudE1vZGU7XG4gIH0sXG4gIHNldCBldmVudE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9pbnRlcm5hbEludGVyYWN0aXZlID0gY29udmVydEV2ZW50TW9kZVRvSW50ZXJhY3RpdmVNb2RlKHZhbHVlKSwgdGhpcy5faW50ZXJuYWxFdmVudE1vZGUgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGRpc3BsYXlPYmplY3QgaXMgaW50ZXJhY3RpdmUgb3Igbm90XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGludGVyYWN0aXZlIG9yIG5vdFxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAc2luY2UgNy4yLjBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnc3RhdGljJztcbiAgICogc3ByaXRlLmlzSW50ZXJhY3RpdmUoKTsgLy8gdHJ1ZVxuICAgKlxuICAgKiBzcHJpdGUuZXZlbnRNb2RlID0gJ2R5bmFtaWMnO1xuICAgKiBzcHJpdGUuaXNJbnRlcmFjdGl2ZSgpOyAvLyB0cnVlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnbm9uZSc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIGZhbHNlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAncGFzc2l2ZSc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIGZhbHNlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnYXV0byc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIGZhbHNlXG4gICAqL1xuICBpc0ludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50TW9kZSA9PT0gXCJzdGF0aWNcIiB8fCB0aGlzLmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCI7XG4gIH0sXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjaGlsZHJlbiB0byB0aGUgZGlzcGxheU9iamVjdCBjYW4gYmUgY2xpY2tlZC90b3VjaGVkXG4gICAqIFNldHRpbmcgdGhpcyB0byBmYWxzZSBhbGxvd3MgUGl4aUpTIHRvIGJ5cGFzcyBhIHJlY3Vyc2l2ZSBgaGl0VGVzdGAgZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xuICAgKi9cbiAgaW50ZXJhY3RpdmVDaGlsZHJlbjogITAsXG4gIC8qKlxuICAgKiBJbnRlcmFjdGlvbiBzaGFwZS4gQ2hpbGRyZW4gd2lsbCBiZSBoaXQgZmlyc3QsIHRoZW4gdGhpcyBzaGFwZSB3aWxsIGJlIGNoZWNrZWQuXG4gICAqIFNldHRpbmcgdGhpcyB3aWxsIGNhdXNlIHRoaXMgc2hhcGUgdG8gYmUgY2hlY2tlZCBpbiBoaXQgdGVzdHMgcmF0aGVyIHRoYW4gdGhlIGRpc3BsYXlPYmplY3QncyBib3VuZHMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFJlY3RhbmdsZSwgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCk7XG4gICAqIEBtZW1iZXIge1BJWEkuSUhpdEFyZWF9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqL1xuICBoaXRBcmVhOiBudWxsLFxuICAvKipcbiAgICogVW5saWtlIGBvbmAgb3IgYGFkZExpc3RlbmVyYCB3aGljaCBhcmUgbWV0aG9kcyBmcm9tIEV2ZW50RW1pdHRlciwgYGFkZEV2ZW50TGlzdGVuZXJgXG4gICAqIHNlZWtzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgRE9NJ3MgYGFkZEV2ZW50TGlzdGVuZXJgIHdpdGggc3VwcG9ydCBmb3Igb3B0aW9ucy5cbiAgICogKipJTVBPUlRBTlQ6KiogX09ubHlfIGF2YWlsYWJsZSBpZiB1c2luZyB0aGUgYEBwaXhpL2V2ZW50c2AgcGFja2FnZS5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGNhbGxiYWNrIG9yIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBMaXN0ZW5lciBvcHRpb25zLCB1c2VkIGZvciBjYXB0dXJlIHBoYXNlLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBUZWxsIHRoZSB1c2VyIHdoZXRoZXIgdGhleSBkaWQgYSBzaW5nbGUsIGRvdWJsZSwgdHJpcGxlLCBvciBudGggY2xpY2suXG4gICAqIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHtcbiAgICogICAgIGhhbmRsZUV2ZW50KGUpOiB7XG4gICAqICAgICAgICAgbGV0IHByZWZpeDtcbiAgICpcbiAgICogICAgICAgICBzd2l0Y2ggKGUuZGV0YWlsKSB7XG4gICAqICAgICAgICAgICAgIGNhc2UgMTogcHJlZml4ID0gJ3NpbmdsZSc7IGJyZWFrO1xuICAgKiAgICAgICAgICAgICBjYXNlIDI6IHByZWZpeCA9ICdkb3VibGUnOyBicmVhaztcbiAgICogICAgICAgICAgICAgY2FzZSAzOiBwcmVmaXggPSAndHJpcGxlJzsgYnJlYWs7XG4gICAqICAgICAgICAgICAgIGRlZmF1bHQ6IHByZWZpeCA9IGUuZGV0YWlsICsgJ3RoJzsgYnJlYWs7XG4gICAqICAgICAgICAgfVxuICAgKlxuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdUaGF0IHdhcyBhICcgKyBwcmVmaXggKyAnY2xpY2snKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEJ1dCBza2lwIHRoZSBmaXJzdCBjbGljayFcbiAgICogYnV0dG9uLnBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIGJsb2NrQ2xpY2tPbmNlKGUpIHtcbiAgICogICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAqICAgICBidXR0b24ucGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYmxvY2tDbGlja09uY2UsIHRydWUpO1xuICAgKiB9LCB7XG4gICAqICAgICBjYXB0dXJlOiB0cnVlLFxuICAgKiB9KTtcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXB0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT0gXCJib29sZWFuXCIgJiYgb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyA9PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZSwgY29udGV4dCA9IHR5cGVvZiBsaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlLCBsaXN0ZW5lciA9IHR5cGVvZiBsaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50LCB0aGlzLm9uKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFVubGlrZSBgb2ZmYCBvciBgcmVtb3ZlTGlzdGVuZXJgIHdoaWNoIGFyZSBtZXRob2RzIGZyb20gRXZlbnRFbWl0dGVyLCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmBcbiAgICogc2Vla3MgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBET00ncyBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgd2l0aCBzdXBwb3J0IGZvciBvcHRpb25zLlxuICAgKiAqKklNUE9SVEFOVDoqKiBfT25seV8gYXZhaWxhYmxlIGlmIHVzaW5nIHRoZSBgQHBpeGkvZXZlbnRzYCBwYWNrYWdlLlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdGhlIGxpc3RlbmVyIGlzIGJvdW5kIHRvLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgY2FsbGJhY2sgb3Igb2JqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcmlnaW5hbCBsaXN0ZW5lciBvcHRpb25zLiBUaGlzIGlzIHJlcXVpcmVkIHRvIGRlcmVnaXN0ZXIgYSBjYXB0dXJlIHBoYXNlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5jYXB0dXJlLCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IGxpc3RlbmVyO1xuICAgIHR5cGUgPSBjYXB0dXJlID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGUsIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09IFwiZnVuY3Rpb25cIiA/IGxpc3RlbmVyIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQsIHRoaXMub2ZmKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgLyoqXG4gICAqIERpc3BhdGNoIHRoZSBldmVudCBvbiB0aGlzIHtAbGluayBQSVhJLkRpc3BsYXlPYmplY3R9IHVzaW5nIHRoZSBldmVudCdzIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnl9LlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBzZXQgdG8gYHRoaXNgIGFuZCB0aGUgYGRlZmF1bHRQcmV2ZW50ZWRgIGZsYWcgaXMgY2xlYXJlZCBiZWZvcmUgZGlzcGF0Y2guXG4gICAqXG4gICAqICoqSU1QT1JUQU5UOioqIF9Pbmx5XyBhdmFpbGFibGUgaWYgdXNpbmcgdGhlIGBAcGl4aS9ldmVudHNgIHBhY2thZ2UuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHtAbGluayBQSVhJLkZlZGVyYXRlZEV2ZW50LnByZXZlbnREZWZhdWx0IHByZXZlbnREZWZhdWx0fSgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJldXNlIGEgY2xpY2sgZXZlbnQhXG4gICAqIGJ1dHRvbi5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZlZGVyYXRlZEV2ZW50KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc3BsYXlPYmplY3QgY2Fubm90IHByb3BhZ2F0ZSBldmVudHMgb3V0c2lkZSBvZiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUElcIik7XG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCA9ICExLCBlLnBhdGggPSBudWxsLCBlLnRhcmdldCA9IHRoaXMsIGUubWFuYWdlci5kaXNwYXRjaEV2ZW50KGUpLCAhZS5kZWZhdWx0UHJldmVudGVkO1xuICB9XG59O1xuRGlzcGxheU9iamVjdC5taXhpbihGZWRlcmF0ZWREaXNwbGF5T2JqZWN0KTtcbmV4cG9ydCB7XG4gIEZlZGVyYXRlZERpc3BsYXlPYmplY3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudFRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSBcIi4vRXZlbnRCb3VuZGFyeS5tanNcIjtcbmltcG9ydCB7IEV2ZW50U3lzdGVtIH0gZnJvbSBcIi4vRXZlbnRTeXN0ZW0ubWpzXCI7XG5pbXBvcnQgeyBGZWRlcmF0ZWRFdmVudCB9IGZyb20gXCIuL0ZlZGVyYXRlZEV2ZW50Lm1qc1wiO1xuaW1wb3J0IFwiLi9GZWRlcmF0ZWRFdmVudE1hcC5tanNcIjtcbmltcG9ydCB7IEZlZGVyYXRlZERpc3BsYXlPYmplY3QgfSBmcm9tIFwiLi9GZWRlcmF0ZWRFdmVudFRhcmdldC5tanNcIjtcbmltcG9ydCB7IEZlZGVyYXRlZE1vdXNlRXZlbnQgfSBmcm9tIFwiLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qc1wiO1xuaW1wb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSBcIi4vRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qc1wiO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gXCIuL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzXCI7XG5leHBvcnQge1xuICBFdmVudEJvdW5kYXJ5LFxuICBFdmVudFN5c3RlbSxcbiAgRmVkZXJhdGVkRGlzcGxheU9iamVjdCxcbiAgRmVkZXJhdGVkRXZlbnQsXG4gIEZlZGVyYXRlZE1vdXNlRXZlbnQsXG4gIEZlZGVyYXRlZFBvaW50ZXJFdmVudCxcbiAgRmVkZXJhdGVkV2hlZWxFdmVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNvbnN0IGFjY2Vzc2libGVUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiAgRmxhZyBmb3IgaWYgdGhlIG9iamVjdCBpcyBhY2Nlc3NpYmxlLiBJZiB0cnVlIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHdpbGwgb3ZlcmxheSBhXG4gICAqICAgc2hhZG93IGRpdiB3aXRoIGF0dHJpYnV0ZXMgc2V0XG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqL1xuICBhY2Nlc3NpYmxlOiAhMSxcbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpdGxlIGF0dHJpYnV0ZSBvZiB0aGUgc2hhZG93IGRpdlxuICAgKiBJZiBhY2Nlc3NpYmxlVGl0bGUgQU5EIGFjY2Vzc2libGVIaW50IGhhcyBub3QgYmVlbiB0aGlzIHdpbGwgZGVmYXVsdCB0byAnZGlzcGxheU9iamVjdCBbdGFiSW5kZXhdJ1xuICAgKiBAbWVtYmVyIHs/c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgYWNjZXNzaWJsZVRpdGxlOiBudWxsLFxuICAvKipcbiAgICogU2V0cyB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIHNoYWRvdyBkaXZcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgYWNjZXNzaWJsZUhpbnQ6IG51bGwsXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBwcml2YXRlXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqL1xuICB0YWJJbmRleDogMCxcbiAgLyoqXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqL1xuICBfYWNjZXNzaWJsZUFjdGl2ZTogITEsXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKi9cbiAgX2FjY2Vzc2libGVEaXY6IG51bGwsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB0eXBlIG9mIGRpdiB0aGUgYWNjZXNzaWJsZSBsYXllciBpcy4gU2NyZWVuIHJlYWRlcnMgdHJlYXQgdGhlIGVsZW1lbnQgZGlmZmVyZW50bHlcbiAgICogZGVwZW5kaW5nIG9uIHRoaXMgdHlwZS4gRGVmYXVsdHMgdG8gYnV0dG9uLlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0ICdidXR0b24nXG4gICAqL1xuICBhY2Nlc3NpYmxlVHlwZTogXCJidXR0b25cIixcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHBvaW50ZXItZXZlbnRzIHRoZSBhY2Nlc3NpYmxlIGRpdiB3aWxsIHVzZVxuICAgKiBEZWZhdWx0cyB0byBhdXRvLlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKi9cbiAgYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICAvKipcbiAgICogU2V0dGluZyB0byBmYWxzZSB3aWxsIHByZXZlbnQgYW55IGNoaWxkcmVuIGluc2lkZSB0aGlzIGNvbnRhaW5lciB0b1xuICAgKiBiZSBhY2Nlc3NpYmxlLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhY2Nlc3NpYmxlQ2hpbGRyZW46ICEwLFxuICByZW5kZXJJZDogLTFcbn07XG5leHBvcnQge1xuICBhY2Nlc3NpYmxlVGFyZ2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzaWJsZVRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscywgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmltcG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSBcIkBwaXhpL2V2ZW50c1wiO1xuaW1wb3J0IHsgYWNjZXNzaWJsZVRhcmdldCB9IGZyb20gXCIuL2FjY2Vzc2libGVUYXJnZXQubWpzXCI7XG5EaXNwbGF5T2JqZWN0Lm1peGluKGFjY2Vzc2libGVUYXJnZXQpO1xuY29uc3QgS0VZX0NPREVfVEFCID0gOSwgRElWX1RPVUNIX1NJWkUgPSAxMDAsIERJVl9UT1VDSF9QT1NfWCA9IDAsIERJVl9UT1VDSF9QT1NfWSA9IDAsIERJVl9UT1VDSF9aSU5ERVggPSAyLCBESVZfSE9PS19TSVpFID0gMSwgRElWX0hPT0tfUE9TX1ggPSAtMWUzLCBESVZfSE9PS19QT1NfWSA9IC0xZTMsIERJVl9IT09LX1pJTkRFWCA9IDI7XG5jbGFzcyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB7XG4gIC8vIDJmcHNcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcnxQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuZGVidWcgPSAhMSwgdGhpcy5faXNBY3RpdmUgPSAhMSwgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gITEsIHRoaXMucG9vbCA9IFtdLCB0aGlzLnJlbmRlcklkID0gMCwgdGhpcy5jaGlsZHJlbiA9IFtdLCB0aGlzLmFuZHJvaWRVcGRhdGVDb3VudCA9IDAsIHRoaXMuYW5kcm9pZFVwZGF0ZUZyZXF1ZW5jeSA9IDUwMCwgdGhpcy5faG9va0RpdiA9IG51bGwsICh1dGlscy5pc01vYmlsZS50YWJsZXQgfHwgdXRpbHMuaXNNb2JpbGUucGhvbmUpICYmIHRoaXMuY3JlYXRlVG91Y2hIb29rKCk7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGAsIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfVE9VQ0hfU0laRX1weGAsIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZGl2LnN0eWxlLnRvcCA9IGAke0RJVl9UT1VDSF9QT1NfWH1weGAsIGRpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX1RPVUNIX1BPU19ZfXB4YCwgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKSwgdGhpcy5kaXYgPSBkaXYsIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyksIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKSwgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sICExKTtcbiAgfVxuICAvKipcbiAgICogVmFsdWUgb2YgYHRydWVgIGlmIGFjY2Vzc2liaWxpdHkgaXMgY3VycmVudGx5IGFjdGl2ZSBhbmQgYWNjZXNzaWJpbGl0eSBsYXllcnMgYXJlIHNob3dpbmcuXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogVmFsdWUgb2YgYHRydWVgIGlmIGFjY2Vzc2liaWxpdHkgaXMgZW5hYmxlZCBmb3IgdG91Y2ggZGV2aWNlcy5cbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNNb2JpbGVBY2Nlc3NpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHRvdWNoIGhvb2tzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlVG91Y2hIb29rKCkge1xuICAgIGNvbnN0IGhvb2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGhvb2tEaXYuc3R5bGUud2lkdGggPSBgJHtESVZfSE9PS19TSVpFfXB4YCwgaG9va0Rpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfSE9PS19TSVpFfXB4YCwgaG9va0Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgaG9va0Rpdi5zdHlsZS50b3AgPSBgJHtESVZfSE9PS19QT1NfWH1weGAsIGhvb2tEaXYuc3R5bGUubGVmdCA9IGAke0RJVl9IT09LX1BPU19ZfXB4YCwgaG9va0Rpdi5zdHlsZS56SW5kZXggPSBESVZfSE9PS19aSU5ERVgudG9TdHJpbmcoKSwgaG9va0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRjAwMDBcIiwgaG9va0Rpdi50aXRsZSA9IFwic2VsZWN0IHRvIGVuYWJsZSBhY2Nlc3NpYmlsaXR5IGZvciB0aGlzIGNvbnRlbnRcIiwgaG9va0Rpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gITAsIHRoaXMuYWN0aXZhdGUoKSwgdGhpcy5kZXN0cm95VG91Y2hIb29rKCk7XG4gICAgfSksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9va0RpdiksIHRoaXMuX2hvb2tEaXYgPSBob29rRGl2O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdG91Y2ggaG9va3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXN0cm95VG91Y2hIb29rKCkge1xuICAgIHRoaXMuX2hvb2tEaXYgJiYgKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5faG9va0RpdiksIHRoaXMuX2hvb2tEaXYgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIHNob3duLlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBwcmVzc2VzIHRoZSB0YWIga2V5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5faXNBY3RpdmUgfHwgKHRoaXMuX2lzQWN0aXZlID0gITAsIGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgITApLCBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgITEpLCB0aGlzLnJlbmRlcmVyLm9uKFwicG9zdHJlbmRlclwiLCB0aGlzLnVwZGF0ZSwgdGhpcyksIHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlPy5hcHBlbmRDaGlsZCh0aGlzLmRpdikpO1xuICB9XG4gIC8qKlxuICAgKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIG1vdmVzIHRoZSBtb3VzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgIXRoaXMuX2lzQWN0aXZlIHx8IHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eSB8fCAodGhpcy5faXNBY3RpdmUgPSAhMSwgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCAhMCksIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCAhMSksIHRoaXMucmVuZGVyZXIub2ZmKFwicG9zdHJlbmRlclwiLCB0aGlzLnVwZGF0ZSksIHRoaXMuZGl2LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuZGl2KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgcmVjdXJzaXZlIGZ1bmN0aW9uIHdpbGwgcnVuIHRocm91Z2ggdGhlIHNjZW5lIGdyYXBoIGFuZCBhZGQgYW55IG5ldyBhY2Nlc3NpYmxlIG9iamVjdHMgdG8gdGhlIERPTSBsYXllci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gZGlzcGxheU9iamVjdCAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNoZWNrLlxuICAgKi9cbiAgdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoZGlzcGxheU9iamVjdCkge1xuICAgIGlmICghZGlzcGxheU9iamVjdC52aXNpYmxlIHx8ICFkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVDaGlsZHJlbilcbiAgICAgIHJldHVybjtcbiAgICBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGUgJiYgZGlzcGxheU9iamVjdC5pc0ludGVyYWN0aXZlKCkgJiYgKGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgfHwgdGhpcy5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KSwgZGlzcGxheU9iamVjdC5yZW5kZXJJZCA9IHRoaXMucmVuZGVySWQpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcbiAgfVxuICAvKipcbiAgICogQmVmb3JlIGVhY2ggcmVuZGVyIHRoaXMgZnVuY3Rpb24gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGl2cyBhcmUgbWFwcGVkIGNvcnJlY3RseSB0byB0aGVpciBEaXNwbGF5T2JqZWN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodXRpbHMuaXNNb2JpbGUuYW5kcm9pZC5kZXZpY2UgJiYgbm93IDwgdGhpcy5hbmRyb2lkVXBkYXRlQ291bnQgfHwgKHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50ID0gbm93ICsgdGhpcy5hbmRyb2lkVXBkYXRlRnJlcXVlbmN5LCAhdGhpcy5yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQgJiYgdGhpcy51cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyh0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCk7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnJlbmRlcmVyLnZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHsgd2lkdGg6IHZpZXdXaWR0aCwgaGVpZ2h0OiB2aWV3SGVpZ2h0LCByZXNvbHV0aW9uIH0gPSB0aGlzLnJlbmRlcmVyLCBzeCA9IHdpZHRoIC8gdmlld1dpZHRoICogcmVzb2x1dGlvbiwgc3kgPSBoZWlnaHQgLyB2aWV3SGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgICBsZXQgZGl2ID0gdGhpcy5kaXY7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBgJHt4fXB4YCwgZGl2LnN0eWxlLnRvcCA9IGAke3l9cHhgLCBkaXYuc3R5bGUud2lkdGggPSBgJHt2aWV3V2lkdGh9cHhgLCBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7dmlld0hlaWdodH1weGA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQucmVuZGVySWQgIT09IHRoaXMucmVuZGVySWQpXG4gICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlQWN0aXZlID0gITEsIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGksIDEpLCB0aGlzLmRpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdiksIHRoaXMucG9vbC5wdXNoKGNoaWxkLl9hY2Nlc3NpYmxlRGl2KSwgY2hpbGQuX2FjY2Vzc2libGVEaXYgPSBudWxsLCBpLS07XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGl2ID0gY2hpbGQuX2FjY2Vzc2libGVEaXY7XG4gICAgICAgIGxldCBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcbiAgICAgICAgY29uc3Qgd3QgPSBjaGlsZC53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgY2hpbGQuaGl0QXJlYSA/IChkaXYuc3R5bGUubGVmdCA9IGAkeyh3dC50eCArIGhpdEFyZWEueCAqIHd0LmEpICogc3h9cHhgLCBkaXYuc3R5bGUudG9wID0gYCR7KHd0LnR5ICsgaGl0QXJlYS55ICogd3QuZCkgKiBzeX1weGAsIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiB3dC5hICogc3h9cHhgLCBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7aGl0QXJlYS5oZWlnaHQgKiB3dC5kICogc3l9cHhgKSA6IChoaXRBcmVhID0gY2hpbGQuZ2V0Qm91bmRzKCksIHRoaXMuY2FwSGl0QXJlYShoaXRBcmVhKSwgZGl2LnN0eWxlLmxlZnQgPSBgJHtoaXRBcmVhLnggKiBzeH1weGAsIGRpdi5zdHlsZS50b3AgPSBgJHtoaXRBcmVhLnkgKiBzeX1weGAsIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiBzeH1weGAsIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtoaXRBcmVhLmhlaWdodCAqIHN5fXB4YCwgZGl2LnRpdGxlICE9PSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgJiYgY2hpbGQuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsICYmIChkaXYudGl0bGUgPSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUpLCBkaXYuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSAhPT0gY2hpbGQuYWNjZXNzaWJsZUhpbnQgJiYgY2hpbGQuYWNjZXNzaWJsZUhpbnQgIT09IG51bGwgJiYgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgY2hpbGQuYWNjZXNzaWJsZUhpbnQpKSwgKGNoaWxkLmFjY2Vzc2libGVUaXRsZSAhPT0gZGl2LnRpdGxlIHx8IGNoaWxkLnRhYkluZGV4ICE9PSBkaXYudGFiSW5kZXgpICYmIChkaXYudGl0bGUgPSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUsIGRpdi50YWJJbmRleCA9IGNoaWxkLnRhYkluZGV4LCB0aGlzLmRlYnVnICYmIHRoaXMudXBkYXRlRGVidWdIVE1MKGRpdikpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlcklkKys7XG4gIH1cbiAgLyoqXG4gICAqIHByaXZhdGUgZnVuY3Rpb24gdGhhdCB3aWxsIHZpc3VhbGx5IGFkZCB0aGUgaW5mb3JtYXRpb24gdG8gdGhlXG4gICAqIGFjY2Vzc2FiaWxpdHkgZGl2XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpdiAtXG4gICAqL1xuICB1cGRhdGVEZWJ1Z0hUTUwoZGl2KSB7XG4gICAgZGl2LmlubmVySFRNTCA9IGB0eXBlOiAke2Rpdi50eXBlfTwvYnI+IHRpdGxlIDogJHtkaXYudGl0bGV9PC9icj4gdGFiSW5kZXg6ICR7ZGl2LnRhYkluZGV4fWA7XG4gIH1cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgaGl0IGFyZWEgYmFzZWQgb24gdGhlIGJvdW5kcyBvZiBhIGRpc3BsYXkgb2JqZWN0XG4gICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGhpdEFyZWEgLSBCb3VuZHMgb2YgdGhlIGNoaWxkXG4gICAqL1xuICBjYXBIaXRBcmVhKGhpdEFyZWEpIHtcbiAgICBoaXRBcmVhLnggPCAwICYmIChoaXRBcmVhLndpZHRoICs9IGhpdEFyZWEueCwgaGl0QXJlYS54ID0gMCksIGhpdEFyZWEueSA8IDAgJiYgKGhpdEFyZWEuaGVpZ2h0ICs9IGhpdEFyZWEueSwgaGl0QXJlYS55ID0gMCk7XG4gICAgY29uc3QgeyB3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHQgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgaGl0QXJlYS54ICsgaGl0QXJlYS53aWR0aCA+IHZpZXdXaWR0aCAmJiAoaGl0QXJlYS53aWR0aCA9IHZpZXdXaWR0aCAtIGhpdEFyZWEueCksIGhpdEFyZWEueSArIGhpdEFyZWEuaGVpZ2h0ID4gdmlld0hlaWdodCAmJiAoaGl0QXJlYS5oZWlnaHQgPSB2aWV3SGVpZ2h0IC0gaGl0QXJlYS55KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIERpc3BsYXlPYmplY3QgdG8gdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIFRoZSBjaGlsZCB0byBtYWtlIGFjY2Vzc2libGUuXG4gICAqL1xuICBhZGRDaGlsZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgbGV0IGRpdiA9IHRoaXMucG9vbC5wb3AoKTtcbiAgICBkaXYgfHwgKGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIGRpdi5zdHlsZS53aWR0aCA9IGAke0RJVl9UT1VDSF9TSVpFfXB4YCwgZGl2LnN0eWxlLmhlaWdodCA9IGAke0RJVl9UT1VDSF9TSVpFfXB4YCwgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGVidWcgPyBcInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIDogXCJ0cmFuc3BhcmVudFwiLCBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGRpdi5zdHlsZS56SW5kZXggPSBESVZfVE9VQ0hfWklOREVYLnRvU3RyaW5nKCksIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9IFwibm9uZVwiLCBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJjaHJvbWVcIikgPyBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwib2ZmXCIpIDogZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKSwgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvcnY6LipHZWNrb1xcLy8pID8gZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtcmVsZXZhbnRcIiwgXCJhZGRpdGlvbnNcIikgOiBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLCBcInRleHRcIiksIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKSwgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9vbkZvY3VzLmJpbmQodGhpcykpLCBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQuYmluZCh0aGlzKSkpLCBkaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVBvaW50ZXJFdmVudHMsIGRpdi50eXBlID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVHlwZSwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGUgJiYgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwgPyBkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSA6ICghZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCB8fCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ID09PSBudWxsKSAmJiAoZGl2LnRpdGxlID0gYGRpc3BsYXlPYmplY3QgJHtkaXNwbGF5T2JqZWN0LnRhYkluZGV4fWApLCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgIT09IG51bGwgJiYgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCksIHRoaXMuZGVidWcgJiYgdGhpcy51cGRhdGVEZWJ1Z0hUTUwoZGl2KSwgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSA9ICEwLCBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2ID0gZGl2LCBkaXYuZGlzcGxheU9iamVjdCA9IGRpc3BsYXlPYmplY3QsIHRoaXMuY2hpbGRyZW4ucHVzaChkaXNwbGF5T2JqZWN0KSwgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdiksIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYudGFiSW5kZXggPSBkaXNwbGF5T2JqZWN0LnRhYkluZGV4O1xuICB9XG4gIC8qKlxuICAgKiBEaXNwYXRjaCBldmVudHMgd2l0aCB0aGUgRXZlbnRTeXN0ZW0uXG4gICAqIEBwYXJhbSBlXG4gICAqIEBwYXJhbSB0eXBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzcGF0Y2hFdmVudChlLCB0eXBlKSB7XG4gICAgY29uc3QgeyBkaXNwbGF5T2JqZWN0OiB0YXJnZXQgfSA9IGUudGFyZ2V0LCBib3VuZHJ5ID0gdGhpcy5yZW5kZXJlci5ldmVudHMucm9vdEJvdW5kYXJ5LCBldmVudCA9IE9iamVjdC5hc3NpZ24obmV3IEZlZGVyYXRlZEV2ZW50KGJvdW5kcnkpLCB7IHRhcmdldCB9KTtcbiAgICBib3VuZHJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCwgdHlwZS5mb3JFYWNoKCh0eXBlMikgPT4gYm91bmRyeS5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0eXBlMikpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSBkaXYgYnV0dG9uIHByZXNzIHRvIHBpeGkncyBFdmVudFN5c3RlbSAoY2xpY2spXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBjbGljayBldmVudC5cbiAgICovXG4gIF9vbkNsaWNrKGUpIHtcbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcImNsaWNrXCIsIFwicG9pbnRlcnRhcFwiLCBcInRhcFwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aSdzIEV2ZW50U3lzdGVtIChtb3VzZW92ZXIpXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZSAtIFRoZSBmb2N1cyBldmVudC5cbiAgICovXG4gIF9vbkZvY3VzKGUpIHtcbiAgICBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIikgfHwgZS50YXJnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwiYXNzZXJ0aXZlXCIpLCB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcIm1vdXNlb3ZlclwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aSdzIEV2ZW50U3lzdGVtIChtb3VzZW91dClcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGb2N1c0V2ZW50fSBlIC0gVGhlIGZvY3Vzb3V0IGV2ZW50LlxuICAgKi9cbiAgX29uRm9jdXNPdXQoZSkge1xuICAgIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSB8fCBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIiksIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZSwgW1wibW91c2VvdXRcIl0pO1xuICB9XG4gIC8qKlxuICAgKiBJcyBjYWxsZWQgd2hlbiBhIGtleSBpcyBwcmVzc2VkXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIFRoZSBrZXlkb3duIGV2ZW50LlxuICAgKi9cbiAgX29uS2V5RG93bihlKSB7XG4gICAgZS5rZXlDb2RlID09PSBLRVlfQ09ERV9UQUIgJiYgdGhpcy5hY3RpdmF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICovXG4gIF9vbk1vdXNlTW92ZShlKSB7XG4gICAgZS5tb3ZlbWVudFggPT09IDAgJiYgZS5tb3ZlbWVudFkgPT09IDAgfHwgdGhpcy5kZWFjdGl2YXRlKCk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBhY2Nlc3NpYmlsaXR5IG1hbmFnZXIgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lUb3VjaEhvb2soKSwgdGhpcy5kaXYgPSBudWxsLCBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsICEwKSwgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24pLCB0aGlzLnBvb2wgPSBudWxsLCB0aGlzLmNoaWxkcmVuID0gbnVsbCwgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJhY2Nlc3NpYmlsaXR5XCIsXG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyUGx1Z2luLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJQbHVnaW5cbiAgXVxufTtcbmV4dGVuc2lvbnMuYWRkKEFjY2Vzc2liaWxpdHlNYW5hZ2VyKTtcbmV4cG9ydCB7XG4gIEFjY2Vzc2liaWxpdHlNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWNjZXNzaWJpbGl0eU1hbmFnZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQWNjZXNzaWJpbGl0eU1hbmFnZXIgfSBmcm9tIFwiLi9BY2Nlc3NpYmlsaXR5TWFuYWdlci5tanNcIjtcbmltcG9ydCB7IGFjY2Vzc2libGVUYXJnZXQgfSBmcm9tIFwiLi9hY2Nlc3NpYmxlVGFyZ2V0Lm1qc1wiO1xuZXhwb3J0IHtcbiAgQWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gIGFjY2Vzc2libGVUYXJnZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIsIGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmNvbnN0IF9BcHBsaWNhdGlvbiA9IGNsYXNzIF9BcHBsaWNhdGlvbjIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9uYWwgYXBwbGljYXRpb24gYW5kIHJlbmRlcmVyIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBDb250YWluZXIoKSwgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZm9yY2VDYW52YXM6ICExXG4gICAgfSwgb3B0aW9ucyksIHRoaXMucmVuZGVyZXIgPSBhdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucyksIF9BcHBsaWNhdGlvbjIuX3BsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBwbHVnaW4uaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBSZW5kZXIgdGhlIGN1cnJlbnQgc3RhZ2UuICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnN0YWdlKTtcbiAgfVxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlcidzIGNhbnZhcyBlbGVtZW50LlxuICAgKiBAbWVtYmVyIHtQSVhJLklDYW52YXN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI/LnZpZXc7XG4gIH1cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBzY3JlZW4gcmVjdGFuZ2xlLiBJdHMgc2FmZSB0byB1c2UgYXMgYGZpbHRlckFyZWFgIG9yIGBoaXRBcmVhYCBmb3IgdGhlIHdob2xlIHNjcmVlbi5cbiAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcj8uc2NyZWVuO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBBdXRvbWF0aWNhbGx5IHJlbW92ZSBjYW52YXMgZnJvbSBET00uXG4gICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtzdGFnZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWdlT3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnc3RhZ2VPcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RhZ2VPcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIHN0YWdlT3B0aW9ucy5jaGlsZHJlbiBpcyBzZXRcbiAgICogIHRvIHRydWUuIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RhZ2VPcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBzdGFnZU9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0XG4gICAqICB0byB0cnVlLiBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICovXG4gIGRlc3Ryb3kocmVtb3ZlVmlldywgc3RhZ2VPcHRpb25zKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IF9BcHBsaWNhdGlvbjIuX3BsdWdpbnMuc2xpY2UoMCk7XG4gICAgcGx1Z2lucy5yZXZlcnNlKCksIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBwbHVnaW4uZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH0pLCB0aGlzLnN0YWdlLmRlc3Ryb3koc3RhZ2VPcHRpb25zKSwgdGhpcy5zdGFnZSA9IG51bGwsIHRoaXMucmVuZGVyZXIuZGVzdHJveShyZW1vdmVWaWV3KSwgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG5fQXBwbGljYXRpb24uX3BsdWdpbnMgPSBbXTtcbmxldCBBcHBsaWNhdGlvbiA9IF9BcHBsaWNhdGlvbjtcbmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuQXBwbGljYXRpb24sIEFwcGxpY2F0aW9uLl9wbHVnaW5zKTtcbmV4cG9ydCB7XG4gIEFwcGxpY2F0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIFBJWEkuQXBwbGljYXRpb24jXG4gICAgICAgKi9cbiAgICAgIHtcbiAgICAgICAgc2V0KGRvbSkge1xuICAgICAgICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKSwgdGhpcy5fcmVzaXplVG8gPSBkb20sIGRvbSAmJiAoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpLCB0aGlzLnJlc2l6ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVUbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksIHRoaXMucXVldWVSZXNpemUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9yZXNpemVUbyAmJiAodGhpcy5jYW5jZWxSZXNpemUoKSwgdGhpcy5fcmVzaXplSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5yZXNpemUoKSkpO1xuICAgIH0sIHRoaXMuY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcmVzaXplSWQgJiYgKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKSwgdGhpcy5fcmVzaXplSWQgPSBudWxsKTtcbiAgICB9LCB0aGlzLnJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzaXplVG8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpXG4gICAgICAgIHdpZHRoID0gZ2xvYmFsVGhpcy5pbm5lcldpZHRoLCBoZWlnaHQgPSBnbG9iYWxUaGlzLmlubmVySGVpZ2h0O1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gdGhpcy5fcmVzaXplVG87XG4gICAgICAgIHdpZHRoID0gY2xpZW50V2lkdGgsIGhlaWdodCA9IGNsaWVudEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpLCB0aGlzLnJlbmRlcigpO1xuICAgIH0sIHRoaXMuX3Jlc2l6ZUlkID0gbnVsbCwgdGhpcy5fcmVzaXplVG8gPSBudWxsLCB0aGlzLnJlc2l6ZVRvID0gb3B0aW9ucy5yZXNpemVUbyB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0aGUgdGlja2VyLCBzY29wZWQgdG8gYXBwbGljYXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpLCB0aGlzLmNhbmNlbFJlc2l6ZSgpLCB0aGlzLmNhbmNlbFJlc2l6ZSA9IG51bGwsIHRoaXMucXVldWVSZXNpemUgPSBudWxsLCB0aGlzLnJlc2l6ZVRvID0gbnVsbCwgdGhpcy5yZXNpemUgPSBudWxsO1xuICB9XG59XG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcbmV4dGVuc2lvbnMuYWRkKFJlc2l6ZVBsdWdpbik7XG5leHBvcnQge1xuICBSZXNpemVQbHVnaW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tIFwiLi9BcHBsaWNhdGlvbi5tanNcIjtcbmltcG9ydCB7IFJlc2l6ZVBsdWdpbiB9IGZyb20gXCIuL1Jlc2l6ZVBsdWdpbi5tanNcIjtcbmV4cG9ydCB7XG4gIEFwcGxpY2F0aW9uLFxuICBSZXNpemVQbHVnaW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmNvbnN0IGFzc2V0S2V5TWFwID0ge1xuICBsb2FkZXI6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgcmVzb2x2ZXI6IEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlcixcbiAgY2FjaGU6IEV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIGRldGVjdGlvbjogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXJcbn07XG5leHRlbnNpb25zLmhhbmRsZShFeHRlbnNpb25UeXBlLkFzc2V0LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5lbnRyaWVzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKFtrZXldKSA9PiAhIXJlZltrZXldKS5mb3JFYWNoKChba2V5LCB0eXBlXSkgPT4gZXh0ZW5zaW9ucy5hZGQoT2JqZWN0LmFzc2lnbihcbiAgICByZWZba2V5XSxcbiAgICAvLyBBbGxvdyB0aGUgZnVuY3Rpb24gdG8gb3B0aW9uYWxseSBkZWZpbmUgaXQncyBvd25cbiAgICAvLyBFeHRlbnNpb25NZXRhZGF0YSwgdGhlIHVzZSBjYXNlcyBoZXJlIGlzIHByaW9yaXR5IGZvciBMb2FkZXJQYXJzZXJzXG4gICAgeyBleHRlbnNpb246IHJlZltrZXldLmV4dGVuc2lvbiA/PyB0eXBlIH1cbiAgKSkpO1xufSwgKGV4dGVuc2lvbikgPT4ge1xuICBjb25zdCByZWYgPSBleHRlbnNpb24ucmVmO1xuICBPYmplY3Qua2V5cyhhc3NldEtleU1hcCkuZmlsdGVyKChrZXkpID0+ICEhcmVmW2tleV0pLmZvckVhY2goKGtleSkgPT4gZXh0ZW5zaW9ucy5yZW1vdmUocmVmW2tleV0pKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXRFeHRlbnNpb24ubWpzLm1hcFxuIiwiY2xhc3MgQmFja2dyb3VuZExvYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbG9hZGVyXG4gICAqIEBwYXJhbSB2ZXJib3NlIC0gc2hvdWxkIHRoZSBsb2FkZXIgbG9nIHRvIHRoZSBjb25zb2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2FkZXIsIHZlcmJvc2UgPSAhMSkge1xuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlciwgdGhpcy5fYXNzZXRMaXN0ID0gW10sIHRoaXMuX2lzTG9hZGluZyA9ICExLCB0aGlzLl9tYXhDb25jdXJyZW50ID0gMSwgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhcnJheSBvZiBhc3NldHMgdG8gbG9hZC5cbiAgICogQHBhcmFtIGFzc2V0VXJscyAtIGFzc2V0cyB0byBsb2FkXG4gICAqL1xuICBhZGQoYXNzZXRVcmxzKSB7XG4gICAgYXNzZXRVcmxzLmZvckVhY2goKGEpID0+IHtcbiAgICAgIHRoaXMuX2Fzc2V0TGlzdC5wdXNoKGEpO1xuICAgIH0pLCB0aGlzLnZlcmJvc2UgJiYgY29uc29sZS5sb2coXCJbQmFja2dyb3VuZExvYWRlcl0gYXNzZXRzOiBcIiwgdGhpcy5fYXNzZXRMaXN0KSwgdGhpcy5faXNBY3RpdmUgJiYgIXRoaXMuX2lzTG9hZGluZyAmJiB0aGlzLl9uZXh0KCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBuZXh0IHNldCBvZiBhc3NldHMuIFdpbGwgdHJ5IHRvIGxvYWQgYXMgbWFueSBhc3NldHMgYXMgaXQgY2FuIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqXG4gICAqIFRoZSBtYXggYXNzZXRzIGl0IHdpbGwgdHJ5IHRvIGxvYWQgYXQgb25lIHRpbWUgd2lsbCBiZSA0LlxuICAgKi9cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuX2Fzc2V0TGlzdC5sZW5ndGggJiYgdGhpcy5faXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuX2lzTG9hZGluZyA9ICEwO1xuICAgICAgY29uc3QgdG9Mb2FkID0gW10sIHRvTG9hZEFtb3VudCA9IE1hdGgubWluKHRoaXMuX2Fzc2V0TGlzdC5sZW5ndGgsIHRoaXMuX21heENvbmN1cnJlbnQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b0xvYWRBbW91bnQ7IGkrKylcbiAgICAgICAgdG9Mb2FkLnB1c2godGhpcy5fYXNzZXRMaXN0LnBvcCgpKTtcbiAgICAgIGF3YWl0IHRoaXMuX2xvYWRlci5sb2FkKHRvTG9hZCksIHRoaXMuX2lzTG9hZGluZyA9ICExLCB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBY3RpdmF0ZS9EZWFjdGl2YXRlIHRoZSBsb2FkaW5nLiBJZiBzZXQgdG8gdHJ1ZSB0aGVuIGl0IHdpbGwgaW1tZWRpYXRlbHkgY29udGludWUgdG8gbG9hZCB0aGUgbmV4dCBhc3NldC5cbiAgICogQHJldHVybnMgd2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlXG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgfVxuICBzZXQgYWN0aXZlKHZhbHVlKSB7XG4gICAgdGhpcy5faXNBY3RpdmUgIT09IHZhbHVlICYmICh0aGlzLl9pc0FjdGl2ZSA9IHZhbHVlLCB2YWx1ZSAmJiAhdGhpcy5faXNMb2FkaW5nICYmIHRoaXMuX25leHQoKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEJhY2tncm91bmRMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kTG9hZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmZ1bmN0aW9uIGNoZWNrRXh0ZW5zaW9uKHVybCwgZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IHRlbXBVUkwgPSB1cmwuc3BsaXQoXCI/XCIpWzBdLCBleHQgPSB1dGlscy5wYXRoLmV4dG5hbWUodGVtcFVSTCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9uKSA/IGV4dGVuc2lvbi5pbmNsdWRlcyhleHQpIDogZXh0ID09PSBleHRlbnNpb247XG59XG5leHBvcnQge1xuICBjaGVja0V4dGVuc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrRXh0ZW5zaW9uLm1qcy5tYXBcbiIsImltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gXCIuL2NoZWNrRGF0YVVybC5tanNcIjtcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSBcIi4vY2hlY2tFeHRlbnNpb24ubWpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSBcIi4vY29udmVydFRvTGlzdC5tanNcIjtcbmltcG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tIFwiLi9jb3B5U2VhcmNoUGFyYW1zLm1qc1wiO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyB9IGZyb20gXCIuL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzXCI7XG5pbXBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tIFwiLi9pc1NpbmdsZUl0ZW0ubWpzXCI7XG5leHBvcnQge1xuICBjaGVja0RhdGFVcmwsXG4gIGNoZWNrRXh0ZW5zaW9uLFxuICBjb252ZXJ0VG9MaXN0LFxuICBjb3B5U2VhcmNoUGFyYW1zLFxuICBjcmVhdGVTdHJpbmdWYXJpYXRpb25zLFxuICBpc1NpbmdsZUl0ZW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjb25zdCBjb252ZXJ0VG9MaXN0ID0gKGlucHV0LCB0cmFuc2Zvcm0sIGZvcmNlVHJhbnNmb3JtID0gITEpID0+IChBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQgPSBbaW5wdXRdKSwgdHJhbnNmb3JtID8gaW5wdXQubWFwKChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PSBcInN0cmluZ1wiIHx8IGZvcmNlVHJhbnNmb3JtID8gdHJhbnNmb3JtKGl0ZW0pIDogaXRlbSkgOiBpbnB1dCk7XG5leHBvcnQge1xuICBjb252ZXJ0VG9MaXN0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydFRvTGlzdC5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBCYXNlVGV4dHVyZSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgXCIuLi91dGlscy9pbmRleC5tanNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb0xpc3QgfSBmcm9tIFwiLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanNcIjtcbmNsYXNzIENhY2hlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJzZXJzID0gW10sIHRoaXMuX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fY2FjaGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8qKiBDbGVhciBhbGwgZW50cmllcy4gKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fY2FjaGVNYXAuY2xlYXIoKSwgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGtleSBleGlzdHNcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2tcbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGVudHJ5IGJ5IGtleVxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gZ2V0XG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FjaGUuZ2V0KGtleSk7XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBjb25zb2xlLndhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApLCByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGJ5IGtleSBvciBrZXlzIG5hbWVcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb3Iga2V5cyB0byBzZXRcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoZSBjYWNoZSBvciBmcm9tIHdoaWNoIGNhY2hlYWJsZSBhc3NldHMgd2lsbCBiZSBkZXJpdmVkLlxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gY29udmVydFRvTGlzdChrZXkpO1xuICAgIGxldCBjYWNoZWFibGVBc3NldHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2Vyc1tpXTtcbiAgICAgIGlmIChwYXJzZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY2FjaGVhYmxlQXNzZXRzID0gcGFyc2VyLmdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWFibGVBc3NldHMgfHwgKGNhY2hlYWJsZUFzc2V0cyA9IHt9LCBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIGNhY2hlYWJsZUFzc2V0c1trZXkyXSA9IHZhbHVlO1xuICAgIH0pKTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZWFibGVBc3NldHMpLCBjYWNoZWRBc3NldHMgPSB7XG4gICAgICBjYWNoZUtleXMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBpZiAoa2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICB0aGlzLl9jYWNoZU1hcC5zZXQoa2V5MiwgY2FjaGVkQXNzZXRzKTtcbiAgICB9KSwgY2FjaGVLZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlLmhhcyhrZXkyKSAmJiB0aGlzLl9jYWNoZS5nZXQoa2V5MikgIT09IHZhbHVlICYmIGNvbnNvbGUud2FybihcIltDYWNoZV0gYWxyZWFkeSBoYXMga2V5OlwiLCBrZXkyKSwgdGhpcy5fY2FjaGUuc2V0KGtleTIsIGNhY2hlYWJsZUFzc2V0c1trZXkyXSk7XG4gICAgfSksIHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHZhbHVlO1xuICAgICAga2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUgIT09IFRleHR1cmUuRU1QVFkuYmFzZVRleHR1cmUgJiYgQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBrZXkyKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGtleTIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgZW50cnkgYnkga2V5XG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIHJlbW92ZSBhbnkgYXNzb2NpYXRlZCBhbGlhcyBmcm9tIHRoZSBjYWNoZSBhbHNvLlxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmUoa2V5KSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZU1hcC5oYXMoa2V5KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcC5nZXQoa2V5KTtcbiAgICBjYWNoZU1hcC5jYWNoZUtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGtleTIpO1xuICAgIH0pLCBjYWNoZU1hcC5rZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLmRlbGV0ZShrZXkyKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQWxsIGxvYWRlciBwYXJzZXJzIHJlZ2lzdGVyZWQgKi9cbiAgZ2V0IHBhcnNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlcnM7XG4gIH1cbn1cbmNvbnN0IENhY2hlID0gbmV3IENhY2hlQ2xhc3MoKTtcbmV4cG9ydCB7XG4gIENhY2hlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGUubWpzLm1hcFxuIiwiY29uc3QgaXNTaW5nbGVJdGVtID0gKGl0ZW0pID0+ICFBcnJheS5pc0FycmF5KGl0ZW0pO1xuZXhwb3J0IHtcbiAgaXNTaW5nbGVJdGVtXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTaW5nbGVJdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCBcIi4uL3V0aWxzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSBcIi4uL3V0aWxzL2lzU2luZ2xlSXRlbS5tanNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb0xpc3QgfSBmcm9tIFwiLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanNcIjtcbmNsYXNzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXSwgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9ICExLCB0aGlzLnBhcnNlcnMgPSBuZXcgUHJveHkodGhpcy5fcGFyc2Vycywge1xuICAgICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiAodGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9ICExLCB0YXJnZXRba2V5XSA9IHZhbHVlLCAhMClcbiAgICB9KSwgdGhpcy5wcm9taXNlQ2FjaGUgPSB7fTtcbiAgfVxuICAvKiogZnVuY3Rpb24gdXNlZCBmb3IgdGVzdGluZyAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gITEsIHRoaXMucHJvbWlzZUNhY2hlID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSB0byBnZW5lcmF0ZSBhIHByb21pc2UgZm9yIHRoZSBhc3NldCB0byBiZSBsb2FkZWQuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGJlIGxvYWRlZFxuICAgKiBAcGFyYW0gZGF0YSAtIGFueSBjdXN0b20gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWxldmFudCB0byB0aGUgYXNzZXQgYmVpbmcgbG9hZGVkXG4gICAqIEByZXR1cm5zIC0gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGFuIEFzc2V0IGZvciBleGFtcGxlIGEgVGV4dHVyZSBvZiBhIEpTT04gb2JqZWN0XG4gICAqL1xuICBfZ2V0TG9hZFByb21pc2VBbmRQYXJzZXIodXJsLCBkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgIHBhcnNlcjogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhc3NldCA9IG51bGwsIHBhcnNlciA9IG51bGw7XG4gICAgICBpZiAoZGF0YS5sb2FkUGFyc2VyICYmIChwYXJzZXIgPSB0aGlzLl9wYXJzZXJIYXNoW2RhdGEubG9hZFBhcnNlcl0sIHBhcnNlciB8fCBjb25zb2xlLndhcm4oYFtBc3NldHNdIHNwZWNpZmllZCBsb2FkIHBhcnNlciBcIiR7ZGF0YS5sb2FkUGFyc2VyfVwiIG5vdCBmb3VuZCB3aGlsZSBsb2FkaW5nICR7dXJsfWApKSwgIXBhcnNlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlclggPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICAgICAgaWYgKHBhcnNlclgubG9hZCAmJiBwYXJzZXJYLnRlc3Q/Lih1cmwsIGRhdGEsIHRoaXMpKSB7XG4gICAgICAgICAgICBwYXJzZXIgPSBwYXJzZXJYO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VyKVxuICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYFtBc3NldHNdICR7dXJsfSBjb3VsZCBub3QgYmUgbG9hZGVkIGFzIHdlIGRvbid0IGtub3cgaG93IHRvIHBhcnNlIGl0LCBlbnN1cmUgdGhlIGNvcnJlY3QgcGFyc2VyIGhhcyBiZWVuIGFkZGVkYCksIG51bGw7XG4gICAgICB9XG4gICAgICBhc3NldCA9IGF3YWl0IHBhcnNlci5sb2FkKHVybCwgZGF0YSwgdGhpcyksIHJlc3VsdC5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJzZXIyID0gdGhpcy5wYXJzZXJzW2ldO1xuICAgICAgICBwYXJzZXIyLnBhcnNlICYmIHBhcnNlcjIucGFyc2UgJiYgYXdhaXQgcGFyc2VyMi50ZXN0UGFyc2U/Lihhc3NldCwgZGF0YSwgdGhpcykgJiYgKGFzc2V0ID0gYXdhaXQgcGFyc2VyMi5wYXJzZShhc3NldCwgZGF0YSwgdGhpcykgfHwgYXNzZXQsIHJlc3VsdC5wYXJzZXIgPSBwYXJzZXIyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NldDtcbiAgICB9KSgpLCByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbG9hZChhc3NldHNUb0xvYWRJbiwgb25Qcm9ncmVzcykge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgfHwgdGhpcy5fdmFsaWRhdGVQYXJzZXJzKCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBhc3NldHMgPSB7fSwgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oYXNzZXRzVG9Mb2FkSW4pLCBhc3NldHNUb0xvYWQgPSBjb252ZXJ0VG9MaXN0KGFzc2V0c1RvTG9hZEluLCAoaXRlbSkgPT4gKHtcbiAgICAgIGFsaWFzOiBbaXRlbV0sXG4gICAgICBzcmM6IGl0ZW1cbiAgICB9KSksIHRvdGFsID0gYXNzZXRzVG9Mb2FkLmxlbmd0aCwgcHJvbWlzZXMgPSBhc3NldHNUb0xvYWQubWFwKGFzeW5jIChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gdXRpbHMucGF0aC50b0Fic29sdXRlKGFzc2V0LnNyYyk7XG4gICAgICBpZiAoIWFzc2V0c1thc3NldC5zcmNdKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucHJvbWlzZUNhY2hlW3VybF0gfHwgKHRoaXMucHJvbWlzZUNhY2hlW3VybF0gPSB0aGlzLl9nZXRMb2FkUHJvbWlzZUFuZFBhcnNlcih1cmwsIGFzc2V0KSksIGFzc2V0c1thc3NldC5zcmNdID0gYXdhaXQgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXS5wcm9taXNlLCBvblByb2dyZXNzICYmIG9uUHJvZ3Jlc3MoKytjb3VudCAvIHRvdGFsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGRlbGV0ZSB0aGlzLnByb21pc2VDYWNoZVt1cmxdLCBkZWxldGUgYXNzZXRzW2Fzc2V0LnNyY10sIG5ldyBFcnJvcihgW0xvYWRlci5sb2FkXSBGYWlsZWQgdG8gbG9hZCAke3VybH0uXG4ke2V9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpLCBzaW5nbGVBc3NldCA/IGFzc2V0c1thc3NldHNUb0xvYWRbMF0uc3JjXSA6IGFzc2V0cztcbiAgfVxuICAvKipcbiAgICogVW5sb2FkcyBvbmUgb3IgbW9yZSBhc3NldHMuIEFueSB1bmxvYWRlZCBhc3NldHMgd2lsbCBiZSBkZXN0cm95ZWQsIGZyZWVpbmcgdXAgbWVtb3J5IGZvciB5b3VyIGFwcC5cbiAgICogVGhlIHBhcnNlciB0aGF0IGNyZWF0ZWQgdGhlIGFzc2V0LCB3aWxsIGJlIHRoZSBvbmUgdGhhdCB1bmxvYWRzIGl0LlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTaW5nbGUgYXNzZXQ6XG4gICAqIGNvbnN0IGFzc2V0ID0gYXdhaXQgTG9hZGVyLmxvYWQoJ2Nvb2wucG5nJyk7XG4gICAqXG4gICAqIGF3YWl0IExvYWRlci51bmxvYWQoJ2Nvb2wucG5nJyk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGFzc2V0LmRlc3Ryb3llZCk7IC8vIHRydWVcbiAgICogQHBhcmFtIGFzc2V0c1RvVW5sb2FkSW4gLSB1cmxzIHRoYXQgeW91IHdhbnQgdG8gdW5sb2FkLCBvciBhIHNpbmdsZSBvbmUhXG4gICAqL1xuICBhc3luYyB1bmxvYWQoYXNzZXRzVG9VbmxvYWRJbikge1xuICAgIGNvbnN0IHByb21pc2VzID0gY29udmVydFRvTGlzdChhc3NldHNUb1VubG9hZEluLCAoaXRlbSkgPT4gKHtcbiAgICAgIGFsaWFzOiBbaXRlbV0sXG4gICAgICBzcmM6IGl0ZW1cbiAgICB9KSkubWFwKGFzeW5jIChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gdXRpbHMucGF0aC50b0Fic29sdXRlKGFzc2V0LnNyYyksIGxvYWRQcm9taXNlID0gdGhpcy5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgICAgIGlmIChsb2FkUHJvbWlzZSkge1xuICAgICAgICBjb25zdCBsb2FkZWRBc3NldCA9IGF3YWl0IGxvYWRQcm9taXNlLnByb21pc2U7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VDYWNoZVt1cmxdLCBsb2FkUHJvbWlzZS5wYXJzZXI/LnVubG9hZD8uKGxvYWRlZEFzc2V0LCBhc3NldCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIC8qKiB2YWxpZGF0ZXMgb3VyIHBhcnNlcnMsIHJpZ2h0IG5vdyBpdCBvbmx5IGNoZWNrcyBmb3IgbmFtZSBjb25mbGljdHMgYnV0IHdlIGNhbiBhZGQgbW9yZSBoZXJlIGFzIHJlcXVpcmVkISAqL1xuICBfdmFsaWRhdGVQYXJzZXJzKCkge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSAhMCwgdGhpcy5fcGFyc2VySGFzaCA9IHRoaXMuX3BhcnNlcnMuZmlsdGVyKChwYXJzZXIpID0+IHBhcnNlci5uYW1lKS5yZWR1Y2UoKGhhc2gsIHBhcnNlcikgPT4gKGhhc2hbcGFyc2VyLm5hbWVdICYmIGNvbnNvbGUud2FybihgW0Fzc2V0c10gbG9hZFBhcnNlciBuYW1lIGNvbmZsaWN0IFwiJHtwYXJzZXIubmFtZX1cImApLCB7IC4uLmhhc2gsIFtwYXJzZXIubmFtZV06IHBhcnNlciB9KSwge30pO1xuICB9XG59XG5leHBvcnQge1xuICBMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2FkZXIubWpzLm1hcFxuIiwidmFyIExvYWRlclBhcnNlclByaW9yaXR5ID0gLyogQF9fUFVSRV9fICovICgoTG9hZGVyUGFyc2VyUHJpb3JpdHkyKSA9PiAoTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5Mi5Mb3cgPSAwXSA9IFwiTG93XCIsIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTIuTm9ybWFsID0gMV0gPSBcIk5vcm1hbFwiLCBMb2FkZXJQYXJzZXJQcmlvcml0eTJbTG9hZGVyUGFyc2VyUHJpb3JpdHkyLkhpZ2ggPSAyXSA9IFwiSGlnaFwiLCBMb2FkZXJQYXJzZXJQcmlvcml0eTIpKShMb2FkZXJQYXJzZXJQcmlvcml0eSB8fCB7fSk7XG5leHBvcnQge1xuICBMb2FkZXJQYXJzZXJQcmlvcml0eVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclBhcnNlci5tanMubWFwXG4iLCJmdW5jdGlvbiBjaGVja0RhdGFVcmwodXJsLCBtaW1lcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtaW1lcykpIHtcbiAgICBmb3IgKGNvbnN0IG1pbWUgb2YgbWltZXMpXG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoYGRhdGE6JHttaW1lfWApKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChgZGF0YToke21pbWVzfWApO1xufVxuZXhwb3J0IHtcbiAgY2hlY2tEYXRhVXJsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tEYXRhVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gXCIuLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzXCI7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gXCIuLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanNcIjtcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSBcIi4vTG9hZGVyUGFyc2VyLm1qc1wiO1xuY29uc3QgdmFsaWRKU09ORXh0ZW5zaW9uID0gXCIuanNvblwiLCB2YWxpZEpTT05NSU1FID0gXCJhcHBsaWNhdGlvbi9qc29uXCIsIGxvYWRKc29uID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICBuYW1lOiBcImxvYWRKc29uXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkSlNPTk1JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRKU09ORXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICByZXR1cm4gYXdhaXQgKGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKSkuanNvbigpO1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZEpzb24pO1xuZXhwb3J0IHtcbiAgbG9hZEpzb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkSnNvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tIFwiLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qc1wiO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tIFwiLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzXCI7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gXCIuL0xvYWRlclBhcnNlci5tanNcIjtcbmNvbnN0IHZhbGlkVFhURXh0ZW5zaW9uID0gXCIudHh0XCIsIHZhbGlkVFhUTUlNRSA9IFwidGV4dC9wbGFpblwiLCBsb2FkVHh0ID0ge1xuICBuYW1lOiBcImxvYWRUeHRcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Mb3dcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRUWFRNSU1FKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkVFhURXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICByZXR1cm4gYXdhaXQgKGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKSkudGV4dCgpO1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFR4dCk7XG5leHBvcnQge1xuICBsb2FkVHh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFR4dC5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscywgRXh0ZW5zaW9uVHlwZSwgc2V0dGluZ3MsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanNcIjtcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qc1wiO1xuaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tIFwiLi9Mb2FkZXJQYXJzZXIubWpzXCI7XG5jb25zdCB2YWxpZFdlaWdodHMgPSBbXG4gIFwibm9ybWFsXCIsXG4gIFwiYm9sZFwiLFxuICBcIjEwMFwiLFxuICBcIjIwMFwiLFxuICBcIjMwMFwiLFxuICBcIjQwMFwiLFxuICBcIjUwMFwiLFxuICBcIjYwMFwiLFxuICBcIjcwMFwiLFxuICBcIjgwMFwiLFxuICBcIjkwMFwiXG5dLCB2YWxpZEZvbnRFeHRlbnNpb25zID0gW1wiLnR0ZlwiLCBcIi5vdGZcIiwgXCIud29mZlwiLCBcIi53b2ZmMlwiXSwgdmFsaWRGb250TUlNRXMgPSBbXG4gIFwiZm9udC90dGZcIixcbiAgXCJmb250L290ZlwiLFxuICBcImZvbnQvd29mZlwiLFxuICBcImZvbnQvd29mZjJcIlxuXSwgQ1NTX0lERU5UX1RPS0VOX1JFR0VYID0gL14oLS18LT9bQS1aX10pWzAtOUEtWl8tXSokL2k7XG5mdW5jdGlvbiBnZXRGb250RmFtaWx5TmFtZSh1cmwpIHtcbiAgY29uc3QgZXh0ID0gdXRpbHMucGF0aC5leHRuYW1lKHVybCksIG5hbWVUb2tlbnMgPSB1dGlscy5wYXRoLmJhc2VuYW1lKHVybCwgZXh0KS5yZXBsYWNlKC8oLXxfKS9nLCBcIiBcIikudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIikubWFwKCh3b3JkKSA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gIGxldCB2YWxpZCA9IG5hbWVUb2tlbnMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBuYW1lVG9rZW5zKVxuICAgIGlmICghdG9rZW4ubWF0Y2goQ1NTX0lERU5UX1RPS0VOX1JFR0VYKSkge1xuICAgICAgdmFsaWQgPSAhMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgbGV0IGZvbnRGYW1pbHlOYW1lID0gbmFtZVRva2Vucy5qb2luKFwiIFwiKTtcbiAgcmV0dXJuIHZhbGlkIHx8IChmb250RmFtaWx5TmFtZSA9IGBcIiR7Zm9udEZhbWlseU5hbWUucmVwbGFjZSgvW1xcXFxcIl0vZywgXCJcXFxcJCZcIil9XCJgKSwgZm9udEZhbWlseU5hbWU7XG59XG5jb25zdCB2YWxpZFVSSUNoYXJhY3RlcnNSZWdleCA9IC9eWzAtOUEtWmEteiU6Lz8jXFxbXFxdQCFcXCQmJygpXFwqXFwrLDs9XFwtLl9+XSokLztcbmZ1bmN0aW9uIGVuY29kZVVSSVdoZW5OZWVkZWQodXJpKSB7XG4gIHJldHVybiB2YWxpZFVSSUNoYXJhY3RlcnNSZWdleC50ZXN0KHVyaSkgPyB1cmkgOiBlbmNvZGVVUkkodXJpKTtcbn1cbmNvbnN0IGxvYWRXZWJGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICBuYW1lOiBcImxvYWRXZWJGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkRm9udE1JTUVzKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkRm9udEV4dGVuc2lvbnMpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvbnRzID0gc2V0dGluZ3MuQURBUFRFUi5nZXRGb250RmFjZVNldCgpO1xuICAgIGlmIChmb250cykge1xuICAgICAgY29uc3QgZm9udEZhY2VzID0gW10sIG5hbWUgPSBvcHRpb25zLmRhdGE/LmZhbWlseSA/PyBnZXRGb250RmFtaWx5TmFtZSh1cmwpLCB3ZWlnaHRzID0gb3B0aW9ucy5kYXRhPy53ZWlnaHRzPy5maWx0ZXIoKHdlaWdodCkgPT4gdmFsaWRXZWlnaHRzLmluY2x1ZGVzKHdlaWdodCkpID8/IFtcIm5vcm1hbFwiXSwgZGF0YSA9IG9wdGlvbnMuZGF0YSA/PyB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzW2ldLCBmb250ID0gbmV3IEZvbnRGYWNlKG5hbWUsIGB1cmwoJHtlbmNvZGVVUklXaGVuTmVlZGVkKHVybCl9KWAsIHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIHdlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgZm9udC5sb2FkKCksIGZvbnRzLmFkZChmb250KSwgZm9udEZhY2VzLnB1c2goZm9udCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9udEZhY2VzLmxlbmd0aCA9PT0gMSA/IGZvbnRGYWNlc1swXSA6IGZvbnRGYWNlcztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcIltsb2FkV2ViRm9udF0gRm9udEZhY2UgQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIFNraXBwaW5nIGxvYWRpbmcgZm9udFwiKSwgbnVsbDtcbiAgfSxcbiAgdW5sb2FkKGZvbnQpIHtcbiAgICAoQXJyYXkuaXNBcnJheShmb250KSA/IGZvbnQgOiBbZm9udF0pLmZvckVhY2goKHQpID0+IHNldHRpbmdzLkFEQVBURVIuZ2V0Rm9udEZhY2VTZXQoKS5kZWxldGUodCkpO1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFdlYkZvbnQpO1xuZXhwb3J0IHtcbiAgZ2V0Rm9udEZhbWlseU5hbWUsXG4gIGxvYWRXZWJGb250XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFdlYkZvbnQubWpzLm1hcFxuIiwibGV0IFVVSUQgPSAwLCBNQVhfV09SS0VSUztcbmNvbnN0IFdISVRFX1BORyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FRQUFBQzFIQXdDQUFBQUMwbEVRVlI0Mm1QOC94OEFBd01DQU8raXAxc0FBQUFBU1VWT1JLNUNZSUk9XCIsIGNoZWNrSW1hZ2VCaXRtYXBDb2RlID0ge1xuICBpZDogXCJjaGVja0ltYWdlQml0bWFwXCIsXG4gIGNvZGU6IGBcbiAgICBhc3luYyBmdW5jdGlvbiBjaGVja0ltYWdlQml0bWFwKClcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJyR7V0hJVEVfUE5HfScpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gIGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iKTtcblxuICAgICAgICAgICAgcmV0dXJuIGltYWdlQml0bWFwLndpZHRoID09PSAxICYmIGltYWdlQml0bWFwLmhlaWdodCA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1hZ2VCaXRtYXAoKS50aGVuKChyZXN1bHQpID0+IHsgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQpOyB9KTtcbiAgICBgXG59LCB3b3JrZXJDb2RlID0ge1xuICBpZDogXCJsb2FkSW1hZ2VCaXRtYXBcIixcbiAgY29kZTogYFxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUJpdG1hcCh1cmwpXG4gICAge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYFtXb3JrZXJNYW5hZ2VyLmxvYWRJbWFnZUJpdG1hcF0gRmFpbGVkIHRvIGZldGNoIFxcJHt1cmx9OiBcXGBcbiAgICAgICAgICAgICAgICArIFxcYFxcJHtyZXNwb25zZS5zdGF0dXN9IFxcJHtyZXNwb25zZS5zdGF0dXNUZXh0fVxcYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSAgYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG5cbiAgICAgICAgcmV0dXJuIGltYWdlQml0bWFwO1xuICAgIH1cbiAgICBzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT5cbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGxvYWRJbWFnZUJpdG1hcChldmVudC5kYXRhLmRhdGFbMF0pO1xuXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZUJpdG1hcCxcbiAgICAgICAgICAgICAgICB1dWlkOiBldmVudC5kYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICB9LCBbaW1hZ2VCaXRtYXBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB1dWlkOiBldmVudC5kYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07YFxufTtcbmxldCB3b3JrZXJVUkw7XG5jbGFzcyBXb3JrZXJNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9ICExLCB0aGlzLl9jcmVhdGVkV29ya2VycyA9IDAsIHRoaXMud29ya2VyUG9vbCA9IFtdLCB0aGlzLnF1ZXVlID0gW10sIHRoaXMucmVzb2x2ZUhhc2ggPSB7fTtcbiAgfVxuICBpc0ltYWdlQml0bWFwU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkICE9PSB2b2lkIDAgPyB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkIDogKHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgd29ya2VyVVJMMiA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoXG4gICAgICAgIFtjaGVja0ltYWdlQml0bWFwQ29kZS5jb2RlXSxcbiAgICAgICAgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9XG4gICAgICApKSwgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwyKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpLCBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTDIpLCByZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQpO1xuICB9XG4gIGxvYWRJbWFnZUJpdG1hcChzcmMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVuKFwibG9hZEltYWdlQml0bWFwXCIsIFtzcmNdKTtcbiAgfVxuICBhc3luYyBfaW5pdFdvcmtlcnMoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgKHRoaXMuX2luaXRpYWxpemVkID0gITApO1xuICB9XG4gIGdldFdvcmtlcigpIHtcbiAgICBNQVhfV09SS0VSUyA9PT0gdm9pZCAwICYmIChNQVhfV09SS0VSUyA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDQpO1xuICAgIGxldCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2wucG9wKCk7XG4gICAgcmV0dXJuICF3b3JrZXIgJiYgdGhpcy5fY3JlYXRlZFdvcmtlcnMgPCBNQVhfV09SS0VSUyAmJiAod29ya2VyVVJMIHx8ICh3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3b3JrZXJDb2RlLmNvZGVdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pKSksIHRoaXMuX2NyZWF0ZWRXb3JrZXJzKyssIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKSwgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5jb21wbGV0ZShldmVudC5kYXRhKSwgdGhpcy5yZXR1cm5Xb3JrZXIoZXZlbnQudGFyZ2V0KSwgdGhpcy5uZXh0KCk7XG4gICAgfSkpLCB3b3JrZXI7XG4gIH1cbiAgcmV0dXJuV29ya2VyKHdvcmtlcikge1xuICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcik7XG4gIH1cbiAgY29tcGxldGUoZGF0YSkge1xuICAgIGRhdGEuZXJyb3IgIT09IHZvaWQgMCA/IHRoaXMucmVzb2x2ZUhhc2hbZGF0YS51dWlkXS5yZWplY3QoZGF0YS5lcnJvcikgOiB0aGlzLnJlc29sdmVIYXNoW2RhdGEudXVpZF0ucmVzb2x2ZShkYXRhLmRhdGEpLCB0aGlzLnJlc29sdmVIYXNoW2RhdGEudXVpZF0gPSBudWxsO1xuICB9XG4gIGFzeW5jIF9ydW4oaWQsIGFyZ3MpIHtcbiAgICBhd2FpdCB0aGlzLl9pbml0V29ya2VycygpO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goeyBpZCwgYXJndW1lbnRzOiBhcmdzLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubmV4dCgpLCBwcm9taXNlO1xuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLmdldFdvcmtlcigpO1xuICAgIGlmICghd29ya2VyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRvRG8gPSB0aGlzLnF1ZXVlLnBvcCgpLCBpZCA9IHRvRG8uaWQ7XG4gICAgdGhpcy5yZXNvbHZlSGFzaFtVVUlEXSA9IHsgcmVzb2x2ZTogdG9Eby5yZXNvbHZlLCByZWplY3Q6IHRvRG8ucmVqZWN0IH0sIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICBkYXRhOiB0b0RvLmFyZ3VtZW50cyxcbiAgICAgIHV1aWQ6IFVVSUQrKyxcbiAgICAgIGlkXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFdvcmtlck1hbmFnZXIgPSBuZXcgV29ya2VyTWFuYWdlckNsYXNzKCk7XG5leHBvcnQge1xuICBXb3JrZXJNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyTWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IENhY2hlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2NhY2hlL0NhY2hlLm1qc1wiO1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCkge1xuICBiYXNlLnJlc291cmNlLmludGVybmFsID0gITA7XG4gIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShiYXNlKSwgdW5sb2FkID0gKCkgPT4ge1xuICAgIGRlbGV0ZSBsb2FkZXIucHJvbWlzZUNhY2hlW3VybF0sIENhY2hlLmhhcyh1cmwpICYmIENhY2hlLnJlbW92ZSh1cmwpO1xuICB9O1xuICByZXR1cm4gdGV4dHVyZS5iYXNlVGV4dHVyZS5vbmNlKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICB1cmwgaW4gbG9hZGVyLnByb21pc2VDYWNoZSAmJiAoY29uc29sZS53YXJuKFwiW0Fzc2V0c10gQSBCYXNlVGV4dHVyZSBtYW5hZ2VkIGJ5IEFzc2V0cyB3YXMgZGVzdHJveWVkIGluc3RlYWQgb2YgdW5sb2FkZWQhIFVzZSBBc3NldHMudW5sb2FkKCkgaW5zdGVhZCBvZiBkZXN0cm95aW5nIHRoZSBCYXNlVGV4dHVyZS5cIiksIHVubG9hZCgpKTtcbiAgfSksIHRleHR1cmUub25jZShcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgYmFzZS5kZXN0cm95ZWQgfHwgKGNvbnNvbGUud2FybihcIltBc3NldHNdIEEgVGV4dHVyZSBtYW5hZ2VkIGJ5IEFzc2V0cyB3YXMgZGVzdHJveWVkIGluc3RlYWQgb2YgdW5sb2FkZWQhIFVzZSBBc3NldHMudW5sb2FkKCkgaW5zdGVhZCBvZiBkZXN0cm95aW5nIHRoZSBUZXh0dXJlLlwiKSwgdW5sb2FkKCkpO1xuICB9KSwgdGV4dHVyZTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZVRleHR1cmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVUZXh0dXJlLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCBFeHRlbnNpb25UeXBlLCB1dGlscywgQmFzZVRleHR1cmUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanNcIjtcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qc1wiO1xuaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tIFwiLi4vTG9hZGVyUGFyc2VyLm1qc1wiO1xuaW1wb3J0IHsgV29ya2VyTWFuYWdlciB9IGZyb20gXCIuLi9Xb3JrZXJNYW5hZ2VyLm1qc1wiO1xuaW1wb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gXCIuL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzXCI7XG5jb25zdCB2YWxpZEltYWdlRXh0ZW5zaW9ucyA9IFtcIi5qcGVnXCIsIFwiLmpwZ1wiLCBcIi5wbmdcIiwgXCIud2VicFwiLCBcIi5hdmlmXCJdLCB2YWxpZEltYWdlTUlNRXMgPSBbXG4gIFwiaW1hZ2UvanBlZ1wiLFxuICBcImltYWdlL3BuZ1wiLFxuICBcImltYWdlL3dlYnBcIixcbiAgXCJpbWFnZS9hdmlmXCJcbl07XG5hc3luYyBmdW5jdGlvbiBsb2FkSW1hZ2VCaXRtYXAodXJsKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgIHRocm93IG5ldyBFcnJvcihgW2xvYWRJbWFnZUJpdG1hcF0gRmFpbGVkIHRvIGZldGNoICR7dXJsfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgY29uc3QgaW1hZ2VCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICByZXR1cm4gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iKTtcbn1cbmNvbnN0IGxvYWRUZXh0dXJlcyA9IHtcbiAgbmFtZTogXCJsb2FkVGV4dHVyZXNcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIGNvbmZpZzoge1xuICAgIHByZWZlcldvcmtlcnM6ICEwLFxuICAgIHByZWZlckNyZWF0ZUltYWdlQml0bWFwOiAhMCxcbiAgICBjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIlxuICB9LFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZEltYWdlTUlNRXMpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRJbWFnZUV4dGVuc2lvbnMpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgYXNzZXQsIGxvYWRlcikge1xuICAgIGNvbnN0IHVzZUltYWdlQml0bWFwID0gZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCAmJiB0aGlzLmNvbmZpZy5wcmVmZXJDcmVhdGVJbWFnZUJpdG1hcDtcbiAgICBsZXQgc3JjO1xuICAgIHVzZUltYWdlQml0bWFwID8gdGhpcy5jb25maWcucHJlZmVyV29ya2VycyAmJiBhd2FpdCBXb3JrZXJNYW5hZ2VyLmlzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQoKSA/IHNyYyA9IGF3YWl0IFdvcmtlck1hbmFnZXIubG9hZEltYWdlQml0bWFwKHVybCkgOiBzcmMgPSBhd2FpdCBsb2FkSW1hZ2VCaXRtYXAodXJsKSA6IHNyYyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNyYzIgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIHNyYzIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNvbmZpZy5jcm9zc09yaWdpbiwgc3JjMi5zcmMgPSB1cmwsIHNyYzIuY29tcGxldGUgPyByZXNvbHZlKHNyYzIpIDogKHNyYzIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShzcmMyKSwgc3JjMi5vbmVycm9yID0gKGUpID0+IHJlamVjdChlKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uYXNzZXQuZGF0YSB9O1xuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA/PyAob3B0aW9ucy5yZXNvbHV0aW9uID0gdXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCkpLCB1c2VJbWFnZUJpdG1hcCAmJiBvcHRpb25zLnJlc291cmNlT3B0aW9ucz8ub3duc0ltYWdlQml0bWFwID09PSB2b2lkIDAgJiYgKG9wdGlvbnMucmVzb3VyY2VPcHRpb25zID0geyAuLi5vcHRpb25zLnJlc291cmNlT3B0aW9ucyB9LCBvcHRpb25zLnJlc291cmNlT3B0aW9ucy5vd25zSW1hZ2VCaXRtYXAgPSAhMCk7XG4gICAgY29uc3QgYmFzZSA9IG5ldyBCYXNlVGV4dHVyZShzcmMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBiYXNlLnJlc291cmNlLnNyYyA9IHVybCwgY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCk7XG4gIH0sXG4gIHVubG9hZCh0ZXh0dXJlKSB7XG4gICAgdGV4dHVyZS5kZXN0cm95KCEwKTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRUZXh0dXJlcyk7XG5leHBvcnQge1xuICBsb2FkSW1hZ2VCaXRtYXAsXG4gIGxvYWRUZXh0dXJlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRUZXh0dXJlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBTVkdSZXNvdXJjZSwgQmFzZVRleHR1cmUsIHV0aWxzLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qc1wiO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzXCI7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gXCIuLi9Mb2FkZXJQYXJzZXIubWpzXCI7XG5pbXBvcnQgeyBsb2FkVGV4dHVyZXMgfSBmcm9tIFwiLi9sb2FkVGV4dHVyZXMubWpzXCI7XG5pbXBvcnQgeyBjcmVhdGVUZXh0dXJlIH0gZnJvbSBcIi4vdXRpbHMvY3JlYXRlVGV4dHVyZS5tanNcIjtcbmNvbnN0IHZhbGlkU1ZHRXh0ZW5zaW9uID0gXCIuc3ZnXCIsIHZhbGlkU1ZHTUlNRSA9IFwiaW1hZ2Uvc3ZnK3htbFwiLCBsb2FkU1ZHID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgbmFtZTogXCJsb2FkU1ZHXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkU1ZHTUlNRSkgfHwgY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZFNWR0V4dGVuc2lvbik7XG4gIH0sXG4gIGFzeW5jIHRlc3RQYXJzZShkYXRhKSB7XG4gICAgcmV0dXJuIFNWR1Jlc291cmNlLnRlc3QoZGF0YSk7XG4gIH0sXG4gIGFzeW5jIHBhcnNlKGFzc2V0LCBkYXRhLCBsb2FkZXIpIHtcbiAgICBjb25zdCBzcmMgPSBuZXcgU1ZHUmVzb3VyY2UoYXNzZXQsIGRhdGE/LmRhdGE/LnJlc291cmNlT3B0aW9ucyk7XG4gICAgYXdhaXQgc3JjLmxvYWQoKTtcbiAgICBjb25zdCBiYXNlID0gbmV3IEJhc2VUZXh0dXJlKHNyYywge1xuICAgICAgcmVzb2x1dGlvbjogdXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKGFzc2V0KSxcbiAgICAgIC4uLmRhdGE/LmRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZS5yZXNvdXJjZS5zcmMgPSBkYXRhLnNyYywgY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIGRhdGEuc3JjKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIChhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkOiBsb2FkVGV4dHVyZXMudW5sb2FkXG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFNWRyk7XG5leHBvcnQge1xuICBsb2FkU1ZHXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFNWRy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgVmlkZW9SZXNvdXJjZSwgQmFzZVRleHR1cmUsIHV0aWxzLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzXCI7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gXCIuLi8uLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanNcIjtcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSBcIi4uL0xvYWRlclBhcnNlci5tanNcIjtcbmltcG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tIFwiLi91dGlscy9jcmVhdGVUZXh0dXJlLm1qc1wiO1xuY29uc3QgdmFsaWRWaWRlb0V4dGVuc2lvbnMgPSBbXCIubXA0XCIsIFwiLm00dlwiLCBcIi53ZWJtXCIsIFwiLm9ndlwiXSwgdmFsaWRWaWRlb01JTUVzID0gW1xuICBcInZpZGVvL21wNFwiLFxuICBcInZpZGVvL3dlYm1cIixcbiAgXCJ2aWRlby9vZ2dcIlxuXSwgbG9hZFZpZGVvID0ge1xuICBuYW1lOiBcImxvYWRWaWRlb1wiLFxuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgY29uZmlnOiB7XG4gICAgZGVmYXVsdEF1dG9QbGF5OiAhMFxuICB9LFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZFZpZGVvTUlNRXMpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRWaWRlb0V4dGVuc2lvbnMpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgbG9hZEFzc2V0LCBsb2FkZXIpIHtcbiAgICBsZXQgdGV4dHVyZTtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgKGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKSkuYmxvYigpLCBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgYXV0b1BsYXk6IHRoaXMuY29uZmlnLmRlZmF1bHRBdXRvUGxheSxcbiAgICAgICAgLi4ubG9hZEFzc2V0Py5kYXRhPy5yZXNvdXJjZU9wdGlvbnNcbiAgICAgIH0sIHNyYyA9IG5ldyBWaWRlb1Jlc291cmNlKGJsb2JVUkwsIG9wdGlvbnMpO1xuICAgICAgYXdhaXQgc3JjLmxvYWQoKTtcbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgQmFzZVRleHR1cmUoc3JjLCB7XG4gICAgICAgIGFscGhhTW9kZTogYXdhaXQgdXRpbHMuZGV0ZWN0VmlkZW9BbHBoYU1vZGUoKSxcbiAgICAgICAgcmVzb2x1dGlvbjogdXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAgIC4uLmxvYWRBc3NldD8uZGF0YVxuICAgICAgfSk7XG4gICAgICBiYXNlLnJlc291cmNlLnNyYyA9IHVybCwgdGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpLCB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uY2UoXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKSwgZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH0sXG4gIHVubG9hZCh0ZXh0dXJlKSB7XG4gICAgdGV4dHVyZS5kZXN0cm95KCEwKTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRWaWRlbyk7XG5leHBvcnQge1xuICBsb2FkVmlkZW9cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkVmlkZW8ubWpzLm1hcFxuIiwiaW1wb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gXCIuL2NyZWF0ZVRleHR1cmUubWpzXCI7XG5leHBvcnQge1xuICBjcmVhdGVUZXh0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgbG9hZFNWRyB9IGZyb20gXCIuL2xvYWRTVkcubWpzXCI7XG5pbXBvcnQgeyBsb2FkSW1hZ2VCaXRtYXAsIGxvYWRUZXh0dXJlcyB9IGZyb20gXCIuL2xvYWRUZXh0dXJlcy5tanNcIjtcbmltcG9ydCB7IGxvYWRWaWRlbyB9IGZyb20gXCIuL2xvYWRWaWRlby5tanNcIjtcbmltcG9ydCBcIi4vdXRpbHMvaW5kZXgubWpzXCI7XG5leHBvcnQge1xuICBsb2FkSW1hZ2VCaXRtYXAsXG4gIGxvYWRTVkcsXG4gIGxvYWRUZXh0dXJlcyxcbiAgbG9hZFZpZGVvXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tIFwiLi9Mb2FkZXJQYXJzZXIubWpzXCI7XG5pbXBvcnQgeyBsb2FkSnNvbiB9IGZyb20gXCIuL2xvYWRKc29uLm1qc1wiO1xuaW1wb3J0IHsgbG9hZFR4dCB9IGZyb20gXCIuL2xvYWRUeHQubWpzXCI7XG5pbXBvcnQgeyBnZXRGb250RmFtaWx5TmFtZSwgbG9hZFdlYkZvbnQgfSBmcm9tIFwiLi9sb2FkV2ViRm9udC5tanNcIjtcbmltcG9ydCBcIi4vdGV4dHVyZXMvaW5kZXgubWpzXCI7XG5leHBvcnQge1xuICBMb2FkZXJQYXJzZXJQcmlvcml0eSxcbiAgZ2V0Rm9udEZhbWlseU5hbWUsXG4gIGxvYWRKc29uLFxuICBsb2FkVHh0LFxuICBsb2FkV2ViRm9udFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImZ1bmN0aW9uIHByb2Nlc3NYKGJhc2UsIGlkcywgZGVwdGgsIHJlc3VsdCwgdGFncykge1xuICBjb25zdCBpZCA9IGlkc1tkZXB0aF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlkW2ldO1xuICAgIGRlcHRoIDwgaWRzLmxlbmd0aCAtIDEgPyBwcm9jZXNzWChiYXNlLnJlcGxhY2UocmVzdWx0W2RlcHRoXSwgdmFsdWUpLCBpZHMsIGRlcHRoICsgMSwgcmVzdWx0LCB0YWdzKSA6IHRhZ3MucHVzaChiYXNlLnJlcGxhY2UocmVzdWx0W2RlcHRoXSwgdmFsdWUpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyhzdHJpbmcpIHtcbiAgY29uc3QgcmVnZXggPSAvXFx7KC4qPylcXH0vZywgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKHJlZ2V4KSwgdGFncyA9IFtdO1xuICBpZiAocmVzdWx0KSB7XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgcmVzdWx0LmZvckVhY2goKHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IHNwbGl0ID0gdmFycy5zdWJzdHJpbmcoMSwgdmFycy5sZW5ndGggLSAxKS5zcGxpdChcIixcIik7XG4gICAgICBpZHMucHVzaChzcGxpdCk7XG4gICAgfSksIHByb2Nlc3NYKHN0cmluZywgaWRzLCAwLCByZXN1bHQsIHRhZ3MpO1xuICB9IGVsc2VcbiAgICB0YWdzLnB1c2goc3RyaW5nKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5leHBvcnQge1xuICBjcmVhdGVTdHJpbmdWYXJpYXRpb25zXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSBcIi4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH0gZnJvbSBcIi4uL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzXCI7XG5pbXBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tIFwiLi4vdXRpbHMvaXNTaW5nbGVJdGVtLm1qc1wiO1xuY2xhc3MgUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMgPSB7XG4gICAgICBjb25uZWN0b3I6IFwiLVwiLFxuICAgICAgY3JlYXRlQnVuZGxlQXNzZXRJZDogKGJ1bmRsZUlkLCBhc3NldElkKSA9PiBgJHtidW5kbGVJZH0ke3RoaXMuX2J1bmRsZUlkQ29ubmVjdG9yfSR7YXNzZXRJZH1gLFxuICAgICAgZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlOiAoYnVuZGxlSWQsIGFzc2V0QnVuZGxlSWQpID0+IGFzc2V0QnVuZGxlSWQucmVwbGFjZShgJHtidW5kbGVJZH0ke3RoaXMuX2J1bmRsZUlkQ29ubmVjdG9yfWAsIFwiXCIpXG4gICAgfSwgdGhpcy5fYnVuZGxlSWRDb25uZWN0b3IgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuY29ubmVjdG9yLCB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmNyZWF0ZUJ1bmRsZUFzc2V0SWQsIHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUsIHRoaXMuX2Fzc2V0TWFwID0ge30sIHRoaXMuX3ByZWZlcnJlZE9yZGVyID0gW10sIHRoaXMuX3BhcnNlcnMgPSBbXSwgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge30sIHRoaXMuX2J1bmRsZXMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgaG93IHRoZSByZXNvbHZlciBkZWFscyB3aXRoIGdlbmVyYXRpbmcgYnVuZGxlIGlkcy5cbiAgICogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGFueSBidW5kbGVzIGFyZSBhZGRlZFxuICAgKiBAcGFyYW0gYnVuZGxlSWRlbnRpZmllciAtIHRoZSBidW5kbGUgaWRlbnRpZmllciBvcHRpb25zXG4gICAqL1xuICBzZXRCdW5kbGVJZGVudGlmaWVyKGJ1bmRsZUlkZW50aWZpZXIpIHtcbiAgICBpZiAodGhpcy5fYnVuZGxlSWRDb25uZWN0b3IgPSBidW5kbGVJZGVudGlmaWVyLmNvbm5lY3RvciA/PyB0aGlzLl9idW5kbGVJZENvbm5lY3RvciwgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCA9IGJ1bmRsZUlkZW50aWZpZXIuY3JlYXRlQnVuZGxlQXNzZXRJZCA/PyB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkLCB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPSBidW5kbGVJZGVudGlmaWVyLmV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA/PyB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUsIHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZShcImZvb1wiLCB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKFwiZm9vXCIsIFwiYmFyXCIpKSAhPT0gXCJiYXJcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSZXNvbHZlcl0gR2VuZXJhdGVCdW5kbGVBc3NldElkIGFyZSBub3Qgd29ya2luZyBjb3JyZWN0bHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIExldCB0aGUgcmVzb2x2ZXIga25vdyB3aGljaCBhc3NldHMgeW91IHByZWZlciB0byB1c2Ugd2hlbiByZXNvbHZpbmcgYXNzZXRzLlxuICAgKiBNdWx0aXBsZSBwcmVmZXIgdXNlciBkZWZpbmVkIHJ1bGVzIGNhbiBiZSBhZGRlZC5cbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIucHJlZmVyKHtcbiAgICogICAgIC8vIGZpcnN0IGxvb2sgZm9yIHNvbWV0aGluZyB3aXRoIHRoZSBjb3JyZWN0IGZvcm1hdCwgYW5kIHRoZW4gdGhlbiBjb3JyZWN0IHJlc29sdXRpb25cbiAgICogICAgIHByaW9yaXR5OiBbJ2Zvcm1hdCcsICdyZXNvbHV0aW9uJ10sXG4gICAqICAgICBwYXJhbXM6e1xuICAgKiAgICAgICAgIGZvcm1hdDond2VicCcsIC8vIHByZWZlciB3ZWJwIGltYWdlc1xuICAgKiAgICAgICAgIHJlc29sdXRpb246IDIsIC8vIHByZWZlciBhIHJlc29sdXRpb24gb2YgMlxuICAgKiAgICAgfVxuICAgKiB9KVxuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsIFsnYmFyQDJ4LndlYnAnLCAnYmFyQDJ4LnBuZycsICdiYXIud2VicCcsICdiYXIucG5nJ10pO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nKSAvLyA9PiAnYmFyQDJ4LndlYnAnXG4gICAqIEBwYXJhbSBwcmVmZXJPcmRlcnMgLSB0aGUgcHJlZmVyIG9wdGlvbnNcbiAgICovXG4gIHByZWZlciguLi5wcmVmZXJPcmRlcnMpIHtcbiAgICBwcmVmZXJPcmRlcnMuZm9yRWFjaCgocHJlZmVyKSA9PiB7XG4gICAgICB0aGlzLl9wcmVmZXJyZWRPcmRlci5wdXNoKHByZWZlciksIHByZWZlci5wcmlvcml0eSB8fCAocHJlZmVyLnByaW9yaXR5ID0gT2JqZWN0LmtleXMocHJlZmVyLnBhcmFtcykpO1xuICAgIH0pLCB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBiYXNlIHBhdGggdG8gcHJlcGVuZCB0byBhbGwgdXJscyB3aGVuIHJlc29sdmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXNvbHZlci5iYXNlUGF0aCA9ICdodHRwczovL2hvbWUuY29tLyc7XG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgJ2Jhci5vbmcnKTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJywgJ2Jhci5wbmcnKTsgLy8gPT4gJ2h0dHBzOi8vaG9tZS5jb20vYmFyLnBuZydcbiAgICogQHBhcmFtIGJhc2VQYXRoIC0gdGhlIGJhc2UgcGF0aCB0byB1c2VcbiAgICovXG4gIHNldCBiYXNlUGF0aChiYXNlUGF0aCkge1xuICAgIHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG4gIH1cbiAgZ2V0IGJhc2VQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlUGF0aDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSByb290IHBhdGggZm9yIHJvb3QtcmVsYXRpdmUgVVJMcy4gQnkgZGVmYXVsdCB0aGUgYGJhc2VQYXRoYCdzIHJvb3QgaXMgdXNlZC4gSWYgbm8gYGJhc2VQYXRoYCBpcyBzZXQsIHRoZW4gdGhlXG4gICAqIGRlZmF1bHQgdmFsdWUgZm9yIGJyb3dzZXJzIGlzIGB3aW5kb3cubG9jYXRpb24ub3JpZ2luYFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBcHBsaWNhdGlvbiBob3N0ZWQgb24gaHR0cHM6Ly9ob21lLmNvbS9zb21lLXBhdGgvaW5kZXguaHRtbFxuICAgKiByZXNvbHZlci5iYXNlUGF0aCA9ICdodHRwczovL2hvbWUuY29tL3NvbWUtcGF0aC8nO1xuICAgKiByZXNvbHZlci5yb290UGF0aCA9ICdodHRwczovL2hvbWUuY29tLyc7XG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgJy9iYXIucG5nJyk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycsICcvYmFyLnBuZycpOyAvLyA9PiAnaHR0cHM6Ly9ob21lLmNvbS9iYXIucG5nJ1xuICAgKiBAcGFyYW0gcm9vdFBhdGggLSB0aGUgcm9vdCBwYXRoIHRvIHVzZVxuICAgKi9cbiAgc2V0IHJvb3RQYXRoKHJvb3RQYXRoKSB7XG4gICAgdGhpcy5fcm9vdFBhdGggPSByb290UGF0aDtcbiAgfVxuICBnZXQgcm9vdFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoO1xuICB9XG4gIC8qKlxuICAgKiBBbGwgdGhlIGFjdGl2ZSBVUkwgcGFyc2VycyB0aGF0IGhlbHAgdGhlIHBhcnNlciB0byBleHRyYWN0IGluZm9ybWF0aW9uIGFuZCBjcmVhdGVcbiAgICogYW4gYXNzZXQgb2JqZWN0LWJhc2VkIG9uIHBhcnNpbmcgdGhlIFVSTCBpdHNlbGYuXG4gICAqXG4gICAqIENhbiBiZSBhZGRlZCB1c2luZyB0aGUgZXh0ZW5zaW9ucyBBUElcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCBbXG4gICAqICAgICB7XG4gICAqICAgICAgICAgcmVzb2x1dGlvbjogMixcbiAgICogICAgICAgICBmb3JtYXQ6ICdwbmcnLFxuICAgKiAgICAgICAgIHNyYzogJ2ltYWdlQDJ4LnBuZycsXG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICAgIHJlc29sdXRpb246MSxcbiAgICogICAgICAgICBmb3JtYXQ6J3BuZycsXG4gICAqICAgICAgICAgc3JjOiAnaW1hZ2UucG5nJyxcbiAgICogICAgIH0sXG4gICAqIF0pO1xuICAgKlxuICAgKiAvLyBXaXRoIGEgdXJsIHBhcnNlciB0aGUgaW5mb3JtYXRpb24gc3VjaCBhcyByZXNvbHV0aW9uIGFuZCBmaWxlIGZvcm1hdCBjb3VsZCBleHRyYWN0ZWQgZnJvbSB0aGUgdXJsIGl0c2VsZjpcbiAgICogZXh0ZW5zaW9ucy5hZGQoe1xuICAgKiAgICAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gICAqICAgICB0ZXN0OiBsb2FkVGV4dHVyZXMudGVzdCwgLy8gdGVzdCBpZiB1cmwgZW5kcyBpbiBhbiBpbWFnZVxuICAgKiAgICAgcGFyc2U6ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgKiAgICAgKHtcbiAgICogICAgICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KHNldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyAnMScpLFxuICAgKiAgICAgICAgIGZvcm1hdDogdmFsdWUuc3BsaXQoJy4nKS5wb3AoKSxcbiAgICogICAgICAgICBzcmM6IHZhbHVlLFxuICAgKiAgICAgfSksXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBOb3cgcmVzb2x1dGlvbiBhbmQgZm9ybWF0IGNhbiBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgdXJsXG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgW1xuICAgKiAgICAgJ2ltYWdlQDJ4LnBuZycsXG4gICAqICAgICAnaW1hZ2UucG5nJyxcbiAgICogXSk7XG4gICAqL1xuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxuICAvKiogVXNlZCBmb3IgdGVzdGluZywgdGhpcyByZXNldHMgdGhlIHJlc29sdmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0QnVuZGxlSWRlbnRpZmllcih0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMpLCB0aGlzLl9hc3NldE1hcCA9IHt9LCB0aGlzLl9wcmVmZXJyZWRPcmRlciA9IFtdLCB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fSwgdGhpcy5fcm9vdFBhdGggPSBudWxsLCB0aGlzLl9iYXNlUGF0aCA9IG51bGwsIHRoaXMuX21hbmlmZXN0ID0gbnVsbCwgdGhpcy5fYnVuZGxlcyA9IHt9LCB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVmYXVsdCBVUkwgc2VhcmNoIHBhcmFtZXRlcnMgZm9yIHRoZSBVUkwgcmVzb2x2ZXIuIFRoZSB1cmxzIGNhbiBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0gc2VhcmNoUGFyYW1zIC0gdGhlIGRlZmF1bHQgdXJsIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHdoZW4gcmVzb2x2aW5nIHVybHNcbiAgICovXG4gIHNldERlZmF1bHRTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBzZWFyY2hQYXJhbXMgPT0gXCJzdHJpbmdcIilcbiAgICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBxdWVyeVZhbHVlcyA9IHNlYXJjaFBhcmFtcztcbiAgICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVZhbHVlcykubWFwKChrZXkpID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeVZhbHVlc1trZXldKX1gKS5qb2luKFwiJlwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFsaWFzZXMgZm9yIGEgZ2l2ZW4gYXNzZXRcbiAgICogQHBhcmFtIGFzc2V0IC0gdGhlIGFzc2V0IHRvIGdldCB0aGUgYWxpYXNlcyBmb3JcbiAgICovXG4gIGdldEFsaWFzKGFzc2V0KSB7XG4gICAgY29uc3QgeyBhbGlhcywgbmFtZSwgc3JjLCBzcmNzIH0gPSBhc3NldDtcbiAgICByZXR1cm4gY29udmVydFRvTGlzdChcbiAgICAgIGFsaWFzIHx8IG5hbWUgfHwgc3JjIHx8IHNyY3MsXG4gICAgICAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiID8gdmFsdWUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gdj8uc3JjID8/IHY/LnNyY3MgPz8gdikgOiB2YWx1ZT8uc3JjIHx8IHZhbHVlPy5zcmNzID8gdmFsdWUuc3JjID8/IHZhbHVlLnNyY3MgOiB2YWx1ZSxcbiAgICAgICEwXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbWFuaWZlc3QgdG8gdGhlIGFzc2V0IHJlc29sdmVyLiBUaGlzIGlzIGEgbmljZSB3YXkgdG8gYWRkIGFsbCB0aGUgYXNzZXQgaW5mb3JtYXRpb24gaW4gb25lIGdvLlxuICAgKiBnZW5lcmFsbHkgYSBtYW5pZmVzdCB3b3VsZCBiZSBidWlsdCB1c2luZyBhIHRvb2wuXG4gICAqIEBwYXJhbSBtYW5pZmVzdCAtIHRoZSBtYW5pZmVzdCB0byBhZGQgdG8gdGhlIHJlc29sdmVyXG4gICAqL1xuICBhZGRNYW5pZmVzdChtYW5pZmVzdCkge1xuICAgIHRoaXMuX21hbmlmZXN0ICYmIGNvbnNvbGUud2FybihcIltSZXNvbHZlcl0gTWFuaWZlc3QgYWxyZWFkeSBleGlzdHMsIHRoaXMgd2lsbCBiZSBvdmVyd3JpdHRlblwiKSwgdGhpcy5fbWFuaWZlc3QgPSBtYW5pZmVzdCwgbWFuaWZlc3QuYnVuZGxlcy5mb3JFYWNoKChidW5kbGUpID0+IHtcbiAgICAgIHRoaXMuYWRkQnVuZGxlKGJ1bmRsZS5uYW1lLCBidW5kbGUuYXNzZXRzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBhZGRzIGEgYnVuZGxlIG9mIGFzc2V0cyBpbiBvbmUgZ28gc28gdGhhdCB5b3UgY2FuIHJlc29sdmUgdGhlbSBhcyBhIGdyb3VwLlxuICAgKiBGb3IgZXhhbXBsZSB5b3UgY291bGQgYWRkIGEgYnVuZGxlIGZvciBlYWNoIHNjcmVlbiBpbiB5b3UgcGl4aSBhcHBcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYWRkQnVuZGxlKCdhbmltYWxzJywge1xuICAgKiAgICAgYnVubnk6ICdidW5ueS5wbmcnLFxuICAgKiAgICAgY2hpY2tlbjogJ2NoaWNrZW4ucG5nJyxcbiAgICogICAgIHRodW1wZXI6ICd0aHVtcGVyLnBuZycsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCByZXNvbHZlZEFzc2V0cyA9IGF3YWl0IHJlc29sdmVyLnJlc29sdmVCdW5kbGUoJ2FuaW1hbHMnKTtcbiAgICogQHBhcmFtIGJ1bmRsZUlkIC0gVGhlIGlkIG9mIHRoZSBidW5kbGUgdG8gYWRkXG4gICAqIEBwYXJhbSBhc3NldHMgLSBBIHJlY29yZCBvZiB0aGUgYXNzZXQgb3IgYXNzZXRzIHRoYXQgd2lsbCBiZSBjaG9zZW4gZnJvbSB3aGVuIGxvYWRpbmcgdmlhIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqL1xuICBhZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cykge1xuICAgIGNvbnN0IGFzc2V0TmFtZXMgPSBbXTtcbiAgICBBcnJheS5pc0FycmF5KGFzc2V0cykgPyBhc3NldHMuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHNyY3MgPSBhc3NldC5zcmMgPz8gYXNzZXQuc3JjcywgYWxpYXNlcyA9IGFzc2V0LmFsaWFzID8/IGFzc2V0Lm5hbWU7XG4gICAgICBsZXQgaWRzO1xuICAgICAgaWYgKHR5cGVvZiBhbGlhc2VzID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgYnVuZGxlQXNzZXRJZCA9IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGFsaWFzZXMpO1xuICAgICAgICBhc3NldE5hbWVzLnB1c2goYnVuZGxlQXNzZXRJZCksIGlkcyA9IFthbGlhc2VzLCBidW5kbGVBc3NldElkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUlkcyA9IGFsaWFzZXMubWFwKChuYW1lKSA9PiB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBuYW1lKSk7XG4gICAgICAgIGFzc2V0TmFtZXMucHVzaCguLi5idW5kbGVJZHMpLCBpZHMgPSBbLi4uYWxpYXNlcywgLi4uYnVuZGxlSWRzXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkKHtcbiAgICAgICAgLi4uYXNzZXQsXG4gICAgICAgIGFsaWFzOiBpZHMsXG4gICAgICAgIHNyYzogc3Jjc1xuICAgICAgfSk7XG4gICAgfSkgOiBPYmplY3Qua2V5cyhhc3NldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgYWxpYXNlcyA9IFtrZXksIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGtleSldO1xuICAgICAgaWYgKHR5cGVvZiBhc3NldHNba2V5XSA9PSBcInN0cmluZ1wiKVxuICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgYWxpYXM6IGFsaWFzZXMsXG4gICAgICAgICAgc3JjOiBhc3NldHNba2V5XVxuICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXNzZXRzW2tleV0pKVxuICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgYWxpYXM6IGFsaWFzZXMsXG4gICAgICAgICAgc3JjOiBhc3NldHNba2V5XVxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0c1trZXldLCBhc3NldFNyYyA9IGFzc2V0LnNyYyA/PyBhc3NldC5zcmNzO1xuICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgLi4uYXNzZXQsXG4gICAgICAgICAgYWxpYXM6IGFsaWFzZXMsXG4gICAgICAgICAgc3JjOiBBcnJheS5pc0FycmF5KGFzc2V0U3JjKSA/IGFzc2V0U3JjIDogW2Fzc2V0U3JjXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFzc2V0TmFtZXMucHVzaCguLi5hbGlhc2VzKTtcbiAgICB9KSwgdGhpcy5fYnVuZGxlc1tidW5kbGVJZF0gPSBhc3NldE5hbWVzO1xuICB9XG4gIGFkZChhbGlhc2VzLCBzcmNzLCBkYXRhLCBmb3JtYXQsIGxvYWRQYXJzZXIpIHtcbiAgICBjb25zdCBhc3NldHMgPSBbXTtcbiAgICB0eXBlb2YgYWxpYXNlcyA9PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoYWxpYXNlcykgJiYgdHlwZW9mIGFsaWFzZXNbMF0gPT0gXCJzdHJpbmdcIiA/ICh1dGlscy5kZXByZWNhdGlvbihcIjcuMi4wXCIsIGBBc3NldHMuYWRkIG5vdyB1c2VzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgcGFyYW1ldGVycy5cblBsZWFzZSB1c2UgQXNzZXRzLmFkZCh7IGFsaWFzLCBzcmMsIGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlciB9KSBpbnN0ZWFkLmApLCBhc3NldHMucHVzaCh7IGFsaWFzOiBhbGlhc2VzLCBzcmM6IHNyY3MsIGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlciB9KSkgOiBBcnJheS5pc0FycmF5KGFsaWFzZXMpID8gYXNzZXRzLnB1c2goLi4uYWxpYXNlcykgOiBhc3NldHMucHVzaChhbGlhc2VzKTtcbiAgICBsZXQga2V5Q2hlY2s7XG4gICAga2V5Q2hlY2sgPSAoa2V5KSA9PiB7XG4gICAgICB0aGlzLmhhc0tleShrZXkpICYmIGNvbnNvbGUud2FybihgW1Jlc29sdmVyXSBhbHJlYWR5IGhhcyBrZXk6ICR7a2V5fSBvdmVyd3JpdGluZ2ApO1xuICAgIH0sIGNvbnZlcnRUb0xpc3QoYXNzZXRzKS5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgeyBzcmMsIHNyY3M6IHNyY3MyIH0gPSBhc3NldDtcbiAgICAgIGxldCB7IGRhdGE6IGRhdGEyLCBmb3JtYXQ6IGZvcm1hdDIsIGxvYWRQYXJzZXI6IGxvYWRQYXJzZXIyIH0gPSBhc3NldDtcbiAgICAgIGNvbnN0IHNyY3NUb1VzZSA9IGNvbnZlcnRUb0xpc3Qoc3JjIHx8IHNyY3MyKS5tYXAoKHNyYzIpID0+IHR5cGVvZiBzcmMyID09IFwic3RyaW5nXCIgPyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zKHNyYzIpIDogQXJyYXkuaXNBcnJheShzcmMyKSA/IHNyYzIgOiBbc3JjMl0pLCBhbGlhc2VzVG9Vc2UgPSB0aGlzLmdldEFsaWFzKGFzc2V0KTtcbiAgICAgIEFycmF5LmlzQXJyYXkoYWxpYXNlc1RvVXNlKSA/IGFsaWFzZXNUb1VzZS5mb3JFYWNoKGtleUNoZWNrKSA6IGtleUNoZWNrKGFsaWFzZXNUb1VzZSk7XG4gICAgICBjb25zdCByZXNvbHZlZEFzc2V0cyA9IFtdO1xuICAgICAgc3Jjc1RvVXNlLmZvckVhY2goKHNyY3MzKSA9PiB7XG4gICAgICAgIHNyY3MzLmZvckVhY2goKHNyYzIpID0+IHtcbiAgICAgICAgICBsZXQgZm9ybWF0dGVkQXNzZXQgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIHNyYzIgIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkQXNzZXQuc3JjID0gc3JjMjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSB0aGlzLl9wYXJzZXJzW2ldO1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRlc3Qoc3JjMikpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRBc3NldCA9IHBhcnNlci5wYXJzZShzcmMyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZGF0YTIgPSBzcmMyLmRhdGEgPz8gZGF0YTIsIGZvcm1hdDIgPSBzcmMyLmZvcm1hdCA/PyBmb3JtYXQyLCBsb2FkUGFyc2VyMiA9IHNyYzIubG9hZFBhcnNlciA/PyBsb2FkUGFyc2VyMiwgZm9ybWF0dGVkQXNzZXQgPSB7XG4gICAgICAgICAgICAgIC4uLmZvcm1hdHRlZEFzc2V0LFxuICAgICAgICAgICAgICAuLi5zcmMyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghYWxpYXNlc1RvVXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbUmVzb2x2ZXJdIGFsaWFzIGlzIHVuZGVmaW5lZCBmb3IgdGhpcyBhc3NldDogJHtmb3JtYXR0ZWRBc3NldC5zcmN9YCk7XG4gICAgICAgICAgZm9ybWF0dGVkQXNzZXQgPSB0aGlzLmJ1aWxkUmVzb2x2ZWRBc3NldChmb3JtYXR0ZWRBc3NldCwge1xuICAgICAgICAgICAgYWxpYXNlczogYWxpYXNlc1RvVXNlLFxuICAgICAgICAgICAgZGF0YTogZGF0YTIsXG4gICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdDIsXG4gICAgICAgICAgICBsb2FkUGFyc2VyOiBsb2FkUGFyc2VyMlxuICAgICAgICAgIH0pLCByZXNvbHZlZEFzc2V0cy5wdXNoKGZvcm1hdHRlZEFzc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgYWxpYXNlc1RvVXNlLmZvckVhY2goKGFsaWFzKSA9PiB7XG4gICAgICAgIHRoaXMuX2Fzc2V0TWFwW2FsaWFzXSA9IHJlc29sdmVkQXNzZXRzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gVE9ETzogdGhpcyBuZWVkcyBhbiBvdmVybG9hZCBsaWtlIGxvYWQgZGlkIGluIEFzc2V0c1xuICAvKipcbiAgICogSWYgdGhlIHJlc29sdmVyIGhhcyBoYWQgYSBtYW5pZmVzdCBzZXQgdmlhIHNldE1hbmlmZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBhc3NldHMgdXJscyBmb3JcbiAgICogYSBnaXZlbiBidW5kbGVJZCBvciBidW5kbGVJZHMuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE1hbmlmZXN0IEV4YW1wbGVcbiAgICogY29uc3QgbWFuaWZlc3QgPSB7XG4gICAqICAgICBidW5kbGVzOiBbXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnbG9hZC1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhY2tncm91bmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ3N1bnNldC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnbG9hZC1iYXIue3BuZyx3ZWJwfScsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnZ2FtZS1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2NoYXJhY3RlcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAncm9ib3QucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdlbmVteScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnYmFkLWd1eS5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgXVxuICAgKiB9O1xuICAgKlxuICAgKiByZXNvbHZlci5zZXRNYW5pZmVzdChtYW5pZmVzdCk7XG4gICAqIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZSgnbG9hZC1zY3JlZW4nKTtcbiAgICogQHBhcmFtIGJ1bmRsZUlkcyAtIFRoZSBidW5kbGUgaWRzIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgQWxsIHRoZSBidW5kbGVzIGFzc2V0cyBvciBhIGhhc2ggb2YgYXNzZXRzIGZvciBlYWNoIGJ1bmRsZSBzcGVjaWZpZWRcbiAgICovXG4gIHJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oYnVuZGxlSWRzKTtcbiAgICBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0KGJ1bmRsZUlkcyk7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgcmV0dXJuIGJ1bmRsZUlkcy5mb3JFYWNoKChidW5kbGVJZCkgPT4ge1xuICAgICAgY29uc3QgYXNzZXROYW1lcyA9IHRoaXMuX2J1bmRsZXNbYnVuZGxlSWRdO1xuICAgICAgaWYgKGFzc2V0TmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMucmVzb2x2ZShhc3NldE5hbWVzKSwgYXNzZXRzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCBhc3NldCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgICBhc3NldHNbdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlKGJ1bmRsZUlkLCBrZXkpXSA9IGFzc2V0O1xuICAgICAgICB9XG4gICAgICAgIG91dFtidW5kbGVJZF0gPSBhc3NldHM7XG4gICAgICB9XG4gICAgfSksIHNpbmdsZUFzc2V0ID8gb3V0W2J1bmRsZUlkc1swXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIERvZXMgZXhhY3RseSB3aGF0IHJlc29sdmUgZG9lcywgYnV0IHJldHVybnMganVzdCB0aGUgVVJMIHJhdGhlciB0aGFuIHRoZSB3aG9sZSBhc3NldCBvYmplY3RcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb3Iga2V5cyB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIC0gVGhlIFVSTHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkocylcbiAgICovXG4gIHJlc29sdmVVcmwoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlKGtleSk7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3Qgb3V0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gcmVzdWx0KVxuICAgICAgICBvdXRbaV0gPSByZXN1bHRbaV0uc3JjO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zcmM7XG4gIH1cbiAgcmVzb2x2ZShrZXlzKSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oa2V5cyk7XG4gICAga2V5cyA9IGNvbnZlcnRUb0xpc3Qoa2V5cyk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgcmV0dXJuIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc29sdmVySGFzaFtrZXldKVxuICAgICAgICBpZiAodGhpcy5fYXNzZXRNYXBba2V5XSkge1xuICAgICAgICAgIGxldCBhc3NldHMgPSB0aGlzLl9hc3NldE1hcFtrZXldO1xuICAgICAgICAgIGNvbnN0IGJlc3RBc3NldCA9IGFzc2V0c1swXSwgcHJlZmVycmVkT3JkZXIgPSB0aGlzLl9nZXRQcmVmZXJyZWRPcmRlcihhc3NldHMpO1xuICAgICAgICAgIHByZWZlcnJlZE9yZGVyPy5wcmlvcml0eS5mb3JFYWNoKChwcmlvcml0eUtleSkgPT4ge1xuICAgICAgICAgICAgcHJlZmVycmVkT3JkZXIucGFyYW1zW3ByaW9yaXR5S2V5XS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZEFzc2V0cyA9IGFzc2V0cy5maWx0ZXIoKGFzc2V0KSA9PiBhc3NldFtwcmlvcml0eUtleV0gPyBhc3NldFtwcmlvcml0eUtleV0gPT09IHZhbHVlIDogITEpO1xuICAgICAgICAgICAgICBmaWx0ZXJlZEFzc2V0cy5sZW5ndGggJiYgKGFzc2V0cyA9IGZpbHRlcmVkQXNzZXRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCB0aGlzLl9yZXNvbHZlckhhc2hba2V5XSA9IGFzc2V0c1swXSA/PyBiZXN0QXNzZXQ7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVySGFzaFtrZXldID0gdGhpcy5idWlsZFJlc29sdmVkQXNzZXQoe1xuICAgICAgICAgICAgYWxpYXM6IFtrZXldLFxuICAgICAgICAgICAgc3JjOiBrZXlcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICByZXN1bHRba2V5XSA9IHRoaXMuX3Jlc29sdmVySGFzaFtrZXldO1xuICAgIH0pLCBzaW5nbGVBc3NldCA/IHJlc3VsdFtrZXlzWzBdXSA6IHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGFzc2V0IHdpdGggYSBnaXZlbiBrZXkgZXhpc3RzIGluIHRoZSByZXNvbHZlclxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgYXNzZXRcbiAgICovXG4gIGhhc0tleShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9hc3NldE1hcFtrZXldO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBidW5kbGUgd2l0aCB0aGUgZ2l2ZW4ga2V5IGV4aXN0cyBpbiB0aGUgcmVzb2x2ZXJcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGJ1bmRsZVxuICAgKi9cbiAgaGFzQnVuZGxlKGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuX2J1bmRsZXNba2V5XTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWwgZnVuY3Rpb24gZm9yIGZpZ3VyaW5nIG91dCB3aGF0IHByZWZlciBjcml0ZXJpYSBhbiBhc3NldCBzaG91bGQgdXNlLlxuICAgKiBAcGFyYW0gYXNzZXRzXG4gICAqL1xuICBfZ2V0UHJlZmVycmVkT3JkZXIoYXNzZXRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRzWzBdLCBwcmVmZXJyZWQgPSB0aGlzLl9wcmVmZXJyZWRPcmRlci5maW5kKChwcmVmZXJlbmNlKSA9PiBwcmVmZXJlbmNlLnBhcmFtcy5mb3JtYXQuaW5jbHVkZXMoYXNzZXQuZm9ybWF0KSk7XG4gICAgICBpZiAocHJlZmVycmVkKVxuICAgICAgICByZXR1cm4gcHJlZmVycmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlZmVycmVkT3JkZXJbMF07XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGRlZmF1bHQgdXJsIHBhcmFtZXRlcnMgdG8gdGhlIHVybFxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIHVybCB0byBhcHBlbmQgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyB0b1xuICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgd2l0aCB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIGFwcGVuZGVkXG4gICAqL1xuICBfYXBwZW5kRGVmYXVsdFNlYXJjaFBhcmFtcyh1cmwpIHtcbiAgICBpZiAoIXRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMpXG4gICAgICByZXR1cm4gdXJsO1xuICAgIGNvbnN0IHBhcmFtQ29ubmVjdG9yID0gL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIjtcbiAgICByZXR1cm4gYCR7dXJsfSR7cGFyYW1Db25uZWN0b3J9JHt0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zfWA7XG4gIH1cbiAgYnVpbGRSZXNvbHZlZEFzc2V0KGZvcm1hdHRlZEFzc2V0LCBkYXRhKSB7XG4gICAgY29uc3QgeyBhbGlhc2VzLCBkYXRhOiBhc3NldERhdGEsIGxvYWRQYXJzZXIsIGZvcm1hdCB9ID0gZGF0YTtcbiAgICByZXR1cm4gKHRoaXMuX2Jhc2VQYXRoIHx8IHRoaXMuX3Jvb3RQYXRoKSAmJiAoZm9ybWF0dGVkQXNzZXQuc3JjID0gdXRpbHMucGF0aC50b0Fic29sdXRlKGZvcm1hdHRlZEFzc2V0LnNyYywgdGhpcy5fYmFzZVBhdGgsIHRoaXMuX3Jvb3RQYXRoKSksIGZvcm1hdHRlZEFzc2V0LmFsaWFzID0gYWxpYXNlcyA/PyBmb3JtYXR0ZWRBc3NldC5hbGlhcyA/PyBbZm9ybWF0dGVkQXNzZXQuc3JjXSwgZm9ybWF0dGVkQXNzZXQuc3JjID0gdGhpcy5fYXBwZW5kRGVmYXVsdFNlYXJjaFBhcmFtcyhmb3JtYXR0ZWRBc3NldC5zcmMpLCBmb3JtYXR0ZWRBc3NldC5kYXRhID0geyAuLi5hc3NldERhdGEgfHwge30sIC4uLmZvcm1hdHRlZEFzc2V0LmRhdGEgfSwgZm9ybWF0dGVkQXNzZXQubG9hZFBhcnNlciA9IGxvYWRQYXJzZXIgPz8gZm9ybWF0dGVkQXNzZXQubG9hZFBhcnNlciwgZm9ybWF0dGVkQXNzZXQuZm9ybWF0ID0gZm9ybWF0ID8/IHV0aWxzLnBhdGguZXh0bmFtZShmb3JtYXR0ZWRBc3NldC5zcmMpLnNsaWNlKDEpLCBmb3JtYXR0ZWRBc3NldC5zcmNzID0gZm9ybWF0dGVkQXNzZXQuc3JjLCBmb3JtYXR0ZWRBc3NldC5uYW1lID0gZm9ybWF0dGVkQXNzZXQuYWxpYXMsIGZvcm1hdHRlZEFzc2V0O1xuICB9XG59XG5leHBvcnQge1xuICBSZXNvbHZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc29sdmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzLCBleHRlbnNpb25zLCBFeHRlbnNpb25UeXBlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfSBmcm9tIFwiLi9CYWNrZ3JvdW5kTG9hZGVyLm1qc1wiO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwiLi9jYWNoZS9DYWNoZS5tanNcIjtcbmltcG9ydCB7IExvYWRlciB9IGZyb20gXCIuL2xvYWRlci9Mb2FkZXIubWpzXCI7XG5pbXBvcnQgXCIuL2xvYWRlci9wYXJzZXJzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgUmVzb2x2ZXIgfSBmcm9tIFwiLi9yZXNvbHZlci9SZXNvbHZlci5tanNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb0xpc3QgfSBmcm9tIFwiLi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qc1wiO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSBcIi4vdXRpbHMvaXNTaW5nbGVJdGVtLm1qc1wiO1xuaW1wb3J0IHsgbG9hZFRleHR1cmVzIH0gZnJvbSBcIi4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qc1wiO1xuY2xhc3MgQXNzZXRzQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kZXRlY3Rpb25zID0gW10sIHRoaXMuX2luaXRpYWxpemVkID0gITEsIHRoaXMucmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIoKSwgdGhpcy5sb2FkZXIgPSBuZXcgTG9hZGVyKCksIHRoaXMuY2FjaGUgPSBDYWNoZSwgdGhpcy5fYmFja2dyb3VuZExvYWRlciA9IG5ldyBCYWNrZ3JvdW5kTG9hZGVyKHRoaXMubG9hZGVyKSwgdGhpcy5fYmFja2dyb3VuZExvYWRlci5hY3RpdmUgPSAhMCwgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBCZXN0IHByYWN0aWNlIGlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgYW55IGxvYWRpbmcgY29tbWVuY2VzXG4gICAqIEluaXRpYXRpbmcgaXMgdGhlIGJlc3QgdGltZSB0byBhZGQgYW55IGN1c3RvbWl6YXRpb24gdG8gdGhlIHdheSB0aGluZ3MgYXJlIGxvYWRlZC5cbiAgICpcbiAgICogeW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBmb3IgdGhlIEFzc2V0IGNsYXNzIHRvIHdvcmssIG9ubHkgaWYgeW91IHdhbnQgdG8gc2V0IGFueSBpbml0aWFsIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIHRvIGluaXRpYWxpemUgdGhlIEFzc2V0IG1hbmFnZXIgd2l0aFxuICAgKi9cbiAgYXN5bmMgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltBc3NldHNdQXNzZXRNYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGl6ZWQsIGRpZCB5b3UgbG9hZCBiZWZvcmUgY2FsbGluZyB0aGlzIEFzc2V0cy5pbml0KCk/XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQgPSAhMCwgb3B0aW9ucy5kZWZhdWx0U2VhcmNoUGFyYW1zICYmIHRoaXMucmVzb2x2ZXIuc2V0RGVmYXVsdFNlYXJjaFBhcmFtcyhvcHRpb25zLmRlZmF1bHRTZWFyY2hQYXJhbXMpLCBvcHRpb25zLmJhc2VQYXRoICYmICh0aGlzLnJlc29sdmVyLmJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aCksIG9wdGlvbnMuYnVuZGxlSWRlbnRpZmllciAmJiB0aGlzLnJlc29sdmVyLnNldEJ1bmRsZUlkZW50aWZpZXIob3B0aW9ucy5idW5kbGVJZGVudGlmaWVyKSwgb3B0aW9ucy5tYW5pZmVzdCkge1xuICAgICAgbGV0IG1hbmlmZXN0ID0gb3B0aW9ucy5tYW5pZmVzdDtcbiAgICAgIHR5cGVvZiBtYW5pZmVzdCA9PSBcInN0cmluZ1wiICYmIChtYW5pZmVzdCA9IGF3YWl0IHRoaXMubG9hZChtYW5pZmVzdCkpLCB0aGlzLnJlc29sdmVyLmFkZE1hbmlmZXN0KG1hbmlmZXN0KTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvblByZWYgPSBvcHRpb25zLnRleHR1cmVQcmVmZXJlbmNlPy5yZXNvbHV0aW9uID8/IDEsIHJlc29sdXRpb24gPSB0eXBlb2YgcmVzb2x1dGlvblByZWYgPT0gXCJudW1iZXJcIiA/IFtyZXNvbHV0aW9uUHJlZl0gOiByZXNvbHV0aW9uUHJlZiwgZm9ybWF0cyA9IGF3YWl0IHRoaXMuX2RldGVjdEZvcm1hdHMoe1xuICAgICAgcHJlZmVycmVkRm9ybWF0czogb3B0aW9ucy50ZXh0dXJlUHJlZmVyZW5jZT8uZm9ybWF0LFxuICAgICAgc2tpcERldGVjdGlvbnM6IG9wdGlvbnMuc2tpcERldGVjdGlvbnMsXG4gICAgICBkZXRlY3Rpb25zOiB0aGlzLl9kZXRlY3Rpb25zXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHZlci5wcmVmZXIoe1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGZvcm1hdDogZm9ybWF0cyxcbiAgICAgICAgcmVzb2x1dGlvblxuICAgICAgfVxuICAgIH0pLCBvcHRpb25zLnByZWZlcmVuY2VzICYmIHRoaXMuc2V0UHJlZmVyZW5jZXMob3B0aW9ucy5wcmVmZXJlbmNlcyk7XG4gIH1cbiAgYWRkKGFsaWFzZXMsIHNyY3MsIGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlcikge1xuICAgIHRoaXMucmVzb2x2ZXIuYWRkKGFsaWFzZXMsIHNyY3MsIGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlcik7XG4gIH1cbiAgYXN5bmMgbG9hZCh1cmxzLCBvblByb2dyZXNzKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0odXJscyksIHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB1cmwgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gdGhpcy5yZXNvbHZlci5nZXRBbGlhcyh1cmwpO1xuICAgICAgICByZXR1cm4gYWxpYXNlcy5zb21lKChhbGlhcykgPT4gIXRoaXMucmVzb2x2ZXIuaGFzS2V5KGFsaWFzKSkgJiYgdGhpcy5hZGQodXJsKSwgQXJyYXkuaXNBcnJheShhbGlhc2VzKSA/IGFsaWFzZXNbMF0gOiBhbGlhc2VzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXIuaGFzS2V5KHVybCkgfHwgdGhpcy5hZGQoeyBhbGlhczogdXJsLCBzcmM6IHVybCB9KSwgdXJsO1xuICAgIH0pLCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxBcnJheSksIG91dCA9IGF3YWl0IHRoaXMuX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFt1cmxBcnJheVswXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgYWRkcyBhIGJ1bmRsZSBvZiBhc3NldHMgaW4gb25lIGdvIHNvIHRoYXQgeW91IGNhbiBsb2FkIHRoZW0gYXMgYSBncm91cC5cbiAgICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIGFkZCBhIGJ1bmRsZSBmb3IgZWFjaCBzY3JlZW4gaW4geW91IHBpeGkgYXBwXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYWRkQnVuZGxlKCdhbmltYWxzJywge1xuICAgKiAgICAgYnVubnk6ICdidW5ueS5wbmcnLFxuICAgKiAgICAgY2hpY2tlbjogJ2NoaWNrZW4ucG5nJyxcbiAgICogICAgIHRodW1wZXI6ICd0aHVtcGVyLnBuZycsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBhc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnYW5pbWFscycpO1xuICAgKiBAcGFyYW0gYnVuZGxlSWQgLSB0aGUgaWQgb2YgdGhlIGJ1bmRsZSB0byBhZGRcbiAgICogQHBhcmFtIGFzc2V0cyAtIGEgcmVjb3JkIG9mIHRoZSBhc3NldCBvciBhc3NldHMgdGhhdCB3aWxsIGJlIGNob3NlbiBmcm9tIHdoZW4gbG9hZGluZyB2aWEgdGhlIHNwZWNpZmllZCBrZXlcbiAgICovXG4gIGFkZEJ1bmRsZShidW5kbGVJZCwgYXNzZXRzKSB7XG4gICAgdGhpcy5yZXNvbHZlci5hZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEJ1bmRsZXMgYXJlIGEgd2F5IHRvIGxvYWQgbXVsdGlwbGUgYXNzZXRzIGF0IG9uY2UuXG4gICAqIElmIGEgbWFuaWZlc3QgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIGluaXQgZnVuY3Rpb24gdGhlbiB5b3UgY2FuIGxvYWQgYSBidW5kbGUsIG9yIGJ1bmRsZXMuXG4gICAqIHlvdSBjYW4gYWxzbyBhZGQgYnVuZGxlcyB2aWEgYGFkZEJ1bmRsZWBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIE1hbmlmZXN0IEV4YW1wbGVcbiAgICogY29uc3QgbWFuaWZlc3QgPSB7XG4gICAqICAgICBidW5kbGVzOiBbXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnbG9hZC1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhY2tncm91bmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ3N1bnNldC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnbG9hZC1iYXIue3BuZyx3ZWJwfScsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnZ2FtZS1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2NoYXJhY3RlcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAncm9ib3QucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdlbmVteScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnYmFkLWd1eS5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgXVxuICAgKiB9O1xuICAgKlxuICAgKiBhd2FpdCBBc3NldHMuaW5pdCh7IG1hbmlmZXN0IH0pO1xuICAgKlxuICAgKiAvLyBMb2FkIGEgYnVuZGxlLi4uXG4gICAqIGxvYWRTY3JlZW5Bc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnbG9hZC1zY3JlZW4nKTtcbiAgICogLy8gTG9hZCBhbm90aGVyIGJ1bmRsZS4uLlxuICAgKiBnYW1lU2NyZWVuQXNzZXRzID0gYXdhaXQgQXNzZXRzLmxvYWRCdW5kbGUoJ2dhbWUtc2NyZWVuJyk7XG4gICAqIEBwYXJhbSBidW5kbGVJZHMgLSB0aGUgYnVuZGxlIGlkIG9yIGlkcyB0byBsb2FkXG4gICAqIEBwYXJhbSBvblByb2dyZXNzIC0gT3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBwcm9ncmVzcyBvbiBhc3NldCBsb2FkaW5nIGlzIG1hZGUuXG4gICAqIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgYSBzaW5nbGUgcGFyYW1ldGVyLCBgcHJvZ3Jlc3NgLCB3aGljaCByZXByZXNlbnRzIHRoZSBwZXJjZW50YWdlICgwLjAgLSAxLjApXG4gICAqIG9mIHRoZSBhc3NldHMgbG9hZGVkLiBEbyBub3QgdXNlIHRoaXMgZnVuY3Rpb24gdG8gZGV0ZWN0IHdoZW4gYXNzZXRzIGFyZSBjb21wbGV0ZSBhbmQgYXZhaWxhYmxlLFxuICAgKiBpbnN0ZWFkIHVzZSB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyBhbGwgdGhlIGJ1bmRsZXMgYXNzZXRzIG9yIGEgaGFzaCBvZiBhc3NldHMgZm9yIGVhY2ggYnVuZGxlIHNwZWNpZmllZFxuICAgKi9cbiAgYXN5bmMgbG9hZEJ1bmRsZShidW5kbGVJZHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCB8fCBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBsZXQgc2luZ2xlQXNzZXQgPSAhMTtcbiAgICB0eXBlb2YgYnVuZGxlSWRzID09IFwic3RyaW5nXCIgJiYgKHNpbmdsZUFzc2V0ID0gITAsIGJ1bmRsZUlkcyA9IFtidW5kbGVJZHNdKTtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpLCBvdXQgPSB7fSwga2V5cyA9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHRzKTtcbiAgICBsZXQgY291bnQgPSAwLCB0b3RhbCA9IDA7XG4gICAgY29uc3QgX29uUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gICAgICBvblByb2dyZXNzPy4oKytjb3VudCAvIHRvdGFsKTtcbiAgICB9LCBwcm9taXNlcyA9IGtleXMubWFwKChidW5kbGVJZCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXTtcbiAgICAgIHJldHVybiB0b3RhbCArPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0KS5sZW5ndGgsIHRoaXMuX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdCwgX29uUHJvZ3Jlc3MpLnRoZW4oKHJlc29sdmVSZXN1bHQyKSA9PiB7XG4gICAgICAgIG91dFtidW5kbGVJZF0gPSByZXNvbHZlUmVzdWx0MjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyksIHNpbmdsZUFzc2V0ID8gb3V0W2J1bmRsZUlkc1swXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgYmFja2dyb3VuZCBsb2FkIG9mIHNvbWUgYXNzZXRzLiBJdCB3aWxsIHBhc3NpdmVseSBiZWdpbiB0byBsb2FkIHRoZXNlIGFzc2V0cyBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogU28gd2hlbiB5b3UgYWN0dWFsbHkgY29tZSB0byBsb2FkaW5nIHRoZW0geW91IHdpbGwgZ2V0IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgYXNzZXRzIGltbWVkaWF0ZWx5XG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSB0aGF0IHlvdSB3b3VsZCBiYWNrZ3JvdW5kIGxvYWQgZ2FtZSBhc3NldHMgYWZ0ZXIgeW91ciBpbml0YWwgbG9hZC5cbiAgICogdGhlbiB3aGVuIHlvdSBnb3QgdG8gYWN0dWFsbHkgbG9hZCB5b3VyIGdhbWUgc2NyZWVuIGFzc2V0cyB3aGVuIGEgcGxheWVyIGdvZXMgdG8gdGhlIGdhbWUgLSB0aGUgbG9hZGluZ1xuICAgKiB3b3VsZCBhbHJlYWR5IGhhdmUgc3RhcmVkIG9yIG1heSBldmVuIGJlIGNvbXBsZXRlLCBzYXZpbmcgeW91IGhhdmluZyB0byBzaG93IGFuIGludGVyaW0gbG9hZCBiYXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYmFja2dyb3VuZExvYWQoJ2J1bm55LnBuZycpO1xuICAgKlxuICAgKiAvLyBsYXRlciBvbiBpbiB5b3VyIGFwcC4uLlxuICAgKiBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnYnVubnkucG5nJyk7IC8vIFdpbGwgcmVzb2x2ZSBxdWlja2VyIGFzIGxvYWRpbmcgbWF5IGhhdmUgY29tcGxldGVkIVxuICAgKiBAcGFyYW0gdXJscyAtIHRoZSB1cmwgLyB1cmxzIHlvdSB3YW50IHRvIGJhY2tncm91bmQgbG9hZFxuICAgKi9cbiAgYXN5bmMgYmFja2dyb3VuZExvYWQodXJscykge1xuICAgIHRoaXMuX2luaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdCgpLCB0eXBlb2YgdXJscyA9PSBcInN0cmluZ1wiICYmICh1cmxzID0gW3VybHNdKTtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFkZChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgYmFja2dyb3VuZCBvZiBhIGJ1bmRsZSwgd29ya3MgZXhhY3RseSBsaWtlIGJhY2tncm91bmRMb2FkIGJ1dCBmb3IgYnVuZGxlcy5cbiAgICogdGhpcyBjYW4gb25seSBiZSB1c2VkIGlmIHRoZSBsb2FkZXIgaGFzIGJlZW4gaW5pdGlhdGVkIHdpdGggYSBtYW5pZmVzdFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBBc3NldHMgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogYXdhaXQgQXNzZXRzLmluaXQoe1xuICAgKiAgICAgbWFuaWZlc3Q6IHtcbiAgICogICAgICAgICBidW5kbGVzOiBbXG4gICAqICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgIG5hbWU6ICdsb2FkLXNjcmVlbicsXG4gICAqICAgICAgICAgICAgICAgICBhc3NldHM6IFsuLi5dLFxuICAgKiAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICAuLi5cbiAgICogICAgICAgICBdLFxuICAgKiAgICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIEFzc2V0cy5iYWNrZ3JvdW5kTG9hZEJ1bmRsZSgnbG9hZC1zY3JlZW4nKTtcbiAgICpcbiAgICogLy8gTGF0ZXIgb24gaW4geW91ciBhcHAuLi5cbiAgICogYXdhaXQgQXNzZXRzLmxvYWRCdW5kbGUoJ2xvYWQtc2NyZWVuJyk7IC8vIFdpbGwgcmVzb2x2ZSBxdWlja2VyIGFzIGxvYWRpbmcgbWF5IGhhdmUgY29tcGxldGVkIVxuICAgKiBAcGFyYW0gYnVuZGxlSWRzIC0gdGhlIGJ1bmRsZUlkIC8gYnVuZGxlSWRzIHlvdSB3YW50IHRvIGJhY2tncm91bmQgbG9hZFxuICAgKi9cbiAgYXN5bmMgYmFja2dyb3VuZExvYWRCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0KCksIHR5cGVvZiBidW5kbGVJZHMgPT0gXCJzdHJpbmdcIiAmJiAoYnVuZGxlSWRzID0gW2J1bmRsZUlkc10pO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcyk7XG4gICAgT2JqZWN0LnZhbHVlcyhyZXNvbHZlUmVzdWx0cykuZm9yRWFjaCgocmVzb2x2ZVJlc3VsdCkgPT4ge1xuICAgICAgdGhpcy5fYmFja2dyb3VuZExvYWRlci5hZGQoT2JqZWN0LnZhbHVlcyhyZXNvbHZlUmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgaW50ZW5kZWQgZm9yIGRldmVsb3BtZW50IHB1cnBvc2VzLlxuICAgKiBUaGlzIHdpbGwgd2lwZSB0aGUgcmVzb2x2ZXIgYW5kIGNhY2hlcy5cbiAgICogWW91IHdpbGwgbmVlZCB0byByZWluaXRpYWxpemUgdGhlIEFzc2V0XG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnJlc29sdmVyLnJlc2V0KCksIHRoaXMubG9hZGVyLnJlc2V0KCksIHRoaXMuY2FjaGUucmVzZXQoKSwgdGhpcy5faW5pdGlhbGl6ZWQgPSAhMTtcbiAgfVxuICBnZXQoa2V5cykge1xuICAgIGlmICh0eXBlb2Yga2V5cyA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIENhY2hlLmdldChrZXlzKTtcbiAgICBjb25zdCBhc3NldHMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICBhc3NldHNbaV0gPSBDYWNoZS5nZXQoa2V5c1tpXSk7XG4gICAgcmV0dXJuIGFzc2V0cztcbiAgfVxuICAvKipcbiAgICogaGVscGVyIGZ1bmN0aW9uIHRvIG1hcCByZXNvbHZlZCBhc3NldHMgYmFjayB0byBsb2FkZWQgYXNzZXRzXG4gICAqIEBwYXJhbSByZXNvbHZlUmVzdWx0cyAtIHRoZSByZXNvbHZlIHJlc3VsdHMgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgLSB0aGUgcHJvZ3Jlc3MgY2FsbGJhY2tcbiAgICovXG4gIGFzeW5jIF9tYXBMb2FkVG9SZXNvbHZlKHJlc29sdmVSZXN1bHRzLCBvblByb2dyZXNzKSB7XG4gICAgY29uc3QgcmVzb2x2ZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhyZXNvbHZlUmVzdWx0cyksIHJlc29sdmVLZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZVJlc3VsdHMpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gITE7XG4gICAgY29uc3QgbG9hZGVkQXNzZXRzID0gYXdhaXQgdGhpcy5sb2FkZXIubG9hZChyZXNvbHZlQXJyYXksIG9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gITA7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgcmV0dXJuIHJlc29sdmVBcnJheS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0LCBpKSA9PiB7XG4gICAgICBjb25zdCBhc3NldCA9IGxvYWRlZEFzc2V0c1tyZXNvbHZlUmVzdWx0LnNyY10sIGtleXMgPSBbcmVzb2x2ZVJlc3VsdC5zcmNdO1xuICAgICAgcmVzb2x2ZVJlc3VsdC5hbGlhcyAmJiBrZXlzLnB1c2goLi4ucmVzb2x2ZVJlc3VsdC5hbGlhcyksIG91dFtyZXNvbHZlS2V5c1tpXV0gPSBhc3NldCwgQ2FjaGUuc2V0KGtleXMsIGFzc2V0KTtcbiAgICB9KSwgb3V0O1xuICB9XG4gIC8qKlxuICAgKiBVbmxvYWQgYW4gYXNzZXQgb3IgYXNzZXRzLiBBcyB0aGUgQXNzZXRzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgYXNzZXRzIHZpYSB0aGUgYGxvYWRgIGZ1bmN0aW9uXG4gICAqIHRoaXMgd2lsbCBtYWtlIHN1cmUgdG8gZGVzdHJveSBhbnkgYXNzZXRzIGFuZCByZWxlYXNlIHRoZW0gZnJvbSBtZW1vcnkuXG4gICAqIE9uY2UgdW5sb2FkZWQsIHlvdSB3aWxsIG5lZWQgdG8gbG9hZCB0aGUgYXNzZXQgYWdhaW4uXG4gICAqXG4gICAqIFVzZSB0aGlzIHRvIGhlbHAgbWFuYWdlIGFzc2V0cyBpZiB5b3UgZmluZCB0aGF0IHlvdSBoYXZlIGEgbGFyZ2UgYXBwIGFuZCB5b3Ugd2FudCB0byBmcmVlIHVwIG1lbW9yeS5cbiAgICpcbiAgICogLSBpdCdzIHVwIHRvIHlvdSBhcyB0aGUgZGV2ZWxvcGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRleHR1cmVzIGFyZSBub3QgYWN0aXZlbHkgYmVpbmcgdXNlZCB3aGVuIHlvdSB1bmxvYWQgdGhlbSxcbiAgICogUGl4aSB3b24ndCBicmVhayBidXQgeW91IHdpbGwgZW5kIHVwIHdpdGggbWlzc2luZyBhc3NldHMuIE5vdCBhIGdvb2QgbG9vayBmb3IgdGhlIHVzZXIhXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiAvLyBMb2FkIGEgVVJMOlxuICAgKiBjb25zdCBteUltYWdlVGV4dHVyZSA9IGF3YWl0IEFzc2V0cy5sb2FkKCdodHRwOi8vc29tZS51cmwuY29tL2ltYWdlLnBuZycpOyAvLyA9PiByZXR1cm5zIGEgdGV4dHVyZVxuICAgKlxuICAgKiBhd2FpdCBBc3NldHMudW5sb2FkKCdodHRwOi8vc29tZS51cmwuY29tL2ltYWdlLnBuZycpXG4gICAqXG4gICAqIC8vIG15SW1hZ2VUZXh0dXJlIHdpbGwgYmUgZGVzdHJveWVkIG5vdy5cbiAgICpcbiAgICogLy8gVW5sb2FkIG11bHRpcGxlIGFzc2V0czpcbiAgICogY29uc3QgdGV4dHVyZXMgPSBhd2FpdCBBc3NldHMudW5sb2FkKFsndGh1bXBlcicsICdjaGlja28nXSk7XG4gICAqIEBwYXJhbSB1cmxzIC0gdGhlIHVybHMgdG8gdW5sb2FkXG4gICAqL1xuICBhc3luYyB1bmxvYWQodXJscykge1xuICAgIHRoaXMuX2luaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4gdHlwZW9mIHVybCAhPSBcInN0cmluZ1wiID8gdXJsLnNyYyA6IHVybCksIHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybEFycmF5KTtcbiAgICBhd2FpdCB0aGlzLl91bmxvYWRGcm9tUmVzb2x2ZWQocmVzb2x2ZVJlc3VsdHMpO1xuICB9XG4gIC8qKlxuICAgKiBCdW5kbGVzIGFyZSBhIHdheSB0byBtYW5hZ2UgbXVsdGlwbGUgYXNzZXRzIGF0IG9uY2UuXG4gICAqIHRoaXMgd2lsbCB1bmxvYWQgYWxsIGZpbGVzIGluIGEgYnVuZGxlLlxuICAgKlxuICAgKiBvbmNlIGEgYnVuZGxlIGhhcyBiZWVuIHVubG9hZGVkLCB5b3UgbmVlZCB0byBsb2FkIGl0IGFnYWluIHRvIGhhdmUgYWNjZXNzIHRvIHRoZSBhc3NldHMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYWRkQnVuZGxlKHtcbiAgICogICAgICd0aHVtcGVyJzogJ2h0dHA6Ly9zb21lLnVybC5jb20vdGh1bXBlci5wbmcnLFxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zdCBhc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgndGh1bXBlcicpO1xuICAgKlxuICAgKiAvLyBOb3cgdG8gdW5sb2FkLi4uXG4gICAqXG4gICAqIGF3YWl0IEFzc2V0cy51bmxvYWRCdW5kbGUoJ3RodW1wZXInKTtcbiAgICpcbiAgICogLy8gQWxsIGFzc2V0cyBpbiB0aGUgYXNzZXRzIG9iamVjdCB3aWxsIG5vdyBoYXZlIGJlZW4gZGVzdHJveWVkIGFuZCBwdXJnZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIGJ1bmRsZUlkcyAtIHRoZSBidW5kbGUgaWQgb3IgaWRzIHRvIHVubG9hZFxuICAgKi9cbiAgYXN5bmMgdW5sb2FkQnVuZGxlKGJ1bmRsZUlkcykge1xuICAgIHRoaXMuX2luaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdCgpLCBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0KGJ1bmRsZUlkcyk7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKSwgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cykubWFwKChidW5kbGVJZCkgPT4gdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICBhc3luYyBfdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHQpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpO1xuICAgIHJlc29sdmVBcnJheS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgQ2FjaGUucmVtb3ZlKHJlc29sdmVSZXN1bHQyLnNyYyk7XG4gICAgfSksIGF3YWl0IHRoaXMubG9hZGVyLnVubG9hZChyZXNvbHZlQXJyYXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIHRoZSBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgdGhlIGJyb3dzZXIsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHN1cHBvcnRlZCBmb3JtYXRzLCByZXNwZWN0aW5nXG4gICAqIHRoZSB1c2VycyBwcmVmZXJyZWQgZm9ybWF0cyBvcmRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBkZXRlY3RpbmcgZm9ybWF0c1xuICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVmZXJyZWRGb3JtYXRzIC0gdGhlIHByZWZlcnJlZCBmb3JtYXRzIHRvIHVzZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5za2lwRGV0ZWN0aW9ucyAtIGlmIHdlIHNob3VsZCBza2lwIHRoZSBkZXRlY3Rpb25zIGFsdG9nZXRoZXJcbiAgICogQHBhcmFtIG9wdGlvbnMuZGV0ZWN0aW9ucyAtIHRoZSBkZXRlY3Rpb25zIHRvIHVzZVxuICAgKiBAcmV0dXJucyAtIHRoZSBkZXRlY3RlZCBmb3JtYXRzXG4gICAqL1xuICBhc3luYyBfZGV0ZWN0Rm9ybWF0cyhvcHRpb25zKSB7XG4gICAgbGV0IGZvcm1hdHMgPSBbXTtcbiAgICBvcHRpb25zLnByZWZlcnJlZEZvcm1hdHMgJiYgKGZvcm1hdHMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMucHJlZmVycmVkRm9ybWF0cykgPyBvcHRpb25zLnByZWZlcnJlZEZvcm1hdHMgOiBbb3B0aW9ucy5wcmVmZXJyZWRGb3JtYXRzXSk7XG4gICAgZm9yIChjb25zdCBkZXRlY3Rpb24gb2Ygb3B0aW9ucy5kZXRlY3Rpb25zKVxuICAgICAgb3B0aW9ucy5za2lwRGV0ZWN0aW9ucyB8fCBhd2FpdCBkZXRlY3Rpb24udGVzdCgpID8gZm9ybWF0cyA9IGF3YWl0IGRldGVjdGlvbi5hZGQoZm9ybWF0cykgOiBvcHRpb25zLnNraXBEZXRlY3Rpb25zIHx8IChmb3JtYXRzID0gYXdhaXQgZGV0ZWN0aW9uLnJlbW92ZShmb3JtYXRzKSk7XG4gICAgcmV0dXJuIGZvcm1hdHMgPSBmb3JtYXRzLmZpbHRlcigoZm9ybWF0LCBpbmRleCkgPT4gZm9ybWF0cy5pbmRleE9mKGZvcm1hdCkgPT09IGluZGV4KSwgZm9ybWF0cztcbiAgfVxuICAvKiogQWxsIHRoZSBkZXRlY3Rpb24gcGFyc2VycyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIEFzc2V0cyBjbGFzcy4gKi9cbiAgZ2V0IGRldGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGVjdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMi4wXG4gICAqIEBzZWUge0BsaW5rIEFzc2V0cy5zZXRQcmVmZXJlbmNlc31cbiAgICovXG4gIGdldCBwcmVmZXJXb3JrZXJzKCkge1xuICAgIHJldHVybiBsb2FkVGV4dHVyZXMuY29uZmlnLnByZWZlcldvcmtlcnM7XG4gIH1cbiAgc2V0IHByZWZlcldvcmtlcnModmFsdWUpIHtcbiAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwiQXNzZXRzLnByZWZlcnNXb3JrZXJzIGlzIGRlcHJlY2F0ZWQsIHVzZSBBc3NldHMuc2V0UHJlZmVyZW5jZXMoeyBwcmVmZXJXb3JrZXJzOiB0cnVlIH0pIGluc3RlYWQuXCIpLCB0aGlzLnNldFByZWZlcmVuY2VzKHsgcHJlZmVyV29ya2VyczogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYWwgc2V0dGVyIGZvciBwcmVmZXJlbmNlcy4gVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBzZXQgcHJlZmVyZW5jZXMgb24gYWxsIHBhcnNlcnMuXG4gICAqIEBwYXJhbSBwcmVmZXJlbmNlcyAtIHRoZSBwcmVmZXJlbmNlcyB0byBzZXRcbiAgICovXG4gIHNldFByZWZlcmVuY2VzKHByZWZlcmVuY2VzKSB7XG4gICAgdGhpcy5sb2FkZXIucGFyc2Vycy5mb3JFYWNoKChwYXJzZXIpID0+IHtcbiAgICAgIHBhcnNlci5jb25maWcgJiYgT2JqZWN0LmtleXMocGFyc2VyLmNvbmZpZykuZmlsdGVyKChrZXkpID0+IGtleSBpbiBwcmVmZXJlbmNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHBhcnNlci5jb25maWdba2V5XSA9IHByZWZlcmVuY2VzW2tleV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQXNzZXRzID0gbmV3IEFzc2V0c0NsYXNzKCk7XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsIEFzc2V0cy5sb2FkZXIucGFyc2VycykuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlciwgQXNzZXRzLnJlc29sdmVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkNhY2hlUGFyc2VyLCBBc3NldHMuY2FjaGUucGFyc2VycykuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLCBBc3NldHMuZGV0ZWN0aW9ucyk7XG5leHBvcnQge1xuICBBc3NldHMsXG4gIEFzc2V0c0NsYXNzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXRzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIFRleHR1cmUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuY29uc3QgY2FjaGVUZXh0dXJlQXJyYXkgPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5DYWNoZVBhcnNlcixcbiAgdGVzdDogKGFzc2V0KSA9PiBBcnJheS5pc0FycmF5KGFzc2V0KSAmJiBhc3NldC5ldmVyeSgodCkgPT4gdCBpbnN0YW5jZW9mIFRleHR1cmUpLFxuICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4ge1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIHJldHVybiBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgYXNzZXQuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBvdXRba2V5ICsgKGkgPT09IDAgPyBcIlwiIDogaSArIDEpXSA9IGl0ZW07XG4gICAgICB9KTtcbiAgICB9KSwgb3V0O1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQoY2FjaGVUZXh0dXJlQXJyYXkpO1xuZXhwb3J0IHtcbiAgY2FjaGVUZXh0dXJlQXJyYXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZVRleHR1cmVBcnJheS5tanMubWFwXG4iLCJpbXBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9IGZyb20gXCIuL2NhY2hlVGV4dHVyZUFycmF5Lm1qc1wiO1xuZXhwb3J0IHtcbiAgY2FjaGVUZXh0dXJlQXJyYXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gXCIuL0NhY2hlLm1qc1wiO1xuaW1wb3J0IFwiLi9DYWNoZVBhcnNlci5tanNcIjtcbmltcG9ydCBcIi4vcGFyc2Vycy9pbmRleC5tanNcIjtcbmV4cG9ydCB7XG4gIENhY2hlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiYXN5bmMgZnVuY3Rpb24gdGVzdEltYWdlRm9ybWF0KGltYWdlRGF0YSkge1xuICBpZiAoXCJJbWFnZVwiIGluIGdsb2JhbFRoaXMpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCEwKTtcbiAgICAgIH0sIGltYWdlLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoITEpO1xuICAgICAgfSwgaW1hZ2Uuc3JjID0gaW1hZ2VEYXRhO1xuICAgIH0pO1xuICBpZiAoXCJjcmVhdGVJbWFnZUJpdG1hcFwiIGluIGdsb2JhbFRoaXMgJiYgXCJmZXRjaFwiIGluIGdsb2JhbFRoaXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IChhd2FpdCBmZXRjaChpbWFnZURhdGEpKS5ibG9iKCk7XG4gICAgICBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmV4cG9ydCB7XG4gIHRlc3RJbWFnZUZvcm1hdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RJbWFnZUZvcm1hdC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IHRlc3RJbWFnZUZvcm1hdCB9IGZyb20gXCIuLi91dGlscy90ZXN0SW1hZ2VGb3JtYXQubWpzXCI7XG5jb25zdCBkZXRlY3RBdmlmID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogMVxuICB9LFxuICB0ZXN0OiBhc3luYyAoKSA9PiB0ZXN0SW1hZ2VGb3JtYXQoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUIwQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFJQUFBQUNBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRME1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFBWUFBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQ1Z0WkdGMEVnQUtDQmdBTm9nUUVBd2dNZzhmOEQvLy84V2Zod0I4K0VySzQyQT1cIlxuICApLFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJhdmlmXCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJhdmlmXCIpXG59O1xuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0QXZpZik7XG5leHBvcnQge1xuICBkZXRlY3RBdmlmXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0QXZpZi5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IHRlc3RJbWFnZUZvcm1hdCB9IGZyb20gXCIuLi91dGlscy90ZXN0SW1hZ2VGb3JtYXQubWpzXCI7XG5jb25zdCBkZXRlY3RXZWJwID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogMFxuICB9LFxuICB0ZXN0OiBhc3luYyAoKSA9PiB0ZXN0SW1hZ2VGb3JtYXQoXG4gICAgXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaDRBQUFCWFJVSlFWbEE0VEJFQUFBQXZBQUFBQUFmUS8vNzN2LytCaU9oL0FBQT1cIlxuICApLFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJ3ZWJwXCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJ3ZWJwXCIpXG59O1xuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0V2VicCk7XG5leHBvcnQge1xuICBkZXRlY3RXZWJwXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0V2VicC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmNvbnN0IGltYWdlRm9ybWF0cyA9IFtcInBuZ1wiLCBcImpwZ1wiLCBcImpwZWdcIl0sIGRldGVjdERlZmF1bHRzID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogLTFcbiAgfSxcbiAgdGVzdDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCEwKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIC4uLmltYWdlRm9ybWF0c10sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhaW1hZ2VGb3JtYXRzLmluY2x1ZGVzKGYpKVxufTtcbmV4dGVuc2lvbnMuYWRkKGRldGVjdERlZmF1bHRzKTtcbmV4cG9ydCB7XG4gIGRldGVjdERlZmF1bHRzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0RGVmYXVsdHMubWpzLm1hcFxuIiwiY29uc3QgaW5Xb3JrZXIgPSBcIldvcmtlckdsb2JhbFNjb3BlXCIgaW4gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5Xb3JrZXJHbG9iYWxTY29wZTtcbmZ1bmN0aW9uIHRlc3RWaWRlb0Zvcm1hdChtaW1lVHlwZSkge1xuICByZXR1cm4gaW5Xb3JrZXIgPyAhMSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKS5jYW5QbGF5VHlwZShtaW1lVHlwZSkgIT09IFwiXCI7XG59XG5leHBvcnQge1xuICB0ZXN0VmlkZW9Gb3JtYXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0VmlkZW9Gb3JtYXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyB0ZXN0VmlkZW9Gb3JtYXQgfSBmcm9tIFwiLi4vdXRpbHMvdGVzdFZpZGVvRm9ybWF0Lm1qc1wiO1xuY29uc3QgZGV0ZWN0V2VibSA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4gdGVzdFZpZGVvRm9ybWF0KFwidmlkZW8vd2VibVwiKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwid2VibVwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwid2VibVwiKVxufTtcbmV4dGVuc2lvbnMuYWRkKGRldGVjdFdlYm0pO1xuZXhwb3J0IHtcbiAgZGV0ZWN0V2VibVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFdlYm0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyB0ZXN0VmlkZW9Gb3JtYXQgfSBmcm9tIFwiLi4vdXRpbHMvdGVzdFZpZGVvRm9ybWF0Lm1qc1wiO1xuY29uc3QgZGV0ZWN0TXA0ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogMFxuICB9LFxuICB0ZXN0OiBhc3luYyAoKSA9PiB0ZXN0VmlkZW9Gb3JtYXQoXCJ2aWRlby9tcDRcIiksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCBcIm1wNFwiLCBcIm00dlwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwibXA0XCIgJiYgZiAhPT0gXCJtNHZcIilcbn07XG5leHRlbnNpb25zLmFkZChkZXRlY3RNcDQpO1xuZXhwb3J0IHtcbiAgZGV0ZWN0TXA0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0TXA0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgdGVzdFZpZGVvRm9ybWF0IH0gZnJvbSBcIi4uL3V0aWxzL3Rlc3RWaWRlb0Zvcm1hdC5tanNcIjtcbmNvbnN0IGRldGVjdE9ndiA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4gdGVzdFZpZGVvRm9ybWF0KFwidmlkZW8vb2dnXCIpLFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJvZ3ZcIl0sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiBmICE9PSBcIm9ndlwiKVxufTtcbmV4dGVuc2lvbnMuYWRkKGRldGVjdE9ndik7XG5leHBvcnQge1xuICBkZXRlY3RPZ3Zcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RPZ3YubWpzLm1hcFxuIiwiaW1wb3J0IHsgZGV0ZWN0QXZpZiB9IGZyb20gXCIuL2RldGVjdEF2aWYubWpzXCI7XG5pbXBvcnQgeyBkZXRlY3RXZWJwIH0gZnJvbSBcIi4vZGV0ZWN0V2VicC5tanNcIjtcbmltcG9ydCB7IGRldGVjdERlZmF1bHRzIH0gZnJvbSBcIi4vZGV0ZWN0RGVmYXVsdHMubWpzXCI7XG5pbXBvcnQgeyBkZXRlY3RXZWJtIH0gZnJvbSBcIi4vZGV0ZWN0V2VibS5tanNcIjtcbmltcG9ydCB7IGRldGVjdE1wNCB9IGZyb20gXCIuL2RldGVjdE1wNC5tanNcIjtcbmltcG9ydCB7IGRldGVjdE9ndiB9IGZyb20gXCIuL2RldGVjdE9ndi5tanNcIjtcbmV4cG9ydCB7XG4gIGRldGVjdEF2aWYsXG4gIGRldGVjdERlZmF1bHRzLFxuICBkZXRlY3RNcDQsXG4gIGRldGVjdE9ndixcbiAgZGV0ZWN0V2VibSxcbiAgZGV0ZWN0V2VicFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCBcIi4vcGFyc2Vycy9pbmRleC5tanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCBcIi4vcGFyc2Vycy9pbmRleC5tanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCB1dGlscywgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgXCIuLi8uLi9sb2FkZXIvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBsb2FkVGV4dHVyZXMgfSBmcm9tIFwiLi4vLi4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qc1wiO1xuY29uc3QgcmVzb2x2ZVRleHR1cmVVcmwgPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICB0ZXN0OiBsb2FkVGV4dHVyZXMudGVzdCxcbiAgcGFyc2U6ICh2YWx1ZSkgPT4gKHtcbiAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KHNldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyBcIjFcIiksXG4gICAgZm9ybWF0OiB1dGlscy5wYXRoLmV4dG5hbWUodmFsdWUpLnNsaWNlKDEpLFxuICAgIHNyYzogdmFsdWVcbiAgfSlcbn07XG5leHRlbnNpb25zLmFkZChyZXNvbHZlVGV4dHVyZVVybCk7XG5leHBvcnQge1xuICByZXNvbHZlVGV4dHVyZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVUZXh0dXJlVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IHJlc29sdmVUZXh0dXJlVXJsIH0gZnJvbSBcIi4vcmVzb2x2ZVRleHR1cmVVcmwubWpzXCI7XG5leHBvcnQge1xuICByZXNvbHZlVGV4dHVyZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCBcIi4vcGFyc2Vycy9pbmRleC5tanNcIjtcbmltcG9ydCBcIi4vdHlwZXMubWpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjb25zdCBjb3B5U2VhcmNoUGFyYW1zID0gKHRhcmdldFVybCwgc291cmNlVXJsKSA9PiB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHNvdXJjZVVybC5zcGxpdChcIj9cIilbMV07XG4gIHJldHVybiBzZWFyY2hQYXJhbXMgJiYgKHRhcmdldFVybCArPSBgPyR7c2VhcmNoUGFyYW1zfWApLCB0YXJnZXRVcmw7XG59O1xuZXhwb3J0IHtcbiAgY29weVNlYXJjaFBhcmFtc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHlTZWFyY2hQYXJhbXMubWpzLm1hcFxuIiwiaW1wb3J0IFwiLi9Bc3NldEV4dGVuc2lvbi5tanNcIjtcbmltcG9ydCB7IEFzc2V0cywgQXNzZXRzQ2xhc3MgfSBmcm9tIFwiLi9Bc3NldHMubWpzXCI7XG5pbXBvcnQgXCIuL2NhY2hlL2luZGV4Lm1qc1wiO1xuaW1wb3J0IFwiLi9kZXRlY3Rpb25zL2luZGV4Lm1qc1wiO1xuaW1wb3J0IFwiLi9sb2FkZXIvaW5kZXgubWpzXCI7XG5pbXBvcnQgXCIuL3Jlc29sdmVyL2luZGV4Lm1qc1wiO1xuaW1wb3J0IFwiLi90eXBlcy5tanNcIjtcbmltcG9ydCBcIi4vdXRpbHMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gXCIuL2NhY2hlL0NhY2hlLm1qc1wiO1xuaW1wb3J0IHsgY2FjaGVUZXh0dXJlQXJyYXkgfSBmcm9tIFwiLi9jYWNoZS9wYXJzZXJzL2NhY2hlVGV4dHVyZUFycmF5Lm1qc1wiO1xuaW1wb3J0IHsgZGV0ZWN0QXZpZiB9IGZyb20gXCIuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLm1qc1wiO1xuaW1wb3J0IHsgZGV0ZWN0V2VicCB9IGZyb20gXCIuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qc1wiO1xuaW1wb3J0IHsgZGV0ZWN0RGVmYXVsdHMgfSBmcm9tIFwiLi9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0RGVmYXVsdHMubWpzXCI7XG5pbXBvcnQgeyBkZXRlY3RXZWJtIH0gZnJvbSBcIi4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYm0ubWpzXCI7XG5pbXBvcnQgeyBkZXRlY3RNcDQgfSBmcm9tIFwiLi9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0TXA0Lm1qc1wiO1xuaW1wb3J0IHsgZGV0ZWN0T2d2IH0gZnJvbSBcIi4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdE9ndi5tanNcIjtcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSBcIi4vbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qc1wiO1xuaW1wb3J0IHsgbG9hZEpzb24gfSBmcm9tIFwiLi9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5tanNcIjtcbmltcG9ydCB7IGxvYWRUeHQgfSBmcm9tIFwiLi9sb2FkZXIvcGFyc2Vycy9sb2FkVHh0Lm1qc1wiO1xuaW1wb3J0IHsgZ2V0Rm9udEZhbWlseU5hbWUsIGxvYWRXZWJGb250IH0gZnJvbSBcIi4vbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQubWpzXCI7XG5pbXBvcnQgeyBsb2FkU1ZHIH0gZnJvbSBcIi4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFNWRy5tanNcIjtcbmltcG9ydCB7IGxvYWRJbWFnZUJpdG1hcCwgbG9hZFRleHR1cmVzIH0gZnJvbSBcIi4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qc1wiO1xuaW1wb3J0IHsgbG9hZFZpZGVvIH0gZnJvbSBcIi4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFZpZGVvLm1qc1wiO1xuaW1wb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gXCIuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgeyByZXNvbHZlVGV4dHVyZVVybCB9IGZyb20gXCIuL3Jlc29sdmVyL3BhcnNlcnMvcmVzb2x2ZVRleHR1cmVVcmwubWpzXCI7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tIFwiLi91dGlscy9jaGVja0RhdGFVcmwubWpzXCI7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gXCIuL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qc1wiO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gXCIuL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzXCI7XG5pbXBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSBcIi4vdXRpbHMvY29weVNlYXJjaFBhcmFtcy5tanNcIjtcbmltcG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfSBmcm9tIFwiLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qc1wiO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSBcIi4vdXRpbHMvaXNTaW5nbGVJdGVtLm1qc1wiO1xuZXhwb3J0IHtcbiAgQXNzZXRzLFxuICBBc3NldHNDbGFzcyxcbiAgQ2FjaGUsXG4gIExvYWRlclBhcnNlclByaW9yaXR5LFxuICBjYWNoZVRleHR1cmVBcnJheSxcbiAgY2hlY2tEYXRhVXJsLFxuICBjaGVja0V4dGVuc2lvbixcbiAgY29udmVydFRvTGlzdCxcbiAgY29weVNlYXJjaFBhcmFtcyxcbiAgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyxcbiAgY3JlYXRlVGV4dHVyZSxcbiAgZGV0ZWN0QXZpZixcbiAgZGV0ZWN0RGVmYXVsdHMsXG4gIGRldGVjdE1wNCxcbiAgZGV0ZWN0T2d2LFxuICBkZXRlY3RXZWJtLFxuICBkZXRlY3RXZWJwLFxuICBnZXRGb250RmFtaWx5TmFtZSxcbiAgaXNTaW5nbGVJdGVtLFxuICBsb2FkSW1hZ2VCaXRtYXAsXG4gIGxvYWRKc29uLFxuICBsb2FkU1ZHLFxuICBsb2FkVGV4dHVyZXMsXG4gIGxvYWRUeHQsXG4gIGxvYWRWaWRlbyxcbiAgbG9hZFdlYkZvbnQsXG4gIHJlc29sdmVUZXh0dXJlVXJsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIElOVEVSTkFMX0ZPUk1BVFMgPSAvKiBAX19QVVJFX18gKi8gKChJTlRFUk5BTF9GT1JNQVRTMikgPT4gKElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQgPSAzMzc3Nl0gPSBcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQgPSAzMzc3N10gPSBcIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUID0gMzM3NzhdID0gXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCA9IDMzNzc5XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQgPSAzNTkxN10gPSBcIkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUID0gMzU5MThdID0gXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVCA9IDM1OTE5XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFRcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQgPSAzNTkxNl0gPSBcIkNPTVBSRVNTRURfU1JHQl9TM1RDX0RYVDFfRVhUXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUjExX0VBQyA9IDM3NDg4XSA9IFwiQ09NUFJFU1NFRF9SMTFfRUFDXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUMgPSAzNzQ4OV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SRzExX0VBQyA9IDM3NDkwXSA9IFwiQ09NUFJFU1NFRF9SRzExX0VBQ1wiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NJR05FRF9SRzExX0VBQyA9IDM3NDkxXSA9IFwiQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUNcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0I4X0VUQzIgPSAzNzQ5Ml0gPSBcIkNPTVBSRVNTRURfUkdCOF9FVEMyXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUMgPSAzNzQ5Nl0gPSBcIkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUNcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TUkdCOF9FVEMyID0gMzc0OTNdID0gXCJDT01QUkVTU0VEX1NSR0I4X0VUQzJcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUMgPSAzNzQ5N10gPSBcIkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIgPSAzNzQ5NF0gPSBcIkNPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzJcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIgPSAzNzQ5NV0gPSBcIkNPTVBSRVNTRURfU1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUcgPSAzNTg0MF0gPSBcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcgPSAzNTg0Ml0gPSBcIkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUcgPSAzNTg0MV0gPSBcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUdcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUcgPSAzNTg0M10gPSBcIkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgPSAzNjE5Nl0gPSBcIkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMID0gMzU5ODZdID0gXCJDT01QUkVTU0VEX1JHQl9BVENfV0VCR0xcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTCA9IDM1OTg3XSA9IFwiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTCA9IDM0Nzk4XSA9IFwiQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0xcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBX0FTVENfNHg0X0tIUiA9IDM3ODA4XSA9IFwiQ09NUFJFU1NFRF9SR0JBX0FTVENfNHg0X0tIUlwiLCBJTlRFUk5BTF9GT1JNQVRTMikpKElOVEVSTkFMX0ZPUk1BVFMgfHwge30pO1xuY29uc3QgSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCA9IHtcbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcbiAgMzM3NzY6IDAuNSxcbiAgMzM3Nzc6IDAuNSxcbiAgMzM3Nzg6IDEsXG4gIDMzNzc5OiAxLFxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAzNTkxNjogMC41LFxuICAzNTkxNzogMC41LFxuICAzNTkxODogMSxcbiAgMzU5MTk6IDEsXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGNcbiAgMzc0ODg6IDAuNSxcbiAgMzc0ODk6IDAuNSxcbiAgMzc0OTA6IDEsXG4gIDM3NDkxOiAxLFxuICAzNzQ5MjogMC41LFxuICAzNzQ5NjogMSxcbiAgMzc0OTM6IDAuNSxcbiAgMzc0OTc6IDEsXG4gIDM3NDk0OiAwLjUsXG4gIC8vIH5+XG4gIDM3NDk1OiAwLjUsXG4gIC8vIH5+XG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuICAzNTg0MDogMC41LFxuICAzNTg0MjogMC41LFxuICAzNTg0MTogMC4yNSxcbiAgMzU4NDM6IDAuMjUsXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXG4gIDM2MTk2OiAwLjUsXG4gIC8vIEBzZWUgaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvT3BlbkdML2V4dGVuc2lvbnMvQU1EL0FNRF9jb21wcmVzc2VkX0FUQ190ZXh0dXJlLnR4dFxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXG4gIDM1OTg2OiAwLjUsXG4gIDM1OTg3OiAxLFxuICAzNDc5ODogMSxcbiAgLy8gQHNlZSBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL09wZW5HTC9leHRlbnNpb25zL0tIUi9LSFJfdGV4dHVyZV9jb21wcmVzc2lvbl9hc3RjX2hkci50eHRcbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZSAqL1xuICAzNzgwODogMVxufTtcbmV4cG9ydCB7XG4gIElOVEVSTkFMX0ZPUk1BVFMsXG4gIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyBhcyBleHRlbnNpb25zJDEgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xubGV0IHN0b3JlZEdsLCBleHRlbnNpb25zO1xuZnVuY3Rpb24gZ2V0Q29tcHJlc3NlZFRleHR1cmVFeHRlbnNpb25zKCkge1xuICBleHRlbnNpb25zID0ge1xuICAgIHMzdGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLFxuICAgIHMzdGNfc1JHQjogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYlwiKSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZSAqL1xuICAgIGV0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSxcbiAgICBldGMxOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxcbiAgICBwdnJ0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpIHx8IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIiksXG4gICAgYXRjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXCIpLFxuICAgIGFzdGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpXG4gIH07XG59XG5jb25zdCBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAyXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBnbCA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuICAgIHJldHVybiBnbCA/IChzdG9yZWRHbCA9IGdsLCAhMCkgOiAoY29uc29sZS53YXJuKFwiV2ViR0wgbm90IGF2YWlsYWJsZSBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcy5cIiksICExKTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4ge1xuICAgIGV4dGVuc2lvbnMgfHwgZ2V0Q29tcHJlc3NlZFRleHR1cmVFeHRlbnNpb25zKCk7XG4gICAgY29uc3QgdGV4dHVyZUZvcm1hdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbk5hbWUgaW4gZXh0ZW5zaW9ucylcbiAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gJiYgdGV4dHVyZUZvcm1hdHMucHVzaChleHRlbnNpb25OYW1lKTtcbiAgICByZXR1cm4gWy4uLnRleHR1cmVGb3JtYXRzLCAuLi5mb3JtYXRzXTtcbiAgfSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gKGV4dGVuc2lvbnMgfHwgZ2V0Q29tcHJlc3NlZFRleHR1cmVFeHRlbnNpb25zKCksIGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhKGYgaW4gZXh0ZW5zaW9ucykpKVxufTtcbmV4dGVuc2lvbnMkMS5hZGQoZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzKTtcbmV4cG9ydCB7XG4gIGRldGVjdENvbXByZXNzZWRUZXh0dXJlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdENvbXByZXNzZWRUZXh0dXJlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSwgVmlld2FibGVCdWZmZXIgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuY2xhc3MgQmxvYlJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBidWZmZXIvVVJMIG9mIHRoZSB0ZXh0dXJlIGZpbGUuXG4gICAqIEBwYXJhbSB7UElYSS5JQmxvYlJlc291cmNlT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0xvYWQ9ZmFsc2VdIC0gV2hldGhlciB0byBmZXRjaCB0aGUgZGF0YSBpbW1lZGlhdGVseTtcbiAgICogIHlvdSBjYW4gZmV0Y2ggaXQgbGF0ZXIgdmlhIHtAbGluayBQSVhJLkJsb2JSZXNvdXJjZSNsb2FkfS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTFdIC0gVGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xXSAtIFRoZSBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0gezF8Mnw0fDh9IFtvcHRpb25zLnVucGFja0FsaWdubWVudD00XSAtIFRoZSBhbGlnbm1lbnQgb2YgdGhlIHBpeGVsIHJvd3MuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEsIGF1dG9Mb2FkOiAhMCB9KSB7XG4gICAgbGV0IG9yaWdpbiwgZGF0YTtcbiAgICB0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIgPyAob3JpZ2luID0gc291cmNlLCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKSkgOiAob3JpZ2luID0gbnVsbCwgZGF0YSA9IHNvdXJjZSksIHN1cGVyKGRhdGEsIG9wdGlvbnMpLCB0aGlzLm9yaWdpbiA9IG9yaWdpbiwgdGhpcy5idWZmZXIgPSBkYXRhID8gbmV3IFZpZXdhYmxlQnVmZmVyKGRhdGEpIDogbnVsbCwgdGhpcy5fbG9hZCA9IG51bGwsIHRoaXMubG9hZGVkID0gITEsIHRoaXMub3JpZ2luICE9PSBudWxsICYmIG9wdGlvbnMuYXV0b0xvYWQgIT09ICExICYmIHRoaXMubG9hZCgpLCB0aGlzLm9yaWdpbiA9PT0gbnVsbCAmJiB0aGlzLmJ1ZmZlciAmJiAodGhpcy5fbG9hZCA9IFByb21pc2UucmVzb2x2ZSh0aGlzKSwgdGhpcy5sb2FkZWQgPSAhMCwgdGhpcy5vbkJsb2JMb2FkZWQodGhpcy5idWZmZXIucmF3QmluYXJ5RGF0YSkpO1xuICB9XG4gIG9uQmxvYkxvYWRlZChfZGF0YSkge1xuICB9XG4gIC8qKiBMb2FkcyB0aGUgYmxvYiAqL1xuICBsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkID8gdGhpcy5fbG9hZCA6ICh0aGlzLl9sb2FkID0gZmV0Y2godGhpcy5vcmlnaW4pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5ibG9iKCkpLnRoZW4oKGJsb2IpID0+IGJsb2IuYXJyYXlCdWZmZXIoKSkudGhlbigoYXJyYXlCdWZmZXIpID0+ICh0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpLCB0aGlzLmJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcihhcnJheUJ1ZmZlciksIHRoaXMubG9hZGVkID0gITAsIHRoaXMub25CbG9iTG9hZGVkKGFycmF5QnVmZmVyKSwgdGhpcy51cGRhdGUoKSwgdGhpcykpLCB0aGlzLl9sb2FkKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQmxvYlJlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxvYlJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgfSBmcm9tIFwiLi4vY29uc3QubWpzXCI7XG5pbXBvcnQgeyBCbG9iUmVzb3VyY2UgfSBmcm9tIFwiLi9CbG9iUmVzb3VyY2UubWpzXCI7XG5jbGFzcyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIGV4dGVuZHMgQmxvYlJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgYnVmZmVyL1VSTCBob2xkaW5nIHRoZSBjb21wcmVzc2VkIHRleHR1cmUgZGF0YVxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1BJWEkuSU5URVJOQUxfRk9STUFUU30gb3B0aW9ucy5mb3JtYXQgLSB0aGUgY29tcHJlc3Npb24gZm9ybWF0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLndpZHRoIC0gdGhlIGltYWdlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gdGhlIGltYWdlIGhlaWdodCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZXZlbD0xXSAtIHRoZSBtaXBtYXAgbGV2ZWxzIHN0b3JlZCBpbiB0aGUgY29tcHJlc3NlZCB0ZXh0dXJlLCBpbmNsdWRpbmcgbGV2ZWwgMC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxldmVsQnVmZmVyc10gLSB0aGUgYnVmZmVycyBmb3IgZWFjaCBtaXBtYXAgbGV2ZWwuIGBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlYCBjYW4gYWxsb3dzIHlvdVxuICAgKiAgICAgIHRvIHBhc3MgYG51bGxgIGZvciBgc291cmNlYCwgZm9yIGNhc2VzIHdoZXJlIGVhY2ggbGV2ZWwgaXMgc3RvcmVkIGluIG5vbi1jb250aWd1b3VzIG1lbW9yeS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyksIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQsIHRoaXMubGV2ZWxzID0gb3B0aW9ucy5sZXZlbHMgfHwgMSwgdGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoLCB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodCwgdGhpcy5fZXh0ZW5zaW9uID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5fZm9ybWF0VG9FeHRlbnNpb24odGhpcy5mb3JtYXQpLCAob3B0aW9ucy5sZXZlbEJ1ZmZlcnMgfHwgdGhpcy5idWZmZXIpICYmICh0aGlzLl9sZXZlbEJ1ZmZlcnMgPSBvcHRpb25zLmxldmVsQnVmZmVycyB8fCBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9jcmVhdGVMZXZlbEJ1ZmZlcnMoXG4gICAgICBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gc291cmNlIDogdGhpcy5idWZmZXIudWludDhWaWV3LFxuICAgICAgdGhpcy5mb3JtYXQsXG4gICAgICB0aGlzLmxldmVscyxcbiAgICAgIDQsXG4gICAgICA0LFxuICAgICAgLy8gUFZSVEMgaGFzIDh4NCBibG9ja3MgaW4gMmJwcCBtb2RlXG4gICAgICB0aGlzLndpZHRoLFxuICAgICAgdGhpcy5oZWlnaHRcbiAgICApKTtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqIEBwYXJhbSBfdGV4dHVyZSAtIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSBfZ2xUZXh0dXJlIC0gdGV4dHVyZSBpbnN0YW5jZSBmb3IgdGhpcyB3ZWJnbCBjb250ZXh0XG4gICAqL1xuICB1cGxvYWQocmVuZGVyZXIsIF90ZXh0dXJlLCBfZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBpZiAoIXJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9uc1t0aGlzLl9leHRlbnNpb25dKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX2V4dGVuc2lvbn0gdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgbWFjaGluZWApO1xuICAgIGlmICghdGhpcy5fbGV2ZWxCdWZmZXJzKVxuICAgICAgcmV0dXJuICExO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIDQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5sZXZlbHM7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgbGV2ZWxJRCwgbGV2ZWxXaWR0aCwgbGV2ZWxIZWlnaHQsIGxldmVsQnVmZmVyIH0gPSB0aGlzLl9sZXZlbEJ1ZmZlcnNbaV07XG4gICAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBsZXZlbElELCB0aGlzLmZvcm1hdCwgbGV2ZWxXaWR0aCwgbGV2ZWxIZWlnaHQsIDAsIGxldmVsQnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIG9uQmxvYkxvYWRlZCgpIHtcbiAgICB0aGlzLl9sZXZlbEJ1ZmZlcnMgPSBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9jcmVhdGVMZXZlbEJ1ZmZlcnMoXG4gICAgICB0aGlzLmJ1ZmZlci51aW50OFZpZXcsXG4gICAgICB0aGlzLmZvcm1hdCxcbiAgICAgIHRoaXMubGV2ZWxzLFxuICAgICAgNCxcbiAgICAgIDQsXG4gICAgICAvLyBQVlJUQyBoYXMgOHg0IGJsb2NrcyBpbiAyYnBwIG1vZGVcbiAgICAgIHRoaXMud2lkdGgsXG4gICAgICB0aGlzLmhlaWdodFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSAodG8gQ29udGV4dFN5c3RlbSNleHRlbnNpb25zKSBmb3IgdGhlIFdlYkdMIGV4dGVuc2lvbiBzdXBwb3J0aW5nIHRoZSBjb21wcmVzc2lvbiBmb3JtYXRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGZvcm1hdCAtIHRoZSBjb21wcmVzc2lvbiBmb3JtYXQgdG8gZ2V0IHRoZSBleHRlbnNpb24gZm9yLlxuICAgKi9cbiAgc3RhdGljIF9mb3JtYXRUb0V4dGVuc2lvbihmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID49IDMzNzc2ICYmIGZvcm1hdCA8PSAzMzc3OSlcbiAgICAgIHJldHVybiBcInMzdGNcIjtcbiAgICBpZiAoZm9ybWF0ID49IDM3NDg4ICYmIGZvcm1hdCA8PSAzNzQ5NylcbiAgICAgIHJldHVybiBcImV0Y1wiO1xuICAgIGlmIChmb3JtYXQgPj0gMzU4NDAgJiYgZm9ybWF0IDw9IDM1ODQzKVxuICAgICAgcmV0dXJuIFwicHZydGNcIjtcbiAgICBpZiAoZm9ybWF0ID49IDM2MTk2KVxuICAgICAgcmV0dXJuIFwiZXRjMVwiO1xuICAgIGlmIChmb3JtYXQgPj0gMzU5ODYgJiYgZm9ybWF0IDw9IDM0Nzk4KVxuICAgICAgcmV0dXJuIFwiYXRjXCI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCAoY29tcHJlc3NlZCkgdGV4dHVyZSBmb3JtYXQgZ2l2ZW4hXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQcmUtY3JlYXRlcyBidWZmZXIgdmlld3MgZm9yIGVhY2ggbWlwbWFwIGxldmVsXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBidWZmZXIgLVxuICAgKiBAcGFyYW0gZm9ybWF0IC0gY29tcHJlc3Npb24gZm9ybWF0c1xuICAgKiBAcGFyYW0gbGV2ZWxzIC0gbWlwbWFwIGxldmVsc1xuICAgKiBAcGFyYW0gYmxvY2tXaWR0aCAtXG4gICAqIEBwYXJhbSBibG9ja0hlaWdodCAtXG4gICAqIEBwYXJhbSBpbWFnZVdpZHRoIC0gd2lkdGggb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAgKiBAcGFyYW0gaW1hZ2VIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVMZXZlbEJ1ZmZlcnMoYnVmZmVyLCBmb3JtYXQsIGxldmVscywgYmxvY2tXaWR0aCwgYmxvY2tIZWlnaHQsIGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IG5ldyBBcnJheShsZXZlbHMpO1xuICAgIGxldCBvZmZzZXQgPSBidWZmZXIuYnl0ZU9mZnNldCwgbGV2ZWxXaWR0aCA9IGltYWdlV2lkdGgsIGxldmVsSGVpZ2h0ID0gaW1hZ2VIZWlnaHQsIGFsaWduZWRMZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCArIGJsb2NrV2lkdGggLSAxICYgfihibG9ja1dpZHRoIC0gMSksIGFsaWduZWRMZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ICsgYmxvY2tIZWlnaHQgLSAxICYgfihibG9ja0hlaWdodCAtIDEpLCBsZXZlbFNpemUgPSBhbGlnbmVkTGV2ZWxXaWR0aCAqIGFsaWduZWRMZXZlbEhlaWdodCAqIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZm9ybWF0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsczsgaSsrKVxuICAgICAgYnVmZmVyc1tpXSA9IHtcbiAgICAgICAgbGV2ZWxJRDogaSxcbiAgICAgICAgbGV2ZWxXaWR0aDogbGV2ZWxzID4gMSA/IGxldmVsV2lkdGggOiBhbGlnbmVkTGV2ZWxXaWR0aCxcbiAgICAgICAgbGV2ZWxIZWlnaHQ6IGxldmVscyA+IDEgPyBsZXZlbEhlaWdodCA6IGFsaWduZWRMZXZlbEhlaWdodCxcbiAgICAgICAgbGV2ZWxCdWZmZXI6IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIG9mZnNldCwgbGV2ZWxTaXplKVxuICAgICAgfSwgb2Zmc2V0ICs9IGxldmVsU2l6ZSwgbGV2ZWxXaWR0aCA9IGxldmVsV2lkdGggPj4gMSB8fCAxLCBsZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ID4+IDEgfHwgMSwgYWxpZ25lZExldmVsV2lkdGggPSBsZXZlbFdpZHRoICsgYmxvY2tXaWR0aCAtIDEgJiB+KGJsb2NrV2lkdGggLSAxKSwgYWxpZ25lZExldmVsSGVpZ2h0ID0gbGV2ZWxIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSksIGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTFtmb3JtYXRdO1xuICAgIHJldHVybiBidWZmZXJzO1xuICB9XG59XG5leHBvcnQge1xuICBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBCbG9iUmVzb3VyY2UgfSBmcm9tIFwiLi9CbG9iUmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH0gZnJvbSBcIi4vQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanNcIjtcbmV4cG9ydCB7XG4gIEJsb2JSZXNvdXJjZSxcbiAgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IElOVEVSTkFMX0ZPUk1BVFMsIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgfSBmcm9tIFwiLi4vY29uc3QubWpzXCI7XG5pbXBvcnQgXCIuLi9yZXNvdXJjZXMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qc1wiO1xuY29uc3QgRERTX01BR0lDX1NJWkUgPSA0LCBERFNfSEVBREVSX1NJWkUgPSAxMjQsIEREU19IRUFERVJfUEZfU0laRSA9IDMyLCBERFNfSEVBREVSX0RYMTBfU0laRSA9IDIwLCBERFNfTUFHSUMgPSA1NDIzMjc4NzYsIEREU19GSUVMRFMgPSB7XG4gIFNJWkU6IDEsXG4gIEZMQUdTOiAyLFxuICBIRUlHSFQ6IDMsXG4gIFdJRFRIOiA0LFxuICBNSVBNQVBfQ09VTlQ6IDcsXG4gIFBJWEVMX0ZPUk1BVDogMTlcbn0sIEREU19QRl9GSUVMRFMgPSB7XG4gIFNJWkU6IDAsXG4gIEZMQUdTOiAxLFxuICBGT1VSQ0M6IDIsXG4gIFJHQl9CSVRDT1VOVDogMyxcbiAgUl9CSVRfTUFTSzogNCxcbiAgR19CSVRfTUFTSzogNSxcbiAgQl9CSVRfTUFTSzogNixcbiAgQV9CSVRfTUFTSzogN1xufSwgRERTX0RYMTBfRklFTERTID0ge1xuICBEWEdJX0ZPUk1BVDogMCxcbiAgUkVTT1VSQ0VfRElNRU5TSU9OOiAxLFxuICBNSVNDX0ZMQUc6IDIsXG4gIEFSUkFZX1NJWkU6IDMsXG4gIE1JU0NfRkxBR1MyOiA0XG59LCBQRl9GTEFHUyA9IDEsIEREUEZfQUxQSEEgPSAyLCBERFBGX0ZPVVJDQyA9IDQsIEREUEZfUkdCID0gNjQsIEREUEZfWVVWID0gNTEyLCBERFBGX0xVTUlOQU5DRSA9IDEzMTA3MiwgRk9VUkNDX0RYVDEgPSA4Mjc2MTEyMDQsIEZPVVJDQ19EWFQzID0gODYxMTY1NjM2LCBGT1VSQ0NfRFhUNSA9IDg5NDcyMDA2OCwgRk9VUkNDX0RYMTAgPSA4MDg1NDAyMjgsIEREU19SRVNPVVJDRV9NSVNDX1RFWFRVUkVDVUJFID0gNCwgRk9VUkNDX1RPX0ZPUk1BVCA9IHtcbiAgW0ZPVVJDQ19EWFQxXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCxcbiAgW0ZPVVJDQ19EWFQzXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcbiAgW0ZPVVJDQ19EWFQ1XTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxufSwgRFhHSV9UT19GT1JNQVQgPSB7XG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXG4gIDcwOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICA3MTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCxcbiAgNzM6IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gIDc0OiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhULFxuICA3NjogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCxcbiAgNzc6IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQsXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcbiAgNzI6IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQsXG4gIDc1OiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhULFxuICA3ODogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFxufTtcbmZ1bmN0aW9uIHBhcnNlRERTKGFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICBpZiAoZGF0YVswXSAhPT0gRERTX01BR0lDKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRERTIGZpbGUgbWFnaWMgd29yZFwiKTtcbiAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCAwLCBERFNfSEVBREVSX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCksIGhlaWdodCA9IGhlYWRlcltERFNfRklFTERTLkhFSUdIVF0sIHdpZHRoID0gaGVhZGVyW0REU19GSUVMRFMuV0lEVEhdLCBtaXBtYXBDb3VudCA9IGhlYWRlcltERFNfRklFTERTLk1JUE1BUF9DT1VOVF0sIHBpeGVsRm9ybWF0ID0gbmV3IFVpbnQzMkFycmF5KFxuICAgIGFycmF5QnVmZmVyLFxuICAgIEREU19GSUVMRFMuUElYRUxfRk9STUFUICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgRERTX0hFQURFUl9QRl9TSVpFIC8gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlRcbiAgKSwgZm9ybWF0RmxhZ3MgPSBwaXhlbEZvcm1hdFtQRl9GTEFHU107XG4gIGlmIChmb3JtYXRGbGFncyAmIEREUEZfRk9VUkNDKSB7XG4gICAgY29uc3QgZm91ckNDID0gcGl4ZWxGb3JtYXRbRERTX1BGX0ZJRUxEUy5GT1VSQ0NdO1xuICAgIGlmIChmb3VyQ0MgIT09IEZPVVJDQ19EWDEwKSB7XG4gICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdDIgPSBGT1VSQ0NfVE9fRk9STUFUW2ZvdXJDQ10sIGRhdGFPZmZzZXQyID0gRERTX01BR0lDX1NJWkUgKyBERFNfSEVBREVSX1NJWkUsIHRleERhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldDIpO1xuICAgICAgcmV0dXJuIFtuZXcgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSh0ZXhEYXRhLCB7XG4gICAgICAgIGZvcm1hdDogaW50ZXJuYWxGb3JtYXQyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBsZXZlbHM6IG1pcG1hcENvdW50XG4gICAgICAgIC8vIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2Ugd2lsbCBzZXBhcmF0ZSB0aGUgbGV2ZWxCdWZmZXJzIGZvciB1cyFcbiAgICAgIH0pXTtcbiAgICB9XG4gICAgY29uc3QgZHgxME9mZnNldCA9IEREU19NQUdJQ19TSVpFICsgRERTX0hFQURFUl9TSVpFLCBkeDEwSGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgZGF0YS5idWZmZXIsXG4gICAgICBkeDEwT2Zmc2V0LFxuICAgICAgRERTX0hFQURFUl9EWDEwX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVFxuICAgICksIGR4Z2lGb3JtYXQgPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5EWEdJX0ZPUk1BVF0sIHJlc291cmNlRGltZW5zaW9uID0gZHgxMEhlYWRlcltERFNfRFgxMF9GSUVMRFMuUkVTT1VSQ0VfRElNRU5TSU9OXSwgbWlzY0ZsYWcgPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5NSVNDX0ZMQUddLCBhcnJheVNpemUgPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5BUlJBWV9TSVpFXSwgaW50ZXJuYWxGb3JtYXQgPSBEWEdJX1RPX0ZPUk1BVFtkeGdpRm9ybWF0XTtcbiAgICBpZiAoaW50ZXJuYWxGb3JtYXQgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRERTUGFyc2VyIGNhbm5vdCBwYXJzZSB0ZXh0dXJlIGRhdGEgd2l0aCBEWEdJIGZvcm1hdCAke2R4Z2lGb3JtYXR9YCk7XG4gICAgaWYgKG1pc2NGbGFnID09PSBERFNfUkVTT1VSQ0VfTUlTQ19URVhUVVJFQ1VCRSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0IGN1YmVtYXAgdGV4dHVyZXNcIik7XG4gICAgaWYgKHJlc291cmNlRGltZW5zaW9uID09PSA2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnRlZCAzRCB0ZXh0dXJlIGRhdGFcIik7XG4gICAgY29uc3QgaW1hZ2VCdWZmZXJzID0gbmV3IEFycmF5KCksIGRhdGFPZmZzZXQgPSBERFNfTUFHSUNfU0laRSArIEREU19IRUFERVJfU0laRSArIEREU19IRUFERVJfRFgxMF9TSVpFO1xuICAgIGlmIChhcnJheVNpemUgPT09IDEpXG4gICAgICBpbWFnZUJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCkpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcGl4ZWxTaXplID0gSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTFtpbnRlcm5hbEZvcm1hdF07XG4gICAgICBsZXQgaW1hZ2VTaXplID0gMCwgbGV2ZWxXaWR0aCA9IHdpZHRoLCBsZXZlbEhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWlwbWFwQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBhbGlnbmVkTGV2ZWxXaWR0aCA9IE1hdGgubWF4KDEsIGxldmVsV2lkdGggKyAzICYgLTQpLCBhbGlnbmVkTGV2ZWxIZWlnaHQgPSBNYXRoLm1heCgxLCBsZXZlbEhlaWdodCArIDMgJiAtNCksIGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogcGl4ZWxTaXplO1xuICAgICAgICBpbWFnZVNpemUgKz0gbGV2ZWxTaXplLCBsZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCA+Pj4gMSwgbGV2ZWxIZWlnaHQgPSBsZXZlbEhlaWdodCA+Pj4gMTtcbiAgICAgIH1cbiAgICAgIGxldCBpbWFnZU9mZnNldCA9IGRhdGFPZmZzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5U2l6ZTsgaSsrKVxuICAgICAgICBpbWFnZUJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgaW1hZ2VPZmZzZXQsIGltYWdlU2l6ZSkpLCBpbWFnZU9mZnNldCArPSBpbWFnZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZUJ1ZmZlcnMubWFwKChidWZmZXIpID0+IG5ldyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlKGJ1ZmZlciwge1xuICAgICAgZm9ybWF0OiBpbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGV2ZWxzOiBtaXBtYXBDb3VudFxuICAgIH0pKTtcbiAgfVxuICB0aHJvdyBmb3JtYXRGbGFncyAmIEREUEZfUkdCID8gbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgdW5jb21wcmVzc2VkIHRleHR1cmUgZGF0YS5cIikgOiBmb3JtYXRGbGFncyAmIEREUEZfWVVWID8gbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnRlZCBZVVYgdW5jb21wcmVzc2VkIHRleHR1cmUgZGF0YS5cIikgOiBmb3JtYXRGbGFncyAmIEREUEZfTFVNSU5BTkNFID8gbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgc2luZ2xlLWNoYW5uZWwgKGx1bW5pbmFuY2UpIHRleHR1cmUgZGF0YSFcIikgOiBmb3JtYXRGbGFncyAmIEREUEZfQUxQSEEgPyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBzaW5nbGUtY2hhbm5lbCAoYWxwaGEpIHRleHR1cmUgZGF0YSFcIikgOiBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZmFpbGVkIHRvIGxvYWQgYSB0ZXh0dXJlIGZpbGUgZHVlIHRvIGFuIHVua25vd24gcmVhc29uIVwiKTtcbn1cbmV4cG9ydCB7XG4gIHBhcnNlRERTXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VERFMubWpzLm1hcFxuIiwiaW1wb3J0IHsgVFlQRVMsIEZPUk1BVFMsIEJ1ZmZlclJlc291cmNlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgfSBmcm9tIFwiLi4vY29uc3QubWpzXCI7XG5pbXBvcnQgXCIuLi9yZXNvdXJjZXMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qc1wiO1xuY29uc3QgRklMRV9JREVOVElGSUVSID0gWzE3MSwgNzUsIDg0LCA4OCwgMzIsIDQ5LCA0OSwgMTg3LCAxMywgMTAsIDI2LCAxMF0sIEVORElBTk5FU1MgPSA2NzMwNTk4NSwgS1RYX0ZJRUxEUyA9IHtcbiAgRklMRV9JREVOVElGSUVSOiAwLFxuICBFTkRJQU5ORVNTOiAxMixcbiAgR0xfVFlQRTogMTYsXG4gIEdMX1RZUEVfU0laRTogMjAsXG4gIEdMX0ZPUk1BVDogMjQsXG4gIEdMX0lOVEVSTkFMX0ZPUk1BVDogMjgsXG4gIEdMX0JBU0VfSU5URVJOQUxfRk9STUFUOiAzMixcbiAgUElYRUxfV0lEVEg6IDM2LFxuICBQSVhFTF9IRUlHSFQ6IDQwLFxuICBQSVhFTF9ERVBUSDogNDQsXG4gIE5VTUJFUl9PRl9BUlJBWV9FTEVNRU5UUzogNDgsXG4gIE5VTUJFUl9PRl9GQUNFUzogNTIsXG4gIE5VTUJFUl9PRl9NSVBNQVBfTEVWRUxTOiA1NixcbiAgQllURVNfT0ZfS0VZX1ZBTFVFX0RBVEE6IDYwXG59LCBGSUxFX0hFQURFUl9TSVpFID0gNjQsIFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQgPSB7XG4gIFtUWVBFUy5VTlNJR05FRF9CWVRFXTogMSxcbiAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXTogMixcbiAgW1RZUEVTLklOVF06IDQsXG4gIFtUWVBFUy5VTlNJR05FRF9JTlRdOiA0LFxuICBbVFlQRVMuRkxPQVRdOiA0LFxuICBbVFlQRVMuSEFMRl9GTE9BVF06IDhcbn0sIEZPUk1BVFNfVE9fQ09NUE9ORU5UUyA9IHtcbiAgW0ZPUk1BVFMuUkdCQV06IDQsXG4gIFtGT1JNQVRTLlJHQl06IDMsXG4gIFtGT1JNQVRTLlJHXTogMixcbiAgW0ZPUk1BVFMuUkVEXTogMSxcbiAgW0ZPUk1BVFMuTFVNSU5BTkNFXTogMSxcbiAgW0ZPUk1BVFMuTFVNSU5BTkNFX0FMUEhBXTogMixcbiAgW0ZPUk1BVFMuQUxQSEFdOiAxXG59LCBUWVBFU19UT19CWVRFU19QRVJfUElYRUwgPSB7XG4gIFtUWVBFUy5VTlNJR05FRF9TSE9SVF80XzRfNF80XTogMixcbiAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNV81XzFdOiAyLFxuICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNV82XzVdOiAyXG59O1xuZnVuY3Rpb24gcGFyc2VLVFgodXJsLCBhcnJheUJ1ZmZlciwgbG9hZEtleVZhbHVlRGF0YSA9ICExKSB7XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgaWYgKCF2YWxpZGF0ZSh1cmwsIGRhdGFWaWV3KSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbGl0dGxlRW5kaWFuID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuRU5ESUFOTkVTUywgITApID09PSBFTkRJQU5ORVNTLCBnbFR5cGUgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5HTF9UWVBFLCBsaXR0bGVFbmRpYW4pLCBnbEZvcm1hdCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLkdMX0ZPUk1BVCwgbGl0dGxlRW5kaWFuKSwgZ2xJbnRlcm5hbEZvcm1hdCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLkdMX0lOVEVSTkFMX0ZPUk1BVCwgbGl0dGxlRW5kaWFuKSwgcGl4ZWxXaWR0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLlBJWEVMX1dJRFRILCBsaXR0bGVFbmRpYW4pLCBwaXhlbEhlaWdodCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLlBJWEVMX0hFSUdIVCwgbGl0dGxlRW5kaWFuKSB8fCAxLCBwaXhlbERlcHRoID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuUElYRUxfREVQVEgsIGxpdHRsZUVuZGlhbikgfHwgMSwgbnVtYmVyT2ZBcnJheUVsZW1lbnRzID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuTlVNQkVSX09GX0FSUkFZX0VMRU1FTlRTLCBsaXR0bGVFbmRpYW4pIHx8IDEsIG51bWJlck9mRmFjZXMgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5OVU1CRVJfT0ZfRkFDRVMsIGxpdHRsZUVuZGlhbiksIG51bWJlck9mTWlwbWFwTGV2ZWxzID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuTlVNQkVSX09GX01JUE1BUF9MRVZFTFMsIGxpdHRsZUVuZGlhbiksIGJ5dGVzT2ZLZXlWYWx1ZURhdGEgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5CWVRFU19PRl9LRVlfVkFMVUVfREFUQSwgbGl0dGxlRW5kaWFuKTtcbiAgaWYgKHBpeGVsSGVpZ2h0ID09PSAwIHx8IHBpeGVsRGVwdGggIT09IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSAyRCB0ZXh0dXJlcyBhcmUgc3VwcG9ydGVkXCIpO1xuICBpZiAobnVtYmVyT2ZGYWNlcyAhPT0gMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdWJlVGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgS1RYTG9hZGVyIHlldCFcIik7XG4gIGlmIChudW1iZXJPZkFycmF5RWxlbWVudHMgIT09IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgZG9lcyBub3Qgc3VwcG9ydCBhcnJheSB0ZXh0dXJlc1wiKTtcbiAgY29uc3QgYmxvY2tXaWR0aCA9IDQsIGJsb2NrSGVpZ2h0ID0gNCwgYWxpZ25lZFdpZHRoID0gcGl4ZWxXaWR0aCArIDMgJiAtNCwgYWxpZ25lZEhlaWdodCA9IHBpeGVsSGVpZ2h0ICsgMyAmIC00LCBpbWFnZUJ1ZmZlcnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZBcnJheUVsZW1lbnRzKTtcbiAgbGV0IGltYWdlUGl4ZWxzID0gcGl4ZWxXaWR0aCAqIHBpeGVsSGVpZ2h0O1xuICBnbFR5cGUgPT09IDAgJiYgKGltYWdlUGl4ZWxzID0gYWxpZ25lZFdpZHRoICogYWxpZ25lZEhlaWdodCk7XG4gIGxldCBpbWFnZVBpeGVsQnl0ZVNpemU7XG4gIGlmIChnbFR5cGUgIT09IDAgPyBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UW2dsVHlwZV0gPyBpbWFnZVBpeGVsQnl0ZVNpemUgPSBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UW2dsVHlwZV0gKiBGT1JNQVRTX1RPX0NPTVBPTkVOVFNbZ2xGb3JtYXRdIDogaW1hZ2VQaXhlbEJ5dGVTaXplID0gVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMW2dsVHlwZV0gOiBpbWFnZVBpeGVsQnl0ZVNpemUgPSBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMW2dsSW50ZXJuYWxGb3JtYXRdLCBpbWFnZVBpeGVsQnl0ZVNpemUgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSB0aGUgcGl4ZWwgZm9ybWF0IHN0b3JlZCBpbiB0aGUgKi5rdHggZmlsZSFcIik7XG4gIGNvbnN0IGt2RGF0YSA9IGxvYWRLZXlWYWx1ZURhdGEgPyBwYXJzZUt2RGF0YShkYXRhVmlldywgYnl0ZXNPZktleVZhbHVlRGF0YSwgbGl0dGxlRW5kaWFuKSA6IG51bGw7XG4gIGxldCBtaXBCeXRlU2l6ZSA9IGltYWdlUGl4ZWxzICogaW1hZ2VQaXhlbEJ5dGVTaXplLCBtaXBXaWR0aCA9IHBpeGVsV2lkdGgsIG1pcEhlaWdodCA9IHBpeGVsSGVpZ2h0LCBhbGlnbmVkTWlwV2lkdGggPSBhbGlnbmVkV2lkdGgsIGFsaWduZWRNaXBIZWlnaHQgPSBhbGlnbmVkSGVpZ2h0LCBpbWFnZU9mZnNldCA9IEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc09mS2V5VmFsdWVEYXRhO1xuICBmb3IgKGxldCBtaXBtYXBMZXZlbCA9IDA7IG1pcG1hcExldmVsIDwgbnVtYmVyT2ZNaXBtYXBMZXZlbHM7IG1pcG1hcExldmVsKyspIHtcbiAgICBjb25zdCBpbWFnZVNpemUgPSBkYXRhVmlldy5nZXRVaW50MzIoaW1hZ2VPZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGVsZW1lbnRPZmZzZXQgPSBpbWFnZU9mZnNldCArIDQ7XG4gICAgZm9yIChsZXQgYXJyYXlFbGVtZW50ID0gMDsgYXJyYXlFbGVtZW50IDwgbnVtYmVyT2ZBcnJheUVsZW1lbnRzOyBhcnJheUVsZW1lbnQrKykge1xuICAgICAgbGV0IG1pcHMgPSBpbWFnZUJ1ZmZlcnNbYXJyYXlFbGVtZW50XTtcbiAgICAgIG1pcHMgfHwgKG1pcHMgPSBpbWFnZUJ1ZmZlcnNbYXJyYXlFbGVtZW50XSA9IG5ldyBBcnJheShudW1iZXJPZk1pcG1hcExldmVscykpLCBtaXBzW21pcG1hcExldmVsXSA9IHtcbiAgICAgICAgbGV2ZWxJRDogbWlwbWFwTGV2ZWwsXG4gICAgICAgIC8vIGRvbid0IGFsaWduIG1pcFdpZHRoIHdoZW4gdGV4dHVyZSBub3QgY29tcHJlc3NlZCEgKGdsVHlwZSBub3QgemVybylcbiAgICAgICAgbGV2ZWxXaWR0aDogbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPiAxIHx8IGdsVHlwZSAhPT0gMCA/IG1pcFdpZHRoIDogYWxpZ25lZE1pcFdpZHRoLFxuICAgICAgICBsZXZlbEhlaWdodDogbnVtYmVyT2ZNaXBtYXBMZXZlbHMgPiAxIHx8IGdsVHlwZSAhPT0gMCA/IG1pcEhlaWdodCA6IGFsaWduZWRNaXBIZWlnaHQsXG4gICAgICAgIGxldmVsQnVmZmVyOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZWxlbWVudE9mZnNldCwgbWlwQnl0ZVNpemUpXG4gICAgICB9LCBlbGVtZW50T2Zmc2V0ICs9IG1pcEJ5dGVTaXplO1xuICAgIH1cbiAgICBpbWFnZU9mZnNldCArPSBpbWFnZVNpemUgKyA0LCBpbWFnZU9mZnNldCA9IGltYWdlT2Zmc2V0ICUgNCAhPT0gMCA/IGltYWdlT2Zmc2V0ICsgNCAtIGltYWdlT2Zmc2V0ICUgNCA6IGltYWdlT2Zmc2V0LCBtaXBXaWR0aCA9IG1pcFdpZHRoID4+IDEgfHwgMSwgbWlwSGVpZ2h0ID0gbWlwSGVpZ2h0ID4+IDEgfHwgMSwgYWxpZ25lZE1pcFdpZHRoID0gbWlwV2lkdGggKyBibG9ja1dpZHRoIC0gMSAmIH4oYmxvY2tXaWR0aCAtIDEpLCBhbGlnbmVkTWlwSGVpZ2h0ID0gbWlwSGVpZ2h0ICsgYmxvY2tIZWlnaHQgLSAxICYgfihibG9ja0hlaWdodCAtIDEpLCBtaXBCeXRlU2l6ZSA9IGFsaWduZWRNaXBXaWR0aCAqIGFsaWduZWRNaXBIZWlnaHQgKiBpbWFnZVBpeGVsQnl0ZVNpemU7XG4gIH1cbiAgcmV0dXJuIGdsVHlwZSAhPT0gMCA/IHtcbiAgICB1bmNvbXByZXNzZWQ6IGltYWdlQnVmZmVycy5tYXAoKGxldmVsQnVmZmVycykgPT4ge1xuICAgICAgbGV0IGJ1ZmZlciA9IGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlciwgY29udmVydFRvSW50ID0gITE7XG4gICAgICByZXR1cm4gZ2xUeXBlID09PSBUWVBFUy5GTE9BVCA/IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5idWZmZXIsXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZUxlbmd0aCAvIDRcbiAgICAgICkgOiBnbFR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0lOVCA/IChjb252ZXJ0VG9JbnQgPSAhMCwgYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnVmZmVyLFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVMZW5ndGggLyA0XG4gICAgICApKSA6IGdsVHlwZSA9PT0gVFlQRVMuSU5UICYmIChjb252ZXJ0VG9JbnQgPSAhMCwgYnVmZmVyID0gbmV3IEludDMyQXJyYXkoXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5idWZmZXIsXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZUxlbmd0aCAvIDRcbiAgICAgICkpLCB7XG4gICAgICAgIHJlc291cmNlOiBuZXcgQnVmZmVyUmVzb3VyY2UoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbGV2ZWxCdWZmZXJzWzBdLmxldmVsSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB0eXBlOiBnbFR5cGUsXG4gICAgICAgIGZvcm1hdDogY29udmVydFRvSW50ID8gY29udmVydEZvcm1hdFRvSW50ZWdlcihnbEZvcm1hdCkgOiBnbEZvcm1hdFxuICAgICAgfTtcbiAgICB9KSxcbiAgICBrdkRhdGFcbiAgfSA6IHtcbiAgICBjb21wcmVzc2VkOiBpbWFnZUJ1ZmZlcnMubWFwKChsZXZlbEJ1ZmZlcnMpID0+IG5ldyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlKG51bGwsIHtcbiAgICAgIGZvcm1hdDogZ2xJbnRlcm5hbEZvcm1hdCxcbiAgICAgIHdpZHRoOiBwaXhlbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwaXhlbEhlaWdodCxcbiAgICAgIGxldmVsczogbnVtYmVyT2ZNaXBtYXBMZXZlbHMsXG4gICAgICBsZXZlbEJ1ZmZlcnNcbiAgICB9KSksXG4gICAga3ZEYXRhXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZSh1cmwsIGRhdGFWaWV3KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgRklMRV9JREVOVElGSUVSLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChpKSAhPT0gRklMRV9JREVOVElGSUVSW2ldKVxuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYCR7dXJsfSBpcyBub3QgYSB2YWxpZCAqLmt0eCBmaWxlIWApLCAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gY29udmVydEZvcm1hdFRvSW50ZWdlcihmb3JtYXQpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIEZPUk1BVFMuUkdCQTpcbiAgICAgIHJldHVybiBGT1JNQVRTLlJHQkFfSU5URUdFUjtcbiAgICBjYXNlIEZPUk1BVFMuUkdCOlxuICAgICAgcmV0dXJuIEZPUk1BVFMuUkdCX0lOVEVHRVI7XG4gICAgY2FzZSBGT1JNQVRTLlJHOlxuICAgICAgcmV0dXJuIEZPUk1BVFMuUkdfSU5URUdFUjtcbiAgICBjYXNlIEZPUk1BVFMuUkVEOlxuICAgICAgcmV0dXJuIEZPUk1BVFMuUkVEX0lOVEVHRVI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlS3ZEYXRhKGRhdGFWaWV3LCBieXRlc09mS2V5VmFsdWVEYXRhLCBsaXR0bGVFbmRpYW4pIHtcbiAgY29uc3Qga3ZEYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGJ5dGVzSW50b0tleVZhbHVlRGF0YSA9IDA7XG4gIGZvciAoOyBieXRlc0ludG9LZXlWYWx1ZURhdGEgPCBieXRlc09mS2V5VmFsdWVEYXRhOyApIHtcbiAgICBjb25zdCBrZXlBbmRWYWx1ZUJ5dGVTaXplID0gZGF0YVZpZXcuZ2V0VWludDMyKEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc0ludG9LZXlWYWx1ZURhdGEsIGxpdHRsZUVuZGlhbiksIGtleUFuZFZhbHVlQnl0ZU9mZnNldCA9IEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc0ludG9LZXlWYWx1ZURhdGEgKyA0LCB2YWx1ZVBhZGRpbmcgPSAzIC0gKGtleUFuZFZhbHVlQnl0ZVNpemUgKyAzKSAlIDQ7XG4gICAgaWYgKGtleUFuZFZhbHVlQnl0ZVNpemUgPT09IDAgfHwga2V5QW5kVmFsdWVCeXRlU2l6ZSA+IGJ5dGVzT2ZLZXlWYWx1ZURhdGEgLSBieXRlc0ludG9LZXlWYWx1ZURhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJLVFhMb2FkZXI6IGtleUFuZFZhbHVlQnl0ZVNpemUgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQga2V5TnVsQnl0ZSA9IDA7XG4gICAgZm9yICg7IGtleU51bEJ5dGUgPCBrZXlBbmRWYWx1ZUJ5dGVTaXplICYmIGRhdGFWaWV3LmdldFVpbnQ4KGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUpICE9PSAwOyBrZXlOdWxCeXRlKyspXG4gICAgICA7XG4gICAgaWYgKGtleU51bEJ5dGUgPT09IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiS1RYTG9hZGVyOiBGYWlsZWQgdG8gZmluZCBudWxsIGJ5dGUgdGVybWluYXRpbmcga3ZEYXRhIGtleVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoXG4gICAgICBuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGtleUFuZFZhbHVlQnl0ZU9mZnNldCwga2V5TnVsQnl0ZSlcbiAgICApLCB2YWx1ZSA9IG5ldyBEYXRhVmlldyhcbiAgICAgIGRhdGFWaWV3LmJ1ZmZlcixcbiAgICAgIGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUgKyAxLFxuICAgICAga2V5QW5kVmFsdWVCeXRlU2l6ZSAtIGtleU51bEJ5dGUgLSAxXG4gICAgKTtcbiAgICBrdkRhdGEuc2V0KGtleSwgdmFsdWUpLCBieXRlc0ludG9LZXlWYWx1ZURhdGEgKz0gNCArIGtleUFuZFZhbHVlQnl0ZVNpemUgKyB2YWx1ZVBhZGRpbmc7XG4gIH1cbiAgcmV0dXJuIGt2RGF0YTtcbn1cbmV4cG9ydCB7XG4gIEZPUk1BVFNfVE9fQ09NUE9ORU5UUyxcbiAgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCxcbiAgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMLFxuICBwYXJzZUtUWFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlS1RYLm1qcy5tYXBcbiIsImltcG9ydCB7IHBhcnNlRERTIH0gZnJvbSBcIi4vcGFyc2VERFMubWpzXCI7XG5pbXBvcnQgeyBGT1JNQVRTX1RPX0NPTVBPTkVOVFMsIFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQsIFRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTCwgcGFyc2VLVFggfSBmcm9tIFwiLi9wYXJzZUtUWC5tanNcIjtcbmV4cG9ydCB7XG4gIEZPUk1BVFNfVE9fQ09NUE9ORU5UUyxcbiAgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCxcbiAgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMLFxuICBwYXJzZUREUyxcbiAgcGFyc2VLVFhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSwgY2hlY2tFeHRlbnNpb24sIGNyZWF0ZVRleHR1cmUgfSBmcm9tIFwiQHBpeGkvYXNzZXRzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgQmFzZVRleHR1cmUsIE1JUE1BUF9NT0RFUywgQUxQSEFfTU9ERVMsIHV0aWxzLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCBcIi4uL3BhcnNlcnMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBwYXJzZUREUyB9IGZyb20gXCIuLi9wYXJzZXJzL3BhcnNlRERTLm1qc1wiO1xuY29uc3QgbG9hZEREUyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZEREU1wiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0V4dGVuc2lvbih1cmwsIFwiLmRkc1wiKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIGFzc2V0LCBsb2FkZXIpIHtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IChhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLmFycmF5QnVmZmVyKCksIHRleHR1cmVzID0gcGFyc2VERFMoYXJyYXlCdWZmZXIpLm1hcCgocmVzb3VyY2UpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgQmFzZVRleHR1cmUocmVzb3VyY2UsIHtcbiAgICAgICAgbWlwbWFwOiBNSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgICBhbHBoYU1vZGU6IEFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgICAuLi5hc3NldC5kYXRhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dHVyZXMubGVuZ3RoID09PSAxID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlcztcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICBBcnJheS5pc0FycmF5KHRleHR1cmUpID8gdGV4dHVyZS5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3koITApKSA6IHRleHR1cmUuZGVzdHJveSghMCk7XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChsb2FkRERTKTtcbmV4cG9ydCB7XG4gIGxvYWRERFNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkRERTLm1qcy5tYXBcbiIsImltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5LCBjaGVja0V4dGVuc2lvbiwgY3JlYXRlVGV4dHVyZSB9IGZyb20gXCJAcGl4aS9hc3NldHNcIjtcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBNSVBNQVBfTU9ERVMsIEFMUEhBX01PREVTLCB1dGlscywgQmFzZVRleHR1cmUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IFwiLi4vcGFyc2Vycy9pbmRleC5tanNcIjtcbmltcG9ydCB7IHBhcnNlS1RYIH0gZnJvbSBcIi4uL3BhcnNlcnMvcGFyc2VLVFgubWpzXCI7XG5jb25zdCBsb2FkS1RYID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgbmFtZTogXCJsb2FkS1RYXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRXh0ZW5zaW9uKHVybCwgXCIua3R4XCIpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgYXNzZXQsIGxvYWRlcikge1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgKGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKSkuYXJyYXlCdWZmZXIoKSwgeyBjb21wcmVzc2VkLCB1bmNvbXByZXNzZWQsIGt2RGF0YSB9ID0gcGFyc2VLVFgodXJsLCBhcnJheUJ1ZmZlciksIHJlc291cmNlcyA9IGNvbXByZXNzZWQgPz8gdW5jb21wcmVzc2VkLCBvcHRpb25zID0ge1xuICAgICAgbWlwbWFwOiBNSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgYWxwaGFNb2RlOiBBTFBIQV9NT0RFUy5OT19QUkVNVUxUSVBMSUVEX0FMUEhBLFxuICAgICAgcmVzb2x1dGlvbjogdXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAuLi5hc3NldC5kYXRhXG4gICAgfSwgdGV4dHVyZXMgPSByZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4ge1xuICAgICAgcmVzb3VyY2VzID09PSB1bmNvbXByZXNzZWQgJiYgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgIHR5cGU6IHJlc291cmNlLnR5cGUsXG4gICAgICAgIGZvcm1hdDogcmVzb3VyY2UuZm9ybWF0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlcyA9IHJlc291cmNlLnJlc291cmNlID8/IHJlc291cmNlLCBiYXNlID0gbmV3IEJhc2VUZXh0dXJlKHJlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gYmFzZS5rdHhLZXlWYWx1ZURhdGEgPSBrdkRhdGEsIGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0dXJlcy5sZW5ndGggPT09IDEgPyB0ZXh0dXJlc1swXSA6IHRleHR1cmVzO1xuICB9LFxuICB1bmxvYWQodGV4dHVyZSkge1xuICAgIEFycmF5LmlzQXJyYXkodGV4dHVyZSkgPyB0ZXh0dXJlLmZvckVhY2goKHQpID0+IHQuZGVzdHJveSghMCkpIDogdGV4dHVyZS5kZXN0cm95KCEwKTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRLVFgpO1xuZXhwb3J0IHtcbiAgbG9hZEtUWFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRLVFgubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgdXRpbHMsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmNvbnN0IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCA9IHtcbiAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIHRlc3Q6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHV0aWxzLnBhdGguZXh0bmFtZSh2YWx1ZSkuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFtcImJhc2lzXCIsIFwia3R4XCIsIFwiZGRzXCJdLmluY2x1ZGVzKGV4dGVuc2lvbik7XG4gIH0sXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBleHRlbnNpb24gPSB1dGlscy5wYXRoLmV4dG5hbWUodmFsdWUpLnNsaWNlKDEpO1xuICAgIGlmIChleHRlbnNpb24gPT09IFwia3R4XCIpIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbnMyID0gW1xuICAgICAgICBcIi5zM3RjLmt0eFwiLFxuICAgICAgICBcIi5zM3RjX3NSR0Iua3R4XCIsXG4gICAgICAgIFwiLmV0Yy5rdHhcIixcbiAgICAgICAgXCIuZXRjMS5rdHhcIixcbiAgICAgICAgXCIucHZydC5rdHhcIixcbiAgICAgICAgXCIuYXRjLmt0eFwiLFxuICAgICAgICBcIi5hc3RjLmt0eFwiXG4gICAgICBdO1xuICAgICAgaWYgKGV4dGVuc2lvbnMyLnNvbWUoKGV4dCkgPT4gdmFsdWUuZW5kc1dpdGgoZXh0KSkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChzZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgICAgIGZvcm1hdDogZXh0ZW5zaW9uczIuZmluZCgoZXh0KSA9PiB2YWx1ZS5lbmRzV2l0aChleHQpKSxcbiAgICAgICAgICBzcmM6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KHNldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyBcIjFcIiksXG4gICAgICBmb3JtYXQ6IGV4dGVuc2lvbixcbiAgICAgIHNyYzogdmFsdWVcbiAgICB9O1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQocmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsKTtcbmV4cG9ydCB7XG4gIHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5tanMubWFwXG4iLCJpbXBvcnQgXCIuL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanNcIjtcbmltcG9ydCB7IGRldGVjdENvbXByZXNzZWRUZXh0dXJlcyB9IGZyb20gXCIuL2RldGVjdENvbXByZXNzZWRUZXh0dXJlcy5tanNcIjtcbmltcG9ydCB7IGxvYWRERFMgfSBmcm9tIFwiLi9sb2FkRERTLm1qc1wiO1xuaW1wb3J0IHsgbG9hZEtUWCB9IGZyb20gXCIuL2xvYWRLVFgubWpzXCI7XG5pbXBvcnQgeyByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwgfSBmcm9tIFwiLi9yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwubWpzXCI7XG5leHBvcnQge1xuICBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMsXG4gIGxvYWRERFMsXG4gIGxvYWRLVFgsXG4gIHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IElOVEVSTkFMX0ZPUk1BVFMsIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgfSBmcm9tIFwiLi9jb25zdC5tanNcIjtcbmltcG9ydCBcIi4vbG9hZGVycy9pbmRleC5tanNcIjtcbmltcG9ydCBcIi4vcGFyc2Vycy9pbmRleC5tanNcIjtcbmltcG9ydCBcIi4vcmVzb3VyY2VzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzIH0gZnJvbSBcIi4vbG9hZGVycy9kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMubWpzXCI7XG5pbXBvcnQgeyBsb2FkRERTIH0gZnJvbSBcIi4vbG9hZGVycy9sb2FkRERTLm1qc1wiO1xuaW1wb3J0IHsgbG9hZEtUWCB9IGZyb20gXCIuL2xvYWRlcnMvbG9hZEtUWC5tanNcIjtcbmltcG9ydCB7IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCB9IGZyb20gXCIuL2xvYWRlcnMvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qc1wiO1xuaW1wb3J0IHsgcGFyc2VERFMgfSBmcm9tIFwiLi9wYXJzZXJzL3BhcnNlRERTLm1qc1wiO1xuaW1wb3J0IHsgRk9STUFUU19UT19DT01QT05FTlRTLCBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5ULCBUWVBFU19UT19CWVRFU19QRVJfUElYRUwsIHBhcnNlS1RYIH0gZnJvbSBcIi4vcGFyc2Vycy9wYXJzZUtUWC5tanNcIjtcbmltcG9ydCB7IEJsb2JSZXNvdXJjZSB9IGZyb20gXCIuL3Jlc291cmNlcy9CbG9iUmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH0gZnJvbSBcIi4vcmVzb3VyY2VzL0NvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzXCI7XG5leHBvcnQge1xuICBCbG9iUmVzb3VyY2UsXG4gIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UsXG4gIEZPUk1BVFNfVE9fQ09NUE9ORU5UUyxcbiAgSU5URVJOQUxfRk9STUFUUyxcbiAgSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCxcbiAgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCxcbiAgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMLFxuICBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMsXG4gIGxvYWRERFMsXG4gIGxvYWRLVFgsXG4gIHBhcnNlRERTLFxuICBwYXJzZUtUWCxcbiAgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlLCB1dGlscywgUmVuZGVyVGV4dHVyZSwgRk9STUFUUywgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jb25zdCBURU1QX1JFQ1QgPSBuZXcgUmVjdGFuZ2xlKCksIEJZVEVTX1BFUl9QSVhFTCA9IDQsIF9FeHRyYWN0ID0gY2xhc3MgX0V4dHJhY3QyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5fcmVuZGVyZXJQcmVtdWx0aXBsaWVkQWxwaGEgPSAhMTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLnJlbmRlcmVyPy5nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHRoaXMuX3JlbmRlcmVyUHJlbXVsdGlwbGllZEFscGhhID0gISEoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmFscGhhICYmIGF0dHJpYnV0ZXMucHJlbXVsdGlwbGllZEFscGhhKTtcbiAgfVxuICAvKipcbiAgICogV2lsbCByZXR1cm4gYSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcbiAgICogQHBhcmFtIHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBmb3JtYXQgLSBJbWFnZSBmb3JtYXQsIGUuZy4gXCJpbWFnZS9qcGVnXCIgb3IgXCJpbWFnZS93ZWJwXCIuXG4gICAqIEBwYXJhbSBxdWFsaXR5IC0gSlBFRyBvciBXZWJwIGNvbXByZXNzaW9uIGZyb20gMCB0byAxLiBEZWZhdWx0IGlzIDAuOTIuXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSB0aGUgZXh0cmFjdGlvbiBpcyByZXN0cmljdGVkIHRvLlxuICAgKiBAcmV0dXJucyAtIEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgKi9cbiAgYXN5bmMgaW1hZ2UodGFyZ2V0LCBmb3JtYXQsIHF1YWxpdHksIGZyYW1lKSB7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICByZXR1cm4gaW1hZ2Uuc3JjID0gYXdhaXQgdGhpcy5iYXNlNjQodGFyZ2V0LCBmb3JtYXQsIHF1YWxpdHksIGZyYW1lKSwgaW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgcmV0dXJuIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoaXMgdGFyZ2V0LiBJdCB3b3JrcyBieSBjYWxsaW5nXG4gICAqICBgRXh0cmFjdC5jYW52YXNgIGFuZCB0aGVuIHJ1bm5pbmcgdG9EYXRhVVJMIG9uIHRoYXQuXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgKiBAcGFyYW0gZm9ybWF0IC0gSW1hZ2UgZm9ybWF0LCBlLmcuIFwiaW1hZ2UvanBlZ1wiIG9yIFwiaW1hZ2Uvd2VicFwiLlxuICAgKiBAcGFyYW0gcXVhbGl0eSAtIEpQRUcgb3IgV2VicCBjb21wcmVzc2lvbiBmcm9tIDAgdG8gMS4gRGVmYXVsdCBpcyAwLjkyLlxuICAgKiBAcGFyYW0gZnJhbWUgLSBUaGUgZnJhbWUgdGhlIGV4dHJhY3Rpb24gaXMgcmVzdHJpY3RlZCB0by5cbiAgICogQHJldHVybnMgLSBBIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgdGV4dHVyZS5cbiAgICovXG4gIGFzeW5jIGJhc2U2NCh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSwgZnJhbWUpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcyh0YXJnZXQsIGZyYW1lKTtcbiAgICBpZiAoY2FudmFzLnRvQmxvYiAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICAgIGlmICghYmxvYikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIklDYW52YXMudG9CbG9iIGZhaWxlZCFcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpLCByZWFkZXIub25lcnJvciA9IHJlamVjdCwgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgIH0sIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgICB9KTtcbiAgICBpZiAoY2FudmFzLnRvRGF0YVVSTCAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoZm9ybWF0LCBxdWFsaXR5KTtcbiAgICBpZiAoY2FudmFzLmNvbnZlcnRUb0Jsb2IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGNhbnZhcy5jb252ZXJ0VG9CbG9iKHsgdHlwZTogZm9ybWF0LCBxdWFsaXR5IH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCksIHJlYWRlci5vbmVycm9yID0gcmVqZWN0LCByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRyYWN0LmJhc2U2NCgpIHJlcXVpcmVzIElDYW52YXMudG9EYXRhVVJMLCBJQ2FudmFzLnRvQmxvYiwgb3IgSUNhbnZhcy5jb252ZXJ0VG9CbG9iIHRvIGJlIGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQsIHJlbmRlcnMgdGhpcyB0YXJnZXQgdG8gaXQgYW5kIHRoZW4gcmV0dXJucyBpdC5cbiAgICogQHBhcmFtIHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSB0aGUgZXh0cmFjdGlvbiBpcyByZXN0cmljdGVkIHRvLlxuICAgKiBAcmV0dXJucyAtIEEgQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgdGV4dHVyZSByZW5kZXJlZCBvbi5cbiAgICovXG4gIGNhbnZhcyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgeyBwaXhlbHMsIHdpZHRoLCBoZWlnaHQsIGZsaXBZLCBwcmVtdWx0aXBsaWVkQWxwaGEgfSA9IHRoaXMuX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKTtcbiAgICBmbGlwWSAmJiBfRXh0cmFjdDIuX2ZsaXBZKHBpeGVscywgd2lkdGgsIGhlaWdodCksIHByZW11bHRpcGxpZWRBbHBoYSAmJiBfRXh0cmFjdDIuX3VucHJlbXVsdGlwbHlBbHBoYShwaXhlbHMpO1xuICAgIGNvbnN0IGNhbnZhc0J1ZmZlciA9IG5ldyB1dGlscy5DYW52YXNSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgMSksIGltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVscy5idWZmZXIpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gY2FudmFzQnVmZmVyLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCksIGNhbnZhc0J1ZmZlci5jYW52YXM7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgcmV0dXJuIGEgb25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgdGhlIGVudGlyZSB0ZXh0dXJlIGluIFJHQkFcbiAgICogb3JkZXIsIHdpdGggaW50ZWdlciB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTUgKGluY2x1ZGVkKS5cbiAgICogQHBhcmFtIHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSB0aGUgZXh0cmFjdGlvbiBpcyByZXN0cmljdGVkIHRvLlxuICAgKiBAcmV0dXJucyAtIE9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZVxuICAgKi9cbiAgcGl4ZWxzKHRhcmdldCwgZnJhbWUpIHtcbiAgICBjb25zdCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCwgZmxpcFksIHByZW11bHRpcGxpZWRBbHBoYSB9ID0gdGhpcy5fcmF3UGl4ZWxzKHRhcmdldCwgZnJhbWUpO1xuICAgIHJldHVybiBmbGlwWSAmJiBfRXh0cmFjdDIuX2ZsaXBZKHBpeGVscywgd2lkdGgsIGhlaWdodCksIHByZW11bHRpcGxpZWRBbHBoYSAmJiBfRXh0cmFjdDIuX3VucHJlbXVsdGlwbHlBbHBoYShwaXhlbHMpLCBwaXhlbHM7XG4gIH1cbiAgX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmICghcmVuZGVyZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRXh0cmFjdCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZFwiKTtcbiAgICBsZXQgcmVzb2x1dGlvbiwgZmxpcFkgPSAhMSwgcHJlbXVsdGlwbGllZEFscGhhID0gITEsIHJlbmRlclRleHR1cmUsIGdlbmVyYXRlZCA9ICExO1xuICAgIHRhcmdldCAmJiAodGFyZ2V0IGluc3RhbmNlb2YgUmVuZGVyVGV4dHVyZSA/IHJlbmRlclRleHR1cmUgPSB0YXJnZXQgOiAocmVuZGVyVGV4dHVyZSA9IHJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZSh0YXJnZXQsIHtcbiAgICAgIHJlZ2lvbjogZnJhbWUsXG4gICAgICByZXNvbHV0aW9uOiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgbXVsdGlzYW1wbGU6IHJlbmRlcmVyLm11bHRpc2FtcGxlXG4gICAgfSksIGdlbmVyYXRlZCA9ICEwLCBmcmFtZSAmJiAoVEVNUF9SRUNULndpZHRoID0gZnJhbWUud2lkdGgsIFRFTVBfUkVDVC5oZWlnaHQgPSBmcmFtZS5oZWlnaHQsIGZyYW1lID0gVEVNUF9SRUNUKSkpO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uLCBmcmFtZSA9IGZyYW1lID8/IHJlbmRlclRleHR1cmUuZnJhbWUsIGZsaXBZID0gITEsIHByZW11bHRpcGxpZWRBbHBoYSA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCAmJiByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLmZvcm1hdCA9PT0gRk9STUFUUy5SR0JBLCAhZ2VuZXJhdGVkKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgY29uc3QgZmJvID0gcmVuZGVyVGV4dHVyZS5mcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1tyZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIgJiYgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChmYm8uYmxpdEZyYW1lYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uLCBmcmFtZSB8fCAoZnJhbWUgPSBURU1QX1JFQ1QsIGZyYW1lLndpZHRoID0gcmVuZGVyZXIud2lkdGggLyByZXNvbHV0aW9uLCBmcmFtZS5oZWlnaHQgPSByZW5kZXJlci5oZWlnaHQgLyByZXNvbHV0aW9uKSwgZmxpcFkgPSAhMCwgcHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5fcmVuZGVyZXJQcmVtdWx0aXBsaWVkQWxwaGEsIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZCgpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZChmcmFtZS53aWR0aCAqIHJlc29sdXRpb24pLCAxKSwgaGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZChmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uKSwgMSksIHBpeGVscyA9IG5ldyBVaW50OEFycmF5KEJZVEVTX1BFUl9QSVhFTCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICByZXR1cm4gZ2wucmVhZFBpeGVscyhcbiAgICAgIE1hdGgucm91bmQoZnJhbWUueCAqIHJlc29sdXRpb24pLFxuICAgICAgTWF0aC5yb3VuZChmcmFtZS55ICogcmVzb2x1dGlvbiksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGdsLlJHQkEsXG4gICAgICBnbC5VTlNJR05FRF9CWVRFLFxuICAgICAgcGl4ZWxzXG4gICAgKSwgZ2VuZXJhdGVkICYmIHJlbmRlclRleHR1cmU/LmRlc3Ryb3koITApLCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCwgZmxpcFksIHByZW11bHRpcGxpZWRBbHBoYSB9O1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgZXh0cmFjdC4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgX2ZsaXBZKHBpeGVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHcgPSB3aWR0aCA8PCAyLCBoID0gaGVpZ2h0ID4+IDEsIHRlbXAgPSBuZXcgVWludDhBcnJheSh3KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGg7IHkrKykge1xuICAgICAgY29uc3QgdCA9IHkgKiB3LCBiID0gKGhlaWdodCAtIHkgLSAxKSAqIHc7XG4gICAgICB0ZW1wLnNldChwaXhlbHMuc3ViYXJyYXkodCwgdCArIHcpKSwgcGl4ZWxzLmNvcHlXaXRoaW4odCwgYiwgYiArIHcpLCBwaXhlbHMuc2V0KHRlbXAsIGIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX3VucHJlbXVsdGlwbHlBbHBoYShwaXhlbHMpIHtcbiAgICBwaXhlbHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSAmJiAocGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkocGl4ZWxzLmJ1ZmZlcikpO1xuICAgIGNvbnN0IG4gPSBwaXhlbHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSA0KSB7XG4gICAgICBjb25zdCBhbHBoYSA9IHBpeGVsc1tpICsgM107XG4gICAgICBpZiAoYWxwaGEgIT09IDApIHtcbiAgICAgICAgY29uc3QgYSA9IDI1NS4wMDEgLyBhbHBoYTtcbiAgICAgICAgcGl4ZWxzW2ldID0gcGl4ZWxzW2ldICogYSArIDAuNSwgcGl4ZWxzW2kgKyAxXSA9IHBpeGVsc1tpICsgMV0gKiBhICsgMC41LCBwaXhlbHNbaSArIDJdID0gcGl4ZWxzW2kgKyAyXSAqIGEgKyAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuX0V4dHJhY3QuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImV4dHJhY3RcIixcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbVxufTtcbmxldCBFeHRyYWN0ID0gX0V4dHJhY3Q7XG5leHRlbnNpb25zLmFkZChFeHRyYWN0KTtcbmV4cG9ydCB7XG4gIEV4dHJhY3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRyYWN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dHJhY3QgfSBmcm9tIFwiLi9FeHRyYWN0Lm1qc1wiO1xuZXhwb3J0IHtcbiAgRXh0cmFjdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jb25zdCBidWlsZENpcmNsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBsZXQgeCwgeSwgZHgsIGR5LCByeCwgcnk7XG4gICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlID09PSBTSEFQRVMuQ0lSQykge1xuICAgICAgY29uc3QgY2lyY2xlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGNpcmNsZS54LCB5ID0gY2lyY2xlLnksIHJ4ID0gcnkgPSBjaXJjbGUucmFkaXVzLCBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2UgaWYgKGdyYXBoaWNzRGF0YS50eXBlID09PSBTSEFQRVMuRUxJUCkge1xuICAgICAgY29uc3QgZWxsaXBzZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgIHggPSBlbGxpcHNlLngsIHkgPSBlbGxpcHNlLnksIHJ4ID0gZWxsaXBzZS53aWR0aCwgcnkgPSBlbGxpcHNlLmhlaWdodCwgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdW5kZWRSZWN0ID0gZ3JhcGhpY3NEYXRhLnNoYXBlLCBoYWxmV2lkdGggPSByb3VuZGVkUmVjdC53aWR0aCAvIDIsIGhhbGZIZWlnaHQgPSByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgeCA9IHJvdW5kZWRSZWN0LnggKyBoYWxmV2lkdGgsIHkgPSByb3VuZGVkUmVjdC55ICsgaGFsZkhlaWdodCwgcnggPSByeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvdW5kZWRSZWN0LnJhZGl1cywgTWF0aC5taW4oaGFsZldpZHRoLCBoYWxmSGVpZ2h0KSkpLCBkeCA9IGhhbGZXaWR0aCAtIHJ4LCBkeSA9IGhhbGZIZWlnaHQgLSByeTtcbiAgICB9XG4gICAgaWYgKCEocnggPj0gMCAmJiByeSA+PSAwICYmIGR4ID49IDAgJiYgZHkgPj0gMCkpIHtcbiAgICAgIHBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKDIuMyAqIE1hdGguc3FydChyeCArIHJ5KSksIG0gPSBuICogOCArIChkeCA/IDQgOiAwKSArIChkeSA/IDQgOiAwKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9IG0sIG0gPT09IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHBvaW50cy5sZW5ndGggPSA4LCBwb2ludHNbMF0gPSBwb2ludHNbNl0gPSB4ICsgZHgsIHBvaW50c1sxXSA9IHBvaW50c1szXSA9IHkgKyBkeSwgcG9pbnRzWzJdID0gcG9pbnRzWzRdID0geCAtIGR4LCBwb2ludHNbNV0gPSBwb2ludHNbN10gPSB5IC0gZHk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBqMSA9IDAsIGoyID0gbiAqIDQgKyAoZHggPyAyIDogMCkgKyAyLCBqMyA9IGoyLCBqNCA9IG07XG4gICAge1xuICAgICAgY29uc3QgeDAgPSBkeCArIHJ4LCB5MCA9IGR5LCB4MSA9IHggKyB4MCwgeDIgPSB4IC0geDAsIHkxID0geSArIHkwO1xuICAgICAgaWYgKHBvaW50c1tqMSsrXSA9IHgxLCBwb2ludHNbajErK10gPSB5MSwgcG9pbnRzWy0tajJdID0geTEsIHBvaW50c1stLWoyXSA9IHgyLCBkeSkge1xuICAgICAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICAgICAgcG9pbnRzW2ozKytdID0geDIsIHBvaW50c1tqMysrXSA9IHkyLCBwb2ludHNbLS1qNF0gPSB5MiwgcG9pbnRzWy0tajRdID0geDE7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5QSSAvIDIgKiAoaSAvIG4pLCB4MCA9IGR4ICsgTWF0aC5jb3MoYSkgKiByeCwgeTAgPSBkeSArIE1hdGguc2luKGEpICogcnksIHgxID0geCArIHgwLCB4MiA9IHggLSB4MCwgeTEgPSB5ICsgeTAsIHkyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2oxKytdID0geDEsIHBvaW50c1tqMSsrXSA9IHkxLCBwb2ludHNbLS1qMl0gPSB5MSwgcG9pbnRzWy0tajJdID0geDIsIHBvaW50c1tqMysrXSA9IHgyLCBwb2ludHNbajMrK10gPSB5MiwgcG9pbnRzWy0tajRdID0geTIsIHBvaW50c1stLWo0XSA9IHgxO1xuICAgIH1cbiAgICB7XG4gICAgICBjb25zdCB4MCA9IGR4LCB5MCA9IGR5ICsgcnksIHgxID0geCArIHgwLCB4MiA9IHggLSB4MCwgeTEgPSB5ICsgeTAsIHkyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2oxKytdID0geDEsIHBvaW50c1tqMSsrXSA9IHkxLCBwb2ludHNbLS1qNF0gPSB5MiwgcG9pbnRzWy0tajRdID0geDEsIGR4ICYmIChwb2ludHNbajErK10gPSB4MiwgcG9pbnRzW2oxKytdID0geTEsIHBvaW50c1stLWo0XSA9IHkyLCBwb2ludHNbLS1qNF0gPSB4Mik7XG4gICAgfVxuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzLCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzLCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBjZW50ZXIgPSB2ZXJ0UG9zO1xuICAgIGxldCB4LCB5O1xuICAgIGlmIChncmFwaGljc0RhdGEudHlwZSAhPT0gU0hBUEVTLlJSRUMpIHtcbiAgICAgIGNvbnN0IGNpcmNsZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgIHggPSBjaXJjbGUueCwgeSA9IGNpcmNsZS55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3VuZGVkUmVjdCA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgIHggPSByb3VuZGVkUmVjdC54ICsgcm91bmRlZFJlY3Qud2lkdGggLyAyLCB5ID0gcm91bmRlZFJlY3QueSArIHJvdW5kZWRSZWN0LmhlaWdodCAvIDI7XG4gICAgfVxuICAgIGNvbnN0IG1hdHJpeCA9IGdyYXBoaWNzRGF0YS5tYXRyaXg7XG4gICAgdmVydHMucHVzaChcbiAgICAgIGdyYXBoaWNzRGF0YS5tYXRyaXggPyBtYXRyaXguYSAqIHggKyBtYXRyaXguYyAqIHkgKyBtYXRyaXgudHggOiB4LFxuICAgICAgZ3JhcGhpY3NEYXRhLm1hdHJpeCA/IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eSA6IHlcbiAgICApLCB2ZXJ0UG9zKyssIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKVxuICAgICAgdmVydHMucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pLCBpbmRpY2VzLnB1c2godmVydFBvcysrLCBjZW50ZXIsIHZlcnRQb3MpO1xuICAgIGluZGljZXMucHVzaChjZW50ZXIgKyAxLCBjZW50ZXIsIHZlcnRQb3MpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgYnVpbGRDaXJjbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZENpcmNsZS5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5mdW5jdGlvbiBmaXhPcmllbnRhdGlvbihwb2ludHMsIGhvbGUgPSAhMSkge1xuICBjb25zdCBtID0gcG9pbnRzLmxlbmd0aDtcbiAgaWYgKG0gPCA2KVxuICAgIHJldHVybjtcbiAgbGV0IGFyZWEgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgeDEgPSBwb2ludHNbbSAtIDJdLCB5MSA9IHBvaW50c1ttIC0gMV07IGkgPCBtOyBpICs9IDIpIHtcbiAgICBjb25zdCB4MiA9IHBvaW50c1tpXSwgeTIgPSBwb2ludHNbaSArIDFdO1xuICAgIGFyZWEgKz0gKHgyIC0geDEpICogKHkyICsgeTEpLCB4MSA9IHgyLCB5MSA9IHkyO1xuICB9XG4gIGlmICghaG9sZSAmJiBhcmVhID4gMCB8fCBob2xlICYmIGFyZWEgPD0gMCkge1xuICAgIGNvbnN0IG4gPSBtIC8gMjtcbiAgICBmb3IgKGxldCBpID0gbiArIG4gJSAyOyBpIDwgbTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBpMSA9IG0gLSBpIC0gMiwgaTIgPSBtIC0gaSAtIDEsIGkzID0gaSwgaTQgPSBpICsgMTtcbiAgICAgIFtwb2ludHNbaTFdLCBwb2ludHNbaTNdXSA9IFtwb2ludHNbaTNdLCBwb2ludHNbaTFdXSwgW3BvaW50c1tpMl0sIHBvaW50c1tpNF1dID0gW3BvaW50c1tpNF0sIHBvaW50c1tpMl1dO1xuICAgIH1cbiAgfVxufVxuY29uc3QgYnVpbGRQb2x5ID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBncmFwaGljc0RhdGEucG9pbnRzID0gZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cy5zbGljZSgpO1xuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBjb25zdCBob2xlcyA9IGdyYXBoaWNzRGF0YS5ob2xlcywgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cywgaW5kaWNlcyA9IGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcztcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA+PSA2KSB7XG4gICAgICBmaXhPcmllbnRhdGlvbihwb2ludHMsICExKTtcbiAgICAgIGNvbnN0IGhvbGVBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBob2xlID0gaG9sZXNbaV07XG4gICAgICAgIGZpeE9yaWVudGF0aW9uKGhvbGUucG9pbnRzLCAhMCksIGhvbGVBcnJheS5wdXNoKHBvaW50cy5sZW5ndGggLyAyKSwgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChob2xlLnBvaW50cyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmlhbmdsZXMgPSB1dGlscy5lYXJjdXQocG9pbnRzLCBob2xlQXJyYXksIDIpO1xuICAgICAgaWYgKCF0cmlhbmdsZXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKSwgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMV0gKyB2ZXJ0UG9zKSwgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZXJ0UG9zKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IHtcbiAgYnVpbGRQb2x5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRQb2x5Lm1qcy5tYXBcbiIsImNvbnN0IGJ1aWxkUmVjdGFuZ2xlID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBjb25zdCByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZSwgeCA9IHJlY3REYXRhLngsIHkgPSByZWN0RGF0YS55LCB3aWR0aCA9IHJlY3REYXRhLndpZHRoLCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQsIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgcG9pbnRzLmxlbmd0aCA9IDAsIHdpZHRoID49IDAgJiYgaGVpZ2h0ID49IDAgJiYgcG9pbnRzLnB1c2goXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHggKyB3aWR0aCxcbiAgICAgIHksXG4gICAgICB4ICsgd2lkdGgsXG4gICAgICB5ICsgaGVpZ2h0LFxuICAgICAgeCxcbiAgICAgIHkgKyBoZWlnaHRcbiAgICApO1xuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzLCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgIHZlcnRzLnB1c2goXG4gICAgICBwb2ludHNbMF0sXG4gICAgICBwb2ludHNbMV0sXG4gICAgICBwb2ludHNbMl0sXG4gICAgICBwb2ludHNbM10sXG4gICAgICBwb2ludHNbNl0sXG4gICAgICBwb2ludHNbN10sXG4gICAgICBwb2ludHNbNF0sXG4gICAgICBwb2ludHNbNV1cbiAgICApLCBncmFwaGljc0dlb21ldHJ5LmluZGljZXMucHVzaChcbiAgICAgIHZlcnRQb3MsXG4gICAgICB2ZXJ0UG9zICsgMSxcbiAgICAgIHZlcnRQb3MgKyAyLFxuICAgICAgdmVydFBvcyArIDEsXG4gICAgICB2ZXJ0UG9zICsgMixcbiAgICAgIHZlcnRQb3MgKyAzXG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIGJ1aWxkUmVjdGFuZ2xlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRSZWN0YW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tIFwiLi9idWlsZENpcmNsZS5tanNcIjtcbmNvbnN0IGJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgYnVpbGRDaXJjbGUuYnVpbGQoZ3JhcGhpY3NEYXRhKTtcbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgYnVpbGRDaXJjbGUudHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIGJ1aWxkUm91bmRlZFJlY3RhbmdsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUm91bmRlZFJlY3RhbmdsZS5tanMubWFwXG4iLCJ2YXIgTElORV9KT0lOID0gLyogQF9fUFVSRV9fICovICgoTElORV9KT0lOMikgPT4gKExJTkVfSk9JTjIuTUlURVIgPSBcIm1pdGVyXCIsIExJTkVfSk9JTjIuQkVWRUwgPSBcImJldmVsXCIsIExJTkVfSk9JTjIuUk9VTkQgPSBcInJvdW5kXCIsIExJTkVfSk9JTjIpKShMSU5FX0pPSU4gfHwge30pLCBMSU5FX0NBUCA9IC8qIEBfX1BVUkVfXyAqLyAoKExJTkVfQ0FQMikgPT4gKExJTkVfQ0FQMi5CVVRUID0gXCJidXR0XCIsIExJTkVfQ0FQMi5ST1VORCA9IFwicm91bmRcIiwgTElORV9DQVAyLlNRVUFSRSA9IFwic3F1YXJlXCIsIExJTkVfQ0FQMikpKExJTkVfQ0FQIHx8IHt9KTtcbmNvbnN0IGN1cnZlcyA9IHtcbiAgYWRhcHRpdmU6ICEwLFxuICBtYXhMZW5ndGg6IDEwLFxuICBtaW5TZWdtZW50czogOCxcbiAgbWF4U2VnbWVudHM6IDIwNDgsXG4gIGVwc2lsb246IDFlLTQsXG4gIF9zZWdtZW50c0NvdW50KGxlbmd0aCwgZGVmYXVsdFNlZ21lbnRzID0gMjApIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRpdmUgfHwgIWxlbmd0aCB8fCBpc05hTihsZW5ndGgpKVxuICAgICAgcmV0dXJuIGRlZmF1bHRTZWdtZW50cztcbiAgICBsZXQgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cyA/IHJlc3VsdCA9IHRoaXMubWluU2VnbWVudHMgOiByZXN1bHQgPiB0aGlzLm1heFNlZ21lbnRzICYmIChyZXN1bHQgPSB0aGlzLm1heFNlZ21lbnRzKSwgcmVzdWx0O1xuICB9XG59LCBHUkFQSElDU19DVVJWRVMgPSBjdXJ2ZXM7XG5leHBvcnQge1xuICBHUkFQSElDU19DVVJWRVMsXG4gIExJTkVfQ0FQLFxuICBMSU5FX0pPSU4sXG4gIGN1cnZlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBJXzIgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgY3VydmVzIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuY2xhc3MgQXJjVXRpbHMge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIGluZm9ybWF0aW9uIG9mIHRoZSBhcmMgZm9yIHtAbGluayBQSVhJLkdyYXBoaWNzLmFyY1RvfS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBvZiB0aGUgYXJjXG4gICAqIEBwYXJhbSB5MSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvZiB0aGUgYXJjXG4gICAqIEBwYXJhbSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9mIHRoZSBhcmNcbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0gcG9pbnRzIC0gQ29sbGVjdGlvbiBvZiBwb2ludHMgdG8gYWRkIHRvXG4gICAqIEByZXR1cm5zIC0gSWYgdGhlIGFyYyBsZW5ndGggaXMgdmFsaWQsIHJldHVybiBjZW50ZXIgb2YgY2lyY2xlLCByYWRpdXMgYW5kIG90aGVyIGluZm8gb3RoZXJ3aXNlIGBudWxsYC5cbiAgICovXG4gIHN0YXRpYyBjdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgYTEgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0geTEsIGIxID0gZnJvbVggLSB4MSwgYTIgPSB5MiAtIHkxLCBiMiA9IHgyIC0geDEsIG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xuICAgIGlmIChtbSA8IDFlLTggfHwgcmFkaXVzID09PSAwKVxuICAgICAgcmV0dXJuIChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICE9PSB4MSB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICE9PSB5MSkgJiYgcG9pbnRzLnB1c2goeDEsIHkxKSwgbnVsbDtcbiAgICBjb25zdCBkZCA9IGExICogYTEgKyBiMSAqIGIxLCBjYyA9IGEyICogYTIgKyBiMiAqIGIyLCB0dCA9IGExICogYTIgKyBiMSAqIGIyLCBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbSwgazIgPSByYWRpdXMgKiBNYXRoLnNxcnQoY2MpIC8gbW0sIGoxID0gazEgKiB0dCAvIGRkLCBqMiA9IGsyICogdHQgLyBjYywgY3ggPSBrMSAqIGIyICsgazIgKiBiMSwgY3kgPSBrMSAqIGEyICsgazIgKiBhMSwgcHggPSBiMSAqIChrMiArIGoxKSwgcHkgPSBhMSAqIChrMiArIGoxKSwgcXggPSBiMiAqIChrMSArIGoyKSwgcXkgPSBhMiAqIChrMSArIGoyKSwgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCksIGVuZEFuZ2xlID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcbiAgICByZXR1cm4ge1xuICAgICAgY3g6IGN4ICsgeDEsXG4gICAgICBjeTogY3kgKyB5MSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGFudGljbG9ja3dpc2U6IGIxICogYTIgPiBiMiAqIGExXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFyYyBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gX3N0YXJ0WCAtIFN0YXJ0IHggbG9jYXRpb24gb2YgYXJjXG4gICAqIEBwYXJhbSBfc3RhcnRZIC0gU3RhcnQgeSBsb2NhdGlvbiBvZiBhcmNcbiAgICogQHBhcmFtIGN4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIGN5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgKiBAcGFyYW0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucyAoMCBpcyBhdCB0aGUgMyBvJ2Nsb2NrIHBvc2l0aW9uXG4gICAqICBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICAgKiBAcGFyYW0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zXG4gICAqIEBwYXJhbSBfYW50aWNsb2Nrd2lzZSAtIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkcmF3aW5nIHNob3VsZCBiZVxuICAgKiAgY291bnRlci1jbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZVxuICAgKiAgaW5kaWNhdGVzIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQ29sbGVjdGlvbiBvZiBwb2ludHMgdG8gYWRkIHRvXG4gICAqL1xuICBzdGF0aWMgYXJjKF9zdGFydFgsIF9zdGFydFksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgX2FudGljbG9ja3dpc2UsIHBvaW50cykge1xuICAgIGNvbnN0IHN3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCBuID0gY3VydmVzLl9zZWdtZW50c0NvdW50KFxuICAgICAgTWF0aC5hYnMoc3dlZXApICogcmFkaXVzLFxuICAgICAgTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIFBJXzIpICogNDBcbiAgICApLCB0aGV0YSA9IHN3ZWVwIC8gKG4gKiAyKSwgdGhldGEyID0gdGhldGEgKiAyLCBjVGhldGEgPSBNYXRoLmNvcyh0aGV0YSksIHNUaGV0YSA9IE1hdGguc2luKHRoZXRhKSwgc2VnTWludXMgPSBuIC0gMSwgcmVtYWluZGVyID0gc2VnTWludXMgJSAxIC8gc2VnTWludXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VnTWludXM7ICsraSkge1xuICAgICAgY29uc3QgcmVhbCA9IGkgKyByZW1haW5kZXIgKiBpLCBhbmdsZSA9IHRoZXRhICsgc3RhcnRBbmdsZSArIHRoZXRhMiAqIHJlYWwsIGMgPSBNYXRoLmNvcyhhbmdsZSksIHMgPSAtTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgIChjVGhldGEgKiBjICsgc1RoZXRhICogcykgKiByYWRpdXMgKyBjeCxcbiAgICAgICAgKGNUaGV0YSAqIC1zICsgc1RoZXRhICogYykgKiByYWRpdXMgKyBjeVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEFyY1V0aWxzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJjVXRpbHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgY3VydmVzIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuY2xhc3MgQmV6aWVyVXRpbHMge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIGxlbmd0aCBvZiBiZXppZXIgY3VydmUuXG4gICAqIEFuYWx5dGljYWwgc29sdXRpb24gaXMgaW1wb3NzaWJsZSwgc2luY2UgaXQgaW52b2x2ZXMgYW4gaW50ZWdyYWwgdGhhdCBkb2VzIG5vdCBpbnRlZ3JhdGUgaW4gZ2VuZXJhbC5cbiAgICogVGhlcmVmb3JlIG51bWVyaWNhbCBzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZnJvbVggLSBTdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSBmcm9tWSAtIFN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHBhcmFtIGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgKiBAcGFyYW0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAqIEBwYXJhbSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICAgKiBAcGFyYW0gY3BZMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHlcbiAgICogQHBhcmFtIHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAgICogQHBhcmFtIHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICogQHJldHVybnMgLSBMZW5ndGggb2YgYmV6aWVyIGN1cnZlXG4gICAqL1xuICBzdGF0aWMgY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICBsZXQgcmVzdWx0ID0gMCwgdCA9IDAsIHQyID0gMCwgdDMgPSAwLCBudCA9IDAsIG50MiA9IDAsIG50MyA9IDAsIHggPSAwLCB5ID0gMCwgZHggPSAwLCBkeSA9IDAsIHByZXZYID0gZnJvbVgsIHByZXZZID0gZnJvbVk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTA7ICsraSlcbiAgICAgIHQgPSBpIC8gMTAsIHQyID0gdCAqIHQsIHQzID0gdDIgKiB0LCBudCA9IDEgLSB0LCBudDIgPSBudCAqIG50LCBudDMgPSBudDIgKiBudCwgeCA9IG50MyAqIGZyb21YICsgMyAqIG50MiAqIHQgKiBjcFggKyAzICogbnQgKiB0MiAqIGNwWDIgKyB0MyAqIHRvWCwgeSA9IG50MyAqIGZyb21ZICsgMyAqIG50MiAqIHQgKiBjcFkgKyAzICogbnQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSwgZHggPSBwcmV2WCAtIHgsIGR5ID0gcHJldlkgLSB5LCBwcmV2WCA9IHgsIHByZXZZID0geSwgcmVzdWx0ICs9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICAgKlxuICAgKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAqIEBwYXJhbSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICogQHBhcmFtIGNwWDIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB4XG4gICAqIEBwYXJhbSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICAgKiBAcGFyYW0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgKiBAcGFyYW0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICAgKiBAcGFyYW0gcG9pbnRzIC0gUGF0aCBhcnJheSB0byBwdXNoIHBvaW50cyBpbnRvXG4gICAqL1xuICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIHBvaW50cy5sZW5ndGggLT0gMjtcbiAgICBjb25zdCBuID0gY3VydmVzLl9zZWdtZW50c0NvdW50KFxuICAgICAgQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpXG4gICAgKTtcbiAgICBsZXQgZHQgPSAwLCBkdDIgPSAwLCBkdDMgPSAwLCB0MiA9IDAsIHQzID0gMDtcbiAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpXG4gICAgICBqID0gaSAvIG4sIGR0ID0gMSAtIGosIGR0MiA9IGR0ICogZHQsIGR0MyA9IGR0MiAqIGR0LCB0MiA9IGogKiBqLCB0MyA9IHQyICogaiwgcG9pbnRzLnB1c2goXG4gICAgICAgIGR0MyAqIGZyb21YICsgMyAqIGR0MiAqIGogKiBjcFggKyAzICogZHQgKiB0MiAqIGNwWDIgKyB0MyAqIHRvWCxcbiAgICAgICAgZHQzICogZnJvbVkgKyAzICogZHQyICogaiAqIGNwWSArIDMgKiBkdCAqIHQyICogY3BZMiArIHQzICogdG9ZXG4gICAgICApO1xuICB9XG59XG5leHBvcnQge1xuICBCZXppZXJVdGlsc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlemllclV0aWxzLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBTSEFQRVMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuZnVuY3Rpb24gc3F1YXJlKHgsIHksIG54LCBueSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBjbG9ja3dpc2UsIHZlcnRzKSB7XG4gIGNvbnN0IGl4ID0geCAtIG54ICogaW5uZXJXZWlnaHQsIGl5ID0geSAtIG55ICogaW5uZXJXZWlnaHQsIG94ID0geCArIG54ICogb3V0ZXJXZWlnaHQsIG95ID0geSArIG55ICogb3V0ZXJXZWlnaHQ7XG4gIGxldCBleHgsIGV5eTtcbiAgY2xvY2t3aXNlID8gKGV4eCA9IG55LCBleXkgPSAtbngpIDogKGV4eCA9IC1ueSwgZXl5ID0gbngpO1xuICBjb25zdCBlaXggPSBpeCArIGV4eCwgZWl5ID0gaXkgKyBleXksIGVveCA9IG94ICsgZXh4LCBlb3kgPSBveSArIGV5eTtcbiAgcmV0dXJuIHZlcnRzLnB1c2goXG4gICAgZWl4LFxuICAgIGVpeSxcbiAgICBlb3gsXG4gICAgZW95XG4gICksIDI7XG59XG5mdW5jdGlvbiByb3VuZChjeCwgY3ksIHN4LCBzeSwgZXgsIGV5LCB2ZXJ0cywgY2xvY2t3aXNlKSB7XG4gIGNvbnN0IGN4MnAweCA9IHN4IC0gY3gsIGN5MnAweSA9IHN5IC0gY3k7XG4gIGxldCBhbmdsZTAgPSBNYXRoLmF0YW4yKGN4MnAweCwgY3kycDB5KSwgYW5nbGUxID0gTWF0aC5hdGFuMihleCAtIGN4LCBleSAtIGN5KTtcbiAgY2xvY2t3aXNlICYmIGFuZ2xlMCA8IGFuZ2xlMSA/IGFuZ2xlMCArPSBNYXRoLlBJICogMiA6ICFjbG9ja3dpc2UgJiYgYW5nbGUwID4gYW5nbGUxICYmIChhbmdsZTEgKz0gTWF0aC5QSSAqIDIpO1xuICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlMDtcbiAgY29uc3QgYW5nbGVEaWZmID0gYW5nbGUxIC0gYW5nbGUwLCBhYnNBbmdsZURpZmYgPSBNYXRoLmFicyhhbmdsZURpZmYpLCByYWRpdXMgPSBNYXRoLnNxcnQoY3gycDB4ICogY3gycDB4ICsgY3kycDB5ICogY3kycDB5KSwgc2VnQ291bnQgPSAoMTUgKiBhYnNBbmdsZURpZmYgKiBNYXRoLnNxcnQocmFkaXVzKSAvIE1hdGguUEkgPj4gMCkgKyAxLCBhbmdsZUluYyA9IGFuZ2xlRGlmZiAvIHNlZ0NvdW50O1xuICBpZiAoc3RhcnRBbmdsZSArPSBhbmdsZUluYywgY2xvY2t3aXNlKSB7XG4gICAgdmVydHMucHVzaChcbiAgICAgIGN4LFxuICAgICAgY3ksXG4gICAgICBzeCxcbiAgICAgIHN5XG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpXG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICBjeCxcbiAgICAgICAgY3ksXG4gICAgICAgIGN4ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgICBjeSArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1c1xuICAgICAgKTtcbiAgICB2ZXJ0cy5wdXNoKFxuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIGV4LFxuICAgICAgZXlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHZlcnRzLnB1c2goXG4gICAgICBzeCxcbiAgICAgIHN5LFxuICAgICAgY3gsXG4gICAgICBjeVxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDEsIGFuZ2xlID0gc3RhcnRBbmdsZTsgaSA8IHNlZ0NvdW50OyBpKyssIGFuZ2xlICs9IGFuZ2xlSW5jKVxuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgICBjeCxcbiAgICAgICAgY3lcbiAgICAgICk7XG4gICAgdmVydHMucHVzaChcbiAgICAgIGV4LFxuICAgICAgZXksXG4gICAgICBjeCxcbiAgICAgIGN5XG4gICAgKTtcbiAgfVxuICByZXR1cm4gc2VnQ291bnQgKiAyO1xufVxuZnVuY3Rpb24gYnVpbGROb25OYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBjb25zdCBzaGFwZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgbGV0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgc2hhcGUucG9pbnRzLnNsaWNlKCk7XG4gIGNvbnN0IGVwcyA9IGdyYXBoaWNzR2VvbWV0cnkuY2xvc2VQb2ludEVwcztcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBzdHlsZSA9IGdyYXBoaWNzRGF0YS5saW5lU3R5bGUsIGZpcnN0UG9pbnQgPSBuZXcgUG9pbnQocG9pbnRzWzBdLCBwb2ludHNbMV0pLCBsYXN0UG9pbnQgPSBuZXcgUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSksIGNsb3NlZFNoYXBlID0gc2hhcGUudHlwZSAhPT0gU0hBUEVTLlBPTFkgfHwgc2hhcGUuY2xvc2VTdHJva2UsIGNsb3NlZFBhdGggPSBNYXRoLmFicyhmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgPCBlcHMgJiYgTWF0aC5hYnMoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpIDwgZXBzO1xuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKSwgY2xvc2VkUGF0aCAmJiAocG9pbnRzLnBvcCgpLCBwb2ludHMucG9wKCksIGxhc3RQb2ludC5zZXQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSkpO1xuICAgIGNvbnN0IG1pZFBvaW50WCA9IChmaXJzdFBvaW50LnggKyBsYXN0UG9pbnQueCkgKiAwLjUsIG1pZFBvaW50WSA9IChsYXN0UG9pbnQueSArIGZpcnN0UG9pbnQueSkgKiAwLjU7XG4gICAgcG9pbnRzLnVuc2hpZnQobWlkUG9pbnRYLCBtaWRQb2ludFkpLCBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gIH1cbiAgY29uc3QgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cywgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIGxldCBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDIsIHdpZHRoID0gc3R5bGUud2lkdGggLyAyLCB3aWR0aFNxdWFyZWQgPSB3aWR0aCAqIHdpZHRoLCBtaXRlckxpbWl0U3F1YXJlZCA9IHN0eWxlLm1pdGVyTGltaXQgKiBzdHlsZS5taXRlckxpbWl0O1xuICBsZXQgeDAgPSBwb2ludHNbMF0sIHkwID0gcG9pbnRzWzFdLCB4MSA9IHBvaW50c1syXSwgeTEgPSBwb2ludHNbM10sIHgyID0gMCwgeTIgPSAwLCBwZXJweCA9IC0oeTAgLSB5MSksIHBlcnB5ID0geDAgLSB4MSwgcGVycDF4ID0gMCwgcGVycDF5ID0gMCwgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gIHBlcnB4IC89IGRpc3QsIHBlcnB5IC89IGRpc3QsIHBlcnB4ICo9IHdpZHRoLCBwZXJweSAqPSB3aWR0aDtcbiAgY29uc3QgcmF0aW8gPSBzdHlsZS5hbGlnbm1lbnQsIGlubmVyV2VpZ2h0ID0gKDEgLSByYXRpbykgKiAyLCBvdXRlcldlaWdodCA9IHJhdGlvICogMjtcbiAgY2xvc2VkU2hhcGUgfHwgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuUk9VTkQgPyBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgIHgwIC0gcGVycHggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgeTAgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICB4MCAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgeTAgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgIHgwICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICB5MCArIHBlcnB5ICogb3V0ZXJXZWlnaHQsXG4gICAgdmVydHMsXG4gICAgITBcbiAgKSArIDIgOiBzdHlsZS5jYXAgPT09IExJTkVfQ0FQLlNRVUFSRSAmJiAoaW5kZXhDb3VudCArPSBzcXVhcmUoeDAsIHkwLCBwZXJweCwgcGVycHksIGlubmVyV2VpZ2h0LCBvdXRlcldlaWdodCwgITAsIHZlcnRzKSkpLCB2ZXJ0cy5wdXNoKFxuICAgIHgwIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICB5MCAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgeDAgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgIHkwICsgcGVycHkgKiBvdXRlcldlaWdodFxuICApO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgIHgwID0gcG9pbnRzWyhpIC0gMSkgKiAyXSwgeTAgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXSwgeDEgPSBwb2ludHNbaSAqIDJdLCB5MSA9IHBvaW50c1tpICogMiArIDFdLCB4MiA9IHBvaW50c1soaSArIDEpICogMl0sIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV0sIHBlcnB4ID0gLSh5MCAtIHkxKSwgcGVycHkgPSB4MCAtIHgxLCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KSwgcGVycHggLz0gZGlzdCwgcGVycHkgLz0gZGlzdCwgcGVycHggKj0gd2lkdGgsIHBlcnB5ICo9IHdpZHRoLCBwZXJwMXggPSAtKHkxIC0geTIpLCBwZXJwMXkgPSB4MSAtIHgyLCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAxeCAqIHBlcnAxeCArIHBlcnAxeSAqIHBlcnAxeSksIHBlcnAxeCAvPSBkaXN0LCBwZXJwMXkgLz0gZGlzdCwgcGVycDF4ICo9IHdpZHRoLCBwZXJwMXkgKj0gd2lkdGg7XG4gICAgY29uc3QgZHgwID0geDEgLSB4MCwgZHkwID0geTAgLSB5MSwgZHgxID0geDEgLSB4MiwgZHkxID0geTIgLSB5MSwgZG90ID0gZHgwICogZHgxICsgZHkwICogZHkxLCBjcm9zcyA9IGR5MCAqIGR4MSAtIGR5MSAqIGR4MCwgY2xvY2t3aXNlID0gY3Jvc3MgPCAwO1xuICAgIGlmIChNYXRoLmFicyhjcm9zcykgPCAxZS0zICogTWF0aC5hYnMoZG90KSkge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHgxICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0XG4gICAgICApLCBkb3QgPj0gMCAmJiAoc3R5bGUuam9pbiA9PT0gTElORV9KT0lOLlJPVU5EID8gaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgdmVydHMsXG4gICAgICAgICExXG4gICAgICApICsgNCA6IGluZGV4Q291bnQgKz0gMiwgdmVydHMucHVzaChcbiAgICAgICAgeDEgLSBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgLSBwZXJwMXkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgeDEgKyBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJwMXkgKiBpbm5lcldlaWdodFxuICAgICAgKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYzEgPSAoLXBlcnB4ICsgeDApICogKC1wZXJweSArIHkxKSAtICgtcGVycHggKyB4MSkgKiAoLXBlcnB5ICsgeTApLCBjMiA9ICgtcGVycDF4ICsgeDIpICogKC1wZXJwMXkgKyB5MSkgLSAoLXBlcnAxeCArIHgxKSAqICgtcGVycDF5ICsgeTIpLCBweCA9IChkeDAgKiBjMiAtIGR4MSAqIGMxKSAvIGNyb3NzLCBweSA9IChkeTEgKiBjMSAtIGR5MCAqIGMyKSAvIGNyb3NzLCBwZGlzdCA9IChweCAtIHgxKSAqIChweCAtIHgxKSArIChweSAtIHkxKSAqIChweSAtIHkxKSwgaW14ID0geDEgKyAocHggLSB4MSkgKiBpbm5lcldlaWdodCwgaW15ID0geTEgKyAocHkgLSB5MSkgKiBpbm5lcldlaWdodCwgb214ID0geDEgLSAocHggLSB4MSkgKiBvdXRlcldlaWdodCwgb215ID0geTEgLSAocHkgLSB5MSkgKiBvdXRlcldlaWdodCwgc21hbGxlckluc2lkZVNlZ21lbnRTcSA9IE1hdGgubWluKGR4MCAqIGR4MCArIGR5MCAqIGR5MCwgZHgxICogZHgxICsgZHkxICogZHkxKSwgaW5zaWRlV2VpZ2h0ID0gY2xvY2t3aXNlID8gaW5uZXJXZWlnaHQgOiBvdXRlcldlaWdodCwgc21hbGxlckluc2lkZURpYWdvbmFsU3EgPSBzbWFsbGVySW5zaWRlU2VnbWVudFNxICsgaW5zaWRlV2VpZ2h0ICogaW5zaWRlV2VpZ2h0ICogd2lkdGhTcXVhcmVkLCBpbnNpZGVNaXRlck9rID0gcGRpc3QgPD0gc21hbGxlckluc2lkZURpYWdvbmFsU3E7XG4gICAgbGV0IGpvaW4gPSBzdHlsZS5qb2luO1xuICAgIGlmIChqb2luID09PSBMSU5FX0pPSU4uTUlURVIgJiYgcGRpc3QgLyB3aWR0aFNxdWFyZWQgPiBtaXRlckxpbWl0U3F1YXJlZCAmJiAoam9pbiA9IExJTkVfSk9JTi5CRVZFTCksIGluc2lkZU1pdGVyT2spXG4gICAgICBzd2l0Y2ggKGpvaW4pIHtcbiAgICAgICAgY2FzZSBMSU5FX0pPSU4uTUlURVI6IHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15LFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExJTkVfSk9JTi5CRVZFTDoge1xuICAgICAgICAgIGNsb2Nrd2lzZSA/IHZlcnRzLnB1c2goXG4gICAgICAgICAgICBpbXgsXG4gICAgICAgICAgICBpbXksXG4gICAgICAgICAgICAvLyBpbm5lciBtaXRlciBwb2ludFxuICAgICAgICAgICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgLy8gZmlyc3Qgc2VnbWVudCdzIG91dGVyIHZlcnRleFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15LFxuICAgICAgICAgICAgLy8gaW5uZXIgbWl0ZXIgcG9pbnRcbiAgICAgICAgICAgIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0XG4gICAgICAgICAgKSA6IHZlcnRzLnB1c2goXG4gICAgICAgICAgICB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICAvLyBmaXJzdCBzZWdtZW50J3MgaW5uZXIgdmVydGV4XG4gICAgICAgICAgICBvbXgsXG4gICAgICAgICAgICBvbXksXG4gICAgICAgICAgICAvLyBvdXRlciBtaXRlciBwb2ludFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICAvLyBzZWNvbmQgc2VnbWVudCdzIG91dGVyIHZlcnRleFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215XG4gICAgICAgICAgKSwgaW5kZXhDb3VudCArPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTElORV9KT0lOLlJPVU5EOiB7XG4gICAgICAgICAgY2xvY2t3aXNlID8gKHZlcnRzLnB1c2goXG4gICAgICAgICAgICBpbXgsXG4gICAgICAgICAgICBpbXksXG4gICAgICAgICAgICB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHRcbiAgICAgICAgICApLCBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHgxICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgdmVydHMsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICkgKyA0LCB2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15LFxuICAgICAgICAgICAgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHRcbiAgICAgICAgICApKSA6ICh2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215XG4gICAgICAgICAgKSwgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApICsgNCwgdmVydHMucHVzaChcbiAgICAgICAgICAgIHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215XG4gICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN3aXRjaCAodmVydHMucHVzaChcbiAgICAgICAgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgIC8vIGZpcnN0IHNlZ21lbnQncyBpbm5lciB2ZXJ0ZXhcbiAgICAgICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHRcbiAgICAgICksIGpvaW4pIHtcbiAgICAgICAgY2FzZSBMSU5FX0pPSU4uTUlURVI6IHtcbiAgICAgICAgICBjbG9ja3dpc2UgPyB2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215LFxuICAgICAgICAgICAgLy8gaW5uZXIgbWl0ZXIgcG9pbnRcbiAgICAgICAgICAgIG9teCxcbiAgICAgICAgICAgIG9teVxuICAgICAgICAgICkgOiB2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15LFxuICAgICAgICAgICAgLy8gb3V0ZXIgbWl0ZXIgcG9pbnRcbiAgICAgICAgICAgIGlteCxcbiAgICAgICAgICAgIGlteVxuICAgICAgICAgICksIGluZGV4Q291bnQgKz0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExJTkVfSk9JTi5ST1VORDoge1xuICAgICAgICAgIGNsb2Nrd2lzZSA/IGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKSArIDIgOiBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgdmVydHMsXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICkgKyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAvLyBzZWNvbmQgc2VnbWVudCdzIGlubmVyIHZlcnRleFxuICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0XG4gICAgICApLCBpbmRleENvdW50ICs9IDI7XG4gICAgfVxuICB9XG4gIHgwID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdLCB5MCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyICsgMV0sIHgxID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDJdLCB5MSA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyICsgMV0sIHBlcnB4ID0gLSh5MCAtIHkxKSwgcGVycHkgPSB4MCAtIHgxLCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KSwgcGVycHggLz0gZGlzdCwgcGVycHkgLz0gZGlzdCwgcGVycHggKj0gd2lkdGgsIHBlcnB5ICo9IHdpZHRoLCB2ZXJ0cy5wdXNoKFxuICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgIHkxICsgcGVycHkgKiBvdXRlcldlaWdodFxuICApLCBjbG9zZWRTaGFwZSB8fCAoc3R5bGUuY2FwID09PSBMSU5FX0NBUC5ST1VORCA/IGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgeDEgLSBwZXJweCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICB5MSAtIHBlcnB5ICogKGlubmVyV2VpZ2h0IC0gb3V0ZXJXZWlnaHQpICogMC41LFxuICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCxcbiAgICB2ZXJ0cyxcbiAgICAhMVxuICApICsgMiA6IHN0eWxlLmNhcCA9PT0gTElORV9DQVAuU1FVQVJFICYmIChpbmRleENvdW50ICs9IHNxdWFyZSh4MSwgeTEsIHBlcnB4LCBwZXJweSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCAhMSwgdmVydHMpKSk7XG4gIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXMsIGVwczIgPSBjdXJ2ZXMuZXBzaWxvbiAqIGN1cnZlcy5lcHNpbG9uO1xuICBmb3IgKGxldCBpID0gaW5kZXhTdGFydDsgaSA8IGluZGV4Q291bnQgKyBpbmRleFN0YXJ0IC0gMjsgKytpKVxuICAgIHgwID0gdmVydHNbaSAqIDJdLCB5MCA9IHZlcnRzW2kgKiAyICsgMV0sIHgxID0gdmVydHNbKGkgKyAxKSAqIDJdLCB5MSA9IHZlcnRzWyhpICsgMSkgKiAyICsgMV0sIHgyID0gdmVydHNbKGkgKyAyKSAqIDJdLCB5MiA9IHZlcnRzWyhpICsgMikgKiAyICsgMV0sICEoTWF0aC5hYnMoeDAgKiAoeTEgLSB5MikgKyB4MSAqICh5MiAtIHkwKSArIHgyICogKHkwIC0geTEpKSA8IGVwczIpICYmIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlLCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzIHx8IHNoYXBlLnBvaW50cywgY2xvc2VkU2hhcGUgPSBzaGFwZS50eXBlICE9PSBTSEFQRVMuUE9MWSB8fCBzaGFwZS5jbG9zZVN0cm9rZTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzLCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMiwgc3RhcnRJbmRleCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gIGxldCBjdXJyZW50SW5kZXggPSBzdGFydEluZGV4O1xuICBmb3IgKHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pLCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHZlcnRzLnB1c2gocG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0pLCBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKSwgY3VycmVudEluZGV4Kys7XG4gIGNsb3NlZFNoYXBlICYmIGluZGljZXMucHVzaChjdXJyZW50SW5kZXgsIHN0YXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBncmFwaGljc0RhdGEubGluZVN0eWxlLm5hdGl2ZSA/IGJ1aWxkTmF0aXZlTGluZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIDogYnVpbGROb25OYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSk7XG59XG5leHBvcnQge1xuICBidWlsZExpbmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZExpbmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgY3VydmVzIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuY2xhc3MgUXVhZHJhdGljVXRpbHMge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIGxlbmd0aCBvZiBxdWFkcmF0aWMgY3VydmVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5tYWxjemFrLmxpbnV4cGwuY29tL2Jsb2cvcXVhZHJhdGljLWJlemllci1jdXJ2ZS1sZW5ndGgvfVxuICAgKiBmb3IgdGhlIGRldGFpbGVkIGV4cGxhbmF0aW9uIG9mIG1hdGggYmVoaW5kIHRoaXMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBmcm9tWCAtIHgtY29vcmRpbmF0ZSBvZiBjdXJ2ZSBzdGFydCBwb2ludFxuICAgKiBAcGFyYW0gZnJvbVkgLSB5LWNvb3JkaW5hdGUgb2YgY3VydmUgc3RhcnQgcG9pbnRcbiAgICogQHBhcmFtIGNwWCAtIHgtY29vcmRpbmF0ZSBvZiBjdXJ2ZSBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSBjcFkgLSB5LWNvb3JkaW5hdGUgb2YgY3VydmUgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0gdG9YIC0geC1jb29yZGluYXRlIG9mIGN1cnZlIGVuZCBwb2ludFxuICAgKiBAcGFyYW0gdG9ZIC0geS1jb29yZGluYXRlIG9mIGN1cnZlIGVuZCBwb2ludFxuICAgKiBAcmV0dXJucyAtIExlbmd0aCBvZiBxdWFkcmF0aWMgY3VydmVcbiAgICovXG4gIHN0YXRpYyBjdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIGNvbnN0IGF4ID0gZnJvbVggLSAyICogY3BYICsgdG9YLCBheSA9IGZyb21ZIC0gMiAqIGNwWSArIHRvWSwgYnggPSAyICogY3BYIC0gMiAqIGZyb21YLCBieSA9IDIgKiBjcFkgLSAyICogZnJvbVksIGEgPSA0ICogKGF4ICogYXggKyBheSAqIGF5KSwgYiA9IDQgKiAoYXggKiBieCArIGF5ICogYnkpLCBjID0gYnggKiBieCArIGJ5ICogYnksIHMgPSAyICogTWF0aC5zcXJ0KGEgKyBiICsgYyksIGEyID0gTWF0aC5zcXJ0KGEpLCBhMzIgPSAyICogYSAqIGEyLCBjMiA9IDIgKiBNYXRoLnNxcnQoYyksIGJhID0gYiAvIGEyO1xuICAgIHJldHVybiAoYTMyICogcyArIGEyICogYiAqIChzIC0gYzIpICsgKDQgKiBjICogYSAtIGIgKiBiKSAqIE1hdGgubG9nKCgyICogYTIgKyBiYSArIHMpIC8gKGJhICsgYzIpKSkgLyAoNCAqIGEzMik7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgKiBAcGFyYW0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAqIEBwYXJhbSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAqIEBwYXJhbSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAqIEBwYXJhbSBwb2ludHMgLSBQb2ludHMgdG8gYWRkIHNlZ21lbnRzIHRvLlxuICAgKi9cbiAgc3RhdGljIGN1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZLCBwb2ludHMpIHtcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgbiA9IGN1cnZlcy5fc2VnbWVudHNDb3VudChcbiAgICAgIFF1YWRyYXRpY1V0aWxzLmN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKVxuICAgICk7XG4gICAgbGV0IHhhID0gMCwgeWEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgY29uc3QgaiA9IGkgLyBuO1xuICAgICAgeGEgPSBmcm9tWCArIChjcFggLSBmcm9tWCkgKiBqLCB5YSA9IGZyb21ZICsgKGNwWSAtIGZyb21ZKSAqIGosIHBvaW50cy5wdXNoKFxuICAgICAgICB4YSArIChjcFggKyAodG9YIC0gY3BYKSAqIGogLSB4YSkgKiBqLFxuICAgICAgICB5YSArIChjcFkgKyAodG9ZIC0gY3BZKSAqIGogLSB5YSkgKiBqXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgUXVhZHJhdGljVXRpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkcmF0aWNVdGlscy5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tIFwiLi9idWlsZENpcmNsZS5tanNcIjtcbmltcG9ydCB7IGJ1aWxkUG9seSB9IGZyb20gXCIuL2J1aWxkUG9seS5tanNcIjtcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSBcIi4vYnVpbGRSZWN0YW5nbGUubWpzXCI7XG5pbXBvcnQgeyBidWlsZFJvdW5kZWRSZWN0YW5nbGUgfSBmcm9tIFwiLi9idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzXCI7XG5pbXBvcnQgeyBBcmNVdGlscyB9IGZyb20gXCIuL0FyY1V0aWxzLm1qc1wiO1xuaW1wb3J0IHsgQmF0Y2hQYXJ0IH0gZnJvbSBcIi4vQmF0Y2hQYXJ0Lm1qc1wiO1xuaW1wb3J0IHsgQmV6aWVyVXRpbHMgfSBmcm9tIFwiLi9CZXppZXJVdGlscy5tanNcIjtcbmltcG9ydCB7IGJ1aWxkTGluZSB9IGZyb20gXCIuL2J1aWxkTGluZS5tanNcIjtcbmltcG9ydCB7IFF1YWRyYXRpY1V0aWxzIH0gZnJvbSBcIi4vUXVhZHJhdGljVXRpbHMubWpzXCI7XG5jb25zdCBGSUxMX0NPTU1BTkRTID0ge1xuICBbU0hBUEVTLlBPTFldOiBidWlsZFBvbHksXG4gIFtTSEFQRVMuQ0lSQ106IGJ1aWxkQ2lyY2xlLFxuICBbU0hBUEVTLkVMSVBdOiBidWlsZENpcmNsZSxcbiAgW1NIQVBFUy5SRUNUXTogYnVpbGRSZWN0YW5nbGUsXG4gIFtTSEFQRVMuUlJFQ106IGJ1aWxkUm91bmRlZFJlY3RhbmdsZVxufSwgQkFUQ0hfUE9PTCA9IFtdLCBEUkFXX0NBTExfUE9PTCA9IFtdO1xuZXhwb3J0IHtcbiAgQXJjVXRpbHMsXG4gIEJBVENIX1BPT0wsXG4gIEJhdGNoUGFydCxcbiAgQmV6aWVyVXRpbHMsXG4gIERSQVdfQ0FMTF9QT09MLFxuICBGSUxMX0NPTU1BTkRTLFxuICBRdWFkcmF0aWNVdGlscyxcbiAgYnVpbGRDaXJjbGUsXG4gIGJ1aWxkTGluZSxcbiAgYnVpbGRQb2x5LFxuICBidWlsZFJlY3RhbmdsZSxcbiAgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY2xhc3MgR3JhcGhpY3NEYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgKiBAcGFyYW0gZmlsbFN0eWxlIC0gdGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICogQHBhcmFtIGxpbmVTdHlsZSAtIHRoZSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAqIEBwYXJhbSBtYXRyaXggLSBUcmFuc2Zvcm0gbWF0cml4XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaGFwZSwgZmlsbFN0eWxlID0gbnVsbCwgbGluZVN0eWxlID0gbnVsbCwgbWF0cml4ID0gbnVsbCkge1xuICAgIHRoaXMucG9pbnRzID0gW10sIHRoaXMuaG9sZXMgPSBbXSwgdGhpcy5zaGFwZSA9IHNoYXBlLCB0aGlzLmxpbmVTdHlsZSA9IGxpbmVTdHlsZSwgdGhpcy5maWxsU3R5bGUgPSBmaWxsU3R5bGUsIHRoaXMubWF0cml4ID0gbWF0cml4LCB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzRGF0YSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIC0gQ2xvbmVkIEdyYXBoaWNzRGF0YSBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKFxuICAgICAgdGhpcy5zaGFwZSxcbiAgICAgIHRoaXMuZmlsbFN0eWxlLFxuICAgICAgdGhpcy5saW5lU3R5bGUsXG4gICAgICB0aGlzLm1hdHJpeFxuICAgICk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBkYXRhLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2hhcGUgPSBudWxsLCB0aGlzLmhvbGVzLmxlbmd0aCA9IDAsIHRoaXMuaG9sZXMgPSBudWxsLCB0aGlzLnBvaW50cy5sZW5ndGggPSAwLCB0aGlzLnBvaW50cyA9IG51bGwsIHRoaXMubGluZVN0eWxlID0gbnVsbCwgdGhpcy5maWxsU3R5bGUgPSBudWxsO1xuICB9XG59XG5leHBvcnQge1xuICBHcmFwaGljc0RhdGFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0RhdGEubWpzLm1hcFxuIiwiY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBCZWdpbiBiYXRjaCBwYXJ0LlxuICAgKiBAcGFyYW0gc3R5bGVcbiAgICogQHBhcmFtIHN0YXJ0SW5kZXhcbiAgICogQHBhcmFtIGF0dHJpYlN0YXJ0XG4gICAqL1xuICBiZWdpbihzdHlsZSwgc3RhcnRJbmRleCwgYXR0cmliU3RhcnQpIHtcbiAgICB0aGlzLnJlc2V0KCksIHRoaXMuc3R5bGUgPSBzdHlsZSwgdGhpcy5zdGFydCA9IHN0YXJ0SW5kZXgsIHRoaXMuYXR0cmliU3RhcnQgPSBhdHRyaWJTdGFydDtcbiAgfVxuICAvKipcbiAgICogRW5kIGJhdGNoIHBhcnQuXG4gICAqIEBwYXJhbSBlbmRJbmRleFxuICAgKiBAcGFyYW0gZW5kQXR0cmliXG4gICAqL1xuICBlbmQoZW5kSW5kZXgsIGVuZEF0dHJpYikge1xuICAgIHRoaXMuYXR0cmliU2l6ZSA9IGVuZEF0dHJpYiAtIHRoaXMuYXR0cmliU3RhcnQsIHRoaXMuc2l6ZSA9IGVuZEluZGV4IC0gdGhpcy5zdGFydDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0eWxlID0gbnVsbCwgdGhpcy5zaXplID0gMCwgdGhpcy5zdGFydCA9IDAsIHRoaXMuYXR0cmliU3RhcnQgPSAwLCB0aGlzLmF0dHJpYlNpemUgPSAwO1xuICB9XG59XG5leHBvcnQge1xuICBCYXRjaFBhcnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFBhcnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQsIEJhdGNoR2VvbWV0cnksIFdSQVBfTU9ERVMsIEJhc2VUZXh0dXJlLCBCYXRjaERyYXdDYWxsLCBCYXRjaFRleHR1cmVBcnJheSwgRFJBV19NT0RFUywgQ29sb3IgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmltcG9ydCB7IEdyYXBoaWNzRGF0YSB9IGZyb20gXCIuL0dyYXBoaWNzRGF0YS5tanNcIjtcbmltcG9ydCB7IERSQVdfQ0FMTF9QT09MLCBCQVRDSF9QT09MLCBGSUxMX0NPTU1BTkRTIH0gZnJvbSBcIi4vdXRpbHMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBCYXRjaFBhcnQgfSBmcm9tIFwiLi91dGlscy9CYXRjaFBhcnQubWpzXCI7XG5pbXBvcnQgeyBidWlsZFBvbHkgfSBmcm9tIFwiLi91dGlscy9idWlsZFBvbHkubWpzXCI7XG5pbXBvcnQgeyBidWlsZExpbmUgfSBmcm9tIFwiLi91dGlscy9idWlsZExpbmUubWpzXCI7XG5jb25zdCB0bXBQb2ludCA9IG5ldyBQb2ludCgpLCBfR3JhcGhpY3NHZW9tZXRyeSA9IGNsYXNzIF9HcmFwaGljc0dlb21ldHJ5MiBleHRlbmRzIEJhdGNoR2VvbWV0cnkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jbG9zZVBvaW50RXBzID0gMWUtNCwgdGhpcy5ib3VuZHNQYWRkaW5nID0gMCwgdGhpcy51dnNGbG9hdDMyID0gbnVsbCwgdGhpcy5pbmRpY2VzVWludDE2ID0gbnVsbCwgdGhpcy5iYXRjaGFibGUgPSAhMSwgdGhpcy5wb2ludHMgPSBbXSwgdGhpcy5jb2xvcnMgPSBbXSwgdGhpcy51dnMgPSBbXSwgdGhpcy5pbmRpY2VzID0gW10sIHRoaXMudGV4dHVyZUlkcyA9IFtdLCB0aGlzLmdyYXBoaWNzRGF0YSA9IFtdLCB0aGlzLmRyYXdDYWxscyA9IFtdLCB0aGlzLmJhdGNoRGlydHkgPSAtMSwgdGhpcy5iYXRjaGVzID0gW10sIHRoaXMuZGlydHkgPSAwLCB0aGlzLmNhY2hlRGlydHkgPSAtMSwgdGhpcy5jbGVhckRpcnR5ID0gMCwgdGhpcy5zaGFwZUluZGV4ID0gMCwgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcygpLCB0aGlzLmJvdW5kc0RpcnR5ID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGdyYXBoaWMgZ2VvbWV0cnkuXG4gICAqXG4gICAqIFNpbmNlIDYuNS4wLCBib3VuZHMgb2YgdGhlIGdyYXBoaWNzIGdlb21ldHJ5IGFyZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSB2ZXJ0aWNlcyBvZiBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gICAqIFNpbmNlIHNoYXBlcyBvciBzdHJva2VzIHdpdGggZnVsbCB0cmFuc3BhcmVuY3kgKGBhbHBoYTogMGApIHdpbGwgbm90IGdlbmVyYXRlIGdlb21ldHJ5LCB0aGV5IGFyZSBub3QgY29uc2lkZXJlZFxuICAgKiB3aGVuIGNhbGN1bGF0aW5nIGJvdW5kcyBmb3IgdGhlIGdyYXBoaWNzIGdlb21ldHJ5LiBTZWUgUFIgWyM4MzQzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGlqcy9wdWxsLzgzNDN9XG4gICAqIGFuZCBpc3N1ZSBbIzg2MjNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aWpzL3B1bGwvODYyM30uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVCYXRjaGVzKCksIHRoaXMuYm91bmRzRGlydHkgIT09IHRoaXMuZGlydHkgJiYgKHRoaXMuYm91bmRzRGlydHkgPSB0aGlzLmRpcnR5LCB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpKSwgdGhpcy5fYm91bmRzO1xuICB9XG4gIC8qKiBDYWxsIGlmIHlvdSBjaGFuZ2VkIGdyYXBoaWNzRGF0YSBtYW51YWxseS4gRW1wdGllcyBhbGwgYmF0Y2ggYnVmZmVycy4gKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLmJvdW5kc0RpcnR5ID0gLTEsIHRoaXMuZGlydHkrKywgdGhpcy5iYXRjaERpcnR5KyssIHRoaXMuc2hhcGVJbmRleCA9IDAsIHRoaXMucG9pbnRzLmxlbmd0aCA9IDAsIHRoaXMuY29sb3JzLmxlbmd0aCA9IDAsIHRoaXMudXZzLmxlbmd0aCA9IDAsIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwLCB0aGlzLnRleHR1cmVJZHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4QXJyYXkuY2xlYXIoKSwgRFJBV19DQUxMX1BPT0wucHVzaCh0aGlzLmRyYXdDYWxsc1tpXSk7XG4gICAgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2hQYXJ0ID0gdGhpcy5iYXRjaGVzW2ldO1xuICAgICAgYmF0Y2hQYXJ0LnJlc2V0KCksIEJBVENIX1BPT0wucHVzaChiYXRjaFBhcnQpO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMDtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBncmFwaGljcyB0aGF0IHdlcmUgZHJhd24gdG8gdGhpcyBHcmFwaGljcyBvYmplY3QsIGFuZCByZXNldHMgZmlsbCBhbmQgbGluZSBzdHlsZSBzZXR0aW5ncy5cbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzR2VvbWV0cnkgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPiAwICYmICh0aGlzLmludmFsaWRhdGUoKSwgdGhpcy5jbGVhckRpcnR5KyssIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDApLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdG8gdGhpcyBHcmFwaGljcyBvYmplY3QuIENhbiBiZSBhbnkgb2YgQ2lyY2xlLCBSZWN0YW5nbGUsIEVsbGlwc2UsIExpbmUgb3IgUG9seWdvbi5cbiAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXG4gICAqIEBwYXJhbSBmaWxsU3R5bGUgLSBEZWZpbmVzIHN0eWxlIG9mIHRoZSBmaWxsLlxuICAgKiBAcGFyYW0gbGluZVN0eWxlIC0gRGVmaW5lcyBzdHlsZSBvZiB0aGUgbGluZXMuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUcmFuc2Zvcm0gYXBwbGllZCB0byB0aGUgcG9pbnRzIG9mIHRoZSBzaGFwZS5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGRyYXdTaGFwZShzaGFwZSwgZmlsbFN0eWxlID0gbnVsbCwgbGluZVN0eWxlID0gbnVsbCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhKHNoYXBlLCBmaWxsU3R5bGUsIGxpbmVTdHlsZSwgbWF0cml4KTtcbiAgICByZXR1cm4gdGhpcy5ncmFwaGljc0RhdGEucHVzaChkYXRhKSwgdGhpcy5kaXJ0eSsrLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdG8gdGhpcyBHcmFwaGljcyBvYmplY3QuIENhbiBiZSBhbnkgb2YgQ2lyY2xlLCBSZWN0YW5nbGUsIEVsbGlwc2UsIExpbmUgb3IgUG9seWdvbi5cbiAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUcmFuc2Zvcm0gYXBwbGllZCB0byB0aGUgcG9pbnRzIG9mIHRoZSBzaGFwZS5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGRyYXdIb2xlKHNoYXBlLCBtYXRyaXggPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YShzaGFwZSwgbnVsbCwgbnVsbCwgbWF0cml4KSwgbGFzdFNoYXBlID0gdGhpcy5ncmFwaGljc0RhdGFbdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGRhdGEubGluZVN0eWxlID0gbGFzdFNoYXBlLmxpbmVTdHlsZSwgbGFzdFNoYXBlLmhvbGVzLnB1c2goZGF0YSksIHRoaXMuZGlydHkrKywgdGhpcztcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEdyYXBoaWNzR2VvbWV0cnkgb2JqZWN0LiAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgdGhpcy5ncmFwaGljc0RhdGFbaV0uZGVzdHJveSgpO1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDAsIHRoaXMucG9pbnRzID0gbnVsbCwgdGhpcy5jb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5jb2xvcnMgPSBudWxsLCB0aGlzLnV2cy5sZW5ndGggPSAwLCB0aGlzLnV2cyA9IG51bGwsIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwLCB0aGlzLmluZGljZXMgPSBudWxsLCB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDAsIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbCwgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMCwgdGhpcy5kcmF3Q2FsbHMgPSBudWxsLCB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMCwgdGhpcy5iYXRjaGVzID0gbnVsbCwgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gcG9pbnQgLSBQb2ludCB0byBjaGVjayBpZiBpdCdzIGNvbnRhaW5lZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBnZW9tZXRyeS5cbiAgICovXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCBncmFwaGljc0RhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZGF0YSA9IGdyYXBoaWNzRGF0YVtpXTtcbiAgICAgIGlmIChkYXRhLmZpbGxTdHlsZS52aXNpYmxlICYmIGRhdGEuc2hhcGUgJiYgKGRhdGEubWF0cml4ID8gZGF0YS5tYXRyaXguYXBwbHlJbnZlcnNlKHBvaW50LCB0bXBQb2ludCkgOiB0bXBQb2ludC5jb3B5RnJvbShwb2ludCksIGRhdGEuc2hhcGUuY29udGFpbnModG1wUG9pbnQueCwgdG1wUG9pbnQueSkpKSB7XG4gICAgICAgIGxldCBoaXRIb2xlID0gITE7XG4gICAgICAgIGlmIChkYXRhLmhvbGVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpMisrKVxuICAgICAgICAgICAgaWYgKGRhdGEuaG9sZXNbaTJdLnNoYXBlLmNvbnRhaW5zKHRtcFBvaW50LngsIHRtcFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgIGhpdEhvbGUgPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoaXRIb2xlKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgaW50ZXJtZWRpYXRlIGJhdGNoIGRhdGEuIEVpdGhlciBnZXRzIGNvbnZlcnRlZCB0byBkcmF3Q2FsbHNcbiAgICogb3IgdXNlZCB0byBjb252ZXJ0IHRvIGJhdGNoIG9iamVjdHMgZGlyZWN0bHkgYnkgdGhlIEdyYXBoaWNzIG9iamVjdC5cbiAgICovXG4gIHVwZGF0ZUJhdGNoZXMoKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmF0Y2hhYmxlID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZUJhdGNoaW5nKCkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jYWNoZURpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cywgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgbGV0IGJhdGNoUGFydCA9IG51bGwsIGN1cnJlbnRTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA+IDAgJiYgKGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1t0aGlzLmJhdGNoZXMubGVuZ3RoIC0gMV0sIGN1cnJlbnRTdHlsZSA9IGJhdGNoUGFydC5zdHlsZSk7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2hhcGVJbmRleDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zaGFwZUluZGV4Kys7XG4gICAgICBjb25zdCBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldLCBmaWxsU3R5bGUgPSBkYXRhLmZpbGxTdHlsZSwgbGluZVN0eWxlID0gZGF0YS5saW5lU3R5bGU7XG4gICAgICBGSUxMX0NPTU1BTkRTW2RhdGEudHlwZV0uYnVpbGQoZGF0YSksIGRhdGEubWF0cml4ICYmIHRoaXMudHJhbnNmb3JtUG9pbnRzKGRhdGEucG9pbnRzLCBkYXRhLm1hdHJpeCksIChmaWxsU3R5bGUudmlzaWJsZSB8fCBsaW5lU3R5bGUudmlzaWJsZSkgJiYgdGhpcy5wcm9jZXNzSG9sZXMoZGF0YS5ob2xlcyk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGogPT09IDAgPyBmaWxsU3R5bGUgOiBsaW5lU3R5bGU7XG4gICAgICAgIGlmICghc3R5bGUudmlzaWJsZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbmRleDIgPSB0aGlzLmluZGljZXMubGVuZ3RoLCBhdHRyaWJJbmRleCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5SRVBFQVQsIGogPT09IDAgPyB0aGlzLnByb2Nlc3NGaWxsKGRhdGEpIDogdGhpcy5wcm9jZXNzTGluZShkYXRhKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDIgLSBhdHRyaWJJbmRleDtcbiAgICAgICAgc2l6ZSAhPT0gMCAmJiAoYmF0Y2hQYXJ0ICYmICF0aGlzLl9jb21wYXJlU3R5bGVzKGN1cnJlbnRTdHlsZSwgc3R5bGUpICYmIChiYXRjaFBhcnQuZW5kKGluZGV4MiwgYXR0cmliSW5kZXgpLCBiYXRjaFBhcnQgPSBudWxsKSwgYmF0Y2hQYXJ0IHx8IChiYXRjaFBhcnQgPSBCQVRDSF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaFBhcnQoKSwgYmF0Y2hQYXJ0LmJlZ2luKHN0eWxlLCBpbmRleDIsIGF0dHJpYkluZGV4KSwgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KSwgY3VycmVudFN0eWxlID0gc3R5bGUpLCB0aGlzLmFkZFV2cyh0aGlzLnBvaW50cywgdXZzLCBzdHlsZS50ZXh0dXJlLCBhdHRyaWJJbmRleCwgc2l6ZSwgc3R5bGUubWF0cml4KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRpY2VzLmxlbmd0aCwgYXR0cmliID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBpZiAoYmF0Y2hQYXJ0ICYmIGJhdGNoUGFydC5lbmQoaW5kZXgsIGF0dHJpYiksIHRoaXMuYmF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuYmF0Y2hhYmxlID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWQzMiA9IGF0dHJpYiA+IDY1NTM1O1xuICAgIHRoaXMuaW5kaWNlc1VpbnQxNiAmJiB0aGlzLmluZGljZXMubGVuZ3RoID09PSB0aGlzLmluZGljZXNVaW50MTYubGVuZ3RoICYmIG5lZWQzMiA9PT0gdGhpcy5pbmRpY2VzVWludDE2LkJZVEVTX1BFUl9FTEVNRU5UID4gMiA/IHRoaXMuaW5kaWNlc1VpbnQxNi5zZXQodGhpcy5pbmRpY2VzKSA6IHRoaXMuaW5kaWNlc1VpbnQxNiA9IG5lZWQzMiA/IG5ldyBVaW50MzJBcnJheSh0aGlzLmluZGljZXMpIDogbmV3IFVpbnQxNkFycmF5KHRoaXMuaW5kaWNlcyksIHRoaXMuYmF0Y2hhYmxlID0gdGhpcy5pc0JhdGNoYWJsZSgpLCB0aGlzLmJhdGNoYWJsZSA/IHRoaXMucGFja0JhdGNoZXMoKSA6IHRoaXMuYnVpbGREcmF3Q2FsbHMoKTtcbiAgfVxuICAvKipcbiAgICogQWZmaW5pdHkgY2hlY2tcbiAgICogQHBhcmFtIHN0eWxlQVxuICAgKiBAcGFyYW0gc3R5bGVCXG4gICAqL1xuICBfY29tcGFyZVN0eWxlcyhzdHlsZUEsIHN0eWxlQikge1xuICAgIHJldHVybiAhKCFzdHlsZUEgfHwgIXN0eWxlQiB8fCBzdHlsZUEudGV4dHVyZS5iYXNlVGV4dHVyZSAhPT0gc3R5bGVCLnRleHR1cmUuYmFzZVRleHR1cmUgfHwgc3R5bGVBLmNvbG9yICsgc3R5bGVBLmFscGhhICE9PSBzdHlsZUIuY29sb3IgKyBzdHlsZUIuYWxwaGEgfHwgISFzdHlsZUEubmF0aXZlICE9ICEhc3R5bGVCLm5hdGl2ZSk7XG4gIH1cbiAgLyoqIFRlc3QgZ2VvbWV0cnkgZm9yIGJhdGNoaW5nIHByb2Nlc3MuICovXG4gIHZhbGlkYXRlQmF0Y2hpbmcoKSB7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IHRoaXMuY2FjaGVEaXJ0eSB8fCAhdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV0sIGZpbGwgPSBkYXRhLmZpbGxTdHlsZSwgbGluZSA9IGRhdGEubGluZVN0eWxlO1xuICAgICAgaWYgKGZpbGwgJiYgIWZpbGwudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZCB8fCBsaW5lICYmICFsaW5lLnRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKiBPZmZzZXQgdGhlIGluZGljZXMgc28gdGhhdCBpdCB3b3JrcyB3aXRoIHRoZSBiYXRjaGVyLiAqL1xuICBwYWNrQmF0Y2hlcygpIHtcbiAgICB0aGlzLmJhdGNoRGlydHkrKywgdGhpcy51dnNGbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnV2cyk7XG4gICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcztcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGJhdGNoZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJhdGNoLnNpemU7IGorKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGJhdGNoLnN0YXJ0ICsgajtcbiAgICAgICAgdGhpcy5pbmRpY2VzVWludDE2W2luZGV4XSA9IHRoaXMuaW5kaWNlc1VpbnQxNltpbmRleF0gLSBiYXRjaC5hdHRyaWJTdGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhpcyBncmFwaGljcyBnZW9tZXRyeSBjYW4gYmUgYmF0Y2hlZC5cbiAgICogQ3VycmVudGx5IGl0IG5lZWRzIHRvIGJlIHNtYWxsIGVub3VnaCBhbmQgbm90IGNvbnRhaW4gYW55IG5hdGl2ZSBsaW5lcy5cbiAgICovXG4gIGlzQmF0Y2hhYmxlKCkge1xuICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPiA2NTUzNSAqIDIpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoYmF0Y2hlc1tpXS5zdHlsZS5uYXRpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gdGhpcy5wb2ludHMubGVuZ3RoIDwgX0dyYXBoaWNzR2VvbWV0cnkyLkJBVENIQUJMRV9TSVpFICogMjtcbiAgfVxuICAvKiogQ29udmVydHMgaW50ZXJtZWRpYXRlIGJhdGNoZXMgZGF0YSB0byBkcmF3Q2FsbHMuICovXG4gIGJ1aWxkRHJhd0NhbGxzKCkge1xuICAgIGxldCBUSUNLID0gKytCYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuZHJhd0NhbGxzW2ldLnRleEFycmF5LmNsZWFyKCksIERSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5jb2xvcnMsIHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IERSQVdfQ0FMTF9QT09MLnBvcCgpO1xuICAgIGN1cnJlbnRHcm91cCB8fCAoY3VycmVudEdyb3VwID0gbmV3IEJhdGNoRHJhd0NhbGwoKSwgY3VycmVudEdyb3VwLnRleEFycmF5ID0gbmV3IEJhdGNoVGV4dHVyZUFycmF5KCkpLCBjdXJyZW50R3JvdXAudGV4QXJyYXkuY291bnQgPSAwLCBjdXJyZW50R3JvdXAuc3RhcnQgPSAwLCBjdXJyZW50R3JvdXAuc2l6ZSA9IDAsIGN1cnJlbnRHcm91cC50eXBlID0gRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgbGV0IHRleHR1cmVDb3VudCA9IDAsIGN1cnJlbnRUZXh0dXJlID0gbnVsbCwgdGV4dHVyZUlkID0gMCwgbmF0aXZlID0gITEsIGRyYXdNb2RlID0gRFJBV19NT0RFUy5UUklBTkdMRVMsIGluZGV4ID0gMDtcbiAgICB0aGlzLmRyYXdDYWxscy5wdXNoKGN1cnJlbnRHcm91cCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmJhdGNoZXNbaV0sIG1heFRleHR1cmVzID0gOCwgc3R5bGUgPSBkYXRhLnN0eWxlLCBuZXh0VGV4dHVyZSA9IHN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICBuYXRpdmUgIT09ICEhc3R5bGUubmF0aXZlICYmIChuYXRpdmUgPSAhIXN0eWxlLm5hdGl2ZSwgZHJhd01vZGUgPSBuYXRpdmUgPyBEUkFXX01PREVTLkxJTkVTIDogRFJBV19NT0RFUy5UUklBTkdMRVMsIGN1cnJlbnRUZXh0dXJlID0gbnVsbCwgdGV4dHVyZUNvdW50ID0gbWF4VGV4dHVyZXMsIFRJQ0srKyksIGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSAmJiAoY3VycmVudFRleHR1cmUgPSBuZXh0VGV4dHVyZSwgbmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCAhPT0gVElDSyAmJiAodGV4dHVyZUNvdW50ID09PSBtYXhUZXh0dXJlcyAmJiAoVElDSysrLCB0ZXh0dXJlQ291bnQgPSAwLCBjdXJyZW50R3JvdXAuc2l6ZSA+IDAgJiYgKGN1cnJlbnRHcm91cCA9IERSQVdfQ0FMTF9QT09MLnBvcCgpLCBjdXJyZW50R3JvdXAgfHwgKGN1cnJlbnRHcm91cCA9IG5ldyBCYXRjaERyYXdDYWxsKCksIGN1cnJlbnRHcm91cC50ZXhBcnJheSA9IG5ldyBCYXRjaFRleHR1cmVBcnJheSgpKSwgdGhpcy5kcmF3Q2FsbHMucHVzaChjdXJyZW50R3JvdXApKSwgY3VycmVudEdyb3VwLnN0YXJ0ID0gaW5kZXgsIGN1cnJlbnRHcm91cC5zaXplID0gMCwgY3VycmVudEdyb3VwLnRleEFycmF5LmNvdW50ID0gMCwgY3VycmVudEdyb3VwLnR5cGUgPSBkcmF3TW9kZSksIG5leHRUZXh0dXJlLnRvdWNoZWQgPSAxLCBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSywgbmV4dFRleHR1cmUuX2JhdGNoTG9jYXRpb24gPSB0ZXh0dXJlQ291bnQsIG5leHRUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5SRVBFQVQsIGN1cnJlbnRHcm91cC50ZXhBcnJheS5lbGVtZW50c1tjdXJyZW50R3JvdXAudGV4QXJyYXkuY291bnQrK10gPSBuZXh0VGV4dHVyZSwgdGV4dHVyZUNvdW50KyspKSwgY3VycmVudEdyb3VwLnNpemUgKz0gZGF0YS5zaXplLCBpbmRleCArPSBkYXRhLnNpemUsIHRleHR1cmVJZCA9IG5leHRUZXh0dXJlLl9iYXRjaExvY2F0aW9uLCB0aGlzLmFkZENvbG9ycyhjb2xvcnMsIHN0eWxlLmNvbG9yLCBzdHlsZS5hbHBoYSwgZGF0YS5hdHRyaWJTaXplLCBkYXRhLmF0dHJpYlN0YXJ0KSwgdGhpcy5hZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIHRleHR1cmVJZCwgZGF0YS5hdHRyaWJTaXplLCBkYXRhLmF0dHJpYlN0YXJ0KTtcbiAgICB9XG4gICAgQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gVElDSywgdGhpcy5wYWNrQXR0cmlidXRlcygpO1xuICB9XG4gIC8qKiBQYWNrcyBhdHRyaWJ1dGVzIHRvIHNpbmdsZSBidWZmZXIuICovXG4gIHBhY2tBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy5wb2ludHMsIHV2cyA9IHRoaXMudXZzLCBjb2xvcnMgPSB0aGlzLmNvbG9ycywgdGV4dHVyZUlkcyA9IHRoaXMudGV4dHVyZUlkcywgZ2xQb2ludHMgPSBuZXcgQXJyYXlCdWZmZXIodmVydHMubGVuZ3RoICogMyAqIDQpLCBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KGdsUG9pbnRzKSwgdTMyID0gbmV3IFVpbnQzMkFycmF5KGdsUG9pbnRzKTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0cy5sZW5ndGggLyAyOyBpKyspXG4gICAgICBmMzJbcCsrXSA9IHZlcnRzW2kgKiAyXSwgZjMyW3ArK10gPSB2ZXJ0c1tpICogMiArIDFdLCBmMzJbcCsrXSA9IHV2c1tpICogMl0sIGYzMltwKytdID0gdXZzW2kgKiAyICsgMV0sIHUzMltwKytdID0gY29sb3JzW2ldLCBmMzJbcCsrXSA9IHRleHR1cmVJZHNbaV07XG4gICAgdGhpcy5fYnVmZmVyLnVwZGF0ZShnbFBvaW50cyksIHRoaXMuX2luZGV4QnVmZmVyLnVwZGF0ZSh0aGlzLmluZGljZXNVaW50MTYpO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGZpbGwgcGFydCBvZiBHcmFwaGljcy5cbiAgICogQHBhcmFtIGRhdGFcbiAgICovXG4gIHByb2Nlc3NGaWxsKGRhdGEpIHtcbiAgICBkYXRhLmhvbGVzLmxlbmd0aCA/IGJ1aWxkUG9seS50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKSA6IEZJTExfQ09NTUFORFNbZGF0YS50eXBlXS50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBsaW5lIHBhcnQgb2YgR3JhcGhpY3MuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqL1xuICBwcm9jZXNzTGluZShkYXRhKSB7XG4gICAgYnVpbGRMaW5lKGRhdGEsIHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5ob2xlcy5sZW5ndGg7IGkrKylcbiAgICAgIGJ1aWxkTGluZShkYXRhLmhvbGVzW2ldLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgaG9sZXMgZGF0YS5cbiAgICogQHBhcmFtIGhvbGVzXG4gICAqL1xuICBwcm9jZXNzSG9sZXMoaG9sZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBob2xlID0gaG9sZXNbaV07XG4gICAgICBGSUxMX0NPTU1BTkRTW2hvbGUudHlwZV0uYnVpbGQoaG9sZSksIGhvbGUubWF0cml4ICYmIHRoaXMudHJhbnNmb3JtUG9pbnRzKGhvbGUucG9pbnRzLCBob2xlLm1hdHJpeCk7XG4gICAgfVxuICB9XG4gIC8qKiBVcGRhdGUgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgb2JqZWN0LiBFeHBlbnNpdmUgdG8gdXNlIHBlcmZvcm1hbmNlLXdpc2UuICovXG4gIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCksIGJvdW5kcy5hZGRWZXJ0ZXhEYXRhKHRoaXMucG9pbnRzLCAwLCB0aGlzLnBvaW50cy5sZW5ndGgpLCBib3VuZHMucGFkKHRoaXMuYm91bmRzUGFkZGluZywgdGhpcy5ib3VuZHNQYWRkaW5nKTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHBvaW50cyB1c2luZyBtYXRyaXguXG4gICAqIEBwYXJhbSBwb2ludHMgLSBQb2ludHMgdG8gdHJhbnNmb3JtXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUcmFuc2Zvcm0gbWF0cml4XG4gICAqL1xuICB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCBtYXRyaXgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBwb2ludHNbaSAqIDJdLCB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICBwb2ludHNbaSAqIDJdID0gbWF0cml4LmEgKiB4ICsgbWF0cml4LmMgKiB5ICsgbWF0cml4LnR4LCBwb2ludHNbaSAqIDIgKyAxXSA9IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjb2xvcnMuXG4gICAqIEBwYXJhbSBjb2xvcnMgLSBMaXN0IG9mIGNvbG9ycyB0byBhZGQgdG9cbiAgICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gYWRkXG4gICAqIEBwYXJhbSBhbHBoYSAtIEFscGhhIHRvIHVzZVxuICAgKiBAcGFyYW0gc2l6ZSAtIE51bWJlciBvZiBjb2xvcnMgdG8gYWRkXG4gICAqIEBwYXJhbSBvZmZzZXRcbiAgICovXG4gIGFkZENvbG9ycyhjb2xvcnMsIGNvbG9yLCBhbHBoYSwgc2l6ZSwgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGJnciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb2xvcikudG9MaXR0bGVFbmRpYW5OdW1iZXIoKSwgcmVzdWx0ID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGJncikudG9QcmVtdWx0aXBsaWVkKGFscGhhKTtcbiAgICBjb2xvcnMubGVuZ3RoID0gTWF0aC5tYXgoY29sb3JzLmxlbmd0aCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICBjb2xvcnNbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCB0ZXh0dXJlIGlkIHRoYXQgdGhlIHNoYWRlci9mcmFnbWVudCB3YW50cyB0byB1c2UuXG4gICAqIEBwYXJhbSB0ZXh0dXJlSWRzXG4gICAqIEBwYXJhbSBpZFxuICAgKiBAcGFyYW0gc2l6ZVxuICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAqL1xuICBhZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIGlkLCBzaXplLCBvZmZzZXQgPSAwKSB7XG4gICAgdGV4dHVyZUlkcy5sZW5ndGggPSBNYXRoLm1heCh0ZXh0dXJlSWRzLmxlbmd0aCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICB0ZXh0dXJlSWRzW29mZnNldCArIGldID0gaWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgVVZzIGZvciBhIHNoYXBlLlxuICAgKiBAcGFyYW0gdmVydHMgLSBWZXJ0aWNlc1xuICAgKiBAcGFyYW0gdXZzIC0gVVZzXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gUmVmZXJlbmNlIHRvIFRleHR1cmVcbiAgICogQHBhcmFtIHN0YXJ0IC0gSW5kZXggYnVmZmVyIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplL2xlbmd0aCBmb3IgaW5kZXggYnVmZmVyLlxuICAgKiBAcGFyYW0gbWF0cml4IC0gT3B0aW9uYWwgdHJhbnNmb3JtIGZvciBhbGwgcG9pbnRzLlxuICAgKi9cbiAgYWRkVXZzKHZlcnRzLCB1dnMsIHRleHR1cmUsIHN0YXJ0LCBzaXplLCBtYXRyaXggPSBudWxsKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCB1dnNTdGFydCA9IHV2cy5sZW5ndGgsIGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcbiAgICBmb3IgKDsgaW5kZXggPCBzaXplOyApIHtcbiAgICAgIGxldCB4ID0gdmVydHNbKHN0YXJ0ICsgaW5kZXgpICogMl0sIHkgPSB2ZXJ0c1soc3RhcnQgKyBpbmRleCkgKiAyICsgMV07XG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIGNvbnN0IG54ID0gbWF0cml4LmEgKiB4ICsgbWF0cml4LmMgKiB5ICsgbWF0cml4LnR4O1xuICAgICAgICB5ID0gbWF0cml4LmIgKiB4ICsgbWF0cml4LmQgKiB5ICsgbWF0cml4LnR5LCB4ID0gbng7XG4gICAgICB9XG4gICAgICBpbmRleCsrLCB1dnMucHVzaCh4IC8gZnJhbWUud2lkdGgsIHkgLyBmcmFtZS5oZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgKGZyYW1lLndpZHRoIDwgYmFzZVRleHR1cmUud2lkdGggfHwgZnJhbWUuaGVpZ2h0IDwgYmFzZVRleHR1cmUuaGVpZ2h0KSAmJiB0aGlzLmFkanVzdFV2cyh1dnMsIHRleHR1cmUsIHV2c1N0YXJ0LCBzaXplKTtcbiAgfVxuICAvKipcbiAgICogTW9kaWZ5IHV2cyBhcnJheSBhY2NvcmRpbmcgdG8gcG9zaXRpb24gb2YgdGV4dHVyZSByZWdpb25cbiAgICogRG9lcyBub3Qgd29yayB3aXRoIHJvdGF0ZWQgb3IgdHJpbW1lZCB0ZXh0dXJlc1xuICAgKiBAcGFyYW0gdXZzIC0gYXJyYXlcbiAgICogQHBhcmFtIHRleHR1cmUgLSByZWdpb25cbiAgICogQHBhcmFtIHN0YXJ0IC0gc3RhcnRpbmcgaW5kZXggZm9yIHV2c1xuICAgKiBAcGFyYW0gc2l6ZSAtIGhvdyBtYW55IHBvaW50cyB0byBhZGp1c3RcbiAgICovXG4gIGFkanVzdFV2cyh1dnMsIHRleHR1cmUsIHN0YXJ0LCBzaXplKSB7XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLCBlcHMgPSAxZS02LCBmaW5pc2ggPSBzdGFydCArIHNpemUgKiAyLCBmcmFtZSA9IHRleHR1cmUuZnJhbWUsIHNjYWxlWCA9IGZyYW1lLndpZHRoIC8gYmFzZVRleHR1cmUud2lkdGgsIHNjYWxlWSA9IGZyYW1lLmhlaWdodCAvIGJhc2VUZXh0dXJlLmhlaWdodDtcbiAgICBsZXQgb2Zmc2V0WCA9IGZyYW1lLnggLyBmcmFtZS53aWR0aCwgb2Zmc2V0WSA9IGZyYW1lLnkgLyBmcmFtZS5oZWlnaHQsIG1pblggPSBNYXRoLmZsb29yKHV2c1tzdGFydF0gKyBlcHMpLCBtaW5ZID0gTWF0aC5mbG9vcih1dnNbc3RhcnQgKyAxXSArIGVwcyk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMjsgaSA8IGZpbmlzaDsgaSArPSAyKVxuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIE1hdGguZmxvb3IodXZzW2ldICsgZXBzKSksIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBNYXRoLmZsb29yKHV2c1tpICsgMV0gKyBlcHMpKTtcbiAgICBvZmZzZXRYIC09IG1pblgsIG9mZnNldFkgLT0gbWluWTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmaW5pc2g7IGkgKz0gMilcbiAgICAgIHV2c1tpXSA9ICh1dnNbaV0gKyBvZmZzZXRYKSAqIHNjYWxlWCwgdXZzW2kgKyAxXSA9ICh1dnNbaSArIDFdICsgb2Zmc2V0WSkgKiBzY2FsZVk7XG4gIH1cbn07XG5fR3JhcGhpY3NHZW9tZXRyeS5CQVRDSEFCTEVfU0laRSA9IDEwMDtcbmxldCBHcmFwaGljc0dlb21ldHJ5ID0gX0dyYXBoaWNzR2VvbWV0cnk7XG5leHBvcnQge1xuICBHcmFwaGljc0dlb21ldHJ5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmNsYXNzIEZpbGxTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29sb3IgPSAxNjc3NzIxNSwgdGhpcy5hbHBoYSA9IDEsIHRoaXMudGV4dHVyZSA9IFRleHR1cmUuV0hJVEUsIHRoaXMubWF0cml4ID0gbnVsbCwgdGhpcy52aXNpYmxlID0gITEsIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKiogQ2xvbmVzIHRoZSBvYmplY3QgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgb2JqID0gbmV3IEZpbGxTdHlsZSgpO1xuICAgIHJldHVybiBvYmouY29sb3IgPSB0aGlzLmNvbG9yLCBvYmouYWxwaGEgPSB0aGlzLmFscGhhLCBvYmoudGV4dHVyZSA9IHRoaXMudGV4dHVyZSwgb2JqLm1hdHJpeCA9IHRoaXMubWF0cml4LCBvYmoudmlzaWJsZSA9IHRoaXMudmlzaWJsZSwgb2JqO1xuICB9XG4gIC8qKiBSZXNldCAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmNvbG9yID0gMTY3NzcyMTUsIHRoaXMuYWxwaGEgPSAxLCB0aGlzLnRleHR1cmUgPSBUZXh0dXJlLldISVRFLCB0aGlzLm1hdHJpeCA9IG51bGwsIHRoaXMudmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsLCB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEZpbGxTdHlsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBMSU5FX0NBUCwgTElORV9KT0lOIH0gZnJvbSBcIi4uL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgRmlsbFN0eWxlIH0gZnJvbSBcIi4vRmlsbFN0eWxlLm1qc1wiO1xuY2xhc3MgTGluZVN0eWxlIGV4dGVuZHMgRmlsbFN0eWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy53aWR0aCA9IDAsIHRoaXMuYWxpZ25tZW50ID0gMC41LCB0aGlzLm5hdGl2ZSA9ICExLCB0aGlzLmNhcCA9IExJTkVfQ0FQLkJVVFQsIHRoaXMuam9pbiA9IExJTkVfSk9JTi5NSVRFUiwgdGhpcy5taXRlckxpbWl0ID0gMTA7XG4gIH1cbiAgLyoqIENsb25lcyB0aGUgb2JqZWN0LiAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBvYmogPSBuZXcgTGluZVN0eWxlKCk7XG4gICAgcmV0dXJuIG9iai5jb2xvciA9IHRoaXMuY29sb3IsIG9iai5hbHBoYSA9IHRoaXMuYWxwaGEsIG9iai50ZXh0dXJlID0gdGhpcy50ZXh0dXJlLCBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXgsIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlLCBvYmoud2lkdGggPSB0aGlzLndpZHRoLCBvYmouYWxpZ25tZW50ID0gdGhpcy5hbGlnbm1lbnQsIG9iai5uYXRpdmUgPSB0aGlzLm5hdGl2ZSwgb2JqLmNhcCA9IHRoaXMuY2FwLCBvYmouam9pbiA9IHRoaXMuam9pbiwgb2JqLm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQsIG9iajtcbiAgfVxuICAvKiogUmVzZXQgdGhlIGxpbmUgc3R5bGUgdG8gZGVmYXVsdC4gKi9cbiAgcmVzZXQoKSB7XG4gICAgc3VwZXIucmVzZXQoKSwgdGhpcy5jb2xvciA9IDAsIHRoaXMuYWxpZ25tZW50ID0gMC41LCB0aGlzLndpZHRoID0gMCwgdGhpcy5uYXRpdmUgPSAhMSwgdGhpcy5jYXAgPSBMSU5FX0NBUC5CVVRULCB0aGlzLmpvaW4gPSBMSU5FX0pPSU4uTUlURVIsIHRoaXMubWl0ZXJMaW1pdCA9IDEwO1xuICB9XG59XG5leHBvcnQge1xuICBMaW5lU3R5bGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU3RhdGUsIENvbG9yLCBCTEVORF9NT0RFUywgVGV4dHVyZSwgUG9seWdvbiwgUElfMiwgUmVjdGFuZ2xlLCBSb3VuZGVkUmVjdGFuZ2xlLCBDaXJjbGUsIEVsbGlwc2UsIFNIQVBFUywgTWF0cml4LCBVbmlmb3JtR3JvdXAsIFNoYWRlciwgUG9pbnQgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmltcG9ydCB7IExJTkVfQ0FQLCBMSU5FX0pPSU4sIGN1cnZlcyB9IGZyb20gXCIuL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9IGZyb20gXCIuL0dyYXBoaWNzR2VvbWV0cnkubWpzXCI7XG5pbXBvcnQgeyBGaWxsU3R5bGUgfSBmcm9tIFwiLi9zdHlsZXMvRmlsbFN0eWxlLm1qc1wiO1xuaW1wb3J0IHsgTGluZVN0eWxlIH0gZnJvbSBcIi4vc3R5bGVzL0xpbmVTdHlsZS5tanNcIjtcbmltcG9ydCBcIi4vdXRpbHMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyBRdWFkcmF0aWNVdGlscyB9IGZyb20gXCIuL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qc1wiO1xuaW1wb3J0IHsgQmV6aWVyVXRpbHMgfSBmcm9tIFwiLi91dGlscy9CZXppZXJVdGlscy5tanNcIjtcbmltcG9ydCB7IEFyY1V0aWxzIH0gZnJvbSBcIi4vdXRpbHMvQXJjVXRpbHMubWpzXCI7XG5jb25zdCBERUZBVUxUX1NIQURFUlMgPSB7fSwgX0dyYXBoaWNzID0gY2xhc3MgX0dyYXBoaWNzMiBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZ2VvbWV0cnkgLSBHZW9tZXRyeSB0byB1c2UsIGlmIG9taXR0ZWQgd2lsbCBjcmVhdGUgYSBuZXcgR3JhcGhpY3NHZW9tZXRyeSBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbnVsbCkge1xuICAgIHN1cGVyKCksIHRoaXMuc2hhZGVyID0gbnVsbCwgdGhpcy5wbHVnaW5OYW1lID0gXCJiYXRjaFwiLCB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbCwgdGhpcy5iYXRjaGVzID0gW10sIHRoaXMuYmF0Y2hUaW50ID0gLTEsIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xLCB0aGlzLnZlcnRleERhdGEgPSBudWxsLCB0aGlzLl9maWxsU3R5bGUgPSBuZXcgRmlsbFN0eWxlKCksIHRoaXMuX2xpbmVTdHlsZSA9IG5ldyBMaW5lU3R5bGUoKSwgdGhpcy5fbWF0cml4ID0gbnVsbCwgdGhpcy5faG9sZU1vZGUgPSAhMSwgdGhpcy5zdGF0ZSA9IFN0YXRlLmZvcjJkKCksIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnkgfHwgbmV3IEdyYXBoaWNzR2VvbWV0cnkoKSwgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQrKywgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMSwgdGhpcy5fdGludENvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KSwgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gIH1cbiAgLyoqXG4gICAqIEluY2x1ZGVzIHZlcnRleCBwb3NpdGlvbnMsIGZhY2UgaW5kaWNlcywgbm9ybWFscywgY29sb3JzLCBVVnMsIGFuZFxuICAgKiBjdXN0b20gYXR0cmlidXRlcyB3aXRoaW4gYnVmZmVycywgcmVkdWNpbmcgdGhlIGNvc3Qgb2YgcGFzc2luZyBhbGxcbiAgICogdGhpcyBkYXRhIHRvIHRoZSBHUFUuIENhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBNZXNoIG9yIEdyYXBoaWNzIG9iamVjdHMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIE5vdGUgdGhhdCBvbmx5IHRoZSBnZW9tZXRyeSBvZiB0aGUgb2JqZWN0IGlzIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICogQHJldHVybnMgLSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFBvbHkoKSwgbmV3IF9HcmFwaGljczIodGhpcy5fZ2VvbWV0cnkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBBcHBseSBhIHZhbHVlIG9mXG4gICAqIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuICBOb3RlIHRoYXQsIHNpbmNlIGVhY2hcbiAgICogcHJpbWl0aXZlIGluIHRoZSBHcmFwaGljc0dlb21ldHJ5IGxpc3QgaXMgcmVuZGVyZWQgc2VxdWVudGlhbGx5LCBtb2Rlc1xuICAgKiBzdWNoIGFzIGBQSVhJLkJMRU5EX01PREVTLkFERGAgYW5kIGBQSVhJLkJMRU5EX01PREVTLk1VTFRJUExZYCB3aWxsXG4gICAqIGJlIGFwcGxpZWQgcGVyLXByaW1pdGl2ZS5cbiAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICovXG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIGVhY2ggZ3JhcGhpYyBzaGFwZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZlxuICAgKiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmlsbCBzdHlsZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbFN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsaW5lIHN0eWxlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lU3R5bGU7XG4gIH1cbiAgbGluZVN0eWxlKG9wdGlvbnMgPSBudWxsLCBjb2xvciA9IDAsIGFscGhhLCBhbGlnbm1lbnQgPSAwLjUsIG5hdGl2ZSA9ICExKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09IFwibnVtYmVyXCIgJiYgKG9wdGlvbnMgPSB7IHdpZHRoOiBvcHRpb25zLCBjb2xvciwgYWxwaGEsIGFsaWdubWVudCwgbmF0aXZlIH0pLCB0aGlzLmxpbmVUZXh0dXJlU3R5bGUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgbGluZSBzdHlsZSBidXQgc3VwcG9ydCB0ZXh0dXJlIGZvciBsaW5lIGZpbGwuXG4gICAqIEBwYXJhbSBbb3B0aW9uc10gLSBDb2xsZWN0aW9uIG9mIG9wdGlvbnMgZm9yIHNldHRpbmcgbGluZSBzdHlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTBdIC0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbb3B0aW9ucy50ZXh0dXJlPVBJWEkuVGV4dHVyZS5XSElURV0gLSBUZXh0dXJlIHRvIHVzZVxuICAgKiBAcGFyYW0ge1BJWEkuQ29sb3JTb3VyY2V9IFtvcHRpb25zLmNvbG9yPTB4MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGUuXG4gICAqICBEZWZhdWx0IDB4RkZGRkZGIGlmIHRleHR1cmUgcHJlc2VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IFtvcHRpb25zLm1hdHJpeD1udWxsXSAtIFRleHR1cmUgbWF0cml4IHRvIHRyYW5zZm9ybSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbGlnbm1lbnQ9MC41XSAtIGFsaWdubWVudCBvZiB0aGUgbGluZSB0byBkcmF3LCAoMCA9IGlubmVyLCAwLjUgPSBtaWRkbGUsIDEgPSBvdXRlcikuXG4gICAqICAgICAgICBXZWJHTCBvbmx5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5hdGl2ZT1mYWxzZV0gLSBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgKiBAcGFyYW0ge1BJWEkuTElORV9DQVB9W29wdGlvbnMuY2FwPVBJWEkuTElORV9DQVAuQlVUVF0gLSBsaW5lIGNhcCBzdHlsZVxuICAgKiBAcGFyYW0ge1BJWEkuTElORV9KT0lOfVtvcHRpb25zLmpvaW49UElYSS5MSU5FX0pPSU4uTUlURVJdIC0gbGluZSBqb2luIHN0eWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfVtvcHRpb25zLm1pdGVyTGltaXQ9MTBdIC0gbWl0ZXIgbGltaXQgcmF0aW9cbiAgICogQHJldHVybnMge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGxpbmVUZXh0dXJlU3R5bGUob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3R5bGVPcHRpb25zID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICB0ZXh0dXJlOiBUZXh0dXJlLldISVRFLFxuICAgICAgY29sb3I6IG9wdGlvbnM/LnRleHR1cmUgPyAxNjc3NzIxNSA6IDAsXG4gICAgICBtYXRyaXg6IG51bGwsXG4gICAgICBhbGlnbm1lbnQ6IDAuNSxcbiAgICAgIG5hdGl2ZTogITEsXG4gICAgICBjYXA6IExJTkVfQ0FQLkJVVFQsXG4gICAgICBqb2luOiBMSU5FX0pPSU4uTUlURVIsXG4gICAgICBtaXRlckxpbWl0OiAxMFxuICAgIH07XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdExpbmVTdHlsZU9wdGlvbnMsIG9wdGlvbnMpLCB0aGlzLm5vcm1hbGl6ZUNvbG9yKG9wdGlvbnMpLCB0aGlzLmN1cnJlbnRQYXRoICYmIHRoaXMuc3RhcnRQb2x5KCk7XG4gICAgY29uc3QgdmlzaWJsZSA9IG9wdGlvbnMud2lkdGggPiAwICYmIG9wdGlvbnMuYWxwaGEgPiAwO1xuICAgIHJldHVybiB2aXNpYmxlID8gKG9wdGlvbnMubWF0cml4ICYmIChvcHRpb25zLm1hdHJpeCA9IG9wdGlvbnMubWF0cml4LmNsb25lKCksIG9wdGlvbnMubWF0cml4LmludmVydCgpKSwgT2JqZWN0LmFzc2lnbih0aGlzLl9saW5lU3R5bGUsIHsgdmlzaWJsZSB9LCBvcHRpb25zKSkgOiB0aGlzLl9saW5lU3R5bGUucmVzZXQoKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBwb2x5Z29uIG9iamVjdCBpbnRlcm5hbGx5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzdGFydFBvbHkoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzLCBsZW4gPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGg7XG4gICAgICBsZW4gPiAyICYmICh0aGlzLmRyYXdTaGFwZSh0aGlzLmN1cnJlbnRQYXRoKSwgdGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQb2x5Z29uKCksIHRoaXMuY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSAhMSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMucHVzaChwb2ludHNbbGVuIC0gMl0sIHBvaW50c1tsZW4gLSAxXSkpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQb2x5Z29uKCksIHRoaXMuY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSAhMTtcbiAgfVxuICAvKipcbiAgICogRmluaXNoIHRoZSBwb2x5Z29uIG9iamVjdC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZmluaXNoUG9seSgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYXRoICYmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPiAyID8gKHRoaXMuZHJhd1NoYXBlKHRoaXMuY3VycmVudFBhdGgpLCB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbCkgOiB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPSAwKTtcbiAgfVxuICAvKipcbiAgICogTW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byB4LCB5LlxuICAgKiBAcGFyYW0geCAtIHRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICAgKiBAcGFyYW0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRQb2x5KCksIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzBdID0geCwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHNbMV0gPSB5LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGxpbmUgdXNpbmcgdGhlIGN1cnJlbnQgbGluZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpO1xuICAgKiBUaGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cbiAgICogQHBhcmFtIHggLSB0aGUgWCBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAgICogQHBhcmFtIHkgLSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuY3VycmVudFBhdGggfHwgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMsIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAoZnJvbVggIT09IHggfHwgZnJvbVkgIT09IHkpICYmIHBvaW50cy5wdXNoKHgsIHkpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBjdXJ2ZVxuICAgKiBAcGFyYW0geFxuICAgKiBAcGFyYW0geVxuICAgKi9cbiAgX2luaXRDdXJ2ZSh4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID8gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID09PSAwICYmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyA9IFt4LCB5XSkgOiB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAgICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICAgKiBAcGFyYW0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAqIEBwYXJhbSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICogQHBhcmFtIHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAgICogQHBhcmFtIHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoID09PSAwICYmIHRoaXMubW92ZVRvKDAsIDApLCBRdWFkcmF0aWNVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICAgKiBAcGFyYW0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAqIEBwYXJhbSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICogQHBhcmFtIGNwWDIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB4XG4gICAqIEBwYXJhbSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICAgKiBAcGFyYW0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgKiBAcGFyYW0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICAgKiBAcmV0dXJucyBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkge1xuICAgIHJldHVybiB0aGlzLl9pbml0Q3VydmUoKSwgQmV6aWVyVXRpbHMuY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHRoaXMuY3VycmVudFBhdGgucG9pbnRzKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIGBhcmNUb2AgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlIGJldHdlZW4gdHdvIHRhbmdlbnRzIG9uIHRoZSBjYW52YXMuXG4gICAqIFRoZSBmaXJzdCB0YW5nZW50IGlzIGZyb20gdGhlIHN0YXJ0IHBvaW50IHRvIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LFxuICAgKiBhbmQgdGhlIHNlY29uZCB0YW5nZW50IGlzIGZyb20gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgdG8gdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBOb3RlIHRoYXQgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgZW5kIHBvaW50IG9mIHRoZSBhcmMuXG4gICAqXG4gICAqIFwiYm9ycm93ZWRcIiBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZnhjYW52YXMvIC0gdGhhbmtzIGdvb2dsZSFcbiAgICogQHBhcmFtIHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBvZiB0aGUgYXJjXG4gICAqIEBwYXJhbSB5MSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvZiB0aGUgYXJjXG4gICAqIEBwYXJhbSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9mIHRoZSBhcmNcbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyY1xuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICB0aGlzLl9pbml0Q3VydmUoeDEsIHkxKTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cywgcmVzdWx0ID0gQXJjVXRpbHMuY3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzLCBwb2ludHMpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGNvbnN0IHsgY3gsIGN5LCByYWRpdXM6IHJhZGl1czIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlIH0gPSByZXN1bHQ7XG4gICAgICB0aGlzLmFyYyhjeCwgY3ksIHJhZGl1czIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhcmMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cbiAgICogQHBhcmFtIGN4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIGN5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgKiBAcGFyYW0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucyAoMCBpcyBhdCB0aGUgMyBvJ2Nsb2NrIHBvc2l0aW9uXG4gICAqICBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICAgKiBAcGFyYW0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zXG4gICAqIEBwYXJhbSBhbnRpY2xvY2t3aXNlIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlXG4gICAqICBjb3VudGVyLWNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlXG4gICAqICBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgYXJjKGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSA9ICExKSB7XG4gICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUgPyBlbmRBbmdsZSArPSBQSV8yIDogYW50aWNsb2Nrd2lzZSAmJiBzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlICYmIChzdGFydEFuZ2xlICs9IFBJXzIpLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPT09IDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzLCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzLCBlcHMgPSB0aGlzLl9nZW9tZXRyeS5jbG9zZVBvaW50RXBzO1xuICAgIGxldCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoID8gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMgOiBudWxsO1xuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIGNvbnN0IHhEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAtIHN0YXJ0WCksIHlEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAtIHN0YXJ0WSk7XG4gICAgICB4RGlmZiA8IGVwcyAmJiB5RGlmZiA8IGVwcyB8fCBwb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSksIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIHJldHVybiBBcmNVdGlscy5hcmMoc3RhcnRYLCBzdGFydFksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgcG9pbnRzKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIGEgc2ltcGxlIG9uZS1jb2xvciBmaWxsIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBvdGhlciBHcmFwaGljcyBtZXRob2RzXG4gICAqIChzdWNoIGFzIGxpbmVUbygpIG9yIGRyYXdDaXJjbGUoKSkgdXNlIHdoZW4gZHJhd2luZy5cbiAgICogQHBhcmFtIHtQSVhJLkNvbG9yU291cmNlfSBjb2xvciAtIHRoZSBjb2xvciBvZiB0aGUgZmlsbFxuICAgKiBAcGFyYW0gYWxwaGEgLSB0aGUgYWxwaGEgb2YgdGhlIGZpbGwsIHdpbGwgb3ZlcnJpZGUgdGhlIGNvbG9yJ3MgYWxwaGFcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gU3VpdGFibGUgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgYmVnaW5GaWxsKGNvbG9yID0gMCwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5iZWdpblRleHR1cmVGaWxsKHsgdGV4dHVyZTogVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhIH0pO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgdGhlIGNvbG9yIGlucHV0IGZyb20gb3B0aW9ucyBmb3IgbGluZSBzdHlsZSBvciBmaWxsXG4gICAqIEBwYXJhbSB7UElYSS5JRmlsbFN0eWxlT3B0aW9uc30gb3B0aW9ucyAtIEZpbGwgc3R5bGUgb2JqZWN0LlxuICAgKi9cbiAgbm9ybWFsaXplQ29sb3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHRlbXAgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUob3B0aW9ucy5jb2xvciA/PyAwKTtcbiAgICBvcHRpb25zLmNvbG9yID0gdGVtcC50b051bWJlcigpLCBvcHRpb25zLmFscGhhID8/IChvcHRpb25zLmFscGhhID0gdGVtcC5hbHBoYSk7XG4gIH1cbiAgLyoqXG4gICAqIEJlZ2luIHRoZSB0ZXh0dXJlIGZpbGwuXG4gICAqIE5vdGU6IFRoZSB3cmFwIG1vZGUgb2YgdGhlIHRleHR1cmUgaXMgZm9yY2VkIHRvIFJFUEVBVCBvbiByZW5kZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRmlsbCBzdHlsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbb3B0aW9ucy50ZXh0dXJlPVBJWEkuVGV4dHVyZS5XSElURV0gLSBUZXh0dXJlIHRvIGZpbGxcbiAgICogQHBhcmFtIHtQSVhJLkNvbG9yU291cmNlfSBbb3B0aW9ucy5jb2xvcj0weGZmZmZmZl0gLSBCYWNrZ3JvdW5kIHRvIGZpbGwgYmVoaW5kIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFscGhhXSAtIEFscGhhIG9mIGZpbGwsIG92ZXJyaWRlcyB0aGUgY29sb3IncyBhbHBoYVxuICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbb3B0aW9ucy5tYXRyaXg9bnVsbF0gLSBUcmFuc2Zvcm0gbWF0cml4XG4gICAqIEByZXR1cm5zIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBiZWdpblRleHR1cmVGaWxsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBtYXRyaXg6IG51bGxcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSwgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKSwgdGhpcy5jdXJyZW50UGF0aCAmJiB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIGNvbnN0IHZpc2libGUgPSBvcHRpb25zLmFscGhhID4gMDtcbiAgICByZXR1cm4gdmlzaWJsZSA/IChvcHRpb25zLm1hdHJpeCAmJiAob3B0aW9ucy5tYXRyaXggPSBvcHRpb25zLm1hdHJpeC5jbG9uZSgpLCBvcHRpb25zLm1hdHJpeC5pbnZlcnQoKSksIE9iamVjdC5hc3NpZ24odGhpcy5fZmlsbFN0eWxlLCB7IHZpc2libGUgfSwgb3B0aW9ucykpIDogdGhpcy5fZmlsbFN0eWxlLnJlc2V0KCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgZW5kRmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hQb2x5KCksIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IGEgcmVjdGFuZ2xlIHNoYXBlIHdpdGggcm91bmRlZC9iZXZlbGVkIGNvcm5lcnMuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSBjb3JuZXJzXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgZHJhd1JvdW5kZWRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgUm91bmRlZFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBjaXJjbGUuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgZHJhd0NpcmNsZSh4LCB5LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IENpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYW4gZWxsaXBzZS5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGRyYXdFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IEVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHBvbHlnb24gdXNpbmcgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSB7bnVtYmVyW118UElYSS5JUG9pbnREYXRhW118UElYSS5Qb2x5Z29ufSBwYXRoIC0gVGhlIHBhdGggZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBkcmF3UG9seWdvbiguLi5wYXRoKSB7XG4gICAgbGV0IHBvaW50cywgY2xvc2VTdHJva2UgPSAhMDtcbiAgICBjb25zdCBwb2x5ID0gcGF0aFswXTtcbiAgICBwb2x5LnBvaW50cyA/IChjbG9zZVN0cm9rZSA9IHBvbHkuY2xvc2VTdHJva2UsIHBvaW50cyA9IHBvbHkucG9pbnRzKSA6IEFycmF5LmlzQXJyYXkocGF0aFswXSkgPyBwb2ludHMgPSBwYXRoWzBdIDogcG9pbnRzID0gcGF0aDtcbiAgICBjb25zdCBzaGFwZSA9IG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgcmV0dXJuIHNoYXBlLmNsb3NlU3Ryb2tlID0gY2xvc2VTdHJva2UsIHRoaXMuZHJhd1NoYXBlKHNoYXBlKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhdyBhbnkgc2hhcGUuXG4gICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gU2hhcGUgdG8gZHJhd1xuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGRyYXdTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiB0aGlzLl9ob2xlTW9kZSA/IHRoaXMuX2dlb21ldHJ5LmRyYXdIb2xlKHNoYXBlLCB0aGlzLl9tYXRyaXgpIDogdGhpcy5fZ2VvbWV0cnkuZHJhd1NoYXBlKFxuICAgICAgc2hhcGUsXG4gICAgICB0aGlzLl9maWxsU3R5bGUuY2xvbmUoKSxcbiAgICAgIHRoaXMuX2xpbmVTdHlsZS5jbG9uZSgpLFxuICAgICAgdGhpcy5fbWF0cml4XG4gICAgKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBncmFwaGljcyB0aGF0IHdlcmUgZHJhd24gdG8gdGhpcyBHcmFwaGljcyBvYmplY3QsIGFuZCByZXNldHMgZmlsbCBhbmQgbGluZSBzdHlsZSBzZXR0aW5ncy5cbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkuY2xlYXIoKSwgdGhpcy5fbGluZVN0eWxlLnJlc2V0KCksIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLl9tYXRyaXggPSBudWxsLCB0aGlzLl9ob2xlTW9kZSA9ICExLCB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBncmFwaGljcyBjb25zaXN0cyBvZiBvbmUgcmVjdGFuZ2xlLCBhbmQgdGh1cywgY2FuIGJlIGRyYXduIGxpa2UgYSBTcHJpdGUgYW5kXG4gICAqIG1hc2tlZCB3aXRoIGdsLnNjaXNzb3IuXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBvbmx5IDEgcmVjdC5cbiAgICovXG4gIGlzRmFzdFJlY3QoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2dlb21ldHJ5LmdyYXBoaWNzRGF0YTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXS5zaGFwZS50eXBlID09PSBTSEFQRVMuUkVDVCAmJiAhZGF0YVswXS5tYXRyaXggJiYgIWRhdGFbMF0uaG9sZXMubGVuZ3RoICYmICEoZGF0YVswXS5saW5lU3R5bGUudmlzaWJsZSAmJiBkYXRhWzBdLmxpbmVTdHlsZS53aWR0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBnZW9tZXRyeS51cGRhdGVCYXRjaGVzKCksIGdlb21ldHJ5LmJhdGNoYWJsZSA/ICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkgJiYgdGhpcy5fcG9wdWxhdGVCYXRjaGVzKCksIHRoaXMuX3JlbmRlckJhdGNoZWQocmVuZGVyZXIpKSA6IChyZW5kZXJlci5iYXRjaC5mbHVzaCgpLCB0aGlzLl9yZW5kZXJEaXJlY3QocmVuZGVyZXIpKTtcbiAgfVxuICAvKiogUG9wdWxhdGluZyBiYXRjaGVzIGZvciByZW5kZXJpbmcuICovXG4gIF9wb3B1bGF0ZUJhdGNoZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeSwgYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGUsIGxlbiA9IGdlb21ldHJ5LmJhdGNoZXMubGVuZ3RoO1xuICAgIHRoaXMuYmF0Y2hUaW50ID0gLTEsIHRoaXMuX3RyYW5zZm9ybUlEID0gLTEsIHRoaXMuYmF0Y2hEaXJ0eSA9IGdlb21ldHJ5LmJhdGNoRGlydHksIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSBsZW4sIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkucG9pbnRzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBnSSA9IGdlb21ldHJ5LmJhdGNoZXNbaV0sIGNvbG9yID0gZ0kuc3R5bGUuY29sb3IsIHZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICB0aGlzLnZlcnRleERhdGEuYnVmZmVyLFxuICAgICAgICBnSS5hdHRyaWJTdGFydCAqIDQgKiAyLFxuICAgICAgICBnSS5hdHRyaWJTaXplICogMlxuICAgICAgKSwgdXZzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgZ2VvbWV0cnkudXZzRmxvYXQzMi5idWZmZXIsXG4gICAgICAgIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsXG4gICAgICAgIGdJLmF0dHJpYlNpemUgKiAyXG4gICAgICApLCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICBnZW9tZXRyeS5pbmRpY2VzVWludDE2LmJ1ZmZlcixcbiAgICAgICAgZ0kuc3RhcnQgKiAyLFxuICAgICAgICBnSS5zaXplXG4gICAgICApLCBiYXRjaCA9IHtcbiAgICAgICAgdmVydGV4RGF0YSxcbiAgICAgICAgYmxlbmRNb2RlLFxuICAgICAgICBpbmRpY2VzLFxuICAgICAgICB1dnMsXG4gICAgICAgIF9iYXRjaFJHQjogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b1JnYkFycmF5KCksXG4gICAgICAgIF90aW50UkdCOiBjb2xvcixcbiAgICAgICAgX3RleHR1cmU6IGdJLnN0eWxlLnRleHR1cmUsXG4gICAgICAgIGFscGhhOiBnSS5zdHlsZS5hbHBoYSxcbiAgICAgICAgd29ybGRBbHBoYTogMVxuICAgICAgfTtcbiAgICAgIHRoaXMuYmF0Y2hlc1tpXSA9IGJhdGNoO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmF0Y2hlcyB1c2luZyB0aGUgQmF0aGVkUmVuZGVyZXIgcGx1Z2luXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKi9cbiAgX3JlbmRlckJhdGNoZWQocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKSwgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpLCB0aGlzLmNhbGN1bGF0ZVRpbnRzKCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGEgKiBiYXRjaC5hbHBoYSwgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcihiYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBncmFwaGljcyBkaXJlY3RcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyRGlyZWN0KHJlbmRlcmVyKSB7XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fcmVzb2x2ZURpcmVjdFNoYWRlcihyZW5kZXJlciksIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnksIHdvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGEsIHVuaWZvcm1zID0gc2hhZGVyLnVuaWZvcm1zLCBkcmF3Q2FsbHMgPSBnZW9tZXRyeS5kcmF3Q2FsbHM7XG4gICAgdW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikucHJlbXVsdGlwbHkod29ybGRBbHBoYSkudG9BcnJheSh1bmlmb3Jtcy50aW50KSwgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKSwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgc2hhZGVyKSwgcmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZHJhd0NhbGxzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuX3JlbmRlckRyYXdDYWxsRGlyZWN0KHJlbmRlcmVyLCBnZW9tZXRyeS5kcmF3Q2FsbHNbaV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHNwZWNpZmljIERyYXdDYWxsXG4gICAqIEBwYXJhbSByZW5kZXJlclxuICAgKiBAcGFyYW0gZHJhd0NhbGxcbiAgICovXG4gIF9yZW5kZXJEcmF3Q2FsbERpcmVjdChyZW5kZXJlciwgZHJhd0NhbGwpIHtcbiAgICBjb25zdCB7IHRleEFycmF5LCB0eXBlLCBzaXplLCBzdGFydCB9ID0gZHJhd0NhbGwsIGdyb3VwVGV4dHVyZUNvdW50ID0gdGV4QXJyYXkuY291bnQ7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cFRleHR1cmVDb3VudDsgaisrKVxuICAgICAgcmVuZGVyZXIudGV4dHVyZS5iaW5kKHRleEFycmF5LmVsZW1lbnRzW2pdLCBqKTtcbiAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHR5cGUsIHNpemUsIHN0YXJ0KTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgc2hhZGVyIGZvciBkaXJlY3QgcmVuZGVyaW5nXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKi9cbiAgX3Jlc29sdmVEaXJlY3RTaGFkZXIocmVuZGVyZXIpIHtcbiAgICBsZXQgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgY29uc3QgcGx1Z2luTmFtZSA9IHRoaXMucGx1Z2luTmFtZTtcbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgaWYgKCFERUZBVUxUX1NIQURFUlNbcGx1Z2luTmFtZV0pIHtcbiAgICAgICAgY29uc3QgeyBtYXhUZXh0dXJlcyB9ID0gcmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSwgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkobWF4VGV4dHVyZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspXG4gICAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gaTtcbiAgICAgICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgdGludDogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLFxuICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4KCksXG4gICAgICAgICAgZGVmYXVsdDogVW5pZm9ybUdyb3VwLmZyb20oeyB1U2FtcGxlcnM6IHNhbXBsZVZhbHVlcyB9LCAhMClcbiAgICAgICAgfSwgcHJvZ3JhbSA9IHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0uX3NoYWRlci5wcm9ncmFtO1xuICAgICAgICBERUZBVUxUX1NIQURFUlNbcGx1Z2luTmFtZV0gPSBuZXcgU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcbiAgICAgIH1cbiAgICAgIHNoYWRlciA9IERFRkFVTFRfU0hBREVSU1twbHVnaW5OYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoaWMgc2hhcGUgYXMgYSByZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBAc2VlIFBJWEkuR3JhcGhpY3NHZW9tZXRyeSNib3VuZHNcbiAgICovXG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBpZiAoIWdlb21ldHJ5LmdyYXBoaWNzRGF0YS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIH0gPSBnZW9tZXRyeS5ib3VuZHM7XG4gICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBncmFwaGljcyBvYmplY3RcbiAgICogQHBhcmFtIHBvaW50IC0gdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHJldHVybnMgLSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCBfR3JhcGhpY3MyLl9URU1QX1BPSU5UKSwgdGhpcy5fZ2VvbWV0cnkuY29udGFpbnNQb2ludChfR3JhcGhpY3MyLl9URU1QX1BPSU5UKTtcbiAgfVxuICAvKiogUmVjYWxjdWxhdGUgdGhlIHRpbnQgYnkgYXBwbHlpbmcgdGludCB0byBiYXRjaGVzIHVzaW5nIEdyYXBoaWNzIHRpbnQuICovXG4gIGNhbGN1bGF0ZVRpbnRzKCkge1xuICAgIGlmICh0aGlzLmJhdGNoVGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICB0aGlzLmJhdGNoVGludCA9IHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLl90aW50UkdCID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikubXVsdGlwbHkoYmF0Y2guX2JhdGNoUkdCKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogSWYgdGhlcmUncyBhIHRyYW5zZm9ybSB1cGRhdGUgb3IgYSBjaGFuZ2UgdG8gdGhlIHNoYXBlIG9mIHRoZSBnZW9tZXRyeSwgcmVjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiAqL1xuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB3dElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB3dElEKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gd3RJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBhID0gd3QuYSwgYiA9IHd0LmIsIGMgPSB3dC5jLCBkID0gd3QuZCwgdHggPSB3dC50eCwgdHkgPSB3dC50eSwgZGF0YSA9IHRoaXMuX2dlb21ldHJ5LnBvaW50cywgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IGRhdGFbaV0sIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSBhICogeCArIGMgKiB5ICsgdHgsIHZlcnRleERhdGFbY291bnQrK10gPSBkICogeSArIGIgKiB4ICsgdHk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgcmV0dXJuIGN1cnJlbnRQYXRoICYmIChjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9ICEwLCB0aGlzLmZpbmlzaFBvbHkoKSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IGEgbWF0cml4IHRvIHRoZSBwb3NpdGlvbmFsIGRhdGEuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBNYXRyaXggdG8gdXNlIGZvciB0cmFuc2Zvcm0gY3VycmVudCBzaGFwZS5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIHNldE1hdHJpeChtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0cml4ID0gbWF0cml4LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBCZWdpbiBhZGRpbmcgaG9sZXMgdG8gdGhlIGxhc3QgZHJhdyBzaGFwZVxuICAgKiBJTVBPUlRBTlQ6IGhvbGVzIG11c3QgYmUgZnVsbHkgaW5zaWRlIGEgc2hhcGUgdG8gd29ya1xuICAgKiBBbHNvIHdlaXJkbmVzcyBlbnN1ZXMgaWYgaG9sZXMgb3ZlcmxhcCFcbiAgICogRWxsaXBzZXMsIENpcmNsZXMsIFJlY3RhbmdsZXMgYW5kIFJvdW5kZWQgUmVjdGFuZ2xlcyBjYW5ub3QgYmUgaG9sZXMgb3IgaG9zdCBmb3IgaG9sZXMgaW4gQ2FudmFzUmVuZGVyZXIsXG4gICAqIHBsZWFzZSB1c2UgYG1vdmVUb2AgYGxpbmVUb2AsIGBxdWFkcmF0aWNDdXJ2ZVRvYCBpZiB5b3UgcmVseSBvbiBwaXhpLWxlZ2FjeSBidW5kbGUuXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBiZWdpbkhvbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUG9seSgpLCB0aGlzLl9ob2xlTW9kZSA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgYWRkaW5nIGhvbGVzIHRvIHRoZSBsYXN0IGRyYXcgc2hhcGUuXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBlbmRIb2xlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFBvbHkoKSwgdGhpcy5faG9sZU1vZGUgPSAhMSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgKiAgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmVcbiAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxuICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHRoaXMuX2dlb21ldHJ5LnJlZkNvdW50LS0sIHRoaXMuX2dlb21ldHJ5LnJlZkNvdW50ID09PSAwICYmIHRoaXMuX2dlb21ldHJ5LmRpc3Bvc2UoKSwgdGhpcy5fbWF0cml4ID0gbnVsbCwgdGhpcy5jdXJyZW50UGF0aCA9IG51bGwsIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCksIHRoaXMuX2xpbmVTdHlsZSA9IG51bGwsIHRoaXMuX2ZpbGxTdHlsZS5kZXN0cm95KCksIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGwsIHRoaXMuX2dlb21ldHJ5ID0gbnVsbCwgdGhpcy5zaGFkZXIgPSBudWxsLCB0aGlzLnZlcnRleERhdGEgPSBudWxsLCB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMCwgdGhpcy5iYXRjaGVzID0gbnVsbCwgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbl9HcmFwaGljcy5jdXJ2ZXMgPSBjdXJ2ZXMsIC8qKlxuKiBUZW1wb3JhcnkgcG9pbnQgdG8gdXNlIGZvciBjb250YWluc1BvaW50LlxuKiBAcHJpdmF0ZVxuKi9cbl9HcmFwaGljcy5fVEVNUF9QT0lOVCA9IG5ldyBQb2ludCgpO1xubGV0IEdyYXBoaWNzID0gX0dyYXBoaWNzO1xuZXhwb3J0IHtcbiAgR3JhcGhpY3Ncbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5tanMubWFwXG4iLCJpbXBvcnQgeyBGSUxMX0NPTU1BTkRTLCBCQVRDSF9QT09MLCBEUkFXX0NBTExfUE9PTCB9IGZyb20gXCIuL3V0aWxzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgR1JBUEhJQ1NfQ1VSVkVTLCBMSU5FX0NBUCwgTElORV9KT0lOLCBjdXJ2ZXMgfSBmcm9tIFwiLi9jb25zdC5tanNcIjtcbmltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIi4vR3JhcGhpY3MubWpzXCI7XG5pbXBvcnQgeyBHcmFwaGljc0RhdGEgfSBmcm9tIFwiLi9HcmFwaGljc0RhdGEubWpzXCI7XG5pbXBvcnQgeyBHcmFwaGljc0dlb21ldHJ5IH0gZnJvbSBcIi4vR3JhcGhpY3NHZW9tZXRyeS5tanNcIjtcbmltcG9ydCB7IEZpbGxTdHlsZSB9IGZyb20gXCIuL3N0eWxlcy9GaWxsU3R5bGUubWpzXCI7XG5pbXBvcnQgeyBMaW5lU3R5bGUgfSBmcm9tIFwiLi9zdHlsZXMvTGluZVN0eWxlLm1qc1wiO1xuaW1wb3J0IHsgYnVpbGRQb2x5IH0gZnJvbSBcIi4vdXRpbHMvYnVpbGRQb2x5Lm1qc1wiO1xuaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tIFwiLi91dGlscy9idWlsZENpcmNsZS5tanNcIjtcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSBcIi4vdXRpbHMvYnVpbGRSZWN0YW5nbGUubWpzXCI7XG5pbXBvcnQgeyBidWlsZFJvdW5kZWRSZWN0YW5nbGUgfSBmcm9tIFwiLi91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzXCI7XG5pbXBvcnQgeyBidWlsZExpbmUgfSBmcm9tIFwiLi91dGlscy9idWlsZExpbmUubWpzXCI7XG5pbXBvcnQgeyBBcmNVdGlscyB9IGZyb20gXCIuL3V0aWxzL0FyY1V0aWxzLm1qc1wiO1xuaW1wb3J0IHsgQmV6aWVyVXRpbHMgfSBmcm9tIFwiLi91dGlscy9CZXppZXJVdGlscy5tanNcIjtcbmltcG9ydCB7IFF1YWRyYXRpY1V0aWxzIH0gZnJvbSBcIi4vdXRpbHMvUXVhZHJhdGljVXRpbHMubWpzXCI7XG5pbXBvcnQgeyBCYXRjaFBhcnQgfSBmcm9tIFwiLi91dGlscy9CYXRjaFBhcnQubWpzXCI7XG5jb25zdCBncmFwaGljc1V0aWxzID0ge1xuICBidWlsZFBvbHksXG4gIGJ1aWxkQ2lyY2xlLFxuICBidWlsZFJlY3RhbmdsZSxcbiAgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLFxuICBidWlsZExpbmUsXG4gIEFyY1V0aWxzLFxuICBCZXppZXJVdGlscyxcbiAgUXVhZHJhdGljVXRpbHMsXG4gIEJhdGNoUGFydCxcbiAgRklMTF9DT01NQU5EUyxcbiAgQkFUQ0hfUE9PTCxcbiAgRFJBV19DQUxMX1BPT0xcbn07XG5leHBvcnQge1xuICBGaWxsU3R5bGUsXG4gIEdSQVBISUNTX0NVUlZFUyxcbiAgR3JhcGhpY3MsXG4gIEdyYXBoaWNzRGF0YSxcbiAgR3JhcGhpY3NHZW9tZXRyeSxcbiAgTElORV9DQVAsXG4gIExJTkVfSk9JTixcbiAgTGluZVN0eWxlLFxuICBjdXJ2ZXMsXG4gIGdyYXBoaWNzVXRpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjbGFzcyBNZXNoQmF0Y2hVdnMge1xuICAvKipcbiAgICogQHBhcmFtIHV2QnVmZmVyIC0gQnVmZmVyIHdpdGggbm9ybWFsaXplZCB1didzXG4gICAqIEBwYXJhbSB1dk1hdHJpeCAtIE1hdGVyaWFsIFVWIG1hdHJpeFxuICAgKi9cbiAgY29uc3RydWN0b3IodXZCdWZmZXIsIHV2TWF0cml4KSB7XG4gICAgdGhpcy51dkJ1ZmZlciA9IHV2QnVmZmVyLCB0aGlzLnV2TWF0cml4ID0gdXZNYXRyaXgsIHRoaXMuZGF0YSA9IG51bGwsIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID0gLTEsIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IC0xLCB0aGlzLl91cGRhdGVJRCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXNcbiAgICogQHBhcmFtIGZvcmNlVXBkYXRlIC0gZm9yY2UgdGhlIHVwZGF0ZVxuICAgKi9cbiAgdXBkYXRlKGZvcmNlVXBkYXRlKSB7XG4gICAgaWYgKCFmb3JjZVVwZGF0ZSAmJiB0aGlzLl9idWZmZXJVcGRhdGVJZCA9PT0gdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQgJiYgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID09PSB0aGlzLnV2TWF0cml4Ll91cGRhdGVJRClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlELCB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPSB0aGlzLnV2TWF0cml4Ll91cGRhdGVJRDtcbiAgICBjb25zdCBkYXRhID0gdGhpcy51dkJ1ZmZlci5kYXRhO1xuICAgICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSAmJiAodGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmxlbmd0aCkpLCB0aGlzLnV2TWF0cml4Lm11bHRpcGx5VXZzKGRhdGEsIHRoaXMuZGF0YSksIHRoaXMuX3VwZGF0ZUlEKys7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIE1lc2hCYXRjaFV2c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hCYXRjaFV2cy5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCwgUG9seWdvbiwgU3RhdGUsIHNldHRpbmdzLCBEUkFXX01PREVTIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCJAcGl4aS9kaXNwbGF5XCI7XG5pbXBvcnQgeyBNZXNoQmF0Y2hVdnMgfSBmcm9tIFwiLi9NZXNoQmF0Y2hVdnMubWpzXCI7XG5jb25zdCB0ZW1wUG9pbnQgPSBuZXcgUG9pbnQoKSwgdGVtcFBvbHlnb24gPSBuZXcgUG9seWdvbigpLCBfTWVzaCA9IGNsYXNzIF9NZXNoMiBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZ2VvbWV0cnkgLSBUaGUgZ2VvbWV0cnkgdGhlIG1lc2ggd2lsbCB1c2UuXG4gICAqIEBwYXJhbSB7UElYSS5NZXNoTWF0ZXJpYWx9IHNoYWRlciAtIFRoZSBzaGFkZXIgdGhlIG1lc2ggd2lsbCB1c2UuXG4gICAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBzdGF0ZSB0aGF0IHRoZSBXZWJHTCBjb250ZXh0IGlzIHJlcXVpcmVkIHRvIGJlIGluIHRvIHJlbmRlciB0aGUgbWVzaFxuICAgKiAgICAgICAgaWYgbm8gc3RhdGUgaXMgcHJvdmlkZWQsIHVzZXMge0BsaW5rIFBJWEkuU3RhdGUuZm9yMmR9IHRvIGNyZWF0ZSBhIDJEIHN0YXRlIGZvciBQaXhpSlMuXG4gICAqIEBwYXJhbSBkcmF3TW9kZSAtIFRoZSBkcmF3TW9kZSwgY2FuIGJlIGFueSBvZiB0aGUge0BsaW5rIFBJWEkuRFJBV19NT0RFU30gY29uc3RhbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2VvbWV0cnksIHNoYWRlciwgc3RhdGUsIGRyYXdNb2RlID0gRFJBV19NT0RFUy5UUklBTkdMRVMpIHtcbiAgICBzdXBlcigpLCB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnksIHRoaXMuc2hhZGVyID0gc2hhZGVyLCB0aGlzLnN0YXRlID0gc3RhdGUgfHwgU3RhdGUuZm9yMmQoKSwgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlLCB0aGlzLnN0YXJ0ID0gMCwgdGhpcy5zaXplID0gMCwgdGhpcy51dnMgPSBudWxsLCB0aGlzLmluZGljZXMgPSBudWxsLCB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDEpLCB0aGlzLnZlcnRleERpcnR5ID0gLTEsIHRoaXMuX3RyYW5zZm9ybUlEID0gLTEsIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTLCB0aGlzLmJhdGNoVXZzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogSW5jbHVkZXMgdmVydGV4IHBvc2l0aW9ucywgZmFjZSBpbmRpY2VzLCBub3JtYWxzLCBjb2xvcnMsIFVWcywgYW5kXG4gICAqIGN1c3RvbSBhdHRyaWJ1dGVzIHdpdGhpbiBidWZmZXJzLCByZWR1Y2luZyB0aGUgY29zdCBvZiBwYXNzaW5nIGFsbFxuICAgKiB0aGlzIGRhdGEgdG8gdGhlIEdQVS4gQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIE1lc2ggb2JqZWN0cy5cbiAgICovXG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gIH1cbiAgc2V0IGdlb21ldHJ5KHZhbHVlKSB7XG4gICAgdGhpcy5fZ2VvbWV0cnkgIT09IHZhbHVlICYmICh0aGlzLl9nZW9tZXRyeSAmJiAodGhpcy5fZ2VvbWV0cnkucmVmQ291bnQtLSwgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQgPT09IDAgJiYgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpKSwgdGhpcy5fZ2VvbWV0cnkgPSB2YWx1ZSwgdGhpcy5fZ2VvbWV0cnkgJiYgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQrKywgdGhpcy52ZXJ0ZXhEaXJ0eSA9IC0xKTtcbiAgfVxuICAvKipcbiAgICogVG8gY2hhbmdlIG1lc2ggdXYncywgY2hhbmdlIGl0cyB1dkJ1ZmZlciBkYXRhIGFuZCBpbmNyZW1lbnQgaXRzIF91cGRhdGVJRC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdXZCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXTtcbiAgfVxuICAvKipcbiAgICogVG8gY2hhbmdlIG1lc2ggdmVydGljZXMsIGNoYW5nZSBpdHMgdXZCdWZmZXIgZGF0YSBhbmQgaW5jcmVtZW50IGl0cyBfdXBkYXRlSUQuXG4gICAqIEluY3JlbWVudGluZyBfdXBkYXRlSUQgaXMgb3B0aW9uYWwgYmVjYXVzZSBtb3N0IG9mIE1lc2ggb2JqZWN0cyBkbyBpdCBhbnl3YXkuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZlcnRpY2VzQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF07XG4gIH1cbiAgLyoqIEFsaWFzIGZvciB7QGxpbmsgUElYSS5NZXNoI3NoYWRlcn0uICovXG4gIHNldCBtYXRlcmlhbCh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlcjtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgTWVzaC4gQXBwbHkgYSB2YWx1ZSBvZlxuICAgKiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICovXG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgKiBBZHZhbnRhZ2VzIGNhbiBpbmNsdWRlIHNoYXJwZXIgaW1hZ2UgcXVhbGl0eSAobGlrZSB0ZXh0KSBhbmQgZmFzdGVyIHJlbmRlcmluZyBvbiBjYW52YXMuXG4gICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAqIFRvIHNldCB0aGUgZ2xvYmFsIGRlZmF1bHQsIGNoYW5nZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5ST1VORF9QSVhFTFN9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyAhPT0gdmFsdWUgJiYgKHRoaXMuX3RyYW5zZm9ybUlEID0gLTEpLCB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICB9XG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtdWx0aXBseSB0aW50IGFwcGxpZWQgdG8gdGhlIE1lc2guIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2ZcbiAgICogYDB4RkZGRkZGYCB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqXG4gICAqIE51bGwgZm9yIG5vbi1NZXNoTWF0ZXJpYWwgc2hhZGVyc1xuICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgKi9cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIFwidGludFwiIGluIHRoaXMuc2hhZGVyID8gdGhpcy5zaGFkZXIudGludCA6IG51bGw7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLnNoYWRlci50aW50ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IGNvbG9yIGFzIGEgUkdCIGludGVnZXJcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZ2V0IHRpbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIudGludFZhbHVlO1xuICB9XG4gIC8qKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBNZXNoIHVzZXMuIE51bGwgZm9yIG5vbi1NZXNoTWF0ZXJpYWwgc2hhZGVycyAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gXCJ0ZXh0dXJlXCIgaW4gdGhpcy5zaGFkZXIgPyB0aGlzLnNoYWRlci50ZXh0dXJlIDogbnVsbDtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU3RhbmRhcmQgcmVuZGVyZXIgZHJhdy5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXG4gICAqL1xuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0uZGF0YTtcbiAgICB0aGlzLnNoYWRlci5iYXRjaGFibGUgJiYgdGhpcy5kcmF3TW9kZSA9PT0gRFJBV19NT0RFUy5UUklBTkdMRVMgJiYgdmVydGljZXMubGVuZ3RoIDwgX01lc2gyLkJBVENIQUJMRV9TSVpFICogMiA/IHRoaXMuX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpIDogdGhpcy5fcmVuZGVyRGVmYXVsdChyZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIFN0YW5kYXJkIG5vbi1iYXRjaGluZyB3YXkgb2YgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBJbnN0YW5jZSB0byByZW5kZXJlci5cbiAgICovXG4gIF9yZW5kZXJEZWZhdWx0KHJlbmRlcmVyKSB7XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgc2hhZGVyLmFscGhhID0gdGhpcy53b3JsZEFscGhhLCBzaGFkZXIudXBkYXRlICYmIHNoYWRlci51cGRhdGUoKSwgcmVuZGVyZXIuYmF0Y2guZmx1c2goKSwgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0udG9BcnJheSghMCksIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlciksIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKSwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLmdlb21ldHJ5LCBzaGFkZXIpLCByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHRoaXMuZHJhd01vZGUsIHRoaXMuc2l6ZSwgdGhpcy5zdGFydCwgdGhpcy5nZW9tZXRyeS5pbnN0YW5jZUNvdW50KTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyaW5nIGJ5IHVzaW5nIHRoZSBCYXRjaCBzeXN0ZW0uXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIEluc3RhbmNlIHRvIHJlbmRlcmVyLlxuICAgKi9cbiAgX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnksIHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIHNoYWRlci51dk1hdHJpeCAmJiAoc2hhZGVyLnV2TWF0cml4LnVwZGF0ZSgpLCB0aGlzLmNhbGN1bGF0ZVV2cygpKSwgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpLCB0aGlzLmluZGljZXMgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLCB0aGlzLl90aW50UkdCID0gc2hhZGVyLl90aW50UkdCLCB0aGlzLl90ZXh0dXJlID0gc2hhZGVyLnRleHR1cmU7XG4gICAgY29uc3QgcGx1Z2luTmFtZSA9IHRoaXMubWF0ZXJpYWwucGx1Z2luTmFtZTtcbiAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3BsdWdpbk5hbWVdKSwgcmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdmVydGV4RGF0YSBmaWVsZCBiYXNlZCBvbiB0cmFuc2Zvcm0gYW5kIHZlcnRpY2VzLiAqL1xuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXSwgdmVydGljZXMgPSB2ZXJ0aWNlc0J1ZmZlci5kYXRhLCB2ZXJ0ZXhEaXJ0eUlkID0gdmVydGljZXNCdWZmZXIuX3VwZGF0ZUlEO1xuICAgIGlmICh2ZXJ0ZXhEaXJ0eUlkID09PSB0aGlzLnZlcnRleERpcnR5ICYmIHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElELCB0aGlzLnZlcnRleERhdGEubGVuZ3RoICE9PSB2ZXJ0aWNlcy5sZW5ndGggJiYgKHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMubGVuZ3RoKSk7XG4gICAgY29uc3Qgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgYSA9IHd0LmEsIGIgPSB3dC5iLCBjID0gd3QuYywgZCA9IHd0LmQsIHR4ID0gd3QudHgsIHR5ID0gd3QudHksIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29uc3QgeCA9IHZlcnRpY2VzW2kgKiAyXSwgeSA9IHZlcnRpY2VzW2kgKiAyICsgMV07XG4gICAgICB2ZXJ0ZXhEYXRhW2kgKiAyXSA9IGEgKiB4ICsgYyAqIHkgKyB0eCwgdmVydGV4RGF0YVtpICogMiArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgIH1cbiAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICB2ZXJ0ZXhEYXRhW2ldID0gTWF0aC5yb3VuZCh2ZXJ0ZXhEYXRhW2ldICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIH1cbiAgICB0aGlzLnZlcnRleERpcnR5ID0gdmVydGV4RGlydHlJZDtcbiAgfVxuICAvKiogVXBkYXRlcyB1diBmaWVsZCBiYXNlZCBvbiBmcm9tIGdlb21ldHJ5IHV2J3Mgb3IgYmF0Y2hVdnMuICovXG4gIGNhbGN1bGF0ZVV2cygpIHtcbiAgICBjb25zdCBnZW9tVXZzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdLCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICBzaGFkZXIudXZNYXRyaXguaXNTaW1wbGUgPyB0aGlzLnV2cyA9IGdlb21VdnMuZGF0YSA6ICh0aGlzLmJhdGNoVXZzIHx8ICh0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2cyhnZW9tVXZzLCBzaGFkZXIudXZNYXRyaXgpKSwgdGhpcy5iYXRjaFV2cy51cGRhdGUoKSwgdGhpcy51dnMgPSB0aGlzLmJhdGNoVXZzLmRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIG1lc2ggYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAgICogdGhlcmUgbXVzdCBiZSBhIGFWZXJ0ZXhQb3NpdGlvbiBhdHRyaWJ1dGUgcHJlc2VudCBpbiB0aGUgZ2VvbWV0cnkgZm9yIGJvdW5kcyB0byBiZSBjYWxjdWxhdGVkIGNvcnJlY3RseS5cbiAgICovXG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpLCB0aGlzLl9ib3VuZHMuYWRkVmVydGV4RGF0YSh0aGlzLnZlcnRleERhdGEsIDAsIHRoaXMudmVydGV4RGF0YS5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIG1lc2guIFdvcmtzIG9ubHkgZm9yIFBJWEkuRFJBV19NT0RFUy5UUklBTkdMRVMuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFRoZSByZXN1bHQgb2YgdGhlIHRlc3QuXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgaWYgKCF0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0ZW1wUG9pbnQpO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YSwgcG9pbnRzID0gdGVtcFBvbHlnb24ucG9pbnRzLCBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRJbmRleCgpLmRhdGEsIGxlbiA9IGluZGljZXMubGVuZ3RoLCBzdGVwID0gdGhpcy5kcmF3TW9kZSA9PT0gNCA/IDMgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICsgMiA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBpbmQwID0gaW5kaWNlc1tpXSAqIDIsIGluZDEgPSBpbmRpY2VzW2kgKyAxXSAqIDIsIGluZDIgPSBpbmRpY2VzW2kgKyAyXSAqIDI7XG4gICAgICBpZiAocG9pbnRzWzBdID0gdmVydGljZXNbaW5kMF0sIHBvaW50c1sxXSA9IHZlcnRpY2VzW2luZDAgKyAxXSwgcG9pbnRzWzJdID0gdmVydGljZXNbaW5kMV0sIHBvaW50c1szXSA9IHZlcnRpY2VzW2luZDEgKyAxXSwgcG9pbnRzWzRdID0gdmVydGljZXNbaW5kMl0sIHBvaW50c1s1XSA9IHZlcnRpY2VzW2luZDIgKyAxXSwgdGVtcFBvbHlnb24uY29udGFpbnModGVtcFBvaW50LngsIHRlbXBQb2ludC55KSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy5fY2FjaGVkVGV4dHVyZSAmJiAodGhpcy5fY2FjaGVkVGV4dHVyZS5kZXN0cm95KCksIHRoaXMuX2NhY2hlZFRleHR1cmUgPSBudWxsKSwgdGhpcy5nZW9tZXRyeSA9IG51bGwsIHRoaXMuc2hhZGVyID0gbnVsbCwgdGhpcy5zdGF0ZSA9IG51bGwsIHRoaXMudXZzID0gbnVsbCwgdGhpcy5pbmRpY2VzID0gbnVsbCwgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgfVxufTtcbl9NZXNoLkJBVENIQUJMRV9TSVpFID0gMTAwO1xubGV0IE1lc2ggPSBfTWVzaDtcbmV4cG9ydCB7XG4gIE1lc2hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoLm1qcy5tYXBcbiIsImltcG9ydCB7IEdlb21ldHJ5LCBCdWZmZXIsIFRZUEVTIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fG51bWJlcltdfSBbdmVydGljZXNdIC0gUG9zaXRpb25hbCBkYXRhIG9uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxudW1iZXJbXX0gW3V2c10gLSBUZXh0dXJlIFVWcy5cbiAgICogQHBhcmFtIHtVaW50MTZBcnJheXxudW1iZXJbXX0gW2luZGV4XSAtIEluZGV4QnVmZmVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgdXZzLCBpbmRleCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdmVydGljZXNCdWZmZXIgPSBuZXcgQnVmZmVyKHZlcnRpY2VzKSwgdXZzQnVmZmVyID0gbmV3IEJ1ZmZlcih1dnMsICEwKSwgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKGluZGV4LCAhMCwgITApO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIHZlcnRpY2VzQnVmZmVyLCAyLCAhMSwgVFlQRVMuRkxPQVQpLmFkZEF0dHJpYnV0ZShcImFUZXh0dXJlQ29vcmRcIiwgdXZzQnVmZmVyLCAyLCAhMSwgVFlQRVMuRkxPQVQpLmFkZEluZGV4KGluZGV4QnVmZmVyKSwgdGhpcy5fdXBkYXRlSWQgPSAtMTtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIHZlcnRleCBwb3NpdGlvbiBpcyB1cGRhdGVkLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCB2ZXJ0ZXhEaXJ0eUlkKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbMF0uX3VwZGF0ZUlEO1xuICB9XG59XG5leHBvcnQge1xuICBNZXNoR2VvbWV0cnlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoR2VvbWV0cnkubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xudW5pZm9ybSB2ZWM0IHVDb2xvcjtcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3I7XG59XG5gO1xuZXhwb3J0IHtcbiAgZnJhZ21lbnQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2guZnJhZy5tanMubWFwXG4iLCJ2YXIgdmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHVUZXh0dXJlTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcblxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRleHR1cmVNYXRyaXggKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xufVxuYDtcbmV4cG9ydCB7XG4gIHZlcnRleCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaC52ZXJ0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNoYWRlciwgTWF0cml4LCBQcm9ncmFtLCBUZXh0dXJlTWF0cml4LCBDb2xvciB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSBcIi4vc2hhZGVyL21lc2guZnJhZy5tanNcIjtcbmltcG9ydCB2ZXJ0ZXggZnJvbSBcIi4vc2hhZGVyL21lc2gudmVydC5tanNcIjtcbmNsYXNzIE1lc2hNYXRlcmlhbCBleHRlbmRzIFNoYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdVNhbXBsZXIgLSBUZXh0dXJlIHRoYXQgbWF0ZXJpYWwgdXNlcyB0byByZW5kZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbHBoYT0xXSAtIERlZmF1bHQgYWxwaGEuXG4gICAqIEBwYXJhbSB7UElYSS5Db2xvclNvdXJjZX0gW29wdGlvbnMudGludD0weEZGRkZGRl0gLSBEZWZhdWx0IHRpbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wbHVnaW5OYW1lPSdiYXRjaCddIC0gUmVuZGVyZXIgcGx1Z2luIGZvciBiYXRjaGluZy5cbiAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IFtvcHRpb25zLnByb2dyYW09MHhGRkZGRkZdIC0gQ3VzdG9tIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy51bmlmb3Jtc10gLSBDdXN0b20gdW5pZm9ybXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1U2FtcGxlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgdVNhbXBsZXIsXG4gICAgICBhbHBoYTogMSxcbiAgICAgIHVUZXh0dXJlTWF0cml4OiBNYXRyaXguSURFTlRJVFksXG4gICAgICB1Q29sb3I6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKVxuICAgIH07XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGludDogMTY3NzcyMTUsXG4gICAgICBhbHBoYTogMSxcbiAgICAgIHBsdWdpbk5hbWU6IFwiYmF0Y2hcIlxuICAgIH0sIG9wdGlvbnMpLCBvcHRpb25zLnVuaWZvcm1zICYmIE9iamVjdC5hc3NpZ24odW5pZm9ybXMsIG9wdGlvbnMudW5pZm9ybXMpLCBzdXBlcihvcHRpb25zLnByb2dyYW0gfHwgUHJvZ3JhbS5mcm9tKHZlcnRleCwgZnJhZ21lbnQpLCB1bmlmb3JtcyksIHRoaXMuX2NvbG9yRGlydHkgPSAhMSwgdGhpcy51dk1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4KHVTYW1wbGVyKSwgdGhpcy5iYXRjaGFibGUgPSBvcHRpb25zLnByb2dyYW0gPT09IHZvaWQgMCwgdGhpcy5wbHVnaW5OYW1lID0gb3B0aW9ucy5wbHVnaW5OYW1lLCB0aGlzLl90aW50Q29sb3IgPSBuZXcgQ29sb3Iob3B0aW9ucy50aW50KSwgdGhpcy5fdGludFJHQiA9IHRoaXMuX3RpbnRDb2xvci50b0xpdHRsZUVuZGlhbk51bWJlcigpLCB0aGlzLl9jb2xvckRpcnR5ID0gITAsIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuICB9XG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRleHR1cmUgYmVpbmcgcmVuZGVyZWQuICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2FtcGxlciAhPT0gdmFsdWUgJiYgKCF0aGlzLnVuaWZvcm1zLnVTYW1wbGVyLmJhc2VUZXh0dXJlLmFscGhhTW9kZSAhPSAhdmFsdWUuYmFzZVRleHR1cmUuYWxwaGFNb2RlICYmICh0aGlzLl9jb2xvckRpcnR5ID0gITApLCB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gdmFsdWUsIHRoaXMudXZNYXRyaXgudGV4dHVyZSA9IHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBnZXRzIGF1dG9tYXRpY2FsbHkgc2V0IGJ5IHRoZSBvYmplY3QgdXNpbmcgdGhpcy5cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdmFsdWUgIT09IHRoaXMuX2FscGhhICYmICh0aGlzLl9hbHBoYSA9IHZhbHVlLCB0aGlzLl9jb2xvckRpcnR5ID0gITApO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxwaGE7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRpbnQgZm9yIHRoZSBtYXRlcmlhbC5cbiAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICovXG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgdmFsdWUgIT09IHRoaXMudGludCAmJiAodGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKSwgdGhpcy5fdGludFJHQiA9IHRoaXMuX3RpbnRDb2xvci50b0xpdHRsZUVuZGlhbk51bWJlcigpLCB0aGlzLl9jb2xvckRpcnR5ID0gITApO1xuICB9XG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJuYWwgbnVtYmVyIGZyb20gdGludCBjb2xvclxuICAgKiBAaWdub3JlXG4gICAqL1xuICBnZXQgdGludFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudG9OdW1iZXIoKTtcbiAgfVxuICAvKiogR2V0cyBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgTWVzaC4gSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBmb3IgY3VzdG9tIHtAbGluayBQSVhJLk1lc2hNYXRlcmlhbH0gb2JqZWN0cy4gKi9cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jb2xvckRpcnR5KSB7XG4gICAgICB0aGlzLl9jb2xvckRpcnR5ID0gITE7XG4gICAgICBjb25zdCBhcHBseVRvQ2hhbm5lbHMgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlO1xuICAgICAgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikucHJlbXVsdGlwbHkodGhpcy5fYWxwaGEsIGFwcGx5VG9DaGFubmVscykudG9BcnJheSh0aGlzLnVuaWZvcm1zLnVDb2xvcik7XG4gICAgfVxuICAgIHRoaXMudXZNYXRyaXgudXBkYXRlKCkgJiYgKHRoaXMudW5pZm9ybXMudVRleHR1cmVNYXRyaXggPSB0aGlzLnV2TWF0cml4Lm1hcENvb3JkKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTWVzaE1hdGVyaWFsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaE1hdGVyaWFsLm1qcy5tYXBcbiIsImltcG9ydCB7IE1lc2ggfSBmcm9tIFwiLi9NZXNoLm1qc1wiO1xuaW1wb3J0IHsgTWVzaEJhdGNoVXZzIH0gZnJvbSBcIi4vTWVzaEJhdGNoVXZzLm1qc1wiO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSBcIi4vTWVzaEdlb21ldHJ5Lm1qc1wiO1xuaW1wb3J0IHsgTWVzaE1hdGVyaWFsIH0gZnJvbSBcIi4vTWVzaE1hdGVyaWFsLm1qc1wiO1xuZXhwb3J0IHtcbiAgTWVzaCxcbiAgTWVzaEJhdGNoVXZzLFxuICBNZXNoR2VvbWV0cnksXG4gIE1lc2hNYXRlcmlhbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1lc2hHZW9tZXRyeSB9IGZyb20gXCJAcGl4aS9tZXNoXCI7XG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgTWVzaEdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgcGxhbmUuXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBwbGFuZS5cbiAgICogQHBhcmFtIHNlZ1dpZHRoIC0gTnVtYmVyIG9mIGhvcml6b250YWwgc2VnbWVudHMuXG4gICAqIEBwYXJhbSBzZWdIZWlnaHQgLSBOdW1iZXIgb2YgdmVydGljYWwgc2VnbWVudHMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDEwMCwgaGVpZ2h0ID0gMTAwLCBzZWdXaWR0aCA9IDEwLCBzZWdIZWlnaHQgPSAxMCkge1xuICAgIHN1cGVyKCksIHRoaXMuc2VnV2lkdGggPSBzZWdXaWR0aCwgdGhpcy5zZWdIZWlnaHQgPSBzZWdIZWlnaHQsIHRoaXMud2lkdGggPSB3aWR0aCwgdGhpcy5oZWlnaHQgPSBoZWlnaHQsIHRoaXMuYnVpbGQoKTtcbiAgfVxuICAvKipcbiAgICogUmVmcmVzaGVzIHBsYW5lIGNvb3JkaW5hdGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBidWlsZCgpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2VnV2lkdGggKiB0aGlzLnNlZ0hlaWdodCwgdmVydHMgPSBbXSwgdXZzID0gW10sIGluZGljZXMgPSBbXSwgc2VnbWVudHNYID0gdGhpcy5zZWdXaWR0aCAtIDEsIHNlZ21lbnRzWSA9IHRoaXMuc2VnSGVpZ2h0IC0gMSwgc2l6ZVggPSB0aGlzLndpZHRoIC8gc2VnbWVudHNYLCBzaXplWSA9IHRoaXMuaGVpZ2h0IC8gc2VnbWVudHNZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgJSB0aGlzLnNlZ1dpZHRoLCB5ID0gaSAvIHRoaXMuc2VnV2lkdGggfCAwO1xuICAgICAgdmVydHMucHVzaCh4ICogc2l6ZVgsIHkgKiBzaXplWSksIHV2cy5wdXNoKHggLyBzZWdtZW50c1gsIHkgLyBzZWdtZW50c1kpO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbFN1YiA9IHNlZ21lbnRzWCAqIHNlZ21lbnRzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsU3ViOyBpKyspIHtcbiAgICAgIGNvbnN0IHhwb3MgPSBpICUgc2VnbWVudHNYLCB5cG9zID0gaSAvIHNlZ21lbnRzWCB8IDAsIHZhbHVlID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zLCB2YWx1ZTIgPSB5cG9zICogdGhpcy5zZWdXaWR0aCArIHhwb3MgKyAxLCB2YWx1ZTMgPSAoeXBvcyArIDEpICogdGhpcy5zZWdXaWR0aCArIHhwb3MsIHZhbHVlNCA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcyArIDE7XG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZTIsXG4gICAgICAgIHZhbHVlMyxcbiAgICAgICAgdmFsdWUyLFxuICAgICAgICB2YWx1ZTQsXG4gICAgICAgIHZhbHVlM1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKSwgdGhpcy5idWZmZXJzWzFdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyksIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzKSwgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpLCB0aGlzLmJ1ZmZlcnNbMV0udXBkYXRlKCksIHRoaXMuaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFBsYW5lR2VvbWV0cnlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGFuZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1lc2hHZW9tZXRyeSB9IGZyb20gXCJAcGl4aS9tZXNoXCI7XG5jbGFzcyBSb3BlR2VvbWV0cnkgZXh0ZW5kcyBNZXNoR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIChpLmUuLCB0aGlja25lc3MpIG9mIHRoZSByb3BlLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2Yge0BsaW5rIFBJWEkuUG9pbnR9IG9iamVjdHMgdG8gY29uc3RydWN0IHRoaXMgcm9wZS5cbiAgICogQHBhcmFtIHRleHR1cmVTY2FsZSAtIEJ5IGRlZmF1bHQgdGhlIHJvcGUgdGV4dHVyZSB3aWxsIGJlIHN0cmV0Y2hlZCB0byBtYXRjaFxuICAgKiAgICAgcm9wZSBsZW5ndGguIElmIHRleHR1cmVTY2FsZSBpcyBwb3NpdGl2ZSB0aGlzIHZhbHVlIHdpbGwgYmUgdHJlYXRlZCBhcyBhIHNjYWxpbmdcbiAgICogICAgIGZhY3RvciBhbmQgdGhlIHRleHR1cmUgd2lsbCBwcmVzZXJ2ZSBpdHMgYXNwZWN0IHJhdGlvIGluc3RlYWQuIFRvIGNyZWF0ZSBhIHRpbGluZyByb3BlXG4gICAqICAgICBzZXQgYmFzZVRleHR1cmUud3JhcE1vZGUgdG8ge0BsaW5rIFBJWEkuV1JBUF9NT0RFUy5SRVBFQVR9IGFuZCB1c2UgYSBwb3dlciBvZiB0d28gdGV4dHVyZSxcbiAgICogICAgIHRoZW4gc2V0IHRleHR1cmVTY2FsZT0xIHRvIGtlZXAgdGhlIG9yaWdpbmFsIHRleHR1cmUgcGl4ZWwgc2l6ZS5cbiAgICogICAgIEluIG9yZGVyIHRvIHJlZHVjZSBhbHBoYSBjaGFubmVsIGFydGlmYWN0cyBwcm92aWRlIGEgbGFyZ2VyIHRleHR1cmUgYW5kIGRvd25zYW1wbGUgLVxuICAgKiAgICAgaS5lLiBzZXQgdGV4dHVyZVNjYWxlPTAuNSB0byBzY2FsZSBpdCBkb3duIHR3aWNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iod2lkdGggPSAyMDAsIHBvaW50cywgdGV4dHVyZVNjYWxlID0gMCkge1xuICAgIHN1cGVyKFxuICAgICAgbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSxcbiAgICAgIG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNilcbiAgICApLCB0aGlzLnBvaW50cyA9IHBvaW50cywgdGhpcy5fd2lkdGggPSB3aWR0aCwgdGhpcy50ZXh0dXJlU2NhbGUgPSB0ZXh0dXJlU2NhbGUsIHRoaXMuYnVpbGQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdpZHRoIChpLmUuLCB0aGlja25lc3MpIG9mIHRoZSByb3BlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgLyoqIFJlZnJlc2hlcyBSb3BlIGluZGljZXMgYW5kIHV2cyAqL1xuICBidWlsZCgpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBpZiAoIXBvaW50cylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKSwgdXZCdWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihcImFUZXh0dXJlQ29vcmRcIiksIGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybjtcbiAgICB2ZXJ0ZXhCdWZmZXIuZGF0YS5sZW5ndGggLyA0ICE9PSBwb2ludHMubGVuZ3RoICYmICh2ZXJ0ZXhCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLCB1dkJ1ZmZlci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIGluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpKTtcbiAgICBjb25zdCB1dnMgPSB1dkJ1ZmZlci5kYXRhLCBpbmRpY2VzID0gaW5kZXhCdWZmZXIuZGF0YTtcbiAgICB1dnNbMF0gPSAwLCB1dnNbMV0gPSAwLCB1dnNbMl0gPSAwLCB1dnNbM10gPSAxO1xuICAgIGxldCBhbW91bnQgPSAwLCBwcmV2ID0gcG9pbnRzWzBdO1xuICAgIGNvbnN0IHRleHR1cmVXaWR0aCA9IHRoaXMuX3dpZHRoICogdGhpcy50ZXh0dXJlU2NhbGUsIHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlU2NhbGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcHJldi54IC0gcG9pbnRzW2ldLngsIGR5ID0gcHJldi55IC0gcG9pbnRzW2ldLnksIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgcHJldiA9IHBvaW50c1tpXSwgYW1vdW50ICs9IGRpc3RhbmNlIC8gdGV4dHVyZVdpZHRoO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGFtb3VudCA9IGkgLyAodG90YWwgLSAxKTtcbiAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQsIHV2c1tpbmRleCArIDFdID0gMCwgdXZzW2luZGV4ICsgMl0gPSBhbW91bnQsIHV2c1tpbmRleCArIDNdID0gMTtcbiAgICB9XG4gICAgbGV0IGluZGV4Q291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWwgLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDI7XG4gICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCwgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxLCBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCArIDIsIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMiwgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxLCBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCArIDM7XG4gICAgfVxuICAgIHV2QnVmZmVyLnVwZGF0ZSgpLCBpbmRleEJ1ZmZlci51cGRhdGUoKSwgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICB9XG4gIC8qKiByZWZyZXNoZXMgdmVydGljZXMgb2YgUm9wZSBtZXNoICovXG4gIHVwZGF0ZVZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbGFzdFBvaW50ID0gcG9pbnRzWzBdLCBuZXh0UG9pbnQsIHBlcnBYID0gMCwgcGVycFkgPSAwO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5idWZmZXJzWzBdLmRhdGEsIHRvdGFsID0gcG9pbnRzLmxlbmd0aCwgaGFsZldpZHRoID0gdGhpcy50ZXh0dXJlU2NhbGUgPiAwID8gdGhpcy50ZXh0dXJlU2NhbGUgKiB0aGlzLl93aWR0aCAvIDIgOiB0aGlzLl93aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXSwgaW5kZXggPSBpICogNDtcbiAgICAgIGkgPCBwb2ludHMubGVuZ3RoIC0gMSA/IG5leHRQb2ludCA9IHBvaW50c1tpICsgMV0gOiBuZXh0UG9pbnQgPSBwb2ludCwgcGVycFkgPSAtKG5leHRQb2ludC54IC0gbGFzdFBvaW50LngpLCBwZXJwWCA9IG5leHRQb2ludC55IC0gbGFzdFBvaW50Lnk7XG4gICAgICBsZXQgcmF0aW8gPSAoMSAtIGkgLyAodG90YWwgLSAxKSkgKiAxMDtcbiAgICAgIHJhdGlvID4gMSAmJiAocmF0aW8gPSAxKTtcbiAgICAgIGNvbnN0IHBlcnBMZW5ndGggPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICAgICAgcGVycExlbmd0aCA8IDFlLTYgPyAocGVycFggPSAwLCBwZXJwWSA9IDApIDogKHBlcnBYIC89IHBlcnBMZW5ndGgsIHBlcnBZIC89IHBlcnBMZW5ndGgsIHBlcnBYICo9IGhhbGZXaWR0aCwgcGVycFkgKj0gaGFsZldpZHRoKSwgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYLCB2ZXJ0aWNlc1tpbmRleCArIDFdID0gcG9pbnQueSArIHBlcnBZLCB2ZXJ0aWNlc1tpbmRleCArIDJdID0gcG9pbnQueCAtIHBlcnBYLCB2ZXJ0aWNlc1tpbmRleCArIDNdID0gcG9pbnQueSAtIHBlcnBZLCBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnRleHR1cmVTY2FsZSA+IDAgPyB0aGlzLmJ1aWxkKCkgOiB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJvcGVHZW9tZXRyeVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvcGVHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IE1lc2gsIE1lc2hNYXRlcmlhbCB9IGZyb20gXCJAcGl4aS9tZXNoXCI7XG5pbXBvcnQgeyBQbGFuZUdlb21ldHJ5IH0gZnJvbSBcIi4vZ2VvbWV0cnkvUGxhbmVHZW9tZXRyeS5tanNcIjtcbmNsYXNzIFNpbXBsZVBsYW5lIGV4dGVuZHMgTWVzaCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHVzZSBvbiB0aGUgU2ltcGxlUGxhbmUuXG4gICAqIEBwYXJhbSB2ZXJ0aWNlc1ggLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSB4LWF4aXNcbiAgICogQHBhcmFtIHZlcnRpY2VzWSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIHktYXhpc1xuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgdmVydGljZXNYLCB2ZXJ0aWNlc1kpIHtcbiAgICBjb25zdCBwbGFuZUdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQsIHZlcnRpY2VzWCwgdmVydGljZXNZKSwgbWVzaE1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbChUZXh0dXJlLldISVRFKTtcbiAgICBzdXBlcihwbGFuZUdlb21ldHJ5LCBtZXNoTWF0ZXJpYWwpLCB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlLCB0aGlzLmF1dG9SZXNpemUgPSAhMDtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgZm9yIG92ZXJyaWRlcywgdG8gZG8gc29tZXRoaW5nIGluIGNhc2UgdGV4dHVyZSBmcmFtZSB3YXMgY2hhbmdlZC5cbiAgICogTWVzaGVzIGJhc2VkIG9uIHBsYW5lIGNhbiBvdmVycmlkZSBpdCBhbmQgY2hhbmdlIG1vcmUgZGV0YWlscyBiYXNlZCBvbiB0ZXh0dXJlLlxuICAgKi9cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc2hhZGVyLnRleHR1cmU7XG4gICAgdGhpcy5hdXRvUmVzaXplICYmIChnZW9tZXRyeS53aWR0aCAhPT0gd2lkdGggfHwgZ2VvbWV0cnkuaGVpZ2h0ICE9PSBoZWlnaHQpICYmIChnZW9tZXRyeS53aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUud2lkdGgsIGdlb21ldHJ5LmhlaWdodCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0LCBnZW9tZXRyeS5idWlsZCgpKTtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUgIT09IHZhbHVlICYmICh0aGlzLnNoYWRlci50ZXh0dXJlID0gdmFsdWUsIHRoaXMuX3RleHR1cmVJRCA9IC0xLCB2YWx1ZS5iYXNlVGV4dHVyZS52YWxpZCA/IHRoaXMudGV4dHVyZVVwZGF0ZWQoKSA6IHZhbHVlLm9uY2UoXCJ1cGRhdGVcIiwgdGhpcy50ZXh0dXJlVXBkYXRlZCwgdGhpcykpO1xuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlci50ZXh0dXJlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLl90ZXh0dXJlSUQgIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlEICYmIHRoaXMudGV4dHVyZVVwZGF0ZWQoKSwgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgdGhpcy5zaGFkZXIudGV4dHVyZS5vZmYoXCJ1cGRhdGVcIiwgdGhpcy50ZXh0dXJlVXBkYXRlZCwgdGhpcyksIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFNpbXBsZVBsYW5lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUGxhbmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBTaW1wbGVQbGFuZSB9IGZyb20gXCIuL1NpbXBsZVBsYW5lLm1qc1wiO1xuY29uc3QgREVGQVVMVF9CT1JERVJfU0laRSA9IDEwO1xuY2xhc3MgTmluZVNsaWNlUGxhbmUgZXh0ZW5kcyBTaW1wbGVQbGFuZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHVzZSBvbiB0aGUgTmluZVNsaWNlUGxhbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVmdFdpZHRoPTEwXSAtIHNpemUgb2YgdGhlIGxlZnQgdmVydGljYWwgYmFyIChBKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RvcEhlaWdodD0xMF0gLSBzaXplIG9mIHRoZSB0b3AgaG9yaXpvbnRhbCBiYXIgKEMpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmlnaHRXaWR0aD0xMF0gLSBzaXplIG9mIHRoZSByaWdodCB2ZXJ0aWNhbCBiYXIgKEIpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYm90dG9tSGVpZ2h0PTEwXSAtIHNpemUgb2YgdGhlIGJvdHRvbSBob3Jpem9udGFsIGJhciAoRClcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGxlZnRXaWR0aCwgdG9wSGVpZ2h0LCByaWdodFdpZHRoLCBib3R0b21IZWlnaHQpIHtcbiAgICBzdXBlcihUZXh0dXJlLldISVRFLCA0LCA0KSwgdGhpcy5fb3JpZ1dpZHRoID0gdGV4dHVyZS5vcmlnLndpZHRoLCB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodCwgdGhpcy5fd2lkdGggPSB0aGlzLl9vcmlnV2lkdGgsIHRoaXMuX2hlaWdodCA9IHRoaXMuX29yaWdIZWlnaHQsIHRoaXMuX2xlZnRXaWR0aCA9IGxlZnRXaWR0aCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy5sZWZ0ID8/IERFRkFVTFRfQk9SREVSX1NJWkUsIHRoaXMuX3JpZ2h0V2lkdGggPSByaWdodFdpZHRoID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LnJpZ2h0ID8/IERFRkFVTFRfQk9SREVSX1NJWkUsIHRoaXMuX3RvcEhlaWdodCA9IHRvcEhlaWdodCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy50b3AgPz8gREVGQVVMVF9CT1JERVJfU0laRSwgdGhpcy5fYm90dG9tSGVpZ2h0ID0gYm90dG9tSGVpZ2h0ID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LmJvdHRvbSA/PyBERUZBVUxUX0JPUkRFUl9TSVpFLCB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICB9XG4gIHRleHR1cmVVcGRhdGVkKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlELCB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgZ2V0IHZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhO1xuICB9XG4gIHNldCB2ZXJ0aWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgaG9yaXpvbnRhbCB2ZXJ0aWNlcy4gKi9cbiAgdXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcywgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzldID0gdmVydGljZXNbMTFdID0gdmVydGljZXNbMTNdID0gdmVydGljZXNbMTVdID0gdGhpcy5fdG9wSGVpZ2h0ICogc2NhbGUsIHZlcnRpY2VzWzE3XSA9IHZlcnRpY2VzWzE5XSA9IHZlcnRpY2VzWzIxXSA9IHZlcnRpY2VzWzIzXSA9IHRoaXMuX2hlaWdodCAtIHRoaXMuX2JvdHRvbUhlaWdodCAqIHNjYWxlLCB2ZXJ0aWNlc1syNV0gPSB2ZXJ0aWNlc1syN10gPSB2ZXJ0aWNlc1syOV0gPSB2ZXJ0aWNlc1szMV0gPSB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIHZlcnRpY2FsIHZlcnRpY2VzLiAqL1xuICB1cGRhdGVWZXJ0aWNhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcywgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbMTBdID0gdmVydGljZXNbMThdID0gdmVydGljZXNbMjZdID0gdGhpcy5fbGVmdFdpZHRoICogc2NhbGUsIHZlcnRpY2VzWzRdID0gdmVydGljZXNbMTJdID0gdmVydGljZXNbMjBdID0gdmVydGljZXNbMjhdID0gdGhpcy5fd2lkdGggLSB0aGlzLl9yaWdodFdpZHRoICogc2NhbGUsIHZlcnRpY2VzWzZdID0gdmVydGljZXNbMTRdID0gdmVydGljZXNbMjJdID0gdmVydGljZXNbMzBdID0gdGhpcy5fd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgYSBzZXQgb2YgdmVydGljYWwgYW5kIGhvcml6b250YWwgc2NhbGUgb2YgbmluZSBzbGljZSBjb3JuZXJzLlxuICAgKiBAcmV0dXJucyBTbWFsbGVyIG51bWJlciBvZiB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY2FsZS5cbiAgICovXG4gIF9nZXRNaW5TY2FsZSgpIHtcbiAgICBjb25zdCB3ID0gdGhpcy5fbGVmdFdpZHRoICsgdGhpcy5fcmlnaHRXaWR0aCwgc2NhbGVXID0gdGhpcy5fd2lkdGggPiB3ID8gMSA6IHRoaXMuX3dpZHRoIC8gdywgaCA9IHRoaXMuX3RvcEhlaWdodCArIHRoaXMuX2JvdHRvbUhlaWdodCwgc2NhbGVIID0gdGhpcy5faGVpZ2h0ID4gaCA/IDEgOiB0aGlzLl9oZWlnaHQgLyBoO1xuICAgIHJldHVybiBNYXRoLm1pbihzY2FsZVcsIHNjYWxlSCk7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgTmluZVNsaWNlUGxhbmUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgdmVydGljZXMgYW5kIFVWJ3Mgb2YgdGhpcyBwbGFuZS4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlLCB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmUuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWUsIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBsZWZ0IGNvbHVtbi4gKi9cbiAgZ2V0IGxlZnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVmdFdpZHRoO1xuICB9XG4gIHNldCBsZWZ0V2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9sZWZ0V2lkdGggPSB2YWx1ZSwgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHJpZ2h0IGNvbHVtbi4gKi9cbiAgZ2V0IHJpZ2h0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0V2lkdGg7XG4gIH1cbiAgc2V0IHJpZ2h0V2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9yaWdodFdpZHRoID0gdmFsdWUsIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgdG9wIHJvdy4gKi9cbiAgZ2V0IHRvcEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9wSGVpZ2h0O1xuICB9XG4gIHNldCB0b3BIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSB2YWx1ZSwgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBib3R0b20gcm93LiAqL1xuICBnZXQgYm90dG9tSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gIH1cbiAgc2V0IGJvdHRvbUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IHZhbHVlLCB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgLyoqIFJlZnJlc2hlcyBOaW5lU2xpY2VQbGFuZSBjb29yZHMuIEFsbCBvZiB0aGVtLiAqL1xuICBfcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlLCB1dnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0uZGF0YTtcbiAgICB0aGlzLl9vcmlnV2lkdGggPSB0ZXh0dXJlLm9yaWcud2lkdGgsIHRoaXMuX29yaWdIZWlnaHQgPSB0ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIGNvbnN0IF91dncgPSAxIC8gdGhpcy5fb3JpZ1dpZHRoLCBfdXZoID0gMSAvIHRoaXMuX29yaWdIZWlnaHQ7XG4gICAgdXZzWzBdID0gdXZzWzhdID0gdXZzWzE2XSA9IHV2c1syNF0gPSAwLCB1dnNbMV0gPSB1dnNbM10gPSB1dnNbNV0gPSB1dnNbN10gPSAwLCB1dnNbNl0gPSB1dnNbMTRdID0gdXZzWzIyXSA9IHV2c1szMF0gPSAxLCB1dnNbMjVdID0gdXZzWzI3XSA9IHV2c1syOV0gPSB1dnNbMzFdID0gMSwgdXZzWzJdID0gdXZzWzEwXSA9IHV2c1sxOF0gPSB1dnNbMjZdID0gX3V2dyAqIHRoaXMuX2xlZnRXaWR0aCwgdXZzWzRdID0gdXZzWzEyXSA9IHV2c1syMF0gPSB1dnNbMjhdID0gMSAtIF91dncgKiB0aGlzLl9yaWdodFdpZHRoLCB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0LCB1dnNbMTddID0gdXZzWzE5XSA9IHV2c1syMV0gPSB1dnNbMjNdID0gMSAtIF91dmggKiB0aGlzLl9ib3R0b21IZWlnaHQsIHRoaXMudXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCksIHRoaXMudXBkYXRlVmVydGljYWxWZXJ0aWNlcygpLCB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0udXBkYXRlKCksIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTmluZVNsaWNlUGxhbmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OaW5lU2xpY2VQbGFuZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IE1lc2gsIE1lc2hHZW9tZXRyeSwgTWVzaE1hdGVyaWFsIH0gZnJvbSBcIkBwaXhpL21lc2hcIjtcbmNsYXNzIFNpbXBsZU1lc2ggZXh0ZW5kcyBNZXNoIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gdXNlXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbdmVydGljZXNdIC0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgdmVydGljZXNcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IFt1dnNdIC0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgdXZzXG4gICAqIEBwYXJhbSB7VWludDE2QXJyYXl9IFtpbmRpY2VzXSAtIGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIGluZGljZXNcbiAgICogQHBhcmFtIGRyYXdNb2RlIC0gdGhlIGRyYXdNb2RlLCBjYW4gYmUgYW55IG9mIHRoZSBNZXNoLkRSQVdfTU9ERVMgY29uc3RzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlID0gVGV4dHVyZS5FTVBUWSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBNZXNoR2VvbWV0cnkodmVydGljZXMsIHV2cywgaW5kaWNlcyk7XG4gICAgZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLnN0YXRpYyA9ICExO1xuICAgIGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBNZXNoTWF0ZXJpYWwodGV4dHVyZSk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG1lc2hNYXRlcmlhbCwgbnVsbCwgZHJhd01vZGUpLCB0aGlzLmF1dG9VcGRhdGUgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiB2ZXJ0aWNlcyBkYXRhLlxuICAgKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuICAgKi9cbiAgZ2V0IHZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhO1xuICB9XG4gIHNldCB2ZXJ0aWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5hdXRvVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLnVwZGF0ZSgpLCBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgU2ltcGxlTWVzaFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZU1lc2gubWpzLm1hcFxuIiwiaW1wb3J0IHsgV1JBUF9NT0RFUyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBNZXNoLCBNZXNoTWF0ZXJpYWwgfSBmcm9tIFwiQHBpeGkvbWVzaFwiO1xuaW1wb3J0IHsgUm9wZUdlb21ldHJ5IH0gZnJvbSBcIi4vZ2VvbWV0cnkvUm9wZUdlb21ldHJ5Lm1qc1wiO1xuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIE1lc2gge1xuICAvKipcbiAgICogTm90ZTogVGhlIHdyYXAgbW9kZSBvZiB0aGUgdGV4dHVyZSBpcyBzZXQgdG8gUkVQRUFUIGlmIGB0ZXh0dXJlU2NhbGVgIGlzIHBvc2l0aXZlLlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHVzZSBvbiB0aGUgcm9wZS5cbiAgICogQHBhcmFtIHBvaW50cyAtIEFuIGFycmF5IG9mIHtAbGluayBQSVhJLlBvaW50fSBvYmplY3RzIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlU2NhbGUgLSBPcHRpb25hbC4gUG9zaXRpdmUgdmFsdWVzIHNjYWxlIHJvcGUgdGV4dHVyZVxuICAgKiBrZWVwaW5nIGl0cyBhc3BlY3QgcmF0aW8uIFlvdSBjYW4gcmVkdWNlIGFscGhhIGNoYW5uZWwgYXJ0aWZhY3RzIGJ5IHByb3ZpZGluZyBhIGxhcmdlciB0ZXh0dXJlXG4gICAqIGFuZCBkb3duc2FtcGxpbmcgaGVyZS4gSWYgc2V0IHRvIHplcm8sIHRleHR1cmUgd2lsbCBiZSBzdHJldGNoZWQgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIHBvaW50cywgdGV4dHVyZVNjYWxlID0gMCkge1xuICAgIGNvbnN0IHJvcGVHZW9tZXRyeSA9IG5ldyBSb3BlR2VvbWV0cnkodGV4dHVyZS5oZWlnaHQsIHBvaW50cywgdGV4dHVyZVNjYWxlKSwgbWVzaE1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbCh0ZXh0dXJlKTtcbiAgICB0ZXh0dXJlU2NhbGUgPiAwICYmICh0ZXh0dXJlLmJhc2VUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5SRVBFQVQpLCBzdXBlcihyb3BlR2VvbWV0cnksIG1lc2hNYXRlcmlhbCksIHRoaXMuYXV0b1VwZGF0ZSA9ICEwO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgKHRoaXMuYXV0b1VwZGF0ZSB8fCBnZW9tZXRyeS5fd2lkdGggIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0KSAmJiAoZ2VvbWV0cnkuX3dpZHRoID0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQsIGdlb21ldHJ5LnVwZGF0ZSgpKSwgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFNpbXBsZVJvcGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVSb3BlLm1qcy5tYXBcbiIsImltcG9ydCB7IFBsYW5lR2VvbWV0cnkgfSBmcm9tIFwiLi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5Lm1qc1wiO1xuaW1wb3J0IHsgUm9wZUdlb21ldHJ5IH0gZnJvbSBcIi4vZ2VvbWV0cnkvUm9wZUdlb21ldHJ5Lm1qc1wiO1xuaW1wb3J0IHsgTmluZVNsaWNlUGxhbmUgfSBmcm9tIFwiLi9OaW5lU2xpY2VQbGFuZS5tanNcIjtcbmltcG9ydCB7IFNpbXBsZU1lc2ggfSBmcm9tIFwiLi9TaW1wbGVNZXNoLm1qc1wiO1xuaW1wb3J0IHsgU2ltcGxlUGxhbmUgfSBmcm9tIFwiLi9TaW1wbGVQbGFuZS5tanNcIjtcbmltcG9ydCB7IFNpbXBsZVJvcGUgfSBmcm9tIFwiLi9TaW1wbGVSb3BlLm1qc1wiO1xuZXhwb3J0IHtcbiAgTmluZVNsaWNlUGxhbmUsXG4gIFBsYW5lR2VvbWV0cnksXG4gIFJvcGVHZW9tZXRyeSxcbiAgU2ltcGxlTWVzaCxcbiAgU2ltcGxlUGxhbmUsXG4gIFNpbXBsZVJvcGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBCTEVORF9NT0RFUywgQ29sb3IgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmNsYXNzIFBhcnRpY2xlQ29udGFpbmVyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtYXhTaXplIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHBhcnRpY2xlcyB0aGF0IGNhbiBiZSByZW5kZXJlZCBieSB0aGUgY29udGFpbmVyLlxuICAgKiAgQWZmZWN0cyBzaXplIG9mIGFsbG9jYXRlZCBidWZmZXJzLlxuICAgKiBAcGFyYW0gcHJvcGVydGllcyAtIFRoZSBwcm9wZXJ0aWVzIG9mIGNoaWxkcmVuIHRoYXQgc2hvdWxkIGJlIHVwbG9hZGVkIHRvIHRoZSBncHUgYW5kIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BlcnRpZXMudmVydGljZXM9ZmFsc2VdIC0gV2hlbiB0cnVlLCB2ZXJ0aWNlcyBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICogICAgICAgICAgICAgICAgICBpZiBzcHJpdGUncyBgIHNjYWxlL2FuY2hvci90cmltL2ZyYW1lL29yaWdgIGlzIGR5bmFtaWMsIHBsZWFzZSBzZXQgYHRydWVgLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnBvc2l0aW9uPXRydWVdIC0gV2hlbiB0cnVlLCBwb3NpdGlvbiBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcGVydGllcy5yb3RhdGlvbj1mYWxzZV0gLSBXaGVuIHRydWUsIHJvdGF0aW9uIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnV2cz1mYWxzZV0gLSBXaGVuIHRydWUsIHV2cyBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcGVydGllcy50aW50PWZhbHNlXSAtIFdoZW4gdHJ1ZSwgYWxwaGEgYW5kIHRpbnQgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYmF0Y2hTaXplPTE2Mzg0XSAtIE51bWJlciBvZiBwYXJ0aWNsZXMgcGVyIGJhdGNoLiBJZiBsZXNzIHRoYW4gbWF4U2l6ZSwgaXQgdXNlcyBtYXhTaXplIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9SZXNpemU9ZmFsc2VdIC0gSWYgdHJ1ZSwgY29udGFpbmVyIGFsbG9jYXRlcyBtb3JlIGJhdGNoZXMgaW4gY2FzZVxuICAgKiAgdGhlcmUgYXJlIG1vcmUgdGhhbiBgbWF4U2l6ZWAgcGFydGljbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE1MDAsIHByb3BlcnRpZXMsIGJhdGNoU2l6ZSA9IDE2Mzg0LCBhdXRvUmVzaXplID0gITEpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG1heEJhdGNoU2l6ZSA9IDE2Mzg0O1xuICAgIGJhdGNoU2l6ZSA+IG1heEJhdGNoU2l6ZSAmJiAoYmF0Y2hTaXplID0gbWF4QmF0Y2hTaXplKSwgdGhpcy5fcHJvcGVydGllcyA9IFshMSwgITAsICExLCAhMSwgITFdLCB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSwgdGhpcy5fYmF0Y2hTaXplID0gYmF0Y2hTaXplLCB0aGlzLl9idWZmZXJzID0gbnVsbCwgdGhpcy5fYnVmZmVyVXBkYXRlSURzID0gW10sIHRoaXMuX3VwZGF0ZUlEID0gMCwgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gITEsIHRoaXMuYmxlbmRNb2RlID0gQkxFTkRfTU9ERVMuTk9STUFMLCB0aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplLCB0aGlzLnJvdW5kUGl4ZWxzID0gITAsIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsLCB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyksIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBDb2xvcigwKSwgdGhpcy50aW50UmdiID0gbmV3IEZsb2F0MzJBcnJheSgzKSwgdGhpcy50aW50ID0gMTY3NzcyMTU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByaXZhdGUgcHJvcGVydGllcyBhcnJheSB0byBkeW5hbWljIC8gc3RhdGljIGJhc2VkIG9uIHRoZSBwYXNzZWQgcHJvcGVydGllcyBvYmplY3RcbiAgICogQHBhcmFtIHByb3BlcnRpZXMgLSBUaGUgcHJvcGVydGllcyB0byBiZSB1cGxvYWRlZFxuICAgKi9cbiAgc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgcHJvcGVydGllcyAmJiAodGhpcy5fcHJvcGVydGllc1swXSA9IFwidmVydGljZXNcIiBpbiBwcm9wZXJ0aWVzIHx8IFwic2NhbGVcIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnZlcnRpY2VzIHx8ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF0sIHRoaXMuX3Byb3BlcnRpZXNbMV0gPSBcInBvc2l0aW9uXCIgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5wb3NpdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMV0sIHRoaXMuX3Byb3BlcnRpZXNbMl0gPSBcInJvdGF0aW9uXCIgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5yb3RhdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMl0sIHRoaXMuX3Byb3BlcnRpZXNbM10gPSBcInV2c1wiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXSwgdGhpcy5fcHJvcGVydGllc1s0XSA9IFwidGludFwiIGluIHByb3BlcnRpZXMgfHwgXCJhbHBoYVwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudGludCB8fCAhIXByb3BlcnRpZXMuYWxwaGEgOiB0aGlzLl9wcm9wZXJ0aWVzWzRdKTtcbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lci4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cbiAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqIElNUE9SVEFOVDogVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKSwgdGhpcy5fdGludENvbG9yLnRvUmdiQXJyYXkodGhpcy50aW50UmdiKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGFpbmVyIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMucmVuZGVyYWJsZSB8fCAodGhpcy5iYXNlVGV4dHVyZSB8fCAodGhpcy5iYXNlVGV4dHVyZSA9IHRoaXMuY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmUsIHRoaXMuYmFzZVRleHR1cmUudmFsaWQgfHwgdGhpcy5iYXNlVGV4dHVyZS5vbmNlKFwidXBkYXRlXCIsICgpID0+IHRoaXMub25DaGlsZHJlbkNoYW5nZSgwKSkpLCByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlKSwgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIodGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGZsYWcgdGhhdCBzdGF0aWMgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCB0byB0cnVlXG4gICAqIEBwYXJhbSBzbWFsbGVzdENoaWxkSW5kZXggLSBUaGUgc21hbGxlc3QgY2hpbGQgaW5kZXguXG4gICAqL1xuICBvbkNoaWxkcmVuQ2hhbmdlKHNtYWxsZXN0Q2hpbGRJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gTWF0aC5mbG9vcihzbWFsbGVzdENoaWxkSW5kZXggLyB0aGlzLl9iYXRjaFNpemUpO1xuICAgIGZvciAoOyB0aGlzLl9idWZmZXJVcGRhdGVJRHMubGVuZ3RoIDwgYnVmZmVySW5kZXg7IClcbiAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcy5wdXNoKDApO1xuICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEc1tidWZmZXJJbmRleF0gPSArK3RoaXMuX3VwZGF0ZUlEO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgdGhpcy5fYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb250YWluZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICogIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxuICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyksIHRoaXMuZGlzcG9zZSgpLCB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbCwgdGhpcy5fYnVmZmVycyA9IG51bGwsIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFBhcnRpY2xlQ29udGFpbmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVDb250YWluZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR2VvbWV0cnksIFRZUEVTLCBCdWZmZXIsIHV0aWxzIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmNsYXNzIFBhcnRpY2xlQnVmZmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gVGhlIHByb3BlcnRpZXMgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gZHluYW1pY1Byb3BlcnR5RmxhZ3MgLSBGbGFncyBmb3Igd2hpY2ggcHJvcGVydGllcyBhcmUgZHluYW1pYy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYmF0Y2guXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgc2l6ZSkge1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKSwgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuc2l6ZSA9IHNpemUsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBbXSwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkgPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbixcbiAgICAgICAgdHlwZTogcHJvcGVydHkudHlwZSB8fCBUWVBFUy5GTE9BVCxcbiAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXRcbiAgICAgIH0sIGR5bmFtaWNQcm9wZXJ0eUZsYWdzW2ldID8gdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KSA6IHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwLCB0aGlzLnN0YXRpY0J1ZmZlciA9IG51bGwsIHRoaXMuc3RhdGljRGF0YSA9IG51bGwsIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG51bGwsIHRoaXMuZHluYW1pY1N0cmlkZSA9IDAsIHRoaXMuZHluYW1pY0J1ZmZlciA9IG51bGwsIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsLCB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbnVsbCwgdGhpcy5fdXBkYXRlSUQgPSAwLCB0aGlzLmluaXRCdWZmZXJzKCk7XG4gIH1cbiAgLyoqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLiAqL1xuICBpbml0QnVmZmVycygpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgbGV0IGR5bmFtaWNPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHV0aWxzLmNyZWF0ZUluZGljZXNGb3JRdWFkcyh0aGlzLnNpemUpLCAhMCwgITApLCBnZW9tZXRyeS5hZGRJbmRleCh0aGlzLmluZGV4QnVmZmVyKSwgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQsIGR5bmFtaWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZSwgdGhpcy5keW5hbWljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IGR5bkJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0ICogNCk7XG4gICAgdGhpcy5keW5hbWljRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZHluQnVmZmVyKSwgdGhpcy5keW5hbWljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkeW5CdWZmZXIpLCB0aGlzLmR5bmFtaWNCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuZHluYW1pY0RhdGEsICExLCAhMSk7XG4gICAgbGV0IHN0YXRpY09mZnNldCA9IDA7XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IHN0YXRpY09mZnNldCwgc3RhdGljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemUsIHRoaXMuc3RhdGljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5zaXplICogdGhpcy5zdGF0aWNTdHJpZGUgKiA0ICogNCk7XG4gICAgdGhpcy5zdGF0aWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShzdGF0QnVmZmVyKSwgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KHN0YXRCdWZmZXIpLCB0aGlzLnN0YXRpY0J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5zdGF0aWNEYXRhLCAhMCwgITEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKFxuICAgICAgICBwcm9wZXJ0eS5hdHRyaWJ1dGVOYW1lLFxuICAgICAgICB0aGlzLmR5bmFtaWNCdWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHByb3BlcnR5LnR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHByb3BlcnR5LnR5cGUsXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsXG4gICAgICAgIHByb3BlcnR5Lm9mZnNldCAqIDRcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShcbiAgICAgICAgcHJvcGVydHkuYXR0cmlidXRlTmFtZSxcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHByb3BlcnR5LnR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHByb3BlcnR5LnR5cGUsXG4gICAgICAgIHRoaXMuc3RhdGljU3RyaWRlICogNCxcbiAgICAgICAgcHJvcGVydHkub2Zmc2V0ICogNFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIGR5bmFtaWMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIGNoaWxkcmVuIC0gVGhlIGNoaWxkcmVuIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggdG8gc3RhcnQgYXQuXG4gICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgbnVtYmVyIHRvIHVwbG9hZC5cbiAgICovXG4gIHVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIHByb3BlcnR5LnR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0JZVEUgPyB0aGlzLmR5bmFtaWNEYXRhVWludDMyIDogdGhpcy5keW5hbWljRGF0YSxcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlLFxuICAgICAgICBwcm9wZXJ0eS5vZmZzZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZHluYW1pY0J1ZmZlci5fdXBkYXRlSUQrKztcbiAgfVxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgc3RhdGljIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBjaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBzdGFydEluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IGF0LlxuICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIG51bWJlciB0byB1cGxvYWQuXG4gICAqL1xuICB1cGxvYWRTdGF0aWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5zdGF0aWNEYXRhVWludDMyIDogdGhpcy5zdGF0aWNEYXRhLFxuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSxcbiAgICAgICAgcHJvcGVydHkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnN0YXRpY0J1ZmZlci5fdXBkYXRlSUQrKztcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIFBhcnRpY2xlQnVmZmVyLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsLCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbCwgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbCwgdGhpcy5keW5hbWljRGF0YSA9IG51bGwsIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsLCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBudWxsLCB0aGlzLnN0YXRpY0J1ZmZlciA9IG51bGwsIHRoaXMuc3RhdGljRGF0YSA9IG51bGwsIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG51bGwsIHRoaXMuZ2VvbWV0cnkuZGVzdHJveSgpO1xuICB9XG59XG5leHBvcnQge1xuICBQYXJ0aWNsZUJ1ZmZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhcnRpY2xlQnVmZmVyLm1qcy5tYXBcbiIsInZhciBmcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG52b2lkIG1haW4odm9pZCl7XG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG59YDtcbmV4cG9ydCB7XG4gIGZyYWdtZW50IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aWNsZXMuZnJhZy5tanMubWFwXG4iLCJ2YXIgdmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG5cbmF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkO1xuYXR0cmlidXRlIGZsb2F0IGFSb3RhdGlvbjtcblxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xudW5pZm9ybSB2ZWM0IHVDb2xvcjtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG52b2lkIG1haW4odm9pZCl7XG4gICAgZmxvYXQgeCA9IChhVmVydGV4UG9zaXRpb24ueCkgKiBjb3MoYVJvdGF0aW9uKSAtIChhVmVydGV4UG9zaXRpb24ueSkgKiBzaW4oYVJvdGF0aW9uKTtcbiAgICBmbG9hdCB5ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIHNpbihhUm90YXRpb24pICsgKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIGNvcyhhUm90YXRpb24pO1xuXG4gICAgdmVjMiB2ID0gdmVjMih4LCB5KTtcbiAgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkO1xuXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzModiwgMS4wKSkueHksIDAuMCwgMS4wKTtcblxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgIHZDb2xvciA9IGFDb2xvciAqIHVDb2xvcjtcbn1cbmA7XG5leHBvcnQge1xuICB2ZXJ0ZXggYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpY2xlcy52ZXJ0Lm1qcy5tYXBcbiIsImltcG9ydCB7IE9iamVjdFJlbmRlcmVyLCBNYXRyaXgsIFRZUEVTLCBTaGFkZXIsIFN0YXRlLCB1dGlscywgQ29sb3IsIEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgUGFydGljbGVCdWZmZXIgfSBmcm9tIFwiLi9QYXJ0aWNsZUJ1ZmZlci5tanNcIjtcbmltcG9ydCBmcmFnbWVudCBmcm9tIFwiLi9wYXJ0aWNsZXMuZnJhZy5tanNcIjtcbmltcG9ydCB2ZXJ0ZXggZnJvbSBcIi4vcGFydGljbGVzLnZlcnQubWpzXCI7XG5jbGFzcyBQYXJ0aWNsZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpLCB0aGlzLnNoYWRlciA9IG51bGwsIHRoaXMucHJvcGVydGllcyA9IG51bGwsIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKSwgdGhpcy5wcm9wZXJ0aWVzID0gW1xuICAgICAgLy8gdmVydGljZXNEYXRhXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVZlcnRleFBvc2l0aW9uXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFZlcnRpY2VzLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICAvLyBwb3NpdGlvbkRhdGFcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhUG9zaXRpb25Db29yZFwiLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRQb3NpdGlvbixcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgLy8gcm90YXRpb25EYXRhXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVJvdGF0aW9uXCIsXG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFJvdGF0aW9uLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICAvLyB1dnNEYXRhXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVRleHR1cmVDb29yZFwiLFxuICAgICAgICBzaXplOiAyLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRVdnMsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIC8vIHRpbnREYXRhXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYUNvbG9yXCIsXG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHR5cGU6IFRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFRpbnQsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIF0sIHRoaXMuc2hhZGVyID0gU2hhZGVyLmZyb20odmVydGV4LCBmcmFnbWVudCwge30pLCB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcGFydGljbGUgY29udGFpbmVyIG9iamVjdC5cbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlci5cbiAgICovXG4gIHJlbmRlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbiwgbWF4U2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZSwgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemUsIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAodG90YWxDaGlsZHJlbiA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICB0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSAmJiAhY29udGFpbmVyLmF1dG9SZXNpemUgJiYgKHRvdGFsQ2hpbGRyZW4gPSBtYXhTaXplKTtcbiAgICBsZXQgYnVmZmVycyA9IGNvbnRhaW5lci5fYnVmZmVycztcbiAgICBidWZmZXJzIHx8IChidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzID0gdGhpcy5nZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKSk7XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZSwgcHJlbXVsdGlwbGllZCA9IGJhc2VUZXh0dXJlLmFscGhhTW9kZSA+IDA7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB1dGlscy5jb3JyZWN0QmxlbmRNb2RlKGNvbnRhaW5lci5ibGVuZE1vZGUsIHByZW11bHRpcGxpZWQpLCByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbCwgbSA9IGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGhpcy50ZW1wTWF0cml4KTtcbiAgICBtLnByZXBlbmQocmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCksIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gbS50b0FycmF5KCEwKSwgdGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbnRhaW5lci50aW50UmdiKS5wcmVtdWx0aXBseShjb250YWluZXIud29ybGRBbHBoYSwgcHJlbXVsdGlwbGllZCkudG9BcnJheSh0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IpLCB0aGlzLnNoYWRlci51bmlmb3Jtcy51U2FtcGxlciA9IGJhc2VUZXh0dXJlLCB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuc2hhZGVyKTtcbiAgICBsZXQgdXBkYXRlU3RhdGljID0gITE7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSArPSBiYXRjaFNpemUsIGogKz0gMSkge1xuICAgICAgbGV0IGFtb3VudCA9IHRvdGFsQ2hpbGRyZW4gLSBpO1xuICAgICAgYW1vdW50ID4gYmF0Y2hTaXplICYmIChhbW91bnQgPSBiYXRjaFNpemUpLCBqID49IGJ1ZmZlcnMubGVuZ3RoICYmIGJ1ZmZlcnMucHVzaCh0aGlzLl9nZW5lcmF0ZU9uZU1vcmVCdWZmZXIoY29udGFpbmVyKSk7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2pdO1xuICAgICAgYnVmZmVyLnVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XG4gICAgICBjb25zdCBiaWQgPSBjb250YWluZXIuX2J1ZmZlclVwZGF0ZUlEc1tqXSB8fCAwO1xuICAgICAgdXBkYXRlU3RhdGljID0gdXBkYXRlU3RhdGljIHx8IGJ1ZmZlci5fdXBkYXRlSUQgPCBiaWQsIHVwZGF0ZVN0YXRpYyAmJiAoYnVmZmVyLl91cGRhdGVJRCA9IGNvbnRhaW5lci5fdXBkYXRlSUQsIGJ1ZmZlci51cGxvYWRTdGF0aWMoY2hpbGRyZW4sIGksIGFtb3VudCkpLCByZW5kZXJlci5nZW9tZXRyeS5iaW5kKGJ1ZmZlci5nZW9tZXRyeSksIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGFtb3VudCAqIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgb25lIHBhcnRpY2xlIGJ1ZmZlciBmb3IgZWFjaCBjaGlsZCBpbiB0aGUgY29udGFpbmVyIHdlIHdhbnQgdG8gcmVuZGVyIGFuZCB1cGRhdGVzIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcbiAgICogQHJldHVybnMgLSBUaGUgYnVmZmVyc1xuICAgKi9cbiAgZ2VuZXJhdGVCdWZmZXJzKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXSwgc2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZSwgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemUsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSBiYXRjaFNpemUpXG4gICAgICBidWZmZXJzLnB1c2gobmV3IFBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSkpO1xuICAgIHJldHVybiBidWZmZXJzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG9uZSBtb3JlIHBhcnRpY2xlIGJ1ZmZlciwgYmVjYXVzZSBjb250YWluZXIgaGFzIGF1dG9SZXNpemUgZmVhdHVyZS5cbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgKiBAcmV0dXJucyAtIFRoZSBnZW5lcmF0ZWQgYnVmZmVyXG4gICAqL1xuICBfZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplLCBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICByZXR1cm4gbmV3IFBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIHZlcnRpY2VzLlxuICAgKiBAcGFyYW0gY2hpbGRyZW4gLSB0aGUgYXJyYXkgb2Ygc3ByaXRlcyB0byByZW5kZXJcbiAgICogQHBhcmFtIHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgdmVydGljZXMgdXBsb2FkZWRcbiAgICogQHBhcmFtIGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICovXG4gIHVwbG9hZFZlcnRpY2VzKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGxldCB3MCA9IDAsIHcxID0gMCwgaDAgPSAwLCBoMSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLCB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlLCBzeCA9IHNwcml0ZS5zY2FsZS54LCBzeSA9IHNwcml0ZS5zY2FsZS55LCB0cmltID0gdGV4dHVyZS50cmltLCBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgICAgdHJpbSA/ICh3MSA9IHRyaW0ueCAtIHNwcml0ZS5hbmNob3IueCAqIG9yaWcud2lkdGgsIHcwID0gdzEgKyB0cmltLndpZHRoLCBoMSA9IHRyaW0ueSAtIHNwcml0ZS5hbmNob3IueSAqIG9yaWcuaGVpZ2h0LCBoMCA9IGgxICsgdHJpbS5oZWlnaHQpIDogKHcwID0gb3JpZy53aWR0aCAqICgxIC0gc3ByaXRlLmFuY2hvci54KSwgdzEgPSBvcmlnLndpZHRoICogLXNwcml0ZS5hbmNob3IueCwgaDAgPSBvcmlnLmhlaWdodCAqICgxIC0gc3ByaXRlLmFuY2hvci55KSwgaDEgPSBvcmlnLmhlaWdodCAqIC1zcHJpdGUuYW5jaG9yLnkpLCBhcnJheVtvZmZzZXRdID0gdzEgKiBzeCwgYXJyYXlbb2Zmc2V0ICsgMV0gPSBoMSAqIHN5LCBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdzAgKiBzeCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBoMSAqIHN5LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHcwICogc3gsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IGgwICogc3ksIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdzEgKiBzeCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gaDAgKiBzeSwgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIHNwcml0ZXMgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9ucyB1cGxvYWRlZFxuICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgKi9cbiAgdXBsb2FkUG9zaXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucG9zaXRpb247XG4gICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUG9zaXRpb24ueCwgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55LCBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUG9zaXRpb24ueCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZVBvc2l0aW9uLngsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnksIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gc3ByaXRlUG9zaXRpb24ueCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gc3ByaXRlUG9zaXRpb24ueSwgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSByb3RhdGlvbi5cbiAgICogQHBhcmFtIGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIHNwcml0ZXMgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAqL1xuICB1cGxvYWRSb3RhdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbiwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVJvdGF0aW9uLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZVJvdGF0aW9uLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVJvdGF0aW9uLCBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIFVWcy5cbiAgICogQHBhcmFtIGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIHNwcml0ZXMgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAqL1xuICB1cGxvYWRVdnMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgY29uc3QgdGV4dHVyZVV2cyA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5fdGV4dHVyZS5fdXZzO1xuICAgICAgdGV4dHVyZVV2cyA/IChhcnJheVtvZmZzZXRdID0gdGV4dHVyZVV2cy54MCwgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZXh0dXJlVXZzLnkwLCBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MSwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSB0ZXh0dXJlVXZzLnkxLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHRleHR1cmVVdnMueDIsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IHRleHR1cmVVdnMueTIsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdGV4dHVyZVV2cy54MywgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gdGV4dHVyZVV2cy55Mywgb2Zmc2V0ICs9IHN0cmlkZSAqIDQpIDogKGFycmF5W29mZnNldF0gPSAwLCBhcnJheVtvZmZzZXQgKyAxXSA9IDAsIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSAwLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IDAsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gMCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gMCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSAwLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzICsgMV0gPSAwLCBvZmZzZXQgKz0gc3RyaWRlICogNCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSB0aW50LlxuICAgKiBAcGFyYW0gY2hpbGRyZW4gLSB0aGUgYXJyYXkgb2Ygc3ByaXRlcyB0byByZW5kZXJcbiAgICogQHBhcmFtIHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcbiAgICogQHBhcmFtIGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICovXG4gIHVwbG9hZFRpbnQoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLCByZXN1bHQgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3ByaXRlLl90aW50UkdCKS50b1ByZW11bHRpcGxpZWQoc3ByaXRlLmFscGhhLCBzcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPiAwKTtcbiAgICAgIGFycmF5W29mZnNldF0gPSByZXN1bHQsIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSByZXN1bHQsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gcmVzdWx0LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHJlc3VsdCwgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgUGFydGljbGVSZW5kZXJlci4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCksIHRoaXMuc2hhZGVyICYmICh0aGlzLnNoYWRlci5kZXN0cm95KCksIHRoaXMuc2hhZGVyID0gbnVsbCksIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG4gIH1cbn1cblBhcnRpY2xlUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInBhcnRpY2xlXCIsXG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW5cbn07XG5leHRlbnNpb25zLmFkZChQYXJ0aWNsZVJlbmRlcmVyKTtcbmV4cG9ydCB7XG4gIFBhcnRpY2xlUmVuZGVyZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNsZVJlbmRlcmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IFBhcnRpY2xlQ29udGFpbmVyIH0gZnJvbSBcIi4vUGFydGljbGVDb250YWluZXIubWpzXCI7XG5pbXBvcnQgeyBQYXJ0aWNsZVJlbmRlcmVyIH0gZnJvbSBcIi4vUGFydGljbGVSZW5kZXJlci5tanNcIjtcbmV4cG9ydCB7XG4gIFBhcnRpY2xlQ29udGFpbmVyLFxuICBQYXJ0aWNsZVJlbmRlcmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIFRFWFRfR1JBRElFTlQgPSAvKiBAX19QVVJFX18gKi8gKChURVhUX0dSQURJRU5UMikgPT4gKFRFWFRfR1JBRElFTlQyW1RFWFRfR1JBRElFTlQyLkxJTkVBUl9WRVJUSUNBTCA9IDBdID0gXCJMSU5FQVJfVkVSVElDQUxcIiwgVEVYVF9HUkFESUVOVDJbVEVYVF9HUkFESUVOVDIuTElORUFSX0hPUklaT05UQUwgPSAxXSA9IFwiTElORUFSX0hPUklaT05UQUxcIiwgVEVYVF9HUkFESUVOVDIpKShURVhUX0dSQURJRU5UIHx8IHt9KTtcbmV4cG9ydCB7XG4gIFRFWFRfR1JBRElFTlRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jb25zdCBjb250ZXh0U2V0dGluZ3MgPSB7XG4gIC8vIFRleHRNZXRyaWNzIHJlcXVpcmVzIGdldEltYWdlRGF0YSByZWFkYmFjayBmb3IgbWVhc3VyaW5nIGZvbnRzLlxuICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG59LCBfVGV4dE1ldHJpY3MgPSBjbGFzcyBfVGV4dE1ldHJpY3MyIHtcbiAgLyoqXG4gICAqIENoZWNraW5nIHRoYXQgd2UgY2FuIHVzZSBtb2Rlcm4gY2FudmFzIDJEIEFQSS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyBhbiB1bnN0YWJsZSBBUEksIENocm9tZSA8IDk0IHVzZSBgdGV4dExldHRlclNwYWNpbmdgLCBsYXRlciB2ZXJzaW9ucyB1c2UgYGxldHRlclNwYWNpbmdgLlxuICAgKiBAc2VlIFBJWEkuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvbGV0dGVyU3BhY2luZ1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vb3JpZ2ludHJpYWxzLyMvdmlld190cmlhbC8zNTg1OTkxMjAzMjkzNzU3NDQxXG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHJlc3VsdCA9IF9UZXh0TWV0cmljczIuX2V4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQ7XG4gICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBwcm90byA9IHNldHRpbmdzLkFEQVBURVIuZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKCkucHJvdG90eXBlO1xuICAgICAgcmVzdWx0ID0gX1RleHRNZXRyaWNzMi5fZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCA9IFwibGV0dGVyU3BhY2luZ1wiIGluIHByb3RvIHx8IFwidGV4dExldHRlclNwYWNpbmdcIiBpbiBwcm90bztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHRleHQgLSB0aGUgdGV4dCB0aGF0IHdhcyBtZWFzdXJlZFxuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdGhhdCB3YXMgbWVhc3VyZWRcbiAgICogQHBhcmFtIHdpZHRoIC0gdGhlIG1lYXN1cmVkIHdpZHRoIG9mIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSB0aGUgbWVhc3VyZWQgaGVpZ2h0IG9mIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBsaW5lcyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lcyBvZiB0ZXh0IGJyb2tlbiBieSBuZXcgbGluZXMgYW5kIHdyYXBwaW5nIGlmIHNwZWNpZmllZCBpbiBzdHlsZVxuICAgKiBAcGFyYW0gbGluZVdpZHRocyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lIHdpZHRocyBmb3IgZWFjaCBsaW5lIG1hdGNoZWQgdG8gYGxpbmVzYFxuICAgKiBAcGFyYW0gbGluZUhlaWdodCAtIHRoZSBtZWFzdXJlZCBsaW5lIGhlaWdodCBmb3IgdGhpcyBzdHlsZVxuICAgKiBAcGFyYW0gbWF4TGluZVdpZHRoIC0gdGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgYWxsIG1lYXN1cmVkIGxpbmVzXG4gICAqIEBwYXJhbSB7UElYSS5JRm9udE1ldHJpY3N9IGZvbnRQcm9wZXJ0aWVzIC0gdGhlIGZvbnQgcHJvcGVydGllcyBvYmplY3QgZnJvbSBUZXh0TWV0cmljcy5tZWFzdXJlRm9udFxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dCwgdGhpcy5zdHlsZSA9IHN0eWxlLCB0aGlzLndpZHRoID0gd2lkdGgsIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0LCB0aGlzLmxpbmVzID0gbGluZXMsIHRoaXMubGluZVdpZHRocyA9IGxpbmVXaWR0aHMsIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQsIHRoaXMubWF4TGluZVdpZHRoID0gbWF4TGluZVdpZHRoLCB0aGlzLmZvbnRQcm9wZXJ0aWVzID0gZm9udFByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzdXBwbGllZCBzdHJpbmcgb2YgdGV4dCBhbmQgcmV0dXJucyBhIFJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBtZWFzdXJlLlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgdGV4dCBzdHlsZSB0byB1c2UgZm9yIG1lYXN1cmluZ1xuICAgKiBAcGFyYW0gd29yZFdyYXAgLSBPdmVycmlkZSBmb3IgaWYgd29yZC13cmFwIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0LlxuICAgKiBAcGFyYW0gY2FudmFzIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgKiBAcmV0dXJucyBNZWFzdXJlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0ZXh0LlxuICAgKi9cbiAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlLCB3b3JkV3JhcCwgY2FudmFzID0gX1RleHRNZXRyaWNzMi5fY2FudmFzKSB7XG4gICAgd29yZFdyYXAgPSB3b3JkV3JhcCA/PyBzdHlsZS53b3JkV3JhcDtcbiAgICBjb25zdCBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCksIGZvbnRQcm9wZXJ0aWVzID0gX1RleHRNZXRyaWNzMi5tZWFzdXJlRm9udChmb250KTtcbiAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9PT0gMCAmJiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSwgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemUpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBsaW5lcyA9ICh3b3JkV3JhcCA/IF9UZXh0TWV0cmljczIud29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykgOiB0ZXh0KS5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyksIGxpbmVXaWR0aHMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBfVGV4dE1ldHJpY3MyLl9tZWFzdXJlVGV4dChsaW5lc1tpXSwgc3R5bGUubGV0dGVyU3BhY2luZywgY29udGV4dCk7XG4gICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoLCBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgfVxuICAgIGxldCB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBzdHlsZS5kcm9wU2hhZG93ICYmICh3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAqIDIpICsgc3R5bGUubGVhZGluZyArIChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZyk7XG4gICAgcmV0dXJuIHN0eWxlLmRyb3BTaGFkb3cgJiYgKGhlaWdodCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UpLCBuZXcgX1RleHRNZXRyaWNzMihcbiAgICAgIHRleHQsXG4gICAgICBzdHlsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGluZXMsXG4gICAgICBsaW5lV2lkdGhzLFxuICAgICAgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsXG4gICAgICBtYXhMaW5lV2lkdGgsXG4gICAgICBmb250UHJvcGVydGllc1xuICAgICk7XG4gIH1cbiAgc3RhdGljIF9tZWFzdXJlVGV4dCh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSB7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSAhMTtcbiAgICBfVGV4dE1ldHJpY3MyLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQgJiYgKF9UZXh0TWV0cmljczIuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA/IChjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YCwgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgLCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gITApIDogKGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCIsIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiKSk7XG4gICAgbGV0IHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICByZXR1cm4gd2lkdGggPiAwICYmICh1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID8gd2lkdGggLT0gbGV0dGVyU3BhY2luZyA6IHdpZHRoICs9IChfVGV4dE1ldHJpY3MyLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZyksIHdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHRleHQgLSBTdHJpbmcgdG8gYXBwbHkgd29yZCB3cmFwcGluZyB0b1xuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdG8gdXNlIHdoZW4gd3JhcHBpbmdcbiAgICogQHBhcmFtIGNhbnZhcyAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAgICogQHJldHVybnMgTmV3IHN0cmluZyB3aXRoIG5ldyBsaW5lcyBhcHBsaWVkIHdoZXJlIHJlcXVpcmVkXG4gICAqL1xuICBzdGF0aWMgd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcyA9IF9UZXh0TWV0cmljczIuX2NhbnZhcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgbGV0IHdpZHRoID0gMCwgbGluZSA9IFwiXCIsIGxpbmVzID0gXCJcIjtcbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7IGxldHRlclNwYWNpbmcsIHdoaXRlU3BhY2UgfSA9IHN0eWxlLCBjb2xsYXBzZVNwYWNlcyA9IF9UZXh0TWV0cmljczIuY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSksIGNvbGxhcHNlTmV3bGluZXMgPSBfVGV4dE1ldHJpY3MyLmNvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSk7XG4gICAgbGV0IGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgY29uc3Qgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nLCB0b2tlbnMgPSBfVGV4dE1ldHJpY3MyLnRva2VuaXplKHRleHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzMi5pc05ld2xpbmUodG9rZW4pKSB7XG4gICAgICAgIGlmICghY29sbGFwc2VOZXdsaW5lcykge1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljczIuYWRkTGluZShsaW5lKSwgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcywgbGluZSA9IFwiXCIsIHdpZHRoID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNlU3BhY2VzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJJc0JyZWFraW5nU3BhY2UgPSBfVGV4dE1ldHJpY3MyLmlzQnJlYWtpbmdTcGFjZSh0b2tlbiksIGxhc3RJc0JyZWFraW5nU3BhY2UgPSBfVGV4dE1ldHJpY3MyLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAoY3VycklzQnJlYWtpbmdTcGFjZSAmJiBsYXN0SXNCcmVha2luZ1NwYWNlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5XaWR0aCA9IF9UZXh0TWV0cmljczIuZ2V0RnJvbUNhY2hlKHRva2VuLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICBpZiAodG9rZW5XaWR0aCA+IHdvcmRXcmFwV2lkdGgpXG4gICAgICAgIGlmIChsaW5lICE9PSBcIlwiICYmIChsaW5lcyArPSBfVGV4dE1ldHJpY3MyLmFkZExpbmUobGluZSksIGxpbmUgPSBcIlwiLCB3aWR0aCA9IDApLCBfVGV4dE1ldHJpY3MyLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IF9UZXh0TWV0cmljczIud29yZFdyYXBTcGxpdCh0b2tlbik7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFyYWN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNoYXJhY3RlcnNbal0sIGxhc3RDaGFyID0gY2hhciwgayA9IDE7XG4gICAgICAgICAgICBmb3IgKDsgY2hhcmFjdGVyc1tqICsga107ICkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJhY3RlcnNbaiArIGtdO1xuICAgICAgICAgICAgICBpZiAoIV9UZXh0TWV0cmljczIuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSlcbiAgICAgICAgICAgICAgICBjaGFyICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGxhc3RDaGFyID0gbmV4dENoYXIsIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGogKz0gayAtIDE7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJXaWR0aCA9IF9UZXh0TWV0cmljczIuZ2V0RnJvbUNhY2hlKGNoYXIsIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoICYmIChsaW5lcyArPSBfVGV4dE1ldHJpY3MyLmFkZExpbmUobGluZSksIGNhblByZXBlbmRTcGFjZXMgPSAhMSwgbGluZSA9IFwiXCIsIHdpZHRoID0gMCksIGxpbmUgKz0gY2hhciwgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmUubGVuZ3RoID4gMCAmJiAobGluZXMgKz0gX1RleHRNZXRyaWNzMi5hZGRMaW5lKGxpbmUpLCBsaW5lID0gXCJcIiwgd2lkdGggPSAwKTtcbiAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljczIuYWRkTGluZSh0b2tlbiwgIWlzTGFzdFRva2VuKSwgY2FuUHJlcGVuZFNwYWNlcyA9ICExLCBsaW5lID0gXCJcIiwgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGggJiYgKGNhblByZXBlbmRTcGFjZXMgPSAhMSwgbGluZXMgKz0gX1RleHRNZXRyaWNzMi5hZGRMaW5lKGxpbmUpLCBsaW5lID0gXCJcIiwgd2lkdGggPSAwKSwgKGxpbmUubGVuZ3RoID4gMCB8fCAhX1RleHRNZXRyaWNzMi5pc0JyZWFraW5nU3BhY2UodG9rZW4pIHx8IGNhblByZXBlbmRTcGFjZXMpICYmIChsaW5lICs9IHRva2VuLCB3aWR0aCArPSB0b2tlbldpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzICs9IF9UZXh0TWV0cmljczIuYWRkTGluZShsaW5lLCAhMSksIGxpbmVzO1xuICB9XG4gIC8qKlxuICAgKiBDb252aWVuaWVuY2UgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgZWFjaCBsaW5lIGFkZGVkIGR1cmluZyB0aGUgd29yZFdyYXAgbWV0aG9kLlxuICAgKiBAcGFyYW0gbGluZSAgICAtIFRoZSBsaW5lIG9mIHRleHQgdG8gYWRkXG4gICAqIEBwYXJhbSBuZXdMaW5lIC0gQWRkIG5ldyBsaW5lIGNoYXJhY3RlciB0byBlbmRcbiAgICogQHJldHVybnMgQSBmb3JtYXR0ZWQgbGluZVxuICAgKi9cbiAgc3RhdGljIGFkZExpbmUobGluZSwgbmV3TGluZSA9ICEwKSB7XG4gICAgcmV0dXJuIGxpbmUgPSBfVGV4dE1ldHJpY3MyLnRyaW1SaWdodChsaW5lKSwgbGluZSA9IG5ld0xpbmUgPyBgJHtsaW5lfVxuYCA6IGxpbmUsIGxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgJiBzZXRzIHRoZSB3aWR0aHMgb2YgY2FsY3VsYXRlZCBjaGFyYWN0ZXJzIGluIGEgY2FjaGUgb2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgICAgICAgICAgICAtIFRoZSBrZXlcbiAgICogQHBhcmFtIGxldHRlclNwYWNpbmcgIC0gVGhlIGxldHRlciBzcGFjaW5nXG4gICAqIEBwYXJhbSBjYWNoZSAgICAgICAgICAtIFRoZSBjYWNoZVxuICAgKiBAcGFyYW0gY29udGV4dCAgICAgICAgLSBUaGUgY2FudmFzIGNvbnRleHRcbiAgICogQHJldHVybnMgVGhlIGZyb20gY2FjaGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0RnJvbUNhY2hlKGtleSwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpIHtcbiAgICBsZXQgd2lkdGggPSBjYWNoZVtrZXldO1xuICAgIHJldHVybiB0eXBlb2Ygd2lkdGggIT0gXCJudW1iZXJcIiAmJiAod2lkdGggPSBfVGV4dE1ldHJpY3MyLl9tZWFzdXJlVGV4dChrZXksIGxldHRlclNwYWNpbmcsIGNvbnRleHQpICsgbGV0dGVyU3BhY2luZywgY2FjaGVba2V5XSA9IHdpZHRoKSwgd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgYnJlYWtpbmcgc3BhY2VzLlxuICAgKiBAcGFyYW0gd2hpdGVTcGFjZSAtIFRoZSBUZXh0U3R5bGUgcHJvcGVydHkgd2hpdGVTcGFjZVxuICAgKiBAcmV0dXJucyBTaG91bGQgY29sbGFwc2VcbiAgICovXG4gIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCIgfHwgd2hpdGVTcGFjZSA9PT0gXCJwcmUtbGluZVwiO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnMuXG4gICAqIEBwYXJhbSB3aGl0ZVNwYWNlIC0gVGhlIHdoaXRlIHNwYWNlXG4gICAqIEByZXR1cm5zIHNob3VsZCBjb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIGNvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSkge1xuICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSBcIm5vcm1hbFwiO1xuICB9XG4gIC8qKlxuICAgKiBUcmltcyBicmVha2luZyB3aGl0ZXNwYWNlcyBmcm9tIHN0cmluZy5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dFxuICAgKiBAcmV0dXJucyBUcmltbWVkIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIHRyaW1SaWdodCh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBpZiAoIV9UZXh0TWV0cmljczIuaXNCcmVha2luZ1NwYWNlKGNoYXIpKVxuICAgICAgICBicmVhaztcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgY2hhciBpcyBhIG5ld2xpbmUuXG4gICAqIEBwYXJhbSBjaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIG5ld2xpbmUsIEZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xuICAgIHJldHVybiB0eXBlb2YgY2hhciAhPSBcInN0cmluZ1wiID8gITEgOiBfVGV4dE1ldHJpY3MyLl9uZXdsaW5lcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBicmVha2luZyB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBJdCBhbGxvd3Mgb25lIHRvIGRldGVybWluZSB3aGV0aGVyIGNoYXIgc2hvdWxkIGJlIGEgYnJlYWtpbmcgd2hpdGVzcGFjZVxuICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIGNoYXIgLSBUaGUgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBbX25leHRDaGFyXSAtIFRoZSBuZXh0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHdoaXRlc3BhY2UsIEZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhciwgX25leHRDaGFyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjaGFyICE9IFwic3RyaW5nXCIgPyAhMSA6IF9UZXh0TWV0cmljczIuX2JyZWFraW5nU3BhY2VzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIHdvcmRzLCBicmVha2luZy1zcGFjZXMgYW5kIG5ld0xpbmUgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0XG4gICAqIEByZXR1cm5zIEEgdG9rZW5pemVkIGFycmF5XG4gICAqL1xuICBzdGF0aWMgdG9rZW5pemUodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV0sIG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzMi5pc0JyZWFraW5nU3BhY2UoY2hhciwgbmV4dENoYXIpIHx8IF9UZXh0TWV0cmljczIuaXNOZXdsaW5lKGNoYXIpKSB7XG4gICAgICAgIHRva2VuICE9PSBcIlwiICYmICh0b2tlbnMucHVzaCh0b2tlbiksIHRva2VuID0gXCJcIiksIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbiAhPT0gXCJcIiAmJiB0b2tlbnMucHVzaCh0b2tlbiksIHRva2VucztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gY3VzdG9taXNlIHdoaWNoIHdvcmRzIHNob3VsZCBicmVha1xuICAgKiBFeGFtcGxlcyBhcmUgaWYgdGhlIHRva2VuIGlzIENKSyBvciBudW1iZXJzLlxuICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBfdG9rZW4gLSBUaGUgdG9rZW5cbiAgICogQHBhcmFtIGJyZWFrV29yZHMgLSBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAqL1xuICBzdGF0aWMgY2FuQnJlYWtXb3JkcyhfdG9rZW4sIGJyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYWlyIG9mIGNoYXJhY3RlcnNcbiAgICogc2hvdWxkIGJlIGJyb2tlbiBieSBuZXdsaW5lc1xuICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIF9jaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcGFyYW0gX25leHRDaGFyIC0gVGhlIG5leHQgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBfdG9rZW4gLSBUaGUgdG9rZW4vd29yZCB0aGUgY2hhcmFjdGVycyBhcmUgZnJvbVxuICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGluZGV4IGluIHRoZSB0b2tlbiBvZiB0aGUgY2hhclxuICAgKiBAcGFyYW0gX2JyZWFrV29yZHMgLSBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgKiBAcmV0dXJucyB3aGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAqL1xuICBzdGF0aWMgY2FuQnJlYWtDaGFycyhfY2hhciwgX25leHRDaGFyLCBfdG9rZW4sIF9pbmRleCwgX2JyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIGhlbHBlciBtZXRob2QgdXNlZCBpbnRlcm5hbGx5IGJ5IFRleHRNZXRyaWNzLCBleHBvc2VkIHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoZSBjbGFzcydzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHRva2VuICh1c3VhbGx5IGEgd29yZCkgaGFzIHRvIGJlIHNwbGl0IGludG8gc2VwYXJhdGUgcGllY2VzXG4gICAqIGluIG9yZGVyIHRvIGRldGVybWluZSB0aGUgcG9pbnQgdG8gYnJlYWsgYSB3b3JkLlxuICAgKiBJdCBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gdG9rZW4gLSBUaGUgdG9rZW4gdG8gc3BsaXRcbiAgICogQHJldHVybnMgVGhlIGNoYXJhY3RlcnMgb2YgdGhlIHRva2VuXG4gICAqIEBzZWUgVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXJcbiAgICovXG4gIHN0YXRpYyB3b3JkV3JhcFNwbGl0KHRva2VuKSB7XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljczIuZ3JhcGhlbWVTZWdtZW50ZXIodG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udC1zdHlsZVxuICAgKiBAcGFyYW0gZm9udCAtIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0eWxlIG9mIHRoZSBmb250XG4gICAqIEByZXR1cm5zIEZvbnQgcHJvcGVydGllcyBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBtZWFzdXJlRm9udChmb250KSB7XG4gICAgaWYgKF9UZXh0TWV0cmljczIuX2ZvbnRzW2ZvbnRdKVxuICAgICAgcmV0dXJuIF9UZXh0TWV0cmljczIuX2ZvbnRzW2ZvbnRdO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBkZXNjZW50OiAwLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9LCBjYW52YXMgPSBfVGV4dE1ldHJpY3MyLl9jYW52YXMsIGNvbnRleHQgPSBfVGV4dE1ldHJpY3MyLl9jb250ZXh0O1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3QgbWV0cmljc1N0cmluZyA9IF9UZXh0TWV0cmljczIuTUVUUklDU19TVFJJTkcgKyBfVGV4dE1ldHJpY3MyLkJBU0VMSU5FX1NZTUJPTCwgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChtZXRyaWNzU3RyaW5nKS53aWR0aCk7XG4gICAgbGV0IGJhc2VsaW5lID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoX1RleHRNZXRyaWNzMi5CQVNFTElORV9TWU1CT0wpLndpZHRoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoX1RleHRNZXRyaWNzMi5IRUlHSFRfTVVMVElQTElFUiAqIGJhc2VsaW5lKTtcbiAgICBpZiAoYmFzZWxpbmUgPSBiYXNlbGluZSAqIF9UZXh0TWV0cmljczIuQkFTRUxJTkVfTVVMVElQTElFUiB8IDAsIHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMClcbiAgICAgIHJldHVybiBfVGV4dE1ldHJpY3MyLl9mb250c1tmb250XSA9IHByb3BlcnRpZXMsIHByb3BlcnRpZXM7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGgsIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQsIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjZjAwXCIsIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCksIGNvbnRleHQuZm9udCA9IGZvbnQsIGNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCIsIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjMDAwXCIsIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xuICAgIGNvbnN0IGltYWdlZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGEsIHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGgsIGxpbmUgPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwLCBpZHggPSAwLCBzdG9wID0gITE7XG4gICAgZm9yIChpID0gMDsgaSA8IGJhc2VsaW5lOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZTsgaiArPSA0KVxuICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICBzdG9wID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGlmICghc3RvcClcbiAgICAgICAgaWR4ICs9IGxpbmU7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpLCBpZHggPSBwaXhlbHMgLSBsaW5lLCBzdG9wID0gITEsIGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgLS1pKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcbiAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XG4gICAgICAgICAgc3RvcCA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBpZiAoIXN0b3ApXG4gICAgICAgIGlkeCAtPSBsaW5lO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXMuZGVzY2VudCA9IGkgLSBiYXNlbGluZSwgcHJvcGVydGllcy5mb250U2l6ZSA9IHByb3BlcnRpZXMuYXNjZW50ICsgcHJvcGVydGllcy5kZXNjZW50LCBfVGV4dE1ldHJpY3MyLl9mb250c1tmb250XSA9IHByb3BlcnRpZXMsIHByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGZvbnQgbWV0cmljcyBpbiBtZXRyaWNzIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXG4gICAqL1xuICBzdGF0aWMgY2xlYXJNZXRyaWNzKGZvbnQgPSBcIlwiKSB7XG4gICAgZm9udCA/IGRlbGV0ZSBfVGV4dE1ldHJpY3MyLl9mb250c1tmb250XSA6IF9UZXh0TWV0cmljczIuX2ZvbnRzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIENhY2hlZCBjYW52YXMgZWxlbWVudCBmb3IgbWVhc3VyaW5nIHRleHRcbiAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IGlzbid0IGJlY2F1c2Ugb2YgYmFja3dhcmQgY29tcGF0LCB3aWxsIGZpeCBsYXRlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGdldCBfY2FudmFzKCkge1xuICAgIGlmICghX1RleHRNZXRyaWNzMi5fX2NhbnZhcykge1xuICAgICAgbGV0IGNhbnZhcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBpZiAoYy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKT8ubWVhc3VyZVRleHQpXG4gICAgICAgICAgcmV0dXJuIF9UZXh0TWV0cmljczIuX19jYW52YXMgPSBjLCBjO1xuICAgICAgICBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTAsIF9UZXh0TWV0cmljczIuX19jYW52YXMgPSBjYW52YXM7XG4gICAgfVxuICAgIHJldHVybiBfVGV4dE1ldHJpY3MyLl9fY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBUT0RPOiB0aGlzIHNob3VsZCBiZSBwcml2YXRlLCBidXQgaXNuJ3QgYmVjYXVzZSBvZiBiYWNrd2FyZCBjb21wYXQsIHdpbGwgZml4IGxhdGVyLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgZ2V0IF9jb250ZXh0KCkge1xuICAgIHJldHVybiBfVGV4dE1ldHJpY3MyLl9fY29udGV4dCB8fCAoX1RleHRNZXRyaWNzMi5fX2NvbnRleHQgPSBfVGV4dE1ldHJpY3MyLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncykpLCBfVGV4dE1ldHJpY3MyLl9fY29udGV4dDtcbiAgfVxufTtcbl9UZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyA9IFwifFxceEM5cVxceEM1XCIsIC8qKiBCYXNlbGluZSBzeW1ib2wgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuICovXG5fVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MID0gXCJNXCIsIC8qKiBCYXNlbGluZSBtdWx0aXBsaWVyIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLiAqL1xuX1RleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgPSAxLjQsIC8qKiBIZWlnaHQgbXVsdGlwbGllciBmb3Igc2V0dGluZyBoZWlnaHQgb2YgY2FudmFzIHRvIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuICovXG5fVGV4dE1ldHJpY3MuSEVJR0hUX01VTFRJUExJRVIgPSAyLCAvKipcbiogQSBVbmljb2RlIFwiY2hhcmFjdGVyXCIsIG9yIFwiZ3JhcGhlbWUgY2x1c3RlclwiLCBjYW4gYmUgY29tcG9zZWQgb2YgbXVsdGlwbGUgVW5pY29kZSBjb2RlIHBvaW50cyxcbiogc3VjaCBhcyBsZXR0ZXJzIHdpdGggZGlhY3JpdGljYWwgbWFya3MgKGUuZy4gYCdcXHUwMDY1XFx1MDMwMSdgLCBsZXR0ZXIgZSB3aXRoIGFjdXRlKVxuKiBvciBlbW9qaXMgd2l0aCBtb2RpZmllcnMgKGUuZy4gYCdcXHVEODNFXFx1REREMVxcdTIwMERcXHVEODNEXFx1RENCQidgLCB0ZWNobm9sb2dpc3QpLlxuKiBUaGUgbmV3IGBJbnRsLlNlZ21lbnRlcmAgQVBJIGluIEVTMjAyMiBjYW4gc3BsaXQgdGhlIHN0cmluZyBpbnRvIGdyYXBoZW1lIGNsdXN0ZXJzIGNvcnJlY3RseS4gSWYgaXQgaXMgbm90IGF2YWlsYWJsZSxcbiogUGl4aUpTIHdpbGwgZmFsbGJhY2sgdG8gdXNlIHRoZSBpdGVyYXRvciBvZiBTdHJpbmcsIHdoaWNoIGNhbiBvbmx5IHNwaWx0IHRoZSBzdHJpbmcgaW50byBjb2RlIHBvaW50cy5cbiogSWYgeW91IHdhbnQgdG8gZ2V0IGZ1bGwgZnVuY3Rpb25hbGl0eSBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IGBJbnRsLlNlZ21lbnRlcmAgKHN1Y2ggYXMgRmlyZWZveCksXG4qIHlvdSBjYW4gdXNlIG90aGVyIGxpYnJhcmllcyBzdWNoIGFzIFtncmFwaGVtZS1zcGxpdHRlcl17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ3JhcGhlbWUtc3BsaXR0ZXJ9XG4qIG9yIFtncmFwaGVtZXJde0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dyYXBoZW1lcn0gdG8gY3JlYXRlIGEgcG9seWZpbGwuIFNpbmNlIHRoZXNlIGxpYnJhcmllcyBjYW4gYmVcbiogcmVsYXRpdmVseSBsYXJnZSBpbiBzaXplIHRvIGhhbmRsZSB2YXJpb3VzIFVuaWNvZGUgZ3JhcGhlbWUgY2x1c3RlcnMgcHJvcGVybHksIFBpeGlKUyB3b24ndCB1c2UgdGhlbSBkaXJlY3RseS5cbiovXG5fVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIgPSAoKCkgPT4ge1xuICBpZiAodHlwZW9mIEludGw/LlNlZ21lbnRlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIoKTtcbiAgICByZXR1cm4gKHMpID0+IFsuLi5zZWdtZW50ZXIuc2VnbWVudChzKV0ubWFwKCh4KSA9PiB4LnNlZ21lbnQpO1xuICB9XG4gIHJldHVybiAocykgPT4gWy4uLnNdO1xufSkoKSwgLyoqXG4qIE5ldyByZW5kZXJpbmcgYmVoYXZpb3IgZm9yIGxldHRlci1zcGFjaW5nIHdoaWNoIHVzZXMgQ2hyb21lJ3MgbmV3IG5hdGl2ZSBBUEkuIFRoaXMgd2lsbFxuKiBsZWFkIHRvIG1vcmUgYWNjdXJhdGUgbGV0dGVyLXNwYWNpbmcgcmVzdWx0cyBiZWNhdXNlIGl0IGRvZXMgbm90IHRyeSB0byBtYW51YWxseSBkcmF3XG4qIGVhY2ggY2hhcmFjdGVyLiBIb3dldmVyLCB0aGlzIENocm9tZSBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgbm90IHNlcnZlIGFsbCBjYXNlcyB5ZXQuXG4qIEBzZWUgUElYSS5UZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkXG4qL1xuX1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSAhMSwgLyoqIENhY2hlIG9mIHtAc2VlIFBJWEkuVGV4dE1ldHJpY3MuRm9udE1ldHJpY3N9IG9iamVjdHMuICovXG5fVGV4dE1ldHJpY3MuX2ZvbnRzID0ge30sIC8qKiBDYWNoZSBvZiBuZXcgbGluZSBjaGFycy4gKi9cbl9UZXh0TWV0cmljcy5fbmV3bGluZXMgPSBbXG4gIDEwLFxuICAvLyBsaW5lIGZlZWRcbiAgMTNcbiAgLy8gY2FycmlhZ2UgcmV0dXJuXG5dLCAvKiogQ2FjaGUgb2YgYnJlYWtpbmcgc3BhY2VzLiAqL1xuX1RleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFtcbiAgOSxcbiAgLy8gY2hhcmFjdGVyIHRhYnVsYXRpb25cbiAgMzIsXG4gIC8vIHNwYWNlXG4gIDgxOTIsXG4gIC8vIGVuIHF1YWRcbiAgODE5MyxcbiAgLy8gZW0gcXVhZFxuICA4MTk0LFxuICAvLyBlbiBzcGFjZVxuICA4MTk1LFxuICAvLyBlbSBzcGFjZVxuICA4MTk2LFxuICAvLyB0aHJlZS1wZXItZW0gc3BhY2VcbiAgODE5NyxcbiAgLy8gZm91ci1wZXItZW0gc3BhY2VcbiAgODE5OCxcbiAgLy8gc2l4LXBlci1lbSBzcGFjZVxuICA4MjAwLFxuICAvLyBwdW5jdHVhdGlvbiBzcGFjZVxuICA4MjAxLFxuICAvLyB0aGluIHNwYWNlXG4gIDgyMDIsXG4gIC8vIGhhaXIgc3BhY2VcbiAgODI4NyxcbiAgLy8gbWVkaXVtIG1hdGhlbWF0aWNhbCBzcGFjZVxuICAxMjI4OFxuICAvLyBpZGVvZ3JhcGhpYyBzcGFjZVxuXTtcbmxldCBUZXh0TWV0cmljcyA9IF9UZXh0TWV0cmljcztcbmV4cG9ydCB7XG4gIFRleHRNZXRyaWNzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dE1ldHJpY3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gXCIuL2NvbnN0Lm1qc1wiO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuY29uc3QgZ2VuZXJpY0ZvbnRGYW1pbGllcyA9IFtcbiAgXCJzZXJpZlwiLFxuICBcInNhbnMtc2VyaWZcIixcbiAgXCJtb25vc3BhY2VcIixcbiAgXCJjdXJzaXZlXCIsXG4gIFwiZmFudGFzeVwiLFxuICBcInN5c3RlbS11aVwiXG5dLCBfVGV4dFN0eWxlID0gY2xhc3MgX1RleHRTdHlsZTIge1xuICAvKipcbiAgICogQHBhcmFtIHN0eWxlIC0gVGV4dFN0eWxlIHByb3BlcnRpZXMgdG8gYmUgc2V0IG9uIHRoZSB0ZXh0LiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmRlZmF1bHRTdHlsZX1cbiAgICogICAgICAgZm9yIHRoZSBkZWZhdWx0IHZhbHVlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZUlEID0gMCwgdGhpcy5yZXNldCgpLCBkZWVwQ29weVByb3BlcnRpZXModGhpcywgc3R5bGUsIHN0eWxlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUZXh0U3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBOb3RlIHRoYXQgdGhlIG9ubHkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBhcmUgY2xvbmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIE5ldyBjbG9uZWQgVGV4dFN0eWxlIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xuICAgIHJldHVybiBkZWVwQ29weVByb3BlcnRpZXMoY2xvbmVkUHJvcGVydGllcywgdGhpcywgX1RleHRTdHlsZTIuZGVmYXVsdFN0eWxlKSwgbmV3IF9UZXh0U3R5bGUyKGNsb25lZFByb3BlcnRpZXMpO1xuICB9XG4gIC8qKiBSZXNldHMgYWxsIHByb3BlcnRpZXMgdG8gdGhlIGRlZmF1bHRzIHNwZWNpZmllZCBpbiBUZXh0U3R5bGUucHJvdG90eXBlLl9kZWZhdWx0ICovXG4gIHJlc2V0KCkge1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBfVGV4dFN0eWxlMi5kZWZhdWx0U3R5bGUsIF9UZXh0U3R5bGUyLmRlZmF1bHRTdHlsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQsIGRvZXMgbm90IGFmZmVjdCBzaW5nbGUgbGluZSB0ZXh0LlxuICAgKlxuICAgKiBAbWVtYmVyIHsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J3wnanVzdGlmeSd9XG4gICAqL1xuICBnZXQgYWxpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICB9XG4gIHNldCBhbGlnbihhbGlnbikge1xuICAgIHRoaXMuX2FsaWduICE9PSBhbGlnbiAmJiAodGhpcy5fYWxpZ24gPSBhbGlnbiwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBJbmRpY2F0ZXMgaWYgbGluZXMgY2FuIGJlIHdyYXBwZWQgd2l0aGluIHdvcmRzLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZS4gKi9cbiAgZ2V0IGJyZWFrV29yZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyZWFrV29yZHM7XG4gIH1cbiAgc2V0IGJyZWFrV29yZHMoYnJlYWtXb3Jkcykge1xuICAgIHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMgJiYgKHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dC4gKi9cbiAgZ2V0IGRyb3BTaGFkb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3c7XG4gIH1cbiAgc2V0IGRyb3BTaGFkb3coZHJvcFNoYWRvdykge1xuICAgIHRoaXMuX2Ryb3BTaGFkb3cgIT09IGRyb3BTaGFkb3cgJiYgKHRoaXMuX2Ryb3BTaGFkb3cgPSBkcm9wU2hhZG93LCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFNldCBhbHBoYSBmb3IgdGhlIGRyb3Agc2hhZG93LiAqL1xuICBnZXQgZHJvcFNoYWRvd0FscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93QWxwaGE7XG4gIH1cbiAgc2V0IGRyb3BTaGFkb3dBbHBoYShkcm9wU2hhZG93QWxwaGEpIHtcbiAgICB0aGlzLl9kcm9wU2hhZG93QWxwaGEgIT09IGRyb3BTaGFkb3dBbHBoYSAmJiAodGhpcy5fZHJvcFNoYWRvd0FscGhhID0gZHJvcFNoYWRvd0FscGhhLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvdy4gKi9cbiAgZ2V0IGRyb3BTaGFkb3dBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QW5nbGUoZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgdGhpcy5fZHJvcFNoYWRvd0FuZ2xlICE9PSBkcm9wU2hhZG93QW5nbGUgJiYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSA9IGRyb3BTaGFkb3dBbmdsZSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBTZXQgYSBzaGFkb3cgYmx1ciByYWRpdXMuICovXG4gIGdldCBkcm9wU2hhZG93Qmx1cigpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0JsdXI7XG4gIH1cbiAgc2V0IGRyb3BTaGFkb3dCbHVyKGRyb3BTaGFkb3dCbHVyKSB7XG4gICAgdGhpcy5fZHJvcFNoYWRvd0JsdXIgIT09IGRyb3BTaGFkb3dCbHVyICYmICh0aGlzLl9kcm9wU2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZy4sICdyZWQnLCAnIzAwRkYwMCcuICovXG4gIGdldCBkcm9wU2hhZG93Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dDb2xvcjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0NvbG9yKGRyb3BTaGFkb3dDb2xvcikge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICB0aGlzLl9kcm9wU2hhZG93Q29sb3IgIT09IG91dHB1dENvbG9yICYmICh0aGlzLl9kcm9wU2hhZG93Q29sb3IgPSBvdXRwdXRDb2xvciwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBTZXQgYSBkaXN0YW5jZSBvZiB0aGUgZHJvcCBzaGFkb3cuICovXG4gIGdldCBkcm9wU2hhZG93RGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZTtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0Rpc3RhbmNlKGRyb3BTaGFkb3dEaXN0YW5jZSkge1xuICAgIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSAhPT0gZHJvcFNoYWRvd0Rpc3RhbmNlICYmICh0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgPSBkcm9wU2hhZG93RGlzdGFuY2UsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZy4sICdyZWQnLCAnIzAwRkYwMCcuXG4gICAqXG4gICAqIENhbiBiZSBhbiBhcnJheSB0byBjcmVhdGUgYSBncmFkaWVudCBlLmcuLCBgWycjMDAwMDAwJywnI0ZGRkZGRiddYFxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9maWxsU3R5bGV8TUROfVxuICAgKlxuICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XG4gICAqL1xuICBnZXQgZmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbDtcbiAgfVxuICBzZXQgZmlsbChmaWxsKSB7XG4gICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihmaWxsKTtcbiAgICB0aGlzLl9maWxsICE9PSBvdXRwdXRDb2xvciAmJiAodGhpcy5fZmlsbCA9IG91dHB1dENvbG9yLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGZpbGwgaXMgYW4gYXJyYXkgb2YgY29sb3VycyB0byBjcmVhdGUgYSBncmFkaWVudCwgdGhpcyBjYW4gY2hhbmdlIHRoZSB0eXBlL2RpcmVjdGlvbiBvZiB0aGUgZ3JhZGllbnQuXG4gICAqXG4gICAqIEB0eXBlIHtQSVhJLlRFWFRfR1JBRElFTlR9XG4gICAqL1xuICBnZXQgZmlsbEdyYWRpZW50VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50VHlwZTtcbiAgfVxuICBzZXQgZmlsbEdyYWRpZW50VHlwZShmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgdGhpcy5fZmlsbEdyYWRpZW50VHlwZSAhPT0gZmlsbEdyYWRpZW50VHlwZSAmJiAodGhpcy5fZmlsbEdyYWRpZW50VHlwZSA9IGZpbGxHcmFkaWVudFR5cGUsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGFycmF5IGNhbiBzZXQgdGhlIHN0b3AgcG9pbnRzXG4gICAqIChudW1iZXJzIGJldHdlZW4gMCBhbmQgMSkgZm9yIHRoZSBjb2xvciwgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgZXZlbmx5IHNwYWNpbmcgdGhlbS5cbiAgICovXG4gIGdldCBmaWxsR3JhZGllbnRTdG9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50U3RvcHM7XG4gIH1cbiAgc2V0IGZpbGxHcmFkaWVudFN0b3BzKGZpbGxHcmFkaWVudFN0b3BzKSB7XG4gICAgYXJlQXJyYXlzRXF1YWwodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMsIGZpbGxHcmFkaWVudFN0b3BzKSB8fCAodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMgPSBmaWxsR3JhZGllbnRTdG9wcywgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCBmYW1pbHksIGNhbiBiZSBhIHNpbmdsZSBmb250IG5hbWUsIG9yIGEgbGlzdCBvZiBuYW1lcyB3aGVyZSB0aGUgZmlyc3RcbiAgICogaXMgdGhlIHByZWZlcnJlZCBmb250LlxuICAgKi9cbiAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRGYW1pbHk7XG4gIH1cbiAgc2V0IGZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSAmJiAodGhpcy5fZm9udEZhbWlseSA9IGZvbnRGYW1pbHksIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvbnQgc2l6ZVxuICAgKiAoYXMgYSBudW1iZXIgaXQgY29udmVydHMgdG8gcHgsIGJ1dCBhcyBhIHN0cmluZywgZXF1aXZhbGVudHMgYXJlICcyNnB4JywnMjBwdCcsJzE2MCUnIG9yICcxLjZlbScpXG4gICAqL1xuICBnZXQgZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplO1xuICB9XG4gIHNldCBmb250U2l6ZShmb250U2l6ZSkge1xuICAgIHRoaXMuX2ZvbnRTaXplICE9PSBmb250U2l6ZSAmJiAodGhpcy5fZm9udFNpemUgPSBmb250U2l6ZSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCBzdHlsZS5cbiAgICpcbiAgICogQG1lbWJlciB7J25vcm1hbCd8J2l0YWxpYyd8J29ibGlxdWUnfVxuICAgKi9cbiAgZ2V0IGZvbnRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICB9XG4gIHNldCBmb250U3R5bGUoZm9udFN0eWxlKSB7XG4gICAgdGhpcy5fZm9udFN0eWxlICE9PSBmb250U3R5bGUgJiYgKHRoaXMuX2ZvbnRTdHlsZSA9IGZvbnRTdHlsZSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCB2YXJpYW50LlxuICAgKlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnc21hbGwtY2Fwcyd9XG4gICAqL1xuICBnZXQgZm9udFZhcmlhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICB9XG4gIHNldCBmb250VmFyaWFudChmb250VmFyaWFudCkge1xuICAgIHRoaXMuX2ZvbnRWYXJpYW50ICE9PSBmb250VmFyaWFudCAmJiAodGhpcy5fZm9udFZhcmlhbnQgPSBmb250VmFyaWFudCwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCB3ZWlnaHQuXG4gICAqXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdib2xkJ3wnYm9sZGVyJ3wnbGlnaHRlcid8JzEwMCd8JzIwMCd8JzMwMCd8JzQwMCd8JzUwMCd8JzYwMCd8JzcwMCd8JzgwMCd8JzkwMCd9XG4gICAqL1xuICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgfVxuICBzZXQgZm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgdGhpcy5fZm9udFdlaWdodCAhPT0gZm9udFdlaWdodCAmJiAodGhpcy5fZm9udFdlaWdodCA9IGZvbnRXZWlnaHQsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycywgZGVmYXVsdCBpcyAwLiAqL1xuICBnZXQgbGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgfVxuICBzZXQgbGV0dGVyU3BhY2luZyhsZXR0ZXJTcGFjaW5nKSB7XG4gICAgdGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZyAmJiAodGhpcy5fbGV0dGVyU3BhY2luZyA9IGxldHRlclNwYWNpbmcsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogVGhlIGxpbmUgaGVpZ2h0LCBhIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIHNwYWNlIHRoYXQgYSBsZXR0ZXIgdXNlcy4gKi9cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gIH1cbiAgc2V0IGxpbmVIZWlnaHQobGluZUhlaWdodCkge1xuICAgIHRoaXMuX2xpbmVIZWlnaHQgIT09IGxpbmVIZWlnaHQgJiYgKHRoaXMuX2xpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0LCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzLiAqL1xuICBnZXQgbGVhZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgfVxuICBzZXQgbGVhZGluZyhsZWFkaW5nKSB7XG4gICAgdGhpcy5fbGVhZGluZyAhPT0gbGVhZGluZyAmJiAodGhpcy5fbGVhZGluZyA9IGxlYWRpbmcsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlIHNwaWtlZCB0ZXh0IGlzc3Vlcy5cbiAgICogRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cbiAgICpcbiAgICogQG1lbWJlciB7J21pdGVyJ3wncm91bmQnfCdiZXZlbCd9XG4gICAqL1xuICBnZXQgbGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVKb2luO1xuICB9XG4gIHNldCBsaW5lSm9pbihsaW5lSm9pbikge1xuICAgIHRoaXMuX2xpbmVKb2luICE9PSBsaW5lSm9pbiAmJiAodGhpcy5fbGluZUpvaW4gPSBsaW5lSm9pbiwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWl0ZXIgbGltaXQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdtaXRlcicgbGluZUpvaW4gbW9kZS5cbiAgICpcbiAgICogVGhpcyBjYW4gcmVkdWNlIG9yIGluY3JlYXNlIHRoZSBzcGlraW5lc3Mgb2YgcmVuZGVyZWQgdGV4dC5cbiAgICovXG4gIGdldCBtaXRlckxpbWl0KCkge1xuICAgIHJldHVybiB0aGlzLl9taXRlckxpbWl0O1xuICB9XG4gIHNldCBtaXRlckxpbWl0KG1pdGVyTGltaXQpIHtcbiAgICB0aGlzLl9taXRlckxpbWl0ICE9PSBtaXRlckxpbWl0ICYmICh0aGlzLl9taXRlckxpbWl0ID0gbWl0ZXJMaW1pdCwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgKiBieSBhZGRpbmcgcGFkZGluZyB0byBhbGwgc2lkZXMgb2YgdGhlIHRleHQuXG4gICAqL1xuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgfVxuICBzZXQgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgdGhpcy5fcGFkZGluZyAhPT0gcGFkZGluZyAmJiAodGhpcy5fcGFkZGluZyA9IHBhZGRpbmcsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZSwgZS5nLiwgJ2JsdWUnLCAnI0ZDRkYwMCdcbiAgICovXG4gIGdldCBzdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZTtcbiAgfVxuICBzZXQgc3Ryb2tlKHN0cm9rZSkge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3Ioc3Ryb2tlKTtcbiAgICB0aGlzLl9zdHJva2UgIT09IG91dHB1dENvbG9yICYmICh0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvciwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VUaGlja25lc3M7XG4gIH1cbiAgc2V0IHN0cm9rZVRoaWNrbmVzcyhzdHJva2VUaGlja25lc3MpIHtcbiAgICB0aGlzLl9zdHJva2VUaGlja25lc3MgIT09IHN0cm9rZVRoaWNrbmVzcyAmJiAodGhpcy5fc3Ryb2tlVGhpY2tuZXNzID0gc3Ryb2tlVGhpY2tuZXNzLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlbGluZSBvZiB0aGUgdGV4dCB0aGF0IGlzIHJlbmRlcmVkLlxuICAgKlxuICAgKiBAbWVtYmVyIHsnYWxwaGFiZXRpYyd8J3RvcCd8J2hhbmdpbmcnfCdtaWRkbGUnfCdpZGVvZ3JhcGhpYyd8J2JvdHRvbSd9XG4gICAqL1xuICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gIH1cbiAgc2V0IHRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICB0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSAmJiAodGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVycy4gKi9cbiAgZ2V0IHRyaW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gIH1cbiAgc2V0IHRyaW0odHJpbSkge1xuICAgIHRoaXMuX3RyaW0gIT09IHRyaW0gJiYgKHRoaXMuX3RyaW0gPSB0cmltLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIEhvdyBuZXdsaW5lcyBhbmQgc3BhY2VzIHNob3VsZCBiZSBoYW5kbGVkLlxuICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxuICAgKlxuICAgKiAgdmFsdWUgICAgICAgfCBOZXcgbGluZXMgICAgIHwgICBTcGFjZXNcbiAgICogIC0tLSAgICAgICAgIHwgLS0tICAgICAgICAgICB8ICAgLS0tXG4gICAqICdub3JtYWwnICAgICB8IENvbGxhcHNlICAgICAgfCAgIENvbGxhcHNlXG4gICAqICdwcmUnICAgICAgICB8IFByZXNlcnZlICAgICAgfCAgIFByZXNlcnZlXG4gICAqICdwcmUtbGluZScgICB8IFByZXNlcnZlICAgICAgfCAgIENvbGxhcHNlXG4gICAqXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdwcmUnfCdwcmUtbGluZSd9XG4gICAqL1xuICBnZXQgd2hpdGVTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2hpdGVTcGFjZTtcbiAgfVxuICBzZXQgd2hpdGVTcGFjZSh3aGl0ZVNwYWNlKSB7XG4gICAgdGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSAmJiAodGhpcy5fd2hpdGVTcGFjZSA9IHdoaXRlU3BhY2UsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZC4gKi9cbiAgZ2V0IHdvcmRXcmFwKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgfVxuICBzZXQgd29yZFdyYXAod29yZFdyYXApIHtcbiAgICB0aGlzLl93b3JkV3JhcCAhPT0gd29yZFdyYXAgJiYgKHRoaXMuX3dvcmRXcmFwID0gd29yZFdyYXAsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZS4gKi9cbiAgZ2V0IHdvcmRXcmFwV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gIH1cbiAgc2V0IHdvcmRXcmFwV2lkdGgod29yZFdyYXBXaWR0aCkge1xuICAgIHRoaXMuX3dvcmRXcmFwV2lkdGggIT09IHdvcmRXcmFwV2lkdGggJiYgKHRoaXMuX3dvcmRXcmFwV2lkdGggPSB3b3JkV3JhcFdpZHRoLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGZvbnQgc3R5bGUgc3RyaW5nIHRvIHVzZSBmb3IgYFRleHRNZXRyaWNzLm1lYXN1cmVGb250KClgLlxuICAgKlxuICAgKiBAcmV0dXJuIEZvbnQgc3R5bGUgc3RyaW5nLCBmb3IgcGFzc2luZyB0byBgVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoKWBcbiAgICovXG4gIHRvRm9udFN0cmluZygpIHtcbiAgICBjb25zdCBmb250U2l6ZVN0cmluZyA9IHR5cGVvZiB0aGlzLmZvbnRTaXplID09IFwibnVtYmVyXCIgPyBgJHt0aGlzLmZvbnRTaXplfXB4YCA6IHRoaXMuZm9udFNpemU7XG4gICAgbGV0IGZvbnRGYW1pbGllcyA9IHRoaXMuZm9udEZhbWlseTtcbiAgICBBcnJheS5pc0FycmF5KHRoaXMuZm9udEZhbWlseSkgfHwgKGZvbnRGYW1pbGllcyA9IHRoaXMuZm9udEZhbWlseS5zcGxpdChcIixcIikpO1xuICAgIGZvciAobGV0IGkgPSBmb250RmFtaWxpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb250RmFtaWx5ID0gZm9udEZhbWlsaWVzW2ldLnRyaW0oKTtcbiAgICAgICEvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS8udGVzdChmb250RmFtaWx5KSAmJiAhZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmNsdWRlcyhmb250RmFtaWx5KSAmJiAoZm9udEZhbWlseSA9IGBcIiR7Zm9udEZhbWlseX1cImApLCBmb250RmFtaWxpZXNbaV0gPSBmb250RmFtaWx5O1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5mb250U3R5bGV9ICR7dGhpcy5mb250VmFyaWFudH0gJHt0aGlzLmZvbnRXZWlnaHR9ICR7Zm9udFNpemVTdHJpbmd9ICR7Zm9udEZhbWlsaWVzLmpvaW4oXCIsXCIpfWA7XG4gIH1cbn07XG5fVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSA9IHtcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuYWxpZ259XG4gICAqIEB0eXBlIHsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J3wnanVzdGlmeSd9XG4gICAqL1xuICBhbGlnbjogXCJsZWZ0XCIsXG4gIC8qKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmJyZWFrV29yZHN9ICovXG4gIGJyZWFrV29yZHM6ICExLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5kcm9wU2hhZG93fSAqL1xuICBkcm9wU2hhZG93OiAhMSxcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZHJvcFNoYWRvd0FscGhhfSAqL1xuICBkcm9wU2hhZG93QWxwaGE6IDEsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmRyb3BTaGFkb3dBbmdsZX1cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgTWF0aC5QSSAvIDZcbiAgICovXG4gIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gIC8qKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmRyb3BTaGFkb3dCbHVyfSAqL1xuICBkcm9wU2hhZG93Qmx1cjogMCxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZHJvcFNoYWRvd0NvbG9yfVxuICAgKiBAdHlwZSB7c3RyaW5nfG51bWJlcn1cbiAgICovXG4gIGRyb3BTaGFkb3dDb2xvcjogXCJibGFja1wiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5kcm9wU2hhZG93RGlzdGFuY2V9ICovXG4gIGRyb3BTaGFkb3dEaXN0YW5jZTogNSxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZmlsbH1cbiAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW118Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybn1cbiAgICovXG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZmlsbEdyYWRpZW50VHlwZX1cbiAgICogQHR5cGUge1BJWEkuVEVYVF9HUkFESUVOVH1cbiAgICogQGRlZmF1bHQgUElYSS5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTFxuICAgKi9cbiAgZmlsbEdyYWRpZW50VHlwZTogVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZpbGxHcmFkaWVudFN0b3BzfVxuICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICBmaWxsR3JhZGllbnRTdG9wczogW10sXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZvbnRGYW1pbHl9XG4gICAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG4gICAqL1xuICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZvbnRTaXplfVxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ30gXG4gICAqL1xuICBmb250U2l6ZTogMjYsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZvbnRTdHlsZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdpdGFsaWMnfCdvYmxpcXVlJ31cbiAgICovXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZm9udFZhcmlhbnR9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wnc21hbGwtY2Fwcyd9XG4gICAqL1xuICBmb250VmFyaWFudDogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZm9udFdlaWdodH1cbiAgICogQHR5cGUgeydub3JtYWwnfCdib2xkJ3wnYm9sZGVyJ3wnbGlnaHRlcid8JzEwMCd8JzIwMCd8JzMwMCd8JzQwMCd8JzUwMCd8JzYwMCd8JzcwMCd8JzgwMCd8JzkwMCd9XG4gICAqL1xuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5sZWFkaW5nfSAqL1xuICBsZWFkaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5sZXR0ZXJTcGFjaW5nfSAqL1xuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5saW5lSGVpZ2h0fSAqL1xuICBsaW5lSGVpZ2h0OiAwLFxuICAvKipcbiAgICogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5saW5lSm9pbn1cbiAgICogQHR5cGUgeydtaXRlcid8J3JvdW5kJ3wnYmV2ZWwnfVxuICAgKi9cbiAgbGluZUpvaW46IFwibWl0ZXJcIixcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUubWl0ZXJMaW1pdH0gKi9cbiAgbWl0ZXJMaW1pdDogMTAsXG4gIC8qKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLnBhZGRpbmd9ICovXG4gIHBhZGRpbmc6IDAsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLnN0cm9rZX1cbiAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAqL1xuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuc3Ryb2tlVGhpY2tuZXNzfSAqL1xuICBzdHJva2VUaGlja25lc3M6IDAsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLnRleHRCYXNlbGluZX0gXG4gICAqIEB0eXBlIHsnYWxwaGFiZXRpYyd8J3RvcCd8J2hhbmdpbmcnfCdtaWRkbGUnfCdpZGVvZ3JhcGhpYyd8J2JvdHRvbSd9XG4gICAqL1xuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS50cmltfSAqL1xuICB0cmltOiAhMSxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUud2hpdGVTcGFjZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdwcmUnfCdwcmUtbGluZSd9XG4gICAqL1xuICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS53b3JkV3JhcH0gKi9cbiAgd29yZFdyYXA6ICExLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS53b3JkV3JhcFdpZHRofSAqL1xuICB3b3JkV3JhcFdpZHRoOiAxMDBcbn07XG5sZXQgVGV4dFN0eWxlID0gX1RleHRTdHlsZTtcbmZ1bmN0aW9uIGdldENvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IHRlbXAgPSBDb2xvci5zaGFyZWQsIGZvcm1hdCA9IChjb2xvcjIpID0+IHtcbiAgICBjb25zdCByZXMgPSB0ZW1wLnNldFZhbHVlKGNvbG9yMik7XG4gICAgcmV0dXJuIHJlcy5hbHBoYSA9PT0gMSA/IHJlcy50b0hleCgpIDogcmVzLnRvUmdiYVN0cmluZygpO1xuICB9O1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvci5tYXAoZm9ybWF0KSA6IGZvcm1hdChjb2xvcik7XG59XG5mdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhcnJheTEsIGFycmF5Mikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkxKSB8fCAhQXJyYXkuaXNBcnJheShhcnJheTIpIHx8IGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSlcbiAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5T2JqKVxuICAgIEFycmF5LmlzQXJyYXkoc291cmNlW3Byb3BdKSA/IHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXS5zbGljZSgpIDogdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xufVxuZXhwb3J0IHtcbiAgVGV4dFN0eWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFN0eWxlLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCBUZXh0dXJlLCBSZWN0YW5nbGUsIHV0aWxzLCBDb2xvciB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tIFwiQHBpeGkvc3ByaXRlXCI7XG5pbXBvcnQgeyBURVhUX0dSQURJRU5UIH0gZnJvbSBcIi4vY29uc3QubWpzXCI7XG5pbXBvcnQgeyBUZXh0TWV0cmljcyB9IGZyb20gXCIuL1RleHRNZXRyaWNzLm1qc1wiO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSBcIi4vVGV4dFN0eWxlLm1qc1wiO1xuY29uc3QgZGVmYXVsdERlc3Ryb3lPcHRpb25zID0ge1xuICB0ZXh0dXJlOiAhMCxcbiAgY2hpbGRyZW46ICExLFxuICBiYXNlVGV4dHVyZTogITBcbn0sIF9UZXh0ID0gY2xhc3MgX1RleHQyIGV4dGVuZHMgU3ByaXRlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHN0cmluZyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIGNhbnZhcyAtIFRoZSBjYW52YXMgZWxlbWVudCBmb3IgZHJhd2luZyB0ZXh0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSwgY2FudmFzKSB7XG4gICAgbGV0IG93bkNhbnZhcyA9ICExO1xuICAgIGNhbnZhcyB8fCAoY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKSwgb3duQ2FudmFzID0gITApLCBjYW52YXMud2lkdGggPSAzLCBjYW52YXMuaGVpZ2h0ID0gMztcbiAgICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tKGNhbnZhcyk7XG4gICAgdGV4dHVyZS5vcmlnID0gbmV3IFJlY3RhbmdsZSgpLCB0ZXh0dXJlLnRyaW0gPSBuZXcgUmVjdGFuZ2xlKCksIHN1cGVyKHRleHR1cmUpLCB0aGlzLl9vd25DYW52YXMgPSBvd25DYW52YXMsIHRoaXMuY2FudmFzID0gY2FudmFzLCB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIC8vIHJlcXVpcmVkIGZvciB0cmltbWluZyB0byB3b3JrIHdpdGhvdXQgd2FybmluZ3NcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogITBcbiAgICB9KSwgdGhpcy5fcmVzb2x1dGlvbiA9IF9UZXh0Mi5kZWZhdWx0UmVzb2x1dGlvbiA/PyBzZXR0aW5ncy5SRVNPTFVUSU9OLCB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IF9UZXh0Mi5kZWZhdWx0QXV0b1Jlc29sdXRpb24sIHRoaXMuX3RleHQgPSBudWxsLCB0aGlzLl9zdHlsZSA9IG51bGwsIHRoaXMuX3N0eWxlTGlzdGVuZXIgPSBudWxsLCB0aGlzLl9mb250ID0gXCJcIiwgdGhpcy50ZXh0ID0gdGV4dCwgdGhpcy5zdHlsZSA9IHN0eWxlLCB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIFBJWEkuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKi9cbiAgc3RhdGljIGdldCBleHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiBUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHN0YXRpYyBzZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyh2YWx1ZSkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFxuICAgICAgXCI3LjEuMFwiLFxuICAgICAgXCJUZXh0LmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdcIlxuICAgICksIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0ZXh0IHRvIGl0cyBjYW52YXMsIGFuZCB1cGRhdGVzIGl0cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGVuc3VyZSB0aGUgdGV4dHVyZSBpcyBjb3JyZWN0IGJlZm9yZSByZW5kZXJpbmcsXG4gICAqIGJ1dCBpdCBjYW4gYmUgdXNlZCBjYWxsZWQgZXh0ZXJuYWxseSwgZm9yIGV4YW1wbGUgZnJvbSB0aGlzIGNsYXNzIHRvICdwcmUtZ2VuZXJhdGUnIHRoZSB0ZXh0dXJlIGZyb20gYSBwaWVjZSBvZiB0ZXh0LFxuICAgKiBhbmQgdGhlbiBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFNwcml0ZXMuXG4gICAqIEBwYXJhbSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZSB0ZXh0IGlmIHRoZSBUZXh0IGlzbid0IGRpcnR5IGFuZCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKi9cbiAgdXBkYXRlVGV4dChyZXNwZWN0RGlydHkpIHtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGlmICh0aGlzLmxvY2FsU3R5bGVJRCAhPT0gc3R5bGUuc3R5bGVJRCAmJiAodGhpcy5kaXJ0eSA9ICEwLCB0aGlzLmxvY2FsU3R5bGVJRCA9IHN0eWxlLnN0eWxlSUQpLCAhdGhpcy5kaXJ0eSAmJiByZXNwZWN0RGlydHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZm9udCA9IHRoaXMuX3N0eWxlLnRvRm9udFN0cmluZygpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQsIG1lYXN1cmVkID0gVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGhpcy5fdGV4dCB8fCBcIiBcIiwgdGhpcy5fc3R5bGUsIHRoaXMuX3N0eWxlLndvcmRXcmFwLCB0aGlzLmNhbnZhcyksIHdpZHRoID0gbWVhc3VyZWQud2lkdGgsIGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodCwgbGluZXMgPSBtZWFzdXJlZC5saW5lcywgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQsIGxpbmVXaWR0aHMgPSBtZWFzdXJlZC5saW5lV2lkdGhzLCBtYXhMaW5lV2lkdGggPSBtZWFzdXJlZC5tYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIHdpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHRoaXMuX3Jlc29sdXRpb24pLCB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiB0aGlzLl9yZXNvbHV0aW9uKSwgY29udGV4dC5zY2FsZSh0aGlzLl9yZXNvbHV0aW9uLCB0aGlzLl9yZXNvbHV0aW9uKSwgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCksIGNvbnRleHQuZm9udCA9IHRoaXMuX2ZvbnQsIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzLCBjb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSwgY29udGV4dC5saW5lSm9pbiA9IHN0eWxlLmxpbmVKb2luLCBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0O1xuICAgIGxldCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZO1xuICAgIGNvbnN0IHBhc3Nlc0NvdW50ID0gc3R5bGUuZHJvcFNoYWRvdyA/IDIgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc2VzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgaXNTaGFkb3dQYXNzID0gc3R5bGUuZHJvcFNoYWRvdyAmJiBpID09PSAwLCBkc09mZnNldFRleHQgPSBpc1NoYWRvd1Bhc3MgPyBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSA6IDAsIGRzT2Zmc2V0U2hhZG93ID0gZHNPZmZzZXRUZXh0ICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgIGlmIChpc1NoYWRvd1Bhc3MpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCIsIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvciwgZHJvcFNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1ciAqIHRoaXMuX3Jlc29sdXRpb24sIGRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpLCBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1ciwgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSwgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSArIGRzT2Zmc2V0U2hhZG93O1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fZ2VuZXJhdGVGaWxsU3R5bGUoc3R5bGUsIGxpbmVzLCBtZWFzdXJlZCksIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2UsIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCIsIGNvbnRleHQuc2hhZG93Qmx1ciA9IDAsIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDAsIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICBsZXQgbGluZVBvc2l0aW9uWVNoaWZ0ID0gKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSkgLyAyO1xuICAgICAgbGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplIDwgMCAmJiAobGluZVBvc2l0aW9uWVNoaWZ0ID0gMCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbGluZXMubGVuZ3RoOyBpMisrKVxuICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiwgbGluZVBvc2l0aW9uWSA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpMiAqIGxpbmVIZWlnaHQgKyBmb250UHJvcGVydGllcy5hc2NlbnQgKyBsaW5lUG9zaXRpb25ZU2hpZnQsIHN0eWxlLmFsaWduID09PSBcInJpZ2h0XCIgPyBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdIDogc3R5bGUuYWxpZ24gPT09IFwiY2VudGVyXCIgJiYgKGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdKSAvIDIpLCBzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzICYmIHRoaXMuZHJhd0xldHRlclNwYWNpbmcoXG4gICAgICAgICAgbGluZXNbaTJdLFxuICAgICAgICAgIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nIC0gZHNPZmZzZXRUZXh0LFxuICAgICAgICAgICEwXG4gICAgICAgICksIHN0eWxlLmZpbGwgJiYgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhcbiAgICAgICAgICBsaW5lc1tpMl0sXG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHRcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIGRyYXdcbiAgICogQHBhcmFtIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICogQHBhcmFtIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBpc1N0cm9rZSAtIElzIHRoaXMgZHJhd2luZyBmb3IgdGhlIG91dHNpZGUgc3Ryb2tlIG9mIHRoZVxuICAgKiAgdGV4dD8gSWYgbm90LCBpdCdzIGZvciB0aGUgaW5zaWRlIGZpbGxcbiAgICovXG4gIGRyYXdMZXR0ZXJTcGFjaW5nKHRleHQsIHgsIHksIGlzU3Ryb2tlID0gITEpIHtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gdGhpcy5fc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICBsZXQgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9ICExO1xuICAgIGlmIChUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkICYmIChUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID8gKHRoaXMuY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGAsIHRoaXMuY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgLCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gITApIDogKHRoaXMuY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gXCIwcHhcIiwgdGhpcy5jb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIikpLCBsZXR0ZXJTcGFjaW5nID09PSAwIHx8IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgIGlzU3Ryb2tlID8gdGhpcy5jb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSkgOiB0aGlzLmNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB4O1xuICAgIGNvbnN0IHN0cmluZ0FycmF5ID0gVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodGV4dCk7XG4gICAgbGV0IHByZXZpb3VzV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGgsIGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY3VycmVudENoYXIgPSBzdHJpbmdBcnJheVtpXTtcbiAgICAgIGlzU3Ryb2tlID8gdGhpcy5jb250ZXh0LnN0cm9rZVRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSkgOiB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICBsZXQgdGV4dFN0ciA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsrailcbiAgICAgICAgdGV4dFN0ciArPSBzdHJpbmdBcnJheVtqXTtcbiAgICAgIGN1cnJlbnRXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0U3RyKS53aWR0aCwgY3VycmVudFBvc2l0aW9uICs9IHByZXZpb3VzV2lkdGggLSBjdXJyZW50V2lkdGggKyBsZXR0ZXJTcGFjaW5nLCBwcmV2aW91c1dpZHRoID0gY3VycmVudFdpZHRoO1xuICAgIH1cbiAgfVxuICAvKiogVXBkYXRlcyB0ZXh0dXJlIHNpemUgYmFzZWQgb24gY2FudmFzIHNpemUuICovXG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgaWYgKHRoaXMuX3N0eWxlLnRyaW0pIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSB1dGlscy50cmltQ2FudmFzKGNhbnZhcyk7XG4gICAgICB0cmltbWVkLmRhdGEgJiYgKGNhbnZhcy53aWR0aCA9IHRyaW1tZWQud2lkdGgsIGNhbnZhcy5oZWlnaHQgPSB0cmltbWVkLmhlaWdodCwgdGhpcy5jb250ZXh0LnB1dEltYWdlRGF0YSh0cmltbWVkLmRhdGEsIDAsIDApKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmUsIHN0eWxlID0gdGhpcy5fc3R5bGUsIHBhZGRpbmcgPSBzdHlsZS50cmltID8gMCA6IHN0eWxlLnBhZGRpbmcsIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB0ZXh0dXJlLnRyaW0ud2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aCA9IGNhbnZhcy53aWR0aCAvIHRoaXMuX3Jlc29sdXRpb24sIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbiwgdGV4dHVyZS50cmltLnggPSAtcGFkZGluZywgdGV4dHVyZS50cmltLnkgPSAtcGFkZGluZywgdGV4dHVyZS5vcmlnLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggLSBwYWRkaW5nICogMiwgdGV4dHVyZS5vcmlnLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIHBhZGRpbmcgKiAyLCB0aGlzLl9vblRleHR1cmVVcGRhdGUoKSwgYmFzZVRleHR1cmUuc2V0UmVhbFNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCB0aGlzLl9yZXNvbHV0aW9uKSwgdGV4dHVyZS51cGRhdGVVdnMoKSwgdGhpcy5kaXJ0eSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKi9cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24gJiYgKHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uLCB0aGlzLmRpcnR5ID0gITApLCB0aGlzLnVwZGF0ZVRleHQoITApLCBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9uIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBmb3IgcmVuZGVyaW5nLiAqL1xuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KCEwKSwgc3VwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgZ2V0Qm91bmRzKHNraXBVcGRhdGUsIHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUZXh0KCEwKSwgdGhpcy5fdGV4dHVyZUlEID09PSAtMSAmJiAoc2tpcFVwZGF0ZSA9ICExKSwgc3VwZXIuZ2V0Qm91bmRzKHNraXBVcGRhdGUsIHJlY3QpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIHRleHQgb2JqZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBUaGUgYm91bmRzLlxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBzdXBlci5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICB9XG4gIC8qKiBDYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIFRleHQgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC4gKi9cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCksIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgZmlsbCBzdHlsZS4gQ2FuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSBncmFkaWVudCBiYXNlZCBvbiB0aGUgZmlsbCBzdHlsZSBiZWluZyBhbiBhcnJheVxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUuXG4gICAqIEBwYXJhbSBsaW5lcyAtIFRoZSBsaW5lcyBvZiB0ZXh0LlxuICAgKiBAcGFyYW0gbWV0cmljc1xuICAgKiBAcmV0dXJucyBUaGUgZmlsbCBzdHlsZVxuICAgKi9cbiAgX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcywgbWV0cmljcykge1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsbFN0eWxlKSkge1xuICAgICAgaWYgKGZpbGxTdHlsZS5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBmaWxsU3R5bGVbMF07XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZmlsbFN0eWxlO1xuICAgIGxldCBncmFkaWVudDtcbiAgICBjb25zdCBkcm9wU2hhZG93Q29ycmVjdGlvbiA9IHN0eWxlLmRyb3BTaGFkb3cgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiAwLCBwYWRkaW5nID0gc3R5bGUucGFkZGluZyB8fCAwLCB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDIsIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb24gLSBkcm9wU2hhZG93Q29ycmVjdGlvbiAtIHBhZGRpbmcgKiAyLCBmaWxsID0gZmlsbFN0eWxlLnNsaWNlKCksIGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aFBsdXMxOyArK2kpXG4gICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goaSAvIGxlbmd0aFBsdXMxKTtcbiAgICB9XG4gICAgaWYgKGZpbGwudW5zaGlmdChmaWxsU3R5bGVbMF0pLCBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApLCBmaWxsLnB1c2goZmlsbFN0eWxlW2ZpbGxTdHlsZS5sZW5ndGggLSAxXSksIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goMSksIHN0eWxlLmZpbGxHcmFkaWVudFR5cGUgPT09IFRFWFRfR1JBRElFTlQuTElORUFSX1ZFUlRJQ0FMKSB7XG4gICAgICBncmFkaWVudCA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh3aWR0aCAvIDIsIHBhZGRpbmcsIHdpZHRoIC8gMiwgaGVpZ2h0ICsgcGFkZGluZyk7XG4gICAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gbWV0cmljcy5mb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGFzdExpbmVCb3R0b20gPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiAoaSAtIDEpICsgdGV4dEhlaWdodCwgdGhpc0xpbmVUb3AgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiBpO1xuICAgICAgICBsZXQgdGhpc0xpbmVHcmFkaWVudFN0YXJ0ID0gdGhpc0xpbmVUb3A7XG4gICAgICAgIGkgPiAwICYmIGxhc3RMaW5lQm90dG9tID4gdGhpc0xpbmVUb3AgJiYgKHRoaXNMaW5lR3JhZGllbnRTdGFydCA9ICh0aGlzTGluZVRvcCArIGxhc3RMaW5lQm90dG9tKSAvIDIpO1xuICAgICAgICBjb25zdCB0aGlzTGluZUJvdHRvbSA9IHRoaXNMaW5lVG9wICsgdGV4dEhlaWdodCwgbmV4dExpbmVUb3AgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiAoaSArIDEpO1xuICAgICAgICBsZXQgdGhpc0xpbmVHcmFkaWVudEVuZCA9IHRoaXNMaW5lQm90dG9tO1xuICAgICAgICBpICsgMSA8IGxpbmVzLmxlbmd0aCAmJiBuZXh0TGluZVRvcCA8IHRoaXNMaW5lQm90dG9tICYmICh0aGlzTGluZUdyYWRpZW50RW5kID0gKHRoaXNMaW5lQm90dG9tICsgbmV4dExpbmVUb3ApIC8gMik7XG4gICAgICAgIGNvbnN0IGdyYWRTdG9wTGluZUhlaWdodCA9ICh0aGlzTGluZUdyYWRpZW50RW5kIC0gdGhpc0xpbmVHcmFkaWVudFN0YXJ0KSAvIGhlaWdodDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGxpbmVTdG9wID0gMDtcbiAgICAgICAgICB0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbal0gPT0gXCJudW1iZXJcIiA/IGxpbmVTdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbal0gOiBsaW5lU3RvcCA9IGogLyBmaWxsLmxlbmd0aDtcbiAgICAgICAgICBsZXQgZ2xvYmFsU3RvcCA9IE1hdGgubWluKDEsIE1hdGgubWF4KFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXNMaW5lR3JhZGllbnRTdGFydCAvIGhlaWdodCArIGxpbmVTdG9wICogZ3JhZFN0b3BMaW5lSGVpZ2h0XG4gICAgICAgICAgKSk7XG4gICAgICAgICAgZ2xvYmFsU3RvcCA9IE51bWJlcihnbG9iYWxTdG9wLnRvRml4ZWQoNSkpLCBncmFkaWVudC5hZGRDb2xvclN0b3AoZ2xvYmFsU3RvcCwgZmlsbFtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQocGFkZGluZywgaGVpZ2h0IC8gMiwgd2lkdGggKyBwYWRkaW5nLCBoZWlnaHQgLyAyKTtcbiAgICAgIGNvbnN0IHRvdGFsSXRlcmF0aW9ucyA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9uID0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RvcDtcbiAgICAgICAgdHlwZW9mIGZpbGxHcmFkaWVudFN0b3BzW2ldID09IFwibnVtYmVyXCIgPyBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbaV0gOiBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucywgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaV0pLCBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkaWVudDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyB0ZXh0IG9iamVjdC5cbiAgICpcbiAgICogTm90ZSogVW5saWtlIGEgU3ByaXRlLCBhIFRleHQgb2JqZWN0IHdpbGwgYXV0b21hdGljYWxseSBkZXN0cm95IGl0cyBiYXNlVGV4dHVyZSBhbmQgdGV4dHVyZSBhc1xuICAgKiB0aGUgbWFqb3JpdHkgb2YgdGhlIHRpbWUgdGhlIHRleHR1cmUgd2lsbCBub3QgYmUgc2hhcmVkIHdpdGggYW55IG90aGVyIFNwcml0ZXMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXG4gICAqICBkZXN0cm95IG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPXRydWVdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHR5cGVvZiBvcHRpb25zID09IFwiYm9vbGVhblwiICYmIChvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9KSwgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyksIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyksIHRoaXMuX293bkNhbnZhcyAmJiAodGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMud2lkdGggPSAwKSwgdGhpcy5jb250ZXh0ID0gbnVsbCwgdGhpcy5jYW52YXMgPSBudWxsLCB0aGlzLl9zdHlsZSA9IG51bGw7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUZXh0KCEwKSwgTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQoITApO1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgsIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LiAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KCEwKTtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCwgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHQuXG4gICAqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhlIHN0eWxlIG9iamVjdCBhbmQgbWFyayB0aGUgdGV4dCBhcyBkaXJ0eS5cbiAgICpcbiAgICogSWYgc2V0dGluZyB0aGUgYHN0eWxlYCBjYW4gYWxzbyBiZSBwYXJ0aWFsIHtAbGluayBQSVhJLklUZXh0U3R5bGV9LlxuICAgKi9cbiAgZ2V0IHN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9LCBzdHlsZSBpbnN0YW5jZW9mIFRleHRTdHlsZSA/IHRoaXMuX3N0eWxlID0gc3R5bGUgOiB0aGlzLl9zdHlsZSA9IG5ldyBUZXh0U3R5bGUoc3R5bGUpLCB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xLCB0aGlzLmRpcnR5ID0gITA7XG4gIH1cbiAgLyoqIFNldCB0aGUgY29weSBmb3IgdGhlIHRleHQgb2JqZWN0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicuICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9XG4gIHNldCB0ZXh0KHRleHQpIHtcbiAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPz8gXCJcIiksIHRoaXMuX3RleHQgIT09IHRleHQgJiYgKHRoaXMuX3RleHQgPSB0ZXh0LCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gITEsIHRoaXMuX3Jlc29sdXRpb24gIT09IHZhbHVlICYmICh0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbn07XG5fVGV4dC5kZWZhdWx0QXV0b1Jlc29sdXRpb24gPSAhMDtcbmxldCBUZXh0ID0gX1RleHQ7XG5leHBvcnQge1xuICBUZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBURVhUX0dSQURJRU5UIH0gZnJvbSBcIi4vY29uc3QubWpzXCI7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSBcIi4vVGV4dC5tanNcIjtcbmltcG9ydCB7IFRleHRNZXRyaWNzIH0gZnJvbSBcIi4vVGV4dE1ldHJpY3MubWpzXCI7XG5pbXBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tIFwiLi9UZXh0U3R5bGUubWpzXCI7XG5leHBvcnQge1xuICBURVhUX0dSQURJRU5ULFxuICBUZXh0LFxuICBUZXh0TWV0cmljcyxcbiAgVGV4dFN0eWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY2xhc3MgQ291bnRMaW1pdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtYXhJdGVtc1BlckZyYW1lIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIHByZXBhcmVkIGVhY2ggZnJhbWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXhJdGVtc1BlckZyYW1lKSB7XG4gICAgdGhpcy5tYXhJdGVtc1BlckZyYW1lID0gbWF4SXRlbXNQZXJGcmFtZSwgdGhpcy5pdGVtc0xlZnQgPSAwO1xuICB9XG4gIC8qKiBSZXNldHMgYW55IGNvdW50aW5nIHByb3BlcnRpZXMgdG8gc3RhcnQgZnJlc2ggb24gYSBuZXcgZnJhbWUuICovXG4gIGJlZ2luRnJhbWUoKSB7XG4gICAgdGhpcy5pdGVtc0xlZnQgPSB0aGlzLm1heEl0ZW1zUGVyRnJhbWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgYW5vdGhlciBpdGVtIGNhbiBiZSB1cGxvYWRlZC4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgaXRlbS5cbiAgICogQHJldHVybnMgSWYgdGhlIGl0ZW0gaXMgYWxsb3dlZCB0byBiZSB1cGxvYWRlZC5cbiAgICovXG4gIGFsbG93ZWRUb1VwbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc0xlZnQtLSA+IDA7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIENvdW50TGltaXRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvdW50TGltaXRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBCYXNlVGV4dHVyZSwgVGlja2VyLCBVUERBVEVfUFJJT1JJVFkgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIkBwaXhpL2Rpc3BsYXlcIjtcbmltcG9ydCB7IFRleHQsIFRleHRTdHlsZSwgVGV4dE1ldHJpY3MgfSBmcm9tIFwiQHBpeGkvdGV4dFwiO1xuaW1wb3J0IHsgQ291bnRMaW1pdGVyIH0gZnJvbSBcIi4vQ291bnRMaW1pdGVyLm1qc1wiO1xuZnVuY3Rpb24gZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKGl0ZW0sIHF1ZXVlKSB7XG4gIGxldCByZXN1bHQgPSAhMTtcbiAgaWYgKGl0ZW0/Ll90ZXh0dXJlcz8ubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLl90ZXh0dXJlcy5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChpdGVtLl90ZXh0dXJlc1tpXSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgYmFzZVRleHR1cmUgPSBpdGVtLl90ZXh0dXJlc1tpXS5iYXNlVGV4dHVyZTtcbiAgICAgICAgcXVldWUuaW5jbHVkZXMoYmFzZVRleHR1cmUpIHx8IChxdWV1ZS5wdXNoKGJhc2VUZXh0dXJlKSwgcmVzdWx0ID0gITApO1xuICAgICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kQmFzZVRleHR1cmUoaXRlbSwgcXVldWUpIHtcbiAgaWYgKGl0ZW0uYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLmJhc2VUZXh0dXJlO1xuICAgIHJldHVybiBxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSB8fCBxdWV1ZS5wdXNoKHRleHR1cmUpLCAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBmaW5kVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbS5fdGV4dHVyZSAmJiBpdGVtLl90ZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHJldHVybiBxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSB8fCBxdWV1ZS5wdXNoKHRleHR1cmUpLCAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBkcmF3VGV4dChfaGVscGVyLCBpdGVtKSB7XG4gIHJldHVybiBpdGVtIGluc3RhbmNlb2YgVGV4dCA/IChpdGVtLnVwZGF0ZVRleHQoITApLCAhMCkgOiAhMTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRleHRTdHlsZShfaGVscGVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dFN0eWxlKSB7XG4gICAgY29uc3QgZm9udCA9IGl0ZW0udG9Gb250U3RyaW5nKCk7XG4gICAgcmV0dXJuIFRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpLCAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBmaW5kVGV4dChpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICBxdWV1ZS5pbmNsdWRlcyhpdGVtLnN0eWxlKSB8fCBxdWV1ZS5wdXNoKGl0ZW0uc3R5bGUpLCBxdWV1ZS5pbmNsdWRlcyhpdGVtKSB8fCBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHJldHVybiBxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSB8fCBxdWV1ZS5wdXNoKHRleHR1cmUpLCAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBmaW5kVGV4dFN0eWxlKGl0ZW0sIHF1ZXVlKSB7XG4gIHJldHVybiBpdGVtIGluc3RhbmNlb2YgVGV4dFN0eWxlID8gKHF1ZXVlLmluY2x1ZGVzKGl0ZW0pIHx8IHF1ZXVlLnB1c2goaXRlbSksICEwKSA6ICExO1xufVxuY29uc3QgX0Jhc2VQcmVwYXJlID0gY2xhc3MgX0Jhc2VQcmVwYXJlMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuSVJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMubGltaXRlciA9IG5ldyBDb3VudExpbWl0ZXIoX0Jhc2VQcmVwYXJlMi51cGxvYWRzUGVyRnJhbWUpLCB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IG51bGwsIHRoaXMucXVldWUgPSBbXSwgdGhpcy5hZGRIb29rcyA9IFtdLCB0aGlzLnVwbG9hZEhvb2tzID0gW10sIHRoaXMuY29tcGxldGVzID0gW10sIHRoaXMudGlja2luZyA9ICExLCB0aGlzLmRlbGF5ZWRUaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZSAmJiB0aGlzLnByZXBhcmVJdGVtcygpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dCksIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dFN0eWxlKSwgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRNdWx0aXBsZUJhc2VUZXh0dXJlcyksIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kQmFzZVRleHR1cmUpLCB0aGlzLnJlZ2lzdGVyRmluZEhvb2soZmluZFRleHR1cmUpLCB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhkcmF3VGV4dCksIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKGNhbGN1bGF0ZVRleHRTdHlsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCBhbGwgdGhlIHRleHR1cmVzIGFuZCBncmFwaGljcyB0byB0aGUgR1BVLlxuICAgKiBAbWV0aG9kIFBJWEkuQmFzZVByZXBhcmUjdXBsb2FkXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuQ29udGFpbmVyfFBJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfFBJWEkuR3JhcGhpY3N8UElYSS5UZXh0fSBbaXRlbV0gLVxuICAgKiAgICAgICAgQ29udGFpbmVyIG9yIGRpc3BsYXkgb2JqZWN0IHRvIHNlYXJjaCBmb3IgaXRlbXMgdG8gdXBsb2FkIG9yIHRoZSBpdGVtcyB0byB1cGxvYWQgdGhlbXNlbHZlcyxcbiAgICogICAgICAgIG9yIG9wdGlvbmFsbHkgb21taXR0ZWQsIGlmIGl0ZW1zIGhhdmUgYmVlbiBhZGRlZCB1c2luZyB7QGxpbmsgUElYSS5CYXNlUHJlcGFyZSNhZGQgYHByZXBhcmUuYWRkYH0uXG4gICAqL1xuICB1cGxvYWQoaXRlbSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaXRlbSAmJiB0aGlzLmFkZChpdGVtKSwgdGhpcy5xdWV1ZS5sZW5ndGggPyAodGhpcy5jb21wbGV0ZXMucHVzaChyZXNvbHZlKSwgdGhpcy50aWNraW5nIHx8ICh0aGlzLnRpY2tpbmcgPSAhMCwgVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgVVBEQVRFX1BSSU9SSVRZLlVUSUxJVFkpKSkgOiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSB0aWNrIHVwZGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGljaygpIHtcbiAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXllZFRpY2ssIDApO1xuICB9XG4gIC8qKlxuICAgKiBBY3R1YWxseSBwcmVwYXJlIGl0ZW1zLiBUaGlzIGlzIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgdGljayBiZWNhdXNlIGl0IHdpbGwgdGFrZSBhIHdoaWxlXG4gICAqIGFuZCB3ZSBkbyBOT1Qgd2FudCB0byBibG9jayB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUgZnJvbSByZW5kZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlSXRlbXMoKSB7XG4gICAgZm9yICh0aGlzLmxpbWl0ZXIuYmVnaW5GcmFtZSgpOyB0aGlzLnF1ZXVlLmxlbmd0aCAmJiB0aGlzLmxpbWl0ZXIuYWxsb3dlZFRvVXBsb2FkKCk7ICkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWVbMF07XG4gICAgICBsZXQgdXBsb2FkZWQgPSAhMTtcbiAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMudXBsb2FkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgaWYgKHRoaXMudXBsb2FkSG9va3NbaV0odGhpcy51cGxvYWRIb29rSGVscGVyLCBpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpLCB1cGxvYWRlZCA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBsb2FkZWQgfHwgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpXG4gICAgICBUaWNrZXIuc3lzdGVtLmFkZE9uY2UodGhpcy50aWNrLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnRpY2tpbmcgPSAhMTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlcyA9IHRoaXMuY29tcGxldGVzLnNsaWNlKDApO1xuICAgICAgdGhpcy5jb21wbGV0ZXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb21wbGV0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNvbXBsZXRlc1tpXSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBob29rcyBmb3IgZmluZGluZyBpdGVtcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWRkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYGl0ZW06KiwgcXVldWU6QXJyYXlgXG4gICAqICAgICAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBhZGQgaXRlbSB0byB0aGUgcXVldWUuXG4gICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWdpc3RlckZpbmRIb29rKGFkZEhvb2spIHtcbiAgICByZXR1cm4gYWRkSG9vayAmJiB0aGlzLmFkZEhvb2tzLnB1c2goYWRkSG9vayksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgaG9va3MgZm9yIHVwbG9hZGluZyBpdGVtcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBsb2FkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcbiAgICogICAgICAgICAgZnVuY3Rpb24gbXVzdCByZXR1cm4gYHRydWVgIGlmIGl0IHdhcyBhYmxlIHRvIGhhbmRsZSB1cGxvYWQgb2YgaXRlbS5cbiAgICogQHJldHVybnMgSW5zdGFuY2Ugb2YgcGx1Z2luIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKSB7XG4gICAgcmV0dXJuIHVwbG9hZEhvb2sgJiYgdGhpcy51cGxvYWRIb29rcy5wdXNoKHVwbG9hZEhvb2spLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBNYW51YWxseSBhZGQgYW4gaXRlbSB0byB0aGUgdXBsb2FkaW5nIHF1ZXVlLlxuICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLkNvbnRhaW5lcnxQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZXxQSVhJLkdyYXBoaWNzfFBJWEkuVGV4dHwqfSBpdGVtIC0gT2JqZWN0IHRvXG4gICAqICAgICAgICBhZGQgdG8gdGhlIHF1ZXVlXG4gICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGQoaXRlbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmFkZEhvb2tzLmxlbmd0aDsgaSA8IGxlbiAmJiAhdGhpcy5hZGRIb29rc1tpXShpdGVtLCB0aGlzLnF1ZXVlKTsgaSsrKVxuICAgICAgO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29udGFpbmVyKVxuICAgICAgZm9yIChsZXQgaSA9IGl0ZW0uY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHRoaXMuYWRkKGl0ZW0uY2hpbGRyZW5baV0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgcGx1Z2luLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRpY2tpbmcgJiYgVGlja2VyLnN5c3RlbS5yZW1vdmUodGhpcy50aWNrLCB0aGlzKSwgdGhpcy50aWNraW5nID0gITEsIHRoaXMuYWRkSG9va3MgPSBudWxsLCB0aGlzLnVwbG9hZEhvb2tzID0gbnVsbCwgdGhpcy5yZW5kZXJlciA9IG51bGwsIHRoaXMuY29tcGxldGVzID0gbnVsbCwgdGhpcy5xdWV1ZSA9IG51bGwsIHRoaXMubGltaXRlciA9IG51bGwsIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IG51bGw7XG4gIH1cbn07XG5fQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lID0gNDtcbmxldCBCYXNlUHJlcGFyZSA9IF9CYXNlUHJlcGFyZTtcbmV4cG9ydCB7XG4gIEJhc2VQcmVwYXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVByZXBhcmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIHV0aWxzIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IHNldHRpbmdzIGFzIHNldHRpbmdzMiB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBCYXNlUHJlcGFyZSB9IGZyb20gXCIuL0Jhc2VQcmVwYXJlLm1qc1wiO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgbnVtYmVyIG9mIHVwbG9hZHMgcGVyIGZyYW1lIHVzaW5nIHByZXBhcmUgcGx1Z2luLlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBuYW1lIFVQTE9BRFNfUEVSX0ZSQU1FXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIFVQTE9BRFNfUEVSX0ZSQU1FOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVwYXJlLkJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZVwiKSwgQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lID0gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcbmV4cG9ydCB7XG4gIHNldHRpbmdzMiBhcyBzZXR0aW5nc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLm1qcy5tYXBcbiIsImltcG9ydCB7IEJhc2VUZXh0dXJlLCBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIkBwaXhpL2dyYXBoaWNzXCI7XG5pbXBvcnQgeyBCYXNlUHJlcGFyZSB9IGZyb20gXCIuL0Jhc2VQcmVwYXJlLm1qc1wiO1xuZnVuY3Rpb24gdXBsb2FkQmFzZVRleHR1cmVzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIHJldHVybiBpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmUgPyAoaXRlbS5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0gfHwgcmVuZGVyZXIudGV4dHVyZS5iaW5kKGl0ZW0pLCAhMCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHVwbG9hZEdyYXBoaWNzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBHcmFwaGljcykpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCB7IGdlb21ldHJ5IH0gPSBpdGVtO1xuICBpdGVtLmZpbmlzaFBvbHkoKSwgZ2VvbWV0cnkudXBkYXRlQmF0Y2hlcygpO1xuICBjb25zdCB7IGJhdGNoZXMgfSA9IGdlb21ldHJ5O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHRleHR1cmUgfSA9IGJhdGNoZXNbaV0uc3R5bGU7XG4gICAgdGV4dHVyZSAmJiB1cGxvYWRCYXNlVGV4dHVyZXMocmVuZGVyZXIsIHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICB9XG4gIHJldHVybiBnZW9tZXRyeS5iYXRjaGFibGUgfHwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgaXRlbS5fcmVzb2x2ZURpcmVjdFNoYWRlcihyZW5kZXJlcikpLCAhMDtcbn1cbmZ1bmN0aW9uIGZpbmRHcmFwaGljcyhpdGVtLCBxdWV1ZSkge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEdyYXBoaWNzID8gKHF1ZXVlLnB1c2goaXRlbSksICEwKSA6ICExO1xufVxuY2xhc3MgUHJlcGFyZSBleHRlbmRzIEJhc2VQcmVwYXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlciksIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IHRoaXMucmVuZGVyZXIsIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kR3JhcGhpY3MpLCB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRCYXNlVGV4dHVyZXMpLCB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRHcmFwaGljcyk7XG4gIH1cbn1cblByZXBhcmUuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInByZXBhcmVcIixcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbVxufTtcbmV4dGVuc2lvbnMuYWRkKFByZXBhcmUpO1xuZXhwb3J0IHtcbiAgUHJlcGFyZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZXBhcmUubWpzLm1hcFxuIiwiaW1wb3J0IFwiLi9zZXR0aW5ncy5tanNcIjtcbmltcG9ydCB7IEJhc2VQcmVwYXJlIH0gZnJvbSBcIi4vQmFzZVByZXBhcmUubWpzXCI7XG5pbXBvcnQgeyBDb3VudExpbWl0ZXIgfSBmcm9tIFwiLi9Db3VudExpbWl0ZXIubWpzXCI7XG5pbXBvcnQgeyBQcmVwYXJlIH0gZnJvbSBcIi4vUHJlcGFyZS5tanNcIjtcbmltcG9ydCB7IFRpbWVMaW1pdGVyIH0gZnJvbSBcIi4vVGltZUxpbWl0ZXIubWpzXCI7XG5leHBvcnQge1xuICBCYXNlUHJlcGFyZSxcbiAgQ291bnRMaW1pdGVyLFxuICBQcmVwYXJlLFxuICBUaW1lTGltaXRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUsIFRpY2tlciwgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gXCJAcGl4aS9zcHJpdGVcIjtcbmNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0dXJlcyAtIEFuIGFycmF5IG9mIHtAbGluayBQSVhJLlRleHR1cmV9IG9yIGZyYW1lXG4gICAqICBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvVXBkYXRlPXRydWVdIC0gV2hldGhlciB0byB1c2UgVGlja2VyLnNoYXJlZCB0byBhdXRvIHVwZGF0ZSBhbmltYXRpb24gdGltZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHR1cmVzLCBhdXRvVXBkYXRlID0gITApIHtcbiAgICBzdXBlcih0ZXh0dXJlc1swXSBpbnN0YW5jZW9mIFRleHR1cmUgPyB0ZXh0dXJlc1swXSA6IHRleHR1cmVzWzBdLnRleHR1cmUpLCB0aGlzLl90ZXh0dXJlcyA9IG51bGwsIHRoaXMuX2R1cmF0aW9ucyA9IG51bGwsIHRoaXMuX2F1dG9VcGRhdGUgPSBhdXRvVXBkYXRlLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITEsIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxLCB0aGlzLmxvb3AgPSAhMCwgdGhpcy51cGRhdGVBbmNob3IgPSAhMSwgdGhpcy5vbkNvbXBsZXRlID0gbnVsbCwgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbCwgdGhpcy5vbkxvb3AgPSBudWxsLCB0aGlzLl9jdXJyZW50VGltZSA9IDAsIHRoaXMuX3BsYXlpbmcgPSAhMSwgdGhpcy5fcHJldmlvdXNGcmFtZSA9IG51bGwsIHRoaXMudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgfVxuICAvKiogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlLiAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuX3BsYXlpbmcgJiYgKHRoaXMuX3BsYXlpbmcgPSAhMSwgdGhpcy5fYXV0b1VwZGF0ZSAmJiB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyICYmIChUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyksIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSAhMSkpO1xuICB9XG4gIC8qKiBQbGF5cyB0aGUgQW5pbWF0ZWRTcHJpdGUuICovXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5fcGxheWluZyB8fCAodGhpcy5fcGxheWluZyA9ICEwLCB0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyICYmIChUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcywgVVBEQVRFX1BSSU9SSVRZLkhJR0gpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITApKTtcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlIGFuZCBnb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUuXG4gICAqIEBwYXJhbSBmcmFtZU51bWJlciAtIEZyYW1lIGluZGV4IHRvIHN0b3AgYXQuXG4gICAqL1xuICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgIHRoaXMuc3RvcCgpLCB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBBbmltYXRlZFNwcml0ZS5cbiAgICogQHBhcmFtIGZyYW1lTnVtYmVyIC0gRnJhbWUgaW5kZXggdG8gc3RhcnQgYXQuXG4gICAqL1xuICBnb3RvQW5kUGxheShmcmFtZU51bWJlcikge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXIsIHRoaXMucGxheSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIGxhc3QgdGljay5cbiAgICovXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWUsIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBpZiAodGhpcy5fZHVyYXRpb25zICE9PSBudWxsKSB7XG4gICAgICBsZXQgbGFnID0gdGhpcy5fY3VycmVudFRpbWUgJSAxICogdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgIGZvciAobGFnICs9IGVsYXBzZWQgLyA2MCAqIDFlMzsgbGFnIDwgMDsgKVxuICAgICAgICB0aGlzLl9jdXJyZW50VGltZS0tLCBsYWcgKz0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24odGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZSk7XG4gICAgICBmb3IgKHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7IGxhZyA+PSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdOyApXG4gICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbiwgdGhpcy5fY3VycmVudFRpbWUgKz0gc2lnbjtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGxhZyAvIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBlbGFwc2VkO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lIDwgMCAmJiAhdGhpcy5sb29wID8gKHRoaXMuZ290b0FuZFN0b3AoMCksIHRoaXMub25Db21wbGV0ZSAmJiB0aGlzLm9uQ29tcGxldGUoKSkgOiB0aGlzLl9jdXJyZW50VGltZSA+PSB0aGlzLl90ZXh0dXJlcy5sZW5ndGggJiYgIXRoaXMubG9vcCA/ICh0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpLCB0aGlzLm9uQ29tcGxldGUgJiYgdGhpcy5vbkNvbXBsZXRlKCkpIDogcHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUgJiYgKHRoaXMubG9vcCAmJiB0aGlzLm9uTG9vcCAmJiAodGhpcy5hbmltYXRpb25TcGVlZCA+IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPCBwcmV2aW91c0ZyYW1lIHx8IHRoaXMuYW5pbWF0aW9uU3BlZWQgPCAwICYmIHRoaXMuY3VycmVudEZyYW1lID4gcHJldmlvdXNGcmFtZSkgJiYgdGhpcy5vbkxvb3AoKSwgdGhpcy51cGRhdGVUZXh0dXJlKCkpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBkaXNwbGF5ZWQgdGV4dHVyZSB0byBtYXRjaCB0aGUgY3VycmVudCBmcmFtZSBpbmRleC4gKi9cbiAgdXBkYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCBjdXJyZW50RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lICE9PSBjdXJyZW50RnJhbWUgJiYgKHRoaXMuX3ByZXZpb3VzRnJhbWUgPSBjdXJyZW50RnJhbWUsIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tjdXJyZW50RnJhbWVdLCB0aGlzLl90ZXh0dXJlSUQgPSAtMSwgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xLCB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTUsIHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzIsIHRoaXMudXBkYXRlQW5jaG9yICYmIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh0aGlzLl90ZXh0dXJlLmRlZmF1bHRBbmNob3IpLCB0aGlzLm9uRnJhbWVDaGFuZ2UgJiYgdGhpcy5vbkZyYW1lQ2hhbmdlKHRoaXMuY3VycmVudEZyYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZSBhbmQgZGVzdHJveXMgaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGwuXG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0b3AoKSwgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy5vbkNvbXBsZXRlID0gbnVsbCwgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbCwgdGhpcy5vbkxvb3AgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGFuIEFuaW1hdGVkU3ByaXRlIGZyb20gYW4gYXJyYXkgb2YgZnJhbWUgaWRzLlxuICAgKiBAcGFyYW0gZnJhbWVzIC0gVGhlIGFycmF5IG9mIGZyYW1lcyBpZHMgdGhlIEFuaW1hdGVkU3ByaXRlIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lcy5cbiAgICogQHJldHVybnMgLSBUaGUgbmV3IGFuaW1hdGVkIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgZnJhbWVzLlxuICAgKi9cbiAgc3RhdGljIGZyb21GcmFtZXMoZnJhbWVzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgIHRleHR1cmVzLnB1c2goVGV4dHVyZS5mcm9tKGZyYW1lc1tpXSkpO1xuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xuICB9XG4gIC8qKlxuICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGFuIEFuaW1hdGVkU3ByaXRlIGZyb20gYW4gYXJyYXkgb2YgaW1hZ2UgaWRzLlxuICAgKiBAcGFyYW0gaW1hZ2VzIC0gVGhlIGFycmF5IG9mIGltYWdlIHVybHMgdGhlIEFuaW1hdGVkU3ByaXRlIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lcy5cbiAgICogQHJldHVybnMgVGhlIG5ldyBhbmltYXRlIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW1hZ2VzIGFzIGZyYW1lcy5cbiAgICovXG4gIHN0YXRpYyBmcm9tSW1hZ2VzKGltYWdlcykge1xuICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpXG4gICAgICB0ZXh0dXJlcy5wdXNoKFRleHR1cmUuZnJvbShpbWFnZXNbaV0pKTtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIEFuaW1hdGVkU3ByaXRlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIG51bWJlciBvZiB0ZXh0dXJlc1xuICAgKiBhc3NpZ25lZCB0byB0aGUgQW5pbWF0ZWRTcHJpdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgdG90YWxGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgfVxuICAvKiogVGhlIGFycmF5IG9mIHRleHR1cmVzIHVzZWQgZm9yIHRoaXMgQW5pbWF0ZWRTcHJpdGUuICovXG4gIGdldCB0ZXh0dXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM7XG4gIH1cbiAgc2V0IHRleHR1cmVzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlWzBdIGluc3RhbmNlb2YgVGV4dHVyZSlcbiAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWUsIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdLCB0aGlzLl9kdXJhdGlvbnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSksIHRoaXMuX2R1cmF0aW9ucy5wdXNoKHZhbHVlW2ldLnRpbWUpO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbCwgdGhpcy5nb3RvQW5kU3RvcCgwKSwgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gIH1cbiAgLyoqIFRoZSBBbmltYXRlZFNwcml0ZSdzIGN1cnJlbnQgZnJhbWUgaW5kZXguICovXG4gIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgbGV0IGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIHJldHVybiBjdXJyZW50RnJhbWUgPCAwICYmIChjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoKSwgY3VycmVudEZyYW1lO1xuICB9XG4gIHNldCBjdXJyZW50RnJhbWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyAtIDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtBbmltYXRlZFNwcml0ZV06IEludmFsaWQgZnJhbWUgaW5kZXggdmFsdWUgJHt2YWx1ZX0sIGV4cGVjdGVkIHRvIGJlIGJldHdlZW4gMCBhbmQgdG90YWxGcmFtZXMgJHt0aGlzLnRvdGFsRnJhbWVzfS5gKTtcbiAgICBjb25zdCBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB2YWx1ZSwgcHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUgJiYgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgQW5pbWF0ZWRTcHJpdGUgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XG4gIH1cbiAgLyoqIFdoZXRoZXIgdG8gdXNlIFRpY2tlci5zaGFyZWQgdG8gYXV0byB1cGRhdGUgYW5pbWF0aW9uIHRpbWUuICovXG4gIGdldCBhdXRvVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICB9XG4gIHNldCBhdXRvVXBkYXRlKHZhbHVlKSB7XG4gICAgdmFsdWUgIT09IHRoaXMuX2F1dG9VcGRhdGUgJiYgKHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZSwgIXRoaXMuX2F1dG9VcGRhdGUgJiYgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA/IChUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyksIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSAhMSkgOiB0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyICYmIHRoaXMuX3BsYXlpbmcgJiYgKFRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKSwgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9ICEwKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEFuaW1hdGVkU3ByaXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0ZWRTcHJpdGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQW5pbWF0ZWRTcHJpdGUgfSBmcm9tIFwiLi9BbmltYXRlZFNwcml0ZS5tanNcIjtcbmV4cG9ydCB7XG4gIEFuaW1hdGVkU3ByaXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQsIFRyYW5zZm9ybSwgVGV4dHVyZU1hdHJpeCwgUmVjdGFuZ2xlLCBUZXh0dXJlIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gXCJAcGl4aS9zcHJpdGVcIjtcbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBQb2ludCgpO1xuY2xhc3MgVGlsaW5nU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgLyoqXG4gICAqIE5vdGU6IFRoZSB3cmFwIG1vZGUgb2YgdGhlIHRleHR1cmUgaXMgZm9yY2VkIHRvIFJFUEVBVCBvbiByZW5kZXIgaWYgdGhlIHNpemUgb2YgdGhlIHRleHR1cmVcbiAgICogaXMgYSBwb3dlciBvZiB0d28sIHRoZSB0ZXh0dXJlJ3Mgd3JhcCBtb2RlIGlzIENMQU1QLCBhbmQgdGhlIHRleHR1cmUgaGFzbid0IGJlZW4gYm91bmQgeWV0LlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIG9mIHRoZSB0aWxpbmcgc3ByaXRlLlxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGUuXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCkge1xuICAgIHN1cGVyKHRleHR1cmUpLCB0aGlzLnRpbGVUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCksIHRoaXMuX3dpZHRoID0gd2lkdGgsIHRoaXMuX2hlaWdodCA9IGhlaWdodCwgdGhpcy51dk1hdHJpeCA9IHRoaXMudGV4dHVyZS51dk1hdHJpeCB8fCBuZXcgVGV4dHVyZU1hdHJpeCh0ZXh0dXJlKSwgdGhpcy5wbHVnaW5OYW1lID0gXCJ0aWxpbmdTcHJpdGVcIiwgdGhpcy51dlJlc3BlY3RBbmNob3IgPSAhMTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZyBpbiBjb3JyZXNwb25kaW5nIHRleHR1cmVUcmFuc2Zvcm0sIHNob3J0Y3V0XG4gICAqIENoYW5nZSB0byAtMC41IHRvIGFkZCBhIHBpeGVsIHRvIHRoZSBlZGdlLCByZWNvbW1lbmRlZCBmb3IgdHJhbnNwYXJlbnQgdHJpbW1lZCB0ZXh0dXJlcyBpbiBhdGxhc1xuICAgKiBAZGVmYXVsdCAwLjVcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNsYW1wTWFyZ2luKCkge1xuICAgIHJldHVybiB0aGlzLnV2TWF0cml4LmNsYW1wTWFyZ2luO1xuICB9XG4gIHNldCBjbGFtcE1hcmdpbih2YWx1ZSkge1xuICAgIHRoaXMudXZNYXRyaXguY2xhbXBNYXJnaW4gPSB2YWx1ZSwgdGhpcy51dk1hdHJpeC51cGRhdGUoITApO1xuICB9XG4gIC8qKiBUaGUgc2NhbGluZyBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZC4gKi9cbiAgZ2V0IHRpbGVTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlVHJhbnNmb3JtLnNjYWxlO1xuICB9XG4gIHNldCB0aWxlU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnRpbGVUcmFuc2Zvcm0uc2NhbGUuY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBpbWFnZSB0aGF0IGlzIGJlaW5nIHRpbGVkLiAqL1xuICBnZXQgdGlsZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG4gIH1cbiAgc2V0IHRpbGVQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vblRleHR1cmVVcGRhdGUoKSB7XG4gICAgdGhpcy51dk1hdHJpeCAmJiAodGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSksIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAhdGV4dHVyZSB8fCAhdGV4dHVyZS52YWxpZCB8fCAodGhpcy50aWxlVHJhbnNmb3JtLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCksIHRoaXMudXZNYXRyaXgudXBkYXRlKCksIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSksIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcykpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIHRpbGluZyBzcHJpdGUuICovXG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgY29uc3QgbWluWCA9IHRoaXMuX3dpZHRoICogLXRoaXMuX2FuY2hvci5feCwgbWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3ksIG1heFggPSB0aGlzLl93aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KSwgbWF4WSA9IHRoaXMuX2hlaWdodCAqICgxIC0gdGhpcy5fYW5jaG9yLl95KTtcbiAgICB0aGlzLl9ib3VuZHMuYWRkRnJhbWUodGhpcy50cmFuc2Zvcm0sIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAqIEBwYXJhbSByZWN0IC0gT3B0aW9uYWwgb3V0cHV0IHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGJvdW5kcy5cbiAgICovXG4gIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyAodGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl93aWR0aCAqIC10aGlzLl9hbmNob3IuX3gsIHRoaXMuX2JvdW5kcy5taW5ZID0gdGhpcy5faGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feSwgdGhpcy5fYm91bmRzLm1heFggPSB0aGlzLl93aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KSwgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl9oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSksIHJlY3QgfHwgKHRoaXMuX2xvY2FsQm91bmRzUmVjdCB8fCAodGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZSgpKSwgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdCksIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCkpIDogc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgdGlsaW5nIHNwcml0ZS5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgc3ByaXRlIGNvbnRhaW5zIHRoZSBwb2ludC5cbiAgICovXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQsIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IuX3g7XG4gICAgaWYgKHRlbXBQb2ludC54ID49IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgY29uc3QgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IuX3k7XG4gICAgICBpZiAodGVtcFBvaW50LnkgPj0geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgc3ByaXRlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlIGFuZCBjaGlsZHJlblxuICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy50aWxlVHJhbnNmb3JtID0gbnVsbCwgdGhpcy51dk1hdHJpeCA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgdGlsaW5nIHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfFBJWEkuVGV4dHVyZXxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSByZXF1aXJlZCB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSByZXF1aXJlZCBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICogQHJldHVybnMge1BJWEkuVGlsaW5nU3ByaXRlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gc291cmNlIGluc3RhbmNlb2YgVGV4dHVyZSA/IHNvdXJjZSA6IFRleHR1cmUuZnJvbShzb3VyY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgVGlsaW5nU3ByaXRlKFxuICAgICAgdGV4dHVyZSxcbiAgICAgIG9wdGlvbnMud2lkdGgsXG4gICAgICBvcHRpb25zLmhlaWdodFxuICAgICk7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBUaWxpbmdTcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LiAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG59XG5leHBvcnQge1xuICBUaWxpbmdTcHJpdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGUubWpzLm1hcFxuIiwidmFyIGdsMkZyYWdtZW50U3JjID0gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxuXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcblxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG5vdXQgdmVjNCBmcmFnbWVudENvbG9yO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xudW5pZm9ybSB2ZWM0IHVDbGFtcEZyYW1lO1xudW5pZm9ybSB2ZWMyIHVDbGFtcE9mZnNldDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBjZWlsKHVDbGFtcE9mZnNldCAtIHZUZXh0dXJlQ29vcmQpO1xuICAgIGNvb3JkID0gKHVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xuICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XG4gICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcblxuICAgIHZlYzQgdGV4U2FtcGxlID0gdGV4dHVyZSh1U2FtcGxlciwgY29vcmQsIHVuY2xhbXBlZCA9PSBjb29yZCA/IDAuMGYgOiAtMzIuMGYpOy8vIGxvZC1iaWFzIHZlcnkgbmVnYXRpdmUgdG8gZm9yY2UgbG9kIDBcblxuICAgIGZyYWdtZW50Q29sb3IgPSB0ZXhTYW1wbGUgKiB1Q29sb3I7XG59XG5gO1xuZXhwb3J0IHtcbiAgZ2wyRnJhZ21lbnRTcmMgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmcuZnJhZy5tanMubWFwXG4iLCJ2YXIgZ2wyVmVydGV4U3JjID0gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTMwMFxuXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcblxuaW4gdmVjMiBhVmVydGV4UG9zaXRpb247XG5pbiB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm07XG5cbm91dCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG5cbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUcmFuc2Zvcm0gKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xufVxuYDtcbmV4cG9ydCB7XG4gIGdsMlZlcnRleFNyYyBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZy52ZXJ0Lm1qcy5tYXBcbiIsInZhciBnbDFGcmFnbWVudFNyYyA9IGAjdmVyc2lvbiAxMDBcbiNpZmRlZiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kXG4gICAgI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlXG4jZW5kaWZcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0xMDBcblxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xudW5pZm9ybSB2ZWM0IHVDbGFtcEZyYW1lO1xudW5pZm9ybSB2ZWMyIHVDbGFtcE9mZnNldDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBjZWlsKHVDbGFtcE9mZnNldCAtIHZUZXh0dXJlQ29vcmQpO1xuICAgIGNvb3JkID0gKHVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xuICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XG4gICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcblxuICAgICNpZmRlZiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kXG4gICAgICAgIHZlYzQgdGV4U2FtcGxlID0gdW5jbGFtcGVkID09IGNvb3JkXG4gICAgICAgICAgICA/IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpIFxuICAgICAgICAgICAgOiB0ZXh0dXJlMkRMb2RFWFQodVNhbXBsZXIsIGNvb3JkLCAwKTtcbiAgICAjZWxzZVxuICAgICAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpO1xuICAgICNlbmRpZlxuXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4U2FtcGxlICogdUNvbG9yO1xufVxuYDtcbmV4cG9ydCB7XG4gIGdsMUZyYWdtZW50U3JjIGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLmZyYWcubWpzLm1hcFxuIiwidmFyIGdsMVZlcnRleFNyYyA9IGAjdmVyc2lvbiAxMDBcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0xMDBcblxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG5cbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm07XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xuXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VHJhbnNmb3JtICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcbn1cbmA7XG5leHBvcnQge1xuICBnbDFWZXJ0ZXhTcmMgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctZmFsbGJhY2sudmVydC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnRTaW1wbGVTcmMgPSBgI3ZlcnNpb24gMTAwXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtU2ltcGxlLTEwMFxuXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSB2ZWM0IHVDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgdmVjNCB0ZXhTYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgIGdsX0ZyYWdDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcbn1cbmA7XG5leHBvcnQge1xuICBmcmFnbWVudFNpbXBsZVNyYyBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZy1zaW1wbGUuZnJhZy5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXgsIE9iamVjdFJlbmRlcmVyLCBRdWFkVXYsIFN0YXRlLCBTaGFkZXIsIFdSQVBfTU9ERVMsIENvbG9yLCB1dGlscywgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgZ2wyRnJhZ21lbnRTcmMgZnJvbSBcIi4vc3ByaXRlLXRpbGluZy5mcmFnLm1qc1wiO1xuaW1wb3J0IGdsMlZlcnRleFNyYyBmcm9tIFwiLi9zcHJpdGUtdGlsaW5nLnZlcnQubWpzXCI7XG5pbXBvcnQgZ2wxRnJhZ21lbnRTcmMgZnJvbSBcIi4vc3ByaXRlLXRpbGluZy1mYWxsYmFjay5mcmFnLm1qc1wiO1xuaW1wb3J0IGdsMVZlcnRleFNyYyBmcm9tIFwiLi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLnZlcnQubWpzXCI7XG5pbXBvcnQgZnJhZ21lbnRTaW1wbGVTcmMgZnJvbSBcIi4vc3ByaXRlLXRpbGluZy1zaW1wbGUuZnJhZy5tanNcIjtcbmNvbnN0IHRlbXBNYXQgPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBUaWxpbmdTcHJpdGVSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yIGZvciByZW5kZXJlclxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgdGlsaW5nIGF3ZXNvbWVuZXNzIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpLCByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpLCB0aGlzLnF1YWQgPSBuZXcgUXVhZFV2KCksIHRoaXMuc3RhdGUgPSBTdGF0ZS5mb3IyZCgpO1xuICB9XG4gIC8qKiBDcmVhdGVzIHNoYWRlcnMgd2hlbiBjb250ZXh0IGlzIGluaXRpYWxpemVkLiAqL1xuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlciwgdW5pZm9ybXMgPSB7IGdsb2JhbHM6IHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zIH07XG4gICAgdGhpcy5zaW1wbGVTaGFkZXIgPSBTaGFkZXIuZnJvbShnbDFWZXJ0ZXhTcmMsIGZyYWdtZW50U2ltcGxlU3JjLCB1bmlmb3JtcyksIHRoaXMuc2hhZGVyID0gcmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPiAxID8gU2hhZGVyLmZyb20oZ2wyVmVydGV4U3JjLCBnbDJGcmFnbWVudFNyYywgdW5pZm9ybXMpIDogU2hhZGVyLmZyb20oZ2wxVmVydGV4U3JjLCBnbDFGcmFnbWVudFNyYywgdW5pZm9ybXMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuVGlsaW5nU3ByaXRlfSB0cyAtIHRpbGluZ1Nwcml0ZSB0byBiZSByZW5kZXJlZFxuICAgKi9cbiAgcmVuZGVyKHRzKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLCBxdWFkID0gdGhpcy5xdWFkO1xuICAgIGxldCB2ZXJ0aWNlcyA9IHF1YWQudmVydGljZXM7XG4gICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IHRzLl93aWR0aCAqIC10cy5hbmNob3IueCwgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IHRzLl9oZWlnaHQgKiAtdHMuYW5jaG9yLnksIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSB0cy5fd2lkdGggKiAoMSAtIHRzLmFuY2hvci54KSwgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IHRzLl9oZWlnaHQgKiAoMSAtIHRzLmFuY2hvci55KTtcbiAgICBjb25zdCBhbmNob3JYID0gdHMudXZSZXNwZWN0QW5jaG9yID8gdHMuYW5jaG9yLnggOiAwLCBhbmNob3JZID0gdHMudXZSZXNwZWN0QW5jaG9yID8gdHMuYW5jaG9yLnkgOiAwO1xuICAgIHZlcnRpY2VzID0gcXVhZC51dnMsIHZlcnRpY2VzWzBdID0gdmVydGljZXNbNl0gPSAtYW5jaG9yWCwgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IC1hbmNob3JZLCB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gMSAtIGFuY2hvclgsIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSAxIC0gYW5jaG9yWSwgcXVhZC5pbnZhbGlkYXRlKCk7XG4gICAgY29uc3QgdGV4ID0gdHMuX3RleHR1cmUsIGJhc2VUZXggPSB0ZXguYmFzZVRleHR1cmUsIHByZW11bHRpcGxpZWQgPSBiYXNlVGV4LmFscGhhTW9kZSA+IDAsIGx0ID0gdHMudGlsZVRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybSwgdXYgPSB0cy51dk1hdHJpeDtcbiAgICBsZXQgaXNTaW1wbGUgPSBiYXNlVGV4LmlzUG93ZXJPZlR3byAmJiB0ZXguZnJhbWUud2lkdGggPT09IGJhc2VUZXgud2lkdGggJiYgdGV4LmZyYW1lLmhlaWdodCA9PT0gYmFzZVRleC5oZWlnaHQ7XG4gICAgaXNTaW1wbGUgJiYgKGJhc2VUZXguX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdID8gaXNTaW1wbGUgPSBiYXNlVGV4LndyYXBNb2RlICE9PSBXUkFQX01PREVTLkNMQU1QIDogYmFzZVRleC53cmFwTW9kZSA9PT0gV1JBUF9NT0RFUy5DTEFNUCAmJiAoYmFzZVRleC53cmFwTW9kZSA9IFdSQVBfTU9ERVMuUkVQRUFUKSk7XG4gICAgY29uc3Qgc2hhZGVyID0gaXNTaW1wbGUgPyB0aGlzLnNpbXBsZVNoYWRlciA6IHRoaXMuc2hhZGVyLCB3ID0gdGV4LndpZHRoLCBoID0gdGV4LmhlaWdodCwgVyA9IHRzLl93aWR0aCwgSCA9IHRzLl9oZWlnaHQ7XG4gICAgdGVtcE1hdC5zZXQoXG4gICAgICBsdC5hICogdyAvIFcsXG4gICAgICBsdC5iICogdyAvIEgsXG4gICAgICBsdC5jICogaCAvIFcsXG4gICAgICBsdC5kICogaCAvIEgsXG4gICAgICBsdC50eCAvIFcsXG4gICAgICBsdC50eSAvIEhcbiAgICApLCB0ZW1wTWF0LmludmVydCgpLCBpc1NpbXBsZSA/IHRlbXBNYXQucHJlcGVuZCh1di5tYXBDb29yZCkgOiAoc2hhZGVyLnVuaWZvcm1zLnVNYXBDb29yZCA9IHV2Lm1hcENvb3JkLnRvQXJyYXkoITApLCBzaGFkZXIudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB1di51Q2xhbXBGcmFtZSwgc2hhZGVyLnVuaWZvcm1zLnVDbGFtcE9mZnNldCA9IHV2LnVDbGFtcE9mZnNldCksIHNoYWRlci51bmlmb3Jtcy51VHJhbnNmb3JtID0gdGVtcE1hdC50b0FycmF5KCEwKSwgc2hhZGVyLnVuaWZvcm1zLnVDb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0cy50aW50KS5wcmVtdWx0aXBseSh0cy53b3JsZEFscGhhLCBwcmVtdWx0aXBsaWVkKS50b0FycmF5KHNoYWRlci51bmlmb3Jtcy51Q29sb3IpLCBzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0cy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0udG9BcnJheSghMCksIHNoYWRlci51bmlmb3Jtcy51U2FtcGxlciA9IHRleCwgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKSwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChxdWFkKSwgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB1dGlscy5jb3JyZWN0QmxlbmRNb2RlKHRzLmJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCksIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKSwgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG4gIH1cbn1cblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJ0aWxpbmdTcHJpdGVcIixcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpblxufTtcbmV4dGVuc2lvbnMuYWRkKFRpbGluZ1Nwcml0ZVJlbmRlcmVyKTtcbmV4cG9ydCB7XG4gIFRpbGluZ1Nwcml0ZVJlbmRlcmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlUmVuZGVyZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGlsaW5nU3ByaXRlIH0gZnJvbSBcIi4vVGlsaW5nU3ByaXRlLm1qc1wiO1xuaW1wb3J0IHsgVGlsaW5nU3ByaXRlUmVuZGVyZXIgfSBmcm9tIFwiLi9UaWxpbmdTcHJpdGVSZW5kZXJlci5tanNcIjtcbmV4cG9ydCB7XG4gIFRpbGluZ1Nwcml0ZSxcbiAgVGlsaW5nU3ByaXRlUmVuZGVyZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBCYXNlVGV4dHVyZSwgdXRpbHMsIFJlY3RhbmdsZSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5jb25zdCBfU3ByaXRlc2hlZXQgPSBjbGFzcyBfU3ByaXRlc2hlZXQyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gUmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgQmFzZVRleHR1cmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIFNwcml0ZXNoZWV0IGltYWdlIGRhdGEuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uRmlsZW5hbWUgLSBUaGUgZmlsZW5hbWUgdG8gY29uc2lkZXIgd2hlbiBkZXRlcm1pbmluZ1xuICAgKiAgICAgICAgdGhlIHJlc29sdXRpb24gb2YgdGhlIHNwcml0ZXNoZWV0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBpbWFnZVVybCB3aWxsXG4gICAqICAgICAgICBiZSB1c2VkIG9uIHRoZSBCYXNlVGV4dHVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGRhdGEsIHJlc29sdXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxpbmtlZFNoZWV0cyA9IFtdLCB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUgPyB0ZXh0dXJlIDogbnVsbCwgdGhpcy5iYXNlVGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSA/IHRleHR1cmUgOiB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLCB0aGlzLnRleHR1cmVzID0ge30sIHRoaXMuYW5pbWF0aW9ucyA9IHt9LCB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCAocmVzb3VyY2UgPyByZXNvdXJjZS51cmwgOiBudWxsKSksIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXMsIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyksIHRoaXMuX2JhdGNoSW5kZXggPSAwLCB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRoZSByZXNvbHV0aW9uIGZyb20gdGhlIGZpbGVuYW1lIG9yIGZhbGxiYWNrXG4gICAqIHRvIHRoZSBtZXRhLnNjYWxlIGZpZWxkIG9mIHRoZSBKU09OIGRhdGEuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uRmlsZW5hbWUgLSBUaGUgZmlsZW5hbWUgdG8gdXNlIGZvciByZXNvbHZpbmdcbiAgICogICAgICAgIHRoZSBkZWZhdWx0IHJlc29sdXRpb24uXG4gICAqIEByZXR1cm5zIFJlc29sdXRpb24gdG8gdXNlIGZvciBzcHJpdGVzaGVldC5cbiAgICovXG4gIF91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICBjb25zdCB7IHNjYWxlIH0gPSB0aGlzLmRhdGEubWV0YTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChyZXNvbHV0aW9uRmlsZW5hbWUsIG51bGwpO1xuICAgIHJldHVybiByZXNvbHV0aW9uID09PSBudWxsICYmIChyZXNvbHV0aW9uID0gdHlwZW9mIHNjYWxlID09IFwibnVtYmVyXCIgPyBzY2FsZSA6IHBhcnNlRmxvYXQoc2NhbGUgPz8gXCIxXCIpKSwgcmVzb2x1dGlvbiAhPT0gMSAmJiB0aGlzLmJhc2VUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbiksIHJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlciBzcHJpdGVzaGVldCBmcm9tIGxvYWRlZCBkYXRhLiBUaGlzIGlzIGRvbmUgYXN5bmNocm9ub3VzbHlcbiAgICogdG8gcHJldmVudCBjcmVhdGluZyB0b28gbWFueSBUZXh0dXJlIHdpdGhpbiBhIHNpbmdsZSBwcm9jZXNzLlxuICAgKiBAbWV0aG9kIFBJWEkuU3ByaXRlc2hlZXQjcGFyc2VcbiAgICovXG4gIHBhcnNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSByZXNvbHZlLCB0aGlzLl9iYXRjaEluZGV4ID0gMCwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA8PSBfU3ByaXRlc2hlZXQyLkJBVENIX1NJWkUgPyAodGhpcy5fcHJvY2Vzc0ZyYW1lcygwKSwgdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKSwgdGhpcy5fcGFyc2VDb21wbGV0ZSgpKSA6IHRoaXMuX25leHRCYXRjaCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgYmF0Y2ggb2YgZnJhbWVzXG4gICAqIEBwYXJhbSBpbml0aWFsRnJhbWVJbmRleCAtIFRoZSBpbmRleCBvZiBmcmFtZSB0byBzdGFydC5cbiAgICovXG4gIF9wcm9jZXNzRnJhbWVzKGluaXRpYWxGcmFtZUluZGV4KSB7XG4gICAgbGV0IGZyYW1lSW5kZXggPSBpbml0aWFsRnJhbWVJbmRleDtcbiAgICBjb25zdCBtYXhGcmFtZXMgPSBfU3ByaXRlc2hlZXQyLkJBVENIX1NJWkU7XG4gICAgZm9yICg7IGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZnJhbWVLZXlzW2ZyYW1lSW5kZXhdLCBkYXRhID0gdGhpcy5fZnJhbWVzW2ldLCByZWN0ID0gZGF0YS5mcmFtZTtcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIGxldCBmcmFtZSA9IG51bGwsIHRyaW0gPSBudWxsO1xuICAgICAgICBjb25zdCBzb3VyY2VTaXplID0gZGF0YS50cmltbWVkICE9PSAhMSAmJiBkYXRhLnNvdXJjZVNpemUgPyBkYXRhLnNvdXJjZVNpemUgOiBkYXRhLmZyYW1lLCBvcmlnID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VTaXplLncpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3Ioc291cmNlU2l6ZS5oKSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgICBkYXRhLnJvdGF0ZWQgPyBmcmFtZSA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICkgOiBmcmFtZSA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICksIGRhdGEudHJpbW1lZCAhPT0gITEgJiYgZGF0YS5zcHJpdGVTb3VyY2VTaXplICYmICh0cmltID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS54KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICkpLCB0aGlzLnRleHR1cmVzW2ldID0gbmV3IFRleHR1cmUoXG4gICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSxcbiAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICBvcmlnLFxuICAgICAgICAgIHRyaW0sXG4gICAgICAgICAgZGF0YS5yb3RhdGVkID8gMiA6IDAsXG4gICAgICAgICAgZGF0YS5hbmNob3IsXG4gICAgICAgICAgZGF0YS5ib3JkZXJzXG4gICAgICAgICksIFRleHR1cmUuYWRkVG9DYWNoZSh0aGlzLnRleHR1cmVzW2ldLCBpLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgZnJhbWVJbmRleCsrO1xuICAgIH1cbiAgfVxuICAvKiogUGFyc2UgYW5pbWF0aW9ucyBjb25maWcuICovXG4gIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XG4gICAgZm9yIChjb25zdCBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1hdGlvbnNbYW5pbU5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lTmFtZSA9IGFuaW1hdGlvbnNbYW5pbU5hbWVdW2ldO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdLnB1c2godGhpcy50ZXh0dXJlc1tmcmFtZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLiAqL1xuICBfcGFyc2VDb21wbGV0ZSgpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbCwgdGhpcy5fYmF0Y2hJbmRleCA9IDAsIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy50ZXh0dXJlcyk7XG4gIH1cbiAgLyoqIEJlZ2luIHRoZSBuZXh0IGJhdGNoIG9mIHRleHR1cmVzLiAqL1xuICBfbmV4dEJhdGNoKCkge1xuICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldDIuQkFUQ0hfU0laRSksIHRoaXMuX2JhdGNoSW5kZXgrKywgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9iYXRjaEluZGV4ICogX1Nwcml0ZXNoZWV0Mi5CQVRDSF9TSVpFIDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA/IHRoaXMuX25leHRCYXRjaCgpIDogKHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCksIHRoaXMuX3BhcnNlQ29tcGxldGUoKSk7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgU3ByaXRlc2hlZXQgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCYXNlID0gITEpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlcylcbiAgICAgIHRoaXMudGV4dHVyZXNbaV0uZGVzdHJveSgpO1xuICAgIHRoaXMuX2ZyYW1lcyA9IG51bGwsIHRoaXMuX2ZyYW1lS2V5cyA9IG51bGwsIHRoaXMuZGF0YSA9IG51bGwsIHRoaXMudGV4dHVyZXMgPSBudWxsLCBkZXN0cm95QmFzZSAmJiAodGhpcy5fdGV4dHVyZT8uZGVzdHJveSgpLCB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKSksIHRoaXMuX3RleHR1cmUgPSBudWxsLCB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbCwgdGhpcy5saW5rZWRTaGVldHMgPSBbXTtcbiAgfVxufTtcbl9TcHJpdGVzaGVldC5CQVRDSF9TSVpFID0gMWUzO1xubGV0IFNwcml0ZXNoZWV0ID0gX1Nwcml0ZXNoZWV0O1xuZXhwb3J0IHtcbiAgU3ByaXRlc2hlZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGVzaGVldC5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSwgY29weVNlYXJjaFBhcmFtcyB9IGZyb20gXCJAcGl4aS9hc3NldHNcIjtcbmltcG9ydCB7IHV0aWxzLCBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBTcHJpdGVzaGVldCB9IGZyb20gXCIuL1Nwcml0ZXNoZWV0Lm1qc1wiO1xuY29uc3QgdmFsaWRJbWFnZXMgPSBbXCJqcGdcIiwgXCJwbmdcIiwgXCJqcGVnXCIsIFwiYXZpZlwiLCBcIndlYnBcIl07XG5mdW5jdGlvbiBnZXRDYWNoZWFibGVBc3NldHMoa2V5cywgYXNzZXQsIGlnbm9yZU11bHRpUGFjaykge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgaWYgKGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3V0W2tleV0gPSBhc3NldDtcbiAgfSksIE9iamVjdC5rZXlzKGFzc2V0LnRleHR1cmVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvdXRba2V5XSA9IGFzc2V0LnRleHR1cmVzW2tleV07XG4gIH0pLCAhaWdub3JlTXVsdGlQYWNrKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSB1dGlscy5wYXRoLmRpcm5hbWUoa2V5c1swXSk7XG4gICAgYXNzZXQubGlua2VkU2hlZXRzLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IG91dDIgPSBnZXRDYWNoZWFibGVBc3NldHMoW2Ake2Jhc2VQYXRofS8ke2Fzc2V0LmRhdGEubWV0YS5yZWxhdGVkX211bHRpX3BhY2tzW2ldfWBdLCBpdGVtLCAhMCk7XG4gICAgICBPYmplY3QuYXNzaWduKG91dCwgb3V0Mik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IHNwcml0ZXNoZWV0QXNzZXQgPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5Bc3NldCxcbiAgLyoqIEhhbmRsZSB0aGUgY2FjaGluZyBvZiB0aGUgcmVsYXRlZCBTcHJpdGVzaGVldCBUZXh0dXJlcyAqL1xuICBjYWNoZToge1xuICAgIHRlc3Q6IChhc3NldCkgPT4gYXNzZXQgaW5zdGFuY2VvZiBTcHJpdGVzaGVldCxcbiAgICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCAhMSlcbiAgfSxcbiAgLyoqIFJlc29sdmUgdGhlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBhc3NldC4gKi9cbiAgcmVzb2x2ZXI6IHtcbiAgICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHNwbGl0ID0gdmFsdWUuc3BsaXQoXCI/XCIpWzBdLnNwbGl0KFwiLlwiKSwgZXh0ZW5zaW9uID0gc3BsaXQucG9wKCksIGZvcm1hdCA9IHNwbGl0LnBvcCgpO1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbiA9PT0gXCJqc29uXCIgJiYgdmFsaWRJbWFnZXMuaW5jbHVkZXMoZm9ybWF0KTtcbiAgICB9LFxuICAgIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHNwbGl0ID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChzZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgICBmb3JtYXQ6IHNwbGl0W3NwbGl0Lmxlbmd0aCAtIDJdLFxuICAgICAgICBzcmM6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIExvYWRlciBwbHVnaW4gdGhhdCBwYXJzZXMgc3ByaXRlIHNoZWV0cyFcbiAgICogb25jZSB0aGUgSlNPTiBoYXMgYmVlbiBsb2FkZWQgdGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBKU09OIGlzIHNwcml0ZXNoZWV0IGRhdGEuXG4gICAqIElmIGl0IGlzLCB3ZSBsb2FkIHRoZSBzcHJpdGVzaGVldHMgaW1hZ2UgYW5kIHBhcnNlIHRoZSBkYXRhIGludG8gUElYSS5TcHJpdGVzaGVldFxuICAgKiBBbGwgdGV4dHVyZXMgaW4gdGhlIHNwcml0ZSBzaGVldCBhcmUgdGhlbiBhZGRlZCB0byB0aGUgY2FjaGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbG9hZGVyOiB7XG4gICAgbmFtZTogXCJzcHJpdGVzaGVldExvYWRlclwiLFxuICAgIGV4dGVuc2lvbjoge1xuICAgICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICAgIH0sXG4gICAgYXN5bmMgdGVzdFBhcnNlKGFzc2V0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdXRpbHMucGF0aC5leHRuYW1lKG9wdGlvbnMuc3JjKS50b0xvd2VyQ2FzZSgpID09PSBcIi5qc29uXCIgJiYgISFhc3NldC5mcmFtZXM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZShhc3NldCwgb3B0aW9ucywgbG9hZGVyKSB7XG4gICAgICBsZXQgYmFzZVBhdGggPSB1dGlscy5wYXRoLmRpcm5hbWUob3B0aW9ucy5zcmMpO1xuICAgICAgYmFzZVBhdGggJiYgYmFzZVBhdGgubGFzdEluZGV4T2YoXCIvXCIpICE9PSBiYXNlUGF0aC5sZW5ndGggLSAxICYmIChiYXNlUGF0aCArPSBcIi9cIik7XG4gICAgICBsZXQgaW1hZ2VQYXRoID0gYmFzZVBhdGggKyBhc3NldC5tZXRhLmltYWdlO1xuICAgICAgaW1hZ2VQYXRoID0gY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIG9wdGlvbnMuc3JjKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSAoYXdhaXQgbG9hZGVyLmxvYWQoW2ltYWdlUGF0aF0pKVtpbWFnZVBhdGhdLCBzcHJpdGVzaGVldCA9IG5ldyBTcHJpdGVzaGVldChcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZSxcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIG9wdGlvbnMuc3JjXG4gICAgICApO1xuICAgICAgYXdhaXQgc3ByaXRlc2hlZXQucGFyc2UoKTtcbiAgICAgIGNvbnN0IG11bHRpUGFja3MgPSBhc3NldD8ubWV0YT8ucmVsYXRlZF9tdWx0aV9wYWNrcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG11bHRpUGFja3MpKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtdWx0aVBhY2tzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBsZXQgaXRlbVVybCA9IGJhc2VQYXRoICsgaXRlbTtcbiAgICAgICAgICBvcHRpb25zLmRhdGE/Lmlnbm9yZU11bHRpUGFjayB8fCAoaXRlbVVybCA9IGNvcHlTZWFyY2hQYXJhbXMoaXRlbVVybCwgb3B0aW9ucy5zcmMpLCBwcm9taXNlcy5wdXNoKGxvYWRlci5sb2FkKHtcbiAgICAgICAgICAgIHNyYzogaXRlbVVybCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaWdub3JlTXVsdGlQYWNrOiAhMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICBzcHJpdGVzaGVldC5saW5rZWRTaGVldHMgPSByZXMsIHJlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaXRlbS5saW5rZWRTaGVldHMgPSBbc3ByaXRlc2hlZXRdLmNvbmNhdChzcHJpdGVzaGVldC5saW5rZWRTaGVldHMuZmlsdGVyKChzcCkgPT4gc3AgIT09IGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ByaXRlc2hlZXQ7XG4gICAgfSxcbiAgICB1bmxvYWQoc3ByaXRlc2hlZXQpIHtcbiAgICAgIHNwcml0ZXNoZWV0LmRlc3Ryb3koITApO1xuICAgIH1cbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKHNwcml0ZXNoZWV0QXNzZXQpO1xuZXhwb3J0IHtcbiAgc3ByaXRlc2hlZXRBc3NldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZXNoZWV0QXNzZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgU3ByaXRlc2hlZXQgfSBmcm9tIFwiLi9TcHJpdGVzaGVldC5tanNcIjtcbmltcG9ydCB7IHNwcml0ZXNoZWV0QXNzZXQgfSBmcm9tIFwiLi9zcHJpdGVzaGVldEFzc2V0Lm1qc1wiO1xuZXhwb3J0IHtcbiAgU3ByaXRlc2hlZXQsXG4gIHNwcml0ZXNoZWV0QXNzZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjbGFzcyBCaXRtYXBGb250RGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5mbyA9IFtdLCB0aGlzLmNvbW1vbiA9IFtdLCB0aGlzLnBhZ2UgPSBbXSwgdGhpcy5jaGFyID0gW10sIHRoaXMua2VybmluZyA9IFtdLCB0aGlzLmRpc3RhbmNlRmllbGQgPSBbXTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQml0bWFwRm9udERhdGFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBGb250RGF0YS5tanMubWFwXG4iLCJpbXBvcnQgeyBCaXRtYXBGb250RGF0YSB9IGZyb20gXCIuLi9CaXRtYXBGb250RGF0YS5tanNcIjtcbmNsYXNzIFRleHRGb3JtYXQge1xuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzb3VyY2UgcmVmZXJzIHRvIHR4dCBmb250IGRhdGEuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiByZXNvdXJjZSBjb3VsZCBiZSB0cmVhdGVkIGFzIGZvbnQgZGF0YSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiICYmIGRhdGEuc3RhcnRzV2l0aChcImluZm8gZmFjZT1cIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGV4dCBmb250IGRhdGEgdG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAgICogQHBhcmFtIHR4dCAtIFJhdyBzdHJpbmcgZGF0YSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybnMgLSBQYXJzZWQgZm9udCBkYXRhXG4gICAqL1xuICBzdGF0aWMgcGFyc2UodHh0KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0eHQubWF0Y2goL15bYS16XStcXHMrLiskL2dtKSwgcmF3RGF0YSA9IHtcbiAgICAgIGluZm86IFtdLFxuICAgICAgY29tbW9uOiBbXSxcbiAgICAgIHBhZ2U6IFtdLFxuICAgICAgY2hhcjogW10sXG4gICAgICBjaGFyczogW10sXG4gICAgICBrZXJuaW5nOiBbXSxcbiAgICAgIGtlcm5pbmdzOiBbXSxcbiAgICAgIGRpc3RhbmNlRmllbGQ6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaXRlbXMpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdGVtc1tpXS5tYXRjaCgvXlthLXpdKy9nbSlbMF0sIGF0dHJpYnV0ZUxpc3QgPSBpdGVtc1tpXS5tYXRjaCgvW2EtekEtWl0rPShbXlxcc1wiJ10rfFwiKFteXCJdKilcIikvZ20pLCBpdGVtRGF0YSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpMiBpbiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gYXR0cmlidXRlTGlzdFtpMl0uc3BsaXQoXCI9XCIpLCBrZXkgPSBzcGxpdFswXSwgc3RyVmFsdWUgPSBzcGxpdFsxXS5yZXBsYWNlKC9cIi9nbSwgXCJcIiksIGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KHN0clZhbHVlKSwgdmFsdWUgPSBpc05hTihmbG9hdFZhbHVlKSA/IHN0clZhbHVlIDogZmxvYXRWYWx1ZTtcbiAgICAgICAgaXRlbURhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmF3RGF0YVtuYW1lXS5wdXNoKGl0ZW1EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xuICAgIHJldHVybiByYXdEYXRhLmluZm8uZm9yRWFjaCgoaW5mbykgPT4gZm9udC5pbmZvLnB1c2goe1xuICAgICAgZmFjZTogaW5mby5mYWNlLFxuICAgICAgc2l6ZTogcGFyc2VJbnQoaW5mby5zaXplLCAxMClcbiAgICB9KSksIHJhd0RhdGEuY29tbW9uLmZvckVhY2goKGNvbW1vbikgPT4gZm9udC5jb21tb24ucHVzaCh7XG4gICAgICBsaW5lSGVpZ2h0OiBwYXJzZUludChjb21tb24ubGluZUhlaWdodCwgMTApXG4gICAgfSkpLCByYXdEYXRhLnBhZ2UuZm9yRWFjaCgocGFnZSkgPT4gZm9udC5wYWdlLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KHBhZ2UuaWQsIDEwKSxcbiAgICAgIGZpbGU6IHBhZ2UuZmlsZVxuICAgIH0pKSwgcmF3RGF0YS5jaGFyLmZvckVhY2goKGNoYXIpID0+IGZvbnQuY2hhci5wdXNoKHtcbiAgICAgIGlkOiBwYXJzZUludChjaGFyLmlkLCAxMCksXG4gICAgICBwYWdlOiBwYXJzZUludChjaGFyLnBhZ2UsIDEwKSxcbiAgICAgIHg6IHBhcnNlSW50KGNoYXIueCwgMTApLFxuICAgICAgeTogcGFyc2VJbnQoY2hhci55LCAxMCksXG4gICAgICB3aWR0aDogcGFyc2VJbnQoY2hhci53aWR0aCwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChjaGFyLmhlaWdodCwgMTApLFxuICAgICAgeG9mZnNldDogcGFyc2VJbnQoY2hhci54b2Zmc2V0LCAxMCksXG4gICAgICB5b2Zmc2V0OiBwYXJzZUludChjaGFyLnlvZmZzZXQsIDEwKSxcbiAgICAgIHhhZHZhbmNlOiBwYXJzZUludChjaGFyLnhhZHZhbmNlLCAxMClcbiAgICB9KSksIHJhd0RhdGEua2VybmluZy5mb3JFYWNoKChrZXJuaW5nKSA9PiBmb250Lmtlcm5pbmcucHVzaCh7XG4gICAgICBmaXJzdDogcGFyc2VJbnQoa2VybmluZy5maXJzdCwgMTApLFxuICAgICAgc2Vjb25kOiBwYXJzZUludChrZXJuaW5nLnNlY29uZCwgMTApLFxuICAgICAgYW1vdW50OiBwYXJzZUludChrZXJuaW5nLmFtb3VudCwgMTApXG4gICAgfSkpLCByYXdEYXRhLmRpc3RhbmNlRmllbGQuZm9yRWFjaCgoZGYpID0+IGZvbnQuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgIGRpc3RhbmNlUmFuZ2U6IHBhcnNlSW50KGRmLmRpc3RhbmNlUmFuZ2UsIDEwKSxcbiAgICAgIGZpZWxkVHlwZTogZGYuZmllbGRUeXBlXG4gICAgfSkpLCBmb250O1xuICB9XG59XG5leHBvcnQge1xuICBUZXh0Rm9ybWF0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dEZvcm1hdC5tanMubWFwXG4iLCJpbXBvcnQgeyBCaXRtYXBGb250RGF0YSB9IGZyb20gXCIuLi9CaXRtYXBGb250RGF0YS5tanNcIjtcbmNsYXNzIFhNTEZvcm1hdCB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiByZXNvdXJjZSByZWZlcnMgdG8geG1sIGZvbnQgZGF0YS5cbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHJlc291cmNlIGNvdWxkIGJlIHRyZWF0ZWQgYXMgZm9udCBkYXRhLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgdGVzdChkYXRhKSB7XG4gICAgY29uc3QgeG1sID0gZGF0YTtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgIT0gXCJzdHJpbmdcIiAmJiBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIgaW4gZGF0YSAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpLmxlbmd0aCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbmZvXCIpWzBdLmdldEF0dHJpYnV0ZShcImZhY2VcIikgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIFhNTCBpbnRvIEJpdG1hcEZvbnREYXRhIHRoYXQgd2UgY2FuIHVzZS5cbiAgICogQHBhcmFtIHhtbFxuICAgKiBAcmV0dXJucyAtIERhdGEgdG8gdXNlIGZvciBCaXRtYXBGb250XG4gICAqL1xuICBzdGF0aWMgcGFyc2UoeG1sKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBCaXRtYXBGb250RGF0YSgpLCBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKSwgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29tbW9uXCIpLCBwYWdlID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFnZVwiKSwgY2hhciA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNoYXJcIiksIGtlcm5pbmcgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJrZXJuaW5nXCIpLCBkaXN0YW5jZUZpZWxkID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGlzdGFuY2VGaWVsZFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZm8ubGVuZ3RoOyBpKyspXG4gICAgICBkYXRhLmluZm8ucHVzaCh7XG4gICAgICAgIGZhY2U6IGluZm9baV0uZ2V0QXR0cmlidXRlKFwiZmFjZVwiKSxcbiAgICAgICAgc2l6ZTogcGFyc2VJbnQoaW5mb1tpXS5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbW9uLmxlbmd0aDsgaSsrKVxuICAgICAgZGF0YS5jb21tb24ucHVzaCh7XG4gICAgICAgIGxpbmVIZWlnaHQ6IHBhcnNlSW50KGNvbW1vbltpXS5nZXRBdHRyaWJ1dGUoXCJsaW5lSGVpZ2h0XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZS5sZW5ndGg7IGkrKylcbiAgICAgIGRhdGEucGFnZS5wdXNoKHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhZ2VbaV0uZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSB8fCAwLFxuICAgICAgICBmaWxlOiBwYWdlW2ldLmdldEF0dHJpYnV0ZShcImZpbGVcIilcbiAgICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGV0dGVyID0gY2hhcltpXTtcbiAgICAgIGRhdGEuY2hhci5wdXNoKHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKSwgMTApLFxuICAgICAgICBwYWdlOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwicGFnZVwiKSwgMTApIHx8IDAsXG4gICAgICAgIHg6IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoXCJ4XCIpLCAxMCksXG4gICAgICAgIHk6IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoXCJ5XCIpLCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksIDEwKSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpLCAxMCksXG4gICAgICAgIHhvZmZzZXQ6IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoXCJ4b2Zmc2V0XCIpLCAxMCksXG4gICAgICAgIHlvZmZzZXQ6IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoXCJ5b2Zmc2V0XCIpLCAxMCksXG4gICAgICAgIHhhZHZhbmNlOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieGFkdmFuY2VcIiksIDEwKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmluZy5sZW5ndGg7IGkrKylcbiAgICAgIGRhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiZmlyc3RcIiksIDEwKSxcbiAgICAgICAgc2Vjb25kOiBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcInNlY29uZFwiKSwgMTApLFxuICAgICAgICBhbW91bnQ6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlzdGFuY2VGaWVsZC5sZW5ndGg7IGkrKylcbiAgICAgIGRhdGEuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgICAgZmllbGRUeXBlOiBkaXN0YW5jZUZpZWxkW2ldLmdldEF0dHJpYnV0ZShcImZpZWxkVHlwZVwiKSxcbiAgICAgICAgZGlzdGFuY2VSYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZFtpXS5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5leHBvcnQge1xuICBYTUxGb3JtYXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1YTUxGb3JtYXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgWE1MRm9ybWF0IH0gZnJvbSBcIi4vWE1MRm9ybWF0Lm1qc1wiO1xuY2xhc3MgWE1MU3RyaW5nRm9ybWF0IHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlc291cmNlIHJlZmVycyB0byB0ZXh0IHhtbCBmb250IGRhdGEuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiByZXNvdXJjZSBjb3VsZCBiZSB0cmVhdGVkIGFzIGZvbnQgZGF0YSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiICYmIGRhdGEuaW5jbHVkZXMoXCI8Zm9udD5cIikgPyBYTUxGb3JtYXQudGVzdChzZXR0aW5ncy5BREFQVEVSLnBhcnNlWE1MKGRhdGEpKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSB0ZXh0IFhNTCBpbnRvIEJpdG1hcEZvbnREYXRhIHRoYXQgd2UgY2FuIHVzZS5cbiAgICogQHBhcmFtIHhtbFR4dFxuICAgKiBAcmV0dXJucyAtIERhdGEgdG8gdXNlIGZvciBCaXRtYXBGb250XG4gICAqL1xuICBzdGF0aWMgcGFyc2UoeG1sVHh0KSB7XG4gICAgcmV0dXJuIFhNTEZvcm1hdC5wYXJzZShzZXR0aW5ncy5BREFQVEVSLnBhcnNlWE1MKHhtbFR4dCkpO1xuICB9XG59XG5leHBvcnQge1xuICBYTUxTdHJpbmdGb3JtYXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1YTUxTdHJpbmdGb3JtYXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dEZvcm1hdCB9IGZyb20gXCIuL1RleHRGb3JtYXQubWpzXCI7XG5pbXBvcnQgeyBYTUxGb3JtYXQgfSBmcm9tIFwiLi9YTUxGb3JtYXQubWpzXCI7XG5pbXBvcnQgeyBYTUxTdHJpbmdGb3JtYXQgfSBmcm9tIFwiLi9YTUxTdHJpbmdGb3JtYXQubWpzXCI7XG5jb25zdCBmb3JtYXRzID0gW1xuICBUZXh0Rm9ybWF0LFxuICBYTUxGb3JtYXQsXG4gIFhNTFN0cmluZ0Zvcm1hdFxuXTtcbmZ1bmN0aW9uIGF1dG9EZXRlY3RGb3JtYXQoZGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGZvcm1hdHNbaV0udGVzdChkYXRhKSlcbiAgICAgIHJldHVybiBmb3JtYXRzW2ldO1xuICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCB7XG4gIFRleHRGb3JtYXQsXG4gIFhNTEZvcm1hdCxcbiAgWE1MU3RyaW5nRm9ybWF0LFxuICBhdXRvRGV0ZWN0Rm9ybWF0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gXCJAcGl4aS90ZXh0XCI7XG5mdW5jdGlvbiBnZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBsaW5lcywgbWV0cmljcykge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICBpZiAoQXJyYXkuaXNBcnJheShmaWxsU3R5bGUpKSB7XG4gICAgaWYgKGZpbGxTdHlsZS5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gZmlsbFN0eWxlWzBdO1xuICB9IGVsc2VcbiAgICByZXR1cm4gZmlsbFN0eWxlO1xuICBsZXQgZ3JhZGllbnQ7XG4gIGNvbnN0IGRyb3BTaGFkb3dDb3JyZWN0aW9uID0gc3R5bGUuZHJvcFNoYWRvdyA/IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA6IDAsIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nIHx8IDAsIHdpZHRoID0gY2FudmFzLndpZHRoIC8gcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDIsIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgLyByZXNvbHV0aW9uIC0gZHJvcFNoYWRvd0NvcnJlY3Rpb24gLSBwYWRkaW5nICogMiwgZmlsbCA9IGZpbGxTdHlsZS5zbGljZSgpLCBmaWxsR3JhZGllbnRTdG9wcyA9IHN0eWxlLmZpbGxHcmFkaWVudFN0b3BzLnNsaWNlKCk7XG4gIGlmICghZmlsbEdyYWRpZW50U3RvcHMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGhQbHVzMTsgKytpKVxuICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICB9XG4gIGlmIChmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKSwgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKSwgZmlsbC5wdXNoKGZpbGxTdHlsZVtmaWxsU3R5bGUubGVuZ3RoIC0gMV0pLCBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpLCBzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBURVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCkge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh3aWR0aCAvIDIsIHBhZGRpbmcsIHdpZHRoIC8gMiwgaGVpZ2h0ICsgcGFkZGluZyk7XG4gICAgbGV0IGxhc3RJdGVyYXRpb25TdG9wID0gMDtcbiAgICBjb25zdCBncmFkU3RvcExpbmVIZWlnaHQgPSAobWV0cmljcy5mb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykgLyBoZWlnaHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGhpc0xpbmVUb3AgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiBpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBsaW5lU3RvcCA9IDA7XG4gICAgICAgIHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PSBcIm51bWJlclwiID8gbGluZVN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tqXSA6IGxpbmVTdG9wID0gaiAvIGZpbGwubGVuZ3RoO1xuICAgICAgICBjb25zdCBnbG9iYWxTdG9wID0gdGhpc0xpbmVUb3AgLyBoZWlnaHQgKyBsaW5lU3RvcCAqIGdyYWRTdG9wTGluZUhlaWdodDtcbiAgICAgICAgbGV0IGNsYW1wZWRTdG9wID0gTWF0aC5tYXgobGFzdEl0ZXJhdGlvblN0b3AsIGdsb2JhbFN0b3ApO1xuICAgICAgICBjbGFtcGVkU3RvcCA9IE1hdGgubWluKGNsYW1wZWRTdG9wLCAxKSwgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGNsYW1wZWRTdG9wLCBmaWxsW2pdKSwgbGFzdEl0ZXJhdGlvblN0b3AgPSBjbGFtcGVkU3RvcDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHBhZGRpbmcsIGhlaWdodCAvIDIsIHdpZHRoICsgcGFkZGluZywgaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgdG90YWxJdGVyYXRpb25zID0gZmlsbC5sZW5ndGggKyAxO1xuICAgIGxldCBjdXJyZW50SXRlcmF0aW9uID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdG9wO1xuICAgICAgdHlwZW9mIGZpbGxHcmFkaWVudFN0b3BzW2ldID09IFwibnVtYmVyXCIgPyBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbaV0gOiBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucywgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaV0pLCBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBncmFkaWVudDtcbn1cbmV4cG9ydCB7XG4gIGdlbmVyYXRlRmlsbFN0eWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVGaWxsU3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVGaWxsU3R5bGUgfSBmcm9tIFwiLi9nZW5lcmF0ZUZpbGxTdHlsZS5tanNcIjtcbmZ1bmN0aW9uIGRyYXdHbHlwaChjYW52YXMsIGNvbnRleHQsIG1ldHJpY3MsIHgsIHksIHJlc29sdXRpb24sIHN0eWxlKSB7XG4gIGNvbnN0IGNoYXIgPSBtZXRyaWNzLnRleHQsIGZvbnRQcm9wZXJ0aWVzID0gbWV0cmljcy5mb250UHJvcGVydGllcztcbiAgY29udGV4dC50cmFuc2xhdGUoeCwgeSksIGNvbnRleHQuc2NhbGUocmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gIGNvbnN0IHR4ID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiwgdHkgPSAtKHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIpO1xuICBpZiAoY29udGV4dC5mb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCksIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzLCBjb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSwgY29udGV4dC5saW5lSm9pbiA9IHN0eWxlLmxpbmVKb2luLCBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0LCBjb250ZXh0LmZpbGxTdHlsZSA9IGdlbmVyYXRlRmlsbFN0eWxlKGNhbnZhcywgY29udGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIFtjaGFyXSwgbWV0cmljcyksIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2UsIHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICBjb25zdCBkcm9wU2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3IsIGRyb3BTaGFkb3dCbHVyID0gc3R5bGUuZHJvcFNoYWRvd0JsdXIgKiByZXNvbHV0aW9uLCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgKiByZXNvbHV0aW9uO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpLCBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1ciwgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSwgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgfSBlbHNlXG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIiwgY29udGV4dC5zaGFkb3dCbHVyID0gMCwgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMCwgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgc3R5bGUuc3Ryb2tlICYmIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAmJiBjb250ZXh0LnN0cm9rZVRleHQoY2hhciwgdHgsIHR5ICsgbWV0cmljcy5saW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZGVzY2VudCksIHN0eWxlLmZpbGwgJiYgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBtZXRyaWNzLmxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5kZXNjZW50KSwgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCksIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG59XG5leHBvcnQge1xuICBkcmF3R2x5cGhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3R2x5cGgubWpzLm1hcFxuIiwiaW1wb3J0IHsgZHJhd0dseXBoIH0gZnJvbSBcIi4vZHJhd0dseXBoLm1qc1wiO1xuaW1wb3J0IHsgZXh0cmFjdENoYXJDb2RlIH0gZnJvbSBcIi4vZXh0cmFjdENoYXJDb2RlLm1qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVGaWxsU3R5bGUgfSBmcm9tIFwiLi9nZW5lcmF0ZUZpbGxTdHlsZS5tanNcIjtcbmltcG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH0gZnJvbSBcIi4vcmVzb2x2ZUNoYXJhY3RlcnMubWpzXCI7XG5pbXBvcnQgeyBzcGxpdFRleHRUb0NoYXJhY3RlcnMgfSBmcm9tIFwiLi9zcGxpdFRleHRUb0NoYXJhY3RlcnMubWpzXCI7XG5leHBvcnQge1xuICBkcmF3R2x5cGgsXG4gIGV4dHJhY3RDaGFyQ29kZSxcbiAgZ2VuZXJhdGVGaWxsU3R5bGUsXG4gIHJlc29sdmVDaGFyYWN0ZXJzLFxuICBzcGxpdFRleHRUb0NoYXJhY3RlcnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJmdW5jdGlvbiBzcGxpdFRleHRUb0NoYXJhY3RlcnModGV4dCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSA/IEFycmF5LmZyb20odGV4dCkgOiB0ZXh0LnNwbGl0KFwiXCIpO1xufVxuZXhwb3J0IHtcbiAgc3BsaXRUZXh0VG9DaGFyYWN0ZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImltcG9ydCB7IHNwbGl0VGV4dFRvQ2hhcmFjdGVycyB9IGZyb20gXCIuL3NwbGl0VGV4dFRvQ2hhcmFjdGVycy5tanNcIjtcbmZ1bmN0aW9uIHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIHR5cGVvZiBjaGFycyA9PSBcInN0cmluZ1wiICYmIChjaGFycyA9IFtjaGFyc10pO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBjaGFycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gY2hhcnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGlmIChpdGVtLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgY29uc3Qgc3RhcnRDb2RlID0gaXRlbVswXS5jaGFyQ29kZUF0KDApLCBlbmRDb2RlID0gaXRlbVsxXS5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGVuZENvZGUgPCBzdGFydENvZGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2UuXCIpO1xuICAgICAgZm9yIChsZXQgaTIgPSBzdGFydENvZGUsIGoyID0gZW5kQ29kZTsgaTIgPD0gajI7IGkyKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICB9IGVsc2VcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnNwbGl0VGV4dFRvQ2hhcmFjdGVycyhpdGVtKSk7XG4gIH1cbiAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBFbXB0eSBzZXQgd2hlbiByZXNvbHZpbmcgY2hhcmFjdGVycy5cIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQge1xuICByZXNvbHZlQ2hhcmFjdGVyc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImZ1bmN0aW9uIGV4dHJhY3RDaGFyQ29kZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jb2RlUG9pbnRBdCA/IHN0ci5jb2RlUG9pbnRBdCgwKSA6IHN0ci5jaGFyQ29kZUF0KDApO1xufVxuZXhwb3J0IHtcbiAgZXh0cmFjdENoYXJDb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdENoYXJDb2RlLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzLCBBTFBIQV9NT0RFUywgTUlQTUFQX01PREVTLCBSZWN0YW5nbGUsIFRleHR1cmUsIHNldHRpbmdzLCBCYXNlVGV4dHVyZSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBUZXh0U3R5bGUsIFRleHRNZXRyaWNzIH0gZnJvbSBcIkBwaXhpL3RleHRcIjtcbmltcG9ydCB7IEJpdG1hcEZvbnREYXRhIH0gZnJvbSBcIi4vQml0bWFwRm9udERhdGEubWpzXCI7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0Rm9ybWF0IH0gZnJvbSBcIi4vZm9ybWF0cy9pbmRleC5tanNcIjtcbmltcG9ydCBcIi4vdXRpbHMvaW5kZXgubWpzXCI7XG5pbXBvcnQgeyByZXNvbHZlQ2hhcmFjdGVycyB9IGZyb20gXCIuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qc1wiO1xuaW1wb3J0IHsgZHJhd0dseXBoIH0gZnJvbSBcIi4vdXRpbHMvZHJhd0dseXBoLm1qc1wiO1xuaW1wb3J0IHsgZXh0cmFjdENoYXJDb2RlIH0gZnJvbSBcIi4vdXRpbHMvZXh0cmFjdENoYXJDb2RlLm1qc1wiO1xuY29uc3QgX0JpdG1hcEZvbnQgPSBjbGFzcyBfQml0bWFwRm9udDIge1xuICAvKipcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHBhcmFtIHRleHR1cmVzXG4gICAqIEBwYXJhbSBvd25zVGV4dHVyZXMgLSBTZXR0aW5nIHRvIGB0cnVlYCB3aWxsIGRlc3Ryb3kgcGFnZSB0ZXh0dXJlc1xuICAgKiAgICAgICAgd2hlbiB0aGUgZm9udCBpcyB1bmluc3RhbGxlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBjb25zdCBbaW5mb10gPSBkYXRhLmluZm8sIFtjb21tb25dID0gZGF0YS5jb21tb24sIFtwYWdlXSA9IGRhdGEucGFnZSwgW2Rpc3RhbmNlRmllbGRdID0gZGF0YS5kaXN0YW5jZUZpZWxkLCByZXMgPSB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwocGFnZS5maWxlKSwgcGFnZVRleHR1cmVzID0ge307XG4gICAgdGhpcy5fb3duc1RleHR1cmVzID0gb3duc1RleHR1cmVzLCB0aGlzLmZvbnQgPSBpbmZvLmZhY2UsIHRoaXMuc2l6ZSA9IGluZm8uc2l6ZSwgdGhpcy5saW5lSGVpZ2h0ID0gY29tbW9uLmxpbmVIZWlnaHQgLyByZXMsIHRoaXMuY2hhcnMgPSB7fSwgdGhpcy5wYWdlVGV4dHVyZXMgPSBwYWdlVGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgaWQsIGZpbGUgfSA9IGRhdGEucGFnZVtpXTtcbiAgICAgIHBhZ2VUZXh0dXJlc1tpZF0gPSB0ZXh0dXJlcyBpbnN0YW5jZW9mIEFycmF5ID8gdGV4dHVyZXNbaV0gOiB0ZXh0dXJlc1tmaWxlXSwgZGlzdGFuY2VGaWVsZD8uZmllbGRUeXBlICYmIGRpc3RhbmNlRmllbGQuZmllbGRUeXBlICE9PSBcIm5vbmVcIiAmJiAocGFnZVRleHR1cmVzW2lkXS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPSBBTFBIQV9NT0RFUy5OT19QUkVNVUxUSVBMSUVEX0FMUEhBLCBwYWdlVGV4dHVyZXNbaWRdLmJhc2VUZXh0dXJlLm1pcG1hcCA9IE1JUE1BUF9NT0RFUy5PRkYpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuY2hhci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBpZCwgcGFnZTogcGFnZTIgfSA9IGRhdGEuY2hhcltpXTtcbiAgICAgIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHhvZmZzZXQsIHlvZmZzZXQsIHhhZHZhbmNlIH0gPSBkYXRhLmNoYXJbaV07XG4gICAgICB4IC89IHJlcywgeSAvPSByZXMsIHdpZHRoIC89IHJlcywgaGVpZ2h0IC89IHJlcywgeG9mZnNldCAvPSByZXMsIHlvZmZzZXQgLz0gcmVzLCB4YWR2YW5jZSAvPSByZXM7XG4gICAgICBjb25zdCByZWN0ID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgeCArIHBhZ2VUZXh0dXJlc1twYWdlMl0uZnJhbWUueCAvIHJlcyxcbiAgICAgICAgeSArIHBhZ2VUZXh0dXJlc1twYWdlMl0uZnJhbWUueSAvIHJlcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hhcnNbaWRdID0ge1xuICAgICAgICB4T2Zmc2V0OiB4b2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiB5b2Zmc2V0LFxuICAgICAgICB4QWR2YW5jZTogeGFkdmFuY2UsXG4gICAgICAgIGtlcm5pbmc6IHt9LFxuICAgICAgICB0ZXh0dXJlOiBuZXcgVGV4dHVyZShcbiAgICAgICAgICBwYWdlVGV4dHVyZXNbcGFnZTJdLmJhc2VUZXh0dXJlLFxuICAgICAgICAgIHJlY3RcbiAgICAgICAgKSxcbiAgICAgICAgcGFnZTogcGFnZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5rZXJuaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBmaXJzdCwgc2Vjb25kLCBhbW91bnQgfSA9IGRhdGEua2VybmluZ1tpXTtcbiAgICAgIGZpcnN0IC89IHJlcywgc2Vjb25kIC89IHJlcywgYW1vdW50IC89IHJlcywgdGhpcy5jaGFyc1tzZWNvbmRdICYmICh0aGlzLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQpO1xuICAgIH1cbiAgICB0aGlzLmRpc3RhbmNlRmllbGRSYW5nZSA9IGRpc3RhbmNlRmllbGQ/LmRpc3RhbmNlUmFuZ2UsIHRoaXMuZGlzdGFuY2VGaWVsZFR5cGUgPSBkaXN0YW5jZUZpZWxkPy5maWVsZFR5cGU/LnRvTG93ZXJDYXNlKCkgPz8gXCJub25lXCI7XG4gIH1cbiAgLyoqIFJlbW92ZSByZWZlcmVuY2VzIHRvIGNyZWF0ZWQgZ2x5cGggdGV4dHVyZXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNoYXJzKVxuICAgICAgdGhpcy5jaGFyc1tpZF0udGV4dHVyZS5kZXN0cm95KCksIHRoaXMuY2hhcnNbaWRdLnRleHR1cmUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5wYWdlVGV4dHVyZXMpXG4gICAgICB0aGlzLl9vd25zVGV4dHVyZXMgJiYgdGhpcy5wYWdlVGV4dHVyZXNbaWRdLmRlc3Ryb3koITApLCB0aGlzLnBhZ2VUZXh0dXJlc1tpZF0gPSBudWxsO1xuICAgIHRoaXMuY2hhcnMgPSBudWxsLCB0aGlzLnBhZ2VUZXh0dXJlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbmV3IGJpdG1hcCBmb250LlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZVxuICAgKiAgICAgICAgY2hhcmFjdGVycyBtYXAgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBhcyB4bWwgb3IgcmF3IHN0cmluZy5cbiAgICogQHBhcmFtIHRleHR1cmVzIC0gTGlzdCBvZiB0ZXh0dXJlcyBmb3IgZWFjaCBwYWdlLlxuICAgKiBAcGFyYW0gb3duc1RleHR1cmVzIC0gU2V0IHRvIGB0cnVlYCB0byBkZXN0cm95IHBhZ2UgdGV4dHVyZXNcbiAgICogICAgICAgIHdoZW4gdGhlIGZvbnQgaXMgdW5pbnN0YWxsZWQuIEJ5IGRlZmF1bHQgZm9udHMgY3JlYXRlZCB3aXRoXG4gICAqICAgICAgICBgQml0bWFwRm9udC5mcm9tYCBvciBmcm9tIHRoZSBgQml0bWFwRm9udExvYWRlcmAgYXJlIGB0cnVlYC5cbiAgICogQHJldHVybnMge1BJWEkuQml0bWFwRm9udH0gUmVzdWx0IGZvbnQgb2JqZWN0IHdpdGggZm9udCwgc2l6ZSwgbGluZUhlaWdodFxuICAgKiAgICAgICAgIGFuZCBjaGFyIGZpZWxkcy5cbiAgICovXG4gIHN0YXRpYyBpbnN0YWxsKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBsZXQgZm9udERhdGE7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCaXRtYXBGb250RGF0YSlcbiAgICAgIGZvbnREYXRhID0gZGF0YTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGF1dG9EZXRlY3RGb3JtYXQoZGF0YSk7XG4gICAgICBpZiAoIWZvcm1hdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0IGZvciBmb250LlwiKTtcbiAgICAgIGZvbnREYXRhID0gZm9ybWF0LnBhcnNlKGRhdGEpO1xuICAgIH1cbiAgICB0ZXh0dXJlcyBpbnN0YW5jZW9mIFRleHR1cmUgJiYgKHRleHR1cmVzID0gW3RleHR1cmVzXSk7XG4gICAgY29uc3QgZm9udCA9IG5ldyBfQml0bWFwRm9udDIoZm9udERhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpO1xuICAgIHJldHVybiBfQml0bWFwRm9udDIuYXZhaWxhYmxlW2ZvbnQuZm9udF0gPSBmb250LCBmb250O1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYml0bWFwIGZvbnQgYnkgbmFtZS5cbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBmb250IHRvIHVuaW5zdGFsbC5cbiAgICovXG4gIHN0YXRpYyB1bmluc3RhbGwobmFtZSkge1xuICAgIGNvbnN0IGZvbnQgPSBfQml0bWFwRm9udDIuYXZhaWxhYmxlW25hbWVdO1xuICAgIGlmICghZm9udClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZm9udCBmb3VuZCBuYW1lZCAnJHtuYW1lfSdgKTtcbiAgICBmb250LmRlc3Ryb3koKSwgZGVsZXRlIF9CaXRtYXBGb250Mi5hdmFpbGFibGVbbmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGJpdG1hcC1mb250IGZvciB0aGUgZ2l2ZW4gc3R5bGUgYW5kIGNoYXJhY3RlciBzZXQuIFRoaXMgZG9lcyBub3Qgc3VwcG9ydFxuICAgKiBrZXJuaW5ncyB5ZXQuIFdpdGggYHN0eWxlYCBwcm9wZXJ0aWVzLCBvbmx5IHRoZSBmb2xsb3dpbmcgbm9uLWxheW91dCBwcm9wZXJ0aWVzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNkcm9wU2hhZG93fGRyb3BTaGFkb3d9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2Ryb3BTaGFkb3dEaXN0YW5jZXxkcm9wU2hhZG93RGlzdGFuY2V9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2Ryb3BTaGFkb3dDb2xvcnxkcm9wU2hhZG93Q29sb3J9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2Ryb3BTaGFkb3dCbHVyfGRyb3BTaGFkb3dCbHVyfVxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNkcm9wU2hhZG93QW5nbGV8ZHJvcFNoYWRvd0FuZ2xlfVxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNmaWxsfGZpbGx9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2ZpbGxHcmFkaWVudFN0b3BzfGZpbGxHcmFkaWVudFN0b3BzfVxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNmaWxsR3JhZGllbnRUeXBlfGZpbGxHcmFkaWVudFR5cGV9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2ZvbnRGYW1pbHl8Zm9udEZhbWlseX1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZm9udFNpemV8Zm9udFNpemV9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2ZvbnRWYXJpYW50fGZvbnRWYXJpYW50fVxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNmb250V2VpZ2h0fGZvbnRXZWlnaHR9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2xpbmVKb2lufGxpbmVKb2lufVxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNtaXRlckxpbWl0fG1pdGVyTGltaXR9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI3N0cm9rZXxzdHJva2V9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI3N0cm9rZVRoaWNrbmVzc3xzdHJva2VUaGlja25lc3N9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI3RleHRCYXNlbGluZXx0ZXh0QmFzZWxpbmV9XG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBmb250IHRvIHVzZSB3aXRoIEJpdG1hcFRleHQuXG4gICAqIEBwYXJhbSB0ZXh0U3R5bGUgLSBTdHlsZSBvcHRpb25zIHRvIHJlbmRlciB3aXRoIEJpdG1hcEZvbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2V0dXAgb3B0aW9ucyBmb3IgZm9udCBvciBuYW1lIG9mIHRoZSBmb250LlxuICAgKiBAcmV0dXJucyBGb250IGdlbmVyYXRlZCBieSBzdHlsZSBvcHRpb25zLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBCaXRtYXBGb250LCBCaXRtYXBUZXh0IH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIEJpdG1hcEZvbnQuZnJvbSgnVGl0bGVGb250Jywge1xuICAgKiAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICogICAgIGZvbnRTaXplOiAxMixcbiAgICogICAgIHN0cm9rZVRoaWNrbmVzczogMixcbiAgICogICAgIGZpbGw6ICdwdXJwbGUnLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgdGl0bGUgPSBuZXcgQml0bWFwVGV4dCgnVGhpcyBpcyB0aGUgdGl0bGUnLCB7IGZvbnROYW1lOiAnVGl0bGVGb250JyB9KTtcbiAgICovXG4gIHN0YXRpYyBmcm9tKG5hbWUsIHRleHRTdHlsZSwgb3B0aW9ucykge1xuICAgIGlmICghbmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XSBQcm9wZXJ0eSBgbmFtZWAgaXMgcmVxdWlyZWQuXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNoYXJzLFxuICAgICAgcGFkZGluZyxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICB0ZXh0dXJlV2lkdGgsXG4gICAgICB0ZXh0dXJlSGVpZ2h0LFxuICAgICAgLi4uYmFzZU9wdGlvbnNcbiAgICB9ID0gT2JqZWN0LmFzc2lnbih7fSwgX0JpdG1hcEZvbnQyLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSwgY2hhcnNMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpLCBzdHlsZSA9IHRleHRTdHlsZSBpbnN0YW5jZW9mIFRleHRTdHlsZSA/IHRleHRTdHlsZSA6IG5ldyBUZXh0U3R5bGUodGV4dFN0eWxlKSwgbGluZVdpZHRoID0gdGV4dHVyZVdpZHRoLCBmb250RGF0YSA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xuICAgIGZvbnREYXRhLmluZm9bMF0gPSB7XG4gICAgICBmYWNlOiBzdHlsZS5mb250RmFtaWx5LFxuICAgICAgc2l6ZTogc3R5bGUuZm9udFNpemVcbiAgICB9LCBmb250RGF0YS5jb21tb25bMF0gPSB7XG4gICAgICBsaW5lSGVpZ2h0OiBzdHlsZS5mb250U2l6ZVxuICAgIH07XG4gICAgbGV0IHBvc2l0aW9uWCA9IDAsIHBvc2l0aW9uWSA9IDAsIGNhbnZhcywgY29udGV4dCwgYmFzZVRleHR1cmUsIG1heENoYXJIZWlnaHQgPSAwO1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlcyA9IFtdLCB0ZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW52YXMgfHwgKGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCksIGNhbnZhcy53aWR0aCA9IHRleHR1cmVXaWR0aCwgY2FudmFzLmhlaWdodCA9IHRleHR1cmVIZWlnaHQsIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShjYW52YXMsIHsgcmVzb2x1dGlvbiwgLi4uYmFzZU9wdGlvbnMgfSksIGJhc2VUZXh0dXJlcy5wdXNoKGJhc2VUZXh0dXJlKSwgdGV4dHVyZXMucHVzaChuZXcgVGV4dHVyZShiYXNlVGV4dHVyZSkpLCBmb250RGF0YS5wYWdlLnB1c2goe1xuICAgICAgICBpZDogdGV4dHVyZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgZmlsZTogXCJcIlxuICAgICAgfSkpO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gY2hhcnNMaXN0W2ldLCBtZXRyaWNzID0gVGV4dE1ldHJpY3MubWVhc3VyZVRleHQoY2hhcmFjdGVyLCBzdHlsZSwgITEsIGNhbnZhcyksIHdpZHRoID0gbWV0cmljcy53aWR0aCwgaGVpZ2h0ID0gTWF0aC5jZWlsKG1ldHJpY3MuaGVpZ2h0KSwgdGV4dHVyZUdseXBoV2lkdGggPSBNYXRoLmNlaWwoKHN0eWxlLmZvbnRTdHlsZSA9PT0gXCJpdGFsaWNcIiA/IDIgOiAxKSAqIHdpZHRoKTtcbiAgICAgIGlmIChwb3NpdGlvblkgPj0gdGV4dHVyZUhlaWdodCAtIGhlaWdodCAqIHJlc29sdXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uWSA9PT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtCaXRtYXBGb250XSB0ZXh0dXJlSGVpZ2h0ICR7dGV4dHVyZUhlaWdodH1weCBpcyB0b28gc21hbGwgKGZvbnRGYW1pbHk6ICcke3N0eWxlLmZvbnRGYW1pbHl9JywgZm9udFNpemU6ICR7c3R5bGUuZm9udFNpemV9cHgsIGNoYXI6ICcke2NoYXJhY3Rlcn0nKWApO1xuICAgICAgICAtLWksIGNhbnZhcyA9IG51bGwsIGNvbnRleHQgPSBudWxsLCBiYXNlVGV4dHVyZSA9IG51bGwsIHBvc2l0aW9uWSA9IDAsIHBvc2l0aW9uWCA9IDAsIG1heENoYXJIZWlnaHQgPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhDaGFySGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0ICsgbWV0cmljcy5mb250UHJvcGVydGllcy5kZXNjZW50LCBtYXhDaGFySGVpZ2h0KSwgdGV4dHVyZUdseXBoV2lkdGggKiByZXNvbHV0aW9uICsgcG9zaXRpb25YID49IGxpbmVXaWR0aCkge1xuICAgICAgICBpZiAocG9zaXRpb25YID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdIHRleHR1cmVXaWR0aCAke3RleHR1cmVXaWR0aH1weCBpcyB0b28gc21hbGwgKGZvbnRGYW1pbHk6ICcke3N0eWxlLmZvbnRGYW1pbHl9JywgZm9udFNpemU6ICR7c3R5bGUuZm9udFNpemV9cHgsIGNoYXI6ICcke2NoYXJhY3Rlcn0nKWApO1xuICAgICAgICAtLWksIHBvc2l0aW9uWSArPSBtYXhDaGFySGVpZ2h0ICogcmVzb2x1dGlvbiwgcG9zaXRpb25ZID0gTWF0aC5jZWlsKHBvc2l0aW9uWSksIHBvc2l0aW9uWCA9IDAsIG1heENoYXJIZWlnaHQgPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRyYXdHbHlwaChjYW52YXMsIGNvbnRleHQsIG1ldHJpY3MsIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCByZXNvbHV0aW9uLCBzdHlsZSk7XG4gICAgICBjb25zdCBpZCA9IGV4dHJhY3RDaGFyQ29kZShtZXRyaWNzLnRleHQpO1xuICAgICAgZm9udERhdGEuY2hhci5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHBhZ2U6IHRleHR1cmVzLmxlbmd0aCAtIDEsXG4gICAgICAgIHg6IHBvc2l0aW9uWCAvIHJlc29sdXRpb24sXG4gICAgICAgIHk6IHBvc2l0aW9uWSAvIHJlc29sdXRpb24sXG4gICAgICAgIHdpZHRoOiB0ZXh0dXJlR2x5cGhXaWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4b2Zmc2V0OiAwLFxuICAgICAgICB5b2Zmc2V0OiAwLFxuICAgICAgICB4YWR2YW5jZTogd2lkdGggLSAoc3R5bGUuZHJvcFNoYWRvdyA/IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA6IDApIC0gKHN0eWxlLnN0cm9rZSA/IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyA6IDApXG4gICAgICB9KSwgcG9zaXRpb25YICs9ICh0ZXh0dXJlR2x5cGhXaWR0aCArIDIgKiBwYWRkaW5nKSAqIHJlc29sdXRpb24sIHBvc2l0aW9uWCA9IE1hdGguY2VpbChwb3NpdGlvblgpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnM/LnNraXBLZXJuaW5nKVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoYXJzTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBmaXJzdCA9IGNoYXJzTGlzdFtpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGNvbnN0IHNlY29uZCA9IGNoYXJzTGlzdFtqXSwgYzEgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0KS53aWR0aCwgYzIgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHNlY29uZCkud2lkdGgsIGFtb3VudCA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QgKyBzZWNvbmQpLndpZHRoIC0gKGMxICsgYzIpO1xuICAgICAgICAgIGFtb3VudCAmJiBmb250RGF0YS5rZXJuaW5nLnB1c2goe1xuICAgICAgICAgICAgZmlyc3Q6IGV4dHJhY3RDaGFyQ29kZShmaXJzdCksXG4gICAgICAgICAgICBzZWNvbmQ6IGV4dHJhY3RDaGFyQ29kZShzZWNvbmQpLFxuICAgICAgICAgICAgYW1vdW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjb25zdCBmb250ID0gbmV3IF9CaXRtYXBGb250Mihmb250RGF0YSwgdGV4dHVyZXMsICEwKTtcbiAgICByZXR1cm4gX0JpdG1hcEZvbnQyLmF2YWlsYWJsZVtuYW1lXSAhPT0gdm9pZCAwICYmIF9CaXRtYXBGb250Mi51bmluc3RhbGwobmFtZSksIF9CaXRtYXBGb250Mi5hdmFpbGFibGVbbmFtZV0gPSBmb250LCBmb250O1xuICB9XG59O1xuX0JpdG1hcEZvbnQuQUxQSEEgPSBbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBcIiBcIl0sIC8qKlxuKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIGRlY2ltYWwgZGlnaXRzIChmcm9tIDAgdG8gOSkuXG4qIEB0eXBlIHtzdHJpbmdbXVtdfVxuKiBAZXhhbXBsZVxuKiBCaXRtYXBGb250LmZyb20oJ0V4YW1wbGVGb250Jywgc3R5bGUsIHsgY2hhcnM6IEJpdG1hcEZvbnQuTlVNRVJJQyB9KVxuKi9cbl9CaXRtYXBGb250Lk5VTUVSSUMgPSBbW1wiMFwiLCBcIjlcIl1dLCAvKipcbiogVGhpcyBjaGFyYWN0ZXIgc2V0IGlzIHRoZSB1bmlvbiBvZiBgQml0bWFwRm9udC5BTFBIQWAgYW5kIGBCaXRtYXBGb250Lk5VTUVSSUNgLlxuKiBAdHlwZSB7c3RyaW5nW11bXX1cbiovXG5fQml0bWFwRm9udC5BTFBIQU5VTUVSSUMgPSBbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBbXCIwXCIsIFwiOVwiXSwgXCIgXCJdLCAvKipcbiogVGhpcyBjaGFyYWN0ZXIgc2V0IGNvbnNpc3RzIG9mIGFsbCB0aGUgQVNDSUkgdGFibGUuXG4qIEBtZW1iZXIge3N0cmluZ1tdW119XG4qIEBzZWUgaHR0cDovL3d3dy5hc2NpaXRhYmxlLmNvbS9cbiovXG5fQml0bWFwRm9udC5BU0NJSSA9IFtbXCIgXCIsIFwiflwiXV0sIC8qKlxuKiBDb2xsZWN0aW9uIG9mIGRlZmF1bHQgb3B0aW9ucyB3aGVuIHVzaW5nIGBCaXRtYXBGb250LmZyb21gLlxuKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb249MV0gLVxuKiBAcHJvcGVydHkge251bWJlcn0gW3RleHR1cmVXaWR0aD01MTJdIC1cbiogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0dXJlSGVpZ2h0PTUxMl0gLVxuKiBAcHJvcGVydHkge251bWJlcn0gW3BhZGRpbmc9NF0gLVxuKiBAcHJvcGVydHkge3N0cmluZ3xzdHJpbmdbXXxzdHJpbmdbXVtdfSBjaGFycyA9IFBJWEkuQml0bWFwRm9udC5BTFBIQU5VTUVSSUNcbiovXG5fQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogMSxcbiAgdGV4dHVyZVdpZHRoOiA1MTIsXG4gIHRleHR1cmVIZWlnaHQ6IDUxMixcbiAgcGFkZGluZzogNCxcbiAgY2hhcnM6IF9CaXRtYXBGb250LkFMUEhBTlVNRVJJQ1xufSwgLyoqIENvbGxlY3Rpb24gb2YgYXZhaWxhYmxlL2luc3RhbGxlZCBmb250cy4gKi9cbl9CaXRtYXBGb250LmF2YWlsYWJsZSA9IHt9O1xubGV0IEJpdG1hcEZvbnQgPSBfQml0bWFwRm9udDtcbmV4cG9ydCB7XG4gIEJpdG1hcEZvbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBGb250Lm1qcy5tYXBcbiIsInZhciBtc2RmRnJhZyA9IGAvLyBQaXhpIHRleHR1cmUgaW5mb1xcclxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcblxcclxuLy8gVGludFxcclxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXHJcblxcclxuLy8gb24gMkQgYXBwbGljYXRpb25zIGZ3aWR0aCBpcyBzY3JlZW5TY2FsZSAvIGdseXBoQXRsYXNTY2FsZSAqIGRpc3RhbmNlRmllbGRSYW5nZVxcclxudW5pZm9ybSBmbG9hdCB1RldpZHRoO1xcclxuXFxyXG52b2lkIG1haW4odm9pZCkge1xcclxuXFxyXG4gIC8vIFRvIHN0YWNrIE1TREYgYW5kIFNERiB3ZSBuZWVkIGEgbm9uLXByZS1tdWx0aXBsaWVkLWFscGhhIHRleHR1cmUuXFxyXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxuXFxyXG4gIC8vIE1TREZcXHJcbiAgZmxvYXQgbWVkaWFuID0gdGV4Q29sb3IuciArIHRleENvbG9yLmcgKyB0ZXhDb2xvci5iIC1cXHJcbiAgICAgICAgICAgICAgICAgIG1pbih0ZXhDb2xvci5yLCBtaW4odGV4Q29sb3IuZywgdGV4Q29sb3IuYikpIC1cXHJcbiAgICAgICAgICAgICAgICAgIG1heCh0ZXhDb2xvci5yLCBtYXgodGV4Q29sb3IuZywgdGV4Q29sb3IuYikpO1xcclxuICAvLyBTREZcXHJcbiAgbWVkaWFuID0gbWluKG1lZGlhbiwgdGV4Q29sb3IuYSk7XFxyXG5cXHJcbiAgZmxvYXQgc2NyZWVuUHhEaXN0YW5jZSA9IHVGV2lkdGggKiAobWVkaWFuIC0gMC41KTtcXHJcbiAgZmxvYXQgYWxwaGEgPSBjbGFtcChzY3JlZW5QeERpc3RhbmNlICsgMC41LCAwLjAsIDEuMCk7XFxyXG4gIGlmIChtZWRpYW4gPCAwLjAxKSB7XFxyXG4gICAgYWxwaGEgPSAwLjA7XFxyXG4gIH0gZWxzZSBpZiAobWVkaWFuID4gMC45OSkge1xcclxuICAgIGFscGhhID0gMS4wO1xcclxuICB9XFxyXG5cXHJcbiAgLy8gR2FtbWEgY29ycmVjdGlvbiBmb3IgY292ZXJhZ2UtbGlrZSBhbHBoYVxcclxuICBmbG9hdCBsdW1hID0gZG90KHVDb2xvci5yZ2IsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xcclxuICBmbG9hdCBnYW1tYSA9IG1peCgxLjAsIDEuMCAvIDIuMiwgbHVtYSk7XFxyXG4gIGZsb2F0IGNvdmVyYWdlID0gcG93KHVDb2xvci5hICogYWxwaGEsIGdhbW1hKTsgIFxcclxuXFxyXG4gIC8vIE5QTSBUZXh0dXJlcywgTlBNIG91dHB1dHNcXHJcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCBjb3ZlcmFnZSk7XFxyXG59XFxyXG5gO1xuZXhwb3J0IHtcbiAgbXNkZkZyYWcgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1zZGYuZnJhZy5tanMubWFwXG4iLCJ2YXIgbXNkZlZlcnQgPSBgLy8gTWVzaCBtYXRlcmlhbCBkZWZhdWx0IGZyYWdtZW50XFxyXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxuXFxyXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcbnVuaWZvcm0gbWF0MyB1VGV4dHVyZU1hdHJpeDtcXHJcblxcclxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXG5cXHJcbnZvaWQgbWFpbih2b2lkKVxcclxue1xcclxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXG5cXHJcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUZXh0dXJlTWF0cml4ICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXHJcbn1cXHJcbmA7XG5leHBvcnQge1xuICBtc2RmVmVydCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNkZi52ZXJ0Lm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yLCBPYnNlcnZhYmxlUG9pbnQsIHNldHRpbmdzLCBQb2ludCwgVGV4dHVyZSwgdXRpbHMsIEJMRU5EX01PREVTLCBQcm9ncmFtIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCJAcGl4aS9kaXNwbGF5XCI7XG5pbXBvcnQgeyBNZXNoR2VvbWV0cnksIE1lc2hNYXRlcmlhbCwgTWVzaCB9IGZyb20gXCJAcGl4aS9tZXNoXCI7XG5pbXBvcnQgeyBCaXRtYXBGb250IH0gZnJvbSBcIi4vQml0bWFwRm9udC5tanNcIjtcbmltcG9ydCBtc2RmRnJhZyBmcm9tIFwiLi9zaGFkZXIvbXNkZi5mcmFnLm1qc1wiO1xuaW1wb3J0IG1zZGZWZXJ0IGZyb20gXCIuL3NoYWRlci9tc2RmLnZlcnQubWpzXCI7XG5pbXBvcnQgXCIuL3V0aWxzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgc3BsaXRUZXh0VG9DaGFyYWN0ZXJzIH0gZnJvbSBcIi4vdXRpbHMvc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qc1wiO1xuaW1wb3J0IHsgZXh0cmFjdENoYXJDb2RlIH0gZnJvbSBcIi4vdXRpbHMvZXh0cmFjdENoYXJDb2RlLm1qc1wiO1xuY29uc3QgcGFnZU1lc2hEYXRhRGVmYXVsdFBhZ2VNZXNoRGF0YSA9IFtdLCBwYWdlTWVzaERhdGFNU0RGUGFnZU1lc2hEYXRhID0gW10sIGNoYXJSZW5kZXJEYXRhUG9vbCA9IFtdLCBfQml0bWFwVGV4dCA9IGNsYXNzIF9CaXRtYXBUZXh0MiBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dCAtIEEgc3RyaW5nIHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheS5cbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZS5mb250TmFtZSAtIFRoZSBpbnN0YWxsZWQgQml0bWFwRm9udCBuYW1lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmZvbnRTaXplXSAtIFRoZSBzaXplIG9mIHRoZSBmb250IGluIHBpeGVscywgZS5nLiAyNC4gSWYgdW5kZWZpbmVkLFxuICAgKi4gICAgIHRoaXMgd2lsbCBkZWZhdWx0IHRvIHRoZSBCaXRtYXBGb250IHNpemUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuYWxpZ249J2xlZnQnXSAtIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgb3IgJ2p1c3RpZnknKSxcbiAgICogICAgICBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dC5cbiAgICogQHBhcmFtIHtQSVhJLkNvbG9yU291cmNlfSBbc3R5bGUudGludD0weEZGRkZGRl0gLSBUaGUgdGludCBjb2xvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5sZXR0ZXJTcGFjaW5nPTBdIC0gVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5tYXhXaWR0aD0wXSAtIFRoZSBtYXggd2lkdGggb2YgdGhlIHRleHQgYmVmb3JlIGxpbmUgd3JhcHBpbmcuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7IGFsaWduLCB0aW50LCBtYXhXaWR0aCwgbGV0dGVyU3BhY2luZywgZm9udE5hbWUsIGZvbnRTaXplIH0gPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBfQml0bWFwVGV4dDIuc3R5bGVEZWZhdWx0cyxcbiAgICAgIHN0eWxlXG4gICAgKTtcbiAgICBpZiAoIUJpdG1hcEZvbnQuYXZhaWxhYmxlW2ZvbnROYW1lXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRtYXBGb250IFwiJHtmb250TmFtZX1cImApO1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBbXSwgdGhpcy5fdGV4dFdpZHRoID0gMCwgdGhpcy5fdGV4dEhlaWdodCA9IDAsIHRoaXMuX2FsaWduID0gYWxpZ24sIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBDb2xvcih0aW50KSwgdGhpcy5fZm9udCA9IHZvaWQgMCwgdGhpcy5fZm9udE5hbWUgPSBmb250TmFtZSwgdGhpcy5fZm9udFNpemUgPSBmb250U2l6ZSwgdGhpcy50ZXh0ID0gdGV4dCwgdGhpcy5fbWF4V2lkdGggPSBtYXhXaWR0aCwgdGhpcy5fbWF4TGluZUhlaWdodCA9IDAsIHRoaXMuX2xldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nLCB0aGlzLl9hbmNob3IgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KCgpID0+IHtcbiAgICAgIHRoaXMuZGlydHkgPSAhMDtcbiAgICB9LCB0aGlzLCAwLCAwKSwgdGhpcy5fcm91bmRQaXhlbHMgPSBzZXR0aW5ncy5ST1VORF9QSVhFTFMsIHRoaXMuZGlydHkgPSAhMCwgdGhpcy5fcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFU09MVVRJT04sIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gITAsIHRoaXMuX3RleHR1cmVDYWNoZSA9IHt9O1xuICB9XG4gIC8qKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWQuIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBCaXRtYXBGb250IGlzIHJlZ2VuZXJhdGVkLiAqL1xuICB1cGRhdGVUZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBCaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV0sIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSwgc2NhbGUgPSBmb250U2l6ZSAvIGRhdGEuc2l6ZSwgcG9zID0gbmV3IFBvaW50KCksIGNoYXJzID0gW10sIGxpbmVXaWR0aHMgPSBbXSwgbGluZVNwYWNlcyA9IFtdLCB0ZXh0ID0gdGhpcy5fdGV4dC5yZXBsYWNlKC8oPzpcXHJcXG58XFxyKS9nLCBgXG5gKSB8fCBcIiBcIiwgY2hhcnNJbnB1dCA9IHNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KSwgbWF4V2lkdGggPSB0aGlzLl9tYXhXaWR0aCAqIGRhdGEuc2l6ZSAvIGZvbnRTaXplLCBwYWdlTWVzaERhdGFQb29sID0gZGF0YS5kaXN0YW5jZUZpZWxkVHlwZSA9PT0gXCJub25lXCIgPyBwYWdlTWVzaERhdGFEZWZhdWx0UGFnZU1lc2hEYXRhIDogcGFnZU1lc2hEYXRhTVNERlBhZ2VNZXNoRGF0YTtcbiAgICBsZXQgcHJldkNoYXJDb2RlID0gbnVsbCwgbGFzdExpbmVXaWR0aCA9IDAsIG1heExpbmVXaWR0aCA9IDAsIGxpbmUgPSAwLCBsYXN0QnJlYWtQb3MgPSAtMSwgbGFzdEJyZWFrV2lkdGggPSAwLCBzcGFjZXNSZW1vdmVkID0gMCwgbWF4TGluZUhlaWdodCA9IDAsIHNwYWNlQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnNJbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzSW5wdXRbaV0sIGNoYXJDb2RlID0gZXh0cmFjdENoYXJDb2RlKGNoYXIpO1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGNoYXIpICYmIChsYXN0QnJlYWtQb3MgPSBpLCBsYXN0QnJlYWtXaWR0aCA9IGxhc3RMaW5lV2lkdGgsIHNwYWNlQ291bnQrKyksIGNoYXIgPT09IFwiXFxyXCIgfHwgY2hhciA9PT0gYFxuYCkge1xuICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCksIGxpbmVTcGFjZXMucHVzaCgtMSksIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCksICsrbGluZSwgKytzcGFjZXNSZW1vdmVkLCBwb3MueCA9IDAsIHBvcy55ICs9IGRhdGEubGluZUhlaWdodCwgcHJldkNoYXJDb2RlID0gbnVsbCwgc3BhY2VDb3VudCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2NoYXJDb2RlXTtcbiAgICAgIGlmICghY2hhckRhdGEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcHJldkNoYXJDb2RlICYmIGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSAmJiAocG9zLnggKz0gY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdKTtcbiAgICAgIGNvbnN0IGNoYXJSZW5kZXJEYXRhID0gY2hhclJlbmRlckRhdGFQb29sLnBvcCgpIHx8IHtcbiAgICAgICAgdGV4dHVyZTogVGV4dHVyZS5FTVBUWSxcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY2hhckNvZGU6IDAsXG4gICAgICAgIHByZXZTcGFjZXM6IDAsXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgUG9pbnQoKVxuICAgICAgfTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLnRleHR1cmUgPSBjaGFyRGF0YS50ZXh0dXJlLCBjaGFyUmVuZGVyRGF0YS5saW5lID0gbGluZSwgY2hhclJlbmRlckRhdGEuY2hhckNvZGUgPSBjaGFyQ29kZSwgY2hhclJlbmRlckRhdGEucG9zaXRpb24ueCA9IE1hdGgucm91bmQocG9zLnggKyBjaGFyRGF0YS54T2Zmc2V0ICsgdGhpcy5fbGV0dGVyU3BhY2luZyAvIDIpLCBjaGFyUmVuZGVyRGF0YS5wb3NpdGlvbi55ID0gTWF0aC5yb3VuZChwb3MueSArIGNoYXJEYXRhLnlPZmZzZXQpLCBjaGFyUmVuZGVyRGF0YS5wcmV2U3BhY2VzID0gc3BhY2VDb3VudCwgY2hhcnMucHVzaChjaGFyUmVuZGVyRGF0YSksIGxhc3RMaW5lV2lkdGggPSBjaGFyUmVuZGVyRGF0YS5wb3NpdGlvbi54ICsgTWF0aC5tYXgoY2hhckRhdGEueEFkdmFuY2UgLSBjaGFyRGF0YS54T2Zmc2V0LCBjaGFyRGF0YS50ZXh0dXJlLm9yaWcud2lkdGgpLCBwb3MueCArPSBjaGFyRGF0YS54QWR2YW5jZSArIHRoaXMuX2xldHRlclNwYWNpbmcsIG1heExpbmVIZWlnaHQgPSBNYXRoLm1heChtYXhMaW5lSGVpZ2h0LCBjaGFyRGF0YS55T2Zmc2V0ICsgY2hhckRhdGEudGV4dHVyZS5oZWlnaHQpLCBwcmV2Q2hhckNvZGUgPSBjaGFyQ29kZSwgbGFzdEJyZWFrUG9zICE9PSAtMSAmJiBtYXhXaWR0aCA+IDAgJiYgcG9zLnggPiBtYXhXaWR0aCAmJiAoKytzcGFjZXNSZW1vdmVkLCB1dGlscy5yZW1vdmVJdGVtcyhjaGFycywgMSArIGxhc3RCcmVha1BvcyAtIHNwYWNlc1JlbW92ZWQsIDEgKyBpIC0gbGFzdEJyZWFrUG9zKSwgaSA9IGxhc3RCcmVha1BvcywgbGFzdEJyZWFrUG9zID0gLTEsIGxpbmVXaWR0aHMucHVzaChsYXN0QnJlYWtXaWR0aCksIGxpbmVTcGFjZXMucHVzaChjaGFycy5sZW5ndGggPiAwID8gY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0ucHJldlNwYWNlcyA6IDApLCBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RCcmVha1dpZHRoKSwgbGluZSsrLCBwb3MueCA9IDAsIHBvcy55ICs9IGRhdGEubGluZUhlaWdodCwgcHJldkNoYXJDb2RlID0gbnVsbCwgc3BhY2VDb3VudCA9IDApO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Q2hhciA9IGNoYXJzSW5wdXRbY2hhcnNJbnB1dC5sZW5ndGggLSAxXTtcbiAgICBsYXN0Q2hhciAhPT0gXCJcXHJcIiAmJiBsYXN0Q2hhciAhPT0gYFxuYCAmJiAoLyg/OlxccykvLnRlc3QobGFzdENoYXIpICYmIChsYXN0TGluZVdpZHRoID0gbGFzdEJyZWFrV2lkdGgpLCBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCksIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCksIGxpbmVTcGFjZXMucHVzaCgtMSkpO1xuICAgIGNvbnN0IGxpbmVBbGlnbk9mZnNldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaW5lOyBpKyspIHtcbiAgICAgIGxldCBhbGlnbk9mZnNldCA9IDA7XG4gICAgICB0aGlzLl9hbGlnbiA9PT0gXCJyaWdodFwiID8gYWxpZ25PZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldIDogdGhpcy5fYWxpZ24gPT09IFwiY2VudGVyXCIgPyBhbGlnbk9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDIgOiB0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIgJiYgKGFsaWduT2Zmc2V0ID0gbGluZVNwYWNlc1tpXSA8IDAgPyAwIDogKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gbGluZVNwYWNlc1tpXSksIGxpbmVBbGlnbk9mZnNldHMucHVzaChhbGlnbk9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbkNoYXJzID0gY2hhcnMubGVuZ3RoLCBwYWdlc01lc2hEYXRhID0ge30sIG5ld1BhZ2VzTWVzaERhdGEgPSBbXSwgYWN0aXZlUGFnZXNNZXNoRGF0YSA9IHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGE7XG4gICAgcGFnZU1lc2hEYXRhUG9vbC5wdXNoKC4uLmFjdGl2ZVBhZ2VzTWVzaERhdGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuQ2hhcnM7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNoYXJzW2ldLnRleHR1cmUsIGJhc2VUZXh0dXJlVWlkID0gdGV4dHVyZS5iYXNlVGV4dHVyZS51aWQ7XG4gICAgICBpZiAoIXBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdKSB7XG4gICAgICAgIGxldCBwYWdlTWVzaERhdGEgPSBwYWdlTWVzaERhdGFQb29sLnBvcCgpO1xuICAgICAgICBpZiAoIXBhZ2VNZXNoRGF0YSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IE1lc2hHZW9tZXRyeSgpO1xuICAgICAgICAgIGxldCBtYXRlcmlhbCwgbWVzaEJsZW5kTW9kZTtcbiAgICAgICAgICBkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIiA/IChtYXRlcmlhbCA9IG5ldyBNZXNoTWF0ZXJpYWwoVGV4dHVyZS5FTVBUWSksIG1lc2hCbGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUwpIDogKG1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbChcbiAgICAgICAgICAgIFRleHR1cmUuRU1QVFksXG4gICAgICAgICAgICB7IHByb2dyYW06IFByb2dyYW0uZnJvbShtc2RmVmVydCwgbXNkZkZyYWcpLCB1bmlmb3JtczogeyB1RldpZHRoOiAwIH0gfVxuICAgICAgICAgICksIG1lc2hCbGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUxfTlBNKTtcbiAgICAgICAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICBtZXNoLmJsZW5kTW9kZSA9IG1lc2hCbGVuZE1vZGUsIHBhZ2VNZXNoRGF0YSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgaW5kZXhDb3VudDogMCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgICAgdXZzQ291bnQ6IDAsXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgIG1lc2gsXG4gICAgICAgICAgICB2ZXJ0aWNlczogbnVsbCxcbiAgICAgICAgICAgIHV2czogbnVsbCxcbiAgICAgICAgICAgIGluZGljZXM6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRleCA9IDAsIHBhZ2VNZXNoRGF0YS5pbmRleENvdW50ID0gMCwgcGFnZU1lc2hEYXRhLnZlcnRleENvdW50ID0gMCwgcGFnZU1lc2hEYXRhLnV2c0NvdW50ID0gMCwgcGFnZU1lc2hEYXRhLnRvdGFsID0gMDtcbiAgICAgICAgY29uc3QgeyBfdGV4dHVyZUNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBfdGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlVWlkXSA9IF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdIHx8IG5ldyBUZXh0dXJlKHRleHR1cmUuYmFzZVRleHR1cmUpLCBwYWdlTWVzaERhdGEubWVzaC50ZXh0dXJlID0gX3RleHR1cmVDYWNoZVtiYXNlVGV4dHVyZVVpZF0sIHBhZ2VNZXNoRGF0YS5tZXNoLnRpbnQgPSB0aGlzLl90aW50Q29sb3IudmFsdWUsIG5ld1BhZ2VzTWVzaERhdGEucHVzaChwYWdlTWVzaERhdGEpLCBwYWdlc01lc2hEYXRhW2Jhc2VUZXh0dXJlVWlkXSA9IHBhZ2VNZXNoRGF0YTtcbiAgICAgIH1cbiAgICAgIHBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdLnRvdGFsKys7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlUGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKylcbiAgICAgIG5ld1BhZ2VzTWVzaERhdGEuaW5jbHVkZXMoYWN0aXZlUGFnZXNNZXNoRGF0YVtpXSkgfHwgdGhpcy5yZW1vdmVDaGlsZChhY3RpdmVQYWdlc01lc2hEYXRhW2ldLm1lc2gpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3UGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKylcbiAgICAgIG5ld1BhZ2VzTWVzaERhdGFbaV0ubWVzaC5wYXJlbnQgIT09IHRoaXMgJiYgdGhpcy5hZGRDaGlsZChuZXdQYWdlc01lc2hEYXRhW2ldLm1lc2gpO1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBuZXdQYWdlc01lc2hEYXRhO1xuICAgIGZvciAoY29uc3QgaSBpbiBwYWdlc01lc2hEYXRhKSB7XG4gICAgICBjb25zdCBwYWdlTWVzaERhdGEgPSBwYWdlc01lc2hEYXRhW2ldLCB0b3RhbCA9IHBhZ2VNZXNoRGF0YS50b3RhbDtcbiAgICAgIGlmICghKHBhZ2VNZXNoRGF0YS5pbmRpY2VzPy5sZW5ndGggPiA2ICogdG90YWwpIHx8IHBhZ2VNZXNoRGF0YS52ZXJ0aWNlcy5sZW5ndGggPCBNZXNoLkJBVENIQUJMRV9TSVpFICogMilcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg0ICogMiAqIHRvdGFsKSwgcGFnZU1lc2hEYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDIgKiB0b3RhbCksIHBhZ2VNZXNoRGF0YS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KDYgKiB0b3RhbCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdG90YWwyID0gcGFnZU1lc2hEYXRhLnRvdGFsLCB2ZXJ0aWNlcyA9IHBhZ2VNZXNoRGF0YS52ZXJ0aWNlcztcbiAgICAgICAgZm9yIChsZXQgaTIgPSB0b3RhbDIgKiA0ICogMjsgaTIgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgdmVydGljZXNbaTJdID0gMDtcbiAgICAgIH1cbiAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnNpemUgPSA2ICogdG90YWw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuQ2hhcnM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgbGV0IG9mZnNldCA9IGNoYXIucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhci5saW5lXSAqICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIgPyBjaGFyLnByZXZTcGFjZXMgOiAxKTtcbiAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzICYmIChvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCkpO1xuICAgICAgY29uc3QgeFBvcyA9IG9mZnNldCAqIHNjYWxlLCB5UG9zID0gY2hhci5wb3NpdGlvbi55ICogc2NhbGUsIHRleHR1cmUgPSBjaGFyLnRleHR1cmUsIHBhZ2VNZXNoID0gcGFnZXNNZXNoRGF0YVt0ZXh0dXJlLmJhc2VUZXh0dXJlLnVpZF0sIHRleHR1cmVGcmFtZSA9IHRleHR1cmUuZnJhbWUsIHRleHR1cmVVdnMgPSB0ZXh0dXJlLl91dnMsIGluZGV4ID0gcGFnZU1lc2guaW5kZXgrKztcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgMF0gPSAwICsgaW5kZXggKiA0LCBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDFdID0gMSArIGluZGV4ICogNCwgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAyXSA9IDIgKyBpbmRleCAqIDQsIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgM10gPSAwICsgaW5kZXggKiA0LCBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDRdID0gMiArIGluZGV4ICogNCwgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyA1XSA9IDMgKyBpbmRleCAqIDQsIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDBdID0geFBvcywgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMV0gPSB5UG9zLCBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyAyXSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZSwgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgM10gPSB5UG9zLCBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA0XSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZSwgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgNV0gPSB5UG9zICsgdGV4dHVyZUZyYW1lLmhlaWdodCAqIHNjYWxlLCBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA2XSA9IHhQb3MsIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDddID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZSwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDBdID0gdGV4dHVyZVV2cy54MCwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDFdID0gdGV4dHVyZVV2cy55MCwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDJdID0gdGV4dHVyZVV2cy54MSwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDNdID0gdGV4dHVyZVV2cy55MSwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDRdID0gdGV4dHVyZVV2cy54MiwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDVdID0gdGV4dHVyZVV2cy55MiwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDZdID0gdGV4dHVyZVV2cy54MywgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDddID0gdGV4dHVyZVV2cy55MztcbiAgICB9XG4gICAgdGhpcy5fdGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGUsIHRoaXMuX3RleHRIZWlnaHQgPSAocG9zLnkgKyBkYXRhLmxpbmVIZWlnaHQpICogc2NhbGU7XG4gICAgZm9yIChjb25zdCBpIGluIHBhZ2VzTWVzaERhdGEpIHtcbiAgICAgIGNvbnN0IHBhZ2VNZXNoRGF0YSA9IHBhZ2VzTWVzaERhdGFbaV07XG4gICAgICBpZiAodGhpcy5hbmNob3IueCAhPT0gMCB8fCB0aGlzLmFuY2hvci55ICE9PSAwKSB7XG4gICAgICAgIGxldCB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFggPSB0aGlzLl90ZXh0V2lkdGggKiB0aGlzLmFuY2hvci54LCBhbmNob3JPZmZzZXRZID0gdGhpcy5fdGV4dEhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwYWdlTWVzaERhdGEudG90YWw7IGkyKyspXG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFgsIHBhZ2VNZXNoRGF0YS52ZXJ0aWNlc1t2ZXJ0ZXhDb3VudCsrXSAtPSBhbmNob3JPZmZzZXRZLCBwYWdlTWVzaERhdGEudmVydGljZXNbdmVydGV4Q291bnQrK10gLT0gYW5jaG9yT2Zmc2V0WCwgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFksIHBhZ2VNZXNoRGF0YS52ZXJ0aWNlc1t2ZXJ0ZXhDb3VudCsrXSAtPSBhbmNob3JPZmZzZXRYLCBwYWdlTWVzaERhdGEudmVydGljZXNbdmVydGV4Q291bnQrK10gLT0gYW5jaG9yT2Zmc2V0WSwgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFgsIHBhZ2VNZXNoRGF0YS52ZXJ0aWNlc1t2ZXJ0ZXhDb3VudCsrXSAtPSBhbmNob3JPZmZzZXRZO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWF4TGluZUhlaWdodCA9IG1heExpbmVIZWlnaHQgKiBzY2FsZTtcbiAgICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IHBhZ2VNZXNoRGF0YS5tZXNoLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKSwgdGV4dHVyZUJ1ZmZlciA9IHBhZ2VNZXNoRGF0YS5tZXNoLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFUZXh0dXJlQ29vcmRcIiksIGluZGV4QnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzLCB0ZXh0dXJlQnVmZmVyLmRhdGEgPSBwYWdlTWVzaERhdGEudXZzLCBpbmRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLmluZGljZXMsIHZlcnRleEJ1ZmZlci51cGRhdGUoKSwgdGV4dHVyZUJ1ZmZlci51cGRhdGUoKSwgaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICBjaGFyUmVuZGVyRGF0YVBvb2wucHVzaChjaGFyc1tpXSk7XG4gICAgdGhpcy5fZm9udCA9IGRhdGEsIHRoaXMuZGlydHkgPSAhMTtcbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpLCB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uICYmICh0aGlzLl9yZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgICBjb25zdCB7IGRpc3RhbmNlRmllbGRSYW5nZSwgZGlzdGFuY2VGaWVsZFR5cGUsIHNpemUgfSA9IEJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXTtcbiAgICBpZiAoZGlzdGFuY2VGaWVsZFR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IHRoaXMud29ybGRUcmFuc2Zvcm0sIGR4ID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpLCBkeSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSwgd29ybGRTY2FsZSA9IChNYXRoLmFicyhkeCkgKyBNYXRoLmFicyhkeSkpIC8gMiwgZm9udFNjYWxlID0gdGhpcy5mb250U2l6ZSAvIHNpemUsIHJlc29sdXRpb24gPSByZW5kZXJlci5fdmlldy5yZXNvbHV0aW9uO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpXG4gICAgICAgIG1lc2gubWVzaC5zaGFkZXIudW5pZm9ybXMudUZXaWR0aCA9IHdvcmxkU2NhbGUgKiBkaXN0YW5jZUZpZWxkUmFuZ2UgKiBmb250U2NhbGUgKiByZXNvbHV0aW9uO1xuICAgIH1cbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRleHQgYmVmb3JlIGNhbGxpbmcgcGFyZW50J3MgZ2V0TG9jYWxCb3VuZHNcbiAgICogQHJldHVybnMgLSBUaGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoKSwgc3VwZXIuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0ZXh0IHdoZW4gbmVlZGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCBmb250ID0gQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGlmICghZm9udClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRtYXBGb250IFwiJHt0aGlzLl9mb250TmFtZX1cImApO1xuICAgIHRoaXMuX2ZvbnQgIT09IGZvbnQgJiYgKHRoaXMuZGlydHkgPSAhMCksIHRoaXMuZGlydHkgJiYgdGhpcy51cGRhdGVUZXh0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdC5cbiAgICogQGRlZmF1bHQgMHhmZmZmZmZcbiAgICovXG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICBpZiAodGhpcy50aW50ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YVtpXS5tZXNoLnRpbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0LlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdsZWZ0J1xuICAgKi9cbiAgZ2V0IGFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgfVxuICBzZXQgYWxpZ24odmFsdWUpIHtcbiAgICB0aGlzLl9hbGlnbiAhPT0gdmFsdWUgJiYgKHRoaXMuX2FsaWduID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBCaXRtYXBGb250LiAqL1xuICBnZXQgZm9udE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnROYW1lO1xuICB9XG4gIHNldCBmb250TmFtZSh2YWx1ZSkge1xuICAgIGlmICghQml0bWFwRm9udC5hdmFpbGFibGVbdmFsdWVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIEJpdG1hcEZvbnQgXCIke3ZhbHVlfVwiYCk7XG4gICAgdGhpcy5fZm9udE5hbWUgIT09IHZhbHVlICYmICh0aGlzLl9mb250TmFtZSA9IHZhbHVlLCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCB0byBkaXNwbGF5LiAqL1xuICBnZXQgZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplID8/IEJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXS5zaXplO1xuICB9XG4gIHNldCBmb250U2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvbnRTaXplICE9PSB2YWx1ZSAmJiAodGhpcy5fZm9udFNpemUgPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHRleHQuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGlzIGAoMCwwKWAsIHRoaXMgbWVhbnMgdGhlIHRleHQncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0LlxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgwLjUsMC41KWAgbWVhbnMgdGhlIHRleHQncyBvcmlnaW4gaXMgY2VudGVyZWQuXG4gICAqXG4gICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byBgKDEsMSlgIHdvdWxkIG1lYW4gdGhlIHRleHQncyBvcmlnaW4gcG9pbnQgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cbiAgICovXG4gIGdldCBhbmNob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuICBzZXQgYW5jaG9yKHZhbHVlKSB7XG4gICAgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB0aGlzLl9hbmNob3Iuc2V0KHZhbHVlKSA6IHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgLyoqIFRoZSB0ZXh0IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdC4gKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA/PyBcIlwiKSwgdGhpcy5fdGV4dCAhPT0gdGV4dCAmJiAodGhpcy5fdGV4dCA9IHRleHQsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXggd2lkdGggb2YgdGhpcyBiaXRtYXAgdGV4dCBpbiBwaXhlbHMuIElmIHRoZSB0ZXh0IHByb3ZpZGVkIGlzIGxvbmdlciB0aGFuIHRoZVxuICAgKiB2YWx1ZSBwcm92aWRlZCwgbGluZSBicmVha3Mgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGluIHRoZSBsYXN0IHdoaXRlc3BhY2UuXG4gICAqIERpc2FibGUgYnkgc2V0dGluZyB0aGUgdmFsdWUgdG8gMC5cbiAgICovXG4gIGdldCBtYXhXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4V2lkdGg7XG4gIH1cbiAgc2V0IG1heFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fbWF4V2lkdGggIT09IHZhbHVlICYmICh0aGlzLl9tYXhXaWR0aCA9IHZhbHVlLCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4IGxpbmUgaGVpZ2h0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRyeWluZyB0byB1c2UgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgVGV4dCxcbiAgICogaS5lLiB3aGVuIHRyeWluZyB0byB2ZXJ0aWNhbGx5IGFsaWduLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtYXhMaW5lSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCksIHRoaXMuX21heExpbmVIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgb3ZlcmFsbCB0ZXh0LCBkaWZmZXJlbnQgZnJvbSBmb250U2l6ZSxcbiAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0ZXh0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoKSwgdGhpcy5fdGV4dFdpZHRoO1xuICB9XG4gIC8qKiBBZGRpdGlvbmFsIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVycy4gKi9cbiAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gIH1cbiAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSB2YWx1ZSAmJiAodGhpcy5fbGV0dGVyU3BhY2luZyA9IHZhbHVlLCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgKiBBZHZhbnRhZ2VzIGNhbiBpbmNsdWRlIHNoYXJwZXIgaW1hZ2UgcXVhbGl0eSAobGlrZSB0ZXh0KSBhbmQgZmFzdGVyIHJlbmRlcmluZyBvbiBjYW52YXMuXG4gICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAqIFRvIHNldCB0aGUgZ2xvYmFsIGRlZmF1bHQsIGNoYW5nZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5ST1VORF9QSVhFTFN9XG4gICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuUk9VTkRfUElYRUxTXG4gICAqL1xuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIHZhbHVlICE9PSB0aGlzLl9yb3VuZFBpeGVscyAmJiAodGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgb3ZlcmFsbCB0ZXh0LCBkaWZmZXJlbnQgZnJvbSBmb250U2l6ZSxcbiAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0ZXh0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCksIHRoaXMuX3RleHRIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSAhMSwgdGhpcy5fcmVzb2x1dGlvbiAhPT0gdmFsdWUgJiYgKHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IF90ZXh0dXJlQ2FjaGUgfSA9IHRoaXMsIHBhZ2VNZXNoRGF0YVBvb2wgPSBCaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV0uZGlzdGFuY2VGaWVsZFR5cGUgPT09IFwibm9uZVwiID8gcGFnZU1lc2hEYXRhRGVmYXVsdFBhZ2VNZXNoRGF0YSA6IHBhZ2VNZXNoRGF0YU1TREZQYWdlTWVzaERhdGE7XG4gICAgcGFnZU1lc2hEYXRhUG9vbC5wdXNoKC4uLnRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpO1xuICAgIGZvciAoY29uc3QgcGFnZU1lc2hEYXRhIG9mIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHBhZ2VNZXNoRGF0YS5tZXNoKTtcbiAgICB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhID0gW10sIHBhZ2VNZXNoRGF0YVBvb2wuZmlsdGVyKChwYWdlKSA9PiBfdGV4dHVyZUNhY2hlW3BhZ2UubWVzaC50ZXh0dXJlLmJhc2VUZXh0dXJlLnVpZF0pLmZvckVhY2goKHBhZ2UpID0+IHtcbiAgICAgIHBhZ2UubWVzaC50ZXh0dXJlID0gVGV4dHVyZS5FTVBUWTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIF90ZXh0dXJlQ2FjaGUpXG4gICAgICBfdGV4dHVyZUNhY2hlW2lkXS5kZXN0cm95KCksIGRlbGV0ZSBfdGV4dHVyZUNhY2hlW2lkXTtcbiAgICB0aGlzLl9mb250ID0gbnVsbCwgdGhpcy5fdGludENvbG9yID0gbnVsbCwgdGhpcy5fdGV4dHVyZUNhY2hlID0gbnVsbCwgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbl9CaXRtYXBUZXh0LnN0eWxlRGVmYXVsdHMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgdGludDogMTY3NzcyMTUsXG4gIG1heFdpZHRoOiAwLFxuICBsZXR0ZXJTcGFjaW5nOiAwXG59O1xubGV0IEJpdG1hcFRleHQgPSBfQml0bWFwVGV4dDtcbmV4cG9ydCB7XG4gIEJpdG1hcFRleHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBUZXh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5LCBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSBcIkBwaXhpL2Fzc2V0c1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgdXRpbHMsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IEJpdG1hcEZvbnQgfSBmcm9tIFwiLi9CaXRtYXBGb250Lm1qc1wiO1xuaW1wb3J0IFwiLi9mb3JtYXRzL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgVGV4dEZvcm1hdCB9IGZyb20gXCIuL2Zvcm1hdHMvVGV4dEZvcm1hdC5tanNcIjtcbmltcG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9IGZyb20gXCIuL2Zvcm1hdHMvWE1MU3RyaW5nRm9ybWF0Lm1qc1wiO1xuY29uc3QgdmFsaWRFeHRlbnNpb25zID0gW1wiLnhtbFwiLCBcIi5mbnRcIl0sIGxvYWRCaXRtYXBGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICB9LFxuICBuYW1lOiBcImxvYWRCaXRtYXBGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIHZhbGlkRXh0ZW5zaW9ucy5pbmNsdWRlcyh1dGlscy5wYXRoLmV4dG5hbWUodXJsKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgYXN5bmMgdGVzdFBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gVGV4dEZvcm1hdC50ZXN0KGRhdGEpIHx8IFhNTFN0cmluZ0Zvcm1hdC50ZXN0KGRhdGEpO1xuICB9LFxuICBhc3luYyBwYXJzZShhc3NldCwgZGF0YSwgbG9hZGVyKSB7XG4gICAgY29uc3QgZm9udERhdGEgPSBUZXh0Rm9ybWF0LnRlc3QoYXNzZXQpID8gVGV4dEZvcm1hdC5wYXJzZShhc3NldCkgOiBYTUxTdHJpbmdGb3JtYXQucGFyc2UoYXNzZXQpLCB7IHNyYyB9ID0gZGF0YSwgeyBwYWdlOiBwYWdlcyB9ID0gZm9udERhdGEsIHRleHR1cmVVcmxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcGFnZUZpbGUgPSBwYWdlc1tpXS5maWxlO1xuICAgICAgbGV0IGltYWdlUGF0aCA9IHV0aWxzLnBhdGguam9pbih1dGlscy5wYXRoLmRpcm5hbWUoc3JjKSwgcGFnZUZpbGUpO1xuICAgICAgaW1hZ2VQYXRoID0gY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIHNyYyksIHRleHR1cmVVcmxzLnB1c2goaW1hZ2VQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkVGV4dHVyZXMgPSBhd2FpdCBsb2FkZXIubG9hZCh0ZXh0dXJlVXJscyksIHRleHR1cmVzID0gdGV4dHVyZVVybHMubWFwKCh1cmwpID0+IGxvYWRlZFRleHR1cmVzW3VybF0pO1xuICAgIHJldHVybiBCaXRtYXBGb250Lmluc3RhbGwoZm9udERhdGEsIHRleHR1cmVzLCAhMCk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIHJldHVybiAoYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpKS50ZXh0KCk7XG4gIH0sXG4gIHVubG9hZChiaXRtYXBGb250KSB7XG4gICAgYml0bWFwRm9udC5kZXN0cm95KCk7XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChsb2FkQml0bWFwRm9udCk7XG5leHBvcnQge1xuICBsb2FkQml0bWFwRm9udFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRCaXRtYXBGb250Lm1qcy5tYXBcbiIsImltcG9ydCB7IEJpdG1hcEZvbnQgfSBmcm9tIFwiLi9CaXRtYXBGb250Lm1qc1wiO1xuaW1wb3J0IHsgQml0bWFwRm9udERhdGEgfSBmcm9tIFwiLi9CaXRtYXBGb250RGF0YS5tanNcIjtcbmltcG9ydCB7IEJpdG1hcFRleHQgfSBmcm9tIFwiLi9CaXRtYXBUZXh0Lm1qc1wiO1xuaW1wb3J0IFwiLi9CaXRtYXBUZXh0U3R5bGUubWpzXCI7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0Rm9ybWF0IH0gZnJvbSBcIi4vZm9ybWF0cy9pbmRleC5tanNcIjtcbmltcG9ydCB7IGxvYWRCaXRtYXBGb250IH0gZnJvbSBcIi4vbG9hZEJpdG1hcEZvbnQubWpzXCI7XG5pbXBvcnQgeyBUZXh0Rm9ybWF0IH0gZnJvbSBcIi4vZm9ybWF0cy9UZXh0Rm9ybWF0Lm1qc1wiO1xuaW1wb3J0IHsgWE1MRm9ybWF0IH0gZnJvbSBcIi4vZm9ybWF0cy9YTUxGb3JtYXQubWpzXCI7XG5pbXBvcnQgeyBYTUxTdHJpbmdGb3JtYXQgfSBmcm9tIFwiLi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5tanNcIjtcbmV4cG9ydCB7XG4gIEJpdG1hcEZvbnQsXG4gIEJpdG1hcEZvbnREYXRhLFxuICBCaXRtYXBUZXh0LFxuICBUZXh0Rm9ybWF0LFxuICBYTUxGb3JtYXQsXG4gIFhNTFN0cmluZ0Zvcm1hdCxcbiAgYXV0b0RldGVjdEZvcm1hdCxcbiAgbG9hZEJpdG1hcEZvbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncywgdXRpbHMgfSBmcm9tIFwiQHBpeGkvY29yZVwiO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSBcIkBwaXhpL3RleHRcIjtcbmNvbnN0IF9IVE1MVGV4dFN0eWxlID0gY2xhc3MgX0hUTUxUZXh0U3R5bGUyIGV4dGVuZHMgVGV4dFN0eWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fZm9udHMgPSBbXSwgdGhpcy5fb3ZlcnJpZGVzID0gW10sIHRoaXMuX3N0eWxlc2hlZXQgPSBcIlwiLCB0aGlzLmZvbnRzRGlydHkgPSAhMTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBhIFRleHRTdHlsZSB0byBIVE1MVGV4dFN0eWxlXG4gICAqIEBwYXJhbSBvcmlnaW5hbFN0eWxlXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7VGV4dFN0eWxlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIGltcG9ydCB7SFRNTFRleHRTdHlsZX0gZnJvbSAnQHBpeGkvdGV4dC1odG1sJztcbiAgICogY29uc3Qgc3R5bGUgPSBuZXcgVGV4dFN0eWxlKCk7XG4gICAqIGNvbnN0IGh0bWxTdHlsZSA9IEhUTUxUZXh0U3R5bGUuZnJvbShzdHlsZSk7XG4gICAqL1xuICBzdGF0aWMgZnJvbShvcmlnaW5hbFN0eWxlKSB7XG4gICAgcmV0dXJuIG5ldyBfSFRNTFRleHRTdHlsZTIoXG4gICAgICBPYmplY3Qua2V5cyhfSFRNTFRleHRTdHlsZTIuZGVmYXVsdE9wdGlvbnMpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiAoeyAuLi5vYmosIFtwcm9wXTogb3JpZ2luYWxTdHlsZVtwcm9wXSB9KSwge30pXG4gICAgKTtcbiAgfVxuICAvKiogQ2xlYXIgdGhlIGN1cnJlbnQgZm9udCAqL1xuICBjbGVhbkZvbnRzKCkge1xuICAgIHRoaXMuX2ZvbnRzLmxlbmd0aCA+IDAgJiYgKHRoaXMuX2ZvbnRzLmZvckVhY2goKGZvbnQpID0+IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZm9udC5zcmMpLCBmb250LnJlZnMtLSwgZm9udC5yZWZzID09PSAwICYmIChmb250LmZvbnRGYWNlICYmIGRvY3VtZW50LmZvbnRzLmRlbGV0ZShmb250LmZvbnRGYWNlKSwgZGVsZXRlIF9IVE1MVGV4dFN0eWxlMi5hdmFpbGFibGVGb250c1tmb250Lm9yaWdpbmFsVXJsXSk7XG4gICAgfSksIHRoaXMuZm9udEZhbWlseSA9IFwiQXJpYWxcIiwgdGhpcy5fZm9udHMubGVuZ3RoID0gMCwgdGhpcy5zdHlsZUlEKyssIHRoaXMuZm9udHNEaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogQmVjYXVzZSBvZiBob3cgSFRNTFRleHQgcmVuZGVycywgZm9udHMgbmVlZCB0byBiZSBpbXBvcnRlZFxuICAgKiBAcGFyYW0gdXJsXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBsb2FkRm9udCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXZhaWxhYmxlRm9udHMgfSA9IF9IVE1MVGV4dFN0eWxlMjtcbiAgICBpZiAoYXZhaWxhYmxlRm9udHNbdXJsXSkge1xuICAgICAgY29uc3QgZm9udCA9IGF2YWlsYWJsZUZvbnRzW3VybF07XG4gICAgICByZXR1cm4gdGhpcy5fZm9udHMucHVzaChmb250KSwgZm9udC5yZWZzKyssIHRoaXMuc3R5bGVJRCsrLCB0aGlzLmZvbnRzRGlydHkgPSAhMCwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmJsb2IoKSkudGhlbihhc3luYyAoYmxvYikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSwgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKFtzcmMsIHJlYWRlci5yZXN1bHRdKSwgcmVhZGVyLm9uZXJyb3IgPSByZWplY3QsIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pKS50aGVuKGFzeW5jIChbc3JjLCBkYXRhU3JjXSkgPT4ge1xuICAgICAgY29uc3QgZm9udCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBmYW1pbHk6IHV0aWxzLnBhdGguYmFzZW5hbWUodXJsLCB1dGlscy5wYXRoLmV4dG5hbWUodXJsKSksXG4gICAgICAgIHdlaWdodDogXCJub3JtYWxcIixcbiAgICAgICAgc3R5bGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYXV0b1wiLFxuICAgICAgICBzcmMsXG4gICAgICAgIGRhdGFTcmMsXG4gICAgICAgIHJlZnM6IDEsXG4gICAgICAgIG9yaWdpbmFsVXJsOiB1cmwsXG4gICAgICAgIGZvbnRGYWNlOiBudWxsXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIGF2YWlsYWJsZUZvbnRzW3VybF0gPSBmb250LCB0aGlzLl9mb250cy5wdXNoKGZvbnQpLCB0aGlzLnN0eWxlSUQrKztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGZvbnQuZmFtaWx5LCBgdXJsKCR7Zm9udC5zcmN9KWAsIHtcbiAgICAgICAgd2VpZ2h0OiBmb250LndlaWdodCxcbiAgICAgICAgc3R5bGU6IGZvbnQuc3R5bGUsXG4gICAgICAgIGRpc3BsYXk6IGZvbnQuZGlzcGxheVxuICAgICAgfSk7XG4gICAgICBmb250LmZvbnRGYWNlID0gZm9udEZhY2UsIGF3YWl0IGZvbnRGYWNlLmxvYWQoKSwgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnRGYWNlKSwgYXdhaXQgZG9jdW1lbnQuZm9udHMucmVhZHksIHRoaXMuc3R5bGVJRCsrLCB0aGlzLmZvbnRzRGlydHkgPSAhMDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgc3R5bGUgb3ZlcnJpZGUsIHRoaXMgY2FuIGJlIGFueSBDU1MgcHJvcGVydHlcbiAgICogaXQgd2lsbCBvdmVycmlkZSBhbnkgYnVpbHQtaW4gc3R5bGUuIFRoaXMgaXMgdGhlXG4gICAqIHByb3BlcnR5IGFuZCB0aGUgdmFsdWUgYXMgYSBzdHJpbmcgKGUuZy4sIGBjb2xvcjogcmVkYCkuXG4gICAqIFRoaXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgaW50ZXJuYWwgc3R5bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIENTUyBzdHlsZShzKSB0byBhZGQuXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLmFkZE92ZXJyaWRlKCdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnKTtcbiAgICovXG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLl9vdmVycmlkZXMuaW5jbHVkZXModikpO1xuICAgIHRvQWRkLmxlbmd0aCA+IDAgJiYgKHRoaXMuX292ZXJyaWRlcy5wdXNoKC4uLnRvQWRkKSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IG92ZXJyaWRlcyB0aGF0IG1hdGNoIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gQ1NTIHN0eWxlIHRvIHJlbW92ZS5cbiAgICogQGV4YW1wbGVcbiAgICogc3R5bGUucmVtb3ZlT3ZlcnJpZGUoJ2JhY2tncm91bmQtY29sb3I6IHJlZCcpO1xuICAgKi9cbiAgcmVtb3ZlT3ZlcnJpZGUoLi4udmFsdWUpIHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IHZhbHVlLmZpbHRlcigodikgPT4gdGhpcy5fb3ZlcnJpZGVzLmluY2x1ZGVzKHYpKTtcbiAgICB0b1JlbW92ZS5sZW5ndGggPiAwICYmICh0aGlzLl9vdmVycmlkZXMgPSB0aGlzLl9vdmVycmlkZXMuZmlsdGVyKCh2KSA9PiAhdG9SZW1vdmUuaW5jbHVkZXModikpLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsbHkgY29udmVydHMgYWxsIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGludG8gQ1NTIGVxdWl2YWxlbnRzLlxuICAgKiBAcGFyYW0gc2NhbGVcbiAgICogQHJldHVybnMgVGhlIENTUyBzdHlsZSBzdHJpbmcsIGZvciBzZXR0aW5nIGBzdHlsZWAgcHJvcGVydHkgb2Ygcm9vdCBIVE1MRWxlbWVudC5cbiAgICovXG4gIHRvQ1NTKHNjYWxlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGB0cmFuc2Zvcm06IHNjYWxlKCR7c2NhbGV9KWAsXG4gICAgICBcInRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0XCIsXG4gICAgICBcImRpc3BsYXk6IGlubGluZS1ibG9ja1wiLFxuICAgICAgYGNvbG9yOiAke3RoaXMubm9ybWFsaXplQ29sb3IodGhpcy5maWxsKX1gLFxuICAgICAgYGZvbnQtc2l6ZTogJHt0aGlzLmZvbnRTaXplfXB4YCxcbiAgICAgIGBmb250LWZhbWlseTogJHt0aGlzLmZvbnRGYW1pbHl9YCxcbiAgICAgIGBmb250LXdlaWdodDogJHt0aGlzLmZvbnRXZWlnaHR9YCxcbiAgICAgIGBmb250LXN0eWxlOiAke3RoaXMuZm9udFN0eWxlfWAsXG4gICAgICBgZm9udC12YXJpYW50OiAke3RoaXMuZm9udFZhcmlhbnR9YCxcbiAgICAgIGBsZXR0ZXItc3BhY2luZzogJHt0aGlzLmxldHRlclNwYWNpbmd9cHhgLFxuICAgICAgYHRleHQtYWxpZ246ICR7dGhpcy5hbGlnbn1gLFxuICAgICAgYHBhZGRpbmc6ICR7dGhpcy5wYWRkaW5nfXB4YCxcbiAgICAgIGB3aGl0ZS1zcGFjZTogJHt0aGlzLndoaXRlU3BhY2V9YCxcbiAgICAgIC4uLnRoaXMubGluZUhlaWdodCA/IFtgbGluZS1oZWlnaHQ6ICR7dGhpcy5saW5lSGVpZ2h0fXB4YF0gOiBbXSxcbiAgICAgIC4uLnRoaXMud29yZFdyYXAgPyBbXG4gICAgICAgIGB3b3JkLXdyYXA6ICR7dGhpcy5icmVha1dvcmRzID8gXCJicmVhay1hbGxcIiA6IFwiYnJlYWstd29yZFwifWAsXG4gICAgICAgIGBtYXgtd2lkdGg6ICR7dGhpcy53b3JkV3JhcFdpZHRofXB4YFxuICAgICAgXSA6IFtdLFxuICAgICAgLi4udGhpcy5zdHJva2VUaGlja25lc3MgPyBbXG4gICAgICAgIGAtd2Via2l0LXRleHQtc3Ryb2tlLXdpZHRoOiAke3RoaXMuc3Ryb2tlVGhpY2tuZXNzfXB4YCxcbiAgICAgICAgYC13ZWJraXQtdGV4dC1zdHJva2UtY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLnN0cm9rZSl9YCxcbiAgICAgICAgYHRleHQtc3Ryb2tlLXdpZHRoOiAke3RoaXMuc3Ryb2tlVGhpY2tuZXNzfXB4YCxcbiAgICAgICAgYHRleHQtc3Ryb2tlLWNvbG9yOiAke3RoaXMubm9ybWFsaXplQ29sb3IodGhpcy5zdHJva2UpfWAsXG4gICAgICAgIFwicGFpbnQtb3JkZXI6IHN0cm9rZVwiXG4gICAgICBdIDogW10sXG4gICAgICAuLi50aGlzLmRyb3BTaGFkb3cgPyBbdGhpcy5kcm9wU2hhZG93VG9DU1MoKV0gOiBbXSxcbiAgICAgIC4uLnRoaXMuX292ZXJyaWRlc1xuICAgIF0uam9pbihcIjtcIik7XG4gIH1cbiAgLyoqIEdldCB0aGUgZm9udCBDU1Mgc3R5bGVzIGZyb20gdGhlIGxvYWRlZCBmb250LCBJZiBhdmFpbGFibGUuICovXG4gIHRvR2xvYmFsQ1NTKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250cy5yZWR1Y2UoKHJlc3VsdCwgZm9udCkgPT4gYCR7cmVzdWx0fVxuICAgICAgICAgICAgQGZvbnQtZmFjZSB7XG4gICAgICAgICAgICAgICAgZm9udC1mYW1pbHk6IFwiJHtmb250LmZhbWlseX1cIjtcbiAgICAgICAgICAgICAgICBzcmM6IHVybCgnJHtmb250LmRhdGFTcmN9Jyk7XG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6ICR7Zm9udC53ZWlnaHR9O1xuICAgICAgICAgICAgICAgIGZvbnQtc3R5bGU6ICR7Zm9udC5zdHlsZX07XG4gICAgICAgICAgICAgICAgZm9udC1kaXNwbGF5OiAke2ZvbnQuZGlzcGxheX07XG4gICAgICAgICAgICB9YCwgdGhpcy5fc3R5bGVzaGVldCk7XG4gIH1cbiAgLyoqIEludGVybmFsIHN0eWxlc2hlZXQgY29udGVudHMsIHVzZWZ1bCBmb3IgY3JlYXRpbmcgcnVsZXMgZm9yIHJlbmRlcmluZyAqL1xuICBnZXQgc3R5bGVzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVzaGVldDtcbiAgfVxuICBzZXQgc3R5bGVzaGVldCh2YWx1ZSkge1xuICAgIHRoaXMuX3N0eWxlc2hlZXQgIT09IHZhbHVlICYmICh0aGlzLl9zdHlsZXNoZWV0ID0gdmFsdWUsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBudW1lcmljYWwgY29sb3JzIGludG8gaGV4LXN0cmluZ3NcbiAgICogQHBhcmFtIGNvbG9yXG4gICAqL1xuICBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNvbG9yKSAmJiAoY29sb3IgPSB1dGlscy5yZ2IyaGV4KGNvbG9yKSksIHR5cGVvZiBjb2xvciA9PSBcIm51bWJlclwiID8gdXRpbHMuaGV4MnN0cmluZyhjb2xvcikgOiBjb2xvcjtcbiAgfVxuICAvKiogQ29udmVydCB0aGUgaW50ZXJuYWwgZHJvcC1zaGFkb3cgc2V0dGluZ3MgdG8gQ1NTIHRleHQtc2hhZG93ICovXG4gIGRyb3BTaGFkb3dUb0NTUygpIHtcbiAgICBsZXQgY29sb3IgPSB0aGlzLm5vcm1hbGl6ZUNvbG9yKHRoaXMuZHJvcFNoYWRvd0NvbG9yKTtcbiAgICBjb25zdCBhbHBoYSA9IHRoaXMuZHJvcFNoYWRvd0FscGhhLCB4ID0gTWF0aC5yb3VuZChNYXRoLmNvcyh0aGlzLmRyb3BTaGFkb3dBbmdsZSkgKiB0aGlzLmRyb3BTaGFkb3dEaXN0YW5jZSksIHkgPSBNYXRoLnJvdW5kKE1hdGguc2luKHRoaXMuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuZHJvcFNoYWRvd0Rpc3RhbmNlKTtcbiAgICBjb2xvci5zdGFydHNXaXRoKFwiI1wiKSAmJiBhbHBoYSA8IDEgJiYgKGNvbG9yICs9IChhbHBoYSAqIDI1NSB8IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gYCR7eH1weCAke3l9cHhgO1xuICAgIHJldHVybiB0aGlzLmRyb3BTaGFkb3dCbHVyID4gMCA/IGB0ZXh0LXNoYWRvdzogJHtwb3NpdGlvbn0gJHt0aGlzLmRyb3BTaGFkb3dCbHVyfXB4ICR7Y29sb3J9YCA6IGB0ZXh0LXNoYWRvdzogJHtwb3NpdGlvbn0gJHtjb2xvcn1gO1xuICB9XG4gIC8qKiBSZXNldHMgYWxsIHByb3BlcnRpZXMgdG8gdGhlIGRlZmF1bHRzIHNwZWNpZmllZCBpbiBUZXh0U3R5bGUucHJvdG90eXBlLl9kZWZhdWx0ICovXG4gIHJlc2V0KCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgX0hUTUxUZXh0U3R5bGUyLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIGFmdGVyIHRoZSBpbWFnZSBpcyBsb2FkZWQgYnV0IGJlZm9yZSBkcmF3aW5nIHRvIHRoZSBjYW52YXMuXG4gICAqIE1vc3RseSB1c2VkIHRvIGhhbmRsZSBTYWZhcmkncyBmb250IGxvYWRpbmcgYnVnLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkJlZm9yZURyYXcoKSB7XG4gICAgY29uc3QgeyBmb250c0RpcnR5OiBwcmV2Rm9udHNEaXJ0eSB9ID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5mb250c0RpcnR5ID0gITEsIHRoaXMuaXNTYWZhcmkgJiYgdGhpcy5fZm9udHMubGVuZ3RoID4gMCAmJiBwcmV2Rm9udHNEaXJ0eSA/IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpbmcgdGhhdCBTYWZhcmkgaXMgdGhlIG5ldyBJRVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBnZXQgaXNTYWZhcmkoKSB7XG4gICAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IHNldHRpbmdzLkFEQVBURVIuZ2V0TmF2aWdhdG9yKCk7XG4gICAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QodXNlckFnZW50KTtcbiAgfVxuICBzZXQgZmlsbEdyYWRpZW50U3RvcHMoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIGZpbGxHcmFkaWVudFN0b3BzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFN0b3BzKCkge1xuICAgIHJldHVybiBzdXBlci5maWxsR3JhZGllbnRTdG9wcztcbiAgfVxuICBzZXQgZmlsbEdyYWRpZW50VHlwZShfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gZmlsbEdyYWRpZW50VHlwZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBmaWxsR3JhZGllbnRUeXBlKCkge1xuICAgIHJldHVybiBzdXBlci5maWxsR3JhZGllbnRUeXBlO1xuICB9XG4gIHNldCBtaXRlckxpbWl0KF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBtaXRlckxpbWl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IG1pdGVyTGltaXQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLm1pdGVyTGltaXQ7XG4gIH1cbiAgc2V0IHRyaW0oX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIHRyaW0gaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgdHJpbSgpIHtcbiAgICByZXR1cm4gc3VwZXIudHJpbTtcbiAgfVxuICBzZXQgdGV4dEJhc2VsaW5lKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSB0ZXh0QmFzZWxpbmUgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiBzdXBlci50ZXh0QmFzZWxpbmU7XG4gIH1cbiAgc2V0IGxlYWRpbmcoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIGxlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbGVhZGluZygpIHtcbiAgICByZXR1cm4gc3VwZXIubGVhZGluZztcbiAgfVxuICBzZXQgbGluZUpvaW4oX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIGxpbmVKb2luIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IGxpbmVKb2luKCkge1xuICAgIHJldHVybiBzdXBlci5saW5lSm9pbjtcbiAgfVxufTtcbl9IVE1MVGV4dFN0eWxlLmF2YWlsYWJsZUZvbnRzID0ge30sIC8qKlxuKiBMaXN0IG9mIGRlZmF1bHQgb3B0aW9ucywgdGhlc2UgYXJlIGxhcmdlbHkgdGhlIHNhbWUgYXMgVGV4dFN0eWxlLFxuKiB3aXRoIHRoZSBleGNlcHRpb24gb2Ygd2hpdGVTcGFjZSwgd2hpY2ggaXMgc2V0IHRvICdub3JtYWwnIGJ5IGRlZmF1bHQuXG4qL1xuX0hUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKiBBbGlnbiAqL1xuICBhbGlnbjogXCJsZWZ0XCIsXG4gIC8qKiBCcmVhayB3b3JkcyAqL1xuICBicmVha1dvcmRzOiAhMSxcbiAgLyoqIERyb3Agc2hhZG93ICovXG4gIGRyb3BTaGFkb3c6ICExLFxuICAvKiogRHJvcCBzaGFkb3cgYWxwaGEgKi9cbiAgZHJvcFNoYWRvd0FscGhhOiAxLFxuICAvKipcbiAgICogRHJvcCBzaGFkb3cgYW5nbGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgTWF0aC5QSSAvIDZcbiAgICovXG4gIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gIC8qKiBEcm9wIHNoYWRvdyBibHVyICovXG4gIGRyb3BTaGFkb3dCbHVyOiAwLFxuICAvKiogRHJvcCBzaGFkb3cgY29sb3IgKi9cbiAgZHJvcFNoYWRvd0NvbG9yOiBcImJsYWNrXCIsXG4gIC8qKiBEcm9wIHNoYWRvdyBkaXN0YW5jZSAqL1xuICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gIC8qKiBGaWxsICovXG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgLyoqIEZvbnQgZmFtaWx5ICovXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgLyoqIEZvbnQgc2l6ZSAqL1xuICBmb250U2l6ZTogMjYsXG4gIC8qKiBGb250IHN0eWxlICovXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgLyoqIEZvbnQgdmFyaWFudCAqL1xuICBmb250VmFyaWFudDogXCJub3JtYWxcIixcbiAgLyoqIEZvbnQgd2VpZ2h0ICovXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIC8qKiBMZXR0ZXIgc3BhY2luZyAqL1xuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICAvKiogTGluZSBoZWlnaHQgKi9cbiAgbGluZUhlaWdodDogMCxcbiAgLyoqIFBhZGRpbmcgKi9cbiAgcGFkZGluZzogMCxcbiAgLyoqIFN0cm9rZSAqL1xuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgLyoqIFN0cm9rZSB0aGlja25lc3MgKi9cbiAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxuICAvKiogV2hpdGUgc3BhY2UgKi9cbiAgd2hpdGVTcGFjZTogXCJub3JtYWxcIixcbiAgLyoqIFdvcmQgd3JhcCAqL1xuICB3b3JkV3JhcDogITEsXG4gIC8qKiBXb3JkIHdyYXAgd2lkdGggKi9cbiAgd29yZFdyYXBXaWR0aDogMTAwXG59O1xubGV0IEhUTUxUZXh0U3R5bGUgPSBfSFRNTFRleHRTdHlsZTtcbmV4cG9ydCB7XG4gIEhUTUxUZXh0U3R5bGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFN0eWxlLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUsIHNldHRpbmdzLCBSZWN0YW5nbGUsIHV0aWxzIH0gZnJvbSBcIkBwaXhpL2NvcmVcIjtcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gXCJAcGl4aS9zcHJpdGVcIjtcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gXCJAcGl4aS90ZXh0XCI7XG5pbXBvcnQgeyBIVE1MVGV4dFN0eWxlIH0gZnJvbSBcIi4vSFRNTFRleHRTdHlsZS5tanNcIjtcbmNvbnN0IF9IVE1MVGV4dCA9IGNsYXNzIF9IVE1MVGV4dDIgZXh0ZW5kcyBTcHJpdGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XSAtIFRleHQgY29udGVudHNcbiAgICogQHBhcmFtIHtQSVhJLkhUTUxUZXh0U3R5bGV8UElYSS5UZXh0U3R5bGV8UElYSS5JVGV4dFN0eWxlfSBbc3R5bGVdIC0gU3R5bGUgc2V0dGluZyB0byB1c2UuXG4gICAqICAgICAgICBTdHJvbmdseSByZWNvbW1lbmQgdXNpbmcgYW4gSFRNTFRleHRTdHlsZSBvYmplY3QuIFByb3ZpZGluZyBhIFBJWEkuVGV4dFN0eWxlXG4gICAqICAgICAgICB3aWxsIGNvbnZlcnQgdGhlIFRleHRTdHlsZSB0byBhbiBIVE1MVGV4dFN0eWxlIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBsaW5rZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0ID0gXCJcIiwgc3R5bGUgPSB7fSkge1xuICAgIHN1cGVyKFRleHR1cmUuRU1QVFkpLCB0aGlzLl90ZXh0ID0gbnVsbCwgdGhpcy5fc3R5bGUgPSBudWxsLCB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9ICEwLCB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xLCB0aGlzLmRpcnR5ID0gITEsIHRoaXMuX3VwZGF0ZUlEID0gMCwgdGhpcy5vd25zU3R5bGUgPSAhMTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpLCB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tKGltYWdlLCB7XG4gICAgICBzY2FsZU1vZGU6IHNldHRpbmdzLlNDQUxFX01PREUsXG4gICAgICByZXNvdXJjZU9wdGlvbnM6IHtcbiAgICAgICAgYXV0b0xvYWQ6ICExXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGV4dHVyZS5vcmlnID0gbmV3IFJlY3RhbmdsZSgpLCB0ZXh0dXJlLnRyaW0gPSBuZXcgUmVjdGFuZ2xlKCksIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIG5zeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgc3ZnUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3N2ZywgXCJzdmdcIiksIGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKSwgZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcImRpdlwiKSwgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwic3R5bGVcIik7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMDAwXCIpLCBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMDAwXCIpLCBmb3JlaWduT2JqZWN0LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgc3ZnUm9vdC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KSwgdGhpcy5tYXhXaWR0aCA9IF9IVE1MVGV4dDIuZGVmYXVsdE1heFdpZHRoLCB0aGlzLm1heEhlaWdodCA9IF9IVE1MVGV4dDIuZGVmYXVsdE1heEhlaWdodCwgdGhpcy5fZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQsIHRoaXMuX3N0eWxlRWxlbWVudCA9IHN0eWxlRWxlbWVudCwgdGhpcy5fc3ZnUm9vdCA9IHN2Z1Jvb3QsIHRoaXMuX2ZvcmVpZ25PYmplY3QgPSBmb3JlaWduT2JqZWN0LCB0aGlzLl9mb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCksIHRoaXMuX2ZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoZG9tRWxlbWVudCksIHRoaXMuX2ltYWdlID0gaW1hZ2UsIHRoaXMuX2xvYWRJbWFnZSA9IG5ldyBJbWFnZSgpLCB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IF9IVE1MVGV4dDIuZGVmYXVsdEF1dG9SZXNvbHV0aW9uLCB0aGlzLl9yZXNvbHV0aW9uID0gX0hUTUxUZXh0Mi5kZWZhdWx0UmVzb2x1dGlvbiA/PyBzZXR0aW5ncy5SRVNPTFVUSU9OLCB0aGlzLnRleHQgPSB0ZXh0LCB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgb3V0cHV0IHRleHQgd2l0aG91dCBhY3R1YWxseSBkcmF3aW5nIGl0LlxuICAgKiBUaGlzIGluY2x1ZGVzIHRoZSBgcGFkZGluZ2AgaW4gdGhlIGBzdHlsZWAgb2JqZWN0LlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgZmFzdC1wYXNzIHRvIGRvIHRoaW5ncyBsaWtlIHRleHQtZml0dGluZy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvdmVycmlkZXNdIC0gT3ZlcnJpZGVzIGZvciB0aGUgdGV4dCwgc3R5bGUsIGFuZCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlcy50ZXh0XSAtIFRoZSB0ZXh0IHRvIG1lYXN1cmUsIGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IHRleHQgaXMgdXNlZC5cbiAgICogQHBhcmFtIHtQSVhJLkhUTUxUZXh0U3R5bGV9IFtvdmVycmlkZXMuc3R5bGVdIC0gVGhlIHN0eWxlIHRvIG1lYXN1cmUsIGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IHN0eWxlIGlzIHVzZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3ZlcnJpZGVzLnJlc29sdXRpb25dIC0gVGhlIHJlc29sdXRpb24gdG8gbWVhc3VyZSwgaWYgbm90IHNwZWNpZmllZCwgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7UElYSS5JU2l6ZX0gV2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbWVhc3VyZWQgdGV4dC5cbiAgICovXG4gIG1lYXN1cmVUZXh0KG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHsgdGV4dCwgc3R5bGUsIHJlc29sdXRpb24gfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGV4dDogdGhpcy5fdGV4dCxcbiAgICAgIHN0eWxlOiB0aGlzLl9zdHlsZSxcbiAgICAgIHJlc29sdXRpb246IHRoaXMuX3Jlc29sdXRpb25cbiAgICB9LCBvdmVycmlkZXMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fZG9tRWxlbWVudCwge1xuICAgICAgaW5uZXJIVE1MOiB0ZXh0LFxuICAgICAgc3R5bGU6IHN0eWxlLnRvQ1NTKHJlc29sdXRpb24pXG4gICAgfSksIHRoaXMuX3N0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IHN0eWxlLnRvR2xvYmFsQ1NTKCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fc3ZnUm9vdCk7XG4gICAgY29uc3QgY29udGVudEJvdW5kcyA9IHRoaXMuX2RvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5fc3ZnUm9vdC5yZW1vdmUoKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvbnRlbnRCb3VuZHM7XG4gICAgKHdpZHRoID4gdGhpcy5tYXhXaWR0aCB8fCBoZWlnaHQgPiB0aGlzLm1heEhlaWdodCkgJiYgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0XSBMYXJnZSBleHBhbnNlIG9mIHRleHQsIGluY3JlYXNlIEhUTUxUZXh0Lm1heFdpZHRoIG9yIEhUTUxUZXh0Lm1heEhlaWdodCBwcm9wZXJ0eS5cIik7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgTWF0aC5jZWlsKHdpZHRoKSksIGNvbnRlbnRIZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgTWF0aC5jZWlsKGhlaWdodCkpO1xuICAgIHJldHVybiB0aGlzLl9zdmdSb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGNvbnRlbnRXaWR0aC50b1N0cmluZygpKSwgdGhpcy5fc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgY29udGVudEhlaWdodC50b1N0cmluZygpKSwgdGV4dCAhPT0gdGhpcy5fdGV4dCAmJiAodGhpcy5fZG9tRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl90ZXh0KSwgc3R5bGUgIT09IHRoaXMuX3N0eWxlICYmIChPYmplY3QuYXNzaWduKHRoaXMuX2RvbUVsZW1lbnQsIHsgc3R5bGU6IHRoaXMuX3N0eWxlPy50b0NTUyhyZXNvbHV0aW9uKSB9KSwgdGhpcy5fc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5fc3R5bGU/LnRvR2xvYmFsQ1NTKCkpLCB7XG4gICAgICB3aWR0aDogY29udGVudFdpZHRoICsgc3R5bGUucGFkZGluZyAqIDIsXG4gICAgICBoZWlnaHQ6IGNvbnRlbnRIZWlnaHQgKyBzdHlsZS5wYWRkaW5nICogMlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHJlZnJlc2ggdGhlIHRleHQuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtib29sZWFufSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZVxuICAgKiAgICAgICAgdGV4dCBpZiB0aGUgVGV4dCBpc24ndCBkaXJ0eSBhbmQgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5ID0gITApIHtcbiAgICBjb25zdCB7IHN0eWxlLCBfaW1hZ2U6IGltYWdlLCBfbG9hZEltYWdlOiBsb2FkSW1hZ2UgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEICYmICh0aGlzLmRpcnR5ID0gITAsIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRCksICF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZVRleHQoKTtcbiAgICBpbWFnZS53aWR0aCA9IGxvYWRJbWFnZS53aWR0aCA9IE1hdGguY2VpbChNYXRoLm1heCgxLCB3aWR0aCkpLCBpbWFnZS5oZWlnaHQgPSBsb2FkSW1hZ2UuaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkpLCB0aGlzLl91cGRhdGVJRCsrO1xuICAgIGNvbnN0IHVwZGF0ZUlEID0gdGhpcy5fdXBkYXRlSUQ7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxvYWRJbWFnZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh1cGRhdGVJRCA8IHRoaXMuX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdHlsZS5vbkJlZm9yZURyYXcoKSwgaW1hZ2Uuc3JjID0gbG9hZEltYWdlLnNyYywgbG9hZEltYWdlLm9ubG9hZCA9IG51bGwsIGxvYWRJbWFnZS5zcmMgPSBcIlwiLCB0aGlzLnVwZGF0ZVRleHR1cmUoKSwgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHN2Z1VSTCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5fc3ZnUm9vdCk7XG4gICAgICBsb2FkSW1hZ2Uuc3JjID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQoc3ZnVVJMKX1gO1xuICAgIH0pO1xuICB9XG4gIC8qKiBUaGUgcmF3IGltYWdlIGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZCB1bmRlci10aGUtaG9vZC4gKi9cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdGV4dHVyZSByZXNvdXJjZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBzdHlsZSwgdGV4dHVyZSwgX2ltYWdlOiBpbWFnZSwgcmVzb2x1dGlvbiB9ID0gdGhpcywgeyBwYWRkaW5nIH0gPSBzdHlsZSwgeyBiYXNlVGV4dHVyZSB9ID0gdGV4dHVyZTtcbiAgICB0ZXh0dXJlLnRyaW0ud2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aCA9IGltYWdlLndpZHRoIC8gcmVzb2x1dGlvbiwgdGV4dHVyZS50cmltLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb24sIHRleHR1cmUudHJpbS54ID0gLXBhZGRpbmcsIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmcsIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gcGFkZGluZyAqIDIsIHRleHR1cmUub3JpZy5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgLSBwYWRkaW5nICogMiwgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCksIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHJlc29sdXRpb24pLCB0aGlzLmRpcnR5ID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24gJiYgKHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uLCB0aGlzLmRpcnR5ID0gITApLCB0aGlzLnVwZGF0ZVRleHQoITApLCBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgUmVuZGVyZXIuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uICYmICh0aGlzLl9yZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgdGhpcy5kaXJ0eSA9ICEwKSwgdGhpcy51cGRhdGVUZXh0KCEwKSwgc3VwZXIuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWwgYm91bmRzLlxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0IC0gSW5wdXQgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7UElYSS5SZWN0YW5nbGV9IExvY2FsIGJvdW5kc1xuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCghMCksIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKSwgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGRpcnR5IHN0eWxlIGNoYW5nZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblN0eWxlQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHkgPSAhMDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGlzIFRleHQgb2JqZWN0LiBEb24ndCB1c2UgYWZ0ZXIgY2FsbGluZy5cbiAgICogQHBhcmFtIHtib29sZWFufG9iamVjdH0gb3B0aW9ucyAtIFNhbWUgYXMgU3ByaXRlIGRlc3Ryb3kgb3B0aW9ucy5cbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHR5cGVvZiBvcHRpb25zID09IFwiYm9vbGVhblwiICYmIChvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9KSwgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIF9IVE1MVGV4dDIuZGVmYXVsdERlc3Ryb3lPcHRpb25zLCBvcHRpb25zKSwgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICBjb25zdCBmb3JjZUNsZWFyID0gbnVsbDtcbiAgICB0aGlzLm93bnNTdHlsZSAmJiB0aGlzLl9zdHlsZT8uY2xlYW5Gb250cygpLCB0aGlzLl9zdHlsZSA9IGZvcmNlQ2xlYXIsIHRoaXMuX3N2Z1Jvb3Q/LnJlbW92ZSgpLCB0aGlzLl9zdmdSb290ID0gZm9yY2VDbGVhciwgdGhpcy5fZG9tRWxlbWVudD8ucmVtb3ZlKCksIHRoaXMuX2RvbUVsZW1lbnQgPSBmb3JjZUNsZWFyLCB0aGlzLl9mb3JlaWduT2JqZWN0Py5yZW1vdmUoKSwgdGhpcy5fZm9yZWlnbk9iamVjdCA9IGZvcmNlQ2xlYXIsIHRoaXMuX3N0eWxlRWxlbWVudD8ucmVtb3ZlKCksIHRoaXMuX3N0eWxlRWxlbWVudCA9IGZvcmNlQ2xlYXIsIHRoaXMuX2xvYWRJbWFnZS5zcmMgPSBcIlwiLCB0aGlzLl9sb2FkSW1hZ2Uub25sb2FkID0gbnVsbCwgdGhpcy5fbG9hZEltYWdlID0gZm9yY2VDbGVhciwgdGhpcy5faW1hZ2Uuc3JjID0gXCJcIiwgdGhpcy5faW1hZ2UgPSBmb3JjZUNsZWFyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5faW1hZ2Uud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KCEwKTtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS54ID0gcyAqIHZhbHVlIC8gdGhpcy5faW1hZ2Uud2lkdGggLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IGluIHBpeGVscy5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUZXh0KCEwKSwgTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX2ltYWdlLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KCEwKTtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5faW1hZ2UuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uLCB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIGJhc2Ugc3R5bGUgdG8gcmVuZGVyIHdpdGggdGV4dC4gKi9cbiAgZ2V0IHN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLl9zdHlsZSAhPT0gc3R5bGUgJiYgKHN0eWxlID0gc3R5bGUgfHwge30sIHN0eWxlIGluc3RhbmNlb2YgSFRNTFRleHRTdHlsZSA/ICh0aGlzLm93bnNTdHlsZSA9ICExLCB0aGlzLl9zdHlsZSA9IHN0eWxlKSA6IHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlID8gKGNvbnNvbGUud2FybihcIltIVE1MVGV4dF0gQ2xvbmluZyBUZXh0U3R5bGUsIGlmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHVzZSBIVE1MVGV4dFN0eWxlXCIpLCB0aGlzLm93bnNTdHlsZSA9ICEwLCB0aGlzLl9zdHlsZSA9IEhUTUxUZXh0U3R5bGUuZnJvbShzdHlsZSkpIDogKHRoaXMub3duc1N0eWxlID0gITAsIHRoaXMuX3N0eWxlID0gbmV3IEhUTUxUZXh0U3R5bGUoc3R5bGUpKSwgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogQ29udGVudHMgb2YgdGV4dC4gVGhpcyBjYW4gYmUgSFRNTCB0ZXh0IGFuZCBpbmNsdWRlIHRhZ3MuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHRleHQgPSBuZXcgSFRNTFRleHQoJ1RoaXMgaXMgYSA8ZW0+c3R5bGVkPC9lbT4gdGV4dCEnKTtcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gXCJcIiB8fCB0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHZvaWQgMCA/IFwiIFwiIDogdGV4dCksIHRleHQgPSB0aGlzLnNhbml0aXNlVGV4dCh0ZXh0KSwgdGhpcy5fdGV4dCAhPT0gdGV4dCAmJiAodGhpcy5fdGV4dCA9IHRleHQsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuXG4gICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb247XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9ICExLCB0aGlzLl9yZXNvbHV0aW9uICE9PSB2YWx1ZSAmJiAodGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlLCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGlzZSB0ZXh0IC0gcmVwbGFjZSBgPGJyPmAgd2l0aCBgPGJyLz5gLCBgJm5ic3A7YCB3aXRoIGAmIzE2MDtgXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuc2l0ZXBvaW50LmNvbS9jb21tdW5pdHkvdC94aHRtbC0xLTAtdHJhbnNpdGlvbmFsLXhtbC1wYXJzaW5nLWVycm9yLWVudGl0eS1uYnNwLW5vdC1kZWZpbmVkLzMzOTIvM1xuICAgKi9cbiAgc2FuaXRpc2VUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC88YnI+L2dpLCBcIjxici8+XCIpLnJlcGxhY2UoLzxocj4vZ2ksIFwiPGhyLz5cIikucmVwbGFjZSgvJm5ic3A7L2dpLCBcIiYjMTYwO1wiKTtcbiAgfVxufTtcbl9IVE1MVGV4dC5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gIHRleHR1cmU6ICEwLFxuICBjaGlsZHJlbjogITEsXG4gIGJhc2VUZXh0dXJlOiAhMFxufSwgLyoqIERlZmF1bHQgbWF4V2lkdGgsIHNldCBhdCBjb25zdHJ1Y3Rpb24gKi9cbl9IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGggPSAyMDI0LCAvKiogRGVmYXVsdCBtYXhIZWlnaHQsIHNldCBhdCBjb25zdHJ1Y3Rpb24gKi9cbl9IVE1MVGV4dC5kZWZhdWx0TWF4SGVpZ2h0ID0gMjAyNCwgLyoqIERlZmF1bHQgYXV0b1Jlc29sdXRpb24gZm9yIGFsbCBIVE1MVGV4dCBvYmplY3RzICovXG5fSFRNTFRleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uID0gITA7XG5sZXQgSFRNTFRleHQgPSBfSFRNTFRleHQ7XG5leHBvcnQge1xuICBIVE1MVGV4dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEhUTUxUZXh0IH0gZnJvbSBcIi4vSFRNTFRleHQubWpzXCI7XG5pbXBvcnQgeyBIVE1MVGV4dFN0eWxlIH0gZnJvbSBcIi4vSFRNTFRleHRTdHlsZS5tanNcIjtcbmV4cG9ydCB7XG4gIEhUTUxUZXh0LFxuICBIVE1MVGV4dFN0eWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IFwiQHBpeGkvbWl4aW4tY2FjaGUtYXMtYml0bWFwXCI7XG5pbXBvcnQgXCJAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZVwiO1xuaW1wb3J0IFwiQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvblwiO1xuaW1wb3J0IHsgZmlsdGVycyB9IGZyb20gXCIuL2ZpbHRlcnMubWpzXCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvYWNjZXNzaWJpbGl0eVwiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2FwcFwiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2Fzc2V0c1wiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXNcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9jb3JlXCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvZGlzcGxheVwiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2V2ZW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2V4dHJhY3RcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9maWx0ZXItYWxwaGFcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9maWx0ZXItYmx1clwiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXhcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvZmlsdGVyLWZ4YWFcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9maWx0ZXItbm9pc2VcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9ncmFwaGljc1wiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL21lc2hcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9tZXNoLWV4dHJhc1wiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL3BhcnRpY2xlLWNvbnRhaW5lclwiO1xuZXhwb3J0ICogZnJvbSBcIkBwaXhpL3ByZXBhcmVcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9zcHJpdGVcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9zcHJpdGUtYW5pbWF0ZWRcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS9zcHJpdGUtdGlsaW5nXCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvc3ByaXRlc2hlZXRcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS90ZXh0XCI7XG5leHBvcnQgKiBmcm9tIFwiQHBpeGkvdGV4dC1iaXRtYXBcIjtcbmV4cG9ydCAqIGZyb20gXCJAcGl4aS90ZXh0LWh0bWxcIjtcbmV4cG9ydCB7XG4gIGZpbHRlcnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///647\n')},754:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  jP: () => (/* reexport */ BezierUtil),\n  hp: () => (/* reexport */ Particle),\n  F8: () => (/* reexport */ ParticleGenerator),\n  mG: () => (/* reexport */ ParticleWay)\n});\n\n// UNUSED EXPORTS: GenerationModeManager, MultipleParticleWays, MultipleParticleWaysOption, ParticleContainer, ParticleGeneratorOption\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/Particle.js\n/**\n * パーティクルを表すクラス。\n * このクラス自体には描画のための機能はない。\n * 各種の描画ライブラリと組み合わせて利用する。\n */\nclass Particle {\n    /**\n     * 指定されたパスに沿って移動するパーティクルを生成する。\n     * @param path\n     */\n    constructor(path) {\n        this._ratio = 0.0;\n        this._visible = true;\n        this.path = path;\n    }\n    /**\n     * パーティクルの位置を更新する。\n     * @param t パーティクルのパス上の位置。入力に制限はないが、ParticleWay側で0.0~1.0の間に丸め込まれる。\n     * @return n ease関数で補正済みのt。\n     */\n    update(t) {\n        this._ratio = t;\n        if (this.ease == null) {\n            return this._ratio;\n        }\n        return this.ease(this._ratio);\n    }\n    /**\n     * パーティクル位置を指定された量移動する。\n     * @param t 移動量 0.0 ~ 1.0\n     */\n    add(t) {\n        return this.update(this._ratio + t);\n    }\n    /**\n     * 現在位置を取得する\n     * @return number\n     */\n    get ratio() {\n        return this._ratio;\n    }\n    get visible() {\n        return this._visible;\n    }\n    set visible(value) {\n        this._visible = value;\n    }\n    dispose() { }\n}\nParticle.MAX_RATIO = 1.0;\nParticle.MIN_RATIO = 0.0;\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/ParticleWay.js\n/**\n * 中間点の座標の算出が可能な経路を表すクラス\n */\n\nclass ParticleWay {\n    /**\n     * コンストラクタ\n     * @param points 経路を表す座標の配列。要素数によってどのようなパスかが判定される。\n     *   要素数2 : 2次元パス\n     *   要素数3 : 3次元パス\n     *   要素数6 : 平面3次元ベジェ曲線\n     */\n    constructor(points) {\n        this.name = "";\n        this.points = points;\n    }\n    /**\n     * 経路の座標配列を更新する。\n     * @param points\n     */\n    set points(points) {\n        this._points = points;\n        this.onSetPoints();\n    }\n    warnPoints() {\n        if (this._points.length === 0) {\n            console.warn("ParticleWay : 長さゼロの配列が指定されました。座標が算出できないため、getPoint関数は常にnullを返します。");\n        }\n        if (this._points.length === 1) {\n            console.warn("ParticleWay : 長さ1の配列が指定されました。座標が算出できないため、getPoint関数は常に固定の座標を返します。");\n        }\n    }\n    /**\n     * pointsが更新された際の処理。\n     * set pointsをトリガーにして実行される。\n     */\n    onSetPoints() {\n        this.warnPoints();\n        const sumTable = new Array(this._points.length).fill(0);\n        this._points.forEach((val, index, array) => {\n            if (index === 0)\n                return;\n            sumTable[index] =\n                ParticleWay.getDistance(array[index - 1], val) + sumTable[index - 1];\n        });\n        const total = sumTable[sumTable.length - 1];\n        this._ratioTable = sumTable.map((val) => {\n            return val / total;\n        });\n    }\n    get points() {\n        return this._points;\n    }\n    /**\n     * 2点間の距離を取得する。\n     * @param pos1\n     * @param pos2\n     */\n    static getDistance(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        switch (pos2.length) {\n            case 6:\n                return BezierUtil.getLengthFromCommand(pos1, pos2);\n            case 3:\n                const dz = pos2[2] - pos1[2];\n                return Math.sqrt(dx * dx + dy * dy + dz * dz);\n            case 2:\n                return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n    /**\n     * 経路上の中間点座標を取得する。\n     * @param t 算出する座標の位置。0.0(始点) ~ 1.0(終点)の間。\n     */\n    getPoint(t) {\n        t = ParticleWayUtil.clampRatio(t);\n        const limited = this.getLimitPoint(t);\n        if (limited !== false)\n            return limited;\n        const i = ParticleWayUtil.getTIndex(t, this._ratioTable);\n        const floorPoint = this._points[i];\n        const ceilPoint = this._points[i + 1];\n        const ratioBase = this._ratioTable[i];\n        return this.getCenterPoint(floorPoint, ceilPoint, (t - ratioBase) / (this._ratioTable[i + 1] - ratioBase));\n    }\n    /**\n     * getPointのうち、制限にかかる値を取得する。\n     * @param t\n     * @private\n     */\n    getLimitPoint(t) {\n        if (!this._points || this._points.length === 0) {\n            return null;\n        }\n        if (t === Particle.MAX_RATIO) {\n            return ParticleWayUtil.getPositionWithMaxT(this._points);\n        }\n        if (this._points.length === 1 || t === Particle.MIN_RATIO) {\n            return [...this._points[0]];\n        }\n        return false;\n    }\n    /**\n     * 線分上の中間点座標を取得する\n     * @param pos1 線分の始点\n     * @param pos2 線分の終点\n     * @param t 算出する座標の位置。0.0(始点) ~ 1.0(終点)の間。\n     */\n    getCenterPoint(pos1, pos2, t) {\n        const rt = 1.0 - t;\n        let pos = [pos1[0] * rt + pos2[0] * t, pos1[1] * rt + pos2[1] * t];\n        switch (pos2.length) {\n            case 6:\n                return BezierUtil.getPointFromCommand(t, pos1, pos2);\n            case 3:\n                pos.push(pos1[2] * rt + pos2[2] * t);\n                return pos;\n            case 2:\n                return pos;\n        }\n    }\n}\nclass ParticleWayUtil {\n    static clamp(val, max, min) {\n        return Math.min(Math.max(val, min), max);\n    }\n    static clampRatio(val) {\n        return this.clamp(val, Particle.MAX_RATIO, Particle.MIN_RATIO);\n    }\n    static getPositionWithMaxT(points) {\n        const n = points.length;\n        let result = points[n - 1];\n        if (result.length === 6) {\n            result = result.slice(-2);\n        }\n        return [...result];\n    }\n    static getTIndex(t, ratioTable) {\n        let i = 1;\n        const n = ratioTable.length;\n        for (i; i < n; i++) {\n            if (ratioTable[i] >= t)\n                break;\n        }\n        i--;\n        return i;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/BezierUtil.js\n\nclass BezierUtil {\n    /**\n     * ベジェ曲線の中間座標を取得する。\n     *\n     * @param t 媒介変数 0.0 ~ 1.0\n     * @param from 始点\n     * @param c1 コントロールポイント1\n     * @param c2 コントロールポイント2\n     * @param to 終点\n     */\n    static getPoint(t, from, c1, c2, to) {\n        const addPoint = (p1, p2, coefficient) => {\n            p1[0] += coefficient * p2[0];\n            p1[1] += coefficient * p2[1];\n        };\n        const result = [0, 0];\n        const difT = 1 - t;\n        let v = Math.pow(difT, 3);\n        addPoint(result, from, v);\n        v = 3 * Math.pow(difT, 2) * t;\n        addPoint(result, c1, v);\n        v = 3 * Math.pow(t, 2) * difT;\n        addPoint(result, c2, v);\n        v = Math.pow(t, 3);\n        addPoint(result, to, v);\n        return result;\n    }\n    /**\n     * ベジェ曲線描画コマンドから、ベジェ曲線の中間座標を取得する。\n     * @param t\n     * @param command1 始点側の描画コマンド 要素数2もしくは6の配列\n     * @param command2 終点側の描画コマンド 要素数6の配列\n     */\n    static getPointFromCommand(t, command1, command2) {\n        return this.getPoint(t, command1.slice(-2), command2.slice(0, 2), command2.slice(2, 4), command2.slice(-2));\n    }\n    /**\n     * ベジェ曲線の長さを取得する。\n     * divの数だけベジェ曲線を分割し、直線の集合として距離を測る。\n     *\n     * @param from 始点\n     * @param c1 コントロールポイント1\n     * @param c2 コントロールポイント2\n     * @param to 終点\n     * @param div 分割数 多いほど精度が向上し、計算負荷は上昇する。 既定値16\n     */\n    static getLength(from, c1, c2, to, div = 16) {\n        let result = 0;\n        let prevPoint;\n        for (let i = 0; i < div + 1; i++) {\n            const p = this.getPoint(i / div, from, c1, c2, to);\n            if (prevPoint) {\n                result += ParticleWay.getDistance(prevPoint, p);\n            }\n            prevPoint = p;\n        }\n        return result;\n    }\n    /**\n     * ベジェ曲線描画コマンドから、ベジェ曲線の長さを取得する。\n     *\n     * @param command1 始点側の描画コマンド 要素数2もしくは6の配列\n     * @param command2 終点側の描画コマンド 要素数6の配列\n     * @param div 分割数 多いほど精度が向上し、計算負荷は上昇する。 既定値16\n     */\n    static getLengthFromCommand(command1, command2, div = 16) {\n        return this.getLength(command1.slice(-2), command2.slice(0, 2), command2.slice(2, 4), command2.slice(-2), div);\n    }\n    /**\n     * 3次ベジェ曲線を2次元座標の配列に分解する。\n     * @param commands\n     * @param div 分割数 デフォルトは16\n     */\n    static subdivide(commands, div = 16) {\n        const points = [];\n        for (let i = 1; i < commands.length; i++) {\n            let sub = this.subdivideSubPath(commands[i - 1], commands[i], div);\n            if (i !== 1) {\n                sub = sub.slice(1);\n            }\n            points.push(...sub);\n        }\n        return points;\n    }\n    static subdivideSubPath(command1, command2, div = 16) {\n        const points = [];\n        for (let i = 0; i < div + 1; i++) {\n            points.push(this.getPointFromCommand(i / div, command1, command2));\n        }\n        return points;\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.js\nvar eventemitter3 = __webpack_require__(34);\n;// CONCATENATED MODULE: ./node_modules/eventemitter3/index.mjs\n\n\n\n/* harmony default export */ const node_modules_eventemitter3 = ((/* unused pure expression or super */ null && (EventEmitter)));\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/raf-ticker/esm/RAFTickerEvent.js\nclass RAFTickerEventContext {\n    constructor(timestamp, delta) {\n        this.timestamp = timestamp;\n        this.delta = delta;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/raf-ticker/esm/RAFTicker.js\nvar _a;\n\n\nclass RAFTicker {\n    static initialize() {\n        if (this._dispatcher == null) {\n            this._dispatcher = new eventemitter3();\n        }\n        this.start();\n    }\n    static reset() {\n        this._dispatcher.removeAllListeners();\n        this.stop();\n        this.start();\n    }\n    static start() {\n        if (!_a._id) {\n            this._lastUpdateTimestamp = undefined;\n            _a.onTick(performance.now());\n        }\n    }\n    static stop() {\n        cancelAnimationFrame(_a._id);\n        this._id = undefined;\n        this._lastUpdateTimestamp = undefined;\n    }\n    static addListener(type, listener) {\n        this._dispatcher.on(type, listener);\n    }\n    /**\n     *\n     * @param type\n     * @param listener\n     */\n    static hasListener(type, listener) {\n        const listeners = this._dispatcher.listeners(type);\n        return listeners.includes(listener);\n    }\n    /**\n     * Removes the specified listener\n     *\n     * @param type\n     * @param listener\n     */\n    static removeListener(type, listener) {\n        this._dispatcher.removeListener(type, listener);\n    }\n    /**\n     * イベントを発効する。\n     * この関数はアプリケーションから利用することはなく、主に単体テストのために使用する。\n     *\n     * @param type\n     * @param event\n     */\n    static emit(type, event) {\n        this._dispatcher.emit(type, event);\n    }\n    static emitTickEvent(timestamp) {\n        if (_a._lastUpdateTimestamp == null) {\n            _a._lastUpdateTimestamp = timestamp;\n        }\n        const delta = timestamp - _a._lastUpdateTimestamp;\n        this._dispatcher.emit("onBeforeTick", new RAFTickerEventContext(timestamp, delta));\n        this._dispatcher.emit("tick", new RAFTickerEventContext(timestamp, delta));\n        this._dispatcher.emit("onAfterTick", new RAFTickerEventContext(timestamp, delta));\n        _a._lastUpdateTimestamp = timestamp;\n    }\n}\n_a = RAFTicker;\n/**\n * Alias for addListener\n *\n * @param type\n * @param listener\n */\nRAFTicker.on = _a.addListener;\n/**\n * Alias for removeListener\n *\n * @param type\n * @param listener\n */\nRAFTicker.off = _a.removeListener;\nRAFTicker.onTick = (timestamp) => {\n    _a.emitTickEvent(timestamp);\n    _a._id = requestAnimationFrame(_a.onTick);\n};\nRAFTicker.initialize();\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/raf-ticker/esm/index.js\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/GenerationModeManager.js\n\nclass GenerationModeManager extends eventemitter3 {\n    get mode() {\n        return this._mode;\n    }\n    set mode(value) {\n        if (value === this._mode)\n            return;\n        this._mode = value;\n        this.emit("change", this._mode);\n    }\n    constructor() {\n        super();\n        this._mode = "sequential";\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/MultipleParticleWays.js\n/**\n * このクラスは、ParticleGeneratorに設定された複数の経路を管理するためのものです。\n */\nclass MultipleParticleWays {\n    constructor(option) {\n        this.waySelectionCount = 0;\n        MultipleParticleWaysOption.initOption(option);\n        this.ways = option.ways;\n        this.waySelectType = option.type;\n    }\n    countUp() {\n        this.waySelectionCount = (this.waySelectionCount + 1) % this.ways.length;\n    }\n    getParticleWay() {\n        let index;\n        switch (this.waySelectType) {\n            case "sequential":\n                index = this.waySelectionCount;\n                break;\n            case "random":\n                index = Math.floor(Math.random() * this.ways.length);\n                break;\n        }\n        return this.ways[index];\n    }\n}\nclass MultipleParticleWaysOption {\n    static initOption(option) {\n        option ??= {};\n        option.ways ??= [];\n        if (!Array.isArray(option.ways)) {\n            option.ways = [option.ways];\n        }\n        option.type ??= "sequential";\n        return option;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleGeneratorUtility.js\n/**\n * ParticleGeneratorで利用する各種の値を算出するヘルパークラス\n */\nclass ParticleGeneratorUtility {\n    /**\n     * パーティクルの生成インターバルと経路上の数から、移動速度を算出する\n     * @param interval\n     * @param particleNum\n     */\n    static getSpeed(interval, particleNum) {\n        return (1.0 / (interval * particleNum)) * 1000;\n    }\n    /**\n     * パーティクルの移動速度と経路上の数から、生成インターバルを算出する\n     * @param speed\n     * @param particleNum\n     */\n    static getInterval(speed, particleNum) {\n        return (1.0 / speed / particleNum) * 1000;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleAnimator.js\n\nclass ParticleAnimator {\n    get generationInterval() {\n        return this._generationInterval;\n    }\n    set generationInterval(value) {\n        if (this._generationInterval === value)\n            return;\n        this._generationInterval = value;\n        if (this._modeManager.mode === "loop") {\n            console.warn("ParticleGenerator : ループ指定中にパーティクル生成間隔を再設定しても反映されません。設定を反映するためにパーティクルを削除して再生成してください。");\n            console.trace();\n        }\n    }\n    get ease() {\n        return this._ease;\n    }\n    constructor(modeManager, particleContainer) {\n        this._generationInterval = 300;\n        this.speedPerSec = 0.07;\n        this._particleContainer = particleContainer;\n        this._modeManager = modeManager;\n    }\n    /**\n     * 生成インターバルと経路上のパーティクル数から移動スピードを算出し設定する。\n     * loop時に破綻しない値が得られる。\n     * @param interval\n     * @param particleNum\n     */\n    setSpeed(interval, particleNum) {\n        this._generationInterval = interval;\n        this.speedPerSec = ParticleGeneratorUtility.getSpeed(interval, particleNum);\n    }\n    /**\n     * 移動スピードと経路上のパーティクル数から生成インターバルを算出し設定する。\n     * loop時に破綻しない値が得られる。\n     * @param speed\n     * @param particleNum\n     */\n    setGenerationInterval(speed, particleNum) {\n        this.speedPerSec = speed;\n        this._generationInterval = ParticleGeneratorUtility.getInterval(speed, particleNum);\n    }\n    /**\n     * パーティクルの位置を経過時間分移動する。\n     * @param delta 前回アニメーションが実行されてからの経過時間 単位ms\n     */\n    move(delta) {\n        const movement = (delta / 1000) * this.speedPerSec;\n        this._particleContainer.move(movement);\n    }\n    /**\n     * 各パーティクルのEase関数を更新する。\n     * @param ease イージング関数。\n     * @param override 現存するパーティクルのEase関数を上書きするか否か。規定値はtrue。\n     */\n    updateEase(ease, override = true) {\n        this._ease = ease;\n        if (!override && this._modeManager.mode === "loop") {\n            console.warn("ParticleGenerator : ループ指定中にEase関数を再設定すると、既存のパーティクルのEase関数は常に上書きされます。");\n            console.trace();\n        }\n        if (override || this._modeManager.mode === "loop") {\n            this._particleContainer.overrideEase(ease);\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleContainer.js\n/**\n * 複数のパーティクルを格納、移動、管理するためのクラスです。\n *\n * 主にParticleGeneratorで生成されたパーティクルを管理します。\n * @see {@link ParticleGenerator}\n */\nclass ParticleContainer {\n    get particles() {\n        return this._particles;\n    }\n    get visible() {\n        return this._visible;\n    }\n    set visible(value) {\n        this._visible = value;\n        this._particles.forEach((p) => {\n            p.visible = this._visible;\n        });\n    }\n    constructor(modeManager) {\n        this._particles = [];\n        this._visible = true;\n        modeManager.on("change", (mode) => {\n            if (mode === "loop") {\n                this.removeAll();\n            }\n        });\n    }\n    /**\n     * パーティクルを格納する。\n     * @param particle\n     */\n    add(particle) {\n        this._particles.push(particle);\n        particle.visible = this._visible;\n    }\n    /**\n     * 格納されたすべてのパーティクルを移動させる。\n     * @see {@link Particle.add}\n     * @param t\n     */\n    move(t) {\n        this._particles.forEach((p) => {\n            p.add(t);\n        });\n    }\n    /**\n     * 寿命切れのパーティクルを一括で削除する。\n     */\n    removeCompletedParticles() {\n        //remove particles\n        this._particles\n            .filter((p) => {\n            return p.ratio >= 1.0;\n        })\n            .forEach((p) => {\n            p.dispose();\n        });\n        //update particle array\n        this._particles = this._particles.filter((p) => {\n            return p.ratio < 1.0;\n        });\n    }\n    /**\n     * 指定されたパーティクルを削除する。\n     * @param particle\n     */\n    remove(particle) {\n        const i = this._particles.indexOf(particle);\n        const popped = this._particles.splice(i, 1);\n        popped.forEach((val) => {\n            val.dispose();\n        });\n    }\n    /**\n     * 格納されたすべてのパーティクルを削除する。\n     */\n    removeAll() {\n        this._particles.forEach((p) => {\n            p.dispose();\n        });\n        this._particles = [];\n    }\n    /**\n     * 終端にたどり着いたパーティクルを始点に巻き戻す。\n     */\n    rollupParticles() {\n        this._particles.forEach((p) => {\n            p.update(p.ratio % 1);\n        });\n    }\n    overrideEase(ease) {\n        this._particles.forEach((p) => {\n            p.ease = ease;\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleValve.js\n/**\n * パーティクル新規生成のバルブ開閉を行うクラス\n * @see {@link ParticleGenerator}\n */\nclass ParticleValve {\n    get isOpen() {\n        return this._isOpen;\n    }\n    constructor(modeManager) {\n        this._isOpen = true;\n        this._modeManager = modeManager;\n    }\n    /**\n     * パーティクル生成を開始する。\n     */\n    open() {\n        if (this._isOpen)\n            return;\n        this._isOpen = true;\n        this.warnUpdateValveMode();\n    }\n    /**\n     * パーティクル生成を停止する。\n     * アニメーションは続行される。\n     */\n    close() {\n        if (!this._isOpen)\n            return;\n        this._isOpen = false;\n        this.warnUpdateValveMode();\n    }\n    warnUpdateValveMode() {\n        if (this._modeManager.mode !== "loop")\n            return;\n        console.warn("ParticleGenerator : ループ指定中にバルブ開閉操作を行いました。この操作はループ指定中には反映されません。");\n        console.trace();\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleGenerator.js\n\n\n\n\n\n\n\n/**\n * 一定間隔でパーティクルを生成し、アニメーションさせるクラス。\n * パーティクルインスタンスの生成と管理を行う。\n */\nclass ParticleGenerator {\n    get isPlaying() {\n        return this._isPlaying;\n    }\n    /**\n     * コンストラクタ\n     * @param path\n     * @param option\n     */\n    constructor(path, option) {\n        this._isPlaying = false;\n        /**\n         * 前回パーティクル生成時からの経過時間 単位ms\n         * @private\n         */\n        this.elapsedFromGenerate = 0;\n        this._isDisposed = false;\n        /**\n         * パーティクルをアニメーションさせる。\n         * @param e\n         */\n        this.animate = (e) => {\n            if (this._isDisposed)\n                return;\n            this.animator.move(e.delta);\n            this.particleContainer.removeCompletedParticles();\n            this.addParticle(e.delta);\n        };\n        /**\n         * パーティクルをループアニメーションさせる。\n         * @param e\n         */\n        this.loop = (e) => {\n            if (this._isDisposed)\n                return;\n            if (this.particleContainer.particles.length === 0) {\n                this.generateAll();\n            }\n            this.animator.move(e.delta);\n            this.particleContainer.rollupParticles();\n        };\n        this.modeManager = new GenerationModeManager();\n        this.multipleWays = new MultipleParticleWays({ ways: path });\n        this.particleContainer = new ParticleContainer(this.modeManager);\n        this.valve = new ParticleValve(this.modeManager);\n        this.animator = new ParticleAnimator(this.modeManager, this.particleContainer);\n        this.modeManager.on("change", (val) => {\n            if (this._isPlaying) {\n                this.stop();\n                this.play();\n            }\n        });\n        option = ParticleGeneratorOption.initOption(option);\n        this.modeManager.mode = option.generationMode;\n        this.animator.updateEase(option.ease);\n        this.probability = option.probability;\n    }\n    /**\n     * パーティクルアニメーションを開始する。\n     */\n    play() {\n        if (this._isPlaying)\n            return;\n        this._isPlaying = true;\n        switch (this.modeManager.mode) {\n            case "loop":\n                RAFTicker.addListener("tick", this.loop);\n                break;\n            case "sequential":\n                RAFTicker.addListener("tick", this.animate);\n                break;\n        }\n    }\n    /**\n     * パーティクルアニメーションを停止する。\n     */\n    stop() {\n        if (!this._isPlaying)\n            return;\n        this._isPlaying = false;\n        RAFTicker.removeListener("tick", this.loop);\n        RAFTicker.removeListener("tick", this.animate);\n    }\n    /**\n     * アニメーションに伴い、新規パーティクルを追加する。\n     * @param delta\n     */\n    addParticle(delta) {\n        if (!this.valve.isOpen)\n            return;\n        const anim = this.animator;\n        this.elapsedFromGenerate += delta;\n        while (this.elapsedFromGenerate > anim.generationInterval) {\n            this.elapsedFromGenerate -= anim.generationInterval;\n            const move = (this.elapsedFromGenerate * anim.speedPerSec) / 1000;\n            //すでに寿命切れのパーティクルは生成をスキップ。\n            if (move > Particle.MAX_RATIO) {\n                continue;\n            }\n            const particle = this.generate();\n            particle?.add(move);\n        }\n    }\n    /**\n     * パーティクルを1つ追加する。\n     */\n    generate() {\n        this.multipleWays.countUp();\n        //発生確率に応じて生成の可否を判定する。\n        if (this.probability !== 1.0) {\n            if (Math.random() > this.probability)\n                return null;\n        }\n        const path = this.multipleWays.getParticleWay();\n        const particle = this.generateParticle(path);\n        if (this.animator.ease != null) {\n            particle.ease = this.animator.ease;\n        }\n        this.particleContainer.add(particle);\n        return particle;\n    }\n    /**\n     * パーティクルを生成する。\n     * generate関数の内部処理。\n     * @param path\n     */\n    generateParticle(path) {\n        const particle = new Particle(path);\n        //TODO ここでコンテナに挿入。\n        return particle;\n    }\n    /**\n     * 経路上にパーティクルを敷き詰める。\n     */\n    generateAll() {\n        //パーティクルの最大生存期間 単位ミリ秒\n        let lifeTime = 1000.0 / this.animator.speedPerSec;\n        while (lifeTime > 0.0) {\n            const particle = this.generate();\n            if (particle)\n                particle.update((lifeTime / 1000) * this.animator.speedPerSec);\n            lifeTime -= this.animator.generationInterval;\n        }\n        this.elapsedFromGenerate = 0;\n    }\n    /**\n     * パーティクル生成の停止とパーティクルの破棄を行う。\n     */\n    dispose() {\n        this.stop();\n        this._isDisposed = true;\n        this.particleContainer.removeAll();\n        this.particleContainer = null;\n        this.multipleWays = null;\n    }\n}\n/**\n * パーティクル生成方法を指定するオプション\n */\nclass ParticleGeneratorOption {\n    static initOption(option) {\n        option ??= {};\n        option.generationMode ??= "sequential";\n        option.probability ??= 1.0;\n        return option;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/index.js\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQ2hHQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDcUQ7QUFDZDtBQUM2QjtBQUNIO0FBQ1I7QUFDRTtBQUNSO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQsZ0NBQWdDLG9CQUFvQixHQUFHLFlBQVk7QUFDbkUscUNBQXFDLGlCQUFpQjtBQUN0RCx5QkFBeUIsYUFBYTtBQUN0Qyw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQixRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakw4QjtBQUNHO0FBQ0Q7QUFDaUI7QUFDRztBQUNIO0FBQ0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9QYXJ0aWNsZS5qcz82YjNmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcGFydGljbGUtd2F5cG9pbnQvZXNtL1BhcnRpY2xlV2F5LmpzPzhlODYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vQmV6aWVyVXRpbC5qcz9hNzI0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzPzE5MzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9yYWYtdGlja2VyL2VzbS9SQUZUaWNrZXJFdmVudC5qcz9hNGIxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcmFmLXRpY2tlci9lc20vUkFGVGlja2VyLmpzPzAzYTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9yYWYtdGlja2VyL2VzbS9pbmRleC5qcz8yMWUxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcGFydGljbGUtd2F5cG9pbnQvZXNtL2dlbmVyYXRvci9HZW5lcmF0aW9uTW9kZU1hbmFnZXIuanM/NDgwYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9nZW5lcmF0b3IvTXVsdGlwbGVQYXJ0aWNsZVdheXMuanM/M2IyYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9nZW5lcmF0b3IvUGFydGljbGVHZW5lcmF0b3JVdGlsaXR5LmpzPzI2YzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vZ2VuZXJhdG9yL1BhcnRpY2xlQW5pbWF0b3IuanM/YTM2YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9nZW5lcmF0b3IvUGFydGljbGVDb250YWluZXIuanM/M2VjYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9nZW5lcmF0b3IvUGFydGljbGVWYWx2ZS5qcz81NTA1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcGFydGljbGUtd2F5cG9pbnQvZXNtL2dlbmVyYXRvci9QYXJ0aWNsZUdlbmVyYXRvci5qcz9mMjI0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcGFydGljbGUtd2F5cG9pbnQvZXNtL2luZGV4LmpzPzJiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDjg5Hjg7zjg4bjgqPjgq/jg6vjgpLooajjgZnjgq/jg6njgrnjgIJcbiAqIOOBk+OBruOCr+ODqeOCueiHquS9k+OBq+OBr+aPj+eUu+OBruOBn+OCgeOBruapn+iDveOBr+OBquOBhOOAglxuICog5ZCE56iu44Gu5o+P55S744Op44Kk44OW44Op44Oq44Go57WE44G/5ZCI44KP44Gb44Gm5Yip55So44GZ44KL44CCXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNsZSB7XG4gICAgLyoqXG4gICAgICog5oyH5a6a44GV44KM44Gf44OR44K544Gr5rK/44Gj44Gm56e75YuV44GZ44KL44OR44O844OG44Kj44Kv44Or44KS55Sf5oiQ44GZ44KL44CCXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gMC4wO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44Gu5L2N572u44KS5pu05paw44GZ44KL44CCXG4gICAgICogQHBhcmFtIHQg44OR44O844OG44Kj44Kv44Or44Gu44OR44K55LiK44Gu5L2N572u44CC5YWl5Yqb44Gr5Yi26ZmQ44Gv44Gq44GE44GM44CBUGFydGljbGVXYXnlgbTjgacwLjB+MS4w44Gu6ZaT44Gr5Li444KB6L6844G+44KM44KL44CCXG4gICAgICogQHJldHVybiBuIGVhc2XplqLmlbDjgafoo5zmraPmuIjjgb/jga5044CCXG4gICAgICovXG4gICAgdXBkYXRlKHQpIHtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSB0O1xuICAgICAgICBpZiAodGhpcy5lYXNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYXRpbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lYXNlKHRoaXMuX3JhdGlvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or5L2N572u44KS5oyH5a6a44GV44KM44Gf6YeP56e75YuV44GZ44KL44CCXG4gICAgICogQHBhcmFtIHQg56e75YuV6YePIDAuMCB+IDEuMFxuICAgICAqL1xuICAgIGFkZCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh0aGlzLl9yYXRpbyArIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDnj77lnKjkvY3nva7jgpLlj5blvpfjgZnjgotcbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqL1xuICAgIGdldCByYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhdGlvO1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfVxuICAgIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHsgfVxufVxuUGFydGljbGUuTUFYX1JBVElPID0gMS4wO1xuUGFydGljbGUuTUlOX1JBVElPID0gMC4wO1xuIiwiLyoqXG4gKiDkuK3plpPngrnjga7luqfmqJnjga7nrpflh7rjgYzlj6/og73jgarntYzot6/jgpLooajjgZnjgq/jg6njgrlcbiAqL1xuaW1wb3J0IHsgUGFydGljbGUsIEJlemllclV0aWwgfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuZXhwb3J0IGNsYXNzIFBhcnRpY2xlV2F5IHtcbiAgICAvKipcbiAgICAgKiDjgrPjg7Pjgrnjg4jjg6njgq/jgr9cbiAgICAgKiBAcGFyYW0gcG9pbnRzIOe1jOi3r+OCkuihqOOBmeW6p+aomeOBrumFjeWIl+OAguimgee0oOaVsOOBq+OCiOOBo+OBpuOBqeOBruOCiOOBhuOBquODkeOCueOBi+OBjOWIpOWumuOBleOCjOOCi+OAglxuICAgICAqICAg6KaB57Sg5pWwMiA6IDLmrKHlhYPjg5HjgrlcbiAgICAgKiAgIOimgee0oOaVsDMgOiAz5qyh5YWD44OR44K5XG4gICAgICogICDopoHntKDmlbA2IDog5bmz6Z2iM+asoeWFg+ODmeOCuOOCp+absue3mlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cykge1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICog57WM6Lev44Gu5bqn5qiZ6YWN5YiX44KS5pu05paw44GZ44KL44CCXG4gICAgICogQHBhcmFtIHBvaW50c1xuICAgICAqL1xuICAgIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy5vblNldFBvaW50cygpO1xuICAgIH1cbiAgICB3YXJuUG9pbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUGFydGljbGVXYXkgOiDplbfjgZXjgrzjg63jga7phY3liJfjgYzmjIflrprjgZXjgozjgb7jgZfjgZ/jgILluqfmqJnjgYznrpflh7rjgafjgY3jgarjgYTjgZ/jgoHjgIFnZXRQb2ludOmWouaVsOOBr+W4uOOBq251bGzjgpLov5TjgZfjgb7jgZnjgIJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlBhcnRpY2xlV2F5IDog6ZW344GVMeOBrumFjeWIl+OBjOaMh+WumuOBleOCjOOBvuOBl+OBn+OAguW6p+aomeOBjOeul+WHuuOBp+OBjeOBquOBhOOBn+OCgeOAgWdldFBvaW506Zai5pWw44Gv5bi444Gr5Zu65a6a44Gu5bqn5qiZ44KS6L+U44GX44G+44GZ44CCXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBvaW50c+OBjOabtOaWsOOBleOCjOOBn+mam+OBruWHpueQhuOAglxuICAgICAqIHNldCBwb2ludHPjgpLjg4jjg6rjgqzjg7zjgavjgZfjgablrp/ooYzjgZXjgozjgovjgIJcbiAgICAgKi9cbiAgICBvblNldFBvaW50cygpIHtcbiAgICAgICAgdGhpcy53YXJuUG9pbnRzKCk7XG4gICAgICAgIGNvbnN0IHN1bVRhYmxlID0gbmV3IEFycmF5KHRoaXMuX3BvaW50cy5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuX3BvaW50cy5mb3JFYWNoKCh2YWwsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN1bVRhYmxlW2luZGV4XSA9XG4gICAgICAgICAgICAgICAgUGFydGljbGVXYXkuZ2V0RGlzdGFuY2UoYXJyYXlbaW5kZXggLSAxXSwgdmFsKSArIHN1bVRhYmxlW2luZGV4IC0gMV07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHN1bVRhYmxlW3N1bVRhYmxlLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLl9yYXRpb1RhYmxlID0gc3VtVGFibGUubWFwKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgLyB0b3RhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBwb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDLngrnplpPjga7ot53pm6LjgpLlj5blvpfjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gcG9zMVxuICAgICAqIEBwYXJhbSBwb3MyXG4gICAgICovXG4gICAgc3RhdGljIGdldERpc3RhbmNlKHBvczEsIHBvczIpIHtcbiAgICAgICAgY29uc3QgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcbiAgICAgICAgY29uc3QgZHkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcbiAgICAgICAgc3dpdGNoIChwb3MyLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBCZXppZXJVdGlsLmdldExlbmd0aEZyb21Db21tYW5kKHBvczEsIHBvczIpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNvbnN0IGR6ID0gcG9zMlsyXSAtIHBvczFbMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOe1jOi3r+S4iuOBruS4remWk+eCueW6p+aomeOCkuWPluW+l+OBmeOCi+OAglxuICAgICAqIEBwYXJhbSB0IOeul+WHuuOBmeOCi+W6p+aomeOBruS9jee9ruOAgjAuMCjlp4vngrkpIH4gMS4wKOe1gueCuSnjga7plpPjgIJcbiAgICAgKi9cbiAgICBnZXRQb2ludCh0KSB7XG4gICAgICAgIHQgPSBQYXJ0aWNsZVdheVV0aWwuY2xhbXBSYXRpbyh0KTtcbiAgICAgICAgY29uc3QgbGltaXRlZCA9IHRoaXMuZ2V0TGltaXRQb2ludCh0KTtcbiAgICAgICAgaWYgKGxpbWl0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGxpbWl0ZWQ7XG4gICAgICAgIGNvbnN0IGkgPSBQYXJ0aWNsZVdheVV0aWwuZ2V0VEluZGV4KHQsIHRoaXMuX3JhdGlvVGFibGUpO1xuICAgICAgICBjb25zdCBmbG9vclBvaW50ID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICBjb25zdCBjZWlsUG9pbnQgPSB0aGlzLl9wb2ludHNbaSArIDFdO1xuICAgICAgICBjb25zdCByYXRpb0Jhc2UgPSB0aGlzLl9yYXRpb1RhYmxlW2ldO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludChmbG9vclBvaW50LCBjZWlsUG9pbnQsICh0IC0gcmF0aW9CYXNlKSAvICh0aGlzLl9yYXRpb1RhYmxlW2kgKyAxXSAtIHJhdGlvQmFzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQb2ludOOBruOBhuOBoeOAgeWItumZkOOBq+OBi+OBi+OCi+WApOOCkuWPluW+l+OBmeOCi+OAglxuICAgICAqIEBwYXJhbSB0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRMaW1pdFBvaW50KHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wb2ludHMgfHwgdGhpcy5fcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPT09IFBhcnRpY2xlLk1BWF9SQVRJTykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnRpY2xlV2F5VXRpbC5nZXRQb3NpdGlvbldpdGhNYXhUKHRoaXMuX3BvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDEgfHwgdCA9PT0gUGFydGljbGUuTUlOX1JBVElPKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuX3BvaW50c1swXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDnt5rliIbkuIrjga7kuK3plpPngrnluqfmqJnjgpLlj5blvpfjgZnjgotcbiAgICAgKiBAcGFyYW0gcG9zMSDnt5rliIbjga7lp4vngrlcbiAgICAgKiBAcGFyYW0gcG9zMiDnt5rliIbjga7ntYLngrlcbiAgICAgKiBAcGFyYW0gdCDnrpflh7rjgZnjgovluqfmqJnjga7kvY3nva7jgIIwLjAo5aeL54K5KSB+IDEuMCjntYLngrkp44Gu6ZaT44CCXG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQocG9zMSwgcG9zMiwgdCkge1xuICAgICAgICBjb25zdCBydCA9IDEuMCAtIHQ7XG4gICAgICAgIGxldCBwb3MgPSBbcG9zMVswXSAqIHJ0ICsgcG9zMlswXSAqIHQsIHBvczFbMV0gKiBydCArIHBvczJbMV0gKiB0XTtcbiAgICAgICAgc3dpdGNoIChwb3MyLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBCZXppZXJVdGlsLmdldFBvaW50RnJvbUNvbW1hbmQodCwgcG9zMSwgcG9zMik7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcG9zLnB1c2gocG9zMVsyXSAqIHJ0ICsgcG9zMlsyXSAqIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFBhcnRpY2xlV2F5VXRpbCB7XG4gICAgc3RhdGljIGNsYW1wKHZhbCwgbWF4LCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgc3RhdGljIGNsYW1wUmF0aW8odmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYW1wKHZhbCwgUGFydGljbGUuTUFYX1JBVElPLCBQYXJ0aWNsZS5NSU5fUkFUSU8pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UG9zaXRpb25XaXRoTWF4VChwb2ludHMpIHtcbiAgICAgICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSBwb2ludHNbbiAtIDFdO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLnJlc3VsdF07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUSW5kZXgodCwgcmF0aW9UYWJsZSkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGNvbnN0IG4gPSByYXRpb1RhYmxlLmxlbmd0aDtcbiAgICAgICAgZm9yIChpOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmF0aW9UYWJsZVtpXSA+PSB0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUGFydGljbGVXYXkgfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuZXhwb3J0IGNsYXNzIEJlemllclV0aWwge1xuICAgIC8qKlxuICAgICAqIOODmeOCuOOCp+absue3muOBruS4remWk+W6p+aomeOCkuWPluW+l+OBmeOCi+OAglxuICAgICAqXG4gICAgICogQHBhcmFtIHQg5aqS5LuL5aSJ5pWwIDAuMCB+IDEuMFxuICAgICAqIEBwYXJhbSBmcm9tIOWni+eCuVxuICAgICAqIEBwYXJhbSBjMSDjgrPjg7Pjg4jjg63jg7zjg6vjg53jgqTjg7Pjg4gxXG4gICAgICogQHBhcmFtIGMyIOOCs+ODs+ODiOODreODvOODq+ODneOCpOODs+ODiDJcbiAgICAgKiBAcGFyYW0gdG8g57WC54K5XG4gICAgICovXG4gICAgc3RhdGljIGdldFBvaW50KHQsIGZyb20sIGMxLCBjMiwgdG8pIHtcbiAgICAgICAgY29uc3QgYWRkUG9pbnQgPSAocDEsIHAyLCBjb2VmZmljaWVudCkgPT4ge1xuICAgICAgICAgICAgcDFbMF0gKz0gY29lZmZpY2llbnQgKiBwMlswXTtcbiAgICAgICAgICAgIHAxWzFdICs9IGNvZWZmaWNpZW50ICogcDJbMV07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgZGlmVCA9IDEgLSB0O1xuICAgICAgICBsZXQgdiA9IE1hdGgucG93KGRpZlQsIDMpO1xuICAgICAgICBhZGRQb2ludChyZXN1bHQsIGZyb20sIHYpO1xuICAgICAgICB2ID0gMyAqIE1hdGgucG93KGRpZlQsIDIpICogdDtcbiAgICAgICAgYWRkUG9pbnQocmVzdWx0LCBjMSwgdik7XG4gICAgICAgIHYgPSAzICogTWF0aC5wb3codCwgMikgKiBkaWZUO1xuICAgICAgICBhZGRQb2ludChyZXN1bHQsIGMyLCB2KTtcbiAgICAgICAgdiA9IE1hdGgucG93KHQsIDMpO1xuICAgICAgICBhZGRQb2ludChyZXN1bHQsIHRvLCB2KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OZ44K444Kn5puy57ea5o+P55S744Kz44Oe44Oz44OJ44GL44KJ44CB44OZ44K444Kn5puy57ea44Gu5Lit6ZaT5bqn5qiZ44KS5Y+W5b6X44GZ44KL44CCXG4gICAgICogQHBhcmFtIHRcbiAgICAgKiBAcGFyYW0gY29tbWFuZDEg5aeL54K55YG044Gu5o+P55S744Kz44Oe44Oz44OJIOimgee0oOaVsDLjgoLjgZfjgY/jga8244Gu6YWN5YiXXG4gICAgICogQHBhcmFtIGNvbW1hbmQyIOe1gueCueWBtOOBruaPj+eUu+OCs+ODnuODs+ODiSDopoHntKDmlbA244Gu6YWN5YiXXG4gICAgICovXG4gICAgc3RhdGljIGdldFBvaW50RnJvbUNvbW1hbmQodCwgY29tbWFuZDEsIGNvbW1hbmQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBvaW50KHQsIGNvbW1hbmQxLnNsaWNlKC0yKSwgY29tbWFuZDIuc2xpY2UoMCwgMiksIGNvbW1hbmQyLnNsaWNlKDIsIDQpLCBjb21tYW5kMi5zbGljZSgtMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5njgrjjgqfmm7Lnt5rjga7plbfjgZXjgpLlj5blvpfjgZnjgovjgIJcbiAgICAgKiBkaXbjga7mlbDjgaDjgZHjg5njgrjjgqfmm7Lnt5rjgpLliIblibLjgZfjgIHnm7Tnt5rjga7pm4blkIjjgajjgZfjgabot53pm6LjgpLmuKzjgovjgIJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tIOWni+eCuVxuICAgICAqIEBwYXJhbSBjMSDjgrPjg7Pjg4jjg63jg7zjg6vjg53jgqTjg7Pjg4gxXG4gICAgICogQHBhcmFtIGMyIOOCs+ODs+ODiOODreODvOODq+ODneOCpOODs+ODiDJcbiAgICAgKiBAcGFyYW0gdG8g57WC54K5XG4gICAgICogQHBhcmFtIGRpdiDliIblibLmlbAg5aSa44GE44G744Gp57K+5bqm44GM5ZCR5LiK44GX44CB6KiI566X6LKg6I2344Gv5LiK5piH44GZ44KL44CCIOaXouWumuWApDE2XG4gICAgICovXG4gICAgc3RhdGljIGdldExlbmd0aChmcm9tLCBjMSwgYzIsIHRvLCBkaXYgPSAxNikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgbGV0IHByZXZQb2ludDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXYgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldFBvaW50KGkgLyBkaXYsIGZyb20sIGMxLCBjMiwgdG8pO1xuICAgICAgICAgICAgaWYgKHByZXZQb2ludCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBQYXJ0aWNsZVdheS5nZXREaXN0YW5jZShwcmV2UG9pbnQsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBvaW50ID0gcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5njgrjjgqfmm7Lnt5rmj4/nlLvjgrPjg57jg7Pjg4njgYvjgonjgIHjg5njgrjjgqfmm7Lnt5rjga7plbfjgZXjgpLlj5blvpfjgZnjgovjgIJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21tYW5kMSDlp4vngrnlgbTjga7mj4/nlLvjgrPjg57jg7Pjg4kg6KaB57Sg5pWwMuOCguOBl+OBj+OBrzbjga7phY3liJdcbiAgICAgKiBAcGFyYW0gY29tbWFuZDIg57WC54K55YG044Gu5o+P55S744Kz44Oe44Oz44OJIOimgee0oOaVsDbjga7phY3liJdcbiAgICAgKiBAcGFyYW0gZGl2IOWIhuWJsuaVsCDlpJrjgYTjgbvjgannsr7luqbjgYzlkJHkuIrjgZfjgIHoqIjnrpfosqDojbfjga/kuIrmmIfjgZnjgovjgIIg5pei5a6a5YCkMTZcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TGVuZ3RoRnJvbUNvbW1hbmQoY29tbWFuZDEsIGNvbW1hbmQyLCBkaXYgPSAxNikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMZW5ndGgoY29tbWFuZDEuc2xpY2UoLTIpLCBjb21tYW5kMi5zbGljZSgwLCAyKSwgY29tbWFuZDIuc2xpY2UoMiwgNCksIGNvbW1hbmQyLnNsaWNlKC0yKSwgZGl2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogM+asoeODmeOCuOOCp+absue3muOCkjLmrKHlhYPluqfmqJnjga7phY3liJfjgavliIbop6PjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gY29tbWFuZHNcbiAgICAgKiBAcGFyYW0gZGl2IOWIhuWJsuaVsCDjg4fjg5Xjgqnjg6vjg4jjga8xNlxuICAgICAqL1xuICAgIHN0YXRpYyBzdWJkaXZpZGUoY29tbWFuZHMsIGRpdiA9IDE2KSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3ViID0gdGhpcy5zdWJkaXZpZGVTdWJQYXRoKGNvbW1hbmRzW2kgLSAxXSwgY29tbWFuZHNbaV0sIGRpdik7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHN1YiA9IHN1Yi5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKC4uLnN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgc3RhdGljIHN1YmRpdmlkZVN1YlBhdGgoY29tbWFuZDEsIGNvbW1hbmQyLCBkaXYgPSAxNikge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXYgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuZ2V0UG9pbnRGcm9tQ29tbWFuZChpIC8gZGl2LCBjb21tYW5kMSwgY29tbWFuZDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi9pbmRleC5qcydcblxuZXhwb3J0IHsgRXZlbnRFbWl0dGVyIH1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlclxuIiwiZXhwb3J0IGNsYXNzIFJBRlRpY2tlckV2ZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodGltZXN0YW1wLCBkZWx0YSkge1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xuICAgIH1cbn1cbiIsInZhciBfYTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudGVtaXR0ZXIzXCI7XG5pbXBvcnQgeyBSQUZUaWNrZXJFdmVudENvbnRleHQgfSBmcm9tIFwiLi9SQUZUaWNrZXJFdmVudC5qc1wiO1xuZXhwb3J0IGNsYXNzIFJBRlRpY2tlciB7XG4gICAgc3RhdGljIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwYXRjaGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKCFfYS5faWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RVcGRhdGVUaW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfYS5vblRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBzdG9wKCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShfYS5faWQpO1xuICAgICAgICB0aGlzLl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbGFzdFVwZGF0ZVRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RhdGljIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIub24odHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgc3RhdGljIGhhc0xpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2Rpc3BhdGNoZXIubGlzdGVuZXJzKHR5cGUpO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmluY2x1ZGVzKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44Kk44OZ44Oz44OI44KS55m65Yq544GZ44KL44CCXG4gICAgICog44GT44Gu6Zai5pWw44Gv44Ki44OX44Oq44Kx44O844K344On44Oz44GL44KJ5Yip55So44GZ44KL44GT44Go44Gv44Gq44GP44CB5Li744Gr5Y2Y5L2T44OG44K544OI44Gu44Gf44KB44Gr5L2/55So44GZ44KL44CCXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIHN0YXRpYyBlbWl0KHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZW1pdCh0eXBlLCBldmVudCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbWl0VGlja0V2ZW50KHRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoX2EuX2xhc3RVcGRhdGVUaW1lc3RhbXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgX2EuX2xhc3RVcGRhdGVUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBfYS5fbGFzdFVwZGF0ZVRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5lbWl0KFwib25CZWZvcmVUaWNrXCIsIG5ldyBSQUZUaWNrZXJFdmVudENvbnRleHQodGltZXN0YW1wLCBkZWx0YSkpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLmVtaXQoXCJ0aWNrXCIsIG5ldyBSQUZUaWNrZXJFdmVudENvbnRleHQodGltZXN0YW1wLCBkZWx0YSkpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLmVtaXQoXCJvbkFmdGVyVGlja1wiLCBuZXcgUkFGVGlja2VyRXZlbnRDb250ZXh0KHRpbWVzdGFtcCwgZGVsdGEpKTtcbiAgICAgICAgX2EuX2xhc3RVcGRhdGVUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxufVxuX2EgPSBSQUZUaWNrZXI7XG4vKipcbiAqIEFsaWFzIGZvciBhZGRMaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gbGlzdGVuZXJcbiAqL1xuUkFGVGlja2VyLm9uID0gX2EuYWRkTGlzdGVuZXI7XG4vKipcbiAqIEFsaWFzIGZvciByZW1vdmVMaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gbGlzdGVuZXJcbiAqL1xuUkFGVGlja2VyLm9mZiA9IF9hLnJlbW92ZUxpc3RlbmVyO1xuUkFGVGlja2VyLm9uVGljayA9ICh0aW1lc3RhbXApID0+IHtcbiAgICBfYS5lbWl0VGlja0V2ZW50KHRpbWVzdGFtcCk7XG4gICAgX2EuX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9hLm9uVGljayk7XG59O1xuUkFGVGlja2VyLmluaXRpYWxpemUoKTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL1JBRlRpY2tlci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vUkFGVGlja2VyRXZlbnQuanNcIjtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudGVtaXR0ZXIzXCI7XG5leHBvcnQgY2xhc3MgR2VuZXJhdGlvbk1vZGVNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuICAgIHNldCBtb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fbW9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbW9kZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcy5fbW9kZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9tb2RlID0gXCJzZXF1ZW50aWFsXCI7XG4gICAgfVxufVxuIiwiLyoqXG4gKiDjgZPjga7jgq/jg6njgrnjga/jgIFQYXJ0aWNsZUdlbmVyYXRvcuOBq+ioreWumuOBleOCjOOBn+ikh+aVsOOBrue1jOi3r+OCkueuoeeQhuOBmeOCi+OBn+OCgeOBruOCguOBruOBp+OBmeOAglxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlwbGVQYXJ0aWNsZVdheXMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbikge1xuICAgICAgICB0aGlzLndheVNlbGVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgTXVsdGlwbGVQYXJ0aWNsZVdheXNPcHRpb24uaW5pdE9wdGlvbihvcHRpb24pO1xuICAgICAgICB0aGlzLndheXMgPSBvcHRpb24ud2F5cztcbiAgICAgICAgdGhpcy53YXlTZWxlY3RUeXBlID0gb3B0aW9uLnR5cGU7XG4gICAgfVxuICAgIGNvdW50VXAoKSB7XG4gICAgICAgIHRoaXMud2F5U2VsZWN0aW9uQ291bnQgPSAodGhpcy53YXlTZWxlY3Rpb25Db3VudCArIDEpICUgdGhpcy53YXlzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0UGFydGljbGVXYXkoKSB7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgc3dpdGNoICh0aGlzLndheVNlbGVjdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzZXF1ZW50aWFsXCI6XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLndheVNlbGVjdGlvbkNvdW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJhbmRvbVwiOlxuICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy53YXlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2F5c1tpbmRleF07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE11bHRpcGxlUGFydGljbGVXYXlzT3B0aW9uIHtcbiAgICBzdGF0aWMgaW5pdE9wdGlvbihvcHRpb24pIHtcbiAgICAgICAgb3B0aW9uID8/PSB7fTtcbiAgICAgICAgb3B0aW9uLndheXMgPz89IFtdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9uLndheXMpKSB7XG4gICAgICAgICAgICBvcHRpb24ud2F5cyA9IFtvcHRpb24ud2F5c107XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uLnR5cGUgPz89IFwic2VxdWVudGlhbFwiO1xuICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbn1cbiIsIi8qKlxuICogUGFydGljbGVHZW5lcmF0b3LjgafliKnnlKjjgZnjgovlkITnqK7jga7lgKTjgpLnrpflh7rjgZnjgovjg5jjg6vjg5Hjg7zjgq/jg6njgrlcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnRpY2xlR2VuZXJhdG9yVXRpbGl0eSB7XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44Gu55Sf5oiQ44Kk44Oz44K/44O844OQ44Or44Go57WM6Lev5LiK44Gu5pWw44GL44KJ44CB56e75YuV6YCf5bqm44KS566X5Ye644GZ44KLXG4gICAgICogQHBhcmFtIGludGVydmFsXG4gICAgICogQHBhcmFtIHBhcnRpY2xlTnVtXG4gICAgICovXG4gICAgc3RhdGljIGdldFNwZWVkKGludGVydmFsLCBwYXJ0aWNsZU51bSkge1xuICAgICAgICByZXR1cm4gKDEuMCAvIChpbnRlcnZhbCAqIHBhcnRpY2xlTnVtKSkgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjga7np7vli5XpgJ/luqbjgajntYzot6/kuIrjga7mlbDjgYvjgonjgIHnlJ/miJDjgqTjg7Pjgr/jg7zjg5Djg6vjgpLnrpflh7rjgZnjgotcbiAgICAgKiBAcGFyYW0gc3BlZWRcbiAgICAgKiBAcGFyYW0gcGFydGljbGVOdW1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SW50ZXJ2YWwoc3BlZWQsIHBhcnRpY2xlTnVtKSB7XG4gICAgICAgIHJldHVybiAoMS4wIC8gc3BlZWQgLyBwYXJ0aWNsZU51bSkgKiAxMDAwO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFBhcnRpY2xlR2VuZXJhdG9yVXRpbGl0eSB9IGZyb20gXCIuL1BhcnRpY2xlR2VuZXJhdG9yVXRpbGl0eS5qc1wiO1xuZXhwb3J0IGNsYXNzIFBhcnRpY2xlQW5pbWF0b3Ige1xuICAgIGdldCBnZW5lcmF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0aW9uSW50ZXJ2YWw7XG4gICAgfVxuICAgIHNldCBnZW5lcmF0aW9uSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dlbmVyYXRpb25JbnRlcnZhbCA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2dlbmVyYXRpb25JbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbW9kZU1hbmFnZXIubW9kZSA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlBhcnRpY2xlR2VuZXJhdG9yIDog44Or44O844OX5oyH5a6a5Lit44Gr44OR44O844OG44Kj44Kv44Or55Sf5oiQ6ZaT6ZqU44KS5YaN6Kit5a6a44GX44Gm44KC5Y+N5pig44GV44KM44G+44Gb44KT44CC6Kit5a6a44KS5Y+N5pig44GZ44KL44Gf44KB44Gr44OR44O844OG44Kj44Kv44Or44KS5YmK6Zmk44GX44Gm5YaN55Sf5oiQ44GX44Gm44GP44Gg44GV44GE44CCXCIpO1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlYXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWFzZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZU1hbmFnZXIsIHBhcnRpY2xlQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRpb25JbnRlcnZhbCA9IDMwMDtcbiAgICAgICAgdGhpcy5zcGVlZFBlclNlYyA9IDAuMDc7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlQ29udGFpbmVyID0gcGFydGljbGVDb250YWluZXI7XG4gICAgICAgIHRoaXMuX21vZGVNYW5hZ2VyID0gbW9kZU1hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOeUn+aIkOOCpOODs+OCv+ODvOODkOODq+OBqOe1jOi3r+S4iuOBruODkeODvOODhuOCo+OCr+ODq+aVsOOBi+OCieenu+WLleOCueODlOODvOODieOCkueul+WHuuOBl+ioreWumuOBmeOCi+OAglxuICAgICAqIGxvb3DmmYLjgavnoLTntrvjgZfjgarjgYTlgKTjgYzlvpfjgonjgozjgovjgIJcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxcbiAgICAgKiBAcGFyYW0gcGFydGljbGVOdW1cbiAgICAgKi9cbiAgICBzZXRTcGVlZChpbnRlcnZhbCwgcGFydGljbGVOdW0pIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGlvbkludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuc3BlZWRQZXJTZWMgPSBQYXJ0aWNsZUdlbmVyYXRvclV0aWxpdHkuZ2V0U3BlZWQoaW50ZXJ2YWwsIHBhcnRpY2xlTnVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog56e75YuV44K544OU44O844OJ44Go57WM6Lev5LiK44Gu44OR44O844OG44Kj44Kv44Or5pWw44GL44KJ55Sf5oiQ44Kk44Oz44K/44O844OQ44Or44KS566X5Ye644GX6Kit5a6a44GZ44KL44CCXG4gICAgICogbG9vcOaZguOBq+egtOe2u+OBl+OBquOBhOWApOOBjOW+l+OCieOCjOOCi+OAglxuICAgICAqIEBwYXJhbSBzcGVlZFxuICAgICAqIEBwYXJhbSBwYXJ0aWNsZU51bVxuICAgICAqL1xuICAgIHNldEdlbmVyYXRpb25JbnRlcnZhbChzcGVlZCwgcGFydGljbGVOdW0pIHtcbiAgICAgICAgdGhpcy5zcGVlZFBlclNlYyA9IHNwZWVkO1xuICAgICAgICB0aGlzLl9nZW5lcmF0aW9uSW50ZXJ2YWwgPSBQYXJ0aWNsZUdlbmVyYXRvclV0aWxpdHkuZ2V0SW50ZXJ2YWwoc3BlZWQsIHBhcnRpY2xlTnVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44Gu5L2N572u44KS57WM6YGO5pmC6ZaT5YiG56e75YuV44GZ44KL44CCXG4gICAgICogQHBhcmFtIGRlbHRhIOWJjeWbnuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOWun+ihjOOBleOCjOOBpuOBi+OCieOBrue1jOmBjuaZgumWkyDljZjkvY1tc1xuICAgICAqL1xuICAgIG1vdmUoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgbW92ZW1lbnQgPSAoZGVsdGEgLyAxMDAwKSAqIHRoaXMuc3BlZWRQZXJTZWM7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlQ29udGFpbmVyLm1vdmUobW92ZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlkITjg5Hjg7zjg4bjgqPjgq/jg6vjga5FYXNl6Zai5pWw44KS5pu05paw44GZ44KL44CCXG4gICAgICogQHBhcmFtIGVhc2Ug44Kk44O844K444Oz44Kw6Zai5pWw44CCXG4gICAgICogQHBhcmFtIG92ZXJyaWRlIOePvuWtmOOBmeOCi+ODkeODvOODhuOCo+OCr+ODq+OBrkVhc2XplqLmlbDjgpLkuIrmm7jjgY3jgZnjgovjgYvlkKbjgYvjgILopo/lrprlgKTjga90cnVl44CCXG4gICAgICovXG4gICAgdXBkYXRlRWFzZShlYXNlLCBvdmVycmlkZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZWFzZSA9IGVhc2U7XG4gICAgICAgIGlmICghb3ZlcnJpZGUgJiYgdGhpcy5fbW9kZU1hbmFnZXIubW9kZSA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlBhcnRpY2xlR2VuZXJhdG9yIDog44Or44O844OX5oyH5a6a5Lit44GrRWFzZemWouaVsOOCkuWGjeioreWumuOBmeOCi+OBqOOAgeaXouWtmOOBruODkeODvOODhuOCo+OCr+ODq+OBrkVhc2XplqLmlbDjga/luLjjgavkuIrmm7jjgY3jgZXjgozjgb7jgZnjgIJcIik7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJyaWRlIHx8IHRoaXMuX21vZGVNYW5hZ2VyLm1vZGUgPT09IFwibG9vcFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZUNvbnRhaW5lci5vdmVycmlkZUVhc2UoZWFzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqIOikh+aVsOOBruODkeODvOODhuOCo+OCr+ODq+OCkuagvOe0jeOAgeenu+WLleOAgeeuoeeQhuOBmeOCi+OBn+OCgeOBruOCr+ODqeOCueOBp+OBmeOAglxuICpcbiAqIOS4u+OBq1BhcnRpY2xlR2VuZXJhdG9y44Gn55Sf5oiQ44GV44KM44Gf44OR44O844OG44Kj44Kv44Or44KS566h55CG44GX44G+44GZ44CCXG4gKiBAc2VlIHtAbGluayBQYXJ0aWNsZUdlbmVyYXRvcn1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnRpY2xlQ29udGFpbmVyIHtcbiAgICBnZXQgcGFydGljbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydGljbGVzO1xuICAgIH1cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfVxuICAgIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGFydGljbGVzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIHAudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIG1vZGVNYW5hZ2VyLm9uKFwiY2hhbmdlXCIsIChtb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44KS5qC857SN44GZ44KL44CCXG4gICAgICogQHBhcmFtIHBhcnRpY2xlXG4gICAgICovXG4gICAgYWRkKHBhcnRpY2xlKSB7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgcGFydGljbGUudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOagvOe0jeOBleOCjOOBn+OBmeOBueOBpuOBruODkeODvOODhuOCo+OCr+ODq+OCkuenu+WLleOBleOBm+OCi+OAglxuICAgICAqIEBzZWUge0BsaW5rIFBhcnRpY2xlLmFkZH1cbiAgICAgKiBAcGFyYW0gdFxuICAgICAqL1xuICAgIG1vdmUodCkge1xuICAgICAgICB0aGlzLl9wYXJ0aWNsZXMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgcC5hZGQodCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlr7/lkb3liIfjgozjga7jg5Hjg7zjg4bjgqPjgq/jg6vjgpLkuIDmi6zjgafliYrpmaTjgZnjgovjgIJcbiAgICAgKi9cbiAgICByZW1vdmVDb21wbGV0ZWRQYXJ0aWNsZXMoKSB7XG4gICAgICAgIC8vcmVtb3ZlIHBhcnRpY2xlc1xuICAgICAgICB0aGlzLl9wYXJ0aWNsZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKHApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwLnJhdGlvID49IDEuMDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdXBkYXRlIHBhcnRpY2xlIGFycmF5XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcyA9IHRoaXMuX3BhcnRpY2xlcy5maWx0ZXIoKHApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwLnJhdGlvIDwgMS4wO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5oyH5a6a44GV44KM44Gf44OR44O844OG44Kj44Kv44Or44KS5YmK6Zmk44GZ44KL44CCXG4gICAgICogQHBhcmFtIHBhcnRpY2xlXG4gICAgICovXG4gICAgcmVtb3ZlKHBhcnRpY2xlKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9wYXJ0aWNsZXMuaW5kZXhPZihwYXJ0aWNsZSk7XG4gICAgICAgIGNvbnN0IHBvcHBlZCA9IHRoaXMuX3BhcnRpY2xlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHBvcHBlZC5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDmoLzntI3jgZXjgozjgZ/jgZnjgbnjgabjga7jg5Hjg7zjg4bjgqPjgq/jg6vjgpLliYrpmaTjgZnjgovjgIJcbiAgICAgKi9cbiAgICByZW1vdmVBbGwoKSB7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDntYLnq6/jgavjgZ/jganjgornnYDjgYTjgZ/jg5Hjg7zjg4bjgqPjgq/jg6vjgpLlp4vngrnjgavlt7vjgY3miLvjgZnjgIJcbiAgICAgKi9cbiAgICByb2xsdXBQYXJ0aWNsZXMoKSB7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLnVwZGF0ZShwLnJhdGlvICUgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvdmVycmlkZUVhc2UoZWFzZSkge1xuICAgICAgICB0aGlzLl9wYXJ0aWNsZXMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgcC5lYXNlID0gZWFzZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKiDjg5Hjg7zjg4bjgqPjgq/jg6vmlrDopo/nlJ/miJDjga7jg5Djg6vjg5bplovplonjgpLooYzjgYbjgq/jg6njgrlcbiAqIEBzZWUge0BsaW5rIFBhcnRpY2xlR2VuZXJhdG9yfVxuICovXG5leHBvcnQgY2xhc3MgUGFydGljbGVWYWx2ZSB7XG4gICAgZ2V0IGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZU1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5faXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbW9kZU1hbmFnZXIgPSBtb2RlTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or55Sf5oiQ44KS6ZaL5aeL44GZ44KL44CCXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzT3BlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YXJuVXBkYXRlVmFsdmVNb2RlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+eUn+aIkOOCkuWBnOatouOBmeOCi+OAglxuICAgICAqIOOCouODi+ODoeODvOOCt+ODp+ODs+OBr+e2muihjOOBleOCjOOCi+OAglxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzT3BlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FyblVwZGF0ZVZhbHZlTW9kZSgpO1xuICAgIH1cbiAgICB3YXJuVXBkYXRlVmFsdmVNb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5fbW9kZU1hbmFnZXIubW9kZSAhPT0gXCJsb29wXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUud2FybihcIlBhcnRpY2xlR2VuZXJhdG9yIDog44Or44O844OX5oyH5a6a5Lit44Gr44OQ44Or44OW6ZaL6ZaJ5pON5L2c44KS6KGM44GE44G+44GX44Gf44CC44GT44Gu5pON5L2c44Gv44Or44O844OX5oyH5a6a5Lit44Gr44Gv5Y+N5pig44GV44KM44G+44Gb44KT44CCXCIpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUkFGVGlja2VyIH0gZnJvbSBcIkBtYXNhdG9tYWtpbm8vcmFmLXRpY2tlclwiO1xuaW1wb3J0IHsgUGFydGljbGUgfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IEdlbmVyYXRpb25Nb2RlTWFuYWdlciwgfSBmcm9tIFwiLi9HZW5lcmF0aW9uTW9kZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IE11bHRpcGxlUGFydGljbGVXYXlzIH0gZnJvbSBcIi4vTXVsdGlwbGVQYXJ0aWNsZVdheXMuanNcIjtcbmltcG9ydCB7IFBhcnRpY2xlQW5pbWF0b3IgfSBmcm9tIFwiLi9QYXJ0aWNsZUFuaW1hdG9yLmpzXCI7XG5pbXBvcnQgeyBQYXJ0aWNsZUNvbnRhaW5lciB9IGZyb20gXCIuL1BhcnRpY2xlQ29udGFpbmVyLmpzXCI7XG5pbXBvcnQgeyBQYXJ0aWNsZVZhbHZlIH0gZnJvbSBcIi4vUGFydGljbGVWYWx2ZS5qc1wiO1xuLyoqXG4gKiDkuIDlrprplpPpmpTjgafjg5Hjg7zjg4bjgqPjgq/jg6vjgpLnlJ/miJDjgZfjgIHjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgZXjgZvjgovjgq/jg6njgrnjgIJcbiAqIOODkeODvOODhuOCo+OCr+ODq+OCpOODs+OCueOCv+ODs+OCueOBrueUn+aIkOOBqOeuoeeQhuOCkuihjOOBhuOAglxuICovXG5leHBvcnQgY2xhc3MgUGFydGljbGVHZW5lcmF0b3Ige1xuICAgIGdldCBpc1BsYXlpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOOCs+ODs+OCueODiOODqeOCr+OCv1xuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICogQHBhcmFtIG9wdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIG9wdGlvbikge1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWJjeWbnuODkeODvOODhuOCo+OCr+ODq+eUn+aIkOaZguOBi+OCieOBrue1jOmBjuaZgumWkyDljZjkvY1tc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFwc2VkRnJvbUdlbmVyYXRlID0gMDtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICog44OR44O844OG44Kj44Kv44Or44KS44Ki44OL44Oh44O844K344On44Oz44GV44Gb44KL44CCXG4gICAgICAgICAqIEBwYXJhbSBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRvci5tb3ZlKGUuZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZUNvbnRhaW5lci5yZW1vdmVDb21wbGV0ZWRQYXJ0aWNsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGFydGljbGUoZS5kZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjgpLjg6vjg7zjg5fjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgZXjgZvjgovjgIJcbiAgICAgICAgICogQHBhcmFtIGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9vcCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZUNvbnRhaW5lci5wYXJ0aWNsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmltYXRvci5tb3ZlKGUuZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZUNvbnRhaW5lci5yb2xsdXBQYXJ0aWNsZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlTWFuYWdlciA9IG5ldyBHZW5lcmF0aW9uTW9kZU1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZVdheXMgPSBuZXcgTXVsdGlwbGVQYXJ0aWNsZVdheXMoeyB3YXlzOiBwYXRoIH0pO1xuICAgICAgICB0aGlzLnBhcnRpY2xlQ29udGFpbmVyID0gbmV3IFBhcnRpY2xlQ29udGFpbmVyKHRoaXMubW9kZU1hbmFnZXIpO1xuICAgICAgICB0aGlzLnZhbHZlID0gbmV3IFBhcnRpY2xlVmFsdmUodGhpcy5tb2RlTWFuYWdlcik7XG4gICAgICAgIHRoaXMuYW5pbWF0b3IgPSBuZXcgUGFydGljbGVBbmltYXRvcih0aGlzLm1vZGVNYW5hZ2VyLCB0aGlzLnBhcnRpY2xlQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5tb2RlTWFuYWdlci5vbihcImNoYW5nZVwiLCAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb24gPSBQYXJ0aWNsZUdlbmVyYXRvck9wdGlvbi5pbml0T3B0aW9uKG9wdGlvbik7XG4gICAgICAgIHRoaXMubW9kZU1hbmFnZXIubW9kZSA9IG9wdGlvbi5nZW5lcmF0aW9uTW9kZTtcbiAgICAgICAgdGhpcy5hbmltYXRvci51cGRhdGVFYXNlKG9wdGlvbi5lYXNlKTtcbiAgICAgICAgdGhpcy5wcm9iYWJpbGl0eSA9IG9wdGlvbi5wcm9iYWJpbGl0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44Ki44OL44Oh44O844K344On44Oz44KS6ZaL5aeL44GZ44KL44CCXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVNYW5hZ2VyLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICAgICAgUkFGVGlja2VyLmFkZExpc3RlbmVyKFwidGlja1wiLCB0aGlzLmxvb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNlcXVlbnRpYWxcIjpcbiAgICAgICAgICAgICAgICBSQUZUaWNrZXIuYWRkTGlzdGVuZXIoXCJ0aWNrXCIsIHRoaXMuYW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44Ki44OL44Oh44O844K344On44Oz44KS5YGc5q2i44GZ44KL44CCXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICBSQUZUaWNrZXIucmVtb3ZlTGlzdGVuZXIoXCJ0aWNrXCIsIHRoaXMubG9vcCk7XG4gICAgICAgIFJBRlRpY2tlci5yZW1vdmVMaXN0ZW5lcihcInRpY2tcIiwgdGhpcy5hbmltYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44Ki44OL44Oh44O844K344On44Oz44Gr5Ly044GE44CB5paw6KaP44OR44O844OG44Kj44Kv44Or44KS6L+95Yqg44GZ44KL44CCXG4gICAgICogQHBhcmFtIGRlbHRhXG4gICAgICovXG4gICAgYWRkUGFydGljbGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHZlLmlzT3BlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYW5pbSA9IHRoaXMuYW5pbWF0b3I7XG4gICAgICAgIHRoaXMuZWxhcHNlZEZyb21HZW5lcmF0ZSArPSBkZWx0YTtcbiAgICAgICAgd2hpbGUgKHRoaXMuZWxhcHNlZEZyb21HZW5lcmF0ZSA+IGFuaW0uZ2VuZXJhdGlvbkludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRGcm9tR2VuZXJhdGUgLT0gYW5pbS5nZW5lcmF0aW9uSW50ZXJ2YWw7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gKHRoaXMuZWxhcHNlZEZyb21HZW5lcmF0ZSAqIGFuaW0uc3BlZWRQZXJTZWMpIC8gMTAwMDtcbiAgICAgICAgICAgIC8v44GZ44Gn44Gr5a+/5ZG95YiH44KM44Gu44OR44O844OG44Kj44Kv44Or44Gv55Sf5oiQ44KS44K544Kt44OD44OX44CCXG4gICAgICAgICAgICBpZiAobW92ZSA+IFBhcnRpY2xlLk1BWF9SQVRJTykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLmdlbmVyYXRlKCk7XG4gICAgICAgICAgICBwYXJ0aWNsZT8uYWRkKG1vdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+OCkjHjgaTov73liqDjgZnjgovjgIJcbiAgICAgKi9cbiAgICBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBsZVdheXMuY291bnRVcCgpO1xuICAgICAgICAvL+eZuueUn+eiuueOh+OBq+W/nOOBmOOBpueUn+aIkOOBruWPr+WQpuOCkuWIpOWumuOBmeOCi+OAglxuICAgICAgICBpZiAodGhpcy5wcm9iYWJpbGl0eSAhPT0gMS4wKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IHRoaXMucHJvYmFiaWxpdHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMubXVsdGlwbGVXYXlzLmdldFBhcnRpY2xlV2F5KCk7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5nZW5lcmF0ZVBhcnRpY2xlKHBhdGgpO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRvci5lYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLmVhc2UgPSB0aGlzLmFuaW1hdG9yLmVhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0aWNsZUNvbnRhaW5lci5hZGQocGFydGljbGUpO1xuICAgICAgICByZXR1cm4gcGFydGljbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+OCkueUn+aIkOOBmeOCi+OAglxuICAgICAqIGdlbmVyYXRl6Zai5pWw44Gu5YaF6YOo5Yem55CG44CCXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVBhcnRpY2xlKHBhdGgpIHtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSBuZXcgUGFydGljbGUocGF0aCk7XG4gICAgICAgIC8vVE9ETyDjgZPjgZPjgafjgrPjg7Pjg4bjg4rjgavmjL/lhaXjgIJcbiAgICAgICAgcmV0dXJuIHBhcnRpY2xlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDntYzot6/kuIrjgavjg5Hjg7zjg4bjgqPjgq/jg6vjgpLmlbfjgY3oqbDjgoHjgovjgIJcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFsbCgpIHtcbiAgICAgICAgLy/jg5Hjg7zjg4bjgqPjgq/jg6vjga7mnIDlpKfnlJ/lrZjmnJ/plpMg5Y2Y5L2N44Of44Oq56eSXG4gICAgICAgIGxldCBsaWZlVGltZSA9IDEwMDAuMCAvIHRoaXMuYW5pbWF0b3Iuc3BlZWRQZXJTZWM7XG4gICAgICAgIHdoaWxlIChsaWZlVGltZSA+IDAuMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLmdlbmVyYXRlKCk7XG4gICAgICAgICAgICBpZiAocGFydGljbGUpXG4gICAgICAgICAgICAgICAgcGFydGljbGUudXBkYXRlKChsaWZlVGltZSAvIDEwMDApICogdGhpcy5hbmltYXRvci5zcGVlZFBlclNlYyk7XG4gICAgICAgICAgICBsaWZlVGltZSAtPSB0aGlzLmFuaW1hdG9yLmdlbmVyYXRpb25JbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsYXBzZWRGcm9tR2VuZXJhdGUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vnlJ/miJDjga7lgZzmraLjgajjg5Hjg7zjg4bjgqPjgq/jg6vjga7noLTmo4TjgpLooYzjgYbjgIJcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucGFydGljbGVDb250YWluZXIucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRoaXMucGFydGljbGVDb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm11bHRpcGxlV2F5cyA9IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiDjg5Hjg7zjg4bjgqPjgq/jg6vnlJ/miJDmlrnms5XjgpLmjIflrprjgZnjgovjgqrjg5fjgrfjg6fjg7NcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnRpY2xlR2VuZXJhdG9yT3B0aW9uIHtcbiAgICBzdGF0aWMgaW5pdE9wdGlvbihvcHRpb24pIHtcbiAgICAgICAgb3B0aW9uID8/PSB7fTtcbiAgICAgICAgb3B0aW9uLmdlbmVyYXRpb25Nb2RlID8/PSBcInNlcXVlbnRpYWxcIjtcbiAgICAgICAgb3B0aW9uLnByb2JhYmlsaXR5ID8/PSAxLjA7XG4gICAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vUGFydGljbGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1BhcnRpY2xlV2F5LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CZXppZXJVdGlsLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9nZW5lcmF0b3IvUGFydGljbGVHZW5lcmF0b3IuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2dlbmVyYXRvci9NdWx0aXBsZVBhcnRpY2xlV2F5cy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZ2VuZXJhdG9yL1BhcnRpY2xlQ29udGFpbmVyLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9nZW5lcmF0b3IvR2VuZXJhdGlvbk1vZGVNYW5hZ2VyLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///754\n')},984:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZP: () => (/* binding */ exports)\n/* harmony export */ });\n/* unused harmony exports Easing, Group, Interpolation, Sequence, Tween, VERSION, add, getAll, nextId, now, remove, removeAll, update */\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = Object.freeze({\n    Linear: Object.freeze({\n        None: function (amount) {\n            return amount;\n        },\n        In: function (amount) {\n            return this.None(amount);\n        },\n        Out: function (amount) {\n            return this.None(amount);\n        },\n        InOut: function (amount) {\n            return this.None(amount);\n        },\n    }),\n    Quadratic: Object.freeze({\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    }),\n    Cubic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    }),\n    Quartic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    }),\n    Quintic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    }),\n    Sinusoidal: Object.freeze({\n        In: function (amount) {\n            return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n        },\n    }),\n    Exponential: Object.freeze({\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    }),\n    Circular: Object.freeze({\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    }),\n    Elastic: Object.freeze({\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    }),\n    Back: Object.freeze({\n        In: function (amount) {\n            var s = 1.70158;\n            return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    }),\n    Bounce: Object.freeze({\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    }),\n    generatePow: function (power) {\n        if (power === void 0) { power = 4; }\n        power = power < Number.EPSILON ? Number.EPSILON : power;\n        power = power > 10000 ? 10000 : power;\n        return {\n            In: function (amount) {\n                return Math.pow(amount, power);\n            },\n            Out: function (amount) {\n                return 1 - Math.pow((1 - amount), power);\n            },\n            InOut: function (amount) {\n                if (amount < 0.5) {\n                    return Math.pow((amount * 2), power) / 2;\n                }\n                return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;\n            },\n        };\n    },\n});\n\nvar now = function () { return performance.now(); };\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) {\n            return _this._tweens[tweenId];\n        });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function (tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    };\n    Group.prototype.remove = function (tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now(); }\n        if (preserve === void 0) { preserve = false; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0) {\n            return false;\n        }\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve) {\n                    delete this._tweens[tweenIds[i]];\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(_object, _group) {\n        if (_group === void 0) { _group = mainGroup; }\n        this._object = _object;\n        this._group = _group;\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._isDynamic = false;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        // eslint-disable-next-line\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._onEveryStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._propertiesAreSetUp = false;\n        this._goToEnd = false;\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.to = function (target, duration) {\n        if (duration === void 0) { duration = 1000; }\n        if (this._isPlaying)\n            throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');\n        this._valuesEnd = target;\n        this._propertiesAreSetUp = false;\n        this._duration = duration;\n        return this;\n    };\n    Tween.prototype.duration = function (duration) {\n        if (duration === void 0) { duration = 1000; }\n        this._duration = duration;\n        return this;\n    };\n    Tween.prototype.dynamic = function (dynamic) {\n        if (dynamic === void 0) { dynamic = false; }\n        this._isDynamic = dynamic;\n        return this;\n    };\n    Tween.prototype.start = function (time, overrideStartingValues) {\n        if (time === void 0) { time = now(); }\n        if (overrideStartingValues === void 0) { overrideStartingValues = false; }\n        if (this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._onEveryStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time;\n        this._startTime += this._delayTime;\n        if (!this._propertiesAreSetUp || overrideStartingValues) {\n            this._propertiesAreSetUp = true;\n            // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\n            if (!this._isDynamic) {\n                var tmp = {};\n                for (var prop in this._valuesEnd)\n                    tmp[prop] = this._valuesEnd[prop];\n                this._valuesEnd = tmp;\n            }\n            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);\n        }\n        return this;\n    };\n    Tween.prototype.startFromCurrentValues = function (time) {\n        return this.start(time, true);\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // Handle an array of relative values.\n                // Creates a local copy of the Array with the start value at the front\n                var temp = [startValue];\n                for (var i = 0, l = endValues.length; i < l; i += 1) {\n                    var value = this._handleRelativeValue(startValue, endValues[i]);\n                    if (isNaN(value)) {\n                        isInterpolationList = false;\n                        console.warn('Found invalid interpolation list. Skipping.');\n                        break;\n                    }\n                    temp.push(value);\n                }\n                if (isInterpolationList) {\n                    // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.\n                    _valuesEnd[property] = temp;\n                    // }\n                }\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                var nestedObject = startValue;\n                for (var prop in nestedObject) {\n                    _valuesStart[property][prop] = nestedObject[prop];\n                }\n                // TODO? repeat nested values? And yoyo? And array values?\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {};\n                var endValues = _valuesEnd[property];\n                // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\n                if (!this._isDynamic) {\n                    var tmp = {};\n                    for (var prop in endValues)\n                        tmp[prop] = endValues[prop];\n                    _valuesEnd[property] = endValues = tmp;\n                }\n                this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);\n            }\n            else {\n                // Save the starting value, but only once unless override is requested.\n                if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(Infinity);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        if (group === void 0) { group = mainGroup; }\n        this._group = group;\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        if (amount === void 0) { amount = 0; }\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        if (times === void 0) { times = 0; }\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        if (yoyo === void 0) { yoyo = false; }\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    // eslint-disable-next-line\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onEveryStart = function (callback) {\n        this._onEveryStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        if (time === void 0) { time = now(); }\n        if (autoStart === void 0) { autoStart = true; }\n        if (this._isPaused)\n            return true;\n        var property;\n        var elapsed;\n        var endTime = this._startTime + this._duration;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (time > endTime)\n                return false;\n            if (autoStart)\n                this.start(time, true);\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        if (this._onEveryStartCallbackFired === false) {\n            if (this._onEveryStartCallback) {\n                this._onEveryStartCallback(this._object);\n            }\n            this._onEveryStartCallbackFired = true;\n        }\n        elapsed = (time - this._startTime) / this._duration;\n        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (elapsed === 1) {\n            if (this._repeat > 0) {\n                if (isFinite(this._repeat)) {\n                    this._repeat--;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                if (this._repeatDelayTime !== undefined) {\n                    this._startTime = time + this._repeatDelayTime;\n                }\n                else {\n                    this._startTime = time + this._delayTime;\n                }\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                this._onEveryStartCallbackFired = false;\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration, false);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        return parseFloat(end);\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    return Tween;\n}());\n\nvar VERSION = '20.0.3';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nvar add = TWEEN.add.bind(TWEEN);\nvar remove = TWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nvar exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    getAll: getAll,\n    removeAll: removeAll,\n    add: add,\n    remove: remove,\n    update: update,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanM/MTA4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0d2Vlbi5qcy5cbiAqL1xudmFyIEVhc2luZyA9IE9iamVjdC5mcmVlemUoe1xuICAgIExpbmVhcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE5vbmU6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Ob25lKGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTm9uZShhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTm9uZShhbW91bnQpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFF1YWRyYXRpYzogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiAoMiAtIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1hbW91bnQgKiAoYW1vdW50IC0gMikgLSAxKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBDdWJpYzogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogYW1vdW50ICsgMik7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgUXVhcnRpYzogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAtIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFF1aW50aWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFNpbnVzb2lkYWw6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNpbigoKDEuMCAtIGFtb3VudCkgKiBNYXRoLlBJKSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbigoYW1vdW50ICogTWF0aC5QSSkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguc2luKE1hdGguUEkgKiAoMC41IC0gYW1vdW50KSkpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEV4cG9uZW50aWFsOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgYW1vdW50IC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBDaXJjdWxhcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWFtb3VudCAqIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGFtb3VudCAqIGFtb3VudCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoYW1vdW50IC09IDIpICogYW1vdW50KSArIDEpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEVsYXN0aWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KSAqIE1hdGguc2luKChhbW91bnQgLSAwLjEpICogNSAqIE1hdGguUEkpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFtb3VudCAqPSAyO1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIE1hdGgucG93KDIsIDEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgQmFjazogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAxID8gMSA6IGFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50IC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IDAgOiAtLWFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50IC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoYW1vdW50IC09IDIpICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgKyBzKSArIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEJvdW5jZTogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2UuT3V0KDEgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDEuNSAvIDIuNzUpICogYW1vdW50ICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFtb3VudCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjI1IC8gMi43NSkgKiBhbW91bnQgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAyLjYyNSAvIDIuNzUpICogYW1vdW50ICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuSW4oYW1vdW50ICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRWFzaW5nLkJvdW5jZS5PdXQoYW1vdW50ICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIGdlbmVyYXRlUG93OiBmdW5jdGlvbiAocG93ZXIpIHtcbiAgICAgICAgaWYgKHBvd2VyID09PSB2b2lkIDApIHsgcG93ZXIgPSA0OyB9XG4gICAgICAgIHBvd2VyID0gcG93ZXIgPCBOdW1iZXIuRVBTSUxPTiA/IE51bWJlci5FUFNJTE9OIDogcG93ZXI7XG4gICAgICAgIHBvd2VyID0gcG93ZXIgPiAxMDAwMCA/IDEwMDAwIDogcG93ZXI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhhbW91bnQsIHBvd2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAtIE1hdGgucG93KCgxIC0gYW1vdW50KSwgcG93ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFtb3VudCA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coKGFtb3VudCAqIDIpLCBwb3dlcikgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDEgLSBNYXRoLnBvdygoMiAtIGFtb3VudCAqIDIpLCBwb3dlcikpIC8gMiArIDAuNTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG52YXIgbm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG5cbi8qKlxuICogQ29udHJvbGxpbmcgZ3JvdXBzIG9mIHR3ZWVuc1xuICpcbiAqIFVzaW5nIHRoZSBUV0VFTiBzaW5nbGV0b24gdG8gbWFuYWdlIHlvdXIgdHdlZW5zIGNhbiBjYXVzZSBpc3N1ZXMgaW4gbGFyZ2UgYXBwcyB3aXRoIG1hbnkgY29tcG9uZW50cy5cbiAqIEluIHRoZXNlIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gY3JlYXRlIHlvdXIgb3duIHNtYWxsZXIgZ3JvdXBzIG9mIHR3ZWVuXG4gKi9cbnZhciBHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm91cCgpIHtcbiAgICAgICAgdGhpcy5fdHdlZW5zID0ge307XG4gICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG4gICAgfVxuICAgIEdyb3VwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnMpLm1hcChmdW5jdGlvbiAodHdlZW5JZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl90d2VlbnNbdHdlZW5JZF07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdHdlZW5zID0ge307XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVuc1t0d2Vlbi5nZXRJZCgpXSA9IHR3ZWVuO1xuICAgICAgICB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZVt0d2Vlbi5nZXRJZCgpXSA9IHR3ZWVuO1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICBkZWxldGUgdGhpcy5fdHdlZW5zW3R3ZWVuLmdldElkKCldO1xuICAgICAgICBkZWxldGUgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV07XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRpbWUsIHByZXNlcnZlKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZSA9PT0gdm9pZCAwKSB7IHByZXNlcnZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKTtcbiAgICAgICAgaWYgKHR3ZWVuSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR3ZWVucyBhcmUgdXBkYXRlZCBpbiBcImJhdGNoZXNcIi4gSWYgeW91IGFkZCBhIG5ldyB0d2VlbiBkdXJpbmcgYW5cbiAgICAgICAgLy8gdXBkYXRlLCB0aGVuIHRoZSBuZXcgdHdlZW4gd2lsbCBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IGJhdGNoLlxuICAgICAgICAvLyBJZiB5b3UgcmVtb3ZlIGEgdHdlZW4gZHVyaW5nIGFuIHVwZGF0ZSwgaXQgbWF5IG9yIG1heSBub3QgYmUgdXBkYXRlZC5cbiAgICAgICAgLy8gSG93ZXZlciwgaWYgdGhlIHJlbW92ZWQgdHdlZW4gd2FzIGFkZGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCxcbiAgICAgICAgLy8gdGhlbiBpdCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgICAgICB3aGlsZSAodHdlZW5JZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgICAgICAgIHZhciBhdXRvU3RhcnQgPSAhcHJlc2VydmU7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuICYmIHR3ZWVuLnVwZGF0ZSh0aW1lLCBhdXRvU3RhcnQpID09PSBmYWxzZSAmJiAhcHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHdlZW5JZHMgPSBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXA7XG59KCkpO1xuXG4vKipcbiAqXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uID0ge1xuICAgIExpbmVhcjogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmID0gbSAqIGs7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGZuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5MaW5lYXI7XG4gICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZbMF0sIHZbMV0sIGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKHZbaV0sIHZbaSArIDEgPiBtID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xuICAgIH0sXG4gICAgQmV6aWVyOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcHcgPSBNYXRoLnBvdztcbiAgICAgICAgdmFyIGJuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgYiArPSBwdygxIC0gaywgbiAtIGkpICogcHcoaywgaSkgKiB2W2ldICogYm4obiwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfSxcbiAgICBDYXRtdWxsUm9tOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGYgPSBtICogaztcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuICAgICAgICB2YXIgZm4gPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG4gICAgICAgIGlmICh2WzBdID09PSB2W21dKSB7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICBpID0gTWF0aC5mbG9vcigoZiA9IG0gKiAoMSArIGspKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2WzBdIC0gKGZuKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbbV0gLSAoZm4odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbih2W2kgPyBpIC0gMSA6IDBdLCB2W2ldLCB2W20gPCBpICsgMSA/IG0gOiBpICsgMV0sIHZbbSA8IGkgKyAyID8gbSA6IGkgKyAyXSwgZiAtIGkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBVdGlsczoge1xuICAgICAgICBMaW5lYXI6IGZ1bmN0aW9uIChwMCwgcDEsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgICAgIH0sXG4gICAgICAgIEJlcm5zdGVpbjogZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBmYyA9IEludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuICAgICAgICAgICAgcmV0dXJuIGZjKG4pIC8gZmMoaSkgLyBmYyhuIC0gaSk7XG4gICAgICAgIH0sXG4gICAgICAgIEZhY3RvcmlhbDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChhW25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhW25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IDE7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBzICo9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFbbl0gPSBzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcbiAgICAgICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgICAgICAgIHZhciB0MyA9IHQgKiB0MjtcbiAgICAgICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG52YXIgU2VxdWVuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2UoKSB7XG4gICAgfVxuICAgIFNlcXVlbmNlLm5leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNlcXVlbmNlLl9uZXh0SWQrKztcbiAgICB9O1xuICAgIFNlcXVlbmNlLl9uZXh0SWQgPSAwO1xuICAgIHJldHVybiBTZXF1ZW5jZTtcbn0oKSk7XG5cbnZhciBtYWluR3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuLyoqXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gKiBUaGFuayB5b3UgYWxsLCB5b3UncmUgYXdlc29tZSFcbiAqL1xudmFyIFR3ZWVuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR3ZWVuKF9vYmplY3QsIF9ncm91cCkge1xuICAgICAgICBpZiAoX2dyb3VwID09PSB2b2lkIDApIHsgX2dyb3VwID0gbWFpbkdyb3VwOyB9XG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gX2dyb3VwO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnQgPSB7fTtcbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0ID0ge307XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMDtcbiAgICAgICAgdGhpcy5faXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl95b3lvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IEVhc2luZy5MaW5lYXIuTm9uZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gSW50ZXJwb2xhdGlvbi5MaW5lYXI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gW107XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSBTZXF1ZW5jZS5uZXh0SWQoKTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0FyZVNldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSBmYWxzZTtcbiAgICB9XG4gICAgVHdlZW4ucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkgeyBkdXJhdGlvbiA9IDEwMDA7IH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBjYWxsIFR3ZWVuLnRvKCkgd2hpbGUgVHdlZW4gaXMgYWxyZWFkeSBzdGFydGVkIG9yIHBhdXNlZC4gU3RvcCB0aGUgVHdlZW4gZmlyc3QuJyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0FyZVNldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7IGR1cmF0aW9uID0gMTAwMDsgfVxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5keW5hbWljID0gZnVuY3Rpb24gKGR5bmFtaWMpIHtcbiAgICAgICAgaWYgKGR5bmFtaWMgPT09IHZvaWQgMCkgeyBkeW5hbWljID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5faXNEeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxuICAgICAgICBpZiAob3ZlcnJpZGVTdGFydGluZ1ZhbHVlcyA9PT0gdm9pZCAwKSB7IG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aGlzLl9pbml0aWFsUmVwZWF0O1xuICAgICAgICBpZiAodGhpcy5fcmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgcmV2ZXJzZWQgKGYuZS4gdXNpbmcgdGhlIHlveW8gZmVhdHVyZSkgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSB0d2VlbiBkaXJlY3Rpb24gYmFjayB0byBmb3J3YXJkLlxuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGhpcy5fZGVsYXlUaW1lO1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXNBcmVTZXRVcCB8fCBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzQXJlU2V0VXAgPSB0cnVlO1xuICAgICAgICAgICAgLy8gSWYgZHluYW1pYyBpcyBub3QgZW5hYmxlZCwgY2xvbmUgdGhlIGVuZCB2YWx1ZXMgaW5zdGVhZCBvZiB1c2luZyB0aGUgcGFzc2VkLWluIGVuZCB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzRHluYW1pYykge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3ZhbHVlc0VuZClcbiAgICAgICAgICAgICAgICAgICAgdG1wW3Byb3BdID0gdGhpcy5fdmFsdWVzRW5kW3Byb3BdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldHVwUHJvcGVydGllcyh0aGlzLl9vYmplY3QsIHRoaXMuX3ZhbHVlc1N0YXJ0LCB0aGlzLl92YWx1ZXNFbmQsIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0LCBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdGFydEZyb21DdXJyZW50VmFsdWVzID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQodGltZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3NldHVwUHJvcGVydGllcyA9IGZ1bmN0aW9uIChfb2JqZWN0LCBfdmFsdWVzU3RhcnQsIF92YWx1ZXNFbmQsIF92YWx1ZXNTdGFydFJlcGVhdCwgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IF9vYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWVJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBwcm9wVHlwZSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gJ2FycmF5JyA6IHR5cGVvZiBzdGFydFZhbHVlO1xuICAgICAgICAgICAgdmFyIGlzSW50ZXJwb2xhdGlvbkxpc3QgPSAhc3RhcnRWYWx1ZUlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShfdmFsdWVzRW5kW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAvLyBJZiBgdG8oKWAgc3BlY2lmaWVzIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0LFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIG5vdCBzZXQgdGhhdCBwcm9wZXJ0eSBpbiB0aGUgb2JqZWN0XG4gICAgICAgICAgICBpZiAocHJvcFR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBBcnJheSB3YXMgcHJvdmlkZWQgYXMgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFZhbHVlcyA9IF92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmIChlbmRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYW4gYXJyYXkgb2YgcmVsYXRpdmUgdmFsdWVzLlxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZXMgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtzdGFydFZhbHVlXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVuZFZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZShzdGFydFZhbHVlLCBlbmRWYWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludGVycG9sYXRpb25MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvdW5kIGludmFsaWQgaW50ZXJwb2xhdGlvbiBsaXN0LiBTa2lwcGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHsgLy8gaGFuZGxlIGVuZCB2YWx1ZXMgb25seSB0aGUgZmlyc3QgdGltZS4gTk9UIE5FRURFRD8gc2V0dXBQcm9wZXJ0aWVzIGlzIG5vdyBndWFyZGVkIGJ5IF9wcm9wZXJ0aWVzQXJlU2V0VXAuXG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNFbmRbcHJvcGVydHldID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgZGVlcG5lc3Mgb2YgdGhlIHZhbHVlc1xuICAgICAgICAgICAgaWYgKChwcm9wVHlwZSA9PT0gJ29iamVjdCcgfHwgc3RhcnRWYWx1ZUlzQXJyYXkpICYmIHN0YXJ0VmFsdWUgJiYgIWlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRPYmplY3QgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbmVzdGVkT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV1bcHJvcF0gPSBuZXN0ZWRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8/IHJlcGVhdCBuZXN0ZWQgdmFsdWVzPyBBbmQgeW95bz8gQW5kIGFycmF5IHZhbHVlcz9cbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgIHZhciBlbmRWYWx1ZXMgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAvLyBJZiBkeW5hbWljIGlzIG5vdCBlbmFibGVkLCBjbG9uZSB0aGUgZW5kIHZhbHVlcyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXNzZWQtaW4gZW5kIHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZW5kVmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wW3Byb3BdID0gZW5kVmFsdWVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzRW5kW3Byb3BlcnR5XSA9IGVuZFZhbHVlcyA9IHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBQcm9wZXJ0aWVzKG5lc3RlZE9iamVjdCwgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSwgZW5kVmFsdWVzLCBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldLCBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHN0YXJ0aW5nIHZhbHVlLCBidXQgb25seSBvbmNlIHVubGVzcyBvdmVycmlkZSBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSAndW5kZWZpbmVkJyB8fCBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldICo9IDEuMDsgLy8gRW5zdXJlcyB3ZSdyZSB1c2luZyBudW1iZXJzLCBub3Qgc3RyaW5nc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNFbmRbcHJvcGVydHldLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhaW5TdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NoYWluU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0b3BDaGFpbmVkVHdlZW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fb25TdG9wQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9nb1RvRW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoSW5maW5pdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSB0aW1lO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSArPSB0aW1lIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5hZGQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnN0b3BDaGFpbmVkVHdlZW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IHRoaXMuX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zW2ldLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICBpZiAoZ3JvdXAgPT09IHZvaWQgMCkgeyBncm91cCA9IG1haW5Hcm91cDsgfVxuICAgICAgICB0aGlzLl9ncm91cCA9IGdyb3VwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7IGFtb3VudCA9IDA7IH1cbiAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gYW1vdW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgaWYgKHRpbWVzID09PSB2b2lkIDApIHsgdGltZXMgPSAwOyB9XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSB0aW1lcztcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGltZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICB0aGlzLl9yZXBlYXREZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnlveW8gPSBmdW5jdGlvbiAoeW95bykge1xuICAgICAgICBpZiAoeW95byA9PT0gdm9pZCAwKSB7IHlveW8gPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLl95b3lvID0geW95bztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZWFzaW5nID0gZnVuY3Rpb24gKGVhc2luZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChlYXNpbmdGdW5jdGlvbiA9PT0gdm9pZCAwKSB7IGVhc2luZ0Z1bmN0aW9uID0gRWFzaW5nLkxpbmVhci5Ob25lOyB9XG4gICAgICAgIHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uRnVuY3Rpb24gPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBJbnRlcnBvbGF0aW9uLkxpbmVhcjsgfVxuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgVHdlZW4ucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHdlZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0d2VlbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gdHdlZW5zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vbkV2ZXJ5U3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblJlcGVhdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vblJlcGVhdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHR3ZWVuIGlzIHN0aWxsIHBsYXlpbmcgYWZ0ZXIgdGhlIHVwZGF0ZSwgZmFsc2VcbiAgICAgKiBvdGhlcndpc2UgKGNhbGxpbmcgdXBkYXRlIG9uIGEgcGF1c2VkIHR3ZWVuIHN0aWxsIHJldHVybnMgdHJ1ZSBiZWNhdXNlXG4gICAgICogaXQgaXMgc3RpbGwgcGxheWluZywganVzdCBwYXVzZWQpLlxuICAgICAqL1xuICAgIFR3ZWVuLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGltZSwgYXV0b1N0YXJ0KSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XG4gICAgICAgIGlmIChhdXRvU3RhcnQgPT09IHZvaWQgMCkgeyBhdXRvU3RhcnQgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgcHJvcGVydHk7XG4gICAgICAgIHZhciBlbGFwc2VkO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuX2dvVG9FbmQgJiYgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiBlbmRUaW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRvU3RhcnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCh0aW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxhcHNlZCA9ICh0aW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBlbGFwc2VkID0gdGhpcy5fZHVyYXRpb24gPT09IDAgfHwgZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZWFzaW5nRnVuY3Rpb24oZWxhcHNlZCk7XG4gICAgICAgIC8vIHByb3BlcnRpZXMgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXModGhpcy5fb2JqZWN0LCB0aGlzLl92YWx1ZXNTdGFydCwgdGhpcy5fdmFsdWVzRW5kLCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCwgZWxhcHNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsYXBzZWQgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHRoaXMuX3JlcGVhdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduIHN0YXJ0aW5nIHZhbHVlcywgcmVzdGFydCBieSBtYWtpbmcgc3RhcnRUaW1lID0gbm93XG4gICAgICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3lveW8gJiYgdHlwZW9mIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdCh0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl95b3lvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gIXRoaXMuX3JldmVyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0RGVsYXlUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSArIHRoaXMuX3JlcGVhdERlbGF5VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9kZWxheVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vblJlcGVhdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFpbmVkIHR3ZWVucyBzdGFydCBleGFjdGx5IGF0IHRoZSB0aW1lIHRoZXkgc2hvdWxkLFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdGFydCh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB1cGRhdGUgcHJvcGVydGllcyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdFxuICAgICAgICAgICAgaWYgKF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xuICAgICAgICAgICAgdmFyIGVuZCA9IF92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX29iamVjdFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgdmFyIGVuZElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGVuZCk7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uTGlzdCA9ICFzdGFydElzQXJyYXkgJiYgZW5kSXNBcnJheTtcbiAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgX29iamVjdFtwcm9wZXJ0eV0gPSB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24oZW5kLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnb2JqZWN0JyAmJiBlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXMoX29iamVjdFtwcm9wZXJ0eV0sIHN0YXJ0LCBlbmQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlcyByZWxhdGl2ZSBlbmQgdmFsdWVzIHdpdGggc3RhcnQgYXMgYmFzZSAoZS5nLjogKzEwLCAtMylcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLl9oYW5kbGVSZWxhdGl2ZVZhbHVlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBub24gbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX29iamVjdFtwcm9wZXJ0eV0gPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5faGFuZGxlUmVsYXRpdmVWYWx1ZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kLmNoYXJBdCgwKSA9PT0gJysnIHx8IGVuZC5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGVuZCk7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mIGVuZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0bXA7XG4gICAgfTtcbiAgICByZXR1cm4gVHdlZW47XG59KCkpO1xuXG52YXIgVkVSU0lPTiA9ICcyMC4wLjMnO1xuXG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG52YXIgbmV4dElkID0gU2VxdWVuY2UubmV4dElkO1xuLyoqXG4gKiBDb250cm9sbGluZyBncm91cHMgb2YgdHdlZW5zXG4gKlxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxuICogSW4gdGhlc2UgY2FzZXMsIHlvdSBtYXkgd2FudCB0byBjcmVhdGUgeW91ciBvd24gc21hbGxlciBncm91cHMgb2YgdHdlZW5zLlxuICovXG52YXIgVFdFRU4gPSBtYWluR3JvdXA7XG4vLyBUaGlzIGlzIHRoZSBiZXN0IHdheSB0byBleHBvcnQgdGhpbmdzIGluIGEgd2F5IHRoYXQncyBjb21wYXRpYmxlIHdpdGggYm90aCBFU1xuLy8gTW9kdWxlcyBhbmQgQ29tbW9uSlMsIHdpdGhvdXQgYnVpbGQgaGFja3MsIGFuZCBzbyBhcyBub3QgdG8gYnJlYWsgdGhlXG4vLyBleGlzdGluZyBBUEkuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTk2MSNpc3N1ZWNvbW1lbnQtNDIzMDM3ODgxXG52YXIgZ2V0QWxsID0gVFdFRU4uZ2V0QWxsLmJpbmQoVFdFRU4pO1xudmFyIHJlbW92ZUFsbCA9IFRXRUVOLnJlbW92ZUFsbC5iaW5kKFRXRUVOKTtcbnZhciBhZGQgPSBUV0VFTi5hZGQuYmluZChUV0VFTik7XG52YXIgcmVtb3ZlID0gVFdFRU4ucmVtb3ZlLmJpbmQoVFdFRU4pO1xudmFyIHVwZGF0ZSA9IFRXRUVOLnVwZGF0ZS5iaW5kKFRXRUVOKTtcbnZhciBleHBvcnRzID0ge1xuICAgIEVhc2luZzogRWFzaW5nLFxuICAgIEdyb3VwOiBHcm91cCxcbiAgICBJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0aW9uLFxuICAgIG5vdzogbm93LFxuICAgIFNlcXVlbmNlOiBTZXF1ZW5jZSxcbiAgICBuZXh0SWQ6IG5leHRJZCxcbiAgICBUd2VlbjogVHdlZW4sXG4gICAgVkVSU0lPTjogVkVSU0lPTixcbiAgICBnZXRBbGw6IGdldEFsbCxcbiAgICByZW1vdmVBbGw6IHJlbW92ZUFsbCxcbiAgICBhZGQ6IGFkZCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbn07XG5cbmV4cG9ydCB7IEVhc2luZywgR3JvdXAsIEludGVycG9sYXRpb24sIFNlcXVlbmNlLCBUd2VlbiwgVkVSU0lPTiwgYWRkLCBleHBvcnRzIGFzIGRlZmF1bHQsIGdldEFsbCwgbmV4dElkLCBub3csIHJlbW92ZSwgcmVtb3ZlQWxsLCB1cGRhdGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///984\n")},332:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony exports BooleanController, ColorController, Controller, FunctionController, GUI, NumberController, OptionController, StringController */\n/**\n * lil-gui\n * https://lil-gui.georgealways.com\n * @version 0.19.1\n * @author George Michael Brower\n * @license MIT\n */\n\n/**\n * Base class for all controllers.\n */\nclass Controller {\n\n\tconstructor( parent, object, property, className, elementType = 'div' ) {\n\n\t\t/**\n\t\t * The GUI that contains this controller.\n\t\t * @type {GUI}\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The object this controller will modify.\n\t\t * @type {object}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The name of the property to control.\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * Used to determine if the controller is disabled.\n\t\t * Use `controller.disable( true|false )` to modify this value.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._disabled = false;\n\n\t\t/**\n\t\t * Used to determine if the Controller is hidden.\n\t\t * Use `controller.show()` or `controller.hide()` to change this.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._hidden = false;\n\n\t\t/**\n\t\t * The value of `object[ property ]` when the controller was created.\n\t\t * @type {any}\n\t\t */\n\t\tthis.initialValue = this.getValue();\n\n\t\t/**\n\t\t * The outermost container DOM element for this controller.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.domElement = document.createElement( elementType );\n\t\tthis.domElement.classList.add( 'controller' );\n\t\tthis.domElement.classList.add( className );\n\n\t\t/**\n\t\t * The DOM element that contains the controller's name.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$name = document.createElement( 'div' );\n\t\tthis.$name.classList.add( 'name' );\n\n\t\tController.nextNameID = Controller.nextNameID || 0;\n\t\tthis.$name.id = `lil-gui-name-${++Controller.nextNameID}`;\n\n\t\t/**\n\t\t * The DOM element that contains the controller's \"widget\" (which differs by controller type).\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$widget = document.createElement( 'div' );\n\t\tthis.$widget.classList.add( 'widget' );\n\n\t\t/**\n\t\t * The DOM element that receives the disabled attribute when using disable().\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$disable = this.$widget;\n\n\t\tthis.domElement.appendChild( this.$name );\n\t\tthis.domElement.appendChild( this.$widget );\n\n\t\t// Don't fire global key events while typing in a controller\n\t\tthis.domElement.addEventListener( 'keydown', e => e.stopPropagation() );\n\t\tthis.domElement.addEventListener( 'keyup', e => e.stopPropagation() );\n\n\t\tthis.parent.children.push( this );\n\t\tthis.parent.controllers.push( this );\n\n\t\tthis.parent.$children.appendChild( this.domElement );\n\n\t\tthis._listenCallback = this._listenCallback.bind( this );\n\n\t\tthis.name( property );\n\n\t}\n\n\t/**\n\t * Sets the name of the controller and its label in the GUI.\n\t * @param {string} name\n\t * @returns {this}\n\t */\n\tname( name ) {\n\t\t/**\n\t\t * The controller's name. Use `controller.name( 'Name' )` to modify this value.\n\t\t * @type {string}\n\t\t */\n\t\tthis._name = name;\n\t\tthis.$name.innerHTML = name;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pass a function to be called whenever the value is modified by this controller.\n\t * The function receives the new value as its first parameter. The value of `this` will be the\n\t * controller.\n\t *\n\t * For function controllers, the `onChange` callback will be fired on click, after the function\n\t * executes.\n\t * @param {Function} callback\n\t * @returns {this}\n\t * @example\n\t * const controller = gui.add( object, 'property' );\n\t *\n\t * controller.onChange( function( v ) {\n\t * \tconsole.log( 'The value is now ' + v );\n\t * \tconsole.assert( this === controller );\n\t * } );\n\t */\n\tonChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onChange` events. Don't modify this value directly.\n\t\t * Use the `controller.onChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onChange = callback;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the onChange methods of this controller and its parent GUI.\n\t * @protected\n\t */\n\t_callOnChange() {\n\n\t\tthis.parent._callOnChange( this );\n\n\t\tif ( this._onChange !== undefined ) {\n\t\t\tthis._onChange.call( this, this.getValue() );\n\t\t}\n\n\t\tthis._changed = true;\n\n\t}\n\n\t/**\n\t * Pass a function to be called after this controller has been modified and loses focus.\n\t * @param {Function} callback\n\t * @returns {this}\n\t * @example\n\t * const controller = gui.add( object, 'property' );\n\t *\n\t * controller.onFinishChange( function( v ) {\n\t * \tconsole.log( 'Changes complete: ' + v );\n\t * \tconsole.assert( this === controller );\n\t * } );\n\t */\n\tonFinishChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onFinishChange` events. Don't modify this value\n\t\t * directly. Use the `controller.onFinishChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onFinishChange = callback;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Should be called by Controller when its widgets lose focus.\n\t * @protected\n\t */\n\t_callOnFinishChange() {\n\n\t\tif ( this._changed ) {\n\n\t\t\tthis.parent._callOnFinishChange( this );\n\n\t\t\tif ( this._onFinishChange !== undefined ) {\n\t\t\t\tthis._onFinishChange.call( this, this.getValue() );\n\t\t\t}\n\n\t\t}\n\n\t\tthis._changed = false;\n\n\t}\n\n\t/**\n\t * Sets the controller back to its initial value.\n\t * @returns {this}\n\t */\n\treset() {\n\t\tthis.setValue( this.initialValue );\n\t\tthis._callOnFinishChange();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables this controller.\n\t * @param {boolean} enabled\n\t * @returns {this}\n\t * @example\n\t * controller.enable();\n\t * controller.enable( false ); // disable\n\t * controller.enable( controller._disabled ); // toggle\n\t */\n\tenable( enabled = true ) {\n\t\treturn this.disable( !enabled );\n\t}\n\n\t/**\n\t * Disables this controller.\n\t * @param {boolean} disabled\n\t * @returns {this}\n\t * @example\n\t * controller.disable();\n\t * controller.disable( false ); // enable\n\t * controller.disable( !controller._disabled ); // toggle\n\t */\n\tdisable( disabled = true ) {\n\n\t\tif ( disabled === this._disabled ) return this;\n\n\t\tthis._disabled = disabled;\n\n\t\tthis.domElement.classList.toggle( 'disabled', disabled );\n\t\tthis.$disable.toggleAttribute( 'disabled', disabled );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Shows the Controller after it's been hidden.\n\t * @param {boolean} show\n\t * @returns {this}\n\t * @example\n\t * controller.show();\n\t * controller.show( false ); // hide\n\t * controller.show( controller._hidden ); // toggle\n\t */\n\tshow( show = true ) {\n\n\t\tthis._hidden = !show;\n\n\t\tthis.domElement.style.display = this._hidden ? 'none' : '';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Hides the Controller.\n\t * @returns {this}\n\t */\n\thide() {\n\t\treturn this.show( false );\n\t}\n\n\t/**\n\t * Changes this controller into a dropdown of options.\n\t *\n\t * Calling this method on an option controller will simply update the options. However, if this\n\t * controller was not already an option controller, old references to this controller are\n\t * destroyed, and a new controller is added to the end of the GUI.\n\t * @example\n\t * // safe usage\n\t *\n\t * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );\n\t * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );\n\t * gui.add( obj, 'prop3' );\n\t *\n\t * // danger\n\t *\n\t * const ctrl1 = gui.add( obj, 'prop1' );\n\t * gui.add( obj, 'prop2' );\n\t *\n\t * // calling options out of order adds a new controller to the end...\n\t * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );\n\t *\n\t * // ...and ctrl1 now references a controller that doesn't exist\n\t * assert( ctrl2 !== ctrl1 )\n\t * @param {object|Array} options\n\t * @returns {Controller}\n\t */\n\toptions( options ) {\n\t\tconst controller = this.parent.add( this.object, this.property, options );\n\t\tcontroller.name( this._name );\n\t\tthis.destroy();\n\t\treturn controller;\n\t}\n\n\t/**\n\t * Sets the minimum value. Only works on number controllers.\n\t * @param {number} min\n\t * @returns {this}\n\t */\n\tmin( min ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the maximum value. Only works on number controllers.\n\t * @param {number} max\n\t * @returns {this}\n\t */\n\tmax( max ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Values set by this controller will be rounded to multiples of `step`. Only works on number\n\t * controllers.\n\t * @param {number} step\n\t * @returns {this}\n\t */\n\tstep( step ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounds the displayed value to a fixed number of decimals, without affecting the actual value\n\t * like `step()`. Only works on number controllers.\n\t * @example\n\t * gui.add( object, 'property' ).listen().decimals( 4 );\n\t * @param {number} decimals\n\t * @returns {this}\n\t */\n\tdecimals( decimals ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls `updateDisplay()` every animation frame. Pass `false` to stop listening.\n\t * @param {boolean} listen\n\t * @returns {this}\n\t */\n\tlisten( listen = true ) {\n\n\t\t/**\n\t\t * Used to determine if the controller is currently listening. Don't modify this value\n\t\t * directly. Use the `controller.listen( true|false )` method instead.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._listening = listen;\n\n\t\tif ( this._listenCallbackID !== undefined ) {\n\t\t\tcancelAnimationFrame( this._listenCallbackID );\n\t\t\tthis._listenCallbackID = undefined;\n\t\t}\n\n\t\tif ( this._listening ) {\n\t\t\tthis._listenCallback();\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t_listenCallback() {\n\n\t\tthis._listenCallbackID = requestAnimationFrame( this._listenCallback );\n\n\t\t// To prevent framerate loss, make sure the value has changed before updating the display.\n\t\t// Note: save() is used here instead of getValue() only because of ColorController. The !== operator\n\t\t// won't work for color objects or arrays, but ColorController.save() always returns a string.\n\n\t\tconst curValue = this.save();\n\n\t\tif ( curValue !== this._listenPrevValue ) {\n\t\t\tthis.updateDisplay();\n\t\t}\n\n\t\tthis._listenPrevValue = curValue;\n\n\t}\n\n\t/**\n\t * Returns `object[ property ]`.\n\t * @returns {any}\n\t */\n\tgetValue() {\n\t\treturn this.object[ this.property ];\n\t}\n\n\t/**\n\t * Sets the value of `object[ property ]`, invokes any `onChange` handlers and updates the display.\n\t * @param {any} value\n\t * @returns {this}\n\t */\n\tsetValue( value ) {\n\t\tthis.object[ this.property ] = value;\n\t\tthis._callOnChange();\n\t\tthis.updateDisplay();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates the display to keep it in sync with the current value. Useful for updating your\n\t * controllers when their values have been modified outside of the GUI.\n\t * @returns {this}\n\t */\n\tupdateDisplay() {\n\t\treturn this;\n\t}\n\n\tload( value ) {\n\t\tthis.setValue( value );\n\t\tthis._callOnFinishChange();\n\t\treturn this;\n\t}\n\n\tsave() {\n\t\treturn this.getValue();\n\t}\n\n\t/**\n\t * Destroys this controller and removes it from the parent GUI.\n\t */\n\tdestroy() {\n\t\tthis.listen( false );\n\t\tthis.parent.children.splice( this.parent.children.indexOf( this ), 1 );\n\t\tthis.parent.controllers.splice( this.parent.controllers.indexOf( this ), 1 );\n\t\tthis.parent.$children.removeChild( this.domElement );\n\t}\n\n}\n\nclass BooleanController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property ) {\n\n\t\tsuper( parent, object, property, 'boolean', 'label' );\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'checkbox' );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$widget.appendChild( this.$input );\n\n\t\tthis.$input.addEventListener( 'change', () => {\n\t\t\tthis.setValue( this.$input.checked );\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$disable = this.$input;\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\tupdateDisplay() {\n\t\tthis.$input.checked = this.getValue();\n\t\treturn this;\n\t}\n\n}\n\nfunction normalizeColorString( string ) {\n\n\tlet match, result;\n\n\tif ( match = string.match( /(#|0x)?([a-f0-9]{6})/i ) ) {\n\n\t\tresult = match[ 2 ];\n\n\t} else if ( match = string.match( /rgb\\(\\s*(\\d*)\\s*,\\s*(\\d*)\\s*,\\s*(\\d*)\\s*\\)/ ) ) {\n\n\t\tresult = parseInt( match[ 1 ] ).toString( 16 ).padStart( 2, 0 )\n\t\t\t+ parseInt( match[ 2 ] ).toString( 16 ).padStart( 2, 0 )\n\t\t\t+ parseInt( match[ 3 ] ).toString( 16 ).padStart( 2, 0 );\n\n\t} else if ( match = string.match( /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i ) ) {\n\n\t\tresult = match[ 1 ] + match[ 1 ] + match[ 2 ] + match[ 2 ] + match[ 3 ] + match[ 3 ];\n\n\t}\n\n\tif ( result ) {\n\t\treturn '#' + result;\n\t}\n\n\treturn false;\n\n}\n\nconst STRING = {\n\tisPrimitive: true,\n\tmatch: v => typeof v === 'string',\n\tfromHexString: normalizeColorString,\n\ttoHexString: normalizeColorString\n};\n\nconst INT = {\n\tisPrimitive: true,\n\tmatch: v => typeof v === 'number',\n\tfromHexString: string => parseInt( string.substring( 1 ), 16 ),\n\ttoHexString: value => '#' + value.toString( 16 ).padStart( 6, 0 )\n};\n\nconst ARRAY = {\n\tisPrimitive: false,\n\n\t// The arrow function is here to appease tree shakers like esbuild or webpack.\n\t// See https://esbuild.github.io/api/#tree-shaking\n\tmatch: v => Array.isArray( v ),\n\n\tfromHexString( string, target, rgbScale = 1 ) {\n\n\t\tconst int = INT.fromHexString( string );\n\n\t\ttarget[ 0 ] = ( int >> 16 & 255 ) / 255 * rgbScale;\n\t\ttarget[ 1 ] = ( int >> 8 & 255 ) / 255 * rgbScale;\n\t\ttarget[ 2 ] = ( int & 255 ) / 255 * rgbScale;\n\n\t},\n\ttoHexString( [ r, g, b ], rgbScale = 1 ) {\n\n\t\trgbScale = 255 / rgbScale;\n\n\t\tconst int = ( r * rgbScale ) << 16 ^\n\t\t\t( g * rgbScale ) << 8 ^\n\t\t\t( b * rgbScale ) << 0;\n\n\t\treturn INT.toHexString( int );\n\n\t}\n};\n\nconst OBJECT = {\n\tisPrimitive: false,\n\tmatch: v => Object( v ) === v,\n\tfromHexString( string, target, rgbScale = 1 ) {\n\n\t\tconst int = INT.fromHexString( string );\n\n\t\ttarget.r = ( int >> 16 & 255 ) / 255 * rgbScale;\n\t\ttarget.g = ( int >> 8 & 255 ) / 255 * rgbScale;\n\t\ttarget.b = ( int & 255 ) / 255 * rgbScale;\n\n\t},\n\ttoHexString( { r, g, b }, rgbScale = 1 ) {\n\n\t\trgbScale = 255 / rgbScale;\n\n\t\tconst int = ( r * rgbScale ) << 16 ^\n\t\t\t( g * rgbScale ) << 8 ^\n\t\t\t( b * rgbScale ) << 0;\n\n\t\treturn INT.toHexString( int );\n\n\t}\n};\n\nconst FORMATS = [ STRING, INT, ARRAY, OBJECT ];\n\nfunction getColorFormat( value ) {\n\treturn FORMATS.find( format => format.match( value ) );\n}\n\nclass ColorController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property, rgbScale ) {\n\n\t\tsuper( parent, object, property, 'color' );\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'color' );\n\t\tthis.$input.setAttribute( 'tabindex', -1 );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$text = document.createElement( 'input' );\n\t\tthis.$text.setAttribute( 'type', 'text' );\n\t\tthis.$text.setAttribute( 'spellcheck', 'false' );\n\t\tthis.$text.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$display = document.createElement( 'div' );\n\t\tthis.$display.classList.add( 'display' );\n\n\t\tthis.$display.appendChild( this.$input );\n\t\tthis.$widget.appendChild( this.$display );\n\t\tthis.$widget.appendChild( this.$text );\n\n\t\tthis._format = getColorFormat( this.initialValue );\n\t\tthis._rgbScale = rgbScale;\n\n\t\tthis._initialValueHexString = this.save();\n\t\tthis._textFocused = false;\n\n\t\tthis.$input.addEventListener( 'input', () => {\n\t\t\tthis._setValueFromHexString( this.$input.value );\n\t\t} );\n\n\t\tthis.$input.addEventListener( 'blur', () => {\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$text.addEventListener( 'input', () => {\n\t\t\tconst tryParse = normalizeColorString( this.$text.value );\n\t\t\tif ( tryParse ) {\n\t\t\t\tthis._setValueFromHexString( tryParse );\n\t\t\t}\n\t\t} );\n\n\t\tthis.$text.addEventListener( 'focus', () => {\n\t\t\tthis._textFocused = true;\n\t\t\tthis.$text.select();\n\t\t} );\n\n\t\tthis.$text.addEventListener( 'blur', () => {\n\t\t\tthis._textFocused = false;\n\t\t\tthis.updateDisplay();\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$disable = this.$text;\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\treset() {\n\t\tthis._setValueFromHexString( this._initialValueHexString );\n\t\treturn this;\n\t}\n\n\t_setValueFromHexString( value ) {\n\n\t\tif ( this._format.isPrimitive ) {\n\n\t\t\tconst newValue = this._format.fromHexString( value );\n\t\t\tthis.setValue( newValue );\n\n\t\t} else {\n\n\t\t\tthis._format.fromHexString( value, this.getValue(), this._rgbScale );\n\t\t\tthis._callOnChange();\n\t\t\tthis.updateDisplay();\n\n\t\t}\n\n\t}\n\n\tsave() {\n\t\treturn this._format.toHexString( this.getValue(), this._rgbScale );\n\t}\n\n\tload( value ) {\n\t\tthis._setValueFromHexString( value );\n\t\tthis._callOnFinishChange();\n\t\treturn this;\n\t}\n\n\tupdateDisplay() {\n\t\tthis.$input.value = this._format.toHexString( this.getValue(), this._rgbScale );\n\t\tif ( !this._textFocused ) {\n\t\t\tthis.$text.value = this.$input.value.substring( 1 );\n\t\t}\n\t\tthis.$display.style.backgroundColor = this.$input.value;\n\t\treturn this;\n\t}\n\n}\n\nclass FunctionController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property ) {\n\n\t\tsuper( parent, object, property, 'function' );\n\n\t\t// Buttons are the only case where widget contains name\n\t\tthis.$button = document.createElement( 'button' );\n\t\tthis.$button.appendChild( this.$name );\n\t\tthis.$widget.appendChild( this.$button );\n\n\t\tthis.$button.addEventListener( 'click', e => {\n\t\t\te.preventDefault();\n\t\t\tthis.getValue().call( this.object );\n\t\t\tthis._callOnChange();\n\t\t} );\n\n\t\t// enables :active pseudo class on mobile\n\t\tthis.$button.addEventListener( 'touchstart', () => {}, { passive: true } );\n\n\t\tthis.$disable = this.$button;\n\n\t}\n\n}\n\nclass NumberController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property, min, max, step ) {\n\n\t\tsuper( parent, object, property, 'number' );\n\n\t\tthis._initInput();\n\n\t\tthis.min( min );\n\t\tthis.max( max );\n\n\t\tconst stepExplicit = step !== undefined;\n\t\tthis.step( stepExplicit ? step : this._getImplicitStep(), stepExplicit );\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\tdecimals( decimals ) {\n\t\tthis._decimals = decimals;\n\t\tthis.updateDisplay();\n\t\treturn this;\n\t}\n\n\tmin( min ) {\n\t\tthis._min = min;\n\t\tthis._onUpdateMinMax();\n\t\treturn this;\n\t}\n\n\tmax( max ) {\n\t\tthis._max = max;\n\t\tthis._onUpdateMinMax();\n\t\treturn this;\n\t}\n\n\tstep( step, explicit = true ) {\n\t\tthis._step = step;\n\t\tthis._stepExplicit = explicit;\n\t\treturn this;\n\t}\n\n\tupdateDisplay() {\n\n\t\tconst value = this.getValue();\n\n\t\tif ( this._hasSlider ) {\n\n\t\t\tlet percent = ( value - this._min ) / ( this._max - this._min );\n\t\t\tpercent = Math.max( 0, Math.min( percent, 1 ) );\n\n\t\t\tthis.$fill.style.width = percent * 100 + '%';\n\n\t\t}\n\n\t\tif ( !this._inputFocused ) {\n\t\t\tthis.$input.value = this._decimals === undefined ? value : value.toFixed( this._decimals );\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t_initInput() {\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'text' );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\t// On touch devices only, use input[type=number] to force a numeric keyboard.\n\t\t// Ideally we could use one input type everywhere, but [type=number] has quirks\n\t\t// on desktop, and [inputmode=decimal] has quirks on iOS.\n\t\t// See https://github.com/georgealways/lil-gui/pull/16\n\n\t\tconst isTouch = window.matchMedia( '(pointer: coarse)' ).matches;\n\n\t\tif ( isTouch ) {\n\t\t\tthis.$input.setAttribute( 'type', 'number' );\n\t\t\tthis.$input.setAttribute( 'step', 'any' );\n\t\t}\n\n\t\tthis.$widget.appendChild( this.$input );\n\n\t\tthis.$disable = this.$input;\n\n\t\tconst onInput = () => {\n\n\t\t\tlet value = parseFloat( this.$input.value );\n\n\t\t\tif ( isNaN( value ) ) return;\n\n\t\t\tif ( this._stepExplicit ) {\n\t\t\t\tvalue = this._snap( value );\n\t\t\t}\n\n\t\t\tthis.setValue( this._clamp( value ) );\n\n\t\t};\n\n\t\t// Keys & mouse wheel\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst increment = delta => {\n\n\t\t\tconst value = parseFloat( this.$input.value );\n\n\t\t\tif ( isNaN( value ) ) return;\n\n\t\t\tthis._snapClampSetValue( value + delta );\n\n\t\t\t// Force the input to updateDisplay when it's focused\n\t\t\tthis.$input.value = this.getValue();\n\n\t\t};\n\n\t\tconst onKeyDown = e => {\n\t\t\t// Using `e.key` instead of `e.code` also catches NumpadEnter\n\t\t\tif ( e.key === 'Enter' ) {\n\t\t\t\tthis.$input.blur();\n\t\t\t}\n\t\t\tif ( e.code === 'ArrowUp' ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tincrement( this._step * this._arrowKeyMultiplier( e ) );\n\t\t\t}\n\t\t\tif ( e.code === 'ArrowDown' ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tincrement( this._step * this._arrowKeyMultiplier( e ) * -1 );\n\t\t\t}\n\t\t};\n\n\t\tconst onWheel = e => {\n\t\t\tif ( this._inputFocused ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tincrement( this._step * this._normalizeMouseWheel( e ) );\n\t\t\t}\n\t\t};\n\n\t\t// Vertical drag\n\t\t// ---------------------------------------------------------------------\n\n\t\tlet testingForVerticalDrag = false,\n\t\t\tinitClientX,\n\t\t\tinitClientY,\n\t\t\tprevClientY,\n\t\t\tinitValue,\n\t\t\tdragDelta;\n\n\t\t// Once the mouse is dragged more than DRAG_THRESH px on any axis, we decide\n\t\t// on the user's intent: horizontal means highlight, vertical means drag.\n\t\tconst DRAG_THRESH = 5;\n\n\t\tconst onMouseDown = e => {\n\n\t\t\tinitClientX = e.clientX;\n\t\t\tinitClientY = prevClientY = e.clientY;\n\t\t\ttestingForVerticalDrag = true;\n\n\t\t\tinitValue = this.getValue();\n\t\t\tdragDelta = 0;\n\n\t\t\twindow.addEventListener( 'mousemove', onMouseMove );\n\t\t\twindow.addEventListener( 'mouseup', onMouseUp );\n\n\t\t};\n\n\t\tconst onMouseMove = e => {\n\n\t\t\tif ( testingForVerticalDrag ) {\n\n\t\t\t\tconst dx = e.clientX - initClientX;\n\t\t\t\tconst dy = e.clientY - initClientY;\n\n\t\t\t\tif ( Math.abs( dy ) > DRAG_THRESH ) {\n\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tthis.$input.blur();\n\t\t\t\t\ttestingForVerticalDrag = false;\n\t\t\t\t\tthis._setDraggingStyle( true, 'vertical' );\n\n\t\t\t\t} else if ( Math.abs( dx ) > DRAG_THRESH ) {\n\n\t\t\t\t\tonMouseUp();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// This isn't an else so that the first move counts towards dragDelta\n\t\t\tif ( !testingForVerticalDrag ) {\n\n\t\t\t\tconst dy = e.clientY - prevClientY;\n\n\t\t\t\tdragDelta -= dy * this._step * this._arrowKeyMultiplier( e );\n\n\t\t\t\t// Clamp dragDelta so we don't have 'dead space' after dragging past bounds.\n\t\t\t\t// We're okay with the fact that bounds can be undefined here.\n\t\t\t\tif ( initValue + dragDelta > this._max ) {\n\t\t\t\t\tdragDelta = this._max - initValue;\n\t\t\t\t} else if ( initValue + dragDelta < this._min ) {\n\t\t\t\t\tdragDelta = this._min - initValue;\n\t\t\t\t}\n\n\t\t\t\tthis._snapClampSetValue( initValue + dragDelta );\n\n\t\t\t}\n\n\t\t\tprevClientY = e.clientY;\n\n\t\t};\n\n\t\tconst onMouseUp = () => {\n\t\t\tthis._setDraggingStyle( false, 'vertical' );\n\t\t\tthis._callOnFinishChange();\n\t\t\twindow.removeEventListener( 'mousemove', onMouseMove );\n\t\t\twindow.removeEventListener( 'mouseup', onMouseUp );\n\t\t};\n\n\t\t// Focus state & onFinishChange\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst onFocus = () => {\n\t\t\tthis._inputFocused = true;\n\t\t};\n\n\t\tconst onBlur = () => {\n\t\t\tthis._inputFocused = false;\n\t\t\tthis.updateDisplay();\n\t\t\tthis._callOnFinishChange();\n\t\t};\n\n\t\tthis.$input.addEventListener( 'input', onInput );\n\t\tthis.$input.addEventListener( 'keydown', onKeyDown );\n\t\tthis.$input.addEventListener( 'wheel', onWheel, { passive: false } );\n\t\tthis.$input.addEventListener( 'mousedown', onMouseDown );\n\t\tthis.$input.addEventListener( 'focus', onFocus );\n\t\tthis.$input.addEventListener( 'blur', onBlur );\n\n\t}\n\n\t_initSlider() {\n\n\t\tthis._hasSlider = true;\n\n\t\t// Build DOM\n\t\t// ---------------------------------------------------------------------\n\n\t\tthis.$slider = document.createElement( 'div' );\n\t\tthis.$slider.classList.add( 'slider' );\n\n\t\tthis.$fill = document.createElement( 'div' );\n\t\tthis.$fill.classList.add( 'fill' );\n\n\t\tthis.$slider.appendChild( this.$fill );\n\t\tthis.$widget.insertBefore( this.$slider, this.$input );\n\n\t\tthis.domElement.classList.add( 'hasSlider' );\n\n\t\t// Map clientX to value\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst map = ( v, a, b, c, d ) => {\n\t\t\treturn ( v - a ) / ( b - a ) * ( d - c ) + c;\n\t\t};\n\n\t\tconst setValueFromX = clientX => {\n\t\t\tconst rect = this.$slider.getBoundingClientRect();\n\t\t\tlet value = map( clientX, rect.left, rect.right, this._min, this._max );\n\t\t\tthis._snapClampSetValue( value );\n\t\t};\n\n\t\t// Mouse drag\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst mouseDown = e => {\n\t\t\tthis._setDraggingStyle( true );\n\t\t\tsetValueFromX( e.clientX );\n\t\t\twindow.addEventListener( 'mousemove', mouseMove );\n\t\t\twindow.addEventListener( 'mouseup', mouseUp );\n\t\t};\n\n\t\tconst mouseMove = e => {\n\t\t\tsetValueFromX( e.clientX );\n\t\t};\n\n\t\tconst mouseUp = () => {\n\t\t\tthis._callOnFinishChange();\n\t\t\tthis._setDraggingStyle( false );\n\t\t\twindow.removeEventListener( 'mousemove', mouseMove );\n\t\t\twindow.removeEventListener( 'mouseup', mouseUp );\n\t\t};\n\n\t\t// Touch drag\n\t\t// ---------------------------------------------------------------------\n\n\t\tlet testingForScroll = false, prevClientX, prevClientY;\n\n\t\tconst beginTouchDrag = e => {\n\t\t\te.preventDefault();\n\t\t\tthis._setDraggingStyle( true );\n\t\t\tsetValueFromX( e.touches[ 0 ].clientX );\n\t\t\ttestingForScroll = false;\n\t\t};\n\n\t\tconst onTouchStart = e => {\n\n\t\t\tif ( e.touches.length > 1 ) return;\n\n\t\t\t// If we're in a scrollable container, we should wait for the first\n\t\t\t// touchmove to see if the user is trying to slide or scroll.\n\t\t\tif ( this._hasScrollBar ) {\n\n\t\t\t\tprevClientX = e.touches[ 0 ].clientX;\n\t\t\t\tprevClientY = e.touches[ 0 ].clientY;\n\t\t\t\ttestingForScroll = true;\n\n\t\t\t} else {\n\n\t\t\t\t// Otherwise, we can set the value straight away on touchstart.\n\t\t\t\tbeginTouchDrag( e );\n\n\t\t\t}\n\n\t\t\twindow.addEventListener( 'touchmove', onTouchMove, { passive: false } );\n\t\t\twindow.addEventListener( 'touchend', onTouchEnd );\n\n\t\t};\n\n\t\tconst onTouchMove = e => {\n\n\t\t\tif ( testingForScroll ) {\n\n\t\t\t\tconst dx = e.touches[ 0 ].clientX - prevClientX;\n\t\t\t\tconst dy = e.touches[ 0 ].clientY - prevClientY;\n\n\t\t\t\tif ( Math.abs( dx ) > Math.abs( dy ) ) {\n\n\t\t\t\t\t// We moved horizontally, set the value and stop checking.\n\t\t\t\t\tbeginTouchDrag( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// This was, in fact, an attempt to scroll. Abort.\n\t\t\t\t\twindow.removeEventListener( 'touchmove', onTouchMove );\n\t\t\t\t\twindow.removeEventListener( 'touchend', onTouchEnd );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\te.preventDefault();\n\t\t\t\tsetValueFromX( e.touches[ 0 ].clientX );\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst onTouchEnd = () => {\n\t\t\tthis._callOnFinishChange();\n\t\t\tthis._setDraggingStyle( false );\n\t\t\twindow.removeEventListener( 'touchmove', onTouchMove );\n\t\t\twindow.removeEventListener( 'touchend', onTouchEnd );\n\t\t};\n\n\t\t// Mouse wheel\n\t\t// ---------------------------------------------------------------------\n\n\t\t// We have to use a debounced function to call onFinishChange because\n\t\t// there's no way to tell when the user is \"done\" mouse-wheeling.\n\t\tconst callOnFinishChange = this._callOnFinishChange.bind( this );\n\t\tconst WHEEL_DEBOUNCE_TIME = 400;\n\t\tlet wheelFinishChangeTimeout;\n\n\t\tconst onWheel = e => {\n\n\t\t\t// ignore vertical wheels if there's a scrollbar\n\t\t\tconst isVertical = Math.abs( e.deltaX ) < Math.abs( e.deltaY );\n\t\t\tif ( isVertical && this._hasScrollBar ) return;\n\n\t\t\te.preventDefault();\n\n\t\t\t// set value\n\t\t\tconst delta = this._normalizeMouseWheel( e ) * this._step;\n\t\t\tthis._snapClampSetValue( this.getValue() + delta );\n\n\t\t\t// force the input to updateDisplay when it's focused\n\t\t\tthis.$input.value = this.getValue();\n\n\t\t\t// debounce onFinishChange\n\t\t\tclearTimeout( wheelFinishChangeTimeout );\n\t\t\twheelFinishChangeTimeout = setTimeout( callOnFinishChange, WHEEL_DEBOUNCE_TIME );\n\n\t\t};\n\n\t\tthis.$slider.addEventListener( 'mousedown', mouseDown );\n\t\tthis.$slider.addEventListener( 'touchstart', onTouchStart, { passive: false } );\n\t\tthis.$slider.addEventListener( 'wheel', onWheel, { passive: false } );\n\n\t}\n\n\t_setDraggingStyle( active, axis = 'horizontal' ) {\n\t\tif ( this.$slider ) {\n\t\t\tthis.$slider.classList.toggle( 'active', active );\n\t\t}\n\t\tdocument.body.classList.toggle( 'lil-gui-dragging', active );\n\t\tdocument.body.classList.toggle( `lil-gui-${axis}`, active );\n\t}\n\n\t_getImplicitStep() {\n\n\t\tif ( this._hasMin && this._hasMax ) {\n\t\t\treturn ( this._max - this._min ) / 1000;\n\t\t}\n\n\t\treturn 0.1;\n\n\t}\n\n\t_onUpdateMinMax() {\n\n\t\tif ( !this._hasSlider && this._hasMin && this._hasMax ) {\n\n\t\t\t// If this is the first time we're hearing about min and max\n\t\t\t// and we haven't explicitly stated what our step is, let's\n\t\t\t// update that too.\n\t\t\tif ( !this._stepExplicit ) {\n\t\t\t\tthis.step( this._getImplicitStep(), false );\n\t\t\t}\n\n\t\t\tthis._initSlider();\n\t\t\tthis.updateDisplay();\n\n\t\t}\n\n\t}\n\n\t_normalizeMouseWheel( e ) {\n\n\t\tlet { deltaX, deltaY } = e;\n\n\t\t// Safari and Chrome report weird non-integral values for a notched wheel,\n\t\t// but still expose actual lines scrolled via wheelDelta. Notched wheels\n\t\t// should behave the same way as arrow keys.\n\t\tif ( Math.floor( e.deltaY ) !== e.deltaY && e.wheelDelta ) {\n\t\t\tdeltaX = 0;\n\t\t\tdeltaY = -e.wheelDelta / 120;\n\t\t\tdeltaY *= this._stepExplicit ? 1 : 10;\n\t\t}\n\n\t\tconst wheel = deltaX + -deltaY;\n\n\t\treturn wheel;\n\n\t}\n\n\t_arrowKeyMultiplier( e ) {\n\n\t\tlet mult = this._stepExplicit ? 1 : 10;\n\n\t\tif ( e.shiftKey ) {\n\t\t\tmult *= 10;\n\t\t} else if ( e.altKey ) {\n\t\t\tmult /= 10;\n\t\t}\n\n\t\treturn mult;\n\n\t}\n\n\t_snap( value ) {\n\n\t\t// This would be the logical way to do things, but floating point errors.\n\t\t// return Math.round( value / this._step ) * this._step;\n\n\t\t// Using inverse step solves a lot of them, but not all\n\t\t// const inverseStep = 1 / this._step;\n\t\t// return Math.round( value * inverseStep ) / inverseStep;\n\n\t\t// Not happy about this, but haven't seen it break.\n\t\tconst r = Math.round( value / this._step ) * this._step;\n\t\treturn parseFloat( r.toPrecision( 15 ) );\n\n\t}\n\n\t_clamp( value ) {\n\t\t// either condition is false if min or max is undefined\n\t\tif ( value < this._min ) value = this._min;\n\t\tif ( value > this._max ) value = this._max;\n\t\treturn value;\n\t}\n\n\t_snapClampSetValue( value ) {\n\t\tthis.setValue( this._clamp( this._snap( value ) ) );\n\t}\n\n\tget _hasScrollBar() {\n\t\tconst root = this.parent.root.$children;\n\t\treturn root.scrollHeight > root.clientHeight;\n\t}\n\n\tget _hasMin() {\n\t\treturn this._min !== undefined;\n\t}\n\n\tget _hasMax() {\n\t\treturn this._max !== undefined;\n\t}\n\n}\n\nclass OptionController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property, options ) {\n\n\t\tsuper( parent, object, property, 'option' );\n\n\t\tthis.$select = document.createElement( 'select' );\n\t\tthis.$select.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$display = document.createElement( 'div' );\n\t\tthis.$display.classList.add( 'display' );\n\n\t\tthis.$select.addEventListener( 'change', () => {\n\t\t\tthis.setValue( this._values[ this.$select.selectedIndex ] );\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$select.addEventListener( 'focus', () => {\n\t\t\tthis.$display.classList.add( 'focus' );\n\t\t} );\n\n\t\tthis.$select.addEventListener( 'blur', () => {\n\t\t\tthis.$display.classList.remove( 'focus' );\n\t\t} );\n\n\t\tthis.$widget.appendChild( this.$select );\n\t\tthis.$widget.appendChild( this.$display );\n\n\t\tthis.$disable = this.$select;\n\n\t\tthis.options( options );\n\n\t}\n\n\toptions( options ) {\n\n\t\tthis._values = Array.isArray( options ) ? options : Object.values( options );\n\t\tthis._names = Array.isArray( options ) ? options : Object.keys( options );\n\n\t\tthis.$select.replaceChildren();\n\n\t\tthis._names.forEach( name => {\n\t\t\tconst $option = document.createElement( 'option' );\n\t\t\t$option.innerHTML = name;\n\t\t\tthis.$select.appendChild( $option );\n\t\t} );\n\n\t\tthis.updateDisplay();\n\n\t\treturn this;\n\n\t}\n\n\tupdateDisplay() {\n\t\tconst value = this.getValue();\n\t\tconst index = this._values.indexOf( value );\n\t\tthis.$select.selectedIndex = index;\n\t\tthis.$display.innerHTML = index === -1 ? value : this._names[ index ];\n\t\treturn this;\n\t}\n\n}\n\nclass StringController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property ) {\n\n\t\tsuper( parent, object, property, 'string' );\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'text' );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$input.addEventListener( 'input', () => {\n\t\t\tthis.setValue( this.$input.value );\n\t\t} );\n\n\t\tthis.$input.addEventListener( 'keydown', e => {\n\t\t\tif ( e.code === 'Enter' ) {\n\t\t\t\tthis.$input.blur();\n\t\t\t}\n\t\t} );\n\n\t\tthis.$input.addEventListener( 'blur', () => {\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$widget.appendChild( this.$input );\n\n\t\tthis.$disable = this.$input;\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\tupdateDisplay() {\n\t\tthis.$input.value = this.getValue();\n\t\treturn this;\n\t}\n\n}\n\nconst stylesheet = (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (`.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, \"Droid Sans Mono\", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: \" \";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: \"lil-gui\";\n  content: \"↕\";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: \"lil-gui\";\n  content: \"▾\";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: \"▸\";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: \"Empty\";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: \"lil-gui\";\n  content: \"✓\";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: \"lil-gui\";\n  src: url(\"data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==\") format(\"woff\");\n}`) : null);\n\nfunction _injectStyles( cssContent ) {\n\tconst injected = document.createElement( 'style' );\n\tinjected.innerHTML = cssContent;\n\tconst before = document.querySelector( 'head link[rel=stylesheet], head style' );\n\tif ( before ) {\n\t\tdocument.head.insertBefore( injected, before );\n\t} else {\n\t\tdocument.head.appendChild( injected );\n\t}\n}\n\nlet stylesInjected = false;\n\nclass GUI {\n\n\t/**\n\t * Creates a panel that holds controllers.\n\t * @example\n\t * new GUI();\n\t * new GUI( { container: document.getElementById( 'custom' ) } );\n\t *\n\t * @param {object} [options]\n\t * @param {boolean} [options.autoPlace=true]\n\t * Adds the GUI to `document.body` and fixes it to the top right of the page.\n\t *\n\t * @param {HTMLElement} [options.container]\n\t * Adds the GUI to this DOM element. Overrides `autoPlace`.\n\t *\n\t * @param {number} [options.width=245]\n\t * Width of the GUI in pixels, usually set when name labels become too long. Note that you can make\n\t * name labels wider in CSS with `.lil‑gui { ‑‑name‑width: 55% }`.\n\t *\n\t * @param {string} [options.title=Controls]\n\t * Name to display in the title bar.\n\t *\n\t * @param {boolean} [options.closeFolders=false]\n\t * Pass `true` to close all folders in this GUI by default.\n\t *\n\t * @param {boolean} [options.injectStyles=true]\n\t * Injects the default stylesheet into the page if this is the first GUI.\n\t * Pass `false` to use your own stylesheet.\n\t *\n\t * @param {number} [options.touchStyles=true]\n\t * Makes controllers larger on touch devices. Pass `false` to disable touch styles.\n\t *\n\t * @param {GUI} [options.parent]\n\t * Adds this GUI as a child in another GUI. Usually this is done for you by `addFolder()`.\n\t *\n\t */\n\tconstructor( {\n\t\tparent,\n\t\tautoPlace = parent === undefined,\n\t\tcontainer,\n\t\twidth,\n\t\ttitle = 'Controls',\n\t\tcloseFolders = false,\n\t\tinjectStyles = true,\n\t\ttouchStyles = true\n\t} = {} ) {\n\n\t\t/**\n\t\t * The GUI containing this folder, or `undefined` if this is the root GUI.\n\t\t * @type {GUI}\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The top level GUI containing this folder, or `this` if this is the root GUI.\n\t\t * @type {GUI}\n\t\t */\n\t\tthis.root = parent ? parent.root : this;\n\n\t\t/**\n\t\t * The list of controllers and folders contained by this GUI.\n\t\t * @type {Array<GUI|Controller>}\n\t\t */\n\t\tthis.children = [];\n\n\t\t/**\n\t\t * The list of controllers contained by this GUI.\n\t\t * @type {Array<Controller>}\n\t\t */\n\t\tthis.controllers = [];\n\n\t\t/**\n\t\t * The list of folders contained by this GUI.\n\t\t * @type {Array<GUI>}\n\t\t */\n\t\tthis.folders = [];\n\n\t\t/**\n\t\t * Used to determine if the GUI is closed. Use `gui.open()` or `gui.close()` to change this.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._closed = false;\n\n\t\t/**\n\t\t * Used to determine if the GUI is hidden. Use `gui.show()` or `gui.hide()` to change this.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._hidden = false;\n\n\t\t/**\n\t\t * The outermost container element.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.domElement = document.createElement( 'div' );\n\t\tthis.domElement.classList.add( 'lil-gui' );\n\n\t\t/**\n\t\t * The DOM element that contains the title.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$title = document.createElement( 'div' );\n\t\tthis.$title.classList.add( 'title' );\n\t\tthis.$title.setAttribute( 'role', 'button' );\n\t\tthis.$title.setAttribute( 'aria-expanded', true );\n\t\tthis.$title.setAttribute( 'tabindex', 0 );\n\n\t\tthis.$title.addEventListener( 'click', () => this.openAnimated( this._closed ) );\n\t\tthis.$title.addEventListener( 'keydown', e => {\n\t\t\tif ( e.code === 'Enter' || e.code === 'Space' ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.$title.click();\n\t\t\t}\n\t\t} );\n\n\t\t// enables :active pseudo class on mobile\n\t\tthis.$title.addEventListener( 'touchstart', () => {}, { passive: true } );\n\n\t\t/**\n\t\t * The DOM element that contains children.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$children = document.createElement( 'div' );\n\t\tthis.$children.classList.add( 'children' );\n\n\t\tthis.domElement.appendChild( this.$title );\n\t\tthis.domElement.appendChild( this.$children );\n\n\t\tthis.title( title );\n\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.children.push( this );\n\t\t\tthis.parent.folders.push( this );\n\n\t\t\tthis.parent.$children.appendChild( this.domElement );\n\n\t\t\t// Stop the constructor early, everything onward only applies to root GUI's\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.domElement.classList.add( 'root' );\n\n\t\tif ( touchStyles ) {\n\t\t\tthis.domElement.classList.add( 'allow-touch-styles' );\n\t\t}\n\n\t\t// Inject stylesheet if we haven't done that yet\n\t\tif ( !stylesInjected && injectStyles ) {\n\t\t\t_injectStyles( stylesheet );\n\t\t\tstylesInjected = true;\n\t\t}\n\n\t\tif ( container ) {\n\n\t\t\tcontainer.appendChild( this.domElement );\n\n\t\t} else if ( autoPlace ) {\n\n\t\t\tthis.domElement.classList.add( 'autoPlace' );\n\t\t\tdocument.body.appendChild( this.domElement );\n\n\t\t}\n\n\t\tif ( width ) {\n\t\t\tthis.domElement.style.setProperty( '--width', width + 'px' );\n\t\t}\n\n\t\tthis._closeFolders = closeFolders;\n\n\t}\n\n\t/**\n\t * Adds a controller to the GUI, inferring controller type using the `typeof` operator.\n\t * @example\n\t * gui.add( object, 'property' );\n\t * gui.add( object, 'number', 0, 100, 1 );\n\t * gui.add( object, 'options', [ 1, 2, 3 ] );\n\t *\n\t * @param {object} object The object the controller will modify.\n\t * @param {string} property Name of the property to control.\n\t * @param {number|object|Array} [$1] Minimum value for number controllers, or the set of\n\t * selectable values for a dropdown.\n\t * @param {number} [max] Maximum value for number controllers.\n\t * @param {number} [step] Step value for number controllers.\n\t * @returns {Controller}\n\t */\n\tadd( object, property, $1, max, step ) {\n\n\t\tif ( Object( $1 ) === $1 ) {\n\n\t\t\treturn new OptionController( this, object, property, $1 );\n\n\t\t}\n\n\t\tconst initialValue = object[ property ];\n\n\t\tswitch ( typeof initialValue ) {\n\n\t\t\tcase 'number':\n\n\t\t\t\treturn new NumberController( this, object, property, $1, max, step );\n\n\t\t\tcase 'boolean':\n\n\t\t\t\treturn new BooleanController( this, object, property );\n\n\t\t\tcase 'string':\n\n\t\t\t\treturn new StringController( this, object, property );\n\n\t\t\tcase 'function':\n\n\t\t\t\treturn new FunctionController( this, object, property );\n\n\t\t}\n\n\t\tconsole.error( `gui.add failed\n\tproperty:`, property, `\n\tobject:`, object, `\n\tvalue:`, initialValue );\n\n\t}\n\n\t/**\n\t * Adds a color controller to the GUI.\n\t * @example\n\t * params = {\n\t * \tcssColor: '#ff00ff',\n\t * \trgbColor: { r: 0, g: 0.2, b: 0.4 },\n\t * \tcustomRange: [ 0, 127, 255 ],\n\t * };\n\t *\n\t * gui.addColor( params, 'cssColor' );\n\t * gui.addColor( params, 'rgbColor' );\n\t * gui.addColor( params, 'customRange', 255 );\n\t *\n\t * @param {object} object The object the controller will modify.\n\t * @param {string} property Name of the property to control.\n\t * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may\n\t * need to set this to 255 if your colors are too bright.\n\t * @returns {Controller}\n\t */\n\taddColor( object, property, rgbScale = 1 ) {\n\t\treturn new ColorController( this, object, property, rgbScale );\n\t}\n\n\t/**\n\t * Adds a folder to the GUI, which is just another GUI. This method returns\n\t * the nested GUI so you can add controllers to it.\n\t * @example\n\t * const folder = gui.addFolder( 'Position' );\n\t * folder.add( position, 'x' );\n\t * folder.add( position, 'y' );\n\t * folder.add( position, 'z' );\n\t *\n\t * @param {string} title Name to display in the folder's title bar.\n\t * @returns {GUI}\n\t */\n\taddFolder( title ) {\n\t\tconst folder = new GUI( { parent: this, title } );\n\t\tif ( this.root._closeFolders ) folder.close();\n\t\treturn folder;\n\t}\n\n\t/**\n\t * Recalls values that were saved with `gui.save()`.\n\t * @param {object} obj\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {this}\n\t */\n\tload( obj, recursive = true ) {\n\n\t\tif ( obj.controllers ) {\n\n\t\t\tthis.controllers.forEach( c => {\n\n\t\t\t\tif ( c instanceof FunctionController ) return;\n\n\t\t\t\tif ( c._name in obj.controllers ) {\n\t\t\t\t\tc.load( obj.controllers[ c._name ] );\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( recursive && obj.folders ) {\n\n\t\t\tthis.folders.forEach( f => {\n\n\t\t\t\tif ( f._title in obj.folders ) {\n\t\t\t\t\tf.load( obj.folders[ f._title ] );\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to\n\t * recall these values.\n\t * @example\n\t * {\n\t * \tcontrollers: {\n\t * \t\tprop1: 1,\n\t * \t\tprop2: 'value',\n\t * \t\t...\n\t * \t},\n\t * \tfolders: {\n\t * \t\tfolderName1: { controllers, folders },\n\t * \t\tfolderName2: { controllers, folders }\n\t * \t\t...\n\t * \t}\n\t * }\n\t *\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {object}\n\t */\n\tsave( recursive = true ) {\n\n\t\tconst obj = {\n\t\t\tcontrollers: {},\n\t\t\tfolders: {}\n\t\t};\n\n\t\tthis.controllers.forEach( c => {\n\n\t\t\tif ( c instanceof FunctionController ) return;\n\n\t\t\tif ( c._name in obj.controllers ) {\n\t\t\t\tthrow new Error( `Cannot save GUI with duplicate property \"${c._name}\"` );\n\t\t\t}\n\n\t\t\tobj.controllers[ c._name ] = c.save();\n\n\t\t} );\n\n\t\tif ( recursive ) {\n\n\t\t\tthis.folders.forEach( f => {\n\n\t\t\t\tif ( f._title in obj.folders ) {\n\t\t\t\t\tthrow new Error( `Cannot save GUI with duplicate folder \"${f._title}\"` );\n\t\t\t\t}\n\n\t\t\t\tobj.folders[ f._title ] = f.save();\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn obj;\n\n\t}\n\n\t/**\n\t * Opens a GUI or folder. GUI and folders are open by default.\n\t * @param {boolean} open Pass false to close.\n\t * @returns {this}\n\t * @example\n\t * gui.open(); // open\n\t * gui.open( false ); // close\n\t * gui.open( gui._closed ); // toggle\n\t */\n\topen( open = true ) {\n\n\t\tthis._setClosed( !open );\n\n\t\tthis.$title.setAttribute( 'aria-expanded', !this._closed );\n\t\tthis.domElement.classList.toggle( 'closed', this._closed );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Closes the GUI.\n\t * @returns {this}\n\t */\n\tclose() {\n\t\treturn this.open( false );\n\t}\n\n\t_setClosed( closed ) {\n\t\tif ( this._closed === closed ) return;\n\t\tthis._closed = closed;\n\t\tthis._callOnOpenClose( this );\n\t}\n\n\t/**\n\t * Shows the GUI after it's been hidden.\n\t * @param {boolean} show\n\t * @returns {this}\n\t * @example\n\t * gui.show();\n\t * gui.show( false ); // hide\n\t * gui.show( gui._hidden ); // toggle\n\t */\n\tshow( show = true ) {\n\n\t\tthis._hidden = !show;\n\n\t\tthis.domElement.style.display = this._hidden ? 'none' : '';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Hides the GUI.\n\t * @returns {this}\n\t */\n\thide() {\n\t\treturn this.show( false );\n\t}\n\n\topenAnimated( open = true ) {\n\n\t\t// set state immediately\n\t\tthis._setClosed( !open );\n\n\t\tthis.$title.setAttribute( 'aria-expanded', !this._closed );\n\n\t\t// wait for next frame to measure $children\n\t\trequestAnimationFrame( () => {\n\n\t\t\t// explicitly set initial height for transition\n\t\t\tconst initialHeight = this.$children.clientHeight;\n\t\t\tthis.$children.style.height = initialHeight + 'px';\n\n\t\t\tthis.domElement.classList.add( 'transition' );\n\n\t\t\tconst onTransitionEnd = e => {\n\t\t\t\tif ( e.target !== this.$children ) return;\n\t\t\t\tthis.$children.style.height = '';\n\t\t\t\tthis.domElement.classList.remove( 'transition' );\n\t\t\t\tthis.$children.removeEventListener( 'transitionend', onTransitionEnd );\n\t\t\t};\n\n\t\t\tthis.$children.addEventListener( 'transitionend', onTransitionEnd );\n\n\t\t\t// todo: this is wrong if children's scrollHeight makes for a gui taller than maxHeight\n\t\t\tconst targetHeight = !open ? 0 : this.$children.scrollHeight;\n\n\t\t\tthis.domElement.classList.toggle( 'closed', !open );\n\n\t\t\trequestAnimationFrame( () => {\n\t\t\t\tthis.$children.style.height = targetHeight + 'px';\n\t\t\t} );\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Change the title of this GUI.\n\t * @param {string} title\n\t * @returns {this}\n\t */\n\ttitle( title ) {\n\t\t/**\n\t\t * Current title of the GUI. Use `gui.title( 'Title' )` to modify this value.\n\t\t * @type {string}\n\t\t */\n\t\tthis._title = title;\n\t\tthis.$title.innerHTML = title;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets all controllers to their initial values.\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {this}\n\t */\n\treset( recursive = true ) {\n\t\tconst controllers = recursive ? this.controllersRecursive() : this.controllers;\n\t\tcontrollers.forEach( c => c.reset() );\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pass a function to be called whenever a controller in this GUI changes.\n\t * @param {function({object:object, property:string, value:any, controller:Controller})} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onChange( event => {\n\t * \tevent.object     // object that was modified\n\t * \tevent.property   // string, name of property\n\t * \tevent.value      // new value of controller\n\t * \tevent.controller // controller that was modified\n\t * } );\n\t */\n\tonChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onChange` events. Don't modify this value\n\t\t * directly. Use the `gui.onChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onChange = callback;\n\t\treturn this;\n\t}\n\n\t_callOnChange( controller ) {\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._callOnChange( controller );\n\t\t}\n\n\t\tif ( this._onChange !== undefined ) {\n\t\t\tthis._onChange.call( this, {\n\t\t\t\tobject: controller.object,\n\t\t\t\tproperty: controller.property,\n\t\t\t\tvalue: controller.getValue(),\n\t\t\t\tcontroller\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Pass a function to be called whenever a controller in this GUI has finished changing.\n\t * @param {function({object:object, property:string, value:any, controller:Controller})} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onFinishChange( event => {\n\t * \tevent.object     // object that was modified\n\t * \tevent.property   // string, name of property\n\t * \tevent.value      // new value of controller\n\t * \tevent.controller // controller that was modified\n\t * } );\n\t */\n\tonFinishChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onFinishChange` events. Don't modify this value\n\t\t * directly. Use the `gui.onFinishChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onFinishChange = callback;\n\t\treturn this;\n\t}\n\n\t_callOnFinishChange( controller ) {\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._callOnFinishChange( controller );\n\t\t}\n\n\t\tif ( this._onFinishChange !== undefined ) {\n\t\t\tthis._onFinishChange.call( this, {\n\t\t\t\tobject: controller.object,\n\t\t\t\tproperty: controller.property,\n\t\t\t\tvalue: controller.getValue(),\n\t\t\t\tcontroller\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Pass a function to be called when this GUI or its descendants are opened or closed.\n\t * @param {function(GUI)} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onOpenClose( changedGUI => {\n\t * \tconsole.log( changedGUI._closed );\n\t * } );\n\t */\n\tonOpenClose( callback ) {\n\t\tthis._onOpenClose = callback;\n\t\treturn this;\n\t}\n\n\t_callOnOpenClose( changedGUI ) {\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._callOnOpenClose( changedGUI );\n\t\t}\n\n\t\tif ( this._onOpenClose !== undefined ) {\n\t\t\tthis._onOpenClose.call( this, changedGUI );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all DOM elements and event listeners associated with this GUI.\n\t */\n\tdestroy() {\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent.children.splice( this.parent.children.indexOf( this ), 1 );\n\t\t\tthis.parent.folders.splice( this.parent.folders.indexOf( this ), 1 );\n\t\t}\n\n\t\tif ( this.domElement.parentElement ) {\n\t\t\tthis.domElement.parentElement.removeChild( this.domElement );\n\t\t}\n\n\t\tArray.from( this.children ).forEach( c => c.destroy() );\n\n\t}\n\n\t/**\n\t * Returns an array of controllers contained by this GUI and its descendents.\n\t * @returns {Controller[]}\n\t */\n\tcontrollersRecursive() {\n\t\tlet controllers = Array.from( this.controllers );\n\t\tthis.folders.forEach( f => {\n\t\t\tcontrollers = controllers.concat( f.controllersRecursive() );\n\t\t} );\n\t\treturn controllers;\n\t}\n\n\t/**\n\t * Returns an array of folders contained by this GUI and its descendents.\n\t * @returns {GUI[]}\n\t */\n\tfoldersRecursive() {\n\t\tlet folders = Array.from( this.folders );\n\t\tthis.folders.forEach( f => {\n\t\t\tfolders = folders.concat( f.foldersRecursive() );\n\t\t} );\n\t\treturn folders;\n\t}\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (GUI) : null));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSx3REFBd0QsaUJBQWlCO0FBQ3pFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRixxREFBcUQsaUJBQWlCOztBQUV0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQiw0RkFBVTs7QUFFekM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsNEZBQVU7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRCxDQUFDLENBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVSxpRUFBaUUsR0FBRztBQUMxRixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxxRkFBRyxXQUFDO0FBQ3NIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvbGlsLWd1aS9kaXN0L2xpbC1ndWkuZXNtLmpzP2JkMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsaWwtZ3VpXG4gKiBodHRwczovL2xpbC1ndWkuZ2VvcmdlYWx3YXlzLmNvbVxuICogQHZlcnNpb24gMC4xOS4xXG4gKiBAYXV0aG9yIEdlb3JnZSBNaWNoYWVsIEJyb3dlclxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgY29udHJvbGxlcnMuXG4gKi9cbmNsYXNzIENvbnRyb2xsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksIGNsYXNzTmFtZSwgZWxlbWVudFR5cGUgPSAnZGl2JyApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBHVUkgdGhhdCBjb250YWlucyB0aGlzIGNvbnRyb2xsZXIuXG5cdFx0ICogQHR5cGUge0dVSX1cblx0XHQgKi9cblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3QgdGhpcyBjb250cm9sbGVyIHdpbGwgbW9kaWZ5LlxuXHRcdCAqIEB0eXBlIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29udHJvbC5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb250cm9sbGVyIGlzIGRpc2FibGVkLlxuXHRcdCAqIFVzZSBgY29udHJvbGxlci5kaXNhYmxlKCB0cnVlfGZhbHNlIClgIHRvIG1vZGlmeSB0aGlzIHZhbHVlLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgQ29udHJvbGxlciBpcyBoaWRkZW4uXG5cdFx0ICogVXNlIGBjb250cm9sbGVyLnNob3coKWAgb3IgYGNvbnRyb2xsZXIuaGlkZSgpYCB0byBjaGFuZ2UgdGhpcy5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9oaWRkZW4gPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2YWx1ZSBvZiBgb2JqZWN0WyBwcm9wZXJ0eSBdYCB3aGVuIHRoZSBjb250cm9sbGVyIHdhcyBjcmVhdGVkLlxuXHRcdCAqIEB0eXBlIHthbnl9XG5cdFx0ICovXG5cdFx0dGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb3V0ZXJtb3N0IGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhpcyBjb250cm9sbGVyLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBlbGVtZW50VHlwZSApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnY29udHJvbGxlcicgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggY2xhc3NOYW1lICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbGxlcidzIG5hbWUuXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHRoaXMuJG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJG5hbWUuY2xhc3NMaXN0LmFkZCggJ25hbWUnICk7XG5cblx0XHRDb250cm9sbGVyLm5leHROYW1lSUQgPSBDb250cm9sbGVyLm5leHROYW1lSUQgfHwgMDtcblx0XHR0aGlzLiRuYW1lLmlkID0gYGxpbC1ndWktbmFtZS0keysrQ29udHJvbGxlci5uZXh0TmFtZUlEfWA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbGxlcidzIFwid2lkZ2V0XCIgKHdoaWNoIGRpZmZlcnMgYnkgY29udHJvbGxlciB0eXBlKS5cblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dGhpcy4kd2lkZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR0aGlzLiR3aWRnZXQuY2xhc3NMaXN0LmFkZCggJ3dpZGdldCcgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IHJlY2VpdmVzIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2hlbiB1c2luZyBkaXNhYmxlKCkuXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiR3aWRnZXQ7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuJG5hbWUgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuJHdpZGdldCApO1xuXG5cdFx0Ly8gRG9uJ3QgZmlyZSBnbG9iYWwga2V5IGV2ZW50cyB3aGlsZSB0eXBpbmcgaW4gYSBjb250cm9sbGVyXG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSApO1xuXG5cdFx0dGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCggdGhpcyApO1xuXHRcdHRoaXMucGFyZW50LmNvbnRyb2xsZXJzLnB1c2goIHRoaXMgKTtcblxuXHRcdHRoaXMucGFyZW50LiRjaGlsZHJlbi5hcHBlbmRDaGlsZCggdGhpcy5kb21FbGVtZW50ICk7XG5cblx0XHR0aGlzLl9saXN0ZW5DYWxsYmFjayA9IHRoaXMuX2xpc3RlbkNhbGxiYWNrLmJpbmQoIHRoaXMgKTtcblxuXHRcdHRoaXMubmFtZSggcHJvcGVydHkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGNvbnRyb2xsZXIgYW5kIGl0cyBsYWJlbCBpbiB0aGUgR1VJLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdG5hbWUoIG5hbWUgKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbnRyb2xsZXIncyBuYW1lLiBVc2UgYGNvbnRyb2xsZXIubmFtZSggJ05hbWUnIClgIHRvIG1vZGlmeSB0aGlzIHZhbHVlLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5fbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4kbmFtZS5pbm5lckhUTUwgPSBuYW1lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGlzIG1vZGlmaWVkIGJ5IHRoaXMgY29udHJvbGxlci5cblx0ICogVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBuZXcgdmFsdWUgYXMgaXRzIGZpcnN0IHBhcmFtZXRlci4gVGhlIHZhbHVlIG9mIGB0aGlzYCB3aWxsIGJlIHRoZVxuXHQgKiBjb250cm9sbGVyLlxuXHQgKlxuXHQgKiBGb3IgZnVuY3Rpb24gY29udHJvbGxlcnMsIHRoZSBgb25DaGFuZ2VgIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgb24gY2xpY2ssIGFmdGVyIHRoZSBmdW5jdGlvblxuXHQgKiBleGVjdXRlcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnN0IGNvbnRyb2xsZXIgPSBndWkuYWRkKCBvYmplY3QsICdwcm9wZXJ0eScgKTtcblx0ICpcblx0ICogY29udHJvbGxlci5vbkNoYW5nZSggZnVuY3Rpb24oIHYgKSB7XG5cdCAqIFx0Y29uc29sZS5sb2coICdUaGUgdmFsdWUgaXMgbm93ICcgKyB2ICk7XG5cdCAqIFx0Y29uc29sZS5hc3NlcnQoIHRoaXMgPT09IGNvbnRyb2xsZXIgKTtcblx0ICogfSApO1xuXHQgKi9cblx0b25DaGFuZ2UoIGNhbGxiYWNrICkge1xuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gYWNjZXNzIHRoZSBmdW5jdGlvbiBib3VuZCB0byBgb25DaGFuZ2VgIGV2ZW50cy4gRG9uJ3QgbW9kaWZ5IHRoaXMgdmFsdWUgZGlyZWN0bHkuXG5cdFx0ICogVXNlIHRoZSBgY29udHJvbGxlci5vbkNoYW5nZSggY2FsbGJhY2sgKWAgbWV0aG9kIGluc3RlYWQuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdHRoaXMuX29uQ2hhbmdlID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uQ2hhbmdlIG1ldGhvZHMgb2YgdGhpcyBjb250cm9sbGVyIGFuZCBpdHMgcGFyZW50IEdVSS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NhbGxPbkNoYW5nZSgpIHtcblxuXHRcdHRoaXMucGFyZW50Ll9jYWxsT25DaGFuZ2UoIHRoaXMgKTtcblxuXHRcdGlmICggdGhpcy5fb25DaGFuZ2UgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX29uQ2hhbmdlLmNhbGwoIHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NoYW5nZWQgPSB0cnVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUGFzcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciB0aGlzIGNvbnRyb2xsZXIgaGFzIGJlZW4gbW9kaWZpZWQgYW5kIGxvc2VzIGZvY3VzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogY29uc3QgY29udHJvbGxlciA9IGd1aS5hZGQoIG9iamVjdCwgJ3Byb3BlcnR5JyApO1xuXHQgKlxuXHQgKiBjb250cm9sbGVyLm9uRmluaXNoQ2hhbmdlKCBmdW5jdGlvbiggdiApIHtcblx0ICogXHRjb25zb2xlLmxvZyggJ0NoYW5nZXMgY29tcGxldGU6ICcgKyB2ICk7XG5cdCAqIFx0Y29uc29sZS5hc3NlcnQoIHRoaXMgPT09IGNvbnRyb2xsZXIgKTtcblx0ICogfSApO1xuXHQgKi9cblx0b25GaW5pc2hDaGFuZ2UoIGNhbGxiYWNrICkge1xuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gYWNjZXNzIHRoZSBmdW5jdGlvbiBib3VuZCB0byBgb25GaW5pc2hDaGFuZ2VgIGV2ZW50cy4gRG9uJ3QgbW9kaWZ5IHRoaXMgdmFsdWVcblx0XHQgKiBkaXJlY3RseS4gVXNlIHRoZSBgY29udHJvbGxlci5vbkZpbmlzaENoYW5nZSggY2FsbGJhY2sgKWAgbWV0aG9kIGluc3RlYWQuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdHRoaXMuX29uRmluaXNoQ2hhbmdlID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2hvdWxkIGJlIGNhbGxlZCBieSBDb250cm9sbGVyIHdoZW4gaXRzIHdpZGdldHMgbG9zZSBmb2N1cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NhbGxPbkZpbmlzaENoYW5nZSgpIHtcblxuXHRcdGlmICggdGhpcy5fY2hhbmdlZCApIHtcblxuXHRcdFx0dGhpcy5wYXJlbnQuX2NhbGxPbkZpbmlzaENoYW5nZSggdGhpcyApO1xuXG5cdFx0XHRpZiAoIHRoaXMuX29uRmluaXNoQ2hhbmdlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMuX29uRmluaXNoQ2hhbmdlLmNhbGwoIHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSApO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fY2hhbmdlZCA9IGZhbHNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29udHJvbGxlciBiYWNrIHRvIGl0cyBpbml0aWFsIHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHJlc2V0KCkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMuaW5pdGlhbFZhbHVlICk7XG5cdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogY29udHJvbGxlci5lbmFibGUoKTtcblx0ICogY29udHJvbGxlci5lbmFibGUoIGZhbHNlICk7IC8vIGRpc2FibGVcblx0ICogY29udHJvbGxlci5lbmFibGUoIGNvbnRyb2xsZXIuX2Rpc2FibGVkICk7IC8vIHRvZ2dsZVxuXHQgKi9cblx0ZW5hYmxlKCBlbmFibGVkID0gdHJ1ZSApIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNhYmxlKCAhZW5hYmxlZCApO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIHRoaXMgY29udHJvbGxlci5cblx0ICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogY29udHJvbGxlci5kaXNhYmxlKCk7XG5cdCAqIGNvbnRyb2xsZXIuZGlzYWJsZSggZmFsc2UgKTsgLy8gZW5hYmxlXG5cdCAqIGNvbnRyb2xsZXIuZGlzYWJsZSggIWNvbnRyb2xsZXIuX2Rpc2FibGVkICk7IC8vIHRvZ2dsZVxuXHQgKi9cblx0ZGlzYWJsZSggZGlzYWJsZWQgPSB0cnVlICkge1xuXG5cdFx0aWYgKCBkaXNhYmxlZCA9PT0gdGhpcy5fZGlzYWJsZWQgKSByZXR1cm4gdGhpcztcblxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZGlzYWJsZWQ7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSggJ2Rpc2FibGVkJywgZGlzYWJsZWQgKTtcblx0XHR0aGlzLiRkaXNhYmxlLnRvZ2dsZUF0dHJpYnV0ZSggJ2Rpc2FibGVkJywgZGlzYWJsZWQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgdGhlIENvbnRyb2xsZXIgYWZ0ZXIgaXQncyBiZWVuIGhpZGRlbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBzaG93XG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb250cm9sbGVyLnNob3coKTtcblx0ICogY29udHJvbGxlci5zaG93KCBmYWxzZSApOyAvLyBoaWRlXG5cdCAqIGNvbnRyb2xsZXIuc2hvdyggY29udHJvbGxlci5faGlkZGVuICk7IC8vIHRvZ2dsZVxuXHQgKi9cblx0c2hvdyggc2hvdyA9IHRydWUgKSB7XG5cblx0XHR0aGlzLl9oaWRkZW4gPSAhc2hvdztcblxuXHRcdHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdGhpcy5faGlkZGVuID8gJ25vbmUnIDogJyc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEhpZGVzIHRoZSBDb250cm9sbGVyLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGhpZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2hvdyggZmFsc2UgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoaXMgY29udHJvbGxlciBpbnRvIGEgZHJvcGRvd24gb2Ygb3B0aW9ucy5cblx0ICpcblx0ICogQ2FsbGluZyB0aGlzIG1ldGhvZCBvbiBhbiBvcHRpb24gY29udHJvbGxlciB3aWxsIHNpbXBseSB1cGRhdGUgdGhlIG9wdGlvbnMuIEhvd2V2ZXIsIGlmIHRoaXNcblx0ICogY29udHJvbGxlciB3YXMgbm90IGFscmVhZHkgYW4gb3B0aW9uIGNvbnRyb2xsZXIsIG9sZCByZWZlcmVuY2VzIHRvIHRoaXMgY29udHJvbGxlciBhcmVcblx0ICogZGVzdHJveWVkLCBhbmQgYSBuZXcgY29udHJvbGxlciBpcyBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBHVUkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIHNhZmUgdXNhZ2Vcblx0ICpcblx0ICogZ3VpLmFkZCggb2JqLCAncHJvcDEnICkub3B0aW9ucyggWyAnYScsICdiJywgJ2MnIF0gKTtcblx0ICogZ3VpLmFkZCggb2JqLCAncHJvcDInICkub3B0aW9ucyggeyBCaWc6IDEwLCBTbWFsbDogMSB9ICk7XG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AzJyApO1xuXHQgKlxuXHQgKiAvLyBkYW5nZXJcblx0ICpcblx0ICogY29uc3QgY3RybDEgPSBndWkuYWRkKCBvYmosICdwcm9wMScgKTtcblx0ICogZ3VpLmFkZCggb2JqLCAncHJvcDInICk7XG5cdCAqXG5cdCAqIC8vIGNhbGxpbmcgb3B0aW9ucyBvdXQgb2Ygb3JkZXIgYWRkcyBhIG5ldyBjb250cm9sbGVyIHRvIHRoZSBlbmQuLi5cblx0ICogY29uc3QgY3RybDIgPSBjdHJsMS5vcHRpb25zKCBbICdhJywgJ2InLCAnYycgXSApO1xuXHQgKlxuXHQgKiAvLyAuLi5hbmQgY3RybDEgbm93IHJlZmVyZW5jZXMgYSBjb250cm9sbGVyIHRoYXQgZG9lc24ndCBleGlzdFxuXHQgKiBhc3NlcnQoIGN0cmwyICE9PSBjdHJsMSApXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtDb250cm9sbGVyfVxuXHQgKi9cblx0b3B0aW9ucyggb3B0aW9ucyApIHtcblx0XHRjb25zdCBjb250cm9sbGVyID0gdGhpcy5wYXJlbnQuYWRkKCB0aGlzLm9iamVjdCwgdGhpcy5wcm9wZXJ0eSwgb3B0aW9ucyApO1xuXHRcdGNvbnRyb2xsZXIubmFtZSggdGhpcy5fbmFtZSApO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdHJldHVybiBjb250cm9sbGVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1pbmltdW0gdmFsdWUuIE9ubHkgd29ya3Mgb24gbnVtYmVyIGNvbnRyb2xsZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0bWluKCBtaW4gKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWF4aW11bSB2YWx1ZS4gT25seSB3b3JrcyBvbiBudW1iZXIgY29udHJvbGxlcnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRtYXgoIG1heCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBWYWx1ZXMgc2V0IGJ5IHRoaXMgY29udHJvbGxlciB3aWxsIGJlIHJvdW5kZWQgdG8gbXVsdGlwbGVzIG9mIGBzdGVwYC4gT25seSB3b3JrcyBvbiBudW1iZXJcblx0ICogY29udHJvbGxlcnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0c3RlcCggc3RlcCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSb3VuZHMgdGhlIGRpc3BsYXllZCB2YWx1ZSB0byBhIGZpeGVkIG51bWJlciBvZiBkZWNpbWFscywgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGFjdHVhbCB2YWx1ZVxuXHQgKiBsaWtlIGBzdGVwKClgLiBPbmx5IHdvcmtzIG9uIG51bWJlciBjb250cm9sbGVycy5cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLmFkZCggb2JqZWN0LCAncHJvcGVydHknICkubGlzdGVuKCkuZGVjaW1hbHMoIDQgKTtcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0ZGVjaW1hbHMoIGRlY2ltYWxzICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIGB1cGRhdGVEaXNwbGF5KClgIGV2ZXJ5IGFuaW1hdGlvbiBmcmFtZS4gUGFzcyBgZmFsc2VgIHRvIHN0b3AgbGlzdGVuaW5nLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxpc3RlblxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGxpc3RlbiggbGlzdGVuID0gdHJ1ZSApIHtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb250cm9sbGVyIGlzIGN1cnJlbnRseSBsaXN0ZW5pbmcuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlXG5cdFx0ICogZGlyZWN0bHkuIFVzZSB0aGUgYGNvbnRyb2xsZXIubGlzdGVuKCB0cnVlfGZhbHNlIClgIG1ldGhvZCBpbnN0ZWFkLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xpc3RlbmluZyA9IGxpc3RlbjtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuQ2FsbGJhY2tJRCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUoIHRoaXMuX2xpc3RlbkNhbGxiYWNrSUQgKTtcblx0XHRcdHRoaXMuX2xpc3RlbkNhbGxiYWNrSUQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5pbmcgKSB7XG5cdFx0XHR0aGlzLl9saXN0ZW5DYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfbGlzdGVuQ2FsbGJhY2soKSB7XG5cblx0XHR0aGlzLl9saXN0ZW5DYWxsYmFja0lEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9saXN0ZW5DYWxsYmFjayApO1xuXG5cdFx0Ly8gVG8gcHJldmVudCBmcmFtZXJhdGUgbG9zcywgbWFrZSBzdXJlIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCBiZWZvcmUgdXBkYXRpbmcgdGhlIGRpc3BsYXkuXG5cdFx0Ly8gTm90ZTogc2F2ZSgpIGlzIHVzZWQgaGVyZSBpbnN0ZWFkIG9mIGdldFZhbHVlKCkgb25seSBiZWNhdXNlIG9mIENvbG9yQ29udHJvbGxlci4gVGhlICE9PSBvcGVyYXRvclxuXHRcdC8vIHdvbid0IHdvcmsgZm9yIGNvbG9yIG9iamVjdHMgb3IgYXJyYXlzLCBidXQgQ29sb3JDb250cm9sbGVyLnNhdmUoKSBhbHdheXMgcmV0dXJucyBhIHN0cmluZy5cblxuXHRcdGNvbnN0IGN1clZhbHVlID0gdGhpcy5zYXZlKCk7XG5cblx0XHRpZiAoIGN1clZhbHVlICE9PSB0aGlzLl9saXN0ZW5QcmV2VmFsdWUgKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9saXN0ZW5QcmV2VmFsdWUgPSBjdXJWYWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYG9iamVjdFsgcHJvcGVydHkgXWAuXG5cdCAqIEByZXR1cm5zIHthbnl9XG5cdCAqL1xuXHRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vYmplY3RbIHRoaXMucHJvcGVydHkgXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiBgb2JqZWN0WyBwcm9wZXJ0eSBdYCwgaW52b2tlcyBhbnkgYG9uQ2hhbmdlYCBoYW5kbGVycyBhbmQgdXBkYXRlcyB0aGUgZGlzcGxheS5cblx0ICogQHBhcmFtIHthbnl9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0c2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdHRoaXMub2JqZWN0WyB0aGlzLnByb3BlcnR5IF0gPSB2YWx1ZTtcblx0XHR0aGlzLl9jYWxsT25DaGFuZ2UoKTtcblx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBkaXNwbGF5IHRvIGtlZXAgaXQgaW4gc3luYyB3aXRoIHRoZSBjdXJyZW50IHZhbHVlLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHlvdXJcblx0ICogY29udHJvbGxlcnMgd2hlbiB0aGVpciB2YWx1ZXMgaGF2ZSBiZWVuIG1vZGlmaWVkIG91dHNpZGUgb2YgdGhlIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHR1cGRhdGVEaXNwbGF5KCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bG9hZCggdmFsdWUgKSB7XG5cdFx0dGhpcy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHNhdmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGlzIGNvbnRyb2xsZXIgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcGFyZW50IEdVSS5cblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5saXN0ZW4oIGZhbHNlICk7XG5cdFx0dGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKCB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKCB0aGlzICksIDEgKTtcblx0XHR0aGlzLnBhcmVudC5jb250cm9sbGVycy5zcGxpY2UoIHRoaXMucGFyZW50LmNvbnRyb2xsZXJzLmluZGV4T2YoIHRoaXMgKSwgMSApO1xuXHRcdHRoaXMucGFyZW50LiRjaGlsZHJlbi5yZW1vdmVDaGlsZCggdGhpcy5kb21FbGVtZW50ICk7XG5cdH1cblxufVxuXG5jbGFzcyBCb29sZWFuQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHkgKSB7XG5cblx0XHRzdXBlciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCAnYm9vbGVhbicsICdsYWJlbCcgKTtcblxuXHRcdHRoaXMuJGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3R5cGUnLCAnY2hlY2tib3gnICk7XG5cdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy4kbmFtZS5pZCApO1xuXG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRpbnB1dCApO1xuXG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsICgpID0+IHtcblx0XHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMuJGlucHV0LmNoZWNrZWQgKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiRpbnB1dDtcblxuXHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG5cdH1cblxuXHR1cGRhdGVEaXNwbGF5KCkge1xuXHRcdHRoaXMuJGlucHV0LmNoZWNrZWQgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvclN0cmluZyggc3RyaW5nICkge1xuXG5cdGxldCBtYXRjaCwgcmVzdWx0O1xuXG5cdGlmICggbWF0Y2ggPSBzdHJpbmcubWF0Y2goIC8oI3wweCk/KFthLWYwLTldezZ9KS9pICkgKSB7XG5cblx0XHRyZXN1bHQgPSBtYXRjaFsgMiBdO1xuXG5cdH0gZWxzZSBpZiAoIG1hdGNoID0gc3RyaW5nLm1hdGNoKCAvcmdiXFwoXFxzKihcXGQqKVxccyosXFxzKihcXGQqKVxccyosXFxzKihcXGQqKVxccypcXCkvICkgKSB7XG5cblx0XHRyZXN1bHQgPSBwYXJzZUludCggbWF0Y2hbIDEgXSApLnRvU3RyaW5nKCAxNiApLnBhZFN0YXJ0KCAyLCAwIClcblx0XHRcdCsgcGFyc2VJbnQoIG1hdGNoWyAyIF0gKS50b1N0cmluZyggMTYgKS5wYWRTdGFydCggMiwgMCApXG5cdFx0XHQrIHBhcnNlSW50KCBtYXRjaFsgMyBdICkudG9TdHJpbmcoIDE2ICkucGFkU3RhcnQoIDIsIDAgKTtcblxuXHR9IGVsc2UgaWYgKCBtYXRjaCA9IHN0cmluZy5tYXRjaCggL14jPyhbYS1mMC05XSkoW2EtZjAtOV0pKFthLWYwLTldKSQvaSApICkge1xuXG5cdFx0cmVzdWx0ID0gbWF0Y2hbIDEgXSArIG1hdGNoWyAxIF0gKyBtYXRjaFsgMiBdICsgbWF0Y2hbIDIgXSArIG1hdGNoWyAzIF0gKyBtYXRjaFsgMyBdO1xuXG5cdH1cblxuXHRpZiAoIHJlc3VsdCApIHtcblx0XHRyZXR1cm4gJyMnICsgcmVzdWx0O1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbmNvbnN0IFNUUklORyA9IHtcblx0aXNQcmltaXRpdmU6IHRydWUsXG5cdG1hdGNoOiB2ID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJyxcblx0ZnJvbUhleFN0cmluZzogbm9ybWFsaXplQ29sb3JTdHJpbmcsXG5cdHRvSGV4U3RyaW5nOiBub3JtYWxpemVDb2xvclN0cmluZ1xufTtcblxuY29uc3QgSU5UID0ge1xuXHRpc1ByaW1pdGl2ZTogdHJ1ZSxcblx0bWF0Y2g6IHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInLFxuXHRmcm9tSGV4U3RyaW5nOiBzdHJpbmcgPT4gcGFyc2VJbnQoIHN0cmluZy5zdWJzdHJpbmcoIDEgKSwgMTYgKSxcblx0dG9IZXhTdHJpbmc6IHZhbHVlID0+ICcjJyArIHZhbHVlLnRvU3RyaW5nKCAxNiApLnBhZFN0YXJ0KCA2LCAwIClcbn07XG5cbmNvbnN0IEFSUkFZID0ge1xuXHRpc1ByaW1pdGl2ZTogZmFsc2UsXG5cblx0Ly8gVGhlIGFycm93IGZ1bmN0aW9uIGlzIGhlcmUgdG8gYXBwZWFzZSB0cmVlIHNoYWtlcnMgbGlrZSBlc2J1aWxkIG9yIHdlYnBhY2suXG5cdC8vIFNlZSBodHRwczovL2VzYnVpbGQuZ2l0aHViLmlvL2FwaS8jdHJlZS1zaGFraW5nXG5cdG1hdGNoOiB2ID0+IEFycmF5LmlzQXJyYXkoIHYgKSxcblxuXHRmcm9tSGV4U3RyaW5nKCBzdHJpbmcsIHRhcmdldCwgcmdiU2NhbGUgPSAxICkge1xuXG5cdFx0Y29uc3QgaW50ID0gSU5ULmZyb21IZXhTdHJpbmcoIHN0cmluZyApO1xuXG5cdFx0dGFyZ2V0WyAwIF0gPSAoIGludCA+PiAxNiAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cdFx0dGFyZ2V0WyAxIF0gPSAoIGludCA+PiA4ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblx0XHR0YXJnZXRbIDIgXSA9ICggaW50ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblxuXHR9LFxuXHR0b0hleFN0cmluZyggWyByLCBnLCBiIF0sIHJnYlNjYWxlID0gMSApIHtcblxuXHRcdHJnYlNjYWxlID0gMjU1IC8gcmdiU2NhbGU7XG5cblx0XHRjb25zdCBpbnQgPSAoIHIgKiByZ2JTY2FsZSApIDw8IDE2IF5cblx0XHRcdCggZyAqIHJnYlNjYWxlICkgPDwgOCBeXG5cdFx0XHQoIGIgKiByZ2JTY2FsZSApIDw8IDA7XG5cblx0XHRyZXR1cm4gSU5ULnRvSGV4U3RyaW5nKCBpbnQgKTtcblxuXHR9XG59O1xuXG5jb25zdCBPQkpFQ1QgPSB7XG5cdGlzUHJpbWl0aXZlOiBmYWxzZSxcblx0bWF0Y2g6IHYgPT4gT2JqZWN0KCB2ICkgPT09IHYsXG5cdGZyb21IZXhTdHJpbmcoIHN0cmluZywgdGFyZ2V0LCByZ2JTY2FsZSA9IDEgKSB7XG5cblx0XHRjb25zdCBpbnQgPSBJTlQuZnJvbUhleFN0cmluZyggc3RyaW5nICk7XG5cblx0XHR0YXJnZXQuciA9ICggaW50ID4+IDE2ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblx0XHR0YXJnZXQuZyA9ICggaW50ID4+IDggJiAyNTUgKSAvIDI1NSAqIHJnYlNjYWxlO1xuXHRcdHRhcmdldC5iID0gKCBpbnQgJiAyNTUgKSAvIDI1NSAqIHJnYlNjYWxlO1xuXG5cdH0sXG5cdHRvSGV4U3RyaW5nKCB7IHIsIGcsIGIgfSwgcmdiU2NhbGUgPSAxICkge1xuXG5cdFx0cmdiU2NhbGUgPSAyNTUgLyByZ2JTY2FsZTtcblxuXHRcdGNvbnN0IGludCA9ICggciAqIHJnYlNjYWxlICkgPDwgMTYgXlxuXHRcdFx0KCBnICogcmdiU2NhbGUgKSA8PCA4IF5cblx0XHRcdCggYiAqIHJnYlNjYWxlICkgPDwgMDtcblxuXHRcdHJldHVybiBJTlQudG9IZXhTdHJpbmcoIGludCApO1xuXG5cdH1cbn07XG5cbmNvbnN0IEZPUk1BVFMgPSBbIFNUUklORywgSU5ULCBBUlJBWSwgT0JKRUNUIF07XG5cbmZ1bmN0aW9uIGdldENvbG9yRm9ybWF0KCB2YWx1ZSApIHtcblx0cmV0dXJuIEZPUk1BVFMuZmluZCggZm9ybWF0ID0+IGZvcm1hdC5tYXRjaCggdmFsdWUgKSApO1xufVxuXG5jbGFzcyBDb2xvckNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCByZ2JTY2FsZSApIHtcblxuXHRcdHN1cGVyKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksICdjb2xvcicgKTtcblxuXHRcdHRoaXMuJGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3R5cGUnLCAnY29sb3InICk7XG5cdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAndGFiaW5kZXgnLCAtMSApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG5cdFx0dGhpcy4kdGV4dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ3RleHQnICk7XG5cdFx0dGhpcy4kdGV4dC5zZXRBdHRyaWJ1dGUoICdzcGVsbGNoZWNrJywgJ2ZhbHNlJyApO1xuXHRcdHRoaXMuJHRleHQuc2V0QXR0cmlidXRlKCAnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy4kbmFtZS5pZCApO1xuXG5cdFx0dGhpcy4kZGlzcGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kZGlzcGxheS5jbGFzc0xpc3QuYWRkKCAnZGlzcGxheScgKTtcblxuXHRcdHRoaXMuJGRpc3BsYXkuYXBwZW5kQ2hpbGQoIHRoaXMuJGlucHV0ICk7XG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRkaXNwbGF5ICk7XG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiR0ZXh0ICk7XG5cblx0XHR0aGlzLl9mb3JtYXQgPSBnZXRDb2xvckZvcm1hdCggdGhpcy5pbml0aWFsVmFsdWUgKTtcblx0XHR0aGlzLl9yZ2JTY2FsZSA9IHJnYlNjYWxlO1xuXG5cdFx0dGhpcy5faW5pdGlhbFZhbHVlSGV4U3RyaW5nID0gdGhpcy5zYXZlKCk7XG5cdFx0dGhpcy5fdGV4dEZvY3VzZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsICgpID0+IHtcblx0XHRcdHRoaXMuX3NldFZhbHVlRnJvbUhleFN0cmluZyggdGhpcy4kaW5wdXQudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsICgpID0+IHtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJHRleHQuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgKCkgPT4ge1xuXHRcdFx0Y29uc3QgdHJ5UGFyc2UgPSBub3JtYWxpemVDb2xvclN0cmluZyggdGhpcy4kdGV4dC52YWx1ZSApO1xuXHRcdFx0aWYgKCB0cnlQYXJzZSApIHtcblx0XHRcdFx0dGhpcy5fc2V0VmFsdWVGcm9tSGV4U3RyaW5nKCB0cnlQYXJzZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMuJHRleHQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzJywgKCkgPT4ge1xuXHRcdFx0dGhpcy5fdGV4dEZvY3VzZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy4kdGV4dC5zZWxlY3QoKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiR0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgKCkgPT4ge1xuXHRcdFx0dGhpcy5fdGV4dEZvY3VzZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXHRcdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJHRleHQ7XG5cblx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHR9XG5cblx0cmVzZXQoKSB7XG5cdFx0dGhpcy5fc2V0VmFsdWVGcm9tSGV4U3RyaW5nKCB0aGlzLl9pbml0aWFsVmFsdWVIZXhTdHJpbmcgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9zZXRWYWx1ZUZyb21IZXhTdHJpbmcoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLl9mb3JtYXQuaXNQcmltaXRpdmUgKSB7XG5cblx0XHRcdGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5fZm9ybWF0LmZyb21IZXhTdHJpbmcoIHZhbHVlICk7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCBuZXdWYWx1ZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5fZm9ybWF0LmZyb21IZXhTdHJpbmcoIHZhbHVlLCB0aGlzLmdldFZhbHVlKCksIHRoaXMuX3JnYlNjYWxlICk7XG5cdFx0XHR0aGlzLl9jYWxsT25DaGFuZ2UoKTtcblx0XHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzYXZlKCkge1xuXHRcdHJldHVybiB0aGlzLl9mb3JtYXQudG9IZXhTdHJpbmcoIHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fcmdiU2NhbGUgKTtcblx0fVxuXG5cdGxvYWQoIHZhbHVlICkge1xuXHRcdHRoaXMuX3NldFZhbHVlRnJvbUhleFN0cmluZyggdmFsdWUgKTtcblx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHVwZGF0ZURpc3BsYXkoKSB7XG5cdFx0dGhpcy4kaW5wdXQudmFsdWUgPSB0aGlzLl9mb3JtYXQudG9IZXhTdHJpbmcoIHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fcmdiU2NhbGUgKTtcblx0XHRpZiAoICF0aGlzLl90ZXh0Rm9jdXNlZCApIHtcblx0XHRcdHRoaXMuJHRleHQudmFsdWUgPSB0aGlzLiRpbnB1dC52YWx1ZS5zdWJzdHJpbmcoIDEgKTtcblx0XHR9XG5cdFx0dGhpcy4kZGlzcGxheS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiRpbnB1dC52YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59XG5cbmNsYXNzIEZ1bmN0aW9uQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHkgKSB7XG5cblx0XHRzdXBlciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCAnZnVuY3Rpb24nICk7XG5cblx0XHQvLyBCdXR0b25zIGFyZSB0aGUgb25seSBjYXNlIHdoZXJlIHdpZGdldCBjb250YWlucyBuYW1lXG5cdFx0dGhpcy4kYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2J1dHRvbicgKTtcblx0XHR0aGlzLiRidXR0b24uYXBwZW5kQ2hpbGQoIHRoaXMuJG5hbWUgKTtcblx0XHR0aGlzLiR3aWRnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuJGJ1dHRvbiApO1xuXG5cdFx0dGhpcy4kYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGUgPT4ge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5nZXRWYWx1ZSgpLmNhbGwoIHRoaXMub2JqZWN0ICk7XG5cdFx0XHR0aGlzLl9jYWxsT25DaGFuZ2UoKTtcblx0XHR9ICk7XG5cblx0XHQvLyBlbmFibGVzIDphY3RpdmUgcHNldWRvIGNsYXNzIG9uIG1vYmlsZVxuXHRcdHRoaXMuJGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsICgpID0+IHt9LCB7IHBhc3NpdmU6IHRydWUgfSApO1xuXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJGJ1dHRvbjtcblxuXHR9XG5cbn1cblxuY2xhc3MgTnVtYmVyQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ251bWJlcicgKTtcblxuXHRcdHRoaXMuX2luaXRJbnB1dCgpO1xuXG5cdFx0dGhpcy5taW4oIG1pbiApO1xuXHRcdHRoaXMubWF4KCBtYXggKTtcblxuXHRcdGNvbnN0IHN0ZXBFeHBsaWNpdCA9IHN0ZXAgIT09IHVuZGVmaW5lZDtcblx0XHR0aGlzLnN0ZXAoIHN0ZXBFeHBsaWNpdCA/IHN0ZXAgOiB0aGlzLl9nZXRJbXBsaWNpdFN0ZXAoKSwgc3RlcEV4cGxpY2l0ICk7XG5cblx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHR9XG5cblx0ZGVjaW1hbHMoIGRlY2ltYWxzICkge1xuXHRcdHRoaXMuX2RlY2ltYWxzID0gZGVjaW1hbHM7XG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRtaW4oIG1pbiApIHtcblx0XHR0aGlzLl9taW4gPSBtaW47XG5cdFx0dGhpcy5fb25VcGRhdGVNaW5NYXgoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdG1heCggbWF4ICkge1xuXHRcdHRoaXMuX21heCA9IG1heDtcblx0XHR0aGlzLl9vblVwZGF0ZU1pbk1heCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c3RlcCggc3RlcCwgZXhwbGljaXQgPSB0cnVlICkge1xuXHRcdHRoaXMuX3N0ZXAgPSBzdGVwO1xuXHRcdHRoaXMuX3N0ZXBFeHBsaWNpdCA9IGV4cGxpY2l0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dXBkYXRlRGlzcGxheSgpIHtcblxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLl9oYXNTbGlkZXIgKSB7XG5cblx0XHRcdGxldCBwZXJjZW50ID0gKCB2YWx1ZSAtIHRoaXMuX21pbiApIC8gKCB0aGlzLl9tYXggLSB0aGlzLl9taW4gKTtcblx0XHRcdHBlcmNlbnQgPSBNYXRoLm1heCggMCwgTWF0aC5taW4oIHBlcmNlbnQsIDEgKSApO1xuXG5cdFx0XHR0aGlzLiRmaWxsLnN0eWxlLndpZHRoID0gcGVyY2VudCAqIDEwMCArICclJztcblxuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuX2lucHV0Rm9jdXNlZCApIHtcblx0XHRcdHRoaXMuJGlucHV0LnZhbHVlID0gdGhpcy5fZGVjaW1hbHMgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdmFsdWUudG9GaXhlZCggdGhpcy5fZGVjaW1hbHMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X2luaXRJbnB1dCgpIHtcblxuXHRcdHRoaXMuJGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3R5cGUnLCAndGV4dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHQvLyBPbiB0b3VjaCBkZXZpY2VzIG9ubHksIHVzZSBpbnB1dFt0eXBlPW51bWJlcl0gdG8gZm9yY2UgYSBudW1lcmljIGtleWJvYXJkLlxuXHRcdC8vIElkZWFsbHkgd2UgY291bGQgdXNlIG9uZSBpbnB1dCB0eXBlIGV2ZXJ5d2hlcmUsIGJ1dCBbdHlwZT1udW1iZXJdIGhhcyBxdWlya3Ncblx0XHQvLyBvbiBkZXNrdG9wLCBhbmQgW2lucHV0bW9kZT1kZWNpbWFsXSBoYXMgcXVpcmtzIG9uIGlPUy5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dlb3JnZWFsd2F5cy9saWwtZ3VpL3B1bGwvMTZcblxuXHRcdGNvbnN0IGlzVG91Y2ggPSB3aW5kb3cubWF0Y2hNZWRpYSggJyhwb2ludGVyOiBjb2Fyc2UpJyApLm1hdGNoZXM7XG5cblx0XHRpZiAoIGlzVG91Y2ggKSB7XG5cdFx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ251bWJlcicgKTtcblx0XHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3N0ZXAnLCAnYW55JyApO1xuXHRcdH1cblxuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kaW5wdXQgKTtcblxuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiRpbnB1dDtcblxuXHRcdGNvbnN0IG9uSW5wdXQgPSAoKSA9PiB7XG5cblx0XHRcdGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoIHRoaXMuJGlucHV0LnZhbHVlICk7XG5cblx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSByZXR1cm47XG5cblx0XHRcdGlmICggdGhpcy5fc3RlcEV4cGxpY2l0ICkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX3NuYXAoIHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMuX2NsYW1wKCB2YWx1ZSApICk7XG5cblx0XHR9O1xuXG5cdFx0Ly8gS2V5cyAmIG1vdXNlIHdoZWVsXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRjb25zdCBpbmNyZW1lbnQgPSBkZWx0YSA9PiB7XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdCggdGhpcy4kaW5wdXQudmFsdWUgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHJldHVybjtcblxuXHRcdFx0dGhpcy5fc25hcENsYW1wU2V0VmFsdWUoIHZhbHVlICsgZGVsdGEgKTtcblxuXHRcdFx0Ly8gRm9yY2UgdGhlIGlucHV0IHRvIHVwZGF0ZURpc3BsYXkgd2hlbiBpdCdzIGZvY3VzZWRcblx0XHRcdHRoaXMuJGlucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uS2V5RG93biA9IGUgPT4ge1xuXHRcdFx0Ly8gVXNpbmcgYGUua2V5YCBpbnN0ZWFkIG9mIGBlLmNvZGVgIGFsc28gY2F0Y2hlcyBOdW1wYWRFbnRlclxuXHRcdFx0aWYgKCBlLmtleSA9PT0gJ0VudGVyJyApIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQuYmx1cigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBlLmNvZGUgPT09ICdBcnJvd1VwJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRpbmNyZW1lbnQoIHRoaXMuX3N0ZXAgKiB0aGlzLl9hcnJvd0tleU11bHRpcGxpZXIoIGUgKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBlLmNvZGUgPT09ICdBcnJvd0Rvd24nICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGluY3JlbWVudCggdGhpcy5fc3RlcCAqIHRoaXMuX2Fycm93S2V5TXVsdGlwbGllciggZSApICogLTEgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25XaGVlbCA9IGUgPT4ge1xuXHRcdFx0aWYgKCB0aGlzLl9pbnB1dEZvY3VzZWQgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0aW5jcmVtZW50KCB0aGlzLl9zdGVwICogdGhpcy5fbm9ybWFsaXplTW91c2VXaGVlbCggZSApICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFZlcnRpY2FsIGRyYWdcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdGxldCB0ZXN0aW5nRm9yVmVydGljYWxEcmFnID0gZmFsc2UsXG5cdFx0XHRpbml0Q2xpZW50WCxcblx0XHRcdGluaXRDbGllbnRZLFxuXHRcdFx0cHJldkNsaWVudFksXG5cdFx0XHRpbml0VmFsdWUsXG5cdFx0XHRkcmFnRGVsdGE7XG5cblx0XHQvLyBPbmNlIHRoZSBtb3VzZSBpcyBkcmFnZ2VkIG1vcmUgdGhhbiBEUkFHX1RIUkVTSCBweCBvbiBhbnkgYXhpcywgd2UgZGVjaWRlXG5cdFx0Ly8gb24gdGhlIHVzZXIncyBpbnRlbnQ6IGhvcml6b250YWwgbWVhbnMgaGlnaGxpZ2h0LCB2ZXJ0aWNhbCBtZWFucyBkcmFnLlxuXHRcdGNvbnN0IERSQUdfVEhSRVNIID0gNTtcblxuXHRcdGNvbnN0IG9uTW91c2VEb3duID0gZSA9PiB7XG5cblx0XHRcdGluaXRDbGllbnRYID0gZS5jbGllbnRYO1xuXHRcdFx0aW5pdENsaWVudFkgPSBwcmV2Q2xpZW50WSA9IGUuY2xpZW50WTtcblx0XHRcdHRlc3RpbmdGb3JWZXJ0aWNhbERyYWcgPSB0cnVlO1xuXG5cdFx0XHRpbml0VmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRkcmFnRGVsdGEgPSAwO1xuXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAgKTtcblxuXHRcdH07XG5cblx0XHRjb25zdCBvbk1vdXNlTW92ZSA9IGUgPT4ge1xuXG5cdFx0XHRpZiAoIHRlc3RpbmdGb3JWZXJ0aWNhbERyYWcgKSB7XG5cblx0XHRcdFx0Y29uc3QgZHggPSBlLmNsaWVudFggLSBpbml0Q2xpZW50WDtcblx0XHRcdFx0Y29uc3QgZHkgPSBlLmNsaWVudFkgLSBpbml0Q2xpZW50WTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBkeSApID4gRFJBR19USFJFU0ggKSB7XG5cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0dGhpcy4kaW5wdXQuYmx1cigpO1xuXHRcdFx0XHRcdHRlc3RpbmdGb3JWZXJ0aWNhbERyYWcgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLl9zZXREcmFnZ2luZ1N0eWxlKCB0cnVlLCAndmVydGljYWwnICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIGR4ICkgPiBEUkFHX1RIUkVTSCApIHtcblxuXHRcdFx0XHRcdG9uTW91c2VVcCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGlzIGlzbid0IGFuIGVsc2Ugc28gdGhhdCB0aGUgZmlyc3QgbW92ZSBjb3VudHMgdG93YXJkcyBkcmFnRGVsdGFcblx0XHRcdGlmICggIXRlc3RpbmdGb3JWZXJ0aWNhbERyYWcgKSB7XG5cblx0XHRcdFx0Y29uc3QgZHkgPSBlLmNsaWVudFkgLSBwcmV2Q2xpZW50WTtcblxuXHRcdFx0XHRkcmFnRGVsdGEgLT0gZHkgKiB0aGlzLl9zdGVwICogdGhpcy5fYXJyb3dLZXlNdWx0aXBsaWVyKCBlICk7XG5cblx0XHRcdFx0Ly8gQ2xhbXAgZHJhZ0RlbHRhIHNvIHdlIGRvbid0IGhhdmUgJ2RlYWQgc3BhY2UnIGFmdGVyIGRyYWdnaW5nIHBhc3QgYm91bmRzLlxuXHRcdFx0XHQvLyBXZSdyZSBva2F5IHdpdGggdGhlIGZhY3QgdGhhdCBib3VuZHMgY2FuIGJlIHVuZGVmaW5lZCBoZXJlLlxuXHRcdFx0XHRpZiAoIGluaXRWYWx1ZSArIGRyYWdEZWx0YSA+IHRoaXMuX21heCApIHtcblx0XHRcdFx0XHRkcmFnRGVsdGEgPSB0aGlzLl9tYXggLSBpbml0VmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGluaXRWYWx1ZSArIGRyYWdEZWx0YSA8IHRoaXMuX21pbiApIHtcblx0XHRcdFx0XHRkcmFnRGVsdGEgPSB0aGlzLl9taW4gLSBpbml0VmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zbmFwQ2xhbXBTZXRWYWx1ZSggaW5pdFZhbHVlICsgZHJhZ0RlbHRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cHJldkNsaWVudFkgPSBlLmNsaWVudFk7XG5cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25Nb3VzZVVwID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggZmFsc2UsICd2ZXJ0aWNhbCcgKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSApO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwICk7XG5cdFx0fTtcblxuXHRcdC8vIEZvY3VzIHN0YXRlICYgb25GaW5pc2hDaGFuZ2Vcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9pbnB1dEZvY3VzZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRjb25zdCBvbkJsdXIgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9pbnB1dEZvY3VzZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXHRcdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIG9uSW5wdXQgKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biApO1xuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSApO1xuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biApO1xuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsIG9uRm9jdXMgKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIG9uQmx1ciApO1xuXG5cdH1cblxuXHRfaW5pdFNsaWRlcigpIHtcblxuXHRcdHRoaXMuX2hhc1NsaWRlciA9IHRydWU7XG5cblx0XHQvLyBCdWlsZCBET01cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHRoaXMuJHNsaWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kc2xpZGVyLmNsYXNzTGlzdC5hZGQoICdzbGlkZXInICk7XG5cblx0XHR0aGlzLiRmaWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR0aGlzLiRmaWxsLmNsYXNzTGlzdC5hZGQoICdmaWxsJyApO1xuXG5cdFx0dGhpcy4kc2xpZGVyLmFwcGVuZENoaWxkKCB0aGlzLiRmaWxsICk7XG5cdFx0dGhpcy4kd2lkZ2V0Lmluc2VydEJlZm9yZSggdGhpcy4kc2xpZGVyLCB0aGlzLiRpbnB1dCApO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICdoYXNTbGlkZXInICk7XG5cblx0XHQvLyBNYXAgY2xpZW50WCB0byB2YWx1ZVxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Y29uc3QgbWFwID0gKCB2LCBhLCBiLCBjLCBkICkgPT4ge1xuXHRcdFx0cmV0dXJuICggdiAtIGEgKSAvICggYiAtIGEgKSAqICggZCAtIGMgKSArIGM7XG5cdFx0fTtcblxuXHRcdGNvbnN0IHNldFZhbHVlRnJvbVggPSBjbGllbnRYID0+IHtcblx0XHRcdGNvbnN0IHJlY3QgPSB0aGlzLiRzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRsZXQgdmFsdWUgPSBtYXAoIGNsaWVudFgsIHJlY3QubGVmdCwgcmVjdC5yaWdodCwgdGhpcy5fbWluLCB0aGlzLl9tYXggKTtcblx0XHRcdHRoaXMuX3NuYXBDbGFtcFNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdH07XG5cblx0XHQvLyBNb3VzZSBkcmFnXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRjb25zdCBtb3VzZURvd24gPSBlID0+IHtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIHRydWUgKTtcblx0XHRcdHNldFZhbHVlRnJvbVgoIGUuY2xpZW50WCApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3VzZU1vdmUgKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG1vdXNlVXAgKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgbW91c2VNb3ZlID0gZSA9PiB7XG5cdFx0XHRzZXRWYWx1ZUZyb21YKCBlLmNsaWVudFggKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgbW91c2VVcCA9ICgpID0+IHtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggZmFsc2UgKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBtb3VzZVVwICk7XG5cdFx0fTtcblxuXHRcdC8vIFRvdWNoIGRyYWdcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdGxldCB0ZXN0aW5nRm9yU2Nyb2xsID0gZmFsc2UsIHByZXZDbGllbnRYLCBwcmV2Q2xpZW50WTtcblxuXHRcdGNvbnN0IGJlZ2luVG91Y2hEcmFnID0gZSA9PiB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLl9zZXREcmFnZ2luZ1N0eWxlKCB0cnVlICk7XG5cdFx0XHRzZXRWYWx1ZUZyb21YKCBlLnRvdWNoZXNbIDAgXS5jbGllbnRYICk7XG5cdFx0XHR0ZXN0aW5nRm9yU2Nyb2xsID0gZmFsc2U7XG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uVG91Y2hTdGFydCA9IGUgPT4ge1xuXG5cdFx0XHRpZiAoIGUudG91Y2hlcy5sZW5ndGggPiAxICkgcmV0dXJuO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBpbiBhIHNjcm9sbGFibGUgY29udGFpbmVyLCB3ZSBzaG91bGQgd2FpdCBmb3IgdGhlIGZpcnN0XG5cdFx0XHQvLyB0b3VjaG1vdmUgdG8gc2VlIGlmIHRoZSB1c2VyIGlzIHRyeWluZyB0byBzbGlkZSBvciBzY3JvbGwuXG5cdFx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbEJhciApIHtcblxuXHRcdFx0XHRwcmV2Q2xpZW50WCA9IGUudG91Y2hlc1sgMCBdLmNsaWVudFg7XG5cdFx0XHRcdHByZXZDbGllbnRZID0gZS50b3VjaGVzWyAwIF0uY2xpZW50WTtcblx0XHRcdFx0dGVzdGluZ0ZvclNjcm9sbCA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB3ZSBjYW4gc2V0IHRoZSB2YWx1ZSBzdHJhaWdodCBhd2F5IG9uIHRvdWNoc3RhcnQuXG5cdFx0XHRcdGJlZ2luVG91Y2hEcmFnKCBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9ICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCApO1xuXG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uVG91Y2hNb3ZlID0gZSA9PiB7XG5cblx0XHRcdGlmICggdGVzdGluZ0ZvclNjcm9sbCApIHtcblxuXHRcdFx0XHRjb25zdCBkeCA9IGUudG91Y2hlc1sgMCBdLmNsaWVudFggLSBwcmV2Q2xpZW50WDtcblx0XHRcdFx0Y29uc3QgZHkgPSBlLnRvdWNoZXNbIDAgXS5jbGllbnRZIC0gcHJldkNsaWVudFk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZHggKSA+IE1hdGguYWJzKCBkeSApICkge1xuXG5cdFx0XHRcdFx0Ly8gV2UgbW92ZWQgaG9yaXpvbnRhbGx5LCBzZXQgdGhlIHZhbHVlIGFuZCBzdG9wIGNoZWNraW5nLlxuXHRcdFx0XHRcdGJlZ2luVG91Y2hEcmFnKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFRoaXMgd2FzLCBpbiBmYWN0LCBhbiBhdHRlbXB0IHRvIHNjcm9sbC4gQWJvcnQuXG5cdFx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSApO1xuXHRcdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0c2V0VmFsdWVGcm9tWCggZS50b3VjaGVzWyAwIF0uY2xpZW50WCApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25Ub3VjaEVuZCA9ICgpID0+IHtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggZmFsc2UgKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUgKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kICk7XG5cdFx0fTtcblxuXHRcdC8vIE1vdXNlIHdoZWVsXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHQvLyBXZSBoYXZlIHRvIHVzZSBhIGRlYm91bmNlZCBmdW5jdGlvbiB0byBjYWxsIG9uRmluaXNoQ2hhbmdlIGJlY2F1c2Vcblx0XHQvLyB0aGVyZSdzIG5vIHdheSB0byB0ZWxsIHdoZW4gdGhlIHVzZXIgaXMgXCJkb25lXCIgbW91c2Utd2hlZWxpbmcuXG5cdFx0Y29uc3QgY2FsbE9uRmluaXNoQ2hhbmdlID0gdGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlLmJpbmQoIHRoaXMgKTtcblx0XHRjb25zdCBXSEVFTF9ERUJPVU5DRV9USU1FID0gNDAwO1xuXHRcdGxldCB3aGVlbEZpbmlzaENoYW5nZVRpbWVvdXQ7XG5cblx0XHRjb25zdCBvbldoZWVsID0gZSA9PiB7XG5cblx0XHRcdC8vIGlnbm9yZSB2ZXJ0aWNhbCB3aGVlbHMgaWYgdGhlcmUncyBhIHNjcm9sbGJhclxuXHRcdFx0Y29uc3QgaXNWZXJ0aWNhbCA9IE1hdGguYWJzKCBlLmRlbHRhWCApIDwgTWF0aC5hYnMoIGUuZGVsdGFZICk7XG5cdFx0XHRpZiAoIGlzVmVydGljYWwgJiYgdGhpcy5faGFzU2Nyb2xsQmFyICkgcmV0dXJuO1xuXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdC8vIHNldCB2YWx1ZVxuXHRcdFx0Y29uc3QgZGVsdGEgPSB0aGlzLl9ub3JtYWxpemVNb3VzZVdoZWVsKCBlICkgKiB0aGlzLl9zdGVwO1xuXHRcdFx0dGhpcy5fc25hcENsYW1wU2V0VmFsdWUoIHRoaXMuZ2V0VmFsdWUoKSArIGRlbHRhICk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBpbnB1dCB0byB1cGRhdGVEaXNwbGF5IHdoZW4gaXQncyBmb2N1c2VkXG5cdFx0XHR0aGlzLiRpbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRcdFx0Ly8gZGVib3VuY2Ugb25GaW5pc2hDaGFuZ2Vcblx0XHRcdGNsZWFyVGltZW91dCggd2hlZWxGaW5pc2hDaGFuZ2VUaW1lb3V0ICk7XG5cdFx0XHR3aGVlbEZpbmlzaENoYW5nZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCBjYWxsT25GaW5pc2hDaGFuZ2UsIFdIRUVMX0RFQk9VTkNFX1RJTUUgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLiRzbGlkZXIuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG1vdXNlRG93biApO1xuXHRcdHRoaXMuJHNsaWRlci5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgeyBwYXNzaXZlOiBmYWxzZSB9ICk7XG5cdFx0dGhpcy4kc2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSApO1xuXG5cdH1cblxuXHRfc2V0RHJhZ2dpbmdTdHlsZSggYWN0aXZlLCBheGlzID0gJ2hvcml6b250YWwnICkge1xuXHRcdGlmICggdGhpcy4kc2xpZGVyICkge1xuXHRcdFx0dGhpcy4kc2xpZGVyLmNsYXNzTGlzdC50b2dnbGUoICdhY3RpdmUnLCBhY3RpdmUgKTtcblx0XHR9XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QudG9nZ2xlKCAnbGlsLWd1aS1kcmFnZ2luZycsIGFjdGl2ZSApO1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSggYGxpbC1ndWktJHtheGlzfWAsIGFjdGl2ZSApO1xuXHR9XG5cblx0X2dldEltcGxpY2l0U3RlcCgpIHtcblxuXHRcdGlmICggdGhpcy5faGFzTWluICYmIHRoaXMuX2hhc01heCApIHtcblx0XHRcdHJldHVybiAoIHRoaXMuX21heCAtIHRoaXMuX21pbiApIC8gMTAwMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gMC4xO1xuXG5cdH1cblxuXHRfb25VcGRhdGVNaW5NYXgoKSB7XG5cblx0XHRpZiAoICF0aGlzLl9oYXNTbGlkZXIgJiYgdGhpcy5faGFzTWluICYmIHRoaXMuX2hhc01heCApIHtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBoZWFyaW5nIGFib3V0IG1pbiBhbmQgbWF4XG5cdFx0XHQvLyBhbmQgd2UgaGF2ZW4ndCBleHBsaWNpdGx5IHN0YXRlZCB3aGF0IG91ciBzdGVwIGlzLCBsZXQnc1xuXHRcdFx0Ly8gdXBkYXRlIHRoYXQgdG9vLlxuXHRcdFx0aWYgKCAhdGhpcy5fc3RlcEV4cGxpY2l0ICkge1xuXHRcdFx0XHR0aGlzLnN0ZXAoIHRoaXMuX2dldEltcGxpY2l0U3RlcCgpLCBmYWxzZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9pbml0U2xpZGVyKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0X25vcm1hbGl6ZU1vdXNlV2hlZWwoIGUgKSB7XG5cblx0XHRsZXQgeyBkZWx0YVgsIGRlbHRhWSB9ID0gZTtcblxuXHRcdC8vIFNhZmFyaSBhbmQgQ2hyb21lIHJlcG9ydCB3ZWlyZCBub24taW50ZWdyYWwgdmFsdWVzIGZvciBhIG5vdGNoZWQgd2hlZWwsXG5cdFx0Ly8gYnV0IHN0aWxsIGV4cG9zZSBhY3R1YWwgbGluZXMgc2Nyb2xsZWQgdmlhIHdoZWVsRGVsdGEuIE5vdGNoZWQgd2hlZWxzXG5cdFx0Ly8gc2hvdWxkIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgYXJyb3cga2V5cy5cblx0XHRpZiAoIE1hdGguZmxvb3IoIGUuZGVsdGFZICkgIT09IGUuZGVsdGFZICYmIGUud2hlZWxEZWx0YSApIHtcblx0XHRcdGRlbHRhWCA9IDA7XG5cdFx0XHRkZWx0YVkgPSAtZS53aGVlbERlbHRhIC8gMTIwO1xuXHRcdFx0ZGVsdGFZICo9IHRoaXMuX3N0ZXBFeHBsaWNpdCA/IDEgOiAxMDtcblx0XHR9XG5cblx0XHRjb25zdCB3aGVlbCA9IGRlbHRhWCArIC1kZWx0YVk7XG5cblx0XHRyZXR1cm4gd2hlZWw7XG5cblx0fVxuXG5cdF9hcnJvd0tleU11bHRpcGxpZXIoIGUgKSB7XG5cblx0XHRsZXQgbXVsdCA9IHRoaXMuX3N0ZXBFeHBsaWNpdCA/IDEgOiAxMDtcblxuXHRcdGlmICggZS5zaGlmdEtleSApIHtcblx0XHRcdG11bHQgKj0gMTA7XG5cdFx0fSBlbHNlIGlmICggZS5hbHRLZXkgKSB7XG5cdFx0XHRtdWx0IC89IDEwO1xuXHRcdH1cblxuXHRcdHJldHVybiBtdWx0O1xuXG5cdH1cblxuXHRfc25hcCggdmFsdWUgKSB7XG5cblx0XHQvLyBUaGlzIHdvdWxkIGJlIHRoZSBsb2dpY2FsIHdheSB0byBkbyB0aGluZ3MsIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMuXG5cdFx0Ly8gcmV0dXJuIE1hdGgucm91bmQoIHZhbHVlIC8gdGhpcy5fc3RlcCApICogdGhpcy5fc3RlcDtcblxuXHRcdC8vIFVzaW5nIGludmVyc2Ugc3RlcCBzb2x2ZXMgYSBsb3Qgb2YgdGhlbSwgYnV0IG5vdCBhbGxcblx0XHQvLyBjb25zdCBpbnZlcnNlU3RlcCA9IDEgLyB0aGlzLl9zdGVwO1xuXHRcdC8vIHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIGludmVyc2VTdGVwICkgLyBpbnZlcnNlU3RlcDtcblxuXHRcdC8vIE5vdCBoYXBweSBhYm91dCB0aGlzLCBidXQgaGF2ZW4ndCBzZWVuIGl0IGJyZWFrLlxuXHRcdGNvbnN0IHIgPSBNYXRoLnJvdW5kKCB2YWx1ZSAvIHRoaXMuX3N0ZXAgKSAqIHRoaXMuX3N0ZXA7XG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoIHIudG9QcmVjaXNpb24oIDE1ICkgKTtcblxuXHR9XG5cblx0X2NsYW1wKCB2YWx1ZSApIHtcblx0XHQvLyBlaXRoZXIgY29uZGl0aW9uIGlzIGZhbHNlIGlmIG1pbiBvciBtYXggaXMgdW5kZWZpbmVkXG5cdFx0aWYgKCB2YWx1ZSA8IHRoaXMuX21pbiApIHZhbHVlID0gdGhpcy5fbWluO1xuXHRcdGlmICggdmFsdWUgPiB0aGlzLl9tYXggKSB2YWx1ZSA9IHRoaXMuX21heDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRfc25hcENsYW1wU2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMuX2NsYW1wKCB0aGlzLl9zbmFwKCB2YWx1ZSApICkgKTtcblx0fVxuXG5cdGdldCBfaGFzU2Nyb2xsQmFyKCkge1xuXHRcdGNvbnN0IHJvb3QgPSB0aGlzLnBhcmVudC5yb290LiRjaGlsZHJlbjtcblx0XHRyZXR1cm4gcm9vdC5zY3JvbGxIZWlnaHQgPiByb290LmNsaWVudEhlaWdodDtcblx0fVxuXG5cdGdldCBfaGFzTWluKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW4gIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdGdldCBfaGFzTWF4KCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXggIT09IHVuZGVmaW5lZDtcblx0fVxuXG59XG5cbmNsYXNzIE9wdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCBvcHRpb25zICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ29wdGlvbicgKTtcblxuXHRcdHRoaXMuJHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzZWxlY3QnICk7XG5cdFx0dGhpcy4kc2VsZWN0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJGRpc3BsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJGRpc3BsYXkuY2xhc3NMaXN0LmFkZCggJ2Rpc3BsYXknICk7XG5cblx0XHR0aGlzLiRzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsICgpID0+IHtcblx0XHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMuX3ZhbHVlc1sgdGhpcy4kc2VsZWN0LnNlbGVjdGVkSW5kZXggXSApO1xuXHRcdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsICgpID0+IHtcblx0XHRcdHRoaXMuJGRpc3BsYXkuY2xhc3NMaXN0LmFkZCggJ2ZvY3VzJyApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsICgpID0+IHtcblx0XHRcdHRoaXMuJGRpc3BsYXkuY2xhc3NMaXN0LnJlbW92ZSggJ2ZvY3VzJyApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kc2VsZWN0ICk7XG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRkaXNwbGF5ICk7XG5cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kc2VsZWN0O1xuXG5cdFx0dGhpcy5vcHRpb25zKCBvcHRpb25zICk7XG5cblx0fVxuXG5cdG9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cblx0XHR0aGlzLl92YWx1ZXMgPSBBcnJheS5pc0FycmF5KCBvcHRpb25zICkgPyBvcHRpb25zIDogT2JqZWN0LnZhbHVlcyggb3B0aW9ucyApO1xuXHRcdHRoaXMuX25hbWVzID0gQXJyYXkuaXNBcnJheSggb3B0aW9ucyApID8gb3B0aW9ucyA6IE9iamVjdC5rZXlzKCBvcHRpb25zICk7XG5cblx0XHR0aGlzLiRzZWxlY3QucmVwbGFjZUNoaWxkcmVuKCk7XG5cblx0XHR0aGlzLl9uYW1lcy5mb3JFYWNoKCBuYW1lID0+IHtcblx0XHRcdGNvbnN0ICRvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnb3B0aW9uJyApO1xuXHRcdFx0JG9wdGlvbi5pbm5lckhUTUwgPSBuYW1lO1xuXHRcdFx0dGhpcy4kc2VsZWN0LmFwcGVuZENoaWxkKCAkb3B0aW9uICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuX3ZhbHVlcy5pbmRleE9mKCB2YWx1ZSApO1xuXHRcdHRoaXMuJHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG5cdFx0dGhpcy4kZGlzcGxheS5pbm5lckhUTUwgPSBpbmRleCA9PT0gLTEgPyB2YWx1ZSA6IHRoaXMuX25hbWVzWyBpbmRleCBdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuY2xhc3MgU3RyaW5nQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHkgKSB7XG5cblx0XHRzdXBlciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCAnc3RyaW5nJyApO1xuXG5cdFx0dGhpcy4kaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG5cdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAndHlwZScsICd0ZXh0JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsICgpID0+IHtcblx0XHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMuJGlucHV0LnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBlID0+IHtcblx0XHRcdGlmICggZS5jb2RlID09PSAnRW50ZXInICkge1xuXHRcdFx0XHR0aGlzLiRpbnB1dC5ibHVyKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiR3aWRnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuJGlucHV0ICk7XG5cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kaW5wdXQ7XG5cblx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHR9XG5cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHR0aGlzLiRpbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59XG5cbmNvbnN0IHN0eWxlc2hlZXQgPSBgLmxpbC1ndWkge1xuICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHkpO1xuICBmb250LXNpemU6IHZhcigtLWZvbnQtc2l6ZSk7XG4gIGxpbmUtaGVpZ2h0OiAxO1xuICBmb250LXdlaWdodDogbm9ybWFsO1xuICBmb250LXN0eWxlOiBub3JtYWw7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG4gIGNvbG9yOiB2YXIoLS10ZXh0LWNvbG9yKTtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xuICAtLWJhY2tncm91bmQtY29sb3I6ICMxZjFmMWY7XG4gIC0tdGV4dC1jb2xvcjogI2ViZWJlYjtcbiAgLS10aXRsZS1iYWNrZ3JvdW5kLWNvbG9yOiAjMTExMTExO1xuICAtLXRpdGxlLXRleHQtY29sb3I6ICNlYmViZWI7XG4gIC0td2lkZ2V0LWNvbG9yOiAjNDI0MjQyO1xuICAtLWhvdmVyLWNvbG9yOiAjNGY0ZjRmO1xuICAtLWZvY3VzLWNvbG9yOiAjNTk1OTU5O1xuICAtLW51bWJlci1jb2xvcjogIzJjYzlmZjtcbiAgLS1zdHJpbmctY29sb3I6ICNhMmRiM2M7XG4gIC0tZm9udC1zaXplOiAxMXB4O1xuICAtLWlucHV0LWZvbnQtc2l6ZTogMTFweDtcbiAgLS1mb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90bywgQXJpYWwsIHNhbnMtc2VyaWY7XG4gIC0tZm9udC1mYW1pbHktbW9ubzogTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFwiRHJvaWQgU2FucyBNb25vXCIsIG1vbm9zcGFjZTtcbiAgLS1wYWRkaW5nOiA0cHg7XG4gIC0tc3BhY2luZzogNHB4O1xuICAtLXdpZGdldC1oZWlnaHQ6IDIwcHg7XG4gIC0tdGl0bGUtaGVpZ2h0OiBjYWxjKHZhcigtLXdpZGdldC1oZWlnaHQpICsgdmFyKC0tc3BhY2luZykgKiAxLjI1KTtcbiAgLS1uYW1lLXdpZHRoOiA0NSU7XG4gIC0tc2xpZGVyLWtub2Itd2lkdGg6IDJweDtcbiAgLS1zbGlkZXItaW5wdXQtd2lkdGg6IDI3JTtcbiAgLS1jb2xvci1pbnB1dC13aWR0aDogMjclO1xuICAtLXNsaWRlci1pbnB1dC1taW4td2lkdGg6IDQ1cHg7XG4gIC0tY29sb3ItaW5wdXQtbWluLXdpZHRoOiA0NXB4O1xuICAtLWZvbGRlci1pbmRlbnQ6IDdweDtcbiAgLS13aWRnZXQtcGFkZGluZzogMCAwIDAgM3B4O1xuICAtLXdpZGdldC1ib3JkZXItcmFkaXVzOiAycHg7XG4gIC0tY2hlY2tib3gtc2l6ZTogY2FsYygwLjc1ICogdmFyKC0td2lkZ2V0LWhlaWdodCkpO1xuICAtLXNjcm9sbGJhci13aWR0aDogNXB4O1xufVxuLmxpbC1ndWksIC5saWwtZ3VpICoge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG59XG4ubGlsLWd1aS5yb290IHtcbiAgd2lkdGg6IHZhcigtLXdpZHRoLCAyNDVweCk7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGJhY2tncm91bmQ6IHZhcigtLWJhY2tncm91bmQtY29sb3IpO1xufVxuLmxpbC1ndWkucm9vdCA+IC50aXRsZSB7XG4gIGJhY2tncm91bmQ6IHZhcigtLXRpdGxlLWJhY2tncm91bmQtY29sb3IpO1xuICBjb2xvcjogdmFyKC0tdGl0bGUtdGV4dC1jb2xvcik7XG59XG4ubGlsLWd1aS5yb290ID4gLmNoaWxkcmVuIHtcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICBvdmVyZmxvdy15OiBhdXRvO1xufVxuLmxpbC1ndWkucm9vdCA+IC5jaGlsZHJlbjo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICB3aWR0aDogdmFyKC0tc2Nyb2xsYmFyLXdpZHRoKTtcbiAgaGVpZ2h0OiB2YXIoLS1zY3JvbGxiYXItd2lkdGgpO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLWNvbG9yKTtcbn1cbi5saWwtZ3VpLnJvb3QgPiAuY2hpbGRyZW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2Nyb2xsYmFyLXdpZHRoKTtcbiAgYmFja2dyb3VuZDogdmFyKC0tZm9jdXMtY29sb3IpO1xufVxuQG1lZGlhIChwb2ludGVyOiBjb2Fyc2UpIHtcbiAgLmxpbC1ndWkuYWxsb3ctdG91Y2gtc3R5bGVzLCAubGlsLWd1aS5hbGxvdy10b3VjaC1zdHlsZXMgLmxpbC1ndWkge1xuICAgIC0td2lkZ2V0LWhlaWdodDogMjhweDtcbiAgICAtLXBhZGRpbmc6IDZweDtcbiAgICAtLXNwYWNpbmc6IDZweDtcbiAgICAtLWZvbnQtc2l6ZTogMTNweDtcbiAgICAtLWlucHV0LWZvbnQtc2l6ZTogMTZweDtcbiAgICAtLWZvbGRlci1pbmRlbnQ6IDEwcHg7XG4gICAgLS1zY3JvbGxiYXItd2lkdGg6IDdweDtcbiAgICAtLXNsaWRlci1pbnB1dC1taW4td2lkdGg6IDUwcHg7XG4gICAgLS1jb2xvci1pbnB1dC1taW4td2lkdGg6IDY1cHg7XG4gIH1cbn1cbi5saWwtZ3VpLmZvcmNlLXRvdWNoLXN0eWxlcywgLmxpbC1ndWkuZm9yY2UtdG91Y2gtc3R5bGVzIC5saWwtZ3VpIHtcbiAgLS13aWRnZXQtaGVpZ2h0OiAyOHB4O1xuICAtLXBhZGRpbmc6IDZweDtcbiAgLS1zcGFjaW5nOiA2cHg7XG4gIC0tZm9udC1zaXplOiAxM3B4O1xuICAtLWlucHV0LWZvbnQtc2l6ZTogMTZweDtcbiAgLS1mb2xkZXItaW5kZW50OiAxMHB4O1xuICAtLXNjcm9sbGJhci13aWR0aDogN3B4O1xuICAtLXNsaWRlci1pbnB1dC1taW4td2lkdGg6IDUwcHg7XG4gIC0tY29sb3ItaW5wdXQtbWluLXdpZHRoOiA2NXB4O1xufVxuLmxpbC1ndWkuYXV0b1BsYWNlIHtcbiAgbWF4LWhlaWdodDogMTAwJTtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDA7XG4gIHJpZ2h0OiAxNXB4O1xuICB6LWluZGV4OiAxMDAxO1xufVxuXG4ubGlsLWd1aSAuY29udHJvbGxlciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHBhZGRpbmc6IDAgdmFyKC0tcGFkZGluZyk7XG4gIG1hcmdpbjogdmFyKC0tc3BhY2luZykgMDtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLmRpc2FibGVkIHtcbiAgb3BhY2l0eTogMC41O1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuZGlzYWJsZWQsIC5saWwtZ3VpIC5jb250cm9sbGVyLmRpc2FibGVkICoge1xuICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIgPiAubmFtZSB7XG4gIG1pbi13aWR0aDogdmFyKC0tbmFtZS13aWR0aCk7XG4gIGZsZXgtc2hyaW5rOiAwO1xuICB3aGl0ZS1zcGFjZTogcHJlO1xuICBwYWRkaW5nLXJpZ2h0OiB2YXIoLS1zcGFjaW5nKTtcbiAgbGluZS1oZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIgLndpZGdldCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgd2lkdGg6IDEwMCU7XG4gIG1pbi1oZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuc3RyaW5nIGlucHV0IHtcbiAgY29sb3I6IHZhcigtLXN0cmluZy1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5ib29sZWFuIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuY29sb3IgLmRpc3BsYXkge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5AbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAubGlsLWd1aSAuY29udHJvbGxlci5jb2xvciAuZGlzcGxheTpob3ZlcjpiZWZvcmUge1xuICAgIGNvbnRlbnQ6IFwiIFwiO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS13aWRnZXQtYm9yZGVyLXJhZGl1cyk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZjk7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICB9XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5jb2xvciBpbnB1dFt0eXBlPWNvbG9yXSB7XG4gIG9wYWNpdHk6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLmNvbG9yIGlucHV0W3R5cGU9dGV4dF0ge1xuICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2luZyk7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseS1tb25vKTtcbiAgbWluLXdpZHRoOiB2YXIoLS1jb2xvci1pbnB1dC1taW4td2lkdGgpO1xuICB3aWR0aDogdmFyKC0tY29sb3ItaW5wdXQtd2lkdGgpO1xuICBmbGV4LXNocmluazogMDtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm9wdGlvbiBzZWxlY3Qge1xuICBvcGFjaXR5OiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXgtd2lkdGg6IDEwMCU7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gLmRpc3BsYXkge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS13aWRnZXQtYm9yZGVyLXJhZGl1cyk7XG4gIGhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIGxpbmUtaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB3b3JkLWJyZWFrOiBicmVhay1hbGw7XG4gIHBhZGRpbmctbGVmdDogMC41NWVtO1xuICBwYWRkaW5nLXJpZ2h0OiAxLjc1ZW07XG4gIGJhY2tncm91bmQ6IHZhcigtLXdpZGdldC1jb2xvcik7XG59XG5AbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gLmRpc3BsYXkuZm9jdXMge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbiAgfVxufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC5kaXNwbGF5LmFjdGl2ZSB7XG4gIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm9wdGlvbiAuZGlzcGxheTphZnRlciB7XG4gIGZvbnQtZmFtaWx5OiBcImxpbC1ndWlcIjtcbiAgY29udGVudDogXCLihpVcIjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIHBhZGRpbmctcmlnaHQ6IDAuMzc1ZW07XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gLndpZGdldCxcbi5saWwtZ3VpIC5jb250cm9sbGVyLm9wdGlvbiBzZWxlY3Qge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5AbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gLndpZGdldDpob3ZlciAuZGlzcGxheSB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0taG92ZXItY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgaW5wdXQge1xuICBjb2xvcjogdmFyKC0tbnVtYmVyLWNvbG9yKTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm51bWJlci5oYXNTbGlkZXIgaW5wdXQge1xuICBtYXJnaW4tbGVmdDogdmFyKC0tc3BhY2luZyk7XG4gIHdpZHRoOiB2YXIoLS1zbGlkZXItaW5wdXQtd2lkdGgpO1xuICBtaW4td2lkdGg6IHZhcigtLXNsaWRlci1pbnB1dC1taW4td2lkdGgpO1xuICBmbGV4LXNocmluazogMDtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm51bWJlciAuc2xpZGVyIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIGJhY2tncm91bmQ6IHZhcigtLXdpZGdldC1jb2xvcik7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgcGFkZGluZy1yaWdodDogdmFyKC0tc2xpZGVyLWtub2Itd2lkdGgpO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBjdXJzb3I6IGV3LXJlc2l6ZTtcbiAgdG91Y2gtYWN0aW9uOiBwYW4teTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIC5saWwtZ3VpIC5jb250cm9sbGVyLm51bWJlciAuc2xpZGVyOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ob3Zlci1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm51bWJlciAuc2xpZGVyLmFjdGl2ZSB7XG4gIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm51bWJlciAuc2xpZGVyLmFjdGl2ZSAuZmlsbCB7XG4gIG9wYWNpdHk6IDAuOTU7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLmZpbGwge1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJvcmRlci1yaWdodDogdmFyKC0tc2xpZGVyLWtub2Itd2lkdGgpIHNvbGlkIHZhcigtLW51bWJlci1jb2xvcik7XG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xufVxuXG4ubGlsLWd1aS1kcmFnZ2luZyAubGlsLWd1aSB7XG4gIC0taG92ZXItY29sb3I6IHZhcigtLXdpZGdldC1jb2xvcik7XG59XG4ubGlsLWd1aS1kcmFnZ2luZyAqIHtcbiAgY3Vyc29yOiBldy1yZXNpemUgIWltcG9ydGFudDtcbn1cblxuLmxpbC1ndWktZHJhZ2dpbmcubGlsLWd1aS12ZXJ0aWNhbCAqIHtcbiAgY3Vyc29yOiBucy1yZXNpemUgIWltcG9ydGFudDtcbn1cblxuLmxpbC1ndWkgLnRpdGxlIHtcbiAgaGVpZ2h0OiB2YXIoLS10aXRsZS1oZWlnaHQpO1xuICBsaW5lLWhlaWdodDogY2FsYyh2YXIoLS10aXRsZS1oZWlnaHQpIC0gNHB4KTtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgcGFkZGluZzogMCB2YXIoLS1wYWRkaW5nKTtcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBvdXRsaW5lOiBub25lO1xuICB0ZXh0LWRlY29yYXRpb24tc2tpcDogb2JqZWN0cztcbn1cbi5saWwtZ3VpIC50aXRsZTpiZWZvcmUge1xuICBmb250LWZhbWlseTogXCJsaWwtZ3VpXCI7XG4gIGNvbnRlbnQ6IFwi4pa+XCI7XG4gIHBhZGRpbmctcmlnaHQ6IDJweDtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xufVxuLmxpbC1ndWkgLnRpdGxlOmFjdGl2ZSB7XG4gIGJhY2tncm91bmQ6IHZhcigtLXRpdGxlLWJhY2tncm91bmQtY29sb3IpO1xuICBvcGFjaXR5OiAwLjc1O1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgYm9keTpub3QoLmxpbC1ndWktZHJhZ2dpbmcpIC5saWwtZ3VpIC50aXRsZTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tdGl0bGUtYmFja2dyb3VuZC1jb2xvcik7XG4gICAgb3BhY2l0eTogMC44NTtcbiAgfVxuICAubGlsLWd1aSAudGl0bGU6Zm9jdXMge1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIHZhcigtLWZvY3VzLWNvbG9yKTtcbiAgfVxufVxuLmxpbC1ndWkucm9vdCA+IC50aXRsZTpmb2N1cyB7XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZSAhaW1wb3J0YW50O1xufVxuLmxpbC1ndWkuY2xvc2VkID4gLnRpdGxlOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwi4pa4XCI7XG59XG4ubGlsLWd1aS5jbG9zZWQgPiAuY2hpbGRyZW4ge1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTdweCk7XG4gIG9wYWNpdHk6IDA7XG59XG4ubGlsLWd1aS5jbG9zZWQ6bm90KC50cmFuc2l0aW9uKSA+IC5jaGlsZHJlbiB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG4ubGlsLWd1aS50cmFuc2l0aW9uID4gLmNoaWxkcmVuIHtcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMzAwbXM7XG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGhlaWdodCwgb3BhY2l0eSwgdHJhbnNmb3JtO1xuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMiwgMC42LCAwLjM1LCAxKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG4ubGlsLWd1aSAuY2hpbGRyZW46ZW1wdHk6YmVmb3JlIHtcbiAgY29udGVudDogXCJFbXB0eVwiO1xuICBwYWRkaW5nOiAwIHZhcigtLXBhZGRpbmcpO1xuICBtYXJnaW46IHZhcigtLXNwYWNpbmcpIDA7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICBmb250LXN0eWxlOiBpdGFsaWM7XG4gIGxpbmUtaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgb3BhY2l0eTogMC41O1xufVxuLmxpbC1ndWkucm9vdCA+IC5jaGlsZHJlbiA+IC5saWwtZ3VpID4gLnRpdGxlIHtcbiAgYm9yZGVyOiAwIHNvbGlkIHZhcigtLXdpZGdldC1jb2xvcik7XG4gIGJvcmRlci13aWR0aDogMXB4IDA7XG4gIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAzMDBtcztcbn1cbi5saWwtZ3VpLnJvb3QgPiAuY2hpbGRyZW4gPiAubGlsLWd1aS5jbG9zZWQgPiAudGl0bGUge1xuICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbi5saWwtZ3VpICsgLmNvbnRyb2xsZXIge1xuICBib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0td2lkZ2V0LWNvbG9yKTtcbiAgbWFyZ2luLXRvcDogMDtcbiAgcGFkZGluZy10b3A6IHZhcigtLXNwYWNpbmcpO1xufVxuLmxpbC1ndWkgLmxpbC1ndWkgLmxpbC1ndWkgPiAudGl0bGUge1xuICBib3JkZXI6IG5vbmU7XG59XG4ubGlsLWd1aSAubGlsLWd1aSAubGlsLWd1aSA+IC5jaGlsZHJlbiB7XG4gIGJvcmRlcjogbm9uZTtcbiAgbWFyZ2luLWxlZnQ6IHZhcigtLWZvbGRlci1pbmRlbnQpO1xuICBib3JkZXItbGVmdDogMnB4IHNvbGlkIHZhcigtLXdpZGdldC1jb2xvcik7XG59XG4ubGlsLWd1aSAubGlsLWd1aSAuY29udHJvbGxlciB7XG4gIGJvcmRlcjogbm9uZTtcbn1cblxuLmxpbC1ndWkgbGFiZWwsIC5saWwtZ3VpIGlucHV0LCAubGlsLWd1aSBidXR0b24ge1xuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuLmxpbC1ndWkgaW5wdXQge1xuICBib3JkZXI6IDA7XG4gIG91dGxpbmU6IG5vbmU7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseSk7XG4gIGZvbnQtc2l6ZTogdmFyKC0taW5wdXQtZm9udC1zaXplKTtcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS13aWRnZXQtY29sb3IpO1xuICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XG4gIHdpZHRoOiAxMDAlO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgaW5wdXQ6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWhvdmVyLWNvbG9yKTtcbiAgfVxuICAubGlsLWd1aSBpbnB1dDphY3RpdmUge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbiAgfVxufVxuLmxpbC1ndWkgaW5wdXQ6ZGlzYWJsZWQge1xuICBvcGFjaXR5OiAxO1xufVxuLmxpbC1ndWkgaW5wdXRbdHlwZT10ZXh0XSxcbi5saWwtZ3VpIGlucHV0W3R5cGU9bnVtYmVyXSB7XG4gIHBhZGRpbmc6IHZhcigtLXdpZGdldC1wYWRkaW5nKTtcbiAgLW1vei1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG59XG4ubGlsLWd1aSBpbnB1dFt0eXBlPXRleHRdOmZvY3VzLFxuLmxpbC1ndWkgaW5wdXRbdHlwZT1udW1iZXJdOmZvY3VzIHtcbiAgYmFja2dyb3VuZDogdmFyKC0tZm9jdXMtY29sb3IpO1xufVxuLmxpbC1ndWkgaW5wdXRbdHlwZT1jaGVja2JveF0ge1xuICBhcHBlYXJhbmNlOiBub25lO1xuICB3aWR0aDogdmFyKC0tY2hlY2tib3gtc2l6ZSk7XG4gIGhlaWdodDogdmFyKC0tY2hlY2tib3gtc2l6ZSk7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4ubGlsLWd1aSBpbnB1dFt0eXBlPWNoZWNrYm94XTpjaGVja2VkOmJlZm9yZSB7XG4gIGZvbnQtZmFtaWx5OiBcImxpbC1ndWlcIjtcbiAgY29udGVudDogXCLinJNcIjtcbiAgZm9udC1zaXplOiB2YXIoLS1jaGVja2JveC1zaXplKTtcbiAgbGluZS1oZWlnaHQ6IHZhcigtLWNoZWNrYm94LXNpemUpO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgaW5wdXRbdHlwZT1jaGVja2JveF06Zm9jdXMge1xuICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIGJ1dHRvbiB7XG4gIG91dGxpbmU6IG5vbmU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtZmFtaWx5KTtcbiAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUpO1xuICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcbiAgYmFja2dyb3VuZDogdmFyKC0td2lkZ2V0LWNvbG9yKTtcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICBib3JkZXI6IG5vbmU7XG59XG5AbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAubGlsLWd1aSBidXR0b246aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWhvdmVyLWNvbG9yKTtcbiAgfVxuICAubGlsLWd1aSBidXR0b246Zm9jdXMge1xuICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIGJ1dHRvbjphY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG59XG5cbkBmb250LWZhY2Uge1xuICBmb250LWZhbWlseTogXCJsaWwtZ3VpXCI7XG4gIHNyYzogdXJsKFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7Y2hhcnNldD11dGYtODtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVc0FBc0FBQUFBQ0p3QUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJIVTFWQ0FBQUJDQUFBQUg0QUFBREFJbXdtWUU5VEx6SUFBQUdJQUFBQVB3QUFBR0JLcUg1U1kyMWhjQUFBQWNnQUFBRDBBQUFDcnVreXlKQm5iSGxtQUFBQ3ZBQUFBRjhBQUFDRUlacFdIMmhsWVdRQUFBTWNBQUFBSndBQUFEWmZjajJ6YUdobFlRQUFBMFFBQUFBWUFBQUFKQUM1QUhob2JYUjRBQUFEWEFBQUFCQUFBQUJNQVpBQUFHeHZZMkVBQUFOc0FBQUFGQUFBQUNnQ0VnSXliV0Y0Y0FBQUE0QUFBQUFlQUFBQUlBRWZBQkp1WVcxbEFBQURvQUFBQVNJQUFBSUs5U1VVL1hCdmMzUUFBQVRFQUFBQVpnQUFBSkNUY01jMmVKeFZqYkVPZ2pBVVJVK2hGUkJLMWRHUkwrQUxuQWlUb3lNTEV6RnBuUHovZUFzaHdTYTk3NTE3Yy9Nd3dKbWVCOWt3UGwrMGNmNSt1R1BaWHNxUHU0bnZaYWJjU1psZFo2a2Z5V25vbUZZL2VTY0txWk5XdXBLSk82a1hOM0s5dUNWb0w3aUluUHIxWDViYVhzM3RqdU1xQ3R6RXVhZ20vQUFselFnUEFBQjRuR05nWVJCbG5NREF5c0RBWU0vZ0JpVDVvTFFCQXd1REpBTURFd01yTXdOV0VKRG1tc0p3Z0NGZVhaZ2hCY2psWk1nRkN6T2lLT0lGQUI3MUJiOEFlSnkxa2pGdXdrQVFSWitEd1JBd0J0TlFSVUdLUThPZEtDQVdVaEFnS0xoSXVBc1ZTcFd6NUJia2ozZEVnWWlVSXN6cVdkcFplK1o3L3dCMW9DWW1Jb2JvaXdpTFQyV2pLbC9qc2NySGZHZy9wS2RNa3lrbEM1WnMyTEVmSFlwamNSb1B6bWU5TVdXbWszZFdiSzlPYmtXa2lrT2V0SjU1NGZXeW9Fc21kU2x0K3VSMHBDSlIzNGI2dC9UVmcxU1kzc1l2ZGY4dnVpS3JweWFEWERJU2llZ3AxN3A3NTc5R3AzcCsreTdIUEFpWTlwbVRpYmxqcnI4NXFTaWR0bGc0K2wyNUdMQ2FTOGU2clJ4TkJtc25FUnVuS2JhT09iUno3TjcyanU1dmRBallwQlhIZ0p5bE9BVnNNc2VEQVBFUDhMWW9VSGljWTJCaUFBRWZoaUFHSmdaV0JnWjdSbkZSZG5WSkVMQ1FsQlNSbEFUSk1vTFYyREs0Z2xTWXM2dWJxNXZiS3JKTFNiR3JnRW1vdkR1REpWaGUzVnpjWEZ3TkxDT0lMQi9DNEl1UTF4VG41RlBpbEJUajVGUG1CQUI0V3dvcUFIaWNZMkJrWUdBQTRzazFzUi9qK1cyK01uQXpwREJnQXlFTVFVQ1NnNEVKeEFFQXdVZ0ZIZ0I0bkdOZ1pHQmdTR0ZnZ0pNaERJd01xRUFZQUJ5SEFUSjRuR05nQUlJVU5Fd21BQUJsM0FHUmVKeGpZQUFDSVFZbEJpTUdKM3dRQUVjUUJFVjRuR05nWkdCZ0VHWmdZMkJpQUFFUXlRV0VEQXovd1h3R0FBc1BBVElBQUhpY1hkQk5Tc05BSEFYd2wzNWlBMFVRWFluTVNoZlM5R1BaQTdUN0xnSXUwM1NTcGt3ellUSXQxQk40QWsvZ0tUeUFlQ3hmdzM5alpranltemN2QXdtQVcvd2d3SFVFR0RiMzYralFRM0dYR290NzlMMjRqeENQNGdIekYvRUlyNGpFSWU3d3hoT0MzZzJUTVl5NFE3K0x1L1NIdUVkL2l2dDR3SmQ0d1B4YlBFS01YM0dJNStESkZHYVNuNHFOems4bWNiS1NSNnhkWGRoU3phT1pKR3RkYXBkNHZWUGJpNnJQK2NMN1RHWE9IdFhLbGw0YlkxWGw3RUduUHRwN1h5Mm4wMHp5S0xWSGZrSEJhNEljSjJvRDNjZ2dnV3Z0L1YvRmJEclVsRVVKaFRuLzBhelZXYk5UTnIwRW5zOGRlMXRjZUs5eFptZkIxQ1BqT21QSDRraXRtdk91YmNOcG1WVE4zb0ZKeWp6Q3ZubXJ3aEpUenF6Vmo5amlTWDkxMUZqZUFBQjRuRzNITVJLQ01CQkEwZjBnaWlLaTREVThrMFYyR1diSVpET2g0UG9XV3ZxNko1VjhJZjlOVk5RY2FEaHlvdVhNaFk0clBUY0c3andZbVhoS3E4V3orcDc2MmFOYWVZWG9tMm4zbTJkTFRWZ3NyQ2dGSjdPVG1Ja1lid0liQzZ2SUI3V21GZkFBQUE9PVwiKSBmb3JtYXQoXCJ3b2ZmXCIpO1xufWA7XG5cbmZ1bmN0aW9uIF9pbmplY3RTdHlsZXMoIGNzc0NvbnRlbnQgKSB7XG5cdGNvbnN0IGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuXHRpbmplY3RlZC5pbm5lckhUTUwgPSBjc3NDb250ZW50O1xuXHRjb25zdCBiZWZvcmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnaGVhZCBsaW5rW3JlbD1zdHlsZXNoZWV0XSwgaGVhZCBzdHlsZScgKTtcblx0aWYgKCBiZWZvcmUgKSB7XG5cdFx0ZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoIGluamVjdGVkLCBiZWZvcmUgKTtcblx0fSBlbHNlIHtcblx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBpbmplY3RlZCApO1xuXHR9XG59XG5cbmxldCBzdHlsZXNJbmplY3RlZCA9IGZhbHNlO1xuXG5jbGFzcyBHVUkge1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcGFuZWwgdGhhdCBob2xkcyBjb250cm9sbGVycy5cblx0ICogQGV4YW1wbGVcblx0ICogbmV3IEdVSSgpO1xuXHQgKiBuZXcgR1VJKCB7IGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoICdjdXN0b20nICkgfSApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b1BsYWNlPXRydWVdXG5cdCAqIEFkZHMgdGhlIEdVSSB0byBgZG9jdW1lbnQuYm9keWAgYW5kIGZpeGVzIGl0IHRvIHRoZSB0b3AgcmlnaHQgb2YgdGhlIHBhZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcl1cblx0ICogQWRkcyB0aGUgR1VJIHRvIHRoaXMgRE9NIGVsZW1lbnQuIE92ZXJyaWRlcyBgYXV0b1BsYWNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTI0NV1cblx0ICogV2lkdGggb2YgdGhlIEdVSSBpbiBwaXhlbHMsIHVzdWFsbHkgc2V0IHdoZW4gbmFtZSBsYWJlbHMgYmVjb21lIHRvbyBsb25nLiBOb3RlIHRoYXQgeW91IGNhbiBtYWtlXG5cdCAqIG5hbWUgbGFiZWxzIHdpZGVyIGluIENTUyB3aXRoIGAubGls4oCRZ3VpIHsg4oCR4oCRbmFtZeKAkXdpZHRoOiA1NSUgfWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aXRsZT1Db250cm9sc11cblx0ICogTmFtZSB0byBkaXNwbGF5IGluIHRoZSB0aXRsZSBiYXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvc2VGb2xkZXJzPWZhbHNlXVxuXHQgKiBQYXNzIGB0cnVlYCB0byBjbG9zZSBhbGwgZm9sZGVycyBpbiB0aGlzIEdVSSBieSBkZWZhdWx0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluamVjdFN0eWxlcz10cnVlXVxuXHQgKiBJbmplY3RzIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgaW50byB0aGUgcGFnZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBHVUkuXG5cdCAqIFBhc3MgYGZhbHNlYCB0byB1c2UgeW91ciBvd24gc3R5bGVzaGVldC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvdWNoU3R5bGVzPXRydWVdXG5cdCAqIE1ha2VzIGNvbnRyb2xsZXJzIGxhcmdlciBvbiB0b3VjaCBkZXZpY2VzLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZSB0b3VjaCBzdHlsZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7R1VJfSBbb3B0aW9ucy5wYXJlbnRdXG5cdCAqIEFkZHMgdGhpcyBHVUkgYXMgYSBjaGlsZCBpbiBhbm90aGVyIEdVSS4gVXN1YWxseSB0aGlzIGlzIGRvbmUgZm9yIHlvdSBieSBgYWRkRm9sZGVyKClgLlxuXHQgKlxuXHQgKi9cblx0Y29uc3RydWN0b3IoIHtcblx0XHRwYXJlbnQsXG5cdFx0YXV0b1BsYWNlID0gcGFyZW50ID09PSB1bmRlZmluZWQsXG5cdFx0Y29udGFpbmVyLFxuXHRcdHdpZHRoLFxuXHRcdHRpdGxlID0gJ0NvbnRyb2xzJyxcblx0XHRjbG9zZUZvbGRlcnMgPSBmYWxzZSxcblx0XHRpbmplY3RTdHlsZXMgPSB0cnVlLFxuXHRcdHRvdWNoU3R5bGVzID0gdHJ1ZVxuXHR9ID0ge30gKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgR1VJIGNvbnRhaW5pbmcgdGhpcyBmb2xkZXIsIG9yIGB1bmRlZmluZWRgIGlmIHRoaXMgaXMgdGhlIHJvb3QgR1VJLlxuXHRcdCAqIEB0eXBlIHtHVUl9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG9wIGxldmVsIEdVSSBjb250YWluaW5nIHRoaXMgZm9sZGVyLCBvciBgdGhpc2AgaWYgdGhpcyBpcyB0aGUgcm9vdCBHVUkuXG5cdFx0ICogQHR5cGUge0dVSX1cblx0XHQgKi9cblx0XHR0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IHRoaXM7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlzdCBvZiBjb250cm9sbGVycyBhbmQgZm9sZGVycyBjb250YWluZWQgYnkgdGhpcyBHVUkuXG5cdFx0ICogQHR5cGUge0FycmF5PEdVSXxDb250cm9sbGVyPn1cblx0XHQgKi9cblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlzdCBvZiBjb250cm9sbGVycyBjb250YWluZWQgYnkgdGhpcyBHVUkuXG5cdFx0ICogQHR5cGUge0FycmF5PENvbnRyb2xsZXI+fVxuXHRcdCAqL1xuXHRcdHRoaXMuY29udHJvbGxlcnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsaXN0IG9mIGZvbGRlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJLlxuXHRcdCAqIEB0eXBlIHtBcnJheTxHVUk+fVxuXHRcdCAqL1xuXHRcdHRoaXMuZm9sZGVycyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIEdVSSBpcyBjbG9zZWQuIFVzZSBgZ3VpLm9wZW4oKWAgb3IgYGd1aS5jbG9zZSgpYCB0byBjaGFuZ2UgdGhpcy5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBHVUkgaXMgaGlkZGVuLiBVc2UgYGd1aS5zaG93KClgIG9yIGBndWkuaGlkZSgpYCB0byBjaGFuZ2UgdGhpcy5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9oaWRkZW4gPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvdXRlcm1vc3QgY29udGFpbmVyIGVsZW1lbnQuXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICdsaWwtZ3VpJyApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpdGxlLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLiR0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kdGl0bGUuY2xhc3NMaXN0LmFkZCggJ3RpdGxlJyApO1xuXHRcdHRoaXMuJHRpdGxlLnNldEF0dHJpYnV0ZSggJ3JvbGUnLCAnYnV0dG9uJyApO1xuXHRcdHRoaXMuJHRpdGxlLnNldEF0dHJpYnV0ZSggJ2FyaWEtZXhwYW5kZWQnLCB0cnVlICk7XG5cdFx0dGhpcy4kdGl0bGUuc2V0QXR0cmlidXRlKCAndGFiaW5kZXgnLCAwICk7XG5cblx0XHR0aGlzLiR0aXRsZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCAoKSA9PiB0aGlzLm9wZW5BbmltYXRlZCggdGhpcy5fY2xvc2VkICkgKTtcblx0XHR0aGlzLiR0aXRsZS5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGUgPT4ge1xuXHRcdFx0aWYgKCBlLmNvZGUgPT09ICdFbnRlcicgfHwgZS5jb2RlID09PSAnU3BhY2UnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHRoaXMuJHRpdGxlLmNsaWNrKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gZW5hYmxlcyA6YWN0aXZlIHBzZXVkbyBjbGFzcyBvbiBtb2JpbGVcblx0XHR0aGlzLiR0aXRsZS5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsICgpID0+IHt9LCB7IHBhc3NpdmU6IHRydWUgfSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgY2hpbGRyZW4uXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHRoaXMuJGNoaWxkcmVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR0aGlzLiRjaGlsZHJlbi5jbGFzc0xpc3QuYWRkKCAnY2hpbGRyZW4nICk7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMuJHRpdGxlICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLiRjaGlsZHJlbiApO1xuXG5cdFx0dGhpcy50aXRsZSggdGl0bGUgKTtcblxuXHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XG5cblx0XHRcdHRoaXMucGFyZW50LmNoaWxkcmVuLnB1c2goIHRoaXMgKTtcblx0XHRcdHRoaXMucGFyZW50LmZvbGRlcnMucHVzaCggdGhpcyApO1xuXG5cdFx0XHR0aGlzLnBhcmVudC4kY2hpbGRyZW4uYXBwZW5kQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXG5cdFx0XHQvLyBTdG9wIHRoZSBjb25zdHJ1Y3RvciBlYXJseSwgZXZlcnl0aGluZyBvbndhcmQgb25seSBhcHBsaWVzIHRvIHJvb3QgR1VJJ3Ncblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAncm9vdCcgKTtcblxuXHRcdGlmICggdG91Y2hTdHlsZXMgKSB7XG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ2FsbG93LXRvdWNoLXN0eWxlcycgKTtcblx0XHR9XG5cblx0XHQvLyBJbmplY3Qgc3R5bGVzaGVldCBpZiB3ZSBoYXZlbid0IGRvbmUgdGhhdCB5ZXRcblx0XHRpZiAoICFzdHlsZXNJbmplY3RlZCAmJiBpbmplY3RTdHlsZXMgKSB7XG5cdFx0XHRfaW5qZWN0U3R5bGVzKCBzdHlsZXNoZWV0ICk7XG5cdFx0XHRzdHlsZXNJbmplY3RlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBjb250YWluZXIgKSB7XG5cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5kb21FbGVtZW50ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBhdXRvUGxhY2UgKSB7XG5cblx0XHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnYXV0b1BsYWNlJyApO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggdGhpcy5kb21FbGVtZW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHdpZHRoICkge1xuXHRcdFx0dGhpcy5kb21FbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCAnLS13aWR0aCcsIHdpZHRoICsgJ3B4JyApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2Nsb3NlRm9sZGVycyA9IGNsb3NlRm9sZGVycztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjb250cm9sbGVyIHRvIHRoZSBHVUksIGluZmVycmluZyBjb250cm9sbGVyIHR5cGUgdXNpbmcgdGhlIGB0eXBlb2ZgIG9wZXJhdG9yLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBndWkuYWRkKCBvYmplY3QsICdwcm9wZXJ0eScgKTtcblx0ICogZ3VpLmFkZCggb2JqZWN0LCAnbnVtYmVyJywgMCwgMTAwLCAxICk7XG5cdCAqIGd1aS5hZGQoIG9iamVjdCwgJ29wdGlvbnMnLCBbIDEsIDIsIDMgXSApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIGNvbnRyb2xsZXIgd2lsbCBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb250cm9sLlxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R8QXJyYXl9IFskMV0gTWluaW11bSB2YWx1ZSBmb3IgbnVtYmVyIGNvbnRyb2xsZXJzLCBvciB0aGUgc2V0IG9mXG5cdCAqIHNlbGVjdGFibGUgdmFsdWVzIGZvciBhIGRyb3Bkb3duLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21heF0gTWF4aW11bSB2YWx1ZSBmb3IgbnVtYmVyIGNvbnRyb2xsZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXBdIFN0ZXAgdmFsdWUgZm9yIG51bWJlciBjb250cm9sbGVycy5cblx0ICogQHJldHVybnMge0NvbnRyb2xsZXJ9XG5cdCAqL1xuXHRhZGQoIG9iamVjdCwgcHJvcGVydHksICQxLCBtYXgsIHN0ZXAgKSB7XG5cblx0XHRpZiAoIE9iamVjdCggJDEgKSA9PT0gJDEgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlciggdGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgJDEgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGluaXRpYWxWYWx1ZSA9IG9iamVjdFsgcHJvcGVydHkgXTtcblxuXHRcdHN3aXRjaCAoIHR5cGVvZiBpbml0aWFsVmFsdWUgKSB7XG5cblx0XHRcdGNhc2UgJ251bWJlcic6XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5LCAkMSwgbWF4LCBzdGVwICk7XG5cblx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXG5cdFx0XHRcdHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIoIHRoaXMsIG9iamVjdCwgcHJvcGVydHkgKTtcblxuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIoIHRoaXMsIG9iamVjdCwgcHJvcGVydHkgKTtcblxuXHRcdFx0Y2FzZSAnZnVuY3Rpb24nOlxuXG5cdFx0XHRcdHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5ICk7XG5cblx0XHR9XG5cblx0XHRjb25zb2xlLmVycm9yKCBgZ3VpLmFkZCBmYWlsZWRcblx0cHJvcGVydHk6YCwgcHJvcGVydHksIGBcblx0b2JqZWN0OmAsIG9iamVjdCwgYFxuXHR2YWx1ZTpgLCBpbml0aWFsVmFsdWUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjb2xvciBjb250cm9sbGVyIHRvIHRoZSBHVUkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIHBhcmFtcyA9IHtcblx0ICogXHRjc3NDb2xvcjogJyNmZjAwZmYnLFxuXHQgKiBcdHJnYkNvbG9yOiB7IHI6IDAsIGc6IDAuMiwgYjogMC40IH0sXG5cdCAqIFx0Y3VzdG9tUmFuZ2U6IFsgMCwgMTI3LCAyNTUgXSxcblx0ICogfTtcblx0ICpcblx0ICogZ3VpLmFkZENvbG9yKCBwYXJhbXMsICdjc3NDb2xvcicgKTtcblx0ICogZ3VpLmFkZENvbG9yKCBwYXJhbXMsICdyZ2JDb2xvcicgKTtcblx0ICogZ3VpLmFkZENvbG9yKCBwYXJhbXMsICdjdXN0b21SYW5nZScsIDI1NSApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIGNvbnRyb2xsZXIgd2lsbCBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb250cm9sLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmdiU2NhbGUgTWF4aW11bSB2YWx1ZSBmb3IgYSBjb2xvciBjaGFubmVsIHdoZW4gdXNpbmcgYW4gUkdCIGNvbG9yLiBZb3UgbWF5XG5cdCAqIG5lZWQgdG8gc2V0IHRoaXMgdG8gMjU1IGlmIHlvdXIgY29sb3JzIGFyZSB0b28gYnJpZ2h0LlxuXHQgKiBAcmV0dXJucyB7Q29udHJvbGxlcn1cblx0ICovXG5cdGFkZENvbG9yKCBvYmplY3QsIHByb3BlcnR5LCByZ2JTY2FsZSA9IDEgKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvckNvbnRyb2xsZXIoIHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHJnYlNjYWxlICk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGZvbGRlciB0byB0aGUgR1VJLCB3aGljaCBpcyBqdXN0IGFub3RoZXIgR1VJLiBUaGlzIG1ldGhvZCByZXR1cm5zXG5cdCAqIHRoZSBuZXN0ZWQgR1VJIHNvIHlvdSBjYW4gYWRkIGNvbnRyb2xsZXJzIHRvIGl0LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb25zdCBmb2xkZXIgPSBndWkuYWRkRm9sZGVyKCAnUG9zaXRpb24nICk7XG5cdCAqIGZvbGRlci5hZGQoIHBvc2l0aW9uLCAneCcgKTtcblx0ICogZm9sZGVyLmFkZCggcG9zaXRpb24sICd5JyApO1xuXHQgKiBmb2xkZXIuYWRkKCBwb3NpdGlvbiwgJ3onICk7XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSBOYW1lIHRvIGRpc3BsYXkgaW4gdGhlIGZvbGRlcidzIHRpdGxlIGJhci5cblx0ICogQHJldHVybnMge0dVSX1cblx0ICovXG5cdGFkZEZvbGRlciggdGl0bGUgKSB7XG5cdFx0Y29uc3QgZm9sZGVyID0gbmV3IEdVSSggeyBwYXJlbnQ6IHRoaXMsIHRpdGxlIH0gKTtcblx0XHRpZiAoIHRoaXMucm9vdC5fY2xvc2VGb2xkZXJzICkgZm9sZGVyLmNsb3NlKCk7XG5cdFx0cmV0dXJuIGZvbGRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWNhbGxzIHZhbHVlcyB0aGF0IHdlcmUgc2F2ZWQgd2l0aCBgZ3VpLnNhdmUoKWAuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcblx0ICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgUGFzcyBmYWxzZSB0byBleGNsdWRlIGZvbGRlcnMgZGVzY2VuZGluZyBmcm9tIHRoaXMgR1VJLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGxvYWQoIG9iaiwgcmVjdXJzaXZlID0gdHJ1ZSApIHtcblxuXHRcdGlmICggb2JqLmNvbnRyb2xsZXJzICkge1xuXG5cdFx0XHR0aGlzLmNvbnRyb2xsZXJzLmZvckVhY2goIGMgPT4ge1xuXG5cdFx0XHRcdGlmICggYyBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlciApIHJldHVybjtcblxuXHRcdFx0XHRpZiAoIGMuX25hbWUgaW4gb2JqLmNvbnRyb2xsZXJzICkge1xuXHRcdFx0XHRcdGMubG9hZCggb2JqLmNvbnRyb2xsZXJzWyBjLl9uYW1lIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlY3Vyc2l2ZSAmJiBvYmouZm9sZGVycyApIHtcblxuXHRcdFx0dGhpcy5mb2xkZXJzLmZvckVhY2goIGYgPT4ge1xuXG5cdFx0XHRcdGlmICggZi5fdGl0bGUgaW4gb2JqLmZvbGRlcnMgKSB7XG5cdFx0XHRcdFx0Zi5sb2FkKCBvYmouZm9sZGVyc1sgZi5fdGl0bGUgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyBjb250cm9sbGVyIG5hbWVzIHRvIHZhbHVlcy4gVGhlIG9iamVjdCBjYW4gYmUgcGFzc2VkIHRvIGBndWkubG9hZCgpYCB0b1xuXHQgKiByZWNhbGwgdGhlc2UgdmFsdWVzLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiB7XG5cdCAqIFx0Y29udHJvbGxlcnM6IHtcblx0ICogXHRcdHByb3AxOiAxLFxuXHQgKiBcdFx0cHJvcDI6ICd2YWx1ZScsXG5cdCAqIFx0XHQuLi5cblx0ICogXHR9LFxuXHQgKiBcdGZvbGRlcnM6IHtcblx0ICogXHRcdGZvbGRlck5hbWUxOiB7IGNvbnRyb2xsZXJzLCBmb2xkZXJzIH0sXG5cdCAqIFx0XHRmb2xkZXJOYW1lMjogeyBjb250cm9sbGVycywgZm9sZGVycyB9XG5cdCAqIFx0XHQuLi5cblx0ICogXHR9XG5cdCAqIH1cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgUGFzcyBmYWxzZSB0byBleGNsdWRlIGZvbGRlcnMgZGVzY2VuZGluZyBmcm9tIHRoaXMgR1VJLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHQgKi9cblx0c2F2ZSggcmVjdXJzaXZlID0gdHJ1ZSApIHtcblxuXHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdGNvbnRyb2xsZXJzOiB7fSxcblx0XHRcdGZvbGRlcnM6IHt9XG5cdFx0fTtcblxuXHRcdHRoaXMuY29udHJvbGxlcnMuZm9yRWFjaCggYyA9PiB7XG5cblx0XHRcdGlmICggYyBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlciApIHJldHVybjtcblxuXHRcdFx0aWYgKCBjLl9uYW1lIGluIG9iai5jb250cm9sbGVycyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgQ2Fubm90IHNhdmUgR1VJIHdpdGggZHVwbGljYXRlIHByb3BlcnR5IFwiJHtjLl9uYW1lfVwiYCApO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmouY29udHJvbGxlcnNbIGMuX25hbWUgXSA9IGMuc2F2ZSgpO1xuXG5cdFx0fSApO1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHRoaXMuZm9sZGVycy5mb3JFYWNoKCBmID0+IHtcblxuXHRcdFx0XHRpZiAoIGYuX3RpdGxlIGluIG9iai5mb2xkZXJzICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggYENhbm5vdCBzYXZlIEdVSSB3aXRoIGR1cGxpY2F0ZSBmb2xkZXIgXCIke2YuX3RpdGxlfVwiYCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqLmZvbGRlcnNbIGYuX3RpdGxlIF0gPSBmLnNhdmUoKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW5zIGEgR1VJIG9yIGZvbGRlci4gR1VJIGFuZCBmb2xkZXJzIGFyZSBvcGVuIGJ5IGRlZmF1bHQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlbiBQYXNzIGZhbHNlIHRvIGNsb3NlLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLm9wZW4oKTsgLy8gb3BlblxuXHQgKiBndWkub3BlbiggZmFsc2UgKTsgLy8gY2xvc2Vcblx0ICogZ3VpLm9wZW4oIGd1aS5fY2xvc2VkICk7IC8vIHRvZ2dsZVxuXHQgKi9cblx0b3Blbiggb3BlbiA9IHRydWUgKSB7XG5cblx0XHR0aGlzLl9zZXRDbG9zZWQoICFvcGVuICk7XG5cblx0XHR0aGlzLiR0aXRsZS5zZXRBdHRyaWJ1dGUoICdhcmlhLWV4cGFuZGVkJywgIXRoaXMuX2Nsb3NlZCApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCAnY2xvc2VkJywgdGhpcy5fY2xvc2VkICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgR1VJLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGNsb3NlKCkge1xuXHRcdHJldHVybiB0aGlzLm9wZW4oIGZhbHNlICk7XG5cdH1cblxuXHRfc2V0Q2xvc2VkKCBjbG9zZWQgKSB7XG5cdFx0aWYgKCB0aGlzLl9jbG9zZWQgPT09IGNsb3NlZCApIHJldHVybjtcblx0XHR0aGlzLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0dGhpcy5fY2FsbE9uT3BlbkNsb3NlKCB0aGlzICk7XG5cdH1cblxuXHQvKipcblx0ICogU2hvd3MgdGhlIEdVSSBhZnRlciBpdCdzIGJlZW4gaGlkZGVuLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5zaG93KCk7XG5cdCAqIGd1aS5zaG93KCBmYWxzZSApOyAvLyBoaWRlXG5cdCAqIGd1aS5zaG93KCBndWkuX2hpZGRlbiApOyAvLyB0b2dnbGVcblx0ICovXG5cdHNob3coIHNob3cgPSB0cnVlICkge1xuXG5cdFx0dGhpcy5faGlkZGVuID0gIXNob3c7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2hpZGRlbiA/ICdub25lJyA6ICcnO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBIaWRlcyB0aGUgR1VJLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGhpZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2hvdyggZmFsc2UgKTtcblx0fVxuXG5cdG9wZW5BbmltYXRlZCggb3BlbiA9IHRydWUgKSB7XG5cblx0XHQvLyBzZXQgc3RhdGUgaW1tZWRpYXRlbHlcblx0XHR0aGlzLl9zZXRDbG9zZWQoICFvcGVuICk7XG5cblx0XHR0aGlzLiR0aXRsZS5zZXRBdHRyaWJ1dGUoICdhcmlhLWV4cGFuZGVkJywgIXRoaXMuX2Nsb3NlZCApO1xuXG5cdFx0Ly8gd2FpdCBmb3IgbmV4dCBmcmFtZSB0byBtZWFzdXJlICRjaGlsZHJlblxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSggKCkgPT4ge1xuXG5cdFx0XHQvLyBleHBsaWNpdGx5IHNldCBpbml0aWFsIGhlaWdodCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0Y29uc3QgaW5pdGlhbEhlaWdodCA9IHRoaXMuJGNoaWxkcmVuLmNsaWVudEhlaWdodDtcblx0XHRcdHRoaXMuJGNoaWxkcmVuLnN0eWxlLmhlaWdodCA9IGluaXRpYWxIZWlnaHQgKyAncHgnO1xuXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3RyYW5zaXRpb24nICk7XG5cblx0XHRcdGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9IGUgPT4ge1xuXHRcdFx0XHRpZiAoIGUudGFyZ2V0ICE9PSB0aGlzLiRjaGlsZHJlbiApIHJldHVybjtcblx0XHRcdFx0dGhpcy4kY2hpbGRyZW4uc3R5bGUuaGVpZ2h0ID0gJyc7XG5cdFx0XHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAndHJhbnNpdGlvbicgKTtcblx0XHRcdFx0dGhpcy4kY2hpbGRyZW4ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RyYW5zaXRpb25lbmQnLCBvblRyYW5zaXRpb25FbmQgKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuJGNoaWxkcmVuLmFkZEV2ZW50TGlzdGVuZXIoICd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kICk7XG5cblx0XHRcdC8vIHRvZG86IHRoaXMgaXMgd3JvbmcgaWYgY2hpbGRyZW4ncyBzY3JvbGxIZWlnaHQgbWFrZXMgZm9yIGEgZ3VpIHRhbGxlciB0aGFuIG1heEhlaWdodFxuXHRcdFx0Y29uc3QgdGFyZ2V0SGVpZ2h0ID0gIW9wZW4gPyAwIDogdGhpcy4kY2hpbGRyZW4uc2Nyb2xsSGVpZ2h0O1xuXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSggJ2Nsb3NlZCcsICFvcGVuICk7XG5cblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSggKCkgPT4ge1xuXHRcdFx0XHR0aGlzLiRjaGlsZHJlbi5zdHlsZS5oZWlnaHQgPSB0YXJnZXRIZWlnaHQgKyAncHgnO1xuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHRpdGxlIG9mIHRoaXMgR1VJLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHR0aXRsZSggdGl0bGUgKSB7XG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCB0aXRsZSBvZiB0aGUgR1VJLiBVc2UgYGd1aS50aXRsZSggJ1RpdGxlJyApYCB0byBtb2RpZnkgdGhpcyB2YWx1ZS5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMuX3RpdGxlID0gdGl0bGU7XG5cdFx0dGhpcy4kdGl0bGUuaW5uZXJIVE1MID0gdGl0bGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIGFsbCBjb250cm9sbGVycyB0byB0aGVpciBpbml0aWFsIHZhbHVlcy5cblx0ICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgUGFzcyBmYWxzZSB0byBleGNsdWRlIGZvbGRlcnMgZGVzY2VuZGluZyBmcm9tIHRoaXMgR1VJLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHJlc2V0KCByZWN1cnNpdmUgPSB0cnVlICkge1xuXHRcdGNvbnN0IGNvbnRyb2xsZXJzID0gcmVjdXJzaXZlID8gdGhpcy5jb250cm9sbGVyc1JlY3Vyc2l2ZSgpIDogdGhpcy5jb250cm9sbGVycztcblx0XHRjb250cm9sbGVycy5mb3JFYWNoKCBjID0+IGMucmVzZXQoKSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBjb250cm9sbGVyIGluIHRoaXMgR1VJIGNoYW5nZXMuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oe29iamVjdDpvYmplY3QsIHByb3BlcnR5OnN0cmluZywgdmFsdWU6YW55LCBjb250cm9sbGVyOkNvbnRyb2xsZXJ9KX0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5vbkNoYW5nZSggZXZlbnQgPT4ge1xuXHQgKiBcdGV2ZW50Lm9iamVjdCAgICAgLy8gb2JqZWN0IHRoYXQgd2FzIG1vZGlmaWVkXG5cdCAqIFx0ZXZlbnQucHJvcGVydHkgICAvLyBzdHJpbmcsIG5hbWUgb2YgcHJvcGVydHlcblx0ICogXHRldmVudC52YWx1ZSAgICAgIC8vIG5ldyB2YWx1ZSBvZiBjb250cm9sbGVyXG5cdCAqIFx0ZXZlbnQuY29udHJvbGxlciAvLyBjb250cm9sbGVyIHRoYXQgd2FzIG1vZGlmaWVkXG5cdCAqIH0gKTtcblx0ICovXG5cdG9uQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlXG5cdFx0ICogZGlyZWN0bHkuIFVzZSB0aGUgYGd1aS5vbkNoYW5nZSggY2FsbGJhY2sgKWAgbWV0aG9kIGluc3RlYWQuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdHRoaXMuX29uQ2hhbmdlID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfY2FsbE9uQ2hhbmdlKCBjb250cm9sbGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcblx0XHRcdHRoaXMucGFyZW50Ll9jYWxsT25DaGFuZ2UoIGNvbnRyb2xsZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX29uQ2hhbmdlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZS5jYWxsKCB0aGlzLCB7XG5cdFx0XHRcdG9iamVjdDogY29udHJvbGxlci5vYmplY3QsXG5cdFx0XHRcdHByb3BlcnR5OiBjb250cm9sbGVyLnByb3BlcnR5LFxuXHRcdFx0XHR2YWx1ZTogY29udHJvbGxlci5nZXRWYWx1ZSgpLFxuXHRcdFx0XHRjb250cm9sbGVyXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBjb250cm9sbGVyIGluIHRoaXMgR1VJIGhhcyBmaW5pc2hlZCBjaGFuZ2luZy5cblx0ICogQHBhcmFtIHtmdW5jdGlvbih7b2JqZWN0Om9iamVjdCwgcHJvcGVydHk6c3RyaW5nLCB2YWx1ZTphbnksIGNvbnRyb2xsZXI6Q29udHJvbGxlcn0pfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLm9uRmluaXNoQ2hhbmdlKCBldmVudCA9PiB7XG5cdCAqIFx0ZXZlbnQub2JqZWN0ICAgICAvLyBvYmplY3QgdGhhdCB3YXMgbW9kaWZpZWRcblx0ICogXHRldmVudC5wcm9wZXJ0eSAgIC8vIHN0cmluZywgbmFtZSBvZiBwcm9wZXJ0eVxuXHQgKiBcdGV2ZW50LnZhbHVlICAgICAgLy8gbmV3IHZhbHVlIG9mIGNvbnRyb2xsZXJcblx0ICogXHRldmVudC5jb250cm9sbGVyIC8vIGNvbnRyb2xsZXIgdGhhdCB3YXMgbW9kaWZpZWRcblx0ICogfSApO1xuXHQgKi9cblx0b25GaW5pc2hDaGFuZ2UoIGNhbGxiYWNrICkge1xuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gYWNjZXNzIHRoZSBmdW5jdGlvbiBib3VuZCB0byBgb25GaW5pc2hDaGFuZ2VgIGV2ZW50cy4gRG9uJ3QgbW9kaWZ5IHRoaXMgdmFsdWVcblx0XHQgKiBkaXJlY3RseS4gVXNlIHRoZSBgZ3VpLm9uRmluaXNoQ2hhbmdlKCBjYWxsYmFjayApYCBtZXRob2QgaW5zdGVhZC5cblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICovXG5cdFx0dGhpcy5fb25GaW5pc2hDaGFuZ2UgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9jYWxsT25GaW5pc2hDaGFuZ2UoIGNvbnRyb2xsZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXHRcdFx0dGhpcy5wYXJlbnQuX2NhbGxPbkZpbmlzaENoYW5nZSggY29udHJvbGxlciApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fb25GaW5pc2hDaGFuZ2UgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX29uRmluaXNoQ2hhbmdlLmNhbGwoIHRoaXMsIHtcblx0XHRcdFx0b2JqZWN0OiBjb250cm9sbGVyLm9iamVjdCxcblx0XHRcdFx0cHJvcGVydHk6IGNvbnRyb2xsZXIucHJvcGVydHksXG5cdFx0XHRcdHZhbHVlOiBjb250cm9sbGVyLmdldFZhbHVlKCksXG5cdFx0XHRcdGNvbnRyb2xsZXJcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUGFzcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoaXMgR1VJIG9yIGl0cyBkZXNjZW5kYW50cyBhcmUgb3BlbmVkIG9yIGNsb3NlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihHVUkpfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLm9uT3BlbkNsb3NlKCBjaGFuZ2VkR1VJID0+IHtcblx0ICogXHRjb25zb2xlLmxvZyggY2hhbmdlZEdVSS5fY2xvc2VkICk7XG5cdCAqIH0gKTtcblx0ICovXG5cdG9uT3BlbkNsb3NlKCBjYWxsYmFjayApIHtcblx0XHR0aGlzLl9vbk9wZW5DbG9zZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2NhbGxPbk9wZW5DbG9zZSggY2hhbmdlZEdVSSApIHtcblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXHRcdFx0dGhpcy5wYXJlbnQuX2NhbGxPbk9wZW5DbG9zZSggY2hhbmdlZEdVSSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fb25PcGVuQ2xvc2UgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX29uT3BlbkNsb3NlLmNhbGwoIHRoaXMsIGNoYW5nZWRHVUkgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgYWxsIERPTSBlbGVtZW50cyBhbmQgZXZlbnQgbGlzdGVuZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEdVSS5cblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXHRcdFx0dGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKCB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKCB0aGlzICksIDEgKTtcblx0XHRcdHRoaXMucGFyZW50LmZvbGRlcnMuc3BsaWNlKCB0aGlzLnBhcmVudC5mb2xkZXJzLmluZGV4T2YoIHRoaXMgKSwgMSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQgKSB7XG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGhpcy5kb21FbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0QXJyYXkuZnJvbSggdGhpcy5jaGlsZHJlbiApLmZvckVhY2goIGMgPT4gYy5kZXN0cm95KCkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29udHJvbGxlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJIGFuZCBpdHMgZGVzY2VuZGVudHMuXG5cdCAqIEByZXR1cm5zIHtDb250cm9sbGVyW119XG5cdCAqL1xuXHRjb250cm9sbGVyc1JlY3Vyc2l2ZSgpIHtcblx0XHRsZXQgY29udHJvbGxlcnMgPSBBcnJheS5mcm9tKCB0aGlzLmNvbnRyb2xsZXJzICk7XG5cdFx0dGhpcy5mb2xkZXJzLmZvckVhY2goIGYgPT4ge1xuXHRcdFx0Y29udHJvbGxlcnMgPSBjb250cm9sbGVycy5jb25jYXQoIGYuY29udHJvbGxlcnNSZWN1cnNpdmUoKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gY29udHJvbGxlcnM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBmb2xkZXJzIGNvbnRhaW5lZCBieSB0aGlzIEdVSSBhbmQgaXRzIGRlc2NlbmRlbnRzLlxuXHQgKiBAcmV0dXJucyB7R1VJW119XG5cdCAqL1xuXHRmb2xkZXJzUmVjdXJzaXZlKCkge1xuXHRcdGxldCBmb2xkZXJzID0gQXJyYXkuZnJvbSggdGhpcy5mb2xkZXJzICk7XG5cdFx0dGhpcy5mb2xkZXJzLmZvckVhY2goIGYgPT4ge1xuXHRcdFx0Zm9sZGVycyA9IGZvbGRlcnMuY29uY2F0KCBmLmZvbGRlcnNSZWN1cnNpdmUoKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZm9sZGVycztcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEdVSTtcbmV4cG9ydCB7IEJvb2xlYW5Db250cm9sbGVyLCBDb2xvckNvbnRyb2xsZXIsIENvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgR1VJLCBOdW1iZXJDb250cm9sbGVyLCBPcHRpb25Db250cm9sbGVyLCBTdHJpbmdDb250cm9sbGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///332\n")}}]);