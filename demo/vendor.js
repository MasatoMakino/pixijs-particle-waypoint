(self.webpackChunk_masatomakino_pixijs_particle_waypoint=self.webpackChunk_masatomakino_pixijs_particle_waypoint||[]).push([[736],{720:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EseUJBQXNCOztBQUV0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsTUFBTTtBQUNOLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0Msd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsd0RBQXdEOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHdCQUF3QixvQkFBb0I7QUFDNUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzPzllNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAzMjc2NyAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgdmFyIHAgPSBjLm5leHQ7XG4gICAgd2hpbGUgKHAgIT09IGEpIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcih4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKHgxLCB5MSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAoIWJyaWRnZSkge1xuICAgICAgICByZXR1cm4gb3V0ZXJOb2RlO1xuICAgIH1cblxuICAgIHZhciBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKGJyaWRnZSwgaG9sZSk7XG5cbiAgICAvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICBmaWx0ZXJQb2ludHMoYnJpZGdlUmV2ZXJzZSwgYnJpZGdlUmV2ZXJzZS5uZXh0KTtcbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKGJyaWRnZSwgYnJpZGdlLm5leHQpO1xufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSAwKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAoeCAtIG1pblgpICogaW52U2l6ZSB8IDA7XG4gICAgeSA9ICh5IC0gbWluWSkgKiBpbnZTaXplIHwgMDtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgPj0gKGF4IC0gcHgpICogKGN5IC0gcHkpICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSA+PSAoYnggLSBweCkgKiAoYXkgLSBweSkgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpID49IChjeCAtIHB4KSAqIChieSAtIHB5KTtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG4gICAgICAgICAgIChsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHZhciBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgdmFyIG8yID0gc2lnbihhcmVhKHAxLCBxMSwgcTIpKTtcbiAgICB2YXIgbzMgPSBzaWduKGFyZWEocDIsIHEyLCBwMSkpO1xuICAgIHZhciBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gMDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///720\n")},3034:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBNkI7QUFDakM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/NzAyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3034\n")},1379:module=>{eval("\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3OS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGFyc2Utc3ZnLXBhdGgvaW5kZXguanM/NzY4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcblxuLyoqXG4gKiBleHBlY3RlZCBhcmd1bWVudCBsZW5ndGhzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBsZW5ndGggPSB7YTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMH1cblxuLyoqXG4gKiBzZWdtZW50IHBhdHRlcm5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cblxudmFyIHNlZ21lbnQgPSAvKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnXG5cbi8qKlxuICogcGFyc2UgYW4gc3ZnIHBhdGggZGF0YSBzdHJpbmcuIEdlbmVyYXRlcyBhbiBBcnJheVxuICogb2YgY29tbWFuZHMgd2hlcmUgZWFjaCBjb21tYW5kIGlzIGFuIEFycmF5IG9mIHRoZVxuICogZm9ybSBgW2NvbW1hbmQsIGFyZzEsIGFyZzIsIC4uLl1gXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcblx0dmFyIGRhdGEgPSBbXVxuXHRwYXRoLnJlcGxhY2Uoc2VnbWVudCwgZnVuY3Rpb24oXywgY29tbWFuZCwgYXJncyl7XG5cdFx0dmFyIHR5cGUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKClcblx0XHRhcmdzID0gcGFyc2VWYWx1ZXMoYXJncylcblxuXHRcdC8vIG92ZXJsb2FkZWQgbW92ZVRvXG5cdFx0aWYgKHR5cGUgPT0gJ20nICYmIGFyZ3MubGVuZ3RoID4gMikge1xuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgMikpKVxuXHRcdFx0dHlwZSA9ICdsJ1xuXHRcdFx0Y29tbWFuZCA9IGNvbW1hbmQgPT0gJ20nID8gJ2wnIDogJ0wnXG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PSBsZW5ndGhbdHlwZV0pIHtcblx0XHRcdFx0YXJncy51bnNoaWZ0KGNvbW1hbmQpXG5cdFx0XHRcdHJldHVybiBkYXRhLnB1c2goYXJncylcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmxlbmd0aCA8IGxlbmd0aFt0eXBlXSkgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgcGF0aCBkYXRhJylcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIGxlbmd0aFt0eXBlXSkpKVxuXHRcdH1cblx0fSlcblx0cmV0dXJuIGRhdGFcbn1cblxudmFyIG51bWJlciA9IC8tP1swLTldKlxcLj9bMC05XSsoPzplWy0rXT9cXGQrKT8vaWdcblxuZnVuY3Rpb24gcGFyc2VWYWx1ZXMoYXJncykge1xuXHR2YXIgbnVtYmVycyA9IGFyZ3MubWF0Y2gobnVtYmVyKVxuXHRyZXR1cm4gbnVtYmVycyA/IG51bWJlcnMubWFwKE51bWJlcikgOiBbXVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1379\n")},4146:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   v: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3034);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0Ni5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFZDtBQUN2QixpRUFBZSxzQ0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzPzE5MzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2luZGV4LmpzJ1xuXG5leHBvcnQgeyBFdmVudEVtaXR0ZXIgfVxuZXhwb3J0IGRlZmF1bHQgRXZlbnRFbWl0dGVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4146\n")},4162:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ Cache)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4796);\n/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9879);\n\n\n\n"use strict";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertToList */ .S)(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)("[Cache] already has key:", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n\n//# sourceMappingURL=Cache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2Mi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUNPOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzRUFBSSxzQkFBc0IsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0ZBQWE7QUFDOUI7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFJO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNFQUFJLHNCQUFzQixLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanM/NjBmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhY2hlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJzZXJzID0gW107XG4gICAgdGhpcy5fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NhY2hlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKiogQ2xlYXIgYWxsIGVudHJpZXMuICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhY2hlTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGtleSBleGlzdHNcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2tcbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGVudHJ5IGJ5IGtleVxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gZ2V0XG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHdhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBieSBrZXkgb3Iga2V5cyBuYW1lXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9yIGtleXMgdG8gc2V0XG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGUgY2FjaGUgb3IgZnJvbSB3aGljaCBjYWNoZWFibGUgYXNzZXRzIHdpbGwgYmUgZGVyaXZlZC5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbnZlcnRUb0xpc3Qoa2V5KTtcbiAgICBsZXQgY2FjaGVhYmxlQXNzZXRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICBpZiAocGFyc2VyLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNhY2hlYWJsZUFzc2V0cyA9IHBhcnNlci5nZXRDYWNoZWFibGVBc3NldHMoa2V5cywgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FjaGVhYmxlTWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhjYWNoZWFibGVBc3NldHMgfHwge30pKTtcbiAgICBpZiAoIWNhY2hlYWJsZUFzc2V0cykge1xuICAgICAga2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGNhY2hlYWJsZU1hcC5zZXQoa2V5MiwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5cyA9IFsuLi5jYWNoZWFibGVNYXAua2V5cygpXTtcbiAgICBjb25zdCBjYWNoZWRBc3NldHMgPSB7XG4gICAgICBjYWNoZUtleXMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLnNldChrZXkyLCBjYWNoZWRBc3NldHMpO1xuICAgIH0pO1xuICAgIGNhY2hlS2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBjYWNoZWFibGVBc3NldHMgPyBjYWNoZWFibGVBc3NldHNba2V5Ml0gOiB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoa2V5MikgJiYgdGhpcy5fY2FjaGUuZ2V0KGtleTIpICE9PSB2YWwpIHtcbiAgICAgICAgd2FybihcIltDYWNoZV0gYWxyZWFkeSBoYXMga2V5OlwiLCBrZXkyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLnNldChrZXkyLCBjYWNoZWFibGVNYXAuZ2V0KGtleTIpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGVudHJ5IGJ5IGtleVxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyByZW1vdmUgYW55IGFzc29jaWF0ZWQgYWxpYXMgZnJvbSB0aGUgY2FjaGUgYWxzby5cbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlKGtleSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIHdhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZU1hcCA9IHRoaXMuX2NhY2hlTWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGNhY2hlS2V5cyA9IGNhY2hlTWFwLmNhY2hlS2V5cztcbiAgICBjYWNoZUtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGtleTIpO1xuICAgIH0pO1xuICAgIGNhY2hlTWFwLmtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGVNYXAuZGVsZXRlKGtleTIpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBBbGwgbG9hZGVyIHBhcnNlcnMgcmVnaXN0ZXJlZCAqL1xuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxufVxuY29uc3QgQ2FjaGUgPSBuZXcgQ2FjaGVDbGFzcygpO1xuXG5leHBvcnQgeyBDYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4162\n')},4334:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ LoaderParserPriority)\n/* harmony export */ });\n\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";\n  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";\n  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\n\n//# sourceMappingURL=LoaderParser.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMzNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7QUFFRztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzPzdlMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSAvKiBAX19QVVJFX18gKi8gKChMb2FkZXJQYXJzZXJQcmlvcml0eTIpID0+IHtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIkxvd1wiXSA9IDBdID0gXCJMb3dcIjtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIk5vcm1hbFwiXSA9IDFdID0gXCJOb3JtYWxcIjtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIkhpZ2hcIl0gPSAyXSA9IFwiSGlnaFwiO1xuICByZXR1cm4gTG9hZGVyUGFyc2VyUHJpb3JpdHkyO1xufSkoTG9hZGVyUGFyc2VyUHJpb3JpdHkgfHwge30pO1xuXG5leHBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyUGFyc2VyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4334\n')},651:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  H: () => (/* binding */ Resolver)\n});\n\n// UNUSED EXPORTS: getUrlExtension\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/convertToList.mjs\nvar convertToList = __webpack_require__(9879);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs\n\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs\nvar isSingleItem = __webpack_require__(1675);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs\n\n\n\n\n\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = (0,convertToList/* convertToList */.S)(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      (0,warn/* warn */.Z)(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        (0,warn/* warn */.Z)(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = (0,convertToList/* convertToList */.S)(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = (0,convertToList/* convertToList */.S)(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(bundleIds);\n    bundleIds = (0,convertToList/* convertToList */.S)(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(keys);\n    keys = (0,convertToList/* convertToList */.S)(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path/* path */.E.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n\n//# sourceMappingURL=Resolver.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcz85ZjdjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9yZXNvbHZlci9SZXNvbHZlci5tanM/OTZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHByb2Nlc3NYKGJhc2UsIGlkcywgZGVwdGgsIHJlc3VsdCwgdGFncykge1xuICBjb25zdCBpZCA9IGlkc1tkZXB0aF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlkW2ldO1xuICAgIGlmIChkZXB0aCA8IGlkcy5sZW5ndGggLSAxKSB7XG4gICAgICBwcm9jZXNzWChiYXNlLnJlcGxhY2UocmVzdWx0W2RlcHRoXSwgdmFsdWUpLCBpZHMsIGRlcHRoICsgMSwgcmVzdWx0LCB0YWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFncy5wdXNoKGJhc2UucmVwbGFjZShyZXN1bHRbZGVwdGhdLCB2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyhzdHJpbmcpIHtcbiAgY29uc3QgcmVnZXggPSAvXFx7KC4qPylcXH0vZztcbiAgY29uc3QgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKHJlZ2V4KTtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBpZiAocmVzdWx0KSB7XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgcmVzdWx0LmZvckVhY2goKHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IHNwbGl0ID0gdmFycy5zdWJzdHJpbmcoMSwgdmFycy5sZW5ndGggLSAxKS5zcGxpdChcIixcIik7XG4gICAgICBpZHMucHVzaChzcGxpdCk7XG4gICAgfSk7XG4gICAgcHJvY2Vzc1goc3RyaW5nLCBpZHMsIDAsIHJlc3VsdCwgdGFncyk7XG4gIH0gZWxzZSB7XG4gICAgdGFncy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgcGF0aCB9IGZyb20gJy4uLy4uL3V0aWxzL3BhdGgubWpzJztcbmltcG9ydCB7IGNvbnZlcnRUb0xpc3QgfSBmcm9tICcuLi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH0gZnJvbSAnLi4vdXRpbHMvY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanMnO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi4vdXRpbHMvaXNTaW5nbGVJdGVtLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMgPSB7XG4gICAgICBjb25uZWN0b3I6IFwiLVwiLFxuICAgICAgY3JlYXRlQnVuZGxlQXNzZXRJZDogKGJ1bmRsZUlkLCBhc3NldElkKSA9PiBgJHtidW5kbGVJZH0ke3RoaXMuX2J1bmRsZUlkQ29ubmVjdG9yfSR7YXNzZXRJZH1gLFxuICAgICAgZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlOiAoYnVuZGxlSWQsIGFzc2V0QnVuZGxlSWQpID0+IGFzc2V0QnVuZGxlSWQucmVwbGFjZShgJHtidW5kbGVJZH0ke3RoaXMuX2J1bmRsZUlkQ29ubmVjdG9yfWAsIFwiXCIpXG4gICAgfTtcbiAgICAvKiogVGhlIGNoYXJhY3RlciB0aGF0IGlzIHVzZWQgdG8gY29ubmVjdCB0aGUgYnVuZGxlSWQgYW5kIHRoZSBhc3NldElkIHdoZW4gZ2VuZXJhdGluZyBhIGJ1bmRsZSBhc3NldCBpZCBrZXkgKi9cbiAgICB0aGlzLl9idW5kbGVJZENvbm5lY3RvciA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5jb25uZWN0b3I7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIGJ1bmRsZSBhc3NldCBpZCBrZXkgZnJvbSBhIGJ1bmRsZUlkIGFuZCBhbiBhc3NldElkXG4gICAgICogQHBhcmFtIGJ1bmRsZUlkIC0gdGhlIGJ1bmRsZUlkXG4gICAgICogQHBhcmFtIGFzc2V0SWQgIC0gdGhlIGFzc2V0SWRcbiAgICAgKiBAcmV0dXJucyB0aGUgYnVuZGxlIGFzc2V0IGlkIGtleVxuICAgICAqL1xuICAgIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuY3JlYXRlQnVuZGxlQXNzZXRJZDtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGFuIGFzc2V0SWQgZnJvbSBhIGJ1bmRsZSBhc3NldCBpZCBrZXkuIFRoaXMgaXMgdGhlIHJldmVyc2Ugb2YgZ2VuZXJhdGVCdW5kbGVBc3NldElkXG4gICAgICogQHBhcmFtIGJ1bmRsZUlkIC0gdGhlIGJ1bmRsZUlkXG4gICAgICogQHBhcmFtIGFzc2V0QnVuZGxlSWQgLSB0aGUgYnVuZGxlIGFzc2V0IGlkIGtleVxuICAgICAqIEByZXR1cm5zIHRoZSBhc3NldElkXG4gICAgICovXG4gICAgdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTtcbiAgICB0aGlzLl9hc3NldE1hcCA9IHt9O1xuICAgIHRoaXMuX3ByZWZlcnJlZE9yZGVyID0gW107XG4gICAgdGhpcy5fcGFyc2VycyA9IFtdO1xuICAgIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9O1xuICAgIHRoaXMuX2J1bmRsZXMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgaG93IHRoZSByZXNvbHZlciBkZWFscyB3aXRoIGdlbmVyYXRpbmcgYnVuZGxlIGlkcy5cbiAgICogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGFueSBidW5kbGVzIGFyZSBhZGRlZFxuICAgKiBAcGFyYW0gYnVuZGxlSWRlbnRpZmllciAtIHRoZSBidW5kbGUgaWRlbnRpZmllciBvcHRpb25zXG4gICAqL1xuICBzZXRCdW5kbGVJZGVudGlmaWVyKGJ1bmRsZUlkZW50aWZpZXIpIHtcbiAgICB0aGlzLl9idW5kbGVJZENvbm5lY3RvciA9IGJ1bmRsZUlkZW50aWZpZXIuY29ubmVjdG9yID8/IHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yO1xuICAgIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQgPSBidW5kbGVJZGVudGlmaWVyLmNyZWF0ZUJ1bmRsZUFzc2V0SWQgPz8gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZDtcbiAgICB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPSBidW5kbGVJZGVudGlmaWVyLmV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA/PyB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGU7XG4gICAgaWYgKHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZShcImZvb1wiLCB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKFwiZm9vXCIsIFwiYmFyXCIpKSAhPT0gXCJiYXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Jlc29sdmVyXSBHZW5lcmF0ZUJ1bmRsZUFzc2V0SWQgYXJlIG5vdCB3b3JraW5nIGNvcnJlY3RseVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExldCB0aGUgcmVzb2x2ZXIga25vdyB3aGljaCBhc3NldHMgeW91IHByZWZlciB0byB1c2Ugd2hlbiByZXNvbHZpbmcgYXNzZXRzLlxuICAgKiBNdWx0aXBsZSBwcmVmZXIgdXNlciBkZWZpbmVkIHJ1bGVzIGNhbiBiZSBhZGRlZC5cbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIucHJlZmVyKHtcbiAgICogICAgIC8vIGZpcnN0IGxvb2sgZm9yIHNvbWV0aGluZyB3aXRoIHRoZSBjb3JyZWN0IGZvcm1hdCwgYW5kIHRoZW4gdGhlbiBjb3JyZWN0IHJlc29sdXRpb25cbiAgICogICAgIHByaW9yaXR5OiBbJ2Zvcm1hdCcsICdyZXNvbHV0aW9uJ10sXG4gICAqICAgICBwYXJhbXM6e1xuICAgKiAgICAgICAgIGZvcm1hdDond2VicCcsIC8vIHByZWZlciB3ZWJwIGltYWdlc1xuICAgKiAgICAgICAgIHJlc29sdXRpb246IDIsIC8vIHByZWZlciBhIHJlc29sdXRpb24gb2YgMlxuICAgKiAgICAgfVxuICAgKiB9KVxuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsIFsnYmFyQDJ4LndlYnAnLCAnYmFyQDJ4LnBuZycsICdiYXIud2VicCcsICdiYXIucG5nJ10pO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nKSAvLyA9PiAnYmFyQDJ4LndlYnAnXG4gICAqIEBwYXJhbSBwcmVmZXJPcmRlcnMgLSB0aGUgcHJlZmVyIG9wdGlvbnNcbiAgICovXG4gIHByZWZlciguLi5wcmVmZXJPcmRlcnMpIHtcbiAgICBwcmVmZXJPcmRlcnMuZm9yRWFjaCgocHJlZmVyKSA9PiB7XG4gICAgICB0aGlzLl9wcmVmZXJyZWRPcmRlci5wdXNoKHByZWZlcik7XG4gICAgICBpZiAoIXByZWZlci5wcmlvcml0eSkge1xuICAgICAgICBwcmVmZXIucHJpb3JpdHkgPSBPYmplY3Qua2V5cyhwcmVmZXIucGFyYW1zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBiYXNlIHBhdGggdG8gcHJlcGVuZCB0byBhbGwgdXJscyB3aGVuIHJlc29sdmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiByZXNvbHZlci5iYXNlUGF0aCA9ICdodHRwczovL2hvbWUuY29tLyc7XG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgJ2Jhci5vbmcnKTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJywgJ2Jhci5wbmcnKTsgLy8gPT4gJ2h0dHBzOi8vaG9tZS5jb20vYmFyLnBuZydcbiAgICogQHBhcmFtIGJhc2VQYXRoIC0gdGhlIGJhc2UgcGF0aCB0byB1c2VcbiAgICovXG4gIHNldCBiYXNlUGF0aChiYXNlUGF0aCkge1xuICAgIHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG4gIH1cbiAgZ2V0IGJhc2VQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlUGF0aDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSByb290IHBhdGggZm9yIHJvb3QtcmVsYXRpdmUgVVJMcy4gQnkgZGVmYXVsdCB0aGUgYGJhc2VQYXRoYCdzIHJvb3QgaXMgdXNlZC4gSWYgbm8gYGJhc2VQYXRoYCBpcyBzZXQsIHRoZW4gdGhlXG4gICAqIGRlZmF1bHQgdmFsdWUgZm9yIGJyb3dzZXJzIGlzIGB3aW5kb3cubG9jYXRpb24ub3JpZ2luYFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBBcHBsaWNhdGlvbiBob3N0ZWQgb24gaHR0cHM6Ly9ob21lLmNvbS9zb21lLXBhdGgvaW5kZXguaHRtbFxuICAgKiByZXNvbHZlci5iYXNlUGF0aCA9ICdodHRwczovL2hvbWUuY29tL3NvbWUtcGF0aC8nO1xuICAgKiByZXNvbHZlci5yb290UGF0aCA9ICdodHRwczovL2hvbWUuY29tLyc7XG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgJy9iYXIucG5nJyk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycsICcvYmFyLnBuZycpOyAvLyA9PiAnaHR0cHM6Ly9ob21lLmNvbS9iYXIucG5nJ1xuICAgKiBAcGFyYW0gcm9vdFBhdGggLSB0aGUgcm9vdCBwYXRoIHRvIHVzZVxuICAgKi9cbiAgc2V0IHJvb3RQYXRoKHJvb3RQYXRoKSB7XG4gICAgdGhpcy5fcm9vdFBhdGggPSByb290UGF0aDtcbiAgfVxuICBnZXQgcm9vdFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoO1xuICB9XG4gIC8qKlxuICAgKiBBbGwgdGhlIGFjdGl2ZSBVUkwgcGFyc2VycyB0aGF0IGhlbHAgdGhlIHBhcnNlciB0byBleHRyYWN0IGluZm9ybWF0aW9uIGFuZCBjcmVhdGVcbiAgICogYW4gYXNzZXQgb2JqZWN0LWJhc2VkIG9uIHBhcnNpbmcgdGhlIFVSTCBpdHNlbGYuXG4gICAqXG4gICAqIENhbiBiZSBhZGRlZCB1c2luZyB0aGUgZXh0ZW5zaW9ucyBBUElcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCBbXG4gICAqICAgICB7XG4gICAqICAgICAgICAgcmVzb2x1dGlvbjogMixcbiAgICogICAgICAgICBmb3JtYXQ6ICdwbmcnLFxuICAgKiAgICAgICAgIHNyYzogJ2ltYWdlQDJ4LnBuZycsXG4gICAqICAgICB9LFxuICAgKiAgICAge1xuICAgKiAgICAgICAgIHJlc29sdXRpb246MSxcbiAgICogICAgICAgICBmb3JtYXQ6J3BuZycsXG4gICAqICAgICAgICAgc3JjOiAnaW1hZ2UucG5nJyxcbiAgICogICAgIH0sXG4gICAqIF0pO1xuICAgKlxuICAgKiAvLyBXaXRoIGEgdXJsIHBhcnNlciB0aGUgaW5mb3JtYXRpb24gc3VjaCBhcyByZXNvbHV0aW9uIGFuZCBmaWxlIGZvcm1hdCBjb3VsZCBleHRyYWN0ZWQgZnJvbSB0aGUgdXJsIGl0c2VsZjpcbiAgICogZXh0ZW5zaW9ucy5hZGQoe1xuICAgKiAgICAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gICAqICAgICB0ZXN0OiBsb2FkVGV4dHVyZXMudGVzdCwgLy8gdGVzdCBpZiB1cmwgZW5kcyBpbiBhbiBpbWFnZVxuICAgKiAgICAgcGFyc2U6ICh2YWx1ZTogc3RyaW5nKSA9PlxuICAgKiAgICAgKHtcbiAgICogICAgICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KFJlc29sdmVyLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyAnMScpLFxuICAgKiAgICAgICAgIGZvcm1hdDogdmFsdWUuc3BsaXQoJy4nKS5wb3AoKSxcbiAgICogICAgICAgICBzcmM6IHZhbHVlLFxuICAgKiAgICAgfSksXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBOb3cgcmVzb2x1dGlvbiBhbmQgZm9ybWF0IGNhbiBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgdXJsXG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgW1xuICAgKiAgICAgJ2ltYWdlQDJ4LnBuZycsXG4gICAqICAgICAnaW1hZ2UucG5nJyxcbiAgICogXSk7XG4gICAqL1xuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxuICAvKiogVXNlZCBmb3IgdGVzdGluZywgdGhpcyByZXNldHMgdGhlIHJlc29sdmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0QnVuZGxlSWRlbnRpZmllcih0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMpO1xuICAgIHRoaXMuX2Fzc2V0TWFwID0ge307XG4gICAgdGhpcy5fcHJlZmVycmVkT3JkZXIgPSBbXTtcbiAgICB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgICB0aGlzLl9yb290UGF0aCA9IG51bGw7XG4gICAgdGhpcy5fYmFzZVBhdGggPSBudWxsO1xuICAgIHRoaXMuX21hbmlmZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9idW5kbGVzID0ge307XG4gICAgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzIGZvciB0aGUgVVJMIHJlc29sdmVyLiBUaGUgdXJscyBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHNlYXJjaFBhcmFtcyAtIHRoZSBkZWZhdWx0IHVybCBwYXJhbWV0ZXJzIHRvIGFwcGVuZCB3aGVuIHJlc29sdmluZyB1cmxzXG4gICAqL1xuICBzZXREZWZhdWx0U2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgIGlmICh0eXBlb2Ygc2VhcmNoUGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBxdWVyeVZhbHVlcyA9IHNlYXJjaFBhcmFtcztcbiAgICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVZhbHVlcykubWFwKChrZXkpID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeVZhbHVlc1trZXldKX1gKS5qb2luKFwiJlwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFsaWFzZXMgZm9yIGEgZ2l2ZW4gYXNzZXRcbiAgICogQHBhcmFtIGFzc2V0IC0gdGhlIGFzc2V0IHRvIGdldCB0aGUgYWxpYXNlcyBmb3JcbiAgICovXG4gIGdldEFsaWFzKGFzc2V0KSB7XG4gICAgY29uc3QgeyBhbGlhcywgc3JjIH0gPSBhc3NldDtcbiAgICBjb25zdCBhbGlhc2VzVG9Vc2UgPSBjb252ZXJ0VG9MaXN0KFxuICAgICAgYWxpYXMgfHwgc3JjLFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdj8uc3JjID8/IHYpO1xuICAgICAgICBpZiAodmFsdWU/LnNyYylcbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3JjO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIGFsaWFzZXNUb1VzZTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbWFuaWZlc3QgdG8gdGhlIGFzc2V0IHJlc29sdmVyLiBUaGlzIGlzIGEgbmljZSB3YXkgdG8gYWRkIGFsbCB0aGUgYXNzZXQgaW5mb3JtYXRpb24gaW4gb25lIGdvLlxuICAgKiBnZW5lcmFsbHkgYSBtYW5pZmVzdCB3b3VsZCBiZSBidWlsdCB1c2luZyBhIHRvb2wuXG4gICAqIEBwYXJhbSBtYW5pZmVzdCAtIHRoZSBtYW5pZmVzdCB0byBhZGQgdG8gdGhlIHJlc29sdmVyXG4gICAqL1xuICBhZGRNYW5pZmVzdChtYW5pZmVzdCkge1xuICAgIGlmICh0aGlzLl9tYW5pZmVzdCkge1xuICAgICAgd2FybihcIltSZXNvbHZlcl0gTWFuaWZlc3QgYWxyZWFkeSBleGlzdHMsIHRoaXMgd2lsbCBiZSBvdmVyd3JpdHRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5fbWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICBtYW5pZmVzdC5idW5kbGVzLmZvckVhY2goKGJ1bmRsZSkgPT4ge1xuICAgICAgdGhpcy5hZGRCdW5kbGUoYnVuZGxlLm5hbWUsIGJ1bmRsZS5hc3NldHMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGFkZHMgYSBidW5kbGUgb2YgYXNzZXRzIGluIG9uZSBnbyBzbyB0aGF0IHlvdSBjYW4gcmVzb2x2ZSB0aGVtIGFzIGEgZ3JvdXAuXG4gICAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCBhZGQgYSBidW5kbGUgZm9yIGVhY2ggc2NyZWVuIGluIHlvdSBwaXhpIGFwcFxuICAgKiBAZXhhbXBsZVxuICAgKiByZXNvbHZlci5hZGRCdW5kbGUoJ2FuaW1hbHMnLCBbXG4gICAqICB7IGFsaWFzOiAnYnVubnknLCBzcmM6ICdidW5ueS5wbmcnIH0sXG4gICAqICB7IGFsaWFzOiAnY2hpY2tlbicsIHNyYzogJ2NoaWNrZW4ucG5nJyB9LFxuICAgKiAgeyBhbGlhczogJ3RodW1wZXInLCBzcmM6ICd0aHVtcGVyLnBuZycgfSxcbiAgICogXSk7XG4gICAqIC8vIG9yXG4gICAqIHJlc29sdmVyLmFkZEJ1bmRsZSgnYW5pbWFscycsIHtcbiAgICogICAgIGJ1bm55OiAnYnVubnkucG5nJyxcbiAgICogICAgIGNoaWNrZW46ICdjaGlja2VuLnBuZycsXG4gICAqICAgICB0aHVtcGVyOiAndGh1bXBlci5wbmcnLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgcmVzb2x2ZWRBc3NldHMgPSBhd2FpdCByZXNvbHZlci5yZXNvbHZlQnVuZGxlKCdhbmltYWxzJyk7XG4gICAqIEBwYXJhbSBidW5kbGVJZCAtIFRoZSBpZCBvZiB0aGUgYnVuZGxlIHRvIGFkZFxuICAgKiBAcGFyYW0gYXNzZXRzIC0gQSByZWNvcmQgb2YgdGhlIGFzc2V0IG9yIGFzc2V0cyB0aGF0IHdpbGwgYmUgY2hvc2VuIGZyb20gd2hlbiBsb2FkaW5nIHZpYSB0aGUgc3BlY2lmaWVkIGtleVxuICAgKi9cbiAgYWRkQnVuZGxlKGJ1bmRsZUlkLCBhc3NldHMpIHtcbiAgICBjb25zdCBhc3NldE5hbWVzID0gW107XG4gICAgbGV0IGNvbnZlcnRlZEFzc2V0cyA9IGFzc2V0cztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXNzZXRzKSkge1xuICAgICAgY29udmVydGVkQXNzZXRzID0gT2JqZWN0LmVudHJpZXMoYXNzZXRzKS5tYXAoKFthbGlhcywgc3JjXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICByZXR1cm4geyBhbGlhcywgc3JjIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYWxpYXMsIC4uLnNyYyB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnZlcnRlZEFzc2V0cy5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgY29uc3Qgc3JjcyA9IGFzc2V0LnNyYztcbiAgICAgIGNvbnN0IGFsaWFzZXMgPSBhc3NldC5hbGlhcztcbiAgICAgIGxldCBpZHM7XG4gICAgICBpZiAodHlwZW9mIGFsaWFzZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgYnVuZGxlQXNzZXRJZCA9IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGFsaWFzZXMpO1xuICAgICAgICBhc3NldE5hbWVzLnB1c2goYnVuZGxlQXNzZXRJZCk7XG4gICAgICAgIGlkcyA9IFthbGlhc2VzLCBidW5kbGVBc3NldElkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUlkcyA9IGFsaWFzZXMubWFwKChuYW1lKSA9PiB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBuYW1lKSk7XG4gICAgICAgIGFzc2V0TmFtZXMucHVzaCguLi5idW5kbGVJZHMpO1xuICAgICAgICBpZHMgPSBbLi4uYWxpYXNlcywgLi4uYnVuZGxlSWRzXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkKHtcbiAgICAgICAgLi4uYXNzZXQsXG4gICAgICAgIC4uLntcbiAgICAgICAgICBhbGlhczogaWRzLFxuICAgICAgICAgIHNyYzogc3Jjc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9idW5kbGVzW2J1bmRsZUlkXSA9IGFzc2V0TmFtZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRlbGxzIHRoZSByZXNvbHZlciB3aGF0IGtleXMgYXJlIGFzc29jaWF0ZWQgd2l0aCB3aXRjaCBhc3NldC5cbiAgICogVGhlIG1vc3QgaW1wb3J0YW50IHRoaW5nIHRoZSByZXNvbHZlciBkb2VzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNpbmdsZSBrZXksIHNpbmdsZSBhc3NldDpcbiAgICogcmVzb2x2ZXIuYWRkKHthbGlhczogJ2ZvbycsIHNyYzogJ2Jhci5wbmcnKTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJykgLy8gPT4gJ2Jhci5wbmcnXG4gICAqXG4gICAqIC8vIE11bHRpcGxlIGtleXMsIHNpbmdsZSBhc3NldDpcbiAgICogcmVzb2x2ZXIuYWRkKHthbGlhczogWydmb28nLCAnYm9vJ10sIHNyYzogJ2Jhci5wbmcnfSk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycpIC8vID0+ICdiYXIucG5nJ1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdib28nKSAvLyA9PiAnYmFyLnBuZydcbiAgICpcbiAgICogLy8gTXVsdGlwbGUga2V5cywgbXVsdGlwbGUgYXNzZXRzOlxuICAgKiByZXNvbHZlci5hZGQoe2FsaWFzOiBbJ2ZvbycsICdib28nXSwgc3JjOiBbJ2Jhci5wbmcnLCAnYmFyLndlYnAnXX0pO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nKSAvLyA9PiAnYmFyLnBuZydcbiAgICpcbiAgICogLy8gQWRkIGN1c3RvbSBkYXRhIGF0dGFjaGVkIHRvIHRoZSByZXNvbHZlclxuICAgKiBSZXNvbHZlci5hZGQoe1xuICAgKiAgICAgYWxpYXM6ICdidW5ueUJvb0Jvb1Ntb290aCcsXG4gICAqICAgICBzcmM6ICdidW5ueXtwbmcsd2VicH0nLFxuICAgKiAgICAgZGF0YTogeyBzY2FsZU1vZGU6U0NBTEVfTU9ERVMuTkVBUkVTVCB9LCAvLyBCYXNlIHRleHR1cmUgb3B0aW9uc1xuICAgKiB9KTtcbiAgICpcbiAgICogcmVzb2x2ZXIucmVzb2x2ZSgnYnVubnlCb29Cb29TbW9vdGgnKSAvLyA9PiB7IHNyYzogJ2J1bm55LnBuZycsIGRhdGE6IHsgc2NhbGVNb2RlOiBTQ0FMRV9NT0RFUy5ORUFSRVNUIH0gfVxuICAgKiBAcGFyYW0gYWxpYXNlcyAtIHRoZSBVbnJlc29sdmVkQXNzZXQgb3IgYXJyYXkgb2YgVW5yZXNvbHZlZEFzc2V0cyB0byBhZGQgdG8gdGhlIHJlc29sdmVyXG4gICAqL1xuICBhZGQoYWxpYXNlcykge1xuICAgIGNvbnN0IGFzc2V0cyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFsaWFzZXMpKSB7XG4gICAgICBhc3NldHMucHVzaCguLi5hbGlhc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXRzLnB1c2goYWxpYXNlcyk7XG4gICAgfVxuICAgIGxldCBrZXlDaGVjaztcbiAgICBrZXlDaGVjayA9IChrZXkpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0tleShrZXkpKSB7XG4gICAgICAgIHdhcm4oYFtSZXNvbHZlcl0gYWxyZWFkeSBoYXMga2V5OiAke2tleX0gb3ZlcndyaXRpbmdgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFzc2V0QXJyYXkgPSBjb252ZXJ0VG9MaXN0KGFzc2V0cyk7XG4gICAgYXNzZXRBcnJheS5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgeyBzcmMgfSA9IGFzc2V0O1xuICAgICAgbGV0IHsgZGF0YSwgZm9ybWF0LCBsb2FkUGFyc2VyIH0gPSBhc3NldDtcbiAgICAgIGNvbnN0IHNyY3NUb1VzZSA9IGNvbnZlcnRUb0xpc3Qoc3JjKS5tYXAoKHNyYzIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoc3JjMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3JjMikgPyBzcmMyIDogW3NyYzJdO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBhbGlhc2VzVG9Vc2UgPSB0aGlzLmdldEFsaWFzKGFzc2V0KTtcbiAgICAgIEFycmF5LmlzQXJyYXkoYWxpYXNlc1RvVXNlKSA/IGFsaWFzZXNUb1VzZS5mb3JFYWNoKGtleUNoZWNrKSA6IGtleUNoZWNrKGFsaWFzZXNUb1VzZSk7XG4gICAgICBjb25zdCByZXNvbHZlZEFzc2V0cyA9IFtdO1xuICAgICAgc3Jjc1RvVXNlLmZvckVhY2goKHNyY3MpID0+IHtcbiAgICAgICAgc3Jjcy5mb3JFYWNoKChzcmMyKSA9PiB7XG4gICAgICAgICAgbGV0IGZvcm1hdHRlZEFzc2V0ID0ge307XG4gICAgICAgICAgaWYgKHR5cGVvZiBzcmMyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSBzcmMyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMuX3BhcnNlcnNbaV07XG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudGVzdChzcmMyKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0gcGFyc2VyLnBhcnNlKHNyYzIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBzcmMyLmRhdGEgPz8gZGF0YTtcbiAgICAgICAgICAgIGZvcm1hdCA9IHNyYzIuZm9ybWF0ID8/IGZvcm1hdDtcbiAgICAgICAgICAgIGxvYWRQYXJzZXIgPSBzcmMyLmxvYWRQYXJzZXIgPz8gbG9hZFBhcnNlcjtcbiAgICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0ge1xuICAgICAgICAgICAgICAuLi5mb3JtYXR0ZWRBc3NldCxcbiAgICAgICAgICAgICAgLi4uc3JjMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhbGlhc2VzVG9Vc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW1Jlc29sdmVyXSBhbGlhcyBpcyB1bmRlZmluZWQgZm9yIHRoaXMgYXNzZXQ6ICR7Zm9ybWF0dGVkQXNzZXQuc3JjfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3JtYXR0ZWRBc3NldCA9IHRoaXMuX2J1aWxkUmVzb2x2ZWRBc3NldChmb3JtYXR0ZWRBc3NldCwge1xuICAgICAgICAgICAgYWxpYXNlczogYWxpYXNlc1RvVXNlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgIGxvYWRQYXJzZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlZEFzc2V0cy5wdXNoKGZvcm1hdHRlZEFzc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGFsaWFzZXNUb1VzZS5mb3JFYWNoKChhbGlhcykgPT4ge1xuICAgICAgICB0aGlzLl9hc3NldE1hcFthbGlhc10gPSByZXNvbHZlZEFzc2V0cztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8vIFRPRE86IHRoaXMgbmVlZHMgYW4gb3ZlcmxvYWQgbGlrZSBsb2FkIGRpZCBpbiBBc3NldHNcbiAgLyoqXG4gICAqIElmIHRoZSByZXNvbHZlciBoYXMgaGFkIGEgbWFuaWZlc3Qgc2V0IHZpYSBzZXRNYW5pZmVzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYXNzZXRzIHVybHMgZm9yXG4gICAqIGEgZ2l2ZW4gYnVuZGxlSWQgb3IgYnVuZGxlSWRzLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBNYW5pZmVzdCBFeGFtcGxlXG4gICAqIGNvbnN0IG1hbmlmZXN0ID0ge1xuICAgKiAgICAgYnVuZGxlczogW1xuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgbmFtZTogJ2xvYWQtc2NyZWVuJyxcbiAgICogICAgICAgICAgICAgYXNzZXRzOiBbXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdiYWNrZ3JvdW5kJyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdzdW5zZXQucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdiYXInLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ2xvYWQtYmFyLntwbmcsd2VicH0nLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgbmFtZTogJ2dhbWUtc2NyZWVuJyxcbiAgICogICAgICAgICAgICAgYXNzZXRzOiBbXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdjaGFyYWN0ZXInLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ3JvYm90LnBuZycsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnZW5lbXknLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ2JhZC1ndXkucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgIF0sXG4gICAqICAgICAgICAgfSxcbiAgICogICAgIF1cbiAgICogfTtcbiAgICpcbiAgICogcmVzb2x2ZXIuc2V0TWFuaWZlc3QobWFuaWZlc3QpO1xuICAgKiBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVyLnJlc29sdmVCdW5kbGUoJ2xvYWQtc2NyZWVuJyk7XG4gICAqIEBwYXJhbSBidW5kbGVJZHMgLSBUaGUgYnVuZGxlIGlkcyB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIEFsbCB0aGUgYnVuZGxlcyBhc3NldHMgb3IgYSBoYXNoIG9mIGFzc2V0cyBmb3IgZWFjaCBidW5kbGUgc3BlY2lmaWVkXG4gICAqL1xuICByZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcykge1xuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtKGJ1bmRsZUlkcyk7XG4gICAgYnVuZGxlSWRzID0gY29udmVydFRvTGlzdChidW5kbGVJZHMpO1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGJ1bmRsZUlkcy5mb3JFYWNoKChidW5kbGVJZCkgPT4ge1xuICAgICAgY29uc3QgYXNzZXROYW1lcyA9IHRoaXMuX2J1bmRsZXNbYnVuZGxlSWRdO1xuICAgICAgaWYgKGFzc2V0TmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMucmVzb2x2ZShhc3NldE5hbWVzKTtcbiAgICAgICAgY29uc3QgYXNzZXRzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCBhc3NldCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgICBhc3NldHNbdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlKGJ1bmRsZUlkLCBrZXkpXSA9IGFzc2V0O1xuICAgICAgICB9XG4gICAgICAgIG91dFtidW5kbGVJZF0gPSBhc3NldHM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gb3V0W2J1bmRsZUlkc1swXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIERvZXMgZXhhY3RseSB3aGF0IHJlc29sdmUgZG9lcywgYnV0IHJldHVybnMganVzdCB0aGUgVVJMIHJhdGhlciB0aGFuIHRoZSB3aG9sZSBhc3NldCBvYmplY3RcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb3Iga2V5cyB0byByZXNvbHZlXG4gICAqIEByZXR1cm5zIC0gVGhlIFVSTHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkocylcbiAgICovXG4gIHJlc29sdmVVcmwoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXNvbHZlKGtleSk7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IG91dCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpIGluIHJlc3VsdCkge1xuICAgICAgICBvdXRbaV0gPSByZXN1bHRbaV0uc3JjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zcmM7XG4gIH1cbiAgcmVzb2x2ZShrZXlzKSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oa2V5cyk7XG4gICAga2V5cyA9IGNvbnZlcnRUb0xpc3Qoa2V5cyk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2Fzc2V0TWFwW2tleV0pIHtcbiAgICAgICAgICBsZXQgYXNzZXRzID0gdGhpcy5fYXNzZXRNYXBba2V5XTtcbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWRPcmRlciA9IHRoaXMuX2dldFByZWZlcnJlZE9yZGVyKGFzc2V0cyk7XG4gICAgICAgICAgcHJlZmVycmVkT3JkZXI/LnByaW9yaXR5LmZvckVhY2goKHByaW9yaXR5S2V5KSA9PiB7XG4gICAgICAgICAgICBwcmVmZXJyZWRPcmRlci5wYXJhbXNbcHJpb3JpdHlLZXldLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQXNzZXRzID0gYXNzZXRzLmZpbHRlcigoYXNzZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZXRbcHJpb3JpdHlLZXldKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRbcHJpb3JpdHlLZXldID09PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkQXNzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2V0cyA9IGZpbHRlcmVkQXNzZXRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlckhhc2hba2V5XSA9IGFzc2V0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlckhhc2hba2V5XSA9IHRoaXMuX2J1aWxkUmVzb2x2ZWRBc3NldCh7XG4gICAgICAgICAgICBhbGlhczogW2tleV0sXG4gICAgICAgICAgICBzcmM6IGtleVxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLl9yZXNvbHZlckhhc2hba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyByZXN1bHRba2V5c1swXV0gOiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbiBhc3NldCB3aXRoIGEgZ2l2ZW4ga2V5IGV4aXN0cyBpbiB0aGUgcmVzb2x2ZXJcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGFzc2V0XG4gICAqL1xuICBoYXNLZXkoa2V5KSB7XG4gICAgcmV0dXJuICEhdGhpcy5fYXNzZXRNYXBba2V5XTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYnVuZGxlIHdpdGggdGhlIGdpdmVuIGtleSBleGlzdHMgaW4gdGhlIHJlc29sdmVyXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBidW5kbGVcbiAgICovXG4gIGhhc0J1bmRsZShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9idW5kbGVzW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsIGZ1bmN0aW9uIGZvciBmaWd1cmluZyBvdXQgd2hhdCBwcmVmZXIgY3JpdGVyaWEgYW4gYXNzZXQgc2hvdWxkIHVzZS5cbiAgICogQHBhcmFtIGFzc2V0c1xuICAgKi9cbiAgX2dldFByZWZlcnJlZE9yZGVyKGFzc2V0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhc3NldCA9IGFzc2V0c1swXTtcbiAgICAgIGNvbnN0IHByZWZlcnJlZCA9IHRoaXMuX3ByZWZlcnJlZE9yZGVyLmZpbmQoKHByZWZlcmVuY2UpID0+IHByZWZlcmVuY2UucGFyYW1zLmZvcm1hdC5pbmNsdWRlcyhhc3NldC5mb3JtYXQpKTtcbiAgICAgIGlmIChwcmVmZXJyZWQpIHtcbiAgICAgICAgcmV0dXJuIHByZWZlcnJlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByZWZlcnJlZE9yZGVyWzBdO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBkZWZhdWx0IHVybCBwYXJhbWV0ZXJzIHRvIHRoZSB1cmxcbiAgICogQHBhcmFtIHVybCAtIFRoZSB1cmwgdG8gYXBwZW5kIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgdG9cbiAgICogQHJldHVybnMgLSBUaGUgdXJsIHdpdGggdGhlIGRlZmF1bHQgcGFyYW1ldGVycyBhcHBlbmRlZFxuICAgKi9cbiAgX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXModXJsKSB7XG4gICAgaWYgKCF0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zKVxuICAgICAgcmV0dXJuIHVybDtcbiAgICBjb25zdCBwYXJhbUNvbm5lY3RvciA9IC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgcmV0dXJuIGAke3VybH0ke3BhcmFtQ29ubmVjdG9yfSR7dGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtc31gO1xuICB9XG4gIF9idWlsZFJlc29sdmVkQXNzZXQoZm9ybWF0dGVkQXNzZXQsIGRhdGEpIHtcbiAgICBjb25zdCB7IGFsaWFzZXMsIGRhdGE6IGFzc2V0RGF0YSwgbG9hZFBhcnNlciwgZm9ybWF0IH0gPSBkYXRhO1xuICAgIGlmICh0aGlzLl9iYXNlUGF0aCB8fCB0aGlzLl9yb290UGF0aCkge1xuICAgICAgZm9ybWF0dGVkQXNzZXQuc3JjID0gcGF0aC50b0Fic29sdXRlKGZvcm1hdHRlZEFzc2V0LnNyYywgdGhpcy5fYmFzZVBhdGgsIHRoaXMuX3Jvb3RQYXRoKTtcbiAgICB9XG4gICAgZm9ybWF0dGVkQXNzZXQuYWxpYXMgPSBhbGlhc2VzID8/IGZvcm1hdHRlZEFzc2V0LmFsaWFzID8/IFtmb3JtYXR0ZWRBc3NldC5zcmNdO1xuICAgIGZvcm1hdHRlZEFzc2V0LnNyYyA9IHRoaXMuX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXMoZm9ybWF0dGVkQXNzZXQuc3JjKTtcbiAgICBmb3JtYXR0ZWRBc3NldC5kYXRhID0geyAuLi5hc3NldERhdGEgfHwge30sIC4uLmZvcm1hdHRlZEFzc2V0LmRhdGEgfTtcbiAgICBmb3JtYXR0ZWRBc3NldC5sb2FkUGFyc2VyID0gbG9hZFBhcnNlciA/PyBmb3JtYXR0ZWRBc3NldC5sb2FkUGFyc2VyO1xuICAgIGZvcm1hdHRlZEFzc2V0LmZvcm1hdCA9IGZvcm1hdCA/PyBmb3JtYXR0ZWRBc3NldC5mb3JtYXQgPz8gZ2V0VXJsRXh0ZW5zaW9uKGZvcm1hdHRlZEFzc2V0LnNyYyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlZEFzc2V0O1xuICB9XG59XG4vKipcbiAqIFRoZSBwcmVmaXggdGhhdCBkZW5vdGVzIGEgVVJMIGlzIGZvciBhIHJldGluYSBhc3NldC5cbiAqIEBzdGF0aWNcbiAqIEBuYW1lIFJFVElOQV9QUkVGSVhcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAZGVmYXVsdCAvQChbMC05XFwuXSspeC9cbiAqIEBleGFtcGxlIGBAMnhgXG4gKi9cblJlc29sdmVyLlJFVElOQV9QUkVGSVggPSAvQChbMC05XFwuXSspeC87XG5mdW5jdGlvbiBnZXRVcmxFeHRlbnNpb24odXJsKSB7XG4gIHJldHVybiB1cmwuc3BsaXQoXCIuXCIpLnBvcCgpLnNwbGl0KFwiP1wiKS5zaGlmdCgpLnNwbGl0KFwiI1wiKS5zaGlmdCgpO1xufVxuXG5leHBvcnQgeyBSZXNvbHZlciwgZ2V0VXJsRXh0ZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvbHZlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///651\n")},9879:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ convertToList)\n/* harmony export */ });\n\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === "string" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\n\n//# sourceMappingURL=convertToList.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg3OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvdXRpbHMvY29udmVydFRvTGlzdC5tanM/ZGNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvbnZlcnRUb0xpc3QgPSAoaW5wdXQsIHRyYW5zZm9ybSwgZm9yY2VUcmFuc2Zvcm0gPSBmYWxzZSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG4gIGlmICghdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgfHwgZm9yY2VUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGNvbnZlcnRUb0xpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnRUb0xpc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9879\n')},8479:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ copySearchParams)\n/* harmony export */ });\n\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\n\n//# sourceMappingURL=copySearchParams.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ3OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvdXRpbHMvY29weVNlYXJjaFBhcmFtcy5tanM/YmM2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvcHlTZWFyY2hQYXJhbXMgPSAodGFyZ2V0VXJsLCBzb3VyY2VVcmwpID0+IHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gc291cmNlVXJsLnNwbGl0KFwiP1wiKVsxXTtcbiAgaWYgKHNlYXJjaFBhcmFtcykge1xuICAgIHRhcmdldFVybCArPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFVybDtcbn07XG5cbmV4cG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHlTZWFyY2hQYXJhbXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8479\n')},1675:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ isSingleItem)\n/* harmony export */ });\n\nconst isSingleItem = (item) => !Array.isArray(item);\n\n\n//# sourceMappingURL=isSingleItem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY3NS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy91dGlscy9pc1NpbmdsZUl0ZW0ubWpzPzU2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc1NpbmdsZUl0ZW0gPSAoaXRlbSkgPT4gIUFycmF5LmlzQXJyYXkoaXRlbSk7XG5cbmV4cG9ydCB7IGlzU2luZ2xlSXRlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTaW5nbGVJdGVtLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1675\n")},8409:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* binding */ Color)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/color/Color.mjs\n\n\n\n"use strict";\nk([names]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter\'s parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter\'s parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error("Cannot set Color#value to null");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._normalize(value);\n      this._value = this._cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === "object" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHex(); // returns "#ffffff"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHexa(); // returns "#ffffffff"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === "string" || typeof value === "object") {\n      if (typeof value === "string") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = w(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === "number") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from \'pixi.js\';\n   * Color.isColorLike(\'white\'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from \'pixi.js\';\n * Color.shared.setValue(0xffffff).toHex(); // \'#ffffff\'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\n\n//# sourceMappingURL=Color.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsRUFBRSxJQUFJLFVBQVUsRUFBRTtBQUM3RDs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvcmQvaW5kZXgubWpzP2M2NDYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3JkL3BsdWdpbnMvbmFtZXMubWpzPzgwNzciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29sb3IvQ29sb3IubWpzP2EyOWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHI9e2dyYWQ6LjksdHVybjozNjAscmFkOjM2MC8oMipNYXRoLlBJKX0sdD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9yLmxlbmd0aD4wOlwibnVtYmVyXCI9PXR5cGVvZiByfSxuPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49TWF0aC5wb3coMTAsdCkpLE1hdGgucm91bmQobipyKS9uKzB9LGU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyPm4/bjpyPnQ/cjp0fSx1PWZ1bmN0aW9uKHIpe3JldHVybihyPWlzRmluaXRlKHIpP3IlMzYwOjApPjA/cjpyKzM2MH0sYT1mdW5jdGlvbihyKXtyZXR1cm57cjplKHIuciwwLDI1NSksZzplKHIuZywwLDI1NSksYjplKHIuYiwwLDI1NSksYTplKHIuYSl9fSxvPWZ1bmN0aW9uKHIpe3JldHVybntyOm4oci5yKSxnOm4oci5nKSxiOm4oci5iKSxhOm4oci5hLDMpfX0saT0vXiMoWzAtOWEtZl17Myw4fSkkL2kscz1mdW5jdGlvbihyKXt2YXIgdD1yLnRvU3RyaW5nKDE2KTtyZXR1cm4gdC5sZW5ndGg8Mj9cIjBcIit0OnR9LGg9ZnVuY3Rpb24ocil7dmFyIHQ9ci5yLG49ci5nLGU9ci5iLHU9ci5hLGE9TWF0aC5tYXgodCxuLGUpLG89YS1NYXRoLm1pbih0LG4sZSksaT1vP2E9PT10PyhuLWUpL286YT09PW4/MisoZS10KS9vOjQrKHQtbikvbzowO3JldHVybntoOjYwKihpPDA/aSs2OmkpLHM6YT9vL2EqMTAwOjAsdjphLzI1NSoxMDAsYTp1fX0sYj1mdW5jdGlvbihyKXt2YXIgdD1yLmgsbj1yLnMsZT1yLnYsdT1yLmE7dD10LzM2MCo2LG4vPTEwMCxlLz0xMDA7dmFyIGE9TWF0aC5mbG9vcih0KSxvPWUqKDEtbiksaT1lKigxLSh0LWEpKm4pLHM9ZSooMS0oMS10K2EpKm4pLGg9YSU2O3JldHVybntyOjI1NSpbZSxpLG8sbyxzLGVdW2hdLGc6MjU1KltzLGUsZSxpLG8sb11baF0sYjoyNTUqW28sbyxzLGUsZSxpXVtoXSxhOnV9fSxnPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSxsOmUoci5sLDAsMTAwKSxhOmUoci5hKX19LGQ9ZnVuY3Rpb24ocil7cmV0dXJue2g6bihyLmgpLHM6bihyLnMpLGw6bihyLmwpLGE6bihyLmEsMyl9fSxmPWZ1bmN0aW9uKHIpe3JldHVybiBiKChuPSh0PXIpLnMse2g6dC5oLHM6KG4qPSgoZT10LmwpPDUwP2U6MTAwLWUpLzEwMCk+MD8yKm4vKGUrbikqMTAwOjAsdjplK24sYTp0LmF9KSk7dmFyIHQsbixlfSxjPWZ1bmN0aW9uKHIpe3JldHVybntoOih0PWgocikpLmgsczoodT0oMjAwLShuPXQucykpKihlPXQudikvMTAwKT4wJiZ1PDIwMD9uKmUvMTAwLyh1PD0xMDA/dToyMDAtdSkqMTAwOjAsbDp1LzIsYTp0LmF9O3ZhciB0LG4sZSx1fSxsPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHA9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHY9L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxtPS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHk9e3N0cmluZzpbW2Z1bmN0aW9uKHIpe3ZhciB0PWkuZXhlYyhyKTtyZXR1cm4gdD8ocj10WzFdKS5sZW5ndGg8PTQ/e3I6cGFyc2VJbnQoclswXStyWzBdLDE2KSxnOnBhcnNlSW50KHJbMV0rclsxXSwxNiksYjpwYXJzZUludChyWzJdK3JbMl0sMTYpLGE6ND09PXIubGVuZ3RoP24ocGFyc2VJbnQoclszXStyWzNdLDE2KS8yNTUsMik6MX06Nj09PXIubGVuZ3RofHw4PT09ci5sZW5ndGg/e3I6cGFyc2VJbnQoci5zdWJzdHIoMCwyKSwxNiksZzpwYXJzZUludChyLnN1YnN0cigyLDIpLDE2KSxiOnBhcnNlSW50KHIuc3Vic3RyKDQsMiksMTYpLGE6OD09PXIubGVuZ3RoP24ocGFyc2VJbnQoci5zdWJzdHIoNiwyKSwxNikvMjU1LDIpOjF9Om51bGw6bnVsbH0sXCJoZXhcIl0sW2Z1bmN0aW9uKHIpe3ZhciB0PXYuZXhlYyhyKXx8bS5leGVjKHIpO3JldHVybiB0P3RbMl0hPT10WzRdfHx0WzRdIT09dFs2XT9udWxsOmEoe3I6TnVtYmVyKHRbMV0pLyh0WzJdPzEwMC8yNTU6MSksZzpOdW1iZXIodFszXSkvKHRbNF0/MTAwLzI1NToxKSxiOk51bWJlcih0WzVdKS8odFs2XT8xMDAvMjU1OjEpLGE6dm9pZCAwPT09dFs3XT8xOk51bWJlcih0WzddKS8odFs4XT8xMDA6MSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24odCl7dmFyIG49bC5leGVjKHQpfHxwLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGUsdSxhPWcoe2g6KGU9blsxXSx1PW5bMl0sdm9pZCAwPT09dSYmKHU9XCJkZWdcIiksTnVtYmVyKGUpKihyW3VdfHwxKSksczpOdW1iZXIoblszXSksbDpOdW1iZXIobls0XSksYTp2b2lkIDA9PT1uWzVdPzE6TnVtYmVyKG5bNV0pLyhuWzZdPzEwMDoxKX0pO3JldHVybiBmKGEpfSxcImhzbFwiXV0sb2JqZWN0OltbZnVuY3Rpb24ocil7dmFyIG49ci5yLGU9ci5nLHU9ci5iLG89ci5hLGk9dm9pZCAwPT09bz8xOm87cmV0dXJuIHQobikmJnQoZSkmJnQodSk/YSh7cjpOdW1iZXIobiksZzpOdW1iZXIoZSksYjpOdW1iZXIodSksYTpOdW1iZXIoaSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGU9ci5zLHU9ci5sLGE9ci5hLG89dm9pZCAwPT09YT8xOmE7aWYoIXQobil8fCF0KGUpfHwhdCh1KSlyZXR1cm4gbnVsbDt2YXIgaT1nKHtoOk51bWJlcihuKSxzOk51bWJlcihlKSxsOk51bWJlcih1KSxhOk51bWJlcihvKX0pO3JldHVybiBmKGkpfSxcImhzbFwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGE9ci5zLG89ci52LGk9ci5hLHM9dm9pZCAwPT09aT8xOmk7aWYoIXQobil8fCF0KGEpfHwhdChvKSlyZXR1cm4gbnVsbDt2YXIgaD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksdjplKHIudiwwLDEwMCksYTplKHIuYSl9fSh7aDpOdW1iZXIobiksczpOdW1iZXIoYSksdjpOdW1iZXIobyksYTpOdW1iZXIocyl9KTtyZXR1cm4gYihoKX0sXCJoc3ZcIl1dfSxOPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBlPXRbbl1bMF0ocik7aWYoZSlyZXR1cm5bZSx0W25dWzFdXX1yZXR1cm5bbnVsbCx2b2lkIDBdfSx4PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP04oci50cmltKCkseS5zdHJpbmcpOlwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9OKHIseS5vYmplY3QpOltudWxsLHZvaWQgMF19LEk9ZnVuY3Rpb24ocil7cmV0dXJuIHgocilbMV19LE09ZnVuY3Rpb24ocix0KXt2YXIgbj1jKHIpO3JldHVybntoOm4uaCxzOmUobi5zKzEwMCp0LDAsMTAwKSxsOm4ubCxhOm4uYX19LEg9ZnVuY3Rpb24ocil7cmV0dXJuKDI5OSpyLnIrNTg3KnIuZysxMTQqci5iKS8xZTMvMjU1fSwkPWZ1bmN0aW9uKHIsdCl7dmFyIG49YyhyKTtyZXR1cm57aDpuLmgsczpuLnMsbDplKG4ubCsxMDAqdCwwLDEwMCksYTpuLmF9fSxqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLnBhcnNlZD14KHIpWzBdLHRoaXMucmdiYT10aGlzLnBhcnNlZHx8e3I6MCxnOjAsYjowLGE6MX19cmV0dXJuIHIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucGFyc2VkfSxyLnByb3RvdHlwZS5icmlnaHRuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4oSCh0aGlzLnJnYmEpLDIpfSxyLnByb3RvdHlwZS5pc0Rhcms9ZnVuY3Rpb24oKXtyZXR1cm4gSCh0aGlzLnJnYmEpPC41fSxyLnByb3RvdHlwZS5pc0xpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEgodGhpcy5yZ2JhKT49LjV9LHIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHI9byh0aGlzLnJnYmEpLHQ9ci5yLGU9ci5nLHU9ci5iLGk9KGE9ci5hKTwxP3MobigyNTUqYSkpOlwiXCIsXCIjXCIrcyh0KStzKGUpK3ModSkraTt2YXIgcix0LGUsdSxhLGl9LHIucHJvdG90eXBlLnRvUmdiPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcy5yZ2JhKX0sci5wcm90b3R5cGUudG9SZ2JTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1vKHRoaXMucmdiYSksdD1yLnIsbj1yLmcsZT1yLmIsKHU9ci5hKTwxP1wicmdiYShcIit0K1wiLCBcIituK1wiLCBcIitlK1wiLCBcIit1K1wiKVwiOlwicmdiKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic2w9ZnVuY3Rpb24oKXtyZXR1cm4gZChjKHRoaXMucmdiYSkpfSxyLnByb3RvdHlwZS50b0hzbFN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPWQoYyh0aGlzLnJnYmEpKSx0PXIuaCxuPXIucyxlPXIubCwodT1yLmEpPDE/XCJoc2xhKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSwgXCIrdStcIilcIjpcImhzbChcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic3Y9ZnVuY3Rpb24oKXtyZXR1cm4gcj1oKHRoaXMucmdiYSkse2g6bihyLmgpLHM6bihyLnMpLHY6bihyLnYpLGE6bihyLmEsMyl9O3ZhciByfSxyLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdyh7cjoyNTUtKHI9dGhpcy5yZ2JhKS5yLGc6MjU1LXIuZyxiOjI1NS1yLmIsYTpyLmF9KTt2YXIgcn0sci5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KE0odGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoTSh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUuZ3JheXNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHcoTSh0aGlzLnJnYmEsLTEpKX0sci5wcm90b3R5cGUubGlnaHRlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoJCh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kYXJrZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KCQodGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MTUpLHRoaXMuaHVlKHRoaXMuaHVlKCkrcil9LHIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP3coe3I6KHQ9dGhpcy5yZ2JhKS5yLGc6dC5nLGI6dC5iLGE6cn0pOm4odGhpcy5yZ2JhLmEsMyk7dmFyIHR9LHIucHJvdG90eXBlLmh1ZT1mdW5jdGlvbihyKXt2YXIgdD1jKHRoaXMucmdiYSk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/dyh7aDpyLHM6dC5zLGw6dC5sLGE6dC5hfSk6bih0LmgpfSxyLnByb3RvdHlwZS5pc0VxdWFsPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvSGV4KCk9PT13KHIpLnRvSGV4KCl9LHJ9KCksdz1mdW5jdGlvbihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIGo/cjpuZXcgaihyKX0sUz1bXSxrPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaChmdW5jdGlvbihyKXtTLmluZGV4T2Yocik8MCYmKHIoaix5KSxTLnB1c2gocikpfSl9LEU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGooe3I6MjU1Kk1hdGgucmFuZG9tKCksZzoyNTUqTWF0aC5yYW5kb20oKSxiOjI1NSpNYXRoLnJhbmRvbSgpfSl9O2V4cG9ydHtqIGFzIENvbG9yZCx3IGFzIGNvbG9yZCxrIGFzIGV4dGVuZCxJIGFzIGdldEZvcm1hdCxFIGFzIHJhbmRvbX07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlLGYpe3ZhciBhPXt3aGl0ZTpcIiNmZmZmZmZcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmx1ZTpcIiMwMDAwZmZcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXp1cmU6XCIjZjBmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBsdW06XCIjZGRhMGRkXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmxhY2s6XCIjMDAwMDAwXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLGNvcm5zaWxrOlwiI2ZmZjhkY1wiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVlZFwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGNyaW1zb246XCIjZGMxNDNjXCIsY3lhbjpcIiMwMGZmZmZcIixkYXJrYmx1ZTpcIiMwMDAwOGJcIixkYXJrY3lhbjpcIiMwMDhiOGJcIixkYXJrZ29sZGVucm9kOlwiI2I4ODYwYlwiLGRhcmtraGFraTpcIiNiZGI3NmJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrb3JhbmdlOlwiI2ZmOGMwMFwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZ3JheTpcIiM4MDgwODBcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsd2hlYXQ6XCIjZjVkZWIzXCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGdyZWVuOlwiIzAwODAwMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsbGF3bmdyZWVuOlwiIzdjZmMwMFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixicm93bjpcIiNhNTJhMmFcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGl2b3J5OlwiI2ZmZmZmMFwiLGxpZ2h0eWVsbG93OlwiI2ZmZmZlMFwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBiMmFhXCIsbGluZW46XCIjZmFmMGU2XCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGltZTpcIiMwMGZmMDBcIixraGFraTpcIiNmMGU2OGNcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbGlnaHRza3libHVlOlwiIzg3Y2VmYVwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixtb2NjYXNpbjpcIiNmZmU0YjVcIixtaW50Y3JlYW06XCIjZjVmZmZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLG9sZGxhY2U6XCIjZmRmNWU2XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLHJlYmVjY2FwdXJwbGU6XCIjNjYzMzk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdGFuOlwiI2QyYjQ4Y1wiLG9yY2hpZDpcIiNkYTcwZDZcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIscHVycGxlOlwiIzgwMDA4MFwiLHBpbms6XCIjZmZjMGNiXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscmVkOlwiI2ZmMDAwMFwiLHllbGxvdzpcIiNmZmZmMDBcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixwZXJ1OlwiI2NkODUzZlwiLHBhbGV2aW9sZXRyZWQ6XCIjZGI3MDkzXCIsdmlvbGV0OlwiI2VlODJlZVwiLHRlYWw6XCIjMDA4MDgwXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLHNlYXNoZWxsOlwiI2ZmZjVlZVwiLHRvbWF0bzpcIiNmZjYzNDdcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2llbm5hOlwiI2EwNTIyZFwiLGxhdmVuZGVyOlwiI2U2ZTZmYVwiLGxpZ2h0Z3JlZW46XCIjOTBlZTkwXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscm95YWxibHVlOlwiIzQxNjllMVwiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix5ZWxsb3dncmVlbjpcIiM5YWNkMzJcIixzYWxtb246XCIjZmE4MDcyXCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixzbm93OlwiI2ZmZmFmYVwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvbGl2ZTpcIiM4MDgwMDBcIn0scj17fTtmb3IodmFyIGQgaW4gYSlyW2FbZF1dPWQ7dmFyIGw9e307ZS5wcm90b3R5cGUudG9OYW1lPWZ1bmN0aW9uKGYpe2lmKCEodGhpcy5yZ2JhLmF8fHRoaXMucmdiYS5yfHx0aGlzLnJnYmEuZ3x8dGhpcy5yZ2JhLmIpKXJldHVyblwidHJhbnNwYXJlbnRcIjt2YXIgZCxpLG49clt0aGlzLnRvSGV4KCldO2lmKG4pcmV0dXJuIG47aWYobnVsbD09Zj92b2lkIDA6Zi5jbG9zZXN0KXt2YXIgbz10aGlzLnRvUmdiKCksdD0xLzAsYj1cImJsYWNrXCI7aWYoIWwubGVuZ3RoKWZvcih2YXIgYyBpbiBhKWxbY109bmV3IGUoYVtjXSkudG9SZ2IoKTtmb3IodmFyIGcgaW4gYSl7dmFyIHU9KGQ9byxpPWxbZ10sTWF0aC5wb3coZC5yLWkuciwyKStNYXRoLnBvdyhkLmctaS5nLDIpK01hdGgucG93KGQuYi1pLmIsMikpO3U8dCYmKHQ9dSxiPWcpfXJldHVybiBifX07Zi5zdHJpbmcucHVzaChbZnVuY3Rpb24oZil7dmFyIHI9Zi50b0xvd2VyQ2FzZSgpLGQ9XCJ0cmFuc3BhcmVudFwiPT09cj9cIiMwMDAwXCI6YVtyXTtyZXR1cm4gZD9uZXcgZShkKS50b1JnYigpOm51bGx9LFwibmFtZVwiXSl9XG4iLCJpbXBvcnQgeyBleHRlbmQsIGNvbG9yZCB9IGZyb20gJ0BwaXhpL2NvbG9yZCc7XG5pbXBvcnQgbmFtZXNQbHVnaW4gZnJvbSAnQHBpeGkvY29sb3JkL3BsdWdpbnMvbmFtZXMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuZChbbmFtZXNQbHVnaW5dKTtcbmNvbnN0IF9Db2xvciA9IGNsYXNzIF9Db2xvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbG9yU291cmNlfSB2YWx1ZSAtIE9wdGlvbmFsIHZhbHVlIHRvIHVzZSwgaWYgbm90IHByb3ZpZGVkLCB3aGl0ZSBpcyB1c2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUgPSAxNjc3NzIxNSkge1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9jb21wb25lbnRzID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB0aGlzLl9jb21wb25lbnRzLmZpbGwoMSk7XG4gICAgdGhpcy5faW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBHZXQgcmVkIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCByZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF07XG4gIH1cbiAgLyoqIEdldCBncmVlbiBjb21wb25lbnQgKDAgLSAxKSAqL1xuICBnZXQgZ3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMV07XG4gIH1cbiAgLyoqIEdldCBibHVlIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCBibHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzJdO1xuICB9XG4gIC8qKiBHZXQgYWxwaGEgY29tcG9uZW50ICgwIC0gMSkgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzNdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmdcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBzZWUgQ29sb3IudmFsdWVcbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBjb2xvciBzb3VyY2UuXG4gICAqXG4gICAqIFdoZW4gc2V0dGluZzpcbiAgICogLSBTZXR0aW5nIHRvIGFuIGluc3RhbmNlIG9mIGBDb2xvcmAgd2lsbCBjb3B5IGl0cyBjb2xvciBzb3VyY2UgYW5kIGNvbXBvbmVudHMuXG4gICAqIC0gT3RoZXJ3aXNlLCBgQ29sb3JgIHdpbGwgdHJ5IHRvIG5vcm1hbGl6ZSB0aGUgY29sb3Igc291cmNlIGFuZCBzZXQgdGhlIGNvbXBvbmVudHMuXG4gICAqICAgSWYgdGhlIGNvbG9yIHNvdXJjZSBpcyBpbnZhbGlkLCBhbiBgRXJyb3JgIHdpbGwgYmUgdGhyb3duIGFuZCB0aGUgYENvbG9yYCB3aWxsIGxlZnQgdW5jaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG51bGxgIGluIHRoZSBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZSBpcyBhZGRlZCB0byBtYXRjaCB0aGUgVHlwZVNjcmlwdCBydWxlOiByZXR1cm4gdHlwZSBvZiBnZXR0ZXJcbiAgICogbXVzdCBiZSBhc3NpZ25hYmxlIHRvIGl0cyBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZS4gU2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYCB3aWxsIHRocm93IGFuIGBFcnJvcmAuXG4gICAqXG4gICAqIFdoZW4gZ2V0dGluZzpcbiAgICogLSBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBvdmVycmlkZGVuIChlLmcuLCB7QGxpbmsgQ29sb3IubXVsdGlwbHkgbXVsdGlwbHl9LFxuICAgKiAgIHtAbGluayBDb2xvci5wcmVtdWx0aXBseSBwcmVtdWx0aXBseX0gb3Ige0BsaW5rIENvbG9yLnJvdW5kIHJvdW5kfSkuXG4gICAqIC0gT3RoZXJ3aXNlLCB0aGUgY29sb3Igc291cmNlIHVzZWQgd2hlbiBzZXR0aW5nIGlzIHJldHVybmVkLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX0NvbG9yKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2Nsb25lU291cmNlKHZhbHVlLl92YWx1ZSk7XG4gICAgICB0aGlzLl9pbnQgPSB2YWx1ZS5faW50O1xuICAgICAgdGhpcy5fY29tcG9uZW50cy5zZXQodmFsdWUuX2NvbXBvbmVudHMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgQ29sb3IjdmFsdWUgdG8gbnVsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3ZhbHVlID09PSBudWxsIHx8ICF0aGlzLl9pc1NvdXJjZUVxdWFsKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX25vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2Nsb25lU291cmNlKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29weSBhIGNvbG9yIHNvdXJjZSBpbnRlcm5hbGx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBDb2xvciBzb3VyY2VcbiAgICovXG4gIF9jbG9uZVNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IC4uLnZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2sgZm9yIGNvbG9yIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB2YWx1ZTEgLSBGaXJzdCBjb2xvciBzb3VyY2VcbiAgICogQHBhcmFtIHZhbHVlMiAtIFNlY29uZCBjb2xvciBzb3VyY2VcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb2xvciBzb3VyY2VzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBfaXNTb3VyY2VFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGNvbnN0IHR5cGUxID0gdHlwZW9mIHZhbHVlMTtcbiAgICBjb25zdCB0eXBlMiA9IHR5cGVvZiB2YWx1ZTI7XG4gICAgaWYgKHR5cGUxICE9PSB0eXBlMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZTEgPT09IFwibnVtYmVyXCIgfHwgdHlwZTEgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUxIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTEpICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCAhPT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSB2YWx1ZTJbaV0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyh2YWx1ZTEpO1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZTIpO1xuICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzMS5ldmVyeSgoa2V5KSA9PiB2YWx1ZTFba2V5XSA9PT0gdmFsdWUyW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBSR0JBIGNvbG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvUmdiKCk7IC8vIHJldHVybnMgeyByOiAxLCBnOiAxLCBiOiAxLCBhOiAxIH1cbiAgICovXG4gIHRvUmdiYSgpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIFJHQiBjb2xvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b1JnYigpOyAvLyByZXR1cm5zIHsgcjogMSwgZzogMSwgYjogMSB9XG4gICAqL1xuICB0b1JnYigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgfVxuICAvKiogQ29udmVydCB0byBhIENTUy1zdHlsZSByZ2JhIHN0cmluZzogYHJnYmEoMjU1LDI1NSwyNTUsMS4wKWAuICovXG4gIHRvUmdiYVN0cmluZygpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCR7Z30sJHtifSwke3RoaXMuYWxwaGF9KWA7XG4gIH1cbiAgdG9VaW50OFJnYkFycmF5KG91dCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgaWYgKCF0aGlzLl9hcnJheVJnYikge1xuICAgICAgdGhpcy5fYXJyYXlSZ2IgPSBbXTtcbiAgICB9XG4gICAgb3V0ID0gb3V0IHx8IHRoaXMuX2FycmF5UmdiO1xuICAgIG91dFswXSA9IE1hdGgucm91bmQociAqIDI1NSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGIgKiAyNTUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9BcnJheShvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2FycmF5UmdiYSkge1xuICAgICAgdGhpcy5fYXJyYXlSZ2JhID0gW107XG4gICAgfVxuICAgIG91dCA9IG91dCB8fCB0aGlzLl9hcnJheVJnYmE7XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICBvdXRbM10gPSBhO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9SZ2JBcnJheShvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2FycmF5UmdiKSB7XG4gICAgICB0aGlzLl9hcnJheVJnYiA9IFtdO1xuICAgIH1cbiAgICBvdXQgPSBvdXQgfHwgdGhpcy5fYXJyYXlSZ2I7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9OdW1iZXIoKTsgLy8gcmV0dXJucyAxNjc3NzIxNVxuICAgKi9cbiAgdG9OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIEJHUiBudW1iZXJcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKDB4ZmZjYzk5KS50b0Jnck51bWJlcigpOyAvLyByZXR1cm5zIDB4OTljY2ZmXG4gICAqL1xuICB0b0Jnck51bWJlcigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiAoYiA8PCAxNikgKyAoZyA8PCA4KSArIHI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIgaW4gbGl0dGxlIGVuZGlhbiBmb3JtYXQgKGUuZy4sIEJCR0dSUikuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcigweGZmY2M5OSkudG9MaXR0bGVFbmRpYW5OdW1iZXIoKTsgLy8gcmV0dXJucyAweDk5Y2NmZlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjb2xvciBhcyBhIG51bWJlciBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cbiAgICovXG4gIHRvTGl0dGxlRW5kaWFuTnVtYmVyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5faW50O1xuICAgIHJldHVybiAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgNjUyODApICsgKCh2YWx1ZSAmIDI1NSkgPDwgMTYpO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSB3aXRoIGFub3RoZXIgY29sb3IuIFRoaXMgYWN0aW9uIGlzIGRlc3RydWN0aXZlLCBhbmQgd2lsbFxuICAgKiBvdmVycmlkZSB0aGUgcHJldmlvdXMgYHZhbHVlYCBwcm9wZXJ0eSB0byBiZSBgbnVsbGAuXG4gICAqIEBwYXJhbSB7Q29sb3JTb3VyY2V9IHZhbHVlIC0gVGhlIGNvbG9yIHRvIG11bHRpcGx5IGJ5LlxuICAgKi9cbiAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBfQ29sb3IuX3RlbXAuc2V0VmFsdWUodmFsdWUpLl9jb21wb25lbnRzO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMF0gKj0gcjtcbiAgICB0aGlzLl9jb21wb25lbnRzWzFdICo9IGc7XG4gICAgdGhpcy5fY29tcG9uZW50c1syXSAqPSBiO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gKj0gYTtcbiAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBjb2xvciB0byBhIHByZW11bHRpcGxpZWQgYWxwaGEgZm9ybWF0LiBUaGlzIGFjdGlvbiBpcyBkZXN0cnVjdGl2ZSwgYW5kIHdpbGxcbiAgICogb3ZlcnJpZGUgdGhlIHByZXZpb3VzIGB2YWx1ZWAgcHJvcGVydHkgdG8gYmUgYG51bGxgLlxuICAgKiBAcGFyYW0gYWxwaGEgLSBUaGUgYWxwaGEgdG8gbXVsdGlwbHkgYnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGx5VG9SR0I9dHJ1ZV0gLSBXaGV0aGVyIHRvIHByZW11bHRpcGx5IFJHQiBjaGFubmVscy5cbiAgICogQHJldHVybnMge0NvbG9yfSAtIEl0c2VsZi5cbiAgICovXG4gIHByZW11bHRpcGx5KGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhcHBseVRvUkdCKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdICo9IGFscGhhO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBhbHBoYTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gKj0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gPSBhbHBoYTtcbiAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQcmVtdWx0aXBsaWVzIGFscGhhIHdpdGggY3VycmVudCBjb2xvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gVGhlIGFscGhhIHRvIG11bHRpcGx5IGJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcHBseVRvUkdCPXRydWVdIC0gV2hldGhlciB0byBwcmVtdWx0aXBseSBSR0IgY2hhbm5lbHMuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbnQgbXVsdGlwbGllZCBieSBhbHBoYVxuICAgKi9cbiAgdG9QcmVtdWx0aXBsaWVkKGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmV0dXJuICgyNTUgPDwgMjQpICsgdGhpcy5faW50O1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgIHJldHVybiBhcHBseVRvUkdCID8gMCA6IHRoaXMuX2ludDtcbiAgICB9XG4gICAgbGV0IHIgPSB0aGlzLl9pbnQgPj4gMTYgJiAyNTU7XG4gICAgbGV0IGcgPSB0aGlzLl9pbnQgPj4gOCAmIDI1NTtcbiAgICBsZXQgYiA9IHRoaXMuX2ludCAmIDI1NTtcbiAgICBpZiAoYXBwbHlUb1JHQikge1xuICAgICAgciA9IHIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgICBnID0gZyAqIGFscGhhICsgMC41IHwgMDtcbiAgICAgIGIgPSBiICogYWxwaGEgKyAwLjUgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGlkZWNpbWFsIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvSGV4KCk7IC8vIHJldHVybnMgXCIjZmZmZmZmXCJcbiAgICovXG4gIHRvSGV4KCkge1xuICAgIGNvbnN0IGhleFN0cmluZyA9IHRoaXMuX2ludC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGAjJHtcIjAwMDAwMFwiLnN1YnN0cmluZygwLCA2IC0gaGV4U3RyaW5nLmxlbmd0aCkgKyBoZXhTdHJpbmd9YDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGlkZWNpbWFsIHN0cmluZyB3aXRoIGFscGhhLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9IZXhhKCk7IC8vIHJldHVybnMgXCIjZmZmZmZmZmZcIlxuICAgKi9cbiAgdG9IZXhhKCkge1xuICAgIGNvbnN0IGFscGhhVmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMuX2NvbXBvbmVudHNbM10gKiAyNTUpO1xuICAgIGNvbnN0IGFscGhhU3RyaW5nID0gYWxwaGFWYWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIFwiMDBcIi5zdWJzdHJpbmcoMCwgMiAtIGFscGhhU3RyaW5nLmxlbmd0aCkgKyBhbHBoYVN0cmluZztcbiAgfVxuICAvKipcbiAgICogU2V0IGFscGhhLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBwYXJhbSBhbHBoYVxuICAgKi9cbiAgc2V0QWxwaGEoYWxwaGEpIHtcbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gdGhpcy5fY2xhbXAoYWxwaGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHZhbHVlIGludG8gcmdiYVxuICAgKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZVxuICAgKi9cbiAgX25vcm1hbGl6ZSh2YWx1ZSkge1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuICAgIGxldCBhO1xuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE2Nzc3MjE1KSB7XG4gICAgICBjb25zdCBpbnQgPSB2YWx1ZTtcbiAgICAgIHIgPSAoaW50ID4+IDE2ICYgMjU1KSAvIDI1NTtcbiAgICAgIGcgPSAoaW50ID4+IDggJiAyNTUpIC8gMjU1O1xuICAgICAgYiA9IChpbnQgJiAyNTUpIC8gMjU1O1xuICAgICAgYSA9IDE7XG4gICAgfSBlbHNlIGlmICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpICYmIHZhbHVlLmxlbmd0aCA+PSAzICYmIHZhbHVlLmxlbmd0aCA8PSA0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2NsYW1wKHZhbHVlKTtcbiAgICAgIFtyLCBnLCBiLCBhID0gMV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgJiYgdmFsdWUubGVuZ3RoID49IDMgJiYgdmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY2xhbXAodmFsdWUsIDAsIDI1NSk7XG4gICAgICBbciwgZywgYiwgYSA9IDI1NV0gPSB2YWx1ZTtcbiAgICAgIHIgLz0gMjU1O1xuICAgICAgZyAvPSAyNTU7XG4gICAgICBiIC89IDI1NTtcbiAgICAgIGEgLz0gMjU1O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF9Db2xvci5IRVhfUEFUVEVSTi5leGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFsdWUgPSBgIyR7bWF0Y2hbMl19YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcmQodmFsdWUpO1xuICAgICAgaWYgKGNvbG9yLmlzVmFsaWQoKSkge1xuICAgICAgICAoeyByLCBnLCBiLCBhIH0gPSBjb2xvci5yZ2JhKTtcbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY29tcG9uZW50c1swXSA9IHI7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzFdID0gZztcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gPSBiO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1szXSA9IGE7XG4gICAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgY29sb3IgJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqIFJlZnJlc2ggdGhlIGludGVybmFsIGNvbG9yIHJnYiBudW1iZXIgKi9cbiAgX3JlZnJlc2hJbnQoKSB7XG4gICAgdGhpcy5fY2xhbXAodGhpcy5fY29tcG9uZW50cyk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9pbnQgPSAociAqIDI1NSA8PCAxNikgKyAoZyAqIDI1NSA8PCA4KSArIChiICogMjU1IHwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsYW1wcyB2YWx1ZXMgdG8gYSByYW5nZS4gV2lsbCBvdmVycmlkZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUocykgdG8gY2xhbXBcbiAgICogQHBhcmFtIG1pbiAtIE1pbmltdW0gdmFsdWVcbiAgICogQHBhcmFtIG1heCAtIE1heGltdW0gdmFsdWVcbiAgICovXG4gIF9jbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgdmFsdWUuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgdmFsdWVbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgY29sb3ItbGlrZSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBjb2xvci1saWtlIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIENvbG9yLmlzQ29sb3JMaWtlKCd3aGl0ZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogQ29sb3IuaXNDb2xvckxpa2UoMHhmZmZmZmYpOyAvLyByZXR1cm5zIHRydWVcbiAgICogQ29sb3IuaXNDb2xvckxpa2UoWzEsIDEsIDFdKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqL1xuICBzdGF0aWMgaXNDb2xvckxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIF9Db2xvciB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB2YWx1ZS5yICE9PSB2b2lkIDAgJiYgdmFsdWUuZyAhPT0gdm9pZCAwICYmIHZhbHVlLmIgIT09IHZvaWQgMCB8fCB2YWx1ZS5yICE9PSB2b2lkIDAgJiYgdmFsdWUuZyAhPT0gdm9pZCAwICYmIHZhbHVlLmIgIT09IHZvaWQgMCAmJiB2YWx1ZS5hICE9PSB2b2lkIDAgfHwgdmFsdWUuaCAhPT0gdm9pZCAwICYmIHZhbHVlLnMgIT09IHZvaWQgMCAmJiB2YWx1ZS5sICE9PSB2b2lkIDAgfHwgdmFsdWUuaCAhPT0gdm9pZCAwICYmIHZhbHVlLnMgIT09IHZvaWQgMCAmJiB2YWx1ZS5sICE9PSB2b2lkIDAgJiYgdmFsdWUuYSAhPT0gdm9pZCAwIHx8IHZhbHVlLmggIT09IHZvaWQgMCAmJiB2YWx1ZS5zICE9PSB2b2lkIDAgJiYgdmFsdWUudiAhPT0gdm9pZCAwIHx8IHZhbHVlLmggIT09IHZvaWQgMCAmJiB2YWx1ZS5zICE9PSB2b2lkIDAgJiYgdmFsdWUudiAhPT0gdm9pZCAwICYmIHZhbHVlLmEgIT09IHZvaWQgMDtcbiAgfVxufTtcbi8qKlxuICogRGVmYXVsdCBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAqIENvbG9yLnNoYXJlZC5zZXRWYWx1ZSgweGZmZmZmZikudG9IZXgoKTsgLy8gJyNmZmZmZmYnXG4gKi9cbl9Db2xvci5zaGFyZWQgPSBuZXcgX0NvbG9yKCk7XG4vKipcbiAqIFRlbXBvcmFyeSBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzIGludGVybmFsbHkuXG4gKiBBcyB0byBub3QgY29uZmxpY3Qgd2l0aCBDb2xvci5zaGFyZWQuXG4gKiBAaWdub3JlXG4gKi9cbl9Db2xvci5fdGVtcCA9IG5ldyBfQ29sb3IoKTtcbi8qKiBQYXR0ZXJuIGZvciBoZXggc3RyaW5ncyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuX0NvbG9yLkhFWF9QQVRURVJOID0gL14oI3wweCk/KChbYS1mMC05XXszfSl7MSwyfShbYS1mMC05XXsyfSk/KSQvaTtcbmxldCBDb2xvciA9IF9Db2xvcjtcblxuZXhwb3J0IHsgQ29sb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8409\n')},3646:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  z: () => (/* binding */ DOMAdapter)\n});\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs\n\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement("canvas");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, "text/xml");\n  }\n};\n\n\n//# sourceMappingURL=BrowserAdapter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs\n\n\n"use strict";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\n\n//# sourceMappingURL=adapter.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQ3JCMkU7O0FBRTNFO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZW52aXJvbm1lbnQtYnJvd3Nlci9Ccm93c2VyQWRhcHRlci5tanM/MGQyNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcz81NTkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQnJvd3NlckFkYXB0ZXIgPSB7XG4gIGNyZWF0ZUNhbnZhczogKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfSxcbiAgZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiAoKSA9PiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dDogKCkgPT4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBnZXROYXZpZ2F0b3I6ICgpID0+IG5hdmlnYXRvcixcbiAgZ2V0QmFzZVVybDogKCkgPT4gZG9jdW1lbnQuYmFzZVVSSSA/PyB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgZ2V0Rm9udEZhY2VTZXQ6ICgpID0+IGRvY3VtZW50LmZvbnRzLFxuICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgcGFyc2VYTUw6ICh4bWwpID0+IHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpO1xuICB9XG59O1xuXG5leHBvcnQgeyBCcm93c2VyQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlckFkYXB0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQnJvd3NlckFkYXB0ZXIgfSBmcm9tICcuLi9lbnZpcm9ubWVudC1icm93c2VyL0Jyb3dzZXJBZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IGN1cnJlbnRBZGFwdGVyID0gQnJvd3NlckFkYXB0ZXI7XG5jb25zdCBET01BZGFwdGVyID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhZGFwdGVyLlxuICAgKiBAcmV0dXJucyB7ZW52aXJvbm1lbnQuQWRhcHRlcn0gVGhlIGN1cnJlbnQgYWRhcHRlci5cbiAgICovXG4gIGdldCgpIHtcbiAgICByZXR1cm4gY3VycmVudEFkYXB0ZXI7XG4gIH0sXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGFkYXB0ZXIuXG4gICAqIEBwYXJhbSBhZGFwdGVyIC0gVGhlIG5ldyBhZGFwdGVyLlxuICAgKi9cbiAgc2V0KGFkYXB0ZXIpIHtcbiAgICBjdXJyZW50QWRhcHRlciA9IGFkYXB0ZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IERPTUFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0ZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3646\n')},3489:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rw: () => (/* binding */ extensions),\n/* harmony export */   nw: () => (/* binding */ ExtensionType)\n/* harmony export */ });\n/* unused harmony export normalizeExtensionPriority */\n\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2["Application"] = "application";\n  ExtensionType2["WebGLPipes"] = "webgl-pipes";\n  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";\n  ExtensionType2["WebGLSystem"] = "webgl-system";\n  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";\n  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";\n  ExtensionType2["WebGPUSystem"] = "webgpu-system";\n  ExtensionType2["CanvasSystem"] = "canvas-system";\n  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";\n  ExtensionType2["CanvasPipes"] = "canvas-pipes";\n  ExtensionType2["Asset"] = "asset";\n  ExtensionType2["LoadParser"] = "load-parser";\n  ExtensionType2["ResolveParser"] = "resolve-parser";\n  ExtensionType2["CacheParser"] = "cache-parser";\n  ExtensionType2["DetectionParser"] = "detection-parser";\n  ExtensionType2["MaskEffect"] = "mask-effect";\n  ExtensionType2["BlendMode"] = "blend-mode";\n  ExtensionType2["TextureSource"] = "texture-source";\n  ExtensionType2["Environment"] = "environment";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error("Extension class must have an extension object");\n    }\n    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === "object") {\n    ext = { ...ext };\n  } else {\n    throw new Error("Invalid extension type");\n  }\n  if (typeof ext.type === "string") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=Extensions.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakYsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw0QkFBNEI7QUFDeEcsbUZBQW1GLDRCQUE0QjtBQUMvRyxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRTtBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanM/YjdhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBFeHRlbnNpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRXh0ZW5zaW9uVHlwZTIpID0+IHtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBcHBsaWNhdGlvblwiXSA9IFwiYXBwbGljYXRpb25cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJXZWJHTFBpcGVzXCJdID0gXCJ3ZWJnbC1waXBlc1wiO1xuICBFeHRlbnNpb25UeXBlMltcIldlYkdMUGlwZXNBZGFwdG9yXCJdID0gXCJ3ZWJnbC1waXBlcy1hZGFwdG9yXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiV2ViR0xTeXN0ZW1cIl0gPSBcIndlYmdsLXN5c3RlbVwiO1xuICBFeHRlbnNpb25UeXBlMltcIldlYkdQVVBpcGVzXCJdID0gXCJ3ZWJncHUtcGlwZXNcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJXZWJHUFVQaXBlc0FkYXB0b3JcIl0gPSBcIndlYmdwdS1waXBlcy1hZGFwdG9yXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiV2ViR1BVU3lzdGVtXCJdID0gXCJ3ZWJncHUtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzU3lzdGVtXCJdID0gXCJjYW52YXMtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzUGlwZXNBZGFwdG9yXCJdID0gXCJjYW52YXMtcGlwZXMtYWRhcHRvclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkNhbnZhc1BpcGVzXCJdID0gXCJjYW52YXMtcGlwZXNcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBc3NldFwiXSA9IFwiYXNzZXRcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJMb2FkUGFyc2VyXCJdID0gXCJsb2FkLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIlJlc29sdmVQYXJzZXJcIl0gPSBcInJlc29sdmUtcGFyc2VyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FjaGVQYXJzZXJcIl0gPSBcImNhY2hlLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkRldGVjdGlvblBhcnNlclwiXSA9IFwiZGV0ZWN0aW9uLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIk1hc2tFZmZlY3RcIl0gPSBcIm1hc2stZWZmZWN0XCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQmxlbmRNb2RlXCJdID0gXCJibGVuZC1tb2RlXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiVGV4dHVyZVNvdXJjZVwiXSA9IFwidGV4dHVyZS1zb3VyY2VcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJFbnZpcm9ubWVudFwiXSA9IFwiZW52aXJvbm1lbnRcIjtcbiAgcmV0dXJuIEV4dGVuc2lvblR5cGUyO1xufSkoRXh0ZW5zaW9uVHlwZSB8fCB7fSk7XG5jb25zdCBub3JtYWxpemVFeHRlbnNpb24gPSAoZXh0KSA9PiB7XG4gIGlmICh0eXBlb2YgZXh0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIiAmJiBleHQuZXh0ZW5zaW9uKSB7XG4gICAgaWYgKCFleHQuZXh0ZW5zaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gY2xhc3MgbXVzdCBoYXZlIGFuIGV4dGVuc2lvbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gdHlwZW9mIGV4dC5leHRlbnNpb24gIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IGV4dC5leHRlbnNpb24gfSA6IGV4dC5leHRlbnNpb247XG4gICAgZXh0ID0geyAuLi5tZXRhZGF0YSwgcmVmOiBleHQgfTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGV4dCA9IHsgLi4uZXh0IH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHRlbnNpb24gdHlwZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXh0LnR5cGUgPSBbZXh0LnR5cGVdO1xuICB9XG4gIHJldHVybiBleHQ7XG59O1xuY29uc3Qgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgPSAoZXh0LCBkZWZhdWx0UHJpb3JpdHkpID0+IG5vcm1hbGl6ZUV4dGVuc2lvbihleHQpLnByaW9yaXR5ID8/IGRlZmF1bHRQcmlvcml0eTtcbmNvbnN0IGV4dGVuc2lvbnMgPSB7XG4gIC8qKiBAaWdub3JlICovXG4gIF9hZGRIYW5kbGVyczoge30sXG4gIC8qKiBAaWdub3JlICovXG4gIF9yZW1vdmVIYW5kbGVyczoge30sXG4gIC8qKiBAaWdub3JlICovXG4gIF9xdWV1ZToge30sXG4gIC8qKlxuICAgKiBSZW1vdmUgZXh0ZW5zaW9ucyBmcm9tIFBpeGlKUy5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBFeHRlbnNpb25zIHRvIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm5zIHtleHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZW1vdmUoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICBleHRlbnNpb25zMi5tYXAobm9ybWFsaXplRXh0ZW5zaW9uKS5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgIGV4dC50eXBlLmZvckVhY2goKHR5cGUpID0+IHRoaXMuX3JlbW92ZUhhbmRsZXJzW3R5cGVdPy4oZXh0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBSZWdpc3RlciBuZXcgZXh0ZW5zaW9ucyB3aXRoIFBpeGlKUy5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBUaGUgc3ByZWFkIG9mIGV4dGVuc2lvbnMgdG8gYWRkIHRvIFBpeGlKUy5cbiAgICogQHJldHVybnMge2V4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZCguLi5leHRlbnNpb25zMikge1xuICAgIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICBpZiAoIWhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgcXVldWVbdHlwZV0gPSBxdWV1ZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICBxdWV1ZVt0eXBlXT8ucHVzaChleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzW3R5cGVdPy4oZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGV4dGVuc2lvbnMgYnkgbmFtZS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXh0ZW5zaW9uIHR5cGUuXG4gICAqIEBwYXJhbSBvbkFkZCAgLSBGdW5jdGlvbiBoYW5kbGVyIHdoZW4gZXh0ZW5zaW9ucyBhcmUgYWRkZWQvcmVnaXN0ZXJlZCB7QGxpbmsgU3RyaWN0RXh0ZW5zaW9uRm9ybWF0fS5cbiAgICogQHBhcmFtIG9uUmVtb3ZlICAtIEZ1bmN0aW9uIGhhbmRsZXIgd2hlbiBleHRlbnNpb25zIGFyZSByZW1vdmVkL3VucmVnaXN0ZXJlZCB7QGxpbmsgU3RyaWN0RXh0ZW5zaW9uRm9ybWF0fS5cbiAgICogQHJldHVybnMge2V4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZSh0eXBlLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBhZGRIYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgIGNvbnN0IHJlbW92ZUhhbmRsZXJzID0gdGhpcy5fcmVtb3ZlSGFuZGxlcnM7XG4gICAgaWYgKGFkZEhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4dGVuc2lvbiB0eXBlICR7dHlwZX0gYWxyZWFkeSBoYXMgYSBoYW5kbGVyYCk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXJzW3R5cGVdID0gb25BZGQ7XG4gICAgcmVtb3ZlSGFuZGxlcnNbdHlwZV0gPSBvblJlbW92ZTtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGlmIChxdWV1ZVt0eXBlXSkge1xuICAgICAgcXVldWVbdHlwZV0/LmZvckVhY2goKGV4dCkgPT4gb25BZGQoZXh0KSk7XG4gICAgICBkZWxldGUgcXVldWVbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbWFwIGJ5IGBuYW1lYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIGV4dGVuc2lvbiB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBtYXAgLSBUaGUgb2JqZWN0IG1hcCBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlNYXAodHlwZSwgbWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKFxuICAgICAgdHlwZSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5uYW1lKSB7XG4gICAgICAgICAgbWFwW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5yZWY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb24ubmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbZXh0ZW5zaW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSxcbiAgLyoqXG4gICAqIEhhbmRsZSBhIHR5cGUsIGJ1dCB1c2luZyBhIGxpc3Qgb2YgZXh0ZW5zaW9ucyB3aXRoIGEgYG5hbWVgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgZXh0ZW5zaW9uIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIG1hcCAtIFRoZSBhcnJheSBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFByaW9yaXR5IC0gRmFsbGJhY2sgcHJpb3JpdHkgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlOYW1lZExpc3QodHlwZSwgbWFwLCBkZWZhdWx0UHJpb3JpdHkgPSAtMSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZShcbiAgICAgIHR5cGUsXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWFwLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS5uYW1lID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFwLnB1c2goeyBuYW1lOiBleHRlbnNpb24ubmFtZSwgdmFsdWU6IGV4dGVuc2lvbi5yZWYgfSk7XG4gICAgICAgIG1hcC5zb3J0KChhLCBiKSA9PiBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eShiLnZhbHVlLCBkZWZhdWx0UHJpb3JpdHkpIC0gbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkoYS52YWx1ZSwgZGVmYXVsdFByaW9yaXR5KSk7XG4gICAgICB9LFxuICAgICAgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0ubmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbWFwLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbGlzdCBvZiBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgZXh0ZW5zaW9uIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCBvZiBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFByaW9yaXR5IC0gVGhlIGRlZmF1bHQgcHJpb3JpdHkgdG8gdXNlIGlmIG5vbmUgaXMgc3BlY2lmaWVkLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlMaXN0KHR5cGUsIGxpc3QsIGRlZmF1bHRQcmlvcml0eSA9IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKFxuICAgICAgdHlwZSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoZXh0ZW5zaW9uLnJlZikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgICBsaXN0LnNvcnQoKGEsIGIpID0+IG5vcm1hbGl6ZUV4dGVuc2lvblByaW9yaXR5KGIsIGRlZmF1bHRQcmlvcml0eSkgLSBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eShhLCBkZWZhdWx0UHJpb3JpdHkpKTtcbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucywgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dGVuc2lvbnMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3489\n')},6282:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ FilterEffect)\n/* harmony export */ });\n\nclass FilterEffect {\n  constructor(options) {\n    this.pipe = "filter";\n    this.priority = 1;\n    this.filters = options?.filters;\n    this.filterArea = options?.filterArea;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\n\n//# sourceMappingURL=FilterEffect.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanM/NzhhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZpbHRlckVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBpcGUgPSBcImZpbHRlclwiO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxO1xuICAgIHRoaXMuZmlsdGVycyA9IG9wdGlvbnM/LmZpbHRlcnM7XG4gICAgdGhpcy5maWx0ZXJBcmVhID0gb3B0aW9ucz8uZmlsdGVyQXJlYTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmlsdGVyRWZmZWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJFZmZlY3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6282\n')},3974:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MxU: () => (/* reexport */ Application),\n  deM: () => (/* reexport */ Assets),\n  TCu: () => (/* reexport */ Graphics/* Graphics */.T),\n  jyi: () => (/* reexport */ Sprite/* Sprite */.j)\n});\n\n// UNUSED EXPORTS: AbstractBitmapFont, AbstractRenderer, AbstractText, AccessibilitySystem, AlphaFilter, AlphaMask, AlphaMaskPipe, AnimatedSprite, AssetsClass, BLEND_TO_NPM, BUFFER_TYPE, BackgroundLoader, BackgroundSystem, Batch, BatchGeometry, BatchTextureArray, BatchableGraphics, BatchableMesh, BatchableSprite, Batcher, BatcherPipe, BigPool, BindGroup, BindGroupSystem, BitmapFont, BitmapFontManager, BitmapText, BitmapTextPipe, BlendModeFilter, BlendModePipe, BlurFilter, BlurFilterPass, Bounds, BrowserAdapter, Buffer, BufferImageSource, BufferResource, BufferUsage, CLEAR, Cache, CanvasPool, CanvasPoolClass, CanvasSource, CanvasTextMetrics, CanvasTextPipe, CanvasTextSystem, Circle, Color, ColorBlend, ColorBurnBlend, ColorDodgeBlend, ColorMask, ColorMaskPipe, ColorMatrixFilter, CompressedSource, Container, Culler, CullerPlugin, CustomRenderPipe, DATA_URI, DDS, DEG_TO_RAD, DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, DOMAdapter, DRAW_MODES, DXGI_TO_TEXTURE_FORMAT, DarkenBlend, DifferenceBlend, DisplacementFilter, DivideBlend, DynamicBitmapFont, Ellipse, EventBoundary, EventEmitter, EventSystem, EventsTicker, ExclusionBlend, ExtensionType, ExtractSystem, FOURCC_TO_TEXTURE_FORMAT, FederatedContainer, FederatedEvent, FederatedMouseEvent, FederatedPointerEvent, FederatedWheelEvent, FillGradient, FillPattern, Filter, FilterEffect, FilterPipe, FilterSystem, FontStylePromiseCache, GAUSSIAN_VALUES, GL_FORMATS, GL_INTERNAL_FORMAT, GL_TARGETS, GL_TYPES, GL_WRAP_MODES, GenerateTextureSystem, Geometry, GlBackBufferSystem, GlBatchAdaptor, GlBuffer, GlBufferSystem, GlColorMaskSystem, GlContextSystem, GlEncoderSystem, GlGeometrySystem, GlGraphicsAdaptor, GlMeshAdaptor, GlProgram, GlProgramData, GlRenderTarget, GlRenderTargetAdaptor, GlRenderTargetSystem, GlShaderSystem, GlStateSystem, GlStencilSystem, GlTexture, GlTextureSystem, GlUboSystem, GlUniformGroupSystem, GlobalUniformSystem, GpuBatchAdaptor, GpuBlendModesToPixi, GpuBufferSystem, GpuColorMaskSystem, GpuDeviceSystem, GpuEncoderSystem, GpuGraphicsAdaptor, GpuGraphicsContext, GpuMeshAdapter, GpuMipmapGenerator, GpuProgram, GpuReadBuffer, GpuRenderTarget, GpuRenderTargetAdaptor, GpuRenderTargetSystem, GpuShaderSystem, GpuStateSystem, GpuStencilModesToPixi, GpuStencilSystem, GpuTextureSystem, GpuUboSystem, GpuUniformBatchPipe, GraphicsContext, GraphicsContextRenderData, GraphicsContextSystem, GraphicsPath, GraphicsPipe, HTMLText, HTMLTextPipe, HTMLTextRenderData, HTMLTextStyle, HTMLTextSystem, HardLightBlend, HardMixBlend, HelloSystem, IGLUniformData, ImageSource, InstructionSet, KTX, LightenBlend, LinearBurnBlend, LinearDodgeBlend, LinearLightBlend, Loader, LoaderParserPriority, LuminosityBlend, MAX_TEXTURES, MSAA_QUALITY, MaskEffectManager, MaskEffectManagerClass, MaskFilter, Matrix, Mesh, MeshGeometry, MeshPipe, MeshPlane, MeshRope, MeshSimple, NOOP, NegationBlend, NineSliceGeometry, NineSlicePlane, NineSliceSprite, NineSliceSpritePipe, NoiseFilter, ObservablePoint, OverlayBlend, PI_2, PinLightBlend, PipelineSystem, PlaneGeometry, Point, Polygon, Pool, PoolGroupClass, PrepareBase, PrepareQueue, PrepareSystem, PrepareUpload, QuadGeometry, RAD_TO_DEG, Rectangle, RenderContainer, RenderGroup, RenderGroupPipe, RenderGroupSystem, RenderTarget, RenderTargetSystem, RenderTexture, RendererType, ResizePlugin, Resolver, RopeGeometry, RoundedRectangle, SCALE_MODES, STENCIL_MODES, SVGParser, SVGToGraphicsPath, SaturationBlend, ScissorMask, SdfShader, Shader, ShaderStage, ShapePath, SharedRenderPipes, SharedSystems, SoftLightBlend, SpritePipe, Spritesheet, State, StencilMask, StencilMaskPipe, SubtractBlend, SystemRunner, TEXTURE_FORMAT_BLOCK_SIZE, Text, TextStyle, Texture, TextureGCSystem, TextureMatrix, TexturePool, TexturePoolClass, TextureSource, TextureStyle, TextureUvs, Ticker, TickerListener, TickerPlugin, TilingSprite, TilingSpritePipe, TilingSpriteShader, Transform, Triangle, UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS, UPDATE_BLEND, UPDATE_COLOR, UPDATE_PRIORITY, UPDATE_TRANSFORM, UPDATE_VISIBLE, UboBatch, UboSystem, UniformGroup, VERSION, VideoSource, ViewSystem, ViewableBuffer, VividLightBlend, WGSL_ALIGN_SIZE_DATA, WGSL_TO_STD40_SIZE, WRAP_MODES, WebGLRenderer, WebGPURenderer, WebWorkerAdapter, WorkerManager, _getGlobalBounds, _getGlobalBoundsRecursive, accessibilityTarget, addBits, addMaskBounds, addMaskLocalBounds, addProgramDefines, alphaFrag, alphaWgsl, applyMatrix, applyStyleParams, assignWithIgnore, autoDetectEnvironment, autoDetectRenderer, autoDetectSource, basisTranscoderUrls, batchSamplersUniformGroup, bitmapFontCachePlugin, bitmapFontTextParser, bitmapFontXMLParser, bitmapFontXMLStringParser, blendTemplateFrag, blendTemplateVert, blendTemplateWgsl, blockDataMap, blurTemplateWgsl, boundsPool, browserExt, buildAdaptiveBezier, buildAdaptiveQuadratic, buildArc, buildArcTo, buildArcToSvg, buildCircle, buildContextBatches, buildGeometryFromPath, buildInstructions, buildLine, buildPolygon, buildRectangle, buildSimpleUvs, buildTriangle, buildUvs, cacheTextureArray, calculateProjection, checkChildrenDidChange, checkDataUrl, checkExtension, childrenHelperMixin, closePointEps, collectAllRenderables, collectRenderGroups, color32BitToUniform, colorBit, colorBitGl, colorMatrixFilterFrag, colorMatrixFilterWgsl, colorToUniform, compareModeToGlCompare, compileHighShader, compileHighShaderGl, compileHighShaderGlProgram, compileHighShaderGpuProgram, compileHooks, compileInputs, compileOutputs, compileShader, convertFillInputToFillStyle, convertFormatIfRequired, convertToList, copySearchParams, createIdFromString, createLevelBuffers, createLevelBuffersFromKTX, createStringVariations, createTexture, createUboElementsSTD40, createUboElementsWGSL, createUboSyncFunction, createUboSyncFunctionSTD40, createUboSyncFunctionWGSL, crossOrigin, cullingMixin, curveEps, defaultFilterVert, defaultValue, definedProps, deprecation, detectAvif, detectBasis, detectCompressed, detectDefaults, detectMp4, detectOgv, detectVideoAlphaMode, detectWebm, detectWebp, determineCrossOrigin, displacementFrag, displacementVert, displacementWgsl, earcut, effectsMixin, ensureAttributes, ensureIsBuffer, ensureOptions, ensurePrecision, ensureTextStyle, executeInstructions, extensions, extractAttributesFromGlProgram, extractAttributesFromGpuProgram, extractFontFamilies, extractStructAndGroups, fastCopy, findHooksRx, findMixin, fontStringFromTextStyle, formatShader, fragmentGPUTemplate, fragmentGlTemplate, generateArraySyncSTD40, generateArraySyncWGSL, generateBlurFragSource, generateBlurGlProgram, generateBlurProgram, generateBlurVertSource, generateGPULayout, generateGpuLayoutGroups, generateLayout, generateLayoutHash, generateProgram, generateShaderSyncCode, generateTextStyleKey, generateTextureBatchBit, generateTextureBatchBitGl, generateUID, generateUniformsSync, getAdjustedBlendModeBlend, getAttributeInfoFromFormat, getBitmapTextLayout, getCanvasBoundingBox, getCanvasFillStyle, getCanvasTexture, getDefaultUniformValue, getFastGlobalBounds, getFontCss, getFontFamilyName, getGeometryBounds, getGlTypeFromFormat, getGlobalBounds, getGlobalRenderableBounds, getLocalBounds, getMatrixRelativeToParent, getMaxFragmentPrecision, getOrientationOfPoints, getParent, getPo2TextureFromSource, getResolutionOfUrl, getSVGUrl, getSupportedCompressedTextureFormats, getSupportedGPUCompressedTextureFormats, getSupportedGlCompressedTextureFormats, getSupportedTextureFormats, getTemporaryCanvasFromImage, getTestContext, getTextureBatchBindGroup, getTextureDefaultMatrix, getTextureFormatFromKTXTexture, getUboData, getUniformData, getUrlExtension, glFormatToGPUFormat, glUploadBufferImageResource, glUploadCompressedTextureResource, glUploadImageResource, glUploadVideoResource, globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl, gpuFormatToBasisTranscoderFormat, gpuFormatToKTXBasisTranscoderFormat, gpuUploadBufferImageResource, gpuUploadCompressedTextureResource, gpuUploadImageResource, gpuUploadVideoResource, groupD8, hasCachedCanvasTexture, hslWgsl, hslgl, hslgpu, injectBits, insertVersion, isMobile, isPow2, isRenderingToScreen, isSafari, isSingleItem, isWebGLSupported, isWebGPUSupported, ktxTranscoderUrls, loadBasis, loadBasisOnWorker, loadBitmapFont, loadDDS, loadFontAsBase64, loadFontCSS, loadImageBitmap, loadJson, loadKTX, loadKTX2, loadKTX2onWorker, loadSVGImage, loadSvg, loadTextures, loadTxt, loadVideoTextures, loadWebFont, localUniformBit, localUniformBitGl, localUniformBitGroup2, localUniformMSDFBit, localUniformMSDFBitGl, log2, logDebugTexture, logProgramError, logRenderGroupScene, logScene, mSDFBit, mSDFBitGl, mapFormatToGlFormat, mapFormatToGlInternalFormat, mapFormatToGlType, mapGlToVertexFormat, mapSize, mapType, mapWebGLBlendModesToPixi, maskFrag, maskVert, maskWgsl, matrixPool, measureHtmlText, measureMixin, migrateFragmentFromV7toV8, mipmapScaleModeToGlFilter, mixColors, mixHexColors, mixStandardAnd32BitColors, multiplyHexColors, nextPow2, noiseFrag, noiseWgsl, nonCompressedFormats, normalizeExtensionPriority, nssvg, nsxhtml, onRenderMixin, parseDDS, parseFunctionBody, parseKTX, path, preloadVideo, removeItems, removeStructAndGroupDuplicates, resetUids, resolveCharacters, resolveCompressedTextureUrl, resolveJsonUrl, resolveTextureUrl, resourceToTexture, roundPixelsBit, roundPixelsBitGl, roundedShapeArc, roundedShapeQuadraticCurve, sayHello, scaleModeToGlFilter, setBasisTranscoderPath, setKTXTranscoderPath, setPositions, setProgramName, setUvs, sortMixin, spritesheetAsset, squaredDistanceToLineSegment, stripVersion, testImageFormat, testVideoFormat, textStyleToCSS, textureBit, textureBitGl, textureFrom, tilingBit, tilingBitGl, toLocalGlobalMixin, transformVertices, triangulateWithHoles, uboSyncFunctionsSTD40, uboSyncFunctionsWGSL, uid, uniformParsers, unpremultiplyAlpha, unsafeEvalSupported, updateLocalTransform, updateQuadBounds, updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren, updateTransformBackwards, updateWorldTransform, v8_0_0, validFormats, validateRenderables, vertexGPUTemplate, vertexGlTemplate, viewportFromFrame, vkFormatToGPUFormat, warn, webworkerExt, wrapModeToGlAddress\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/browserExt.mjs\n\n\n"use strict";\nconst browserExt = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.Environment,\n    name: "browser",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(737), __webpack_require__.e(81)]).then(__webpack_require__.bind(__webpack_require__, 2081));\n  }\n};\n\n\n//# sourceMappingURL=browserExt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs\n\n\n"use strict";\nconst webworkerExt = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.Environment,\n    name: "webworker",\n    priority: 0\n  },\n  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(737), __webpack_require__.e(277)]).then(__webpack_require__.bind(__webpack_require__, 1277));\n  }\n};\n\n\n//# sourceMappingURL=webworkerExt.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs + 5 modules\nvar init = __webpack_require__(8713);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs + 2 modules\nvar spritesheet_init = __webpack_require__(9154);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs\n\n\n"use strict";\nconst environments = [];\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.Environment, environments);\nasync function autoDetectEnvironment(manageImports) {\n  if (!manageImports)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\n\n\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs\nvar AbstractRenderer = __webpack_require__(7199);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs\n\n\n\n"use strict";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer */.I.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!adapter/* DOMAdapter */.z.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = adapter/* DOMAdapter */.z.get().createCanvas();\n      let gl = canvas.getContext("webgl", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension("WEBGL_lose_context");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs\n\n\n"use strict";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = adapter/* DOMAdapter */.z.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await navigator.gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\n\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs\n\n\n\n\n\n"use strict";\nconst renderPriority = ["webgpu", "webgl", "canvas"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  await autoDetectEnvironment(\n    options.manageImports ?? true\n  );\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === "webgpu" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(992), __webpack_require__.e(45)]).then(__webpack_require__.bind(__webpack_require__, 7045));\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === "webgl" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer */.I.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(992), __webpack_require__.e(172)]).then(__webpack_require__.bind(__webpack_require__, 2172));\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === "canvas") {\n      finalOptions = { ...options };\n      break;\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/Application.mjs\n\n\n\n\n\n"use strict";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that\'s rendered. */\n    this.stage = new Container/* Container */.W2();\n    if (args[0] !== void 0) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Application constructor options are deprecated, please use Application.init() instead.");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Application.view is deprecated, please use Application.canvas instead.");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.Application, Application._plugins);\n\n\n//# sourceMappingURL=Application.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/BackgroundLoader.mjs\n\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) {\n      console.log("[BackgroundLoader] assets: ", this._assetList);\n    }\n    if (this._isActive && !this._isLoading) {\n      void this._next();\n    }\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      void this._next();\n    }\n  }\n  /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      void this._next();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BackgroundLoader.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs\n\n\n\n"use strict";\nconst cacheTextureArray = {\n  extension: Extensions/* ExtensionType */.nw.CacheParser,\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture/* Texture */.x),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? "" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\n\n\n//# sourceMappingURL=cacheTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs\n\nasync function testImageFormat(imageData) {\n  if ("Image" in globalThis) {\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(true);\n      };\n      image.onerror = () => {\n        resolve(false);\n      };\n      image.src = imageData;\n    });\n  }\n  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\n\n//# sourceMappingURL=testImageFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs\n\n\n\n"use strict";\nconst detectAvif = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat(\n    // eslint-disable-next-line max-len\n    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="\n  ),\n  add: async (formats) => [...formats, "avif"],\n  remove: async (formats) => formats.filter((f) => f !== "avif")\n};\n\n\n//# sourceMappingURL=detectAvif.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs\n\n\n"use strict";\nconst imageFormats = ["png", "jpg", "jpeg"];\nconst detectDefaults = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\n\n\n//# sourceMappingURL=detectDefaults.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs\n\nconst inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  if (inWorker) {\n    return false;\n  }\n  const video = document.createElement("video");\n  return video.canPlayType(mimeType) !== "";\n}\n\n\n//# sourceMappingURL=testVideoFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs\n\n\n\n"use strict";\nconst detectMp4 = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/mp4"),\n  add: async (formats) => [...formats, "mp4", "m4v"],\n  remove: async (formats) => formats.filter((f) => f !== "mp4" && f !== "m4v")\n};\n\n\n//# sourceMappingURL=detectMp4.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs\n\n\n\n"use strict";\nconst detectOgv = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/ogg"),\n  add: async (formats) => [...formats, "ogv"],\n  remove: async (formats) => formats.filter((f) => f !== "ogv")\n};\n\n\n//# sourceMappingURL=detectOgv.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs\n\n\n\n"use strict";\nconst detectWebm = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat("video/webm"),\n  add: async (formats) => [...formats, "webm"],\n  remove: async (formats) => formats.filter((f) => f !== "webm")\n};\n\n\n//# sourceMappingURL=detectWebm.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs\n\n\n\n"use strict";\nconst detectWebp = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat(\n    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="\n  ),\n  add: async (formats) => [...formats, "webp"],\n  remove: async (formats) => formats.filter((f) => f !== "webp")\n};\n\n\n//# sourceMappingURL=detectWebp.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/convertToList.mjs\nvar convertToList = __webpack_require__(9879);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs\nvar isSingleItem = __webpack_require__(1675);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/Loader.mjs\n\n\n\n\n\n"use strict";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          (0,warn/* warn */.Z)(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          (0,warn/* warn */.Z)(`[Assets] ${url} could not be loaded as we don\'t know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(assetsToLoadIn);\n    const assetsToLoad = (0,convertToList/* convertToList */.S)(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path/* path */.E.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load(\'cool.png\');\n   *\n   * await Loader.unload(\'cool.png\');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = (0,convertToList/* convertToList */.S)(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path/* path */.E.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        (0,warn/* warn */.Z)(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        (0,warn/* warn */.Z)(`[Assets] loadParser name conflict "${parser.name}"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\n\n//# sourceMappingURL=Loader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs\n\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\n\n//# sourceMappingURL=checkDataUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs\n\n\n"use strict";\nfunction checkExtension(url, extension) {\n  const tempURL = url.split("?")[0];\n  const ext = path/* path */.E.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\n\n//# sourceMappingURL=checkExtension.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs\n\n\n\n\n\n\n"use strict";\nconst validJSONExtension = ".json";\nconst validJSONMIME = "application/json";\nconst loadJson = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Low\n  },\n  name: "loadJson",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\n\n\n//# sourceMappingURL=loadJson.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs\n\n\n\n\n\n\n"use strict";\nconst validTXTExtension = ".txt";\nconst validTXTMIME = "text/plain";\nconst loadTxt = {\n  name: "loadTxt",\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Low\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\n\n\n//# sourceMappingURL=loadTxt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validWeights = [\n  "normal",\n  "bold",\n  "100",\n  "200",\n  "300",\n  "400",\n  "500",\n  "600",\n  "700",\n  "800",\n  "900"\n];\nconst validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];\nconst validFontMIMEs = [\n  "font/ttf",\n  "font/otf",\n  "font/woff",\n  "font/woff2"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path/* path */.E.extname(url);\n  const name = path/* path */.E.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, " ");\n  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(" ");\n  if (!valid) {\n    fontFamilyName = `"${fontFamilyName.replace(/[\\\\"]/g, "\\\\$&")}"`;\n  }\n  return fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&\'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  if (validURICharactersRegex.test(uri)) {\n    return uri;\n  }\n  return encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Low\n  },\n  name: "loadWebFont",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = adapter/* DOMAdapter */.z.get().getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      Cache/* Cache */.C.set(name, {\n        url,\n        fontFaces\n      });\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    (0,warn/* warn */.Z)("[loadWebFont] FontFace API is not supported. Skipping loading font");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => {\n      Cache/* Cache */.C.remove(t.family);\n      adapter/* DOMAdapter */.z.get().getFontFaceSet().delete(t);\n    });\n  }\n};\n\n\n//# sourceMappingURL=loadWebFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs + 15 modules\nvar GraphicsContext = __webpack_require__(6653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs + 1 modules\nvar Resolver = __webpack_require__(651);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs\n\n\n"use strict";\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = Resolver/* Resolver */.H.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\n\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs\n\n\n\n\n"use strict";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  const texture = new Texture/* Texture */.x({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache/* Cache */.C.has(url)) {\n      Cache/* Cache */.C.remove(url);\n    }\n  };\n  texture.once("destroy", () => {\n    if (url in loader.promiseCache) {\n      (0,warn/* warn */.Z)("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");\n      unload();\n    }\n  });\n  texture.source.once("destroy", () => {\n    if (!source.destroyed) {\n      (0,warn/* warn */.Z)("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");\n      unload();\n    }\n  });\n  return texture;\n}\n\n\n//# sourceMappingURL=createTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validSVGExtension = ".svg";\nconst validSVGMIME = "image/svg+xml";\nconst loadSvg = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Low\n  },\n  name: "loadSVG",\n  config: {\n    crossOrigin: "anonymous",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement("canvas");\n  const context = canvas.getContext("2d");\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n  const base = new ImageSource/* ImageSource */.c({\n    resource: canvas,\n    alphaMode: "premultiply-alpha-on-upload",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext/* GraphicsContext */.g();\n  context.svg(svgSource);\n  return context;\n}\n\n\n//# sourceMappingURL=loadSVG.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs\nconst WORKER_CODE = "(function () {\\n    \'use strict\';\\n\\n    const WHITE_PNG = \\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\"function\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: \'application/javascript\' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\n\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs\nconst loadImageBitmap_worker_WORKER_CODE = "(function () {\\n    \'use strict\';\\n\\n    async function loadImageBitmap(url) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      const imageBitmap = await createImageBitmap(imageBlob);\\n      return imageBitmap;\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n";\nlet loadImageBitmap_worker_WORKER_URL = null;\nclass loadImageBitmap_worker_WorkerInstance\n{\n    constructor()\n    {\n        if (!loadImageBitmap_worker_WORKER_URL)\n        {\n            loadImageBitmap_worker_WORKER_URL = URL.createObjectURL(new Blob([loadImageBitmap_worker_WORKER_CODE], { type: \'application/javascript\' }));\n        }\n        this.worker = new Worker(loadImageBitmap_worker_WORKER_URL);\n    }\n}\nloadImageBitmap_worker_WorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (loadImageBitmap_worker_WORKER_URL)\n    {\n        URL.revokeObjectURL(loadImageBitmap_worker_WORKER_URL);\n        loadImageBitmap_worker_WORKER_URL = null;\n    }\n};\n\n\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs\n\n\n\n"use strict";\nlet UUID = 0;\nlet MAX_WORKERS;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this._workerPool = [];\n    this._queue = [];\n    this._resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const { worker } = new WorkerInstance();\n      worker.addEventListener("message", (event) => {\n        worker.terminate();\n        WorkerInstance.revokeObjectURL();\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src) {\n    return this._run("loadImageBitmap", [src]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  _getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this._workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      this._createdWorkers++;\n      worker = new loadImageBitmap_worker_WorkerInstance().worker;\n      worker.addEventListener("message", (event) => {\n        this._complete(event.data);\n        this._returnWorker(event.target);\n        this._next();\n      });\n    }\n    return worker;\n  }\n  _returnWorker(worker) {\n    this._workerPool.push(worker);\n  }\n  _complete(data) {\n    if (data.error !== void 0) {\n      this._resolveHash[data.uuid].reject(data.error);\n    } else {\n      this._resolveHash[data.uuid].resolve(data.data);\n    }\n    this._resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({ id, arguments: args, resolve, reject });\n    });\n    this._next();\n    return promise;\n  }\n  _next() {\n    if (!this._queue.length)\n      return;\n    const worker = this._getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this._queue.pop();\n    const id = toDo.id;\n    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\n\n//# sourceMappingURL=WorkerManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];\nconst validImageMIMEs = [\n  "image/jpeg",\n  "image/png",\n  "image/webp",\n  "image/avif"\n];\nasync function loadImageBitmap(url) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  name: "loadTextures",\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.High\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: "anonymous"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise((resolve) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new ImageSource/* ImageSource */.c({\n      resource: src,\n      alphaMode: "premultiply-alpha-on-upload",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\n\n//# sourceMappingURL=loadTextures.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs\nvar VideoSource = __webpack_require__(914);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs\nvar detectVideoAlphaMode = __webpack_require__(5447);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith("data:")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener("canplaythrough", loaded);\n    element.addEventListener("error", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener("canplaythrough", loaded);\n      element.removeEventListener("error", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith("data:")) {\n    return "";\n  }\n  loc = loc || globalThis.location;\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return "anonymous";\n  }\n  return "";\n}\nconst loadVideoTextures = {\n  name: "loadVideo",\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser\n  },\n  config: null,\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource/* VideoSource */.L.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await (0,detectVideoAlphaMode/* detectVideoAlphaMode */.D)(),\n      ...asset.data\n    };\n    const videoElement = document.createElement("video");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? "auto" : void 0,\n      "webkit-playsinline": options.playsinline !== false ? "" : void 0,\n      playsinline: options.playsinline !== false ? "" : void 0,\n      muted: options.muted === true ? "" : void 0,\n      loop: options.loop === true ? "" : void 0,\n      autoplay: options.autoPlay !== false ? "" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement("source");\n    let mime;\n    if (url.startsWith("data:")) {\n      mime = url.slice(5, url.indexOf(";"));\n    } else if (!url.startsWith("blob:")) {\n      const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();\n      mime = VideoSource/* VideoSource */.L.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource/* VideoSource */.L({ ...options, resource: videoElement });\n        videoElement.removeEventListener("canplay", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener("canplay", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\n\n//# sourceMappingURL=loadVideoTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs\n\n\n\n\n"use strict";\nconst resolveTextureUrl = {\n  extension: Extensions/* ExtensionType */.nw.ResolveParser,\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(Resolver/* Resolver */.H.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n    format: value.split(".").pop(),\n    src: value\n  })\n};\n\n\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs\n\n\n\n\n"use strict";\nconst resolveJsonUrl = {\n  extension: Extensions/* ExtensionType */.nw.ResolveParser,\n  test: (value) => Resolver/* Resolver */.H.RETINA_PREFIX.test(value) && value.endsWith(".json"),\n  parse: resolveTextureUrl.parse\n};\n\n\n//# sourceMappingURL=resolveJsonUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/Assets.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver/* Resolver */.H();\n    this.loader = new Loader();\n    this.cache = Cache/* Cache */.C;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      (0,warn/* warn */.Z)("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === "string") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Simple\n   * Assets.add({alias: \'bunnyBooBoo\', src: \'bunny.png\'});\n   * const bunny = await Assets.load(\'bunnyBooBoo\');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: [\'burger\', \'chicken\'], src: \'bunny.png\'});\n   *\n   * const bunny = await Assets.load(\'burger\');\n   * const bunny2 = await Assets.load(\'chicken\');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: \'bunnyBooBooSmooth\',\n   *     src: \'bunny{png,webp}\',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: \'bunnyBooBoo\', src: \'bunny{png,webp}\'});\n   *\n   * Assets.add({\n   *     alias: \'bunnyBooBoo\',\n   *     src: [\n   *         \'bunny.png\',\n   *         \'bunny.webp\',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load(\'bunnyBooBoo\'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = (0,isSingleItem/* isSingleItem */.X)(urls);\n    const urlArray = (0,convertToList/* convertToList */.S)(urls).map((url) => {\n      if (typeof url !== "string") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.addBundle(\'animals\', [\n   *  { alias: \'bunny\', src: \'bunny.png\' },\n   *  { alias: \'chicken\', src: \'chicken.png\' },\n   *  { alias: \'thumper\', src: \'thumper.png\' },\n   * ]);\n   * // or\n   * Assets.addBundle(\'animals\', {\n   *     bunny: \'bunny.png\',\n   *     chicken: \'chicken.png\',\n   *     thumper: \'thumper.png\',\n   * });\n   *\n   * const assets = await Assets.loadBundle(\'animals\');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: \'load-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'background\',\n   *                     src: \'sunset.png\',\n   *                 },\n   *                 {\n   *                     alias: \'bar\',\n   *                     src: \'load-bar.{png,webp}\',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: \'game-screen\',\n   *             assets: [\n   *                 {\n   *                     alias: \'character\',\n   *                     src: \'robot.png\',\n   *                 },\n   *                 {\n   *                     alias: \'enemy\',\n   *                     src: \'bad-guy.png\',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle(\'load-screen\');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle(\'game-screen\');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === "string") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.backgroundLoad(\'bunny.png\');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle(\'bunny.png\'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === "string") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: \'load-screen\',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle(\'load-screen\');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle(\'load-screen\'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === "string") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === "string") {\n      return Cache/* Cache */.C.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache/* Cache */.C.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache/* Cache */.C.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it\'s up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won\'t break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load(\'http://some.url.com/image.png\'); // => returns a texture\n   *\n   * await Assets.unload(\'http://some.url.com/image.png\')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload([\'thumper\', \'chicko\']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = (0,convertToList/* convertToList */.S)(urls).map((url) => typeof url !== "string" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from \'pixi.js\';\n   *\n   * Assets.addBundle({\n   *     \'thumper\': \'http://some.url.com/thumper.png\',\n   * })\n   *\n   * const assets = await Assets.loadBundle(\'thumper\');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle(\'thumper\');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = (0,convertToList/* convertToList */.S)(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache/* Cache */.C.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.LoadParser, Assets.loader.parsers).handleByList(Extensions/* ExtensionType */.nw.ResolveParser, Assets.resolver.parsers).handleByList(Extensions/* ExtensionType */.nw.CacheParser, Assets.cache.parsers).handleByList(Extensions/* ExtensionType */.nw.DetectionParser, Assets.detections);\nExtensions/* extensions */.Rw.add(\n  cacheTextureArray,\n  detectDefaults,\n  detectAvif,\n  detectWebp,\n  detectMp4,\n  detectOgv,\n  detectWebm,\n  loadJson,\n  loadTxt,\n  loadWebFont,\n  loadSvg,\n  loadTextures,\n  loadVideoTextures,\n  resolveTextureUrl,\n  resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: Extensions/* ExtensionType */.nw.LoadParser,\n  resolver: Extensions/* ExtensionType */.nw.ResolveParser,\n  cache: Extensions/* ExtensionType */.nw.CacheParser,\n  detection: Extensions/* ExtensionType */.nw.DetectionParser\n};\nExtensions/* extensions */.Rw.handle(Extensions/* ExtensionType */.nw.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => Extensions/* extensions */.Rw.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it\'s own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => Extensions/* extensions */.Rw.remove(ref[key]));\n});\n\n\n//# sourceMappingURL=Assets.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4325);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nif (365 == __webpack_require__.j) {\nvar Graphics = __webpack_require__(6475);\n}\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(5263);\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(browserExt, webworkerExt);\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1k7QUFDUjtBQUNKO0FBQ0s7QUFDbkI7QUFDUTtBQUNKO0FBQ0U7QUFDQTtBQUNaO0FBQ0s7QUFDbEI7QUFDUTtBQUNxQjtBQUNVO0FBQ0Y7QUFDWTtBQUNDO0FBQ3JDO0FBQ2M7QUFDZDtBQUNRO0FBQ007QUFDVTtBQUNKO0FBQzFCO0FBQ1E7QUFDNEI7QUFDMUI7QUFDRTtBQUNnQjtBQUNLO0FBQ3pCO0FBQ29DO0FBQ3RCO0FBQ1Y7QUFDRTtBQUNNO0FBQ0Y7QUFDQTtBQUNFO0FBQ047QUFDSTtBQUNvQjtBQUNWO0FBQ3JCO0FBQ3VEO0FBQ3BDO0FBQ3ZDO0FBQ1U7QUFDa0I7QUFDVTtBQUNNO0FBQzdCO0FBQ1U7QUFDakI7QUFDUjtBQUNnQjtBQUNtQjtBQUN4QjtBQUNBO0FBQ2dCO0FBQ0U7QUFDSTtBQUNDO0FBQ2xDO0FBQ1c7QUFDRztBQUNMO0FBQ2U7QUFDSjtBQUNLO0FBQ0E7QUFDTztBQUM3QjtBQUNIO0FBQ1U7QUFDcUI7QUFDcEM7QUFDSztBQUN3QjtBQUNaO0FBQ2Q7O0FBRTNDO0FBQ0EsNkJBQVUsS0FBSyxVQUFVLEVBQUUsWUFBWTs7QUFFUztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50LWJyb3dzZXIvYnJvd3NlckV4dC5tanM/NjFlNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9lbnZpcm9ubWVudC13ZWJ3b3JrZXIvd2Vid29ya2VyRXh0Lm1qcz9hZjgyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanM/OTM2ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9icm93c2VyL2lzV2ViR0xTdXBwb3J0ZWQubWpzPzEyYzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9pc1dlYkdQVVN1cHBvcnRlZC5tanM/MzBhYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2F1dG9EZXRlY3RSZW5kZXJlci5tanM/M2JkNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hcHAvQXBwbGljYXRpb24ubWpzPzViOTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL0JhY2tncm91bmRMb2FkZXIubWpzPzMxMjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkubWpzP2Q5ZmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL2RldGVjdGlvbnMvdXRpbHMvdGVzdEltYWdlRm9ybWF0Lm1qcz83MmUyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0QXZpZi5tanM/Y2VhYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLm1qcz82MGJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9kZXRlY3Rpb25zL3V0aWxzL3Rlc3RWaWRlb0Zvcm1hdC5tanM/ZmQ0MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdE1wNC5tanM/MDgyMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdE9ndi5tanM/ODAxNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYm0ubWpzPzgxZjciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcz9iMThkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9sb2FkZXIvTG9hZGVyLm1qcz84ODRmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy91dGlscy9jaGVja0RhdGFVcmwubWpzPzM2ZTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcz8yZTk5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5tanM/ODk5ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvbG9hZFR4dC5tanM/YmZmMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQubWpzPzdhZmIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzP2IxMTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzP2I4OTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRTVkcubWpzPzQ4NWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvX3ZpcnR1YWwvY2hlY2tJbWFnZUJpdG1hcC53b3JrZXIubWpzP2M2NGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvX3ZpcnR1YWwvbG9hZEltYWdlQml0bWFwLndvcmtlci5tanM/NmMyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvbG9hZGVyL3dvcmtlcnMvV29ya2VyTWFuYWdlci5tanM/NzJmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcz9lODE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVmlkZW9UZXh0dXJlcy5tanM/NGMzNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlVGV4dHVyZVVybC5tanM/YjRjZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlSnNvblVybC5tanM/NWE1OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvQXNzZXRzLm1qcz8wOTRlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2luZGV4Lm1qcz82NTM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBicm93c2VyRXh0ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkVudmlyb25tZW50LFxuICAgIG5hbWU6IFwiYnJvd3NlclwiLFxuICAgIHByaW9yaXR5OiAtMVxuICB9LFxuICB0ZXN0OiAoKSA9PiB0cnVlLFxuICBsb2FkOiBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgaW1wb3J0KCcuL2Jyb3dzZXJBbGwubWpzJyk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJyb3dzZXJFeHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJFeHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHdlYndvcmtlckV4dCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5FbnZpcm9ubWVudCxcbiAgICBuYW1lOiBcIndlYndvcmtlclwiLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6ICgpID0+IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuV29ya2VyR2xvYmFsU2NvcGUgIT09IHZvaWQgMCxcbiAgbG9hZDogYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGltcG9ydCgnLi93ZWJ3b3JrZXJBbGwubWpzJyk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHdlYndvcmtlckV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Vid29ya2VyRXh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBlbnZpcm9ubWVudHMgPSBbXTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlOYW1lZExpc3QoRXh0ZW5zaW9uVHlwZS5FbnZpcm9ubWVudCwgZW52aXJvbm1lbnRzKTtcbmFzeW5jIGZ1bmN0aW9uIGF1dG9EZXRlY3RFbnZpcm9ubWVudChtYW5hZ2VJbXBvcnRzKSB7XG4gIGlmICghbWFuYWdlSW1wb3J0cylcbiAgICByZXR1cm47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW52aXJvbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZW52ID0gZW52aXJvbm1lbnRzW2ldO1xuICAgIGlmIChlbnYudmFsdWUudGVzdCgpKSB7XG4gICAgICBhd2FpdCBlbnYudmFsdWUubG9hZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBhdXRvRGV0ZWN0RW52aXJvbm1lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RFbnZpcm9ubWVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9BYnN0cmFjdFJlbmRlcmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IF9pc1dlYkdMU3VwcG9ydGVkO1xuZnVuY3Rpb24gaXNXZWJHTFN1cHBvcnRlZChmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0KSB7XG4gIGlmIChfaXNXZWJHTFN1cHBvcnRlZCAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBfaXNXZWJHTFN1cHBvcnRlZDtcbiAgX2lzV2ViR0xTdXBwb3J0ZWQgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHRPcHRpb25zID0ge1xuICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgPz8gQWJzdHJhY3RSZW5kZXJlci5kZWZhdWx0T3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFET01BZGFwdGVyLmdldCgpLmdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAhIWdsPy5nZXRDb250ZXh0QXR0cmlidXRlcygpPy5zdGVuY2lsO1xuICAgICAgaWYgKGdsKSB7XG4gICAgICAgIGNvbnN0IGxvc2VDb250ZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgICAgICBpZiAobG9zZUNvbnRleHQpIHtcbiAgICAgICAgICBsb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbCA9IG51bGw7XG4gICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4gX2lzV2ViR0xTdXBwb3J0ZWQ7XG59XG5cbmV4cG9ydCB7IGlzV2ViR0xTdXBwb3J0ZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzV2ViR0xTdXBwb3J0ZWQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX2lzV2ViR1BVU3VwcG9ydGVkO1xuYXN5bmMgZnVuY3Rpb24gaXNXZWJHUFVTdXBwb3J0ZWQob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChfaXNXZWJHUFVTdXBwb3J0ZWQgIT09IHZvaWQgMClcbiAgICByZXR1cm4gX2lzV2ViR1BVU3VwcG9ydGVkO1xuICBfaXNXZWJHUFVTdXBwb3J0ZWQgPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGdwdSA9IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCkuZ3B1O1xuICAgIGlmICghZ3B1KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcihvcHRpb25zKTtcbiAgICAgIGF3YWl0IGFkYXB0ZXIucmVxdWVzdERldmljZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIF9pc1dlYkdQVVN1cHBvcnRlZDtcbn1cblxuZXhwb3J0IHsgaXNXZWJHUFVTdXBwb3J0ZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzV2ViR1BVU3VwcG9ydGVkLm1qcy5tYXBcbiIsImltcG9ydCB7IGF1dG9EZXRlY3RFbnZpcm9ubWVudCB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanMnO1xuaW1wb3J0IHsgaXNXZWJHTFN1cHBvcnRlZCB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXIvaXNXZWJHTFN1cHBvcnRlZC5tanMnO1xuaW1wb3J0IHsgaXNXZWJHUFVTdXBwb3J0ZWQgfSBmcm9tICcuLi8uLi91dGlscy9icm93c2VyL2lzV2ViR1BVU3VwcG9ydGVkLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdFJlbmRlcmVyIH0gZnJvbSAnLi9zaGFyZWQvc3lzdGVtL0Fic3RyYWN0UmVuZGVyZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCByZW5kZXJQcmlvcml0eSA9IFtcIndlYmdwdVwiLCBcIndlYmdsXCIsIFwiY2FudmFzXCJdO1xuYXN5bmMgZnVuY3Rpb24gYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgbGV0IHByZWZlcnJlZE9yZGVyID0gW107XG4gIGlmIChvcHRpb25zLnByZWZlcmVuY2UpIHtcbiAgICBwcmVmZXJyZWRPcmRlci5wdXNoKG9wdGlvbnMucHJlZmVyZW5jZSk7XG4gICAgcmVuZGVyUHJpb3JpdHkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0gIT09IG9wdGlvbnMucHJlZmVyZW5jZSkge1xuICAgICAgICBwcmVmZXJyZWRPcmRlci5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHByZWZlcnJlZE9yZGVyID0gcmVuZGVyUHJpb3JpdHkuc2xpY2UoKTtcbiAgfVxuICBsZXQgUmVuZGVyZXJDbGFzcztcbiAgYXdhaXQgYXV0b0RldGVjdEVudmlyb25tZW50KFxuICAgIG9wdGlvbnMubWFuYWdlSW1wb3J0cyA/PyB0cnVlXG4gICk7XG4gIGxldCBmaW5hbE9wdGlvbnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmZXJyZWRPcmRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IHByZWZlcnJlZE9yZGVyW2ldO1xuICAgIGlmIChyZW5kZXJlclR5cGUgPT09IFwid2ViZ3B1XCIgJiYgYXdhaXQgaXNXZWJHUFVTdXBwb3J0ZWQoKSkge1xuICAgICAgY29uc3QgeyBXZWJHUFVSZW5kZXJlciB9ID0gYXdhaXQgaW1wb3J0KCcuL2dwdS9XZWJHUFVSZW5kZXJlci5tanMnKTtcbiAgICAgIFJlbmRlcmVyQ2xhc3MgPSBXZWJHUFVSZW5kZXJlcjtcbiAgICAgIGZpbmFsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgLi4ub3B0aW9ucy53ZWJncHUgfTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyZXJUeXBlID09PSBcIndlYmdsXCIgJiYgaXNXZWJHTFN1cHBvcnRlZChcbiAgICAgIG9wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA/PyBBYnN0cmFjdFJlbmRlcmVyLmRlZmF1bHRPcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcbiAgICApKSB7XG4gICAgICBjb25zdCB7IFdlYkdMUmVuZGVyZXIgfSA9IGF3YWl0IGltcG9ydCgnLi9nbC9XZWJHTFJlbmRlcmVyLm1qcycpO1xuICAgICAgUmVuZGVyZXJDbGFzcyA9IFdlYkdMUmVuZGVyZXI7XG4gICAgICBmaW5hbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLm9wdGlvbnMud2ViZ2wgfTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyZXJUeXBlID09PSBcImNhbnZhc1wiKSB7XG4gICAgICBmaW5hbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBkZWxldGUgZmluYWxPcHRpb25zLndlYmdwdTtcbiAgZGVsZXRlIGZpbmFsT3B0aW9ucy53ZWJnbDtcbiAgY29uc3QgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJDbGFzcygpO1xuICBhd2FpdCByZW5kZXJlci5pbml0KGZpbmFsT3B0aW9ucyk7XG4gIHJldHVybiByZW5kZXJlcjtcbn1cblxuZXhwb3J0IHsgYXV0b0RldGVjdFJlbmRlcmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvRGV0ZWN0UmVuZGVyZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucywgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgYXV0b0RldGVjdFJlbmRlcmVyIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9Db250YWluZXIubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX0FwcGxpY2F0aW9uID0gY2xhc3MgX0FwcGxpY2F0aW9uIHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIC8qKiBUaGUgcm9vdCBkaXNwbGF5IGNvbnRhaW5lciB0aGF0J3MgcmVuZGVyZWQuICovXG4gICAgdGhpcy5zdGFnZSA9IG5ldyBDb250YWluZXIoKTtcbiAgICBpZiAoYXJnc1swXSAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQXBwbGljYXRpb24gY29uc3RydWN0b3Igb3B0aW9ucyBhcmUgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBBcHBsaWNhdGlvbi5pbml0KCkgaW5zdGVhZC5cIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25hbCBhcHBsaWNhdGlvbiBhbmQgcmVuZGVyZXIgcGFyYW1ldGVycy5cbiAgICovXG4gIGFzeW5jIGluaXQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLnJlbmRlcmVyID0gYXdhaXQgYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpO1xuICAgIF9BcHBsaWNhdGlvbi5fcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgIHBsdWdpbi5pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIFJlbmRlciB0aGUgY3VycmVudCBzdGFnZS4gKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHsgY29udGFpbmVyOiB0aGlzLnN0YWdlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyJ3MgY2FudmFzIGVsZW1lbnQuXG4gICAqIEByZWFkb25seVxuICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICovXG4gIGdldCBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyJ3MgY2FudmFzIGVsZW1lbnQuXG4gICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMFxuICAgKi9cbiAgZ2V0IHZpZXcoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkFwcGxpY2F0aW9uLnZpZXcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBBcHBsaWNhdGlvbi5jYW52YXMgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyJ3Mgc2NyZWVuIHJlY3RhbmdsZS4gSXRzIHNhZmUgdG8gdXNlIGFzIGBmaWx0ZXJBcmVhYCBvciBgaGl0QXJlYWAgZm9yIHRoZSB3aG9sZSBzY3JlZW4uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5zY3JlZW47XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBhcHBsaWNhdGlvbiBhbmQgYWxsIG9mIGl0cyByZXNvdXJjZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59W3JlbmRlcmVyRGVzdHJveU9wdGlvbnM9ZmFsc2VdIC0gVGhlIG9wdGlvbnMgZm9yIGRlc3Ryb3lpbmcgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59W3JlbmRlcmVyRGVzdHJveU9wdGlvbnMucmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zPWZhbHNlXSAtIFRoZSBvcHRpb25zIGZvciBkZXN0cm95aW5nIHRoZSBzdGFnZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveSBtZXRob2RcbiAgICogY2FsbGVkIGFzIHdlbGwuIGBvcHRpb25zYCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGRyZW4gd2l0aCB0ZXh0dXJlcyBlLmcuIFNwcml0ZXMuXG4gICAqIElmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWUsXG4gICAqIGl0IHNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkcmVuIHdpdGggdGV4dHVyZXMgZS5nLiBTcHJpdGVzLlxuICAgKiAgSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICogaXQgc2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgc291cmNlIG9mIHRoZSBjaGlsZCBzcHJpdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29udGV4dD1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkcmVuIHdpdGggZ3JhcGhpY3NDb250ZXh0cyBlLmcuIEdyYXBoaWNzLlxuICAgKiBJZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlLFxuICAgKiBpdCBzaG91bGQgZGVzdHJveSB0aGUgY29udGV4dCBvZiB0aGUgY2hpbGQgZ3JhcGhpY3MuXG4gICAqL1xuICBkZXN0cm95KHJlbmRlcmVyRGVzdHJveU9wdGlvbnMgPSBmYWxzZSwgb3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgY29uc3QgcGx1Z2lucyA9IF9BcHBsaWNhdGlvbi5fcGx1Z2lucy5zbGljZSgwKTtcbiAgICBwbHVnaW5zLnJldmVyc2UoKTtcbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YWdlLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgdGhpcy5zdGFnZSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KHJlbmRlcmVyRGVzdHJveU9wdGlvbnMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59O1xuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGluc3RhbGxlZCBwbHVnaW5zLlxuICogQGFsaWFzIF9wbHVnaW5zXG4gKi9cbl9BcHBsaWNhdGlvbi5fcGx1Z2lucyA9IFtdO1xubGV0IEFwcGxpY2F0aW9uID0gX0FwcGxpY2F0aW9uO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbiwgQXBwbGljYXRpb24uX3BsdWdpbnMpO1xuXG5leHBvcnQgeyBBcHBsaWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYWNrZ3JvdW5kTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBsb2FkZXJcbiAgICogQHBhcmFtIHZlcmJvc2UgLSBzaG91bGQgdGhlIGxvYWRlciBsb2cgdG8gdGhlIGNvbnNvbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdmVyYm9zZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMuX2Fzc2V0TGlzdCA9IFtdO1xuICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX21heENvbmN1cnJlbnQgPSAxO1xuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJyYXkgb2YgYXNzZXRzIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBhc3NldFVybHMgLSBhc3NldHMgdG8gbG9hZFxuICAgKi9cbiAgYWRkKGFzc2V0VXJscykge1xuICAgIGFzc2V0VXJscy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICB0aGlzLl9hc3NldExpc3QucHVzaChhKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltCYWNrZ3JvdW5kTG9hZGVyXSBhc3NldHM6IFwiLCB0aGlzLl9hc3NldExpc3QpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNBY3RpdmUgJiYgIXRoaXMuX2lzTG9hZGluZykge1xuICAgICAgdm9pZCB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgbmV4dCBzZXQgb2YgYXNzZXRzLiBXaWxsIHRyeSB0byBsb2FkIGFzIG1hbnkgYXNzZXRzIGFzIGl0IGNhbiBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKlxuICAgKiBUaGUgbWF4IGFzc2V0cyBpdCB3aWxsIHRyeSB0byBsb2FkIGF0IG9uZSB0aW1lIHdpbGwgYmUgNC5cbiAgICovXG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLl9hc3NldExpc3QubGVuZ3RoICYmIHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgdG9Mb2FkID0gW107XG4gICAgICBjb25zdCB0b0xvYWRBbW91bnQgPSBNYXRoLm1pbih0aGlzLl9hc3NldExpc3QubGVuZ3RoLCB0aGlzLl9tYXhDb25jdXJyZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Mb2FkQW1vdW50OyBpKyspIHtcbiAgICAgICAgdG9Mb2FkLnB1c2godGhpcy5fYXNzZXRMaXN0LnBvcCgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX2xvYWRlci5sb2FkKHRvTG9hZCk7XG4gICAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHZvaWQgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGUvRGVhY3RpdmF0ZSB0aGUgbG9hZGluZy4gSWYgc2V0IHRvIHRydWUgdGhlbiBpdCB3aWxsIGltbWVkaWF0ZWx5IGNvbnRpbnVlIHRvIGxvYWQgdGhlIG5leHQgYXNzZXQuXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGNsYXNzIGlzIGFjdGl2ZVxuICAgKi9cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNBY3RpdmU7XG4gIH1cbiAgc2V0IGFjdGl2ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNBY3RpdmUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgJiYgIXRoaXMuX2lzTG9hZGluZykge1xuICAgICAgdm9pZCB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhY2tncm91bmRMb2FkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNhY2hlVGV4dHVyZUFycmF5ID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIHRlc3Q6IChhc3NldCkgPT4gQXJyYXkuaXNBcnJheShhc3NldCkgJiYgYXNzZXQuZXZlcnkoKHQpID0+IHQgaW5zdGFuY2VvZiBUZXh0dXJlKSxcbiAgZ2V0Q2FjaGVhYmxlQXNzZXRzOiAoa2V5cywgYXNzZXQpID0+IHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgYXNzZXQuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBvdXRba2V5ICsgKGkgPT09IDAgPyBcIlwiIDogaSArIDEpXSA9IGl0ZW07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuXG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVUZXh0dXJlQXJyYXkubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5hc3luYyBmdW5jdGlvbiB0ZXN0SW1hZ2VGb3JtYXQoaW1hZ2VEYXRhKSB7XG4gIGlmIChcIkltYWdlXCIgaW4gZ2xvYmFsVGhpcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH07XG4gICAgICBpbWFnZS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH07XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZURhdGE7XG4gICAgfSk7XG4gIH1cbiAgaWYgKFwiY3JlYXRlSW1hZ2VCaXRtYXBcIiBpbiBnbG9iYWxUaGlzICYmIFwiZmV0Y2hcIiBpbiBnbG9iYWxUaGlzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCAoYXdhaXQgZmV0Y2goaW1hZ2VEYXRhKSkuYmxvYigpO1xuICAgICAgYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IHRlc3RJbWFnZUZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdEltYWdlRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHRlc3RJbWFnZUZvcm1hdCB9IGZyb20gJy4uL3V0aWxzL3Rlc3RJbWFnZUZvcm1hdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRldGVjdEF2aWYgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAxXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHRlc3RJbWFnZUZvcm1hdChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIFwiZGF0YTppbWFnZS9hdmlmO2Jhc2U2NCxBQUFBSUdaMGVYQmhkbWxtQUFBQUFHRjJhV1p0YVdZeGJXbGhaazFCTVVJQUFBRHliV1YwWVFBQUFBQUFBQUFvYUdSc2NnQUFBQUFBQUFBQWNHbGpkQUFBQUFBQUFBQUFBQUFBQUd4cFltRjJhV1lBQUFBQURuQnBkRzBBQUFBQUFBRUFBQUFlYVd4dll3QUFBQUJFQUFBQkFBRUFBQUFCQUFBQkdnQUFBQjBBQUFBb2FXbHVaZ0FBQUFBQUFRQUFBQnBwYm1abEFnQUFBQUFCQUFCaGRqQXhRMjlzYjNJQUFBQUFhbWx3Y25BQUFBQkxhWEJqYndBQUFCUnBjM0JsQUFBQUFBQUFBQUlBQUFBQ0FBQUFFSEJwZUdrQUFBQUFBd2dJQ0FBQUFBeGhkakZEZ1EwTUFBQUFBQk5qYjJ4eWJtTnNlQUFDQUFJQUFZQUFBQUFYYVhCdFlRQUFBQUFBQUFBQkFBRUVBUUtEQkFBQUFDVnRaR0YwRWdBS0NCZ0FOb2dRRUF3Z01nOGY4RC8vLzhXZmh3QjgrRXJLNDJBPVwiXG4gICksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCBcImF2aWZcIl0sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiBmICE9PSBcImF2aWZcIilcbn07XG5cbmV4cG9ydCB7IGRldGVjdEF2aWYgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdEF2aWYubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGltYWdlRm9ybWF0cyA9IFtcInBuZ1wiLCBcImpwZ1wiLCBcImpwZWdcIl07XG5jb25zdCBkZXRlY3REZWZhdWx0cyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IC0xXG4gIH0sXG4gIHRlc3Q6ICgpID0+IFByb21pc2UucmVzb2x2ZSh0cnVlKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIC4uLmltYWdlRm9ybWF0c10sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhaW1hZ2VGb3JtYXRzLmluY2x1ZGVzKGYpKVxufTtcblxuZXhwb3J0IHsgZGV0ZWN0RGVmYXVsdHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdERlZmF1bHRzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaW5Xb3JrZXIgPSBcIldvcmtlckdsb2JhbFNjb3BlXCIgaW4gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5Xb3JrZXJHbG9iYWxTY29wZTtcbmZ1bmN0aW9uIHRlc3RWaWRlb0Zvcm1hdChtaW1lVHlwZSkge1xuICBpZiAoaW5Xb3JrZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gIHJldHVybiB2aWRlby5jYW5QbGF5VHlwZShtaW1lVHlwZSkgIT09IFwiXCI7XG59XG5cbmV4cG9ydCB7IHRlc3RWaWRlb0Zvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdFZpZGVvRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHRlc3RWaWRlb0Zvcm1hdCB9IGZyb20gJy4uL3V0aWxzL3Rlc3RWaWRlb0Zvcm1hdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRldGVjdE1wNCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4gdGVzdFZpZGVvRm9ybWF0KFwidmlkZW8vbXA0XCIpLFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJtcDRcIiwgXCJtNHZcIl0sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiBmICE9PSBcIm1wNFwiICYmIGYgIT09IFwibTR2XCIpXG59O1xuXG5leHBvcnQgeyBkZXRlY3RNcDQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdE1wNC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB0ZXN0VmlkZW9Gb3JtYXQgfSBmcm9tICcuLi91dGlscy90ZXN0VmlkZW9Gb3JtYXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBkZXRlY3RPZ3YgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHRlc3RWaWRlb0Zvcm1hdChcInZpZGVvL29nZ1wiKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwib2d2XCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJvZ3ZcIilcbn07XG5cbmV4cG9ydCB7IGRldGVjdE9ndiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0T2d2Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHRlc3RWaWRlb0Zvcm1hdCB9IGZyb20gJy4uL3V0aWxzL3Rlc3RWaWRlb0Zvcm1hdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRldGVjdFdlYm0gPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHRlc3RWaWRlb0Zvcm1hdChcInZpZGVvL3dlYm1cIiksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCBcIndlYm1cIl0sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiBmICE9PSBcIndlYm1cIilcbn07XG5cbmV4cG9ydCB7IGRldGVjdFdlYm0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFdlYm0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgdGVzdEltYWdlRm9ybWF0IH0gZnJvbSAnLi4vdXRpbHMvdGVzdEltYWdlRm9ybWF0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZGV0ZWN0V2VicCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4gdGVzdEltYWdlRm9ybWF0KFxuICAgIFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QUFBQUFBZlEvLzczdi8rQmlPaC9BQUE9XCJcbiAgKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwid2VicFwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwid2VicFwiKVxufTtcblxuZXhwb3J0IHsgZGV0ZWN0V2VicCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0V2VicC5tanMubWFwXG4iLCJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnLi4vLi4vdXRpbHMvcGF0aC5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcbmltcG9ydCB7IGlzU2luZ2xlSXRlbSB9IGZyb20gJy4uL3V0aWxzL2lzU2luZ2xlSXRlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXTtcbiAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQWxsIGxvYWRlciBwYXJzZXJzIHJlZ2lzdGVyZWRcbiAgICAgKiBAdHlwZSB7YXNzZXRzLkxvYWRlclBhcnNlcltdfVxuICAgICAqL1xuICAgIHRoaXMucGFyc2VycyA9IG5ldyBQcm94eSh0aGlzLl9wYXJzZXJzLCB7XG4gICAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKiogQ2FjaGUgbG9hZGluZyBwcm9taXNlcyB0aGF0IGFlIGN1cnJlbnRseSBhY3RpdmUgKi9cbiAgICB0aGlzLnByb21pc2VDYWNoZSA9IHt9O1xuICB9XG4gIC8qKiBmdW5jdGlvbiB1c2VkIGZvciB0ZXN0aW5nICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByb21pc2VDYWNoZSA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGludGVybmFsbHkgdG8gZ2VuZXJhdGUgYSBwcm9taXNlIGZvciB0aGUgYXNzZXQgdG8gYmUgbG9hZGVkLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBiZSBsb2FkZWRcbiAgICogQHBhcmFtIGRhdGEgLSBhbnkgY3VzdG9tIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVsZXZhbnQgdG8gdGhlIGFzc2V0IGJlaW5nIGxvYWRlZFxuICAgKiBAcmV0dXJucyAtIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byBhbiBBc3NldCBmb3IgZXhhbXBsZSBhIFRleHR1cmUgb2YgYSBKU09OIG9iamVjdFxuICAgKi9cbiAgX2dldExvYWRQcm9taXNlQW5kUGFyc2VyKHVybCwgZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb21pc2U6IG51bGwsXG4gICAgICBwYXJzZXI6IG51bGxcbiAgICB9O1xuICAgIHJlc3VsdC5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhc3NldCA9IG51bGw7XG4gICAgICBsZXQgcGFyc2VyID0gbnVsbDtcbiAgICAgIGlmIChkYXRhLmxvYWRQYXJzZXIpIHtcbiAgICAgICAgcGFyc2VyID0gdGhpcy5fcGFyc2VySGFzaFtkYXRhLmxvYWRQYXJzZXJdO1xuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHdhcm4oYFtBc3NldHNdIHNwZWNpZmllZCBsb2FkIHBhcnNlciBcIiR7ZGF0YS5sb2FkUGFyc2VyfVwiIG5vdCBmb3VuZCB3aGlsZSBsb2FkaW5nICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlclggPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICAgICAgaWYgKHBhcnNlclgubG9hZCAmJiBwYXJzZXJYLnRlc3Q/Lih1cmwsIGRhdGEsIHRoaXMpKSB7XG4gICAgICAgICAgICBwYXJzZXIgPSBwYXJzZXJYO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgICAgd2FybihgW0Fzc2V0c10gJHt1cmx9IGNvdWxkIG5vdCBiZSBsb2FkZWQgYXMgd2UgZG9uJ3Qga25vdyBob3cgdG8gcGFyc2UgaXQsIGVuc3VyZSB0aGUgY29ycmVjdCBwYXJzZXIgaGFzIGJlZW4gYWRkZWRgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXNzZXQgPSBhd2FpdCBwYXJzZXIubG9hZCh1cmwsIGRhdGEsIHRoaXMpO1xuICAgICAgcmVzdWx0LnBhcnNlciA9IHBhcnNlcjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlcjIgPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICAgIGlmIChwYXJzZXIyLnBhcnNlKSB7XG4gICAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UgJiYgYXdhaXQgcGFyc2VyMi50ZXN0UGFyc2U/Lihhc3NldCwgZGF0YSwgdGhpcykpIHtcbiAgICAgICAgICAgIGFzc2V0ID0gYXdhaXQgcGFyc2VyMi5wYXJzZShhc3NldCwgZGF0YSwgdGhpcykgfHwgYXNzZXQ7XG4gICAgICAgICAgICByZXN1bHQucGFyc2VyID0gcGFyc2VyMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NldDtcbiAgICB9KSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbG9hZChhc3NldHNUb0xvYWRJbiwgb25Qcm9ncmVzcykge1xuICAgIGlmICghdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVQYXJzZXJzKCk7XG4gICAgfVxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgYXNzZXRzID0ge307XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oYXNzZXRzVG9Mb2FkSW4pO1xuICAgIGNvbnN0IGFzc2V0c1RvTG9hZCA9IGNvbnZlcnRUb0xpc3QoYXNzZXRzVG9Mb2FkSW4sIChpdGVtKSA9PiAoe1xuICAgICAgYWxpYXM6IFtpdGVtXSxcbiAgICAgIHNyYzogaXRlbVxuICAgIH0pKTtcbiAgICBjb25zdCB0b3RhbCA9IGFzc2V0c1RvTG9hZC5sZW5ndGg7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBhc3NldHNUb0xvYWQubWFwKGFzeW5jIChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gcGF0aC50b0Fic29sdXRlKGFzc2V0LnNyYyk7XG4gICAgICBpZiAoIWFzc2V0c1thc3NldC5zcmNdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnByb21pc2VDYWNoZVt1cmxdKSB7XG4gICAgICAgICAgICB0aGlzLnByb21pc2VDYWNoZVt1cmxdID0gdGhpcy5fZ2V0TG9hZFByb21pc2VBbmRQYXJzZXIodXJsLCBhc3NldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2V0c1thc3NldC5zcmNdID0gYXdhaXQgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXS5wcm9taXNlO1xuICAgICAgICAgIGlmIChvblByb2dyZXNzKVxuICAgICAgICAgICAgb25Qcm9ncmVzcygrK2NvdW50IC8gdG90YWwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucHJvbWlzZUNhY2hlW3VybF07XG4gICAgICAgICAgZGVsZXRlIGFzc2V0c1thc3NldC5zcmNdO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0xvYWRlci5sb2FkXSBGYWlsZWQgdG8gbG9hZCAke3VybH0uXG4ke2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gYXNzZXRzW2Fzc2V0c1RvTG9hZFswXS5zcmNdIDogYXNzZXRzO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvYWRzIG9uZSBvciBtb3JlIGFzc2V0cy4gQW55IHVubG9hZGVkIGFzc2V0cyB3aWxsIGJlIGRlc3Ryb3llZCwgZnJlZWluZyB1cCBtZW1vcnkgZm9yIHlvdXIgYXBwLlxuICAgKiBUaGUgcGFyc2VyIHRoYXQgY3JlYXRlZCB0aGUgYXNzZXQsIHdpbGwgYmUgdGhlIG9uZSB0aGF0IHVubG9hZHMgaXQuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNpbmdsZSBhc3NldDpcbiAgICogY29uc3QgYXNzZXQgPSBhd2FpdCBMb2FkZXIubG9hZCgnY29vbC5wbmcnKTtcbiAgICpcbiAgICogYXdhaXQgTG9hZGVyLnVubG9hZCgnY29vbC5wbmcnKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coYXNzZXQuZGVzdHJveWVkKTsgLy8gdHJ1ZVxuICAgKiBAcGFyYW0gYXNzZXRzVG9VbmxvYWRJbiAtIHVybHMgdGhhdCB5b3Ugd2FudCB0byB1bmxvYWQsIG9yIGEgc2luZ2xlIG9uZSFcbiAgICovXG4gIGFzeW5jIHVubG9hZChhc3NldHNUb1VubG9hZEluKSB7XG4gICAgY29uc3QgYXNzZXRzVG9VbmxvYWQgPSBjb252ZXJ0VG9MaXN0KGFzc2V0c1RvVW5sb2FkSW4sIChpdGVtKSA9PiAoe1xuICAgICAgYWxpYXM6IFtpdGVtXSxcbiAgICAgIHNyYzogaXRlbVxuICAgIH0pKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGFzc2V0c1RvVW5sb2FkLm1hcChhc3luYyAoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHBhdGgudG9BYnNvbHV0ZShhc3NldC5zcmMpO1xuICAgICAgY29uc3QgbG9hZFByb21pc2UgPSB0aGlzLnByb21pc2VDYWNoZVt1cmxdO1xuICAgICAgaWYgKGxvYWRQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IGxvYWRlZEFzc2V0ID0gYXdhaXQgbG9hZFByb21pc2UucHJvbWlzZTtcbiAgICAgICAgZGVsZXRlIHRoaXMucHJvbWlzZUNhY2hlW3VybF07XG4gICAgICAgIGxvYWRQcm9taXNlLnBhcnNlcj8udW5sb2FkPy4obG9hZGVkQXNzZXQsIGFzc2V0LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cbiAgLyoqIHZhbGlkYXRlcyBvdXIgcGFyc2VycywgcmlnaHQgbm93IGl0IG9ubHkgY2hlY2tzIGZvciBuYW1lIGNvbmZsaWN0cyBidXQgd2UgY2FuIGFkZCBtb3JlIGhlcmUgYXMgcmVxdWlyZWQhICovXG4gIF92YWxpZGF0ZVBhcnNlcnMoKSB7XG4gICAgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5fcGFyc2VySGFzaCA9IHRoaXMuX3BhcnNlcnMuZmlsdGVyKChwYXJzZXIpID0+IHBhcnNlci5uYW1lKS5yZWR1Y2UoKGhhc2gsIHBhcnNlcikgPT4ge1xuICAgICAgaWYgKCFwYXJzZXIubmFtZSkge1xuICAgICAgICB3YXJuKGBbQXNzZXRzXSBsb2FkUGFyc2VyIHNob3VsZCBoYXZlIGEgbmFtZWApO1xuICAgICAgfSBlbHNlIGlmIChoYXNoW3BhcnNlci5uYW1lXSkge1xuICAgICAgICB3YXJuKGBbQXNzZXRzXSBsb2FkUGFyc2VyIG5hbWUgY29uZmxpY3QgXCIke3BhcnNlci5uYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5oYXNoLCBbcGFyc2VyLm5hbWVdOiBwYXJzZXIgfTtcbiAgICB9LCB7fSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTG9hZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2FkZXIubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjaGVja0RhdGFVcmwodXJsLCBtaW1lcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtaW1lcykpIHtcbiAgICBmb3IgKGNvbnN0IG1pbWUgb2YgbWltZXMpIHtcbiAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChgZGF0YToke21pbWV9YCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKGBkYXRhOiR7bWltZXN9YCk7XG59XG5cbmV4cG9ydCB7IGNoZWNrRGF0YVVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tEYXRhVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IHBhdGggfSBmcm9tICcuLi8uLi91dGlscy9wYXRoLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY2hlY2tFeHRlbnNpb24odXJsLCBleHRlbnNpb24pIHtcbiAgY29uc3QgdGVtcFVSTCA9IHVybC5zcGxpdChcIj9cIilbMF07XG4gIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZSh0ZW1wVVJMKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoQXJyYXkuaXNBcnJheShleHRlbnNpb24pKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5pbmNsdWRlcyhleHQpO1xuICB9XG4gIHJldHVybiBleHQgPT09IGV4dGVuc2lvbjtcbn1cblxuZXhwb3J0IHsgY2hlY2tFeHRlbnNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrRXh0ZW5zaW9uLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzJztcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9Mb2FkZXJQYXJzZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB2YWxpZEpTT05FeHRlbnNpb24gPSBcIi5qc29uXCI7XG5jb25zdCB2YWxpZEpTT05NSU1FID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5jb25zdCBsb2FkSnNvbiA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Mb3dcbiAgfSxcbiAgbmFtZTogXCJsb2FkSnNvblwiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZEpTT05NSU1FKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkSlNPTkV4dGVuc2lvbik7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBET01BZGFwdGVyLmdldCgpLmZldGNoKHVybCk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufTtcblxuZXhwb3J0IHsgbG9hZEpzb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRKc29uLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuLi8uLi91dGlscy9jaGVja0RhdGFVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24ubWpzJztcbmltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9Mb2FkZXJQYXJzZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB2YWxpZFRYVEV4dGVuc2lvbiA9IFwiLnR4dFwiO1xuY29uc3QgdmFsaWRUWFRNSU1FID0gXCJ0ZXh0L3BsYWluXCI7XG5jb25zdCBsb2FkVHh0ID0ge1xuICBuYW1lOiBcImxvYWRUeHRcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Mb3dcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRUWFRNSU1FKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkVFhURXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IERPTUFkYXB0ZXIuZ2V0KCkuZmV0Y2godXJsKTtcbiAgICBjb25zdCB0eHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgcmV0dXJuIHR4dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgbG9hZFR4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFR4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgcGF0aCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3BhdGgubWpzJztcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vY2FjaGUvQ2FjaGUubWpzJztcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gJy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanMnO1xuaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuL0xvYWRlclBhcnNlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHZhbGlkV2VpZ2h0cyA9IFtcbiAgXCJub3JtYWxcIixcbiAgXCJib2xkXCIsXG4gIFwiMTAwXCIsXG4gIFwiMjAwXCIsXG4gIFwiMzAwXCIsXG4gIFwiNDAwXCIsXG4gIFwiNTAwXCIsXG4gIFwiNjAwXCIsXG4gIFwiNzAwXCIsXG4gIFwiODAwXCIsXG4gIFwiOTAwXCJcbl07XG5jb25zdCB2YWxpZEZvbnRFeHRlbnNpb25zID0gW1wiLnR0ZlwiLCBcIi5vdGZcIiwgXCIud29mZlwiLCBcIi53b2ZmMlwiXTtcbmNvbnN0IHZhbGlkRm9udE1JTUVzID0gW1xuICBcImZvbnQvdHRmXCIsXG4gIFwiZm9udC9vdGZcIixcbiAgXCJmb250L3dvZmZcIixcbiAgXCJmb250L3dvZmYyXCJcbl07XG5jb25zdCBDU1NfSURFTlRfVE9LRU5fUkVHRVggPSAvXigtLXwtP1tBLVpfXSlbMC05QS1aXy1dKiQvaTtcbmZ1bmN0aW9uIGdldEZvbnRGYW1pbHlOYW1lKHVybCkge1xuICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUodXJsKTtcbiAgY29uc3QgbmFtZSA9IHBhdGguYmFzZW5hbWUodXJsLCBleHQpO1xuICBjb25zdCBuYW1lV2l0aFNwYWNlcyA9IG5hbWUucmVwbGFjZSgvKC18XykvZywgXCIgXCIpO1xuICBjb25zdCBuYW1lVG9rZW5zID0gbmFtZVdpdGhTcGFjZXMudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIikubWFwKCh3b3JkKSA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gIGxldCB2YWxpZCA9IG5hbWVUb2tlbnMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBuYW1lVG9rZW5zKSB7XG4gICAgaWYgKCF0b2tlbi5tYXRjaChDU1NfSURFTlRfVE9LRU5fUkVHRVgpKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxldCBmb250RmFtaWx5TmFtZSA9IG5hbWVUb2tlbnMuam9pbihcIiBcIik7XG4gIGlmICghdmFsaWQpIHtcbiAgICBmb250RmFtaWx5TmFtZSA9IGBcIiR7Zm9udEZhbWlseU5hbWUucmVwbGFjZSgvW1xcXFxcIl0vZywgXCJcXFxcJCZcIil9XCJgO1xuICB9XG4gIHJldHVybiBmb250RmFtaWx5TmFtZTtcbn1cbmNvbnN0IHZhbGlkVVJJQ2hhcmFjdGVyc1JlZ2V4ID0gL15bMC05QS1aYS16JTovPyNcXFtcXF1AIVxcJCYnKClcXCpcXCssOz1cXC0uX35dKiQvO1xuZnVuY3Rpb24gZW5jb2RlVVJJV2hlbk5lZWRlZCh1cmkpIHtcbiAgaWYgKHZhbGlkVVJJQ2hhcmFjdGVyc1JlZ2V4LnRlc3QodXJpKSkge1xuICAgIHJldHVybiB1cmk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZVVSSSh1cmkpO1xufVxuY29uc3QgbG9hZFdlYkZvbnQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuTG93XG4gIH0sXG4gIG5hbWU6IFwibG9hZFdlYkZvbnRcIixcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRGb250TUlNRXMpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRGb250RXh0ZW5zaW9ucyk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9udHMgPSBET01BZGFwdGVyLmdldCgpLmdldEZvbnRGYWNlU2V0KCk7XG4gICAgaWYgKGZvbnRzKSB7XG4gICAgICBjb25zdCBmb250RmFjZXMgPSBbXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLmRhdGE/LmZhbWlseSA/PyBnZXRGb250RmFtaWx5TmFtZSh1cmwpO1xuICAgICAgY29uc3Qgd2VpZ2h0cyA9IG9wdGlvbnMuZGF0YT8ud2VpZ2h0cz8uZmlsdGVyKCh3ZWlnaHQpID0+IHZhbGlkV2VpZ2h0cy5pbmNsdWRlcyh3ZWlnaHQpKSA/PyBbXCJub3JtYWxcIl07XG4gICAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhID8/IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IHdlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2UobmFtZSwgYHVybCgke2VuY29kZVVSSVdoZW5OZWVkZWQodXJsKX0pYCwge1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgd2VpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBmb250LmxvYWQoKTtcbiAgICAgICAgZm9udHMuYWRkKGZvbnQpO1xuICAgICAgICBmb250RmFjZXMucHVzaChmb250KTtcbiAgICAgIH1cbiAgICAgIENhY2hlLnNldChuYW1lLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgZm9udEZhY2VzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmb250RmFjZXMubGVuZ3RoID09PSAxID8gZm9udEZhY2VzWzBdIDogZm9udEZhY2VzO1xuICAgIH1cbiAgICB3YXJuKFwiW2xvYWRXZWJGb250XSBGb250RmFjZSBBUEkgaXMgbm90IHN1cHBvcnRlZC4gU2tpcHBpbmcgbG9hZGluZyBmb250XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICB1bmxvYWQoZm9udCkge1xuICAgIChBcnJheS5pc0FycmF5KGZvbnQpID8gZm9udCA6IFtmb250XSkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgQ2FjaGUucmVtb3ZlKHQuZmFtaWx5KTtcbiAgICAgIERPTUFkYXB0ZXIuZ2V0KCkuZ2V0Rm9udEZhY2VTZXQoKS5kZWxldGUodCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGdldEZvbnRGYW1pbHlOYW1lLCBsb2FkV2ViRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFdlYkZvbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVzb2x2ZXIgfSBmcm9tICcuLi8uLi9hc3NldHMvcmVzb2x2ZXIvUmVzb2x2ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRSZXNvbHV0aW9uT2ZVcmwodXJsLCBkZWZhdWx0VmFsdWUgPSAxKSB7XG4gIGNvbnN0IHJlc29sdXRpb24gPSBSZXNvbHZlci5SRVRJTkFfUFJFRklYPy5leGVjKHVybCk7XG4gIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuZXhwb3J0IHsgZ2V0UmVzb2x1dGlvbk9mVXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRSZXNvbHV0aW9uT2ZVcmwubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuLi8uLi8uLi8uLi9jYWNoZS9DYWNoZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoc291cmNlLCBsb2FkZXIsIHVybCkge1xuICBzb3VyY2UubGFiZWwgPSB1cmw7XG4gIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh7XG4gICAgc291cmNlLFxuICAgIGxhYmVsOiB1cmxcbiAgfSk7XG4gIGNvbnN0IHVubG9hZCA9ICgpID0+IHtcbiAgICBkZWxldGUgbG9hZGVyLnByb21pc2VDYWNoZVt1cmxdO1xuICAgIGlmIChDYWNoZS5oYXModXJsKSkge1xuICAgICAgQ2FjaGUucmVtb3ZlKHVybCk7XG4gICAgfVxuICB9O1xuICB0ZXh0dXJlLm9uY2UoXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICBpZiAodXJsIGluIGxvYWRlci5wcm9taXNlQ2FjaGUpIHtcbiAgICAgIHdhcm4oXCJbQXNzZXRzXSBBIFRleHR1cmUgbWFuYWdlZCBieSBBc3NldHMgd2FzIGRlc3Ryb3llZCBpbnN0ZWFkIG9mIHVubG9hZGVkISBVc2UgQXNzZXRzLnVubG9hZCgpIGluc3RlYWQgb2YgZGVzdHJveWluZyB0aGUgVGV4dHVyZS5cIik7XG4gICAgICB1bmxvYWQoKTtcbiAgICB9XG4gIH0pO1xuICB0ZXh0dXJlLnNvdXJjZS5vbmNlKFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgaWYgKCFzb3VyY2UuZGVzdHJveWVkKSB7XG4gICAgICB3YXJuKFwiW0Fzc2V0c10gQSBUZXh0dXJlIG1hbmFnZWQgYnkgQXNzZXRzIHdhcyBkZXN0cm95ZWQgaW5zdGVhZCBvZiB1bmxvYWRlZCEgVXNlIEFzc2V0cy51bmxvYWQoKSBpbnN0ZWFkIG9mIGRlc3Ryb3lpbmcgdGhlIFRleHR1cmUuXCIpO1xuICAgICAgdW5sb2FkKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0NvbnRleHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBnZXRSZXNvbHV0aW9uT2ZVcmwgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9uZXR3b3JrL2dldFJlc29sdXRpb25PZlVybC5tanMnO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uL0xvYWRlclBhcnNlci5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHZhbGlkU1ZHRXh0ZW5zaW9uID0gXCIuc3ZnXCI7XG5jb25zdCB2YWxpZFNWR01JTUUgPSBcImltYWdlL3N2Zyt4bWxcIjtcbmNvbnN0IGxvYWRTdmcgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuTG93XG4gIH0sXG4gIG5hbWU6IFwibG9hZFNWR1wiLFxuICBjb25maWc6IHtcbiAgICBjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIixcbiAgICBwYXJzZUFzR3JhcGhpY3NDb250ZXh0OiBmYWxzZVxuICB9LFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZFNWR01JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRTVkdFeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgYXNzZXQsIGxvYWRlcikge1xuICAgIGlmIChhc3NldC5kYXRhLnBhcnNlQXNHcmFwaGljc0NvbnRleHQgPz8gdGhpcy5jb25maWcucGFyc2VBc0dyYXBoaWNzQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGxvYWRBc0dyYXBoaWNzKHVybCk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkQXNUZXh0dXJlKHVybCwgYXNzZXQsIGxvYWRlciwgdGhpcy5jb25maWcuY3Jvc3NPcmlnaW4pO1xuICB9LFxuICB1bmxvYWQoYXNzZXQpIHtcbiAgICBhc3NldC5kZXN0cm95KHRydWUpO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gbG9hZEFzVGV4dHVyZSh1cmwsIGFzc2V0LCBsb2FkZXIsIGNyb3NzT3JpZ2luKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICBjb25zdCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgaW1hZ2Uuc3JjID0gYmxvYlVybDtcbiAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgYXdhaXQgaW1hZ2UuZGVjb2RlKCk7XG4gIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjb25zdCByZXNvbHV0aW9uID0gYXNzZXQuZGF0YT8ucmVzb2x1dGlvbiB8fCBnZXRSZXNvbHV0aW9uT2ZVcmwodXJsKTtcbiAgY29uc3Qgd2lkdGggPSBhc3NldC5kYXRhPy53aWR0aCA/PyBpbWFnZS53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gYXNzZXQuZGF0YT8uaGVpZ2h0ID8/IGltYWdlLmhlaWdodDtcbiAgY2FudmFzLndpZHRoID0gd2lkdGggKiByZXNvbHV0aW9uO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoICogcmVzb2x1dGlvbiwgaGVpZ2h0ICogcmVzb2x1dGlvbik7XG4gIGNvbnN0IHsgcGFyc2VBc0dyYXBoaWNzQ29udGV4dDogX3AsIC4uLnJlc3QgfSA9IGFzc2V0LmRhdGE7XG4gIGNvbnN0IGJhc2UgPSBuZXcgSW1hZ2VTb3VyY2Uoe1xuICAgIHJlc291cmNlOiBjYW52YXMsXG4gICAgYWxwaGFNb2RlOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiLFxuICAgIHJlc29sdXRpb24sXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEFzR3JhcGhpY3ModXJsKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICBjb25zdCBzdmdTb3VyY2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgR3JhcGhpY3NDb250ZXh0KCk7XG4gIGNvbnRleHQuc3ZnKHN2Z1NvdXJjZSk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgeyBsb2FkU3ZnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkU1ZHLm1qcy5tYXBcbiIsImNvbnN0IFdPUktFUl9DT0RFID0gXCIoZnVuY3Rpb24gKCkge1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIGNvbnN0IFdISVRFX1BORyA9IFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVFBQUFDMUhBd0NBQUFBQzBsRVFWUjQybVA4L3g4QUF3TUNBTytpcDFzQUFBQUFTVVZPUks1Q1lJST1cXFwiO1xcbiAgICBhc3luYyBmdW5jdGlvbiBjaGVja0ltYWdlQml0bWFwKCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSBcXFwiZnVuY3Rpb25cXFwiKVxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFdISVRFX1BORyk7XFxuICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XFxuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XFxuICAgICAgICByZXR1cm4gaW1hZ2VCaXRtYXAud2lkdGggPT09IDEgJiYgaW1hZ2VCaXRtYXAuaGVpZ2h0ID09PSAxO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdm9pZCBjaGVja0ltYWdlQml0bWFwKCkudGhlbigocmVzdWx0KSA9PiB7XFxuICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQpO1xcbiAgICB9KTtcXG5cXG59KSgpO1xcblwiO1xubGV0IFdPUktFUl9VUkwgPSBudWxsO1xuY2xhc3MgV29ya2VySW5zdGFuY2VcbntcbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBpZiAoIVdPUktFUl9VUkwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIFdPUktFUl9VUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtXT1JLRVJfQ09ERV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoV09SS0VSX1VSTCk7XG4gICAgfVxufVxuV29ya2VySW5zdGFuY2UucmV2b2tlT2JqZWN0VVJMID0gZnVuY3Rpb24gcmV2b2tlT2JqZWN0VVJMKClcbntcbiAgICBpZiAoV09SS0VSX1VSTClcbiAgICB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoV09SS0VSX1VSTCk7XG4gICAgICAgIFdPUktFUl9VUkwgPSBudWxsO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFdvcmtlckluc3RhbmNlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrSW1hZ2VCaXRtYXAud29ya2VyLm1qcy5tYXBcbiIsImNvbnN0IFdPUktFUl9DT0RFID0gXCIoZnVuY3Rpb24gKCkge1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUJpdG1hcCh1cmwpIHtcXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbV29ya2VyTWFuYWdlci5sb2FkSW1hZ2VCaXRtYXBdIEZhaWxlZCB0byBmZXRjaCAke3VybH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcXG4gICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XFxuICAgICAgcmV0dXJuIGltYWdlQml0bWFwO1xcbiAgICB9XFxuICAgIHNlbGYub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgbG9hZEltYWdlQml0bWFwKGV2ZW50LmRhdGEuZGF0YVswXSk7XFxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcXG4gICAgICAgICAgZGF0YTogaW1hZ2VCaXRtYXAsXFxuICAgICAgICAgIHV1aWQ6IGV2ZW50LmRhdGEudXVpZCxcXG4gICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWRcXG4gICAgICAgIH0sIFtpbWFnZUJpdG1hcF0pO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xcbiAgICAgICAgICBlcnJvcjogZSxcXG4gICAgICAgICAgdXVpZDogZXZlbnQuZGF0YS51dWlkLFxcbiAgICAgICAgICBpZDogZXZlbnQuZGF0YS5pZFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbn0pKCk7XFxuXCI7XG5sZXQgV09SS0VSX1VSTCA9IG51bGw7XG5jbGFzcyBXb3JrZXJJbnN0YW5jZVxue1xuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIGlmICghV09SS0VSX1VSTClcbiAgICAgICAge1xuICAgICAgICAgICAgV09SS0VSX1VSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW1dPUktFUl9DT0RFXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcihXT1JLRVJfVVJMKTtcbiAgICB9XG59XG5Xb3JrZXJJbnN0YW5jZS5yZXZva2VPYmplY3RVUkwgPSBmdW5jdGlvbiByZXZva2VPYmplY3RVUkwoKVxue1xuICAgIGlmIChXT1JLRVJfVVJMKVxuICAgIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChXT1JLRVJfVVJMKTtcbiAgICAgICAgV09SS0VSX1VSTCA9IG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgV29ya2VySW5zdGFuY2UgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEltYWdlQml0bWFwLndvcmtlci5tanMubWFwXG4iLCJpbXBvcnQgV29ya2VySW5zdGFuY2UgZnJvbSAnLi4vLi4vLi4vX3ZpcnR1YWwvY2hlY2tJbWFnZUJpdG1hcC53b3JrZXIubWpzJztcbmltcG9ydCBXb3JrZXJJbnN0YW5jZSQxIGZyb20gJy4uLy4uLy4uL192aXJ0dWFsL2xvYWRJbWFnZUJpdG1hcC53b3JrZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgVVVJRCA9IDA7XG5sZXQgTUFYX1dPUktFUlM7XG5jbGFzcyBXb3JrZXJNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NyZWF0ZWRXb3JrZXJzID0gMDtcbiAgICB0aGlzLl93b3JrZXJQb29sID0gW107XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9yZXNvbHZlSGFzaCA9IHt9O1xuICB9XG4gIGlzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkO1xuICAgIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgeyB3b3JrZXIgfSA9IG5ldyBXb3JrZXJJbnN0YW5jZSgpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIFdvcmtlckluc3RhbmNlLnJldm9rZU9iamVjdFVSTCgpO1xuICAgICAgICByZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQ7XG4gIH1cbiAgbG9hZEltYWdlQml0bWFwKHNyYykge1xuICAgIHJldHVybiB0aGlzLl9ydW4oXCJsb2FkSW1hZ2VCaXRtYXBcIiwgW3NyY10pO1xuICB9XG4gIGFzeW5jIF9pbml0V29ya2VycygpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIF9nZXRXb3JrZXIoKSB7XG4gICAgaWYgKE1BWF9XT1JLRVJTID09PSB2b2lkIDApIHtcbiAgICAgIE1BWF9XT1JLRVJTID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgNDtcbiAgICB9XG4gICAgbGV0IHdvcmtlciA9IHRoaXMuX3dvcmtlclBvb2wucG9wKCk7XG4gICAgaWYgKCF3b3JrZXIgJiYgdGhpcy5fY3JlYXRlZFdvcmtlcnMgPCBNQVhfV09SS0VSUykge1xuICAgICAgdGhpcy5fY3JlYXRlZFdvcmtlcnMrKztcbiAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXJJbnN0YW5jZSQxKCkud29ya2VyO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZShldmVudC5kYXRhKTtcbiAgICAgICAgdGhpcy5fcmV0dXJuV29ya2VyKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG4gIF9yZXR1cm5Xb3JrZXIod29ya2VyKSB7XG4gICAgdGhpcy5fd29ya2VyUG9vbC5wdXNoKHdvcmtlcik7XG4gIH1cbiAgX2NvbXBsZXRlKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlSGFzaFtkYXRhLnV1aWRdLnJlamVjdChkYXRhLmVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUhhc2hbZGF0YS51dWlkXS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3Jlc29sdmVIYXNoW2RhdGEudXVpZF0gPSBudWxsO1xuICB9XG4gIGFzeW5jIF9ydW4oaWQsIGFyZ3MpIHtcbiAgICBhd2FpdCB0aGlzLl9pbml0V29ya2VycygpO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgaWQsIGFyZ3VtZW50czogYXJncywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX25leHQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBfbmV4dCgpIHtcbiAgICBpZiAoIXRoaXMuX3F1ZXVlLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLl9nZXRXb3JrZXIoKTtcbiAgICBpZiAoIXdvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b0RvID0gdGhpcy5fcXVldWUucG9wKCk7XG4gICAgY29uc3QgaWQgPSB0b0RvLmlkO1xuICAgIHRoaXMuX3Jlc29sdmVIYXNoW1VVSURdID0geyByZXNvbHZlOiB0b0RvLnJlc29sdmUsIHJlamVjdDogdG9Eby5yZWplY3QgfTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgZGF0YTogdG9Eby5hcmd1bWVudHMsXG4gICAgICB1dWlkOiBVVUlEKyssXG4gICAgICBpZFxuICAgIH0pO1xuICB9XG59XG5jb25zdCBXb3JrZXJNYW5hZ2VyID0gbmV3IFdvcmtlck1hbmFnZXJDbGFzcygpO1xuXG5leHBvcnQgeyBXb3JrZXJNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Xb3JrZXJNYW5hZ2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBJbWFnZVNvdXJjZSB9IGZyb20gJy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9JbWFnZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgZ2V0UmVzb2x1dGlvbk9mVXJsIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanMnO1xuaW1wb3J0IHsgV29ya2VyTWFuYWdlciB9IGZyb20gJy4uLy4uL3dvcmtlcnMvV29ya2VyTWFuYWdlci5tanMnO1xuaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuLi9Mb2FkZXJQYXJzZXIubWpzJztcbmltcG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB2YWxpZEltYWdlRXh0ZW5zaW9ucyA9IFtcIi5qcGVnXCIsIFwiLmpwZ1wiLCBcIi5wbmdcIiwgXCIud2VicFwiLCBcIi5hdmlmXCJdO1xuY29uc3QgdmFsaWRJbWFnZU1JTUVzID0gW1xuICBcImltYWdlL2pwZWdcIixcbiAgXCJpbWFnZS9wbmdcIixcbiAgXCJpbWFnZS93ZWJwXCIsXG4gIFwiaW1hZ2UvYXZpZlwiXG5dO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEltYWdlQml0bWFwKHVybCkge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IERPTUFkYXB0ZXIuZ2V0KCkuZmV0Y2godXJsKTtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgW2xvYWRJbWFnZUJpdG1hcF0gRmFpbGVkIHRvIGZldGNoICR7dXJsfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgfVxuICBjb25zdCBpbWFnZUJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iKTtcbiAgcmV0dXJuIGltYWdlQml0bWFwO1xufVxuY29uc3QgbG9hZFRleHR1cmVzID0ge1xuICBuYW1lOiBcImxvYWRUZXh0dXJlc1wiLFxuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgY29uZmlnOiB7XG4gICAgcHJlZmVyV29ya2VyczogdHJ1ZSxcbiAgICBwcmVmZXJDcmVhdGVJbWFnZUJpdG1hcDogdHJ1ZSxcbiAgICBjcm9zc09yaWdpbjogXCJhbm9ueW1vdXNcIlxuICB9LFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZEltYWdlTUlNRXMpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRJbWFnZUV4dGVuc2lvbnMpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgYXNzZXQsIGxvYWRlcikge1xuICAgIGxldCBzcmMgPSBudWxsO1xuICAgIGlmIChnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwICYmIHRoaXMuY29uZmlnLnByZWZlckNyZWF0ZUltYWdlQml0bWFwKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcucHJlZmVyV29ya2VycyAmJiBhd2FpdCBXb3JrZXJNYW5hZ2VyLmlzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQoKSkge1xuICAgICAgICBzcmMgPSBhd2FpdCBXb3JrZXJNYW5hZ2VyLmxvYWRJbWFnZUJpdG1hcCh1cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjID0gYXdhaXQgbG9hZEltYWdlQml0bWFwKHVybCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNyYyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBzcmMuY3Jvc3NPcmlnaW4gPSB0aGlzLmNvbmZpZy5jcm9zc09yaWdpbjtcbiAgICAgICAgc3JjLnNyYyA9IHVybDtcbiAgICAgICAgaWYgKHNyYy5jb21wbGV0ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcmMub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShzcmMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBiYXNlID0gbmV3IEltYWdlU291cmNlKHtcbiAgICAgIHJlc291cmNlOiBzcmMsXG4gICAgICBhbHBoYU1vZGU6IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCIsXG4gICAgICByZXNvbHV0aW9uOiBhc3NldC5kYXRhPy5yZXNvbHV0aW9uIHx8IGdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgLi4uYXNzZXQuZGF0YVxuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGxvYWRJbWFnZUJpdG1hcCwgbG9hZFRleHR1cmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkVGV4dHVyZXMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVmlkZW9Tb3VyY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvVmlkZW9Tb3VyY2UubWpzJztcbmltcG9ydCB7IGRldGVjdFZpZGVvQWxwaGFNb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvYnJvd3Nlci9kZXRlY3RWaWRlb0FscGhhTW9kZS5tanMnO1xuaW1wb3J0IHsgZ2V0UmVzb2x1dGlvbk9mVXJsIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzJztcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHZhbGlkVmlkZW9FeHRlbnNpb25zID0gW1wiLm1wNFwiLCBcIi5tNHZcIiwgXCIud2VibVwiLCBcIi5vZ2dcIiwgXCIub2d2XCIsIFwiLmgyNjRcIiwgXCIuYXZpXCIsIFwiLm1vdlwiXTtcbmNvbnN0IHZhbGlkVmlkZW9NSU1FcyA9IHZhbGlkVmlkZW9FeHRlbnNpb25zLm1hcCgoZXh0KSA9PiBgdmlkZW8vJHtleHQuc3Vic3RyaW5nKDEpfWApO1xuZnVuY3Rpb24gY3Jvc3NPcmlnaW4oZWxlbWVudCwgdXJsLCBjcm9zc29yaWdpbikge1xuICBpZiAoY3Jvc3NvcmlnaW4gPT09IHZvaWQgMCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSBkZXRlcm1pbmVDcm9zc09yaWdpbih1cmwpO1xuICB9IGVsc2UgaWYgKGNyb3Nzb3JpZ2luICE9PSBmYWxzZSkge1xuICAgIGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0eXBlb2YgY3Jvc3NvcmlnaW4gPT09IFwic3RyaW5nXCIgPyBjcm9zc29yaWdpbiA6IFwiYW5vbnltb3VzXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWxvYWRWaWRlbyhlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgbG9hZGVkKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgZWxlbWVudC5sb2FkKCk7XG4gICAgZnVuY3Rpb24gbG9hZGVkKCkge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgbG9hZGVkKTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsLCBsb2MgPSBnbG9iYWxUaGlzLmxvY2F0aW9uKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgbG9jID0gbG9jIHx8IGdsb2JhbFRoaXMubG9jYXRpb247XG4gIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsLCBkb2N1bWVudC5iYXNlVVJJKTtcbiAgaWYgKHBhcnNlZFVybC5ob3N0bmFtZSAhPT0gbG9jLmhvc3RuYW1lIHx8IHBhcnNlZFVybC5wb3J0ICE9PSBsb2MucG9ydCB8fCBwYXJzZWRVcmwucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuY29uc3QgbG9hZFZpZGVvVGV4dHVyZXMgPSB7XG4gIG5hbWU6IFwibG9hZFZpZGVvXCIsXG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlclxuICB9LFxuICBjb25maWc6IG51bGwsXG4gIHRlc3QodXJsKSB7XG4gICAgY29uc3QgaXNWYWxpZERhdGFVcmwgPSBjaGVja0RhdGFVcmwodXJsLCB2YWxpZFZpZGVvTUlNRXMpO1xuICAgIGNvbnN0IGlzVmFsaWRFeHRlbnNpb24gPSBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkVmlkZW9FeHRlbnNpb25zKTtcbiAgICByZXR1cm4gaXNWYWxpZERhdGFVcmwgfHwgaXNWYWxpZEV4dGVuc2lvbjtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIGFzc2V0LCBsb2FkZXIpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uVmlkZW9Tb3VyY2UuZGVmYXVsdE9wdGlvbnMsXG4gICAgICByZXNvbHV0aW9uOiBhc3NldC5kYXRhPy5yZXNvbHV0aW9uIHx8IGdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgYWxwaGFNb2RlOiBhc3NldC5kYXRhPy5hbHBoYU1vZGUgfHwgYXdhaXQgZGV0ZWN0VmlkZW9BbHBoYU1vZGUoKSxcbiAgICAgIC4uLmFzc2V0LmRhdGFcbiAgICB9O1xuICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYXAgPSB7XG4gICAgICBwcmVsb2FkOiBvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSA/IFwiYXV0b1wiIDogdm9pZCAwLFxuICAgICAgXCJ3ZWJraXQtcGxheXNpbmxpbmVcIjogb3B0aW9ucy5wbGF5c2lubGluZSAhPT0gZmFsc2UgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgcGxheXNpbmxpbmU6IG9wdGlvbnMucGxheXNpbmxpbmUgIT09IGZhbHNlID8gXCJcIiA6IHZvaWQgMCxcbiAgICAgIG11dGVkOiBvcHRpb25zLm11dGVkID09PSB0cnVlID8gXCJcIiA6IHZvaWQgMCxcbiAgICAgIGxvb3A6IG9wdGlvbnMubG9vcCA9PT0gdHJ1ZSA/IFwiXCIgOiB2b2lkIDAsXG4gICAgICBhdXRvcGxheTogb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2UgPyBcIlwiIDogdm9pZCAwXG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVNYXBba2V5XTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKVxuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLm11dGVkID09PSB0cnVlKSB7XG4gICAgICB2aWRlb0VsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjcm9zc09yaWdpbih2aWRlb0VsZW1lbnQsIHVybCwgb3B0aW9ucy5jcm9zc29yaWdpbik7XG4gICAgY29uc3Qgc291cmNlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7XG4gICAgbGV0IG1pbWU7XG4gICAgaWYgKHVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgIG1pbWUgPSB1cmwuc2xpY2UoNSwgdXJsLmluZGV4T2YoXCI7XCIpKTtcbiAgICB9IGVsc2UgaWYgKCF1cmwuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICBjb25zdCBleHQgPSB1cmwuc3BsaXQoXCI/XCIpWzBdLnNsaWNlKHVybC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbWltZSA9IFZpZGVvU291cmNlLk1JTUVfVFlQRVNbZXh0XSB8fCBgdmlkZW8vJHtleHR9YDtcbiAgICB9XG4gICAgc291cmNlRWxlbWVudC5zcmMgPSB1cmw7XG4gICAgaWYgKG1pbWUpIHtcbiAgICAgIHNvdXJjZUVsZW1lbnQudHlwZSA9IG1pbWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgb25DYW5QbGF5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlID0gbmV3IFZpZGVvU291cmNlKHsgLi4ub3B0aW9ucywgcmVzb3VyY2U6IHZpZGVvRWxlbWVudCB9KTtcbiAgICAgICAgdmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uQ2FuUGxheSk7XG4gICAgICAgIGlmIChhc3NldC5kYXRhLnByZWxvYWQpIHtcbiAgICAgICAgICBhd2FpdCBwcmVsb2FkVmlkZW8odmlkZW9FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpKTtcbiAgICAgIH07XG4gICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5KTtcbiAgICAgIHZpZGVvRWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2VFbGVtZW50KTtcbiAgICB9KTtcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNyb3NzT3JpZ2luLCBkZXRlcm1pbmVDcm9zc09yaWdpbiwgbG9hZFZpZGVvVGV4dHVyZXMsIHByZWxvYWRWaWRlbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFZpZGVvVGV4dHVyZXMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgbG9hZFRleHR1cmVzIH0gZnJvbSAnLi4vLi4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcyc7XG5pbXBvcnQgeyBSZXNvbHZlciB9IGZyb20gJy4uL1Jlc29sdmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcmVzb2x2ZVRleHR1cmVVcmwgPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICB0ZXN0OiBsb2FkVGV4dHVyZXMudGVzdCxcbiAgcGFyc2U6ICh2YWx1ZSkgPT4gKHtcbiAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KFJlc29sdmVyLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyBcIjFcIiksXG4gICAgZm9ybWF0OiB2YWx1ZS5zcGxpdChcIi5cIikucG9wKCksXG4gICAgc3JjOiB2YWx1ZVxuICB9KVxufTtcblxuZXhwb3J0IHsgcmVzb2x2ZVRleHR1cmVVcmwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVUZXh0dXJlVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFJlc29sdmVyIH0gZnJvbSAnLi4vUmVzb2x2ZXIubWpzJztcbmltcG9ydCB7IHJlc29sdmVUZXh0dXJlVXJsIH0gZnJvbSAnLi9yZXNvbHZlVGV4dHVyZVVybC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHJlc29sdmVKc29uVXJsID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlcixcbiAgdGVzdDogKHZhbHVlKSA9PiBSZXNvbHZlci5SRVRJTkFfUFJFRklYLnRlc3QodmFsdWUpICYmIHZhbHVlLmVuZHNXaXRoKFwiLmpzb25cIiksXG4gIHBhcnNlOiByZXNvbHZlVGV4dHVyZVVybC5wYXJzZVxufTtcblxuZXhwb3J0IHsgcmVzb2x2ZUpzb25VcmwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVKc29uVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfSBmcm9tICcuL0JhY2tncm91bmRMb2FkZXIubWpzJztcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgY2FjaGVUZXh0dXJlQXJyYXkgfSBmcm9tICcuL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkubWpzJztcbmltcG9ydCB7IGRldGVjdEF2aWYgfSBmcm9tICcuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLm1qcyc7XG5pbXBvcnQgeyBkZXRlY3REZWZhdWx0cyB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLm1qcyc7XG5pbXBvcnQgeyBkZXRlY3RNcDQgfSBmcm9tICcuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RNcDQubWpzJztcbmltcG9ydCB7IGRldGVjdE9ndiB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdE9ndi5tanMnO1xuaW1wb3J0IHsgZGV0ZWN0V2VibSB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYm0ubWpzJztcbmltcG9ydCB7IGRldGVjdFdlYnAgfSBmcm9tICcuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL2xvYWRlci9Mb2FkZXIubWpzJztcbmltcG9ydCB7IGxvYWRKc29uIH0gZnJvbSAnLi9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5tanMnO1xuaW1wb3J0IHsgbG9hZFR4dCB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvbG9hZFR4dC5tanMnO1xuaW1wb3J0IHsgbG9hZFdlYkZvbnQgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL2xvYWRXZWJGb250Lm1qcyc7XG5pbXBvcnQgeyBsb2FkU3ZnIH0gZnJvbSAnLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkU1ZHLm1qcyc7XG5pbXBvcnQgeyBsb2FkVGV4dHVyZXMgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgbG9hZFZpZGVvVGV4dHVyZXMgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRWaWRlb1RleHR1cmVzLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlSnNvblVybCB9IGZyb20gJy4vcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlSnNvblVybC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVRleHR1cmVVcmwgfSBmcm9tICcuL3Jlc29sdmVyL3BhcnNlcnMvcmVzb2x2ZVRleHR1cmVVcmwubWpzJztcbmltcG9ydCB7IFJlc29sdmVyIH0gZnJvbSAnLi9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBc3NldHNDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2RldGVjdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMucmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIoKTtcbiAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXIoKTtcbiAgICB0aGlzLmNhY2hlID0gQ2FjaGU7XG4gICAgdGhpcy5fYmFja2dyb3VuZExvYWRlciA9IG5ldyBCYWNrZ3JvdW5kTG9hZGVyKHRoaXMubG9hZGVyKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBCZXN0IHByYWN0aWNlIGlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgYW55IGxvYWRpbmcgY29tbWVuY2VzXG4gICAqIEluaXRpYXRpbmcgaXMgdGhlIGJlc3QgdGltZSB0byBhZGQgYW55IGN1c3RvbWl6YXRpb24gdG8gdGhlIHdheSB0aGluZ3MgYXJlIGxvYWRlZC5cbiAgICpcbiAgICogeW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBmb3IgdGhlIEFzc2V0cyBjbGFzcyB0byB3b3JrLCBvbmx5IGlmIHlvdSB3YW50IHRvIHNldCBhbnkgaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBBc3NldHMgbWFuYWdlciB3aXRoXG4gICAqL1xuICBhc3luYyBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgd2FybihcIltBc3NldHNdQXNzZXRNYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGl6ZWQsIGRpZCB5b3UgbG9hZCBiZWZvcmUgY2FsbGluZyB0aGlzIEFzc2V0cy5pbml0KCk/XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgICAgdGhpcy5yZXNvbHZlci5zZXREZWZhdWx0U2VhcmNoUGFyYW1zKG9wdGlvbnMuZGVmYXVsdFNlYXJjaFBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJhc2VQYXRoKSB7XG4gICAgICB0aGlzLnJlc29sdmVyLmJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYnVuZGxlSWRlbnRpZmllcikge1xuICAgICAgdGhpcy5yZXNvbHZlci5zZXRCdW5kbGVJZGVudGlmaWVyKG9wdGlvbnMuYnVuZGxlSWRlbnRpZmllcik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1hbmlmZXN0KSB7XG4gICAgICBsZXQgbWFuaWZlc3QgPSBvcHRpb25zLm1hbmlmZXN0O1xuICAgICAgaWYgKHR5cGVvZiBtYW5pZmVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtYW5pZmVzdCA9IGF3YWl0IHRoaXMubG9hZChtYW5pZmVzdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc29sdmVyLmFkZE1hbmlmZXN0KG1hbmlmZXN0KTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvblByZWYgPSBvcHRpb25zLnRleHR1cmVQcmVmZXJlbmNlPy5yZXNvbHV0aW9uID8/IDE7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHR5cGVvZiByZXNvbHV0aW9uUHJlZiA9PT0gXCJudW1iZXJcIiA/IFtyZXNvbHV0aW9uUHJlZl0gOiByZXNvbHV0aW9uUHJlZjtcbiAgICBjb25zdCBmb3JtYXRzID0gYXdhaXQgdGhpcy5fZGV0ZWN0Rm9ybWF0cyh7XG4gICAgICBwcmVmZXJyZWRGb3JtYXRzOiBvcHRpb25zLnRleHR1cmVQcmVmZXJlbmNlPy5mb3JtYXQsXG4gICAgICBza2lwRGV0ZWN0aW9uczogb3B0aW9ucy5za2lwRGV0ZWN0aW9ucyxcbiAgICAgIGRldGVjdGlvbnM6IHRoaXMuX2RldGVjdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnJlc29sdmVyLnByZWZlcih7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRzLFxuICAgICAgICByZXNvbHV0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMucHJlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuc2V0UHJlZmVyZW5jZXMob3B0aW9ucy5wcmVmZXJlbmNlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIHNwZWNpZnkgaG93IHRvIHJlc29sdmUgYW55IGFzc2V0cyBsb2FkIHJlcXVlc3RzLlxuICAgKiBUaGVyZSBhcmUgYSBmZXcgd2F5cyB0byBhZGQgdGhpbmdzIGhlcmUgYXMgc2hvd24gYmVsb3c6XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiAvLyBTaW1wbGVcbiAgICogQXNzZXRzLmFkZCh7YWxpYXM6ICdidW5ueUJvb0JvbycsIHNyYzogJ2J1bm55LnBuZyd9KTtcbiAgICogY29uc3QgYnVubnkgPSBhd2FpdCBBc3NldHMubG9hZCgnYnVubnlCb29Cb28nKTtcbiAgICpcbiAgICogLy8gTXVsdGlwbGUga2V5czpcbiAgICogQXNzZXRzLmFkZCh7YWxpYXM6IFsnYnVyZ2VyJywgJ2NoaWNrZW4nXSwgc3JjOiAnYnVubnkucG5nJ30pO1xuICAgKlxuICAgKiBjb25zdCBidW5ueSA9IGF3YWl0IEFzc2V0cy5sb2FkKCdidXJnZXInKTtcbiAgICogY29uc3QgYnVubnkyID0gYXdhaXQgQXNzZXRzLmxvYWQoJ2NoaWNrZW4nKTtcbiAgICpcbiAgICogLy8gcGFzc2luZyBvcHRpb25zIHRvIHRvIHRoZSBvYmplY3RcbiAgICogQXNzZXRzLmFkZCh7XG4gICAqICAgICBhbGlhczogJ2J1bm55Qm9vQm9vU21vb3RoJyxcbiAgICogICAgIHNyYzogJ2J1bm55e3BuZyx3ZWJwfScsXG4gICAqICAgICBkYXRhOiB7IHNjYWxlTW9kZTogU0NBTEVfTU9ERVMuTkVBUkVTVCB9LCAvLyBCYXNlIHRleHR1cmUgb3B0aW9uc1xuICAgKiB9KTtcbiAgICpcbiAgICogLy8gTXVsdGlwbGUgYXNzZXRzXG4gICAqXG4gICAqIC8vIFRoZSBmb2xsb3dpbmcgYWxsIGRvIHRoZSBzYW1lIHRoaW5nOlxuICAgKlxuICAgKiBBc3NldHMuYWRkKHthbGlhczogJ2J1bm55Qm9vQm9vJywgc3JjOiAnYnVubnl7cG5nLHdlYnB9J30pO1xuICAgKlxuICAgKiBBc3NldHMuYWRkKHtcbiAgICogICAgIGFsaWFzOiAnYnVubnlCb29Cb28nLFxuICAgKiAgICAgc3JjOiBbXG4gICAqICAgICAgICAgJ2J1bm55LnBuZycsXG4gICAqICAgICAgICAgJ2J1bm55LndlYnAnLFxuICAgKiAgICBdLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgYnVubnkgPSBhd2FpdCBBc3NldHMubG9hZCgnYnVubnlCb29Cb28nKTsgLy8gV2lsbCB0cnkgdG8gbG9hZCBXZWJQIGlmIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gYXNzZXRzIC0gdGhlIHVucmVzb2x2ZWQgYXNzZXRzIHRvIGFkZCB0byB0aGUgcmVzb2x2ZXJcbiAgICovXG4gIGFkZChhc3NldHMpIHtcbiAgICB0aGlzLnJlc29sdmVyLmFkZChhc3NldHMpO1xuICB9XG4gIGFzeW5jIGxvYWQodXJscywgb25Qcm9ncmVzcykge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbSh1cmxzKTtcbiAgICBjb25zdCB1cmxBcnJheSA9IGNvbnZlcnRUb0xpc3QodXJscykubWFwKCh1cmwpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSB0aGlzLnJlc29sdmVyLmdldEFsaWFzKHVybCk7XG4gICAgICAgIGlmIChhbGlhc2VzLnNvbWUoKGFsaWFzKSA9PiAhdGhpcy5yZXNvbHZlci5oYXNLZXkoYWxpYXMpKSkge1xuICAgICAgICAgIHRoaXMuYWRkKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYWxpYXNlcykgPyBhbGlhc2VzWzBdIDogYWxpYXNlcztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZXNvbHZlci5oYXNLZXkodXJsKSlcbiAgICAgICAgdGhpcy5hZGQoeyBhbGlhczogdXJsLCBzcmM6IHVybCB9KTtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmUodXJsQXJyYXkpO1xuICAgIGNvbnN0IG91dCA9IGF3YWl0IHRoaXMuX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFt1cmxBcnJheVswXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgYWRkcyBhIGJ1bmRsZSBvZiBhc3NldHMgaW4gb25lIGdvIHNvIHRoYXQgeW91IGNhbiBsb2FkIHRoZW0gYXMgYSBncm91cC5cbiAgICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIGFkZCBhIGJ1bmRsZSBmb3IgZWFjaCBzY3JlZW4gaW4geW91IHBpeGkgYXBwXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYWRkQnVuZGxlKCdhbmltYWxzJywgW1xuICAgKiAgeyBhbGlhczogJ2J1bm55Jywgc3JjOiAnYnVubnkucG5nJyB9LFxuICAgKiAgeyBhbGlhczogJ2NoaWNrZW4nLCBzcmM6ICdjaGlja2VuLnBuZycgfSxcbiAgICogIHsgYWxpYXM6ICd0aHVtcGVyJywgc3JjOiAndGh1bXBlci5wbmcnIH0sXG4gICAqIF0pO1xuICAgKiAvLyBvclxuICAgKiBBc3NldHMuYWRkQnVuZGxlKCdhbmltYWxzJywge1xuICAgKiAgICAgYnVubnk6ICdidW5ueS5wbmcnLFxuICAgKiAgICAgY2hpY2tlbjogJ2NoaWNrZW4ucG5nJyxcbiAgICogICAgIHRodW1wZXI6ICd0aHVtcGVyLnBuZycsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBhc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnYW5pbWFscycpO1xuICAgKiBAcGFyYW0gYnVuZGxlSWQgLSB0aGUgaWQgb2YgdGhlIGJ1bmRsZSB0byBhZGRcbiAgICogQHBhcmFtIGFzc2V0cyAtIGEgcmVjb3JkIG9mIHRoZSBhc3NldCBvciBhc3NldHMgdGhhdCB3aWxsIGJlIGNob3NlbiBmcm9tIHdoZW4gbG9hZGluZyB2aWEgdGhlIHNwZWNpZmllZCBrZXlcbiAgICovXG4gIGFkZEJ1bmRsZShidW5kbGVJZCwgYXNzZXRzKSB7XG4gICAgdGhpcy5yZXNvbHZlci5hZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEJ1bmRsZXMgYXJlIGEgd2F5IHRvIGxvYWQgbXVsdGlwbGUgYXNzZXRzIGF0IG9uY2UuXG4gICAqIElmIGEgbWFuaWZlc3QgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIGluaXQgZnVuY3Rpb24gdGhlbiB5b3UgY2FuIGxvYWQgYSBidW5kbGUsIG9yIGJ1bmRsZXMuXG4gICAqIHlvdSBjYW4gYWxzbyBhZGQgYnVuZGxlcyB2aWEgYGFkZEJ1bmRsZWBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIE1hbmlmZXN0IEV4YW1wbGVcbiAgICogY29uc3QgbWFuaWZlc3QgPSB7XG4gICAqICAgICBidW5kbGVzOiBbXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnbG9hZC1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhY2tncm91bmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ3N1bnNldC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnbG9hZC1iYXIue3BuZyx3ZWJwfScsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnZ2FtZS1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2NoYXJhY3RlcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAncm9ib3QucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdlbmVteScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnYmFkLWd1eS5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgXVxuICAgKiB9O1xuICAgKlxuICAgKiBhd2FpdCBBc3NldHMuaW5pdCh7IG1hbmlmZXN0IH0pO1xuICAgKlxuICAgKiAvLyBMb2FkIGEgYnVuZGxlLi4uXG4gICAqIGxvYWRTY3JlZW5Bc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnbG9hZC1zY3JlZW4nKTtcbiAgICogLy8gTG9hZCBhbm90aGVyIGJ1bmRsZS4uLlxuICAgKiBnYW1lU2NyZWVuQXNzZXRzID0gYXdhaXQgQXNzZXRzLmxvYWRCdW5kbGUoJ2dhbWUtc2NyZWVuJyk7XG4gICAqIEBwYXJhbSBidW5kbGVJZHMgLSB0aGUgYnVuZGxlIGlkIG9yIGlkcyB0byBsb2FkXG4gICAqIEBwYXJhbSBvblByb2dyZXNzIC0gT3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBwcm9ncmVzcyBvbiBhc3NldCBsb2FkaW5nIGlzIG1hZGUuXG4gICAqIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgYSBzaW5nbGUgcGFyYW1ldGVyLCBgcHJvZ3Jlc3NgLCB3aGljaCByZXByZXNlbnRzIHRoZSBwZXJjZW50YWdlICgwLjAgLSAxLjApXG4gICAqIG9mIHRoZSBhc3NldHMgbG9hZGVkLiBEbyBub3QgdXNlIHRoaXMgZnVuY3Rpb24gdG8gZGV0ZWN0IHdoZW4gYXNzZXRzIGFyZSBjb21wbGV0ZSBhbmQgYXZhaWxhYmxlLFxuICAgKiBpbnN0ZWFkIHVzZSB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyBhbGwgdGhlIGJ1bmRsZXMgYXNzZXRzIG9yIGEgaGFzaCBvZiBhc3NldHMgZm9yIGVhY2ggYnVuZGxlIHNwZWNpZmllZFxuICAgKi9cbiAgYXN5bmMgbG9hZEJ1bmRsZShidW5kbGVJZHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgbGV0IHNpbmdsZUFzc2V0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBidW5kbGVJZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNpbmdsZUFzc2V0ID0gdHJ1ZTtcbiAgICAgIGJ1bmRsZUlkcyA9IFtidW5kbGVJZHNdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpO1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cyk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGNvbnN0IF9vblByb2dyZXNzID0gKCkgPT4ge1xuICAgICAgb25Qcm9ncmVzcz8uKCsrY291bnQgLyB0b3RhbCk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKChidW5kbGVJZCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXTtcbiAgICAgIHRvdGFsICs9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHQpLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLl9tYXBMb2FkVG9SZXNvbHZlKHJlc29sdmVSZXN1bHQsIF9vblByb2dyZXNzKS50aGVuKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgICBvdXRbYnVuZGxlSWRdID0gcmVzb2x2ZVJlc3VsdDI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gb3V0W2J1bmRsZUlkc1swXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgYmFja2dyb3VuZCBsb2FkIG9mIHNvbWUgYXNzZXRzLiBJdCB3aWxsIHBhc3NpdmVseSBiZWdpbiB0byBsb2FkIHRoZXNlIGFzc2V0cyBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogU28gd2hlbiB5b3UgYWN0dWFsbHkgY29tZSB0byBsb2FkaW5nIHRoZW0geW91IHdpbGwgZ2V0IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgYXNzZXRzIGltbWVkaWF0ZWx5XG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSB0aGF0IHlvdSB3b3VsZCBiYWNrZ3JvdW5kIGxvYWQgZ2FtZSBhc3NldHMgYWZ0ZXIgeW91ciBpbml0YWwgbG9hZC5cbiAgICogdGhlbiB3aGVuIHlvdSBnb3QgdG8gYWN0dWFsbHkgbG9hZCB5b3VyIGdhbWUgc2NyZWVuIGFzc2V0cyB3aGVuIGEgcGxheWVyIGdvZXMgdG8gdGhlIGdhbWUgLSB0aGUgbG9hZGluZ1xuICAgKiB3b3VsZCBhbHJlYWR5IGhhdmUgc3RhcmVkIG9yIG1heSBldmVuIGJlIGNvbXBsZXRlLCBzYXZpbmcgeW91IGhhdmluZyB0byBzaG93IGFuIGludGVyaW0gbG9hZCBiYXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYmFja2dyb3VuZExvYWQoJ2J1bm55LnBuZycpO1xuICAgKlxuICAgKiAvLyBsYXRlciBvbiBpbiB5b3VyIGFwcC4uLlxuICAgKiBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnYnVubnkucG5nJyk7IC8vIFdpbGwgcmVzb2x2ZSBxdWlja2VyIGFzIGxvYWRpbmcgbWF5IGhhdmUgY29tcGxldGVkIVxuICAgKiBAcGFyYW0gdXJscyAtIHRoZSB1cmwgLyB1cmxzIHlvdSB3YW50IHRvIGJhY2tncm91bmQgbG9hZFxuICAgKi9cbiAgYXN5bmMgYmFja2dyb3VuZExvYWQodXJscykge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVybHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHVybHMgPSBbdXJsc107XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybHMpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWRkKE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdHMpKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgYSBiYWNrZ3JvdW5kIG9mIGEgYnVuZGxlLCB3b3JrcyBleGFjdGx5IGxpa2UgYmFja2dyb3VuZExvYWQgYnV0IGZvciBidW5kbGVzLlxuICAgKiB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgaWYgdGhlIGxvYWRlciBoYXMgYmVlbiBpbml0aWF0ZWQgd2l0aCBhIG1hbmlmZXN0XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBhd2FpdCBBc3NldHMuaW5pdCh7XG4gICAqICAgICBtYW5pZmVzdDoge1xuICAgKiAgICAgICAgIGJ1bmRsZXM6IFtcbiAgICogICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgbmFtZTogJ2xvYWQtc2NyZWVuJyxcbiAgICogICAgICAgICAgICAgICAgIGFzc2V0czogWy4uLl0sXG4gICAqICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgIF0sXG4gICAqICAgICB9LFxuICAgKiB9KTtcbiAgICpcbiAgICogQXNzZXRzLmJhY2tncm91bmRMb2FkQnVuZGxlKCdsb2FkLXNjcmVlbicpO1xuICAgKlxuICAgKiAvLyBMYXRlciBvbiBpbiB5b3VyIGFwcC4uLlxuICAgKiBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnbG9hZC1zY3JlZW4nKTsgLy8gV2lsbCByZXNvbHZlIHF1aWNrZXIgYXMgbG9hZGluZyBtYXkgaGF2ZSBjb21wbGV0ZWQhXG4gICAqIEBwYXJhbSBidW5kbGVJZHMgLSB0aGUgYnVuZGxlSWQgLyBidW5kbGVJZHMgeW91IHdhbnQgdG8gYmFja2dyb3VuZCBsb2FkXG4gICAqL1xuICBhc3luYyBiYWNrZ3JvdW5kTG9hZEJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBidW5kbGVJZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ1bmRsZUlkcyA9IFtidW5kbGVJZHNdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpO1xuICAgIE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdHMpLmZvckVhY2goKHJlc29sdmVSZXN1bHQpID0+IHtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWRkKE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPbmx5IGludGVuZGVkIGZvciBkZXZlbG9wbWVudCBwdXJwb3Nlcy5cbiAgICogVGhpcyB3aWxsIHdpcGUgdGhlIHJlc29sdmVyIGFuZCBjYWNoZXMuXG4gICAqIFlvdSB3aWxsIG5lZWQgdG8gcmVpbml0aWFsaXplIHRoZSBBc3NldFxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5yZXNvbHZlci5yZXNldCgpO1xuICAgIHRoaXMubG9hZGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jYWNoZS5yZXNldCgpO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0KGtleXMpIHtcbiAgICBpZiAodHlwZW9mIGtleXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBDYWNoZS5nZXQoa2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IGFzc2V0cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXNzZXRzW2ldID0gQ2FjaGUuZ2V0KGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNzZXRzO1xuICB9XG4gIC8qKlxuICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gbWFwIHJlc29sdmVkIGFzc2V0cyBiYWNrIHRvIGxvYWRlZCBhc3NldHNcbiAgICogQHBhcmFtIHJlc29sdmVSZXN1bHRzIC0gdGhlIHJlc29sdmUgcmVzdWx0cyBmcm9tIHRoZSByZXNvbHZlclxuICAgKiBAcGFyYW0gb25Qcm9ncmVzcyAtIHRoZSBwcm9ncmVzcyBjYWxsYmFja1xuICAgKi9cbiAgYXN5bmMgX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBbLi4ubmV3IFNldChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKSldO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gZmFsc2U7XG4gICAgY29uc3QgbG9hZGVkQXNzZXRzID0gYXdhaXQgdGhpcy5sb2FkZXIubG9hZChyZXNvbHZlQXJyYXksIG9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICByZXNvbHZlQXJyYXkuZm9yRWFjaCgocmVzb2x2ZVJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgYXNzZXQgPSBsb2FkZWRBc3NldHNbcmVzb2x2ZVJlc3VsdC5zcmNdO1xuICAgICAgY29uc3Qga2V5cyA9IFtyZXNvbHZlUmVzdWx0LnNyY107XG4gICAgICBpZiAocmVzb2x2ZVJlc3VsdC5hbGlhcykge1xuICAgICAgICBrZXlzLnB1c2goLi4ucmVzb2x2ZVJlc3VsdC5hbGlhcyk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBvdXRba2V5XSA9IGFzc2V0O1xuICAgICAgfSk7XG4gICAgICBDYWNoZS5zZXQoa2V5cywgYXNzZXQpO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFVubG9hZCBhbiBhc3NldCBvciBhc3NldHMuIEFzIHRoZSBBc3NldHMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBhc3NldHMgdmlhIHRoZSBgbG9hZGAgZnVuY3Rpb25cbiAgICogdGhpcyB3aWxsIG1ha2Ugc3VyZSB0byBkZXN0cm95IGFueSBhc3NldHMgYW5kIHJlbGVhc2UgdGhlbSBmcm9tIG1lbW9yeS5cbiAgICogT25jZSB1bmxvYWRlZCwgeW91IHdpbGwgbmVlZCB0byBsb2FkIHRoZSBhc3NldCBhZ2Fpbi5cbiAgICpcbiAgICogVXNlIHRoaXMgdG8gaGVscCBtYW5hZ2UgYXNzZXRzIGlmIHlvdSBmaW5kIHRoYXQgeW91IGhhdmUgYSBsYXJnZSBhcHAgYW5kIHlvdSB3YW50IHRvIGZyZWUgdXAgbWVtb3J5LlxuICAgKlxuICAgKiAtIGl0J3MgdXAgdG8geW91IGFzIHRoZSBkZXZlbG9wZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGV4dHVyZXMgYXJlIG5vdCBhY3RpdmVseSBiZWluZyB1c2VkIHdoZW4geW91IHVubG9hZCB0aGVtLFxuICAgKiBQaXhpIHdvbid0IGJyZWFrIGJ1dCB5b3Ugd2lsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIGFzc2V0cy4gTm90IGEgZ29vZCBsb29rIGZvciB0aGUgdXNlciFcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIExvYWQgYSBVUkw6XG4gICAqIGNvbnN0IG15SW1hZ2VUZXh0dXJlID0gYXdhaXQgQXNzZXRzLmxvYWQoJ2h0dHA6Ly9zb21lLnVybC5jb20vaW1hZ2UucG5nJyk7IC8vID0+IHJldHVybnMgYSB0ZXh0dXJlXG4gICAqXG4gICAqIGF3YWl0IEFzc2V0cy51bmxvYWQoJ2h0dHA6Ly9zb21lLnVybC5jb20vaW1hZ2UucG5nJylcbiAgICpcbiAgICogLy8gbXlJbWFnZVRleHR1cmUgd2lsbCBiZSBkZXN0cm95ZWQgbm93LlxuICAgKlxuICAgKiAvLyBVbmxvYWQgbXVsdGlwbGUgYXNzZXRzOlxuICAgKiBjb25zdCB0ZXh0dXJlcyA9IGF3YWl0IEFzc2V0cy51bmxvYWQoWyd0aHVtcGVyJywgJ2NoaWNrbyddKTtcbiAgICogQHBhcmFtIHVybHMgLSB0aGUgdXJscyB0byB1bmxvYWRcbiAgICovXG4gIGFzeW5jIHVubG9hZCh1cmxzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4gdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiA/IHVybC5zcmMgOiB1cmwpO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybEFycmF5KTtcbiAgICBhd2FpdCB0aGlzLl91bmxvYWRGcm9tUmVzb2x2ZWQocmVzb2x2ZVJlc3VsdHMpO1xuICB9XG4gIC8qKlxuICAgKiBCdW5kbGVzIGFyZSBhIHdheSB0byBtYW5hZ2UgbXVsdGlwbGUgYXNzZXRzIGF0IG9uY2UuXG4gICAqIHRoaXMgd2lsbCB1bmxvYWQgYWxsIGZpbGVzIGluIGEgYnVuZGxlLlxuICAgKlxuICAgKiBvbmNlIGEgYnVuZGxlIGhhcyBiZWVuIHVubG9hZGVkLCB5b3UgbmVlZCB0byBsb2FkIGl0IGFnYWluIHRvIGhhdmUgYWNjZXNzIHRvIHRoZSBhc3NldHMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYWRkQnVuZGxlKHtcbiAgICogICAgICd0aHVtcGVyJzogJ2h0dHA6Ly9zb21lLnVybC5jb20vdGh1bXBlci5wbmcnLFxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zdCBhc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgndGh1bXBlcicpO1xuICAgKlxuICAgKiAvLyBOb3cgdG8gdW5sb2FkLi4uXG4gICAqXG4gICAqIGF3YWl0IEFzc2V0cy51bmxvYWRCdW5kbGUoJ3RodW1wZXInKTtcbiAgICpcbiAgICogLy8gQWxsIGFzc2V0cyBpbiB0aGUgYXNzZXRzIG9iamVjdCB3aWxsIG5vdyBoYXZlIGJlZW4gZGVzdHJveWVkIGFuZCBwdXJnZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIGJ1bmRsZUlkcyAtIHRoZSBidW5kbGUgaWQgb3IgaWRzIHRvIHVubG9hZFxuICAgKi9cbiAgYXN5bmMgdW5sb2FkQnVuZGxlKGJ1bmRsZUlkcykge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0KGJ1bmRsZUlkcyk7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHRzKS5tYXAoKGJ1bmRsZUlkKSA9PiB0aGlzLl91bmxvYWRGcm9tUmVzb2x2ZWQocmVzb2x2ZVJlc3VsdHNbYnVuZGxlSWRdKSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIGFzeW5jIF91bmxvYWRGcm9tUmVzb2x2ZWQocmVzb2x2ZVJlc3VsdCkge1xuICAgIGNvbnN0IHJlc29sdmVBcnJheSA9IE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdCk7XG4gICAgcmVzb2x2ZUFycmF5LmZvckVhY2goKHJlc29sdmVSZXN1bHQyKSA9PiB7XG4gICAgICBDYWNoZS5yZW1vdmUocmVzb2x2ZVJlc3VsdDIuc3JjKTtcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmxvYWRlci51bmxvYWQocmVzb2x2ZUFycmF5KTtcbiAgfVxuICAvKipcbiAgICogRGV0ZWN0cyB0aGUgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIHRoZSBicm93c2VyLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBzdXBwb3J0ZWQgZm9ybWF0cywgcmVzcGVjdGluZ1xuICAgKiB0aGUgdXNlcnMgcHJlZmVycmVkIGZvcm1hdHMgb3JkZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gZGV0ZWN0aW5nIGZvcm1hdHNcbiAgICogQHBhcmFtIG9wdGlvbnMucHJlZmVycmVkRm9ybWF0cyAtIHRoZSBwcmVmZXJyZWQgZm9ybWF0cyB0byB1c2VcbiAgICogQHBhcmFtIG9wdGlvbnMuc2tpcERldGVjdGlvbnMgLSBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgZGV0ZWN0aW9ucyBhbHRvZ2V0aGVyXG4gICAqIEBwYXJhbSBvcHRpb25zLmRldGVjdGlvbnMgLSB0aGUgZGV0ZWN0aW9ucyB0byB1c2VcbiAgICogQHJldHVybnMgLSB0aGUgZGV0ZWN0ZWQgZm9ybWF0c1xuICAgKi9cbiAgYXN5bmMgX2RldGVjdEZvcm1hdHMob3B0aW9ucykge1xuICAgIGxldCBmb3JtYXRzID0gW107XG4gICAgaWYgKG9wdGlvbnMucHJlZmVycmVkRm9ybWF0cykge1xuICAgICAgZm9ybWF0cyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wcmVmZXJyZWRGb3JtYXRzKSA/IG9wdGlvbnMucHJlZmVycmVkRm9ybWF0cyA6IFtvcHRpb25zLnByZWZlcnJlZEZvcm1hdHNdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRldGVjdGlvbiBvZiBvcHRpb25zLmRldGVjdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnNraXBEZXRlY3Rpb25zIHx8IGF3YWl0IGRldGVjdGlvbi50ZXN0KCkpIHtcbiAgICAgICAgZm9ybWF0cyA9IGF3YWl0IGRldGVjdGlvbi5hZGQoZm9ybWF0cyk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNraXBEZXRlY3Rpb25zKSB7XG4gICAgICAgIGZvcm1hdHMgPSBhd2FpdCBkZXRlY3Rpb24ucmVtb3ZlKGZvcm1hdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3JtYXRzID0gZm9ybWF0cy5maWx0ZXIoKGZvcm1hdCwgaW5kZXgpID0+IGZvcm1hdHMuaW5kZXhPZihmb3JtYXQpID09PSBpbmRleCk7XG4gICAgcmV0dXJuIGZvcm1hdHM7XG4gIH1cbiAgLyoqIEFsbCB0aGUgZGV0ZWN0aW9uIHBhcnNlcnMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBBc3NldHMgY2xhc3MuICovXG4gIGdldCBkZXRlY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXRlY3Rpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmFsIHNldHRlciBmb3IgcHJlZmVyZW5jZXMuIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gc2V0IHByZWZlcmVuY2VzIG9uIGFsbCBwYXJzZXJzLlxuICAgKiBAcGFyYW0gcHJlZmVyZW5jZXMgLSB0aGUgcHJlZmVyZW5jZXMgdG8gc2V0XG4gICAqL1xuICBzZXRQcmVmZXJlbmNlcyhwcmVmZXJlbmNlcykge1xuICAgIHRoaXMubG9hZGVyLnBhcnNlcnMuZm9yRWFjaCgocGFyc2VyKSA9PiB7XG4gICAgICBpZiAoIXBhcnNlci5jb25maWcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIE9iamVjdC5rZXlzKHBhcnNlci5jb25maWcpLmZpbHRlcigoa2V5KSA9PiBrZXkgaW4gcHJlZmVyZW5jZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBwYXJzZXIuY29uZmlnW2tleV0gPSBwcmVmZXJlbmNlc1trZXldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEFzc2V0cyA9IG5ldyBBc3NldHNDbGFzcygpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLCBBc3NldHMubG9hZGVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsIEFzc2V0cy5yZXNvbHZlci5wYXJzZXJzKS5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5DYWNoZVBhcnNlciwgQXNzZXRzLmNhY2hlLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlciwgQXNzZXRzLmRldGVjdGlvbnMpO1xuZXh0ZW5zaW9ucy5hZGQoXG4gIGNhY2hlVGV4dHVyZUFycmF5LFxuICBkZXRlY3REZWZhdWx0cyxcbiAgZGV0ZWN0QXZpZixcbiAgZGV0ZWN0V2VicCxcbiAgZGV0ZWN0TXA0LFxuICBkZXRlY3RPZ3YsXG4gIGRldGVjdFdlYm0sXG4gIGxvYWRKc29uLFxuICBsb2FkVHh0LFxuICBsb2FkV2ViRm9udCxcbiAgbG9hZFN2ZyxcbiAgbG9hZFRleHR1cmVzLFxuICBsb2FkVmlkZW9UZXh0dXJlcyxcbiAgcmVzb2x2ZVRleHR1cmVVcmwsXG4gIHJlc29sdmVKc29uVXJsXG4pO1xuY29uc3QgYXNzZXRLZXlNYXAgPSB7XG4gIGxvYWRlcjogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICByZXNvbHZlcjogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICBjYWNoZTogRXh0ZW5zaW9uVHlwZS5DYWNoZVBhcnNlcixcbiAgZGV0ZWN0aW9uOiBFeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlclxufTtcbmV4dGVuc2lvbnMuaGFuZGxlKEV4dGVuc2lvblR5cGUuQXNzZXQsIChleHRlbnNpb24pID0+IHtcbiAgY29uc3QgcmVmID0gZXh0ZW5zaW9uLnJlZjtcbiAgT2JqZWN0LmVudHJpZXMoYXNzZXRLZXlNYXApLmZpbHRlcigoW2tleV0pID0+ICEhcmVmW2tleV0pLmZvckVhY2goKFtrZXksIHR5cGVdKSA9PiBleHRlbnNpb25zLmFkZChPYmplY3QuYXNzaWduKFxuICAgIHJlZltrZXldLFxuICAgIC8vIEFsbG93IHRoZSBmdW5jdGlvbiB0byBvcHRpb25hbGx5IGRlZmluZSBpdCdzIG93blxuICAgIC8vIEV4dGVuc2lvbk1ldGFkYXRhLCB0aGUgdXNlIGNhc2VzIGhlcmUgaXMgcHJpb3JpdHkgZm9yIExvYWRlclBhcnNlcnNcbiAgICB7IGV4dGVuc2lvbjogcmVmW2tleV0uZXh0ZW5zaW9uID8/IHR5cGUgfVxuICApKSk7XG59LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5rZXlzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKGtleSkgPT4gISFyZWZba2V5XSkuZm9yRWFjaCgoa2V5KSA9PiBleHRlbnNpb25zLnJlbW92ZShyZWZba2V5XSkpO1xufSk7XG5cbmV4cG9ydCB7IEFzc2V0cywgQXNzZXRzQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0cy5tanMubWFwXG4iLCJpbXBvcnQgeyBicm93c2VyRXh0IH0gZnJvbSAnLi9lbnZpcm9ubWVudC1icm93c2VyL2Jyb3dzZXJFeHQubWpzJztcbmltcG9ydCB7IHdlYndvcmtlckV4dCB9IGZyb20gJy4vZW52aXJvbm1lbnQtd2Vid29ya2VyL3dlYndvcmtlckV4dC5tanMnO1xuaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5leHBvcnQgeyBFeHRlbnNpb25UeXBlLCBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eSB9IGZyb20gJy4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgJy4vcmVuZGVyaW5nL2luaXQubWpzJztcbmltcG9ydCAnLi9zcHJpdGVzaGVldC9pbml0Lm1qcyc7XG5pbXBvcnQgJy4vYWNjZXNzaWJpbGl0eS9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vYXBwL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vYXNzZXRzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vY29sb3IvaW5kZXgubWpzJztcbmltcG9ydCAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vY3VsbGluZy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50L2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vZW52aXJvbm1lbnQtYnJvd3Nlci9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50LXdlYndvcmtlci9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2V2ZW50cy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2V4dGVuc2lvbnMvaW5kZXgubWpzJztcbmltcG9ydCAnLi9maWx0ZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vbWF0aHMvaW5kZXgubWpzJztcbmltcG9ydCAnLi9wcmVwYXJlL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcmVuZGVyaW5nL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vc2NlbmUvaW5kZXgubWpzJztcbmltcG9ydCAnLi9zcHJpdGVzaGVldC9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3RpY2tlci9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3V0aWxzL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBBY2Nlc3NpYmlsaXR5U3lzdGVtIH0gZnJvbSAnLi9hY2Nlc3NpYmlsaXR5L0FjY2Vzc2liaWxpdHlTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGFjY2Vzc2liaWxpdHlUYXJnZXQgfSBmcm9tICcuL2FjY2Vzc2liaWxpdHkvYWNjZXNzaWJpbGl0eVRhcmdldC5tanMnO1xuZXhwb3J0IHsgQ29sb3JCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvQ29sb3JCbGVuZC5tanMnO1xuZXhwb3J0IHsgQ29sb3JCdXJuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0NvbG9yQnVybkJsZW5kLm1qcyc7XG5leHBvcnQgeyBDb2xvckRvZGdlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0NvbG9yRG9kZ2VCbGVuZC5tanMnO1xuZXhwb3J0IHsgRGFya2VuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0RhcmtlbkJsZW5kLm1qcyc7XG5leHBvcnQgeyBEaWZmZXJlbmNlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0RpZmZlcmVuY2VCbGVuZC5tanMnO1xuZXhwb3J0IHsgRGl2aWRlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0RpdmlkZUJsZW5kLm1qcyc7XG5leHBvcnQgeyBFeGNsdXNpb25CbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvRXhjbHVzaW9uQmxlbmQubWpzJztcbmV4cG9ydCB7IEhhcmRMaWdodEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9IYXJkTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgSGFyZE1peEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9IYXJkTWl4QmxlbmQubWpzJztcbmV4cG9ydCB7IExpZ2h0ZW5CbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTGlnaHRlbkJsZW5kLm1qcyc7XG5leHBvcnQgeyBMaW5lYXJCdXJuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0xpbmVhckJ1cm5CbGVuZC5tanMnO1xuZXhwb3J0IHsgTGluZWFyRG9kZ2VCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTGluZWFyRG9kZ2VCbGVuZC5tanMnO1xuZXhwb3J0IHsgTGluZWFyTGlnaHRCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTGluZWFyTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgTHVtaW5vc2l0eUJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9MdW1pbm9zaXR5QmxlbmQubWpzJztcbmV4cG9ydCB7IE5lZ2F0aW9uQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL05lZ2F0aW9uQmxlbmQubWpzJztcbmV4cG9ydCB7IE92ZXJsYXlCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvT3ZlcmxheUJsZW5kLm1qcyc7XG5leHBvcnQgeyBQaW5MaWdodEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9QaW5MaWdodEJsZW5kLm1qcyc7XG5leHBvcnQgeyBTYXR1cmF0aW9uQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL1NhdHVyYXRpb25CbGVuZC5tanMnO1xuZXhwb3J0IHsgU29mdExpZ2h0QmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL1NvZnRMaWdodEJsZW5kLm1qcyc7XG5leHBvcnQgeyBTdWJ0cmFjdEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9TdWJ0cmFjdEJsZW5kLm1qcyc7XG5leHBvcnQgeyBWaXZpZExpZ2h0QmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL1ZpdmlkTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tICcuL2FwcC9BcHBsaWNhdGlvbi5tanMnO1xuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9hcHAvUmVzaXplUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBUaWNrZXJQbHVnaW4gfSBmcm9tICcuL2FwcC9UaWNrZXJQbHVnaW4ubWpzJztcbmV4cG9ydCB7IEFzc2V0cywgQXNzZXRzQ2xhc3MgfSBmcm9tICcuL2Fzc2V0cy9Bc3NldHMubWpzJztcbmV4cG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfSBmcm9tICcuL2Fzc2V0cy9CYWNrZ3JvdW5kTG9hZGVyLm1qcyc7XG5leHBvcnQgeyBDYWNoZSB9IGZyb20gJy4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9IGZyb20gJy4vYXNzZXRzL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkubWpzJztcbmV4cG9ydCB7IGRldGVjdEF2aWYgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0QXZpZi5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0RGVmYXVsdHMgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0RGVmYXVsdHMubWpzJztcbmV4cG9ydCB7IGRldGVjdE1wNCB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RNcDQubWpzJztcbmV4cG9ydCB7IGRldGVjdE9ndiB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RPZ3YubWpzJztcbmV4cG9ydCB7IGRldGVjdFdlYm0gfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0V2VibS5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0V2VicCB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcyc7XG5leHBvcnQgeyB0ZXN0SW1hZ2VGb3JtYXQgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3V0aWxzL3Rlc3RJbWFnZUZvcm1hdC5tanMnO1xuZXhwb3J0IHsgdGVzdFZpZGVvRm9ybWF0IH0gZnJvbSAnLi9hc3NldHMvZGV0ZWN0aW9ucy91dGlscy90ZXN0VmlkZW9Gb3JtYXQubWpzJztcbmV4cG9ydCB7IExvYWRlciB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9Mb2FkZXIubWpzJztcbmV4cG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBsb2FkSnNvbiB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL2xvYWRKc29uLm1qcyc7XG5leHBvcnQgeyBsb2FkVHh0IH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvbG9hZFR4dC5tanMnO1xuZXhwb3J0IHsgZ2V0Rm9udEZhbWlseU5hbWUsIGxvYWRXZWJGb250IH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQubWpzJztcbmV4cG9ydCB7IGxvYWRTdmcgfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkU1ZHLm1qcyc7XG5leHBvcnQgeyBsb2FkSW1hZ2VCaXRtYXAsIGxvYWRUZXh0dXJlcyB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5tanMnO1xuZXhwb3J0IHsgY3Jvc3NPcmlnaW4sIGRldGVybWluZUNyb3NzT3JpZ2luLCBsb2FkVmlkZW9UZXh0dXJlcywgcHJlbG9hZFZpZGVvIH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFZpZGVvVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy91dGlscy9jcmVhdGVUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBXb3JrZXJNYW5hZ2VyIH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3dvcmtlcnMvV29ya2VyTWFuYWdlci5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUpzb25VcmwgfSBmcm9tICcuL2Fzc2V0cy9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVKc29uVXJsLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlVGV4dHVyZVVybCB9IGZyb20gJy4vYXNzZXRzL3Jlc29sdmVyL3BhcnNlcnMvcmVzb2x2ZVRleHR1cmVVcmwubWpzJztcbmV4cG9ydCB7IFJlc29sdmVyLCBnZXRVcmxFeHRlbnNpb24gfSBmcm9tICcuL2Fzc2V0cy9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuZXhwb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi9hc3NldHMvdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5leHBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4vYXNzZXRzL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5leHBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi9hc3NldHMvdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuZXhwb3J0IHsgY29weVNlYXJjaFBhcmFtcyB9IGZyb20gJy4vYXNzZXRzL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfSBmcm9tICcuL2Fzc2V0cy91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuL2Fzc2V0cy91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcbmV4cG9ydCB7IENvbG9yIH0gZnJvbSAnLi9jb2xvci9Db2xvci5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0QmFzaXMgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvYmFzaXMvZGV0ZWN0QmFzaXMubWpzJztcbmV4cG9ydCB7IGxvYWRCYXNpcyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy9sb2FkQmFzaXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZUxldmVsQnVmZmVycyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy91dGlscy9jcmVhdGVMZXZlbEJ1ZmZlcnMubWpzJztcbmV4cG9ydCB7IGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL3V0aWxzL2dwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBiYXNpc1RyYW5zY29kZXJVcmxzLCBzZXRCYXNpc1RyYW5zY29kZXJQYXRoIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL3V0aWxzL3NldEJhc2lzVHJhbnNjb2RlclBhdGgubWpzJztcbmV4cG9ydCB7IGxvYWRCYXNpc09uV29ya2VyIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL3dvcmtlci9sb2FkQmFzaXNPbldvcmtlci5tanMnO1xuZXhwb3J0IHsgRERTLCBEWEdJX1RPX1RFWFRVUkVfRk9STUFULCBGT1VSQ0NfVE9fVEVYVFVSRV9GT1JNQVQsIFRFWFRVUkVfRk9STUFUX0JMT0NLX1NJWkUgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvZGRzL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBsb2FkRERTIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Rkcy9sb2FkRERTLm1qcyc7XG5leHBvcnQgeyBwYXJzZUREUyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9kZHMvcGFyc2VERFMubWpzJztcbmV4cG9ydCB7IGxvYWRLVFggfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4L2xvYWRLVFgubWpzJztcbmV4cG9ydCB7IHBhcnNlS1RYIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eC9wYXJzZUtUWC5tanMnO1xuZXhwb3J0IHsgR0xfSU5URVJOQUxfRk9STUFULCBLVFggfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi9jb25zdC5tanMnO1xuZXhwb3J0IHsgbG9hZEtUWDIgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi9sb2FkS1RYMi5tanMnO1xuZXhwb3J0IHsgY29udmVydEZvcm1hdElmUmVxdWlyZWQgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi91dGlscy9jb252ZXJ0Rm9ybWF0SWZSZXF1aXJlZC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlTGV2ZWxCdWZmZXJzRnJvbUtUWCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2NyZWF0ZUxldmVsQnVmZmVyc0Zyb21LVFgubWpzJztcbmV4cG9ydCB7IGdldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZSB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2dldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgZ2xGb3JtYXRUb0dQVUZvcm1hdCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2dsRm9ybWF0VG9HUFVGb3JtYXQubWpzJztcbmV4cG9ydCB7IGdwdUZvcm1hdFRvS1RYQmFzaXNUcmFuc2NvZGVyRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eDIvdXRpbHMvZ3B1Rm9ybWF0VG9LVFhCYXNpc1RyYW5zY29kZXJGb3JtYXQubWpzJztcbmV4cG9ydCB7IGt0eFRyYW5zY29kZXJVcmxzLCBzZXRLVFhUcmFuc2NvZGVyUGF0aCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL3NldEtUWFRyYW5zY29kZXJQYXRoLm1qcyc7XG5leHBvcnQgeyB2a0Zvcm1hdFRvR1BVRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eDIvdXRpbHMvdmtGb3JtYXRUb0dQVUZvcm1hdC5tanMnO1xuZXhwb3J0IHsgbG9hZEtUWDJvbldvcmtlciB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3dvcmtlci9sb2FkS1RYMm9uV29ya2VyLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RDb21wcmVzc2VkIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL3NoYXJlZC9kZXRlY3RDb21wcmVzc2VkLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwsIHZhbGlkRm9ybWF0cyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9zaGFyZWQvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qcyc7XG5leHBvcnQgeyBDdWxsZXIgfSBmcm9tICcuL2N1bGxpbmcvQ3VsbGVyLm1qcyc7XG5leHBvcnQgeyBDdWxsZXJQbHVnaW4gfSBmcm9tICcuL2N1bGxpbmcvQ3VsbGVyUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBjdWxsaW5nTWl4aW4gfSBmcm9tICcuL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcyc7XG5leHBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5leHBvcnQgeyBhdXRvRGV0ZWN0RW52aXJvbm1lbnQgfSBmcm9tICcuL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanMnO1xuZXhwb3J0IHsgQnJvd3NlckFkYXB0ZXIgfSBmcm9tICcuL2Vudmlyb25tZW50LWJyb3dzZXIvQnJvd3NlckFkYXB0ZXIubWpzJztcbmV4cG9ydCB7IFdlYldvcmtlckFkYXB0ZXIgfSBmcm9tICcuL2Vudmlyb25tZW50LXdlYndvcmtlci9XZWJXb3JrZXJBZGFwdGVyLm1qcyc7XG5leHBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSAnLi9ldmVudHMvRXZlbnRCb3VuZGFyeS5tanMnO1xuZXhwb3J0IHsgRXZlbnRTeXN0ZW0gfSBmcm9tICcuL2V2ZW50cy9FdmVudFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRXZlbnRzVGlja2VyIH0gZnJvbSAnLi9ldmVudHMvRXZlbnRUaWNrZXIubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkRXZlbnQubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZENvbnRhaW5lciB9IGZyb20gJy4vZXZlbnRzL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBibGVuZFRlbXBsYXRlRnJhZyB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9ibGVuZC10ZW1wbGF0ZS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJsZW5kVGVtcGxhdGVWZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL2JsZW5kLW1vZGVzL2JsZW5kLXRlbXBsYXRlLnZlcnQubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYmxlbmRUZW1wbGF0ZVdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvYmxlbmQtbW9kZXMvYmxlbmQtdGVtcGxhdGUud2dzbC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoc2xXZ3NsIH0gZnJvbSAnLi9maWx0ZXJzL2JsZW5kLW1vZGVzL2hzbC53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFscGhhRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9hbHBoYS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFscGhhV2dzbCB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9hbHBoYS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJsdXJUZW1wbGF0ZVdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvYmx1ci9ncHUvYmx1ci10ZW1wbGF0ZS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbG9yTWF0cml4RmlsdGVyRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9jb2xvci1tYXRyaXgvY29sb3JNYXRyaXhGaWx0ZXIuZnJhZy5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb2xvck1hdHJpeEZpbHRlcldnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvY29sb3ItbWF0cml4L2NvbG9yTWF0cml4RmlsdGVyLndnc2wubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdEZpbHRlclZlcnQgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGVmYXVsdEZpbHRlci52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudEZyYWcgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudFZlcnQgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudFdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vaXNlRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9ub2lzZS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vaXNlV2dzbCB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9ub2lzZS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tGcmFnIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tWZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tXZ3NsIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay53Z3NsLm1qcyc7XG5leHBvcnQgeyBCbGVuZE1vZGVGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcnMvYmxlbmQtbW9kZXMvQmxlbmRNb2RlRmlsdGVyLm1qcyc7XG5leHBvcnQgeyBoc2xnbCB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9obHMvR0xobHMubWpzJztcbmV4cG9ydCB7IGhzbGdwdSB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9obHMvR1BVaGxzLm1qcyc7XG5leHBvcnQgeyBBbHBoYUZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9BbHBoYUZpbHRlci5tanMnO1xuZXhwb3J0IHsgQmx1ckZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL0JsdXJGaWx0ZXIubWpzJztcbmV4cG9ydCB7IEJsdXJGaWx0ZXJQYXNzIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvQmx1ckZpbHRlclBhc3MubWpzJztcbmV4cG9ydCB7IEdBVVNTSUFOX1ZBTFVFUyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyR2xQcm9ncmFtIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyR2xQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyVmVydFNvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyUHJvZ3JhbSB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL2dwdS9nZW5lcmF0ZUJsdXJQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBDb2xvck1hdHJpeEZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9jb2xvci1tYXRyaXgvQ29sb3JNYXRyaXhGaWx0ZXIubWpzJztcbmV4cG9ydCB7IERpc3BsYWNlbWVudEZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9kaXNwbGFjZW1lbnQvRGlzcGxhY2VtZW50RmlsdGVyLm1qcyc7XG5leHBvcnQgeyBOb2lzZUZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9Ob2lzZUZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyRWZmZWN0IH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuZXhwb3J0IHsgRmlsdGVyUGlwZSB9IGZyb20gJy4vZmlsdGVycy9GaWx0ZXJQaXBlLm1qcyc7XG5leHBvcnQgeyBGaWx0ZXJTeXN0ZW0gfSBmcm9tICcuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBNYXNrRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svTWFza0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4vbWF0aHMvbWF0cml4L2dyb3VwRDgubWpzJztcbmV4cG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuZXhwb3J0IHsgREVHX1RPX1JBRCwgUElfMiwgUkFEX1RPX0RFRyB9IGZyb20gJy4vbWF0aHMvbWlzYy9jb25zdC5tanMnO1xuZXhwb3J0IHsgaXNQb3cyLCBsb2cyLCBuZXh0UG93MiB9IGZyb20gJy4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5leHBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi9tYXRocy9taXNjL3NxdWFyZWREaXN0YW5jZVRvTGluZVNlZ21lbnQubWpzJztcbmV4cG9ydCB7IE9ic2VydmFibGVQb2ludCB9IGZyb20gJy4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5leHBvcnQgeyBQb2ludCB9IGZyb20gJy4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmV4cG9ydCB7IENpcmNsZSB9IGZyb20gJy4vbWF0aHMvc2hhcGVzL0NpcmNsZS5tanMnO1xuZXhwb3J0IHsgRWxsaXBzZSB9IGZyb20gJy4vbWF0aHMvc2hhcGVzL0VsbGlwc2UubWpzJztcbmV4cG9ydCB7IFBvbHlnb24gfSBmcm9tICcuL21hdGhzL3NoYXBlcy9Qb2x5Z29uLm1qcyc7XG5leHBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmV4cG9ydCB7IFJvdW5kZWRSZWN0YW5nbGUgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLm1qcyc7XG5leHBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4vbWF0aHMvc2hhcGVzL1RyaWFuZ2xlLm1qcyc7XG5leHBvcnQgeyBQcmVwYXJlQmFzZSB9IGZyb20gJy4vcHJlcGFyZS9QcmVwYXJlQmFzZS5tanMnO1xuZXhwb3J0IHsgUHJlcGFyZVF1ZXVlIH0gZnJvbSAnLi9wcmVwYXJlL1ByZXBhcmVRdWV1ZS5tanMnO1xuZXhwb3J0IHsgUHJlcGFyZVN5c3RlbSB9IGZyb20gJy4vcHJlcGFyZS9QcmVwYXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBQcmVwYXJlVXBsb2FkIH0gZnJvbSAnLi9wcmVwYXJlL1ByZXBhcmVVcGxvYWQubWpzJztcbmV4cG9ydCB7IEdsQmF0Y2hBZGFwdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9nbC9HbEJhdGNoQWRhcHRvci5tanMnO1xuZXhwb3J0IHsgQmF0Y2hHZW9tZXRyeSB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L0JhdGNoR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlR1BVTGF5b3V0IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2VuZXJhdGVHUFVMYXlvdXQubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlTGF5b3V0IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2VuZXJhdGVMYXlvdXQubWpzJztcbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L2dldFRleHR1cmVCYXRjaEJpbmRHcm91cC5tanMnO1xuZXhwb3J0IHsgR3B1QmF0Y2hBZGFwdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvR3B1QmF0Y2hBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBCYXRjaCwgQmF0Y2hlciB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzJztcbmV4cG9ydCB7IEJhdGNoZXJQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlclBpcGUubWpzJztcbmV4cG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hUZXh0dXJlQXJyYXkubWpzJztcbmV4cG9ydCB7IE1BWF9URVhUVVJFUyB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmV4cG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyLCBjb21waWxlSGlnaFNoYWRlckdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvY29tcGlsZUhpZ2hTaGFkZXIubWpzJztcbmV4cG9ydCB7IGFkZEJpdHMgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlci91dGlscy9hZGRCaXRzLm1qcyc7XG5leHBvcnQgeyBjb21waWxlSG9va3MsIGZpbmRIb29rc1J4IH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvY29tcGlsZUhvb2tzLm1qcyc7XG5leHBvcnQgeyBjb21waWxlSW5wdXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvY29tcGlsZUlucHV0cy5tanMnO1xuZXhwb3J0IHsgY29tcGlsZU91dHB1dHMgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlci91dGlscy9jb21waWxlT3V0cHV0cy5tanMnO1xuZXhwb3J0IHsgZm9ybWF0U2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvZm9ybWF0U2hhZGVyLm1qcyc7XG5leHBvcnQgeyBpbmplY3RCaXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvaW5qZWN0Qml0cy5tanMnO1xuZXhwb3J0IHsgZnJhZ21lbnRHUFVUZW1wbGF0ZSwgZnJhZ21lbnRHbFRlbXBsYXRlLCB2ZXJ0ZXhHUFVUZW1wbGF0ZSwgdmVydGV4R2xUZW1wbGF0ZSB9IGZyb20gJy4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL2RlZmF1bHRQcm9ncmFtVGVtcGxhdGUubWpzJztcbmV4cG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0LCBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQubWpzJztcbmV4cG9ydCB7IGdsb2JhbFVuaWZvcm1zQml0LCBnbG9iYWxVbmlmb3Jtc0JpdEdsLCBnbG9iYWxVbmlmb3Jtc1VCT0JpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2xvYmFsVW5pZm9ybXNCaXQubWpzJztcbmV4cG9ydCB7IGxvY2FsVW5pZm9ybUJpdCwgbG9jYWxVbmlmb3JtQml0R2wsIGxvY2FsVW5pZm9ybUJpdEdyb3VwMiB9IGZyb20gJy4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybUJpdC5tanMnO1xuZXhwb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuZXhwb3J0IHsgdGV4dHVyZUJpdCwgdGV4dHVyZUJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvdGV4dHVyZUJpdC5tanMnO1xuZXhwb3J0IHsgQWxwaGFNYXNrIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9hbHBoYS9BbHBoYU1hc2subWpzJztcbmV4cG9ydCB7IEFscGhhTWFza1BpcGUgfSBmcm9tICcuL3JlbmRlcmluZy9tYXNrL2FscGhhL0FscGhhTWFza1BpcGUubWpzJztcbmV4cG9ydCB7IENvbG9yTWFzayB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svY29sb3IvQ29sb3JNYXNrLm1qcyc7XG5leHBvcnQgeyBDb2xvck1hc2tQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9jb2xvci9Db2xvck1hc2tQaXBlLm1qcyc7XG5leHBvcnQgeyBNYXNrRWZmZWN0TWFuYWdlciwgTWFza0VmZmVjdE1hbmFnZXJDbGFzcyB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzJztcbmV4cG9ydCB7IFNjaXNzb3JNYXNrIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9zY2lzc29yL1NjaXNzb3JNYXNrLm1qcyc7XG5leHBvcnQgeyBTdGVuY2lsTWFzayB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svc3RlbmNpbC9TdGVuY2lsTWFzay5tanMnO1xuZXhwb3J0IHsgU3RlbmNpbE1hc2tQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrUGlwZS5tanMnO1xuZXhwb3J0IHsgYWRkTWFza0JvdW5kcyB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svdXRpbHMvYWRkTWFza0JvdW5kcy5tanMnO1xuZXhwb3J0IHsgYWRkTWFza0xvY2FsQm91bmRzLCBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50IH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay91dGlscy9hZGRNYXNrTG9jYWxCb3VuZHMubWpzJztcbmV4cG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJVRkZFUl9UWVBFIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2J1ZmZlci9jb25zdC5tanMnO1xuZXhwb3J0IHsgR2xCdWZmZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvYnVmZmVyL0dsQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBHbEJ1ZmZlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9idWZmZXIvR2xCdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IENMRUFSIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBHbENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvY29udGV4dC9HbENvbnRleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdsR2VvbWV0cnlTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvZ2VvbWV0cnkvR2xHZW9tZXRyeVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgZ2V0R2xUeXBlRnJvbUZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9nZW9tZXRyeS91dGlscy9nZXRHbFR5cGVGcm9tRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBHbEJhY2tCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xCYWNrQnVmZmVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHbENvbG9yTWFza1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbENvbG9yTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xFbmNvZGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsRW5jb2RlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IEdsU3RlbmNpbFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbFN0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdsVWJvU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsVWJvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHbFJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvcmVuZGVyVGFyZ2V0L0dsUmVuZGVyVGFyZ2V0QWRhcHRvci5tanMnO1xuZXhwb3J0IHsgR2xSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvcmVuZGVyVGFyZ2V0L0dsUmVuZGVyVGFyZ2V0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVNoYWRlclN5bmNDb2RlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HZW5lcmF0ZVNoYWRlclN5bmNDb2RlLm1qcyc7XG5leHBvcnQgeyBHbFByb2dyYW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgR2xQcm9ncmFtRGF0YSwgSUdMVW5pZm9ybURhdGEgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbURhdGEubWpzJztcbmV4cG9ydCB7IEdsU2hhZGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HbFNoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xVbmlmb3JtR3JvdXBTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsVW5pZm9ybUdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBtaWdyYXRlRnJhZ21lbnRGcm9tVjd0b1Y4IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9taWdyYXRlRnJhZ21lbnRGcm9tVjd0b1Y4Lm1qcyc7XG5leHBvcnQgeyBjb21waWxlU2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2NvbXBpbGVTaGFkZXIubWpzJztcbmV4cG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9kZWZhdWx0VmFsdWUubWpzJztcbmV4cG9ydCB7IGVuc3VyZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZW5zdXJlQXR0cmlidXRlcy5tanMnO1xuZXhwb3J0IHsgZXh0cmFjdEF0dHJpYnV0ZXNGcm9tR2xQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2V4dHJhY3RBdHRyaWJ1dGVzRnJvbUdsUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dlbmVyYXRlUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24ubWpzJztcbmV4cG9ydCB7IGdldFRlc3RDb250ZXh0IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFRlc3RDb250ZXh0Lm1qcyc7XG5leHBvcnQgeyBnZXRVYm9EYXRhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFVib0RhdGEubWpzJztcbmV4cG9ydCB7IGdldFVuaWZvcm1EYXRhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFVuaWZvcm1EYXRhLm1qcyc7XG5leHBvcnQgeyBsb2dQcm9ncmFtRXJyb3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vbG9nUHJvZ3JhbUVycm9yLm1qcyc7XG5leHBvcnQgeyBtYXBTaXplIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL21hcFNpemUubWpzJztcbmV4cG9ydCB7IG1hcEdsVG9WZXJ0ZXhGb3JtYXQsIG1hcFR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vbWFwVHlwZS5tanMnO1xuZXhwb3J0IHsgYWRkUHJvZ3JhbURlZmluZXMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vcHJlcHJvY2Vzc29ycy9hZGRQcm9ncmFtRGVmaW5lcy5tanMnO1xuZXhwb3J0IHsgZW5zdXJlUHJlY2lzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvZW5zdXJlUHJlY2lzaW9uLm1qcyc7XG5leHBvcnQgeyBpbnNlcnRWZXJzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvaW5zZXJ0VmVyc2lvbi5tanMnO1xuZXhwb3J0IHsgc2V0UHJvZ3JhbU5hbWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vcHJlcHJvY2Vzc29ycy9zZXRQcm9ncmFtTmFtZS5tanMnO1xuZXhwb3J0IHsgc3RyaXBWZXJzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvc3RyaXBWZXJzaW9uLm1qcyc7XG5leHBvcnQgeyBXR1NMX1RPX1NURDQwX1NJWkUsIGNyZWF0ZVVib0VsZW1lbnRzU1RENDAgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzU1RENDAubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVVib1N5bmNGdW5jdGlvblNURDQwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jU1RENDAubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlQXJyYXlTeW5jU1RENDAgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2dlbmVyYXRlQXJyYXlTeW5jU1RENDAubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMnO1xuZXhwb3J0IHsgVU5JRk9STV9UT19BUlJBWV9TRVRURVJTLCBVTklGT1JNX1RPX1NJTkdMRV9TRVRURVJTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luY1R5cGVzLm1qcyc7XG5leHBvcnQgeyBHbFN0YXRlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3N0YXRlL0dsU3RhdGVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zdGF0ZS9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzJztcbmV4cG9ydCB7IEdMX0ZPUk1BVFMsIEdMX1RBUkdFVFMsIEdMX1RZUEVTLCBHTF9XUkFQX01PREVTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvY29uc3QubWpzJztcbmV4cG9ydCB7IEdsVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL0dsVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgR2xUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvR2xUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRWaWRlb1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBhcHBseVN0eWxlUGFyYW1zIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvYXBwbHlTdHlsZVBhcmFtcy5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkR2xDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9nZXRTdXBwb3J0ZWRHbENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbEZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xGb3JtYXQubWpzJztcbmV4cG9ydCB7IG1hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdC5tanMnO1xuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbFR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9tYXBGb3JtYXRUb0dsVHlwZS5tanMnO1xuZXhwb3J0IHsgY29tcGFyZU1vZGVUb0dsQ29tcGFyZSwgbWlwbWFwU2NhbGVNb2RlVG9HbEZpbHRlciwgc2NhbGVNb2RlVG9HbEZpbHRlciwgd3JhcE1vZGVUb0dsQWRkcmVzcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL3BpeGlUb0dsTWFwcy5tanMnO1xuZXhwb3J0IHsgdW5wcmVtdWx0aXBseUFscGhhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvdW5wcmVtdWx0aXBseUFscGhhLm1qcyc7XG5leHBvcnQgeyBXZWJHTFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL1dlYkdMUmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJpbmRHcm91cFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvQmluZEdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVCdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVJlYWRCdWZmZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVSZWFkQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBVYm9CYXRjaCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvYnVmZmVyL1Vib0JhdGNoLm1qcyc7XG5leHBvcnQgeyBHcHVDb2xvck1hc2tTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUNvbG9yTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgR3B1RGV2aWNlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVEZXZpY2VTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdUVuY29kZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUVuY29kZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVN0ZW5jaWxTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdVN0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVVib1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvR3B1VWJvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVVbmlmb3JtQmF0Y2hQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVVbmlmb3JtQmF0Y2hQaXBlLm1qcyc7XG5leHBvcnQgeyBQaXBlbGluZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvcGlwZWxpbmUvUGlwZWxpbmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGNhbGN1bGF0ZVByb2plY3Rpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9jYWxjdWxhdGVQcm9qZWN0aW9uLm1qcyc7XG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IEdwdVJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuZXhwb3J0IHsgR3B1UHJvZ3JhbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVByb2dyYW0ubWpzJztcbmV4cG9ydCB7IEdwdVNoYWRlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVNoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgV0dTTF9BTElHTl9TSVpFX0RBVEEsIGNyZWF0ZVVib0VsZW1lbnRzV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzV0dTTC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib1N5bmNGdW5jdGlvbldHU0wubWpzJztcbmV4cG9ydCB7IGV4dHJhY3RBdHRyaWJ1dGVzRnJvbUdwdVByb2dyYW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9leHRyYWN0QXR0cmlidXRlc0Zyb21HcHVQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBleHRyYWN0U3RydWN0QW5kR3JvdXBzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZXh0cmFjdFN0cnVjdEFuZEdyb3Vwcy5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVBcnJheVN5bmNXR1NMIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVBcnJheVN5bmNXR1NMLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUdwdUxheW91dEdyb3VwcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2dlbmVyYXRlR3B1TGF5b3V0R3JvdXBzLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUxheW91dEhhc2ggfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9nZW5lcmF0ZUxheW91dEhhc2gubWpzJztcbmV4cG9ydCB7IHJlbW92ZVN0cnVjdEFuZEdyb3VwRHVwbGljYXRlcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL3JlbW92ZVN0cnVjdEFuZEdyb3VwRHVwbGljYXRlcy5tanMnO1xuZXhwb3J0IHsgR3B1QmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc3RhdGUvR3B1QmxlbmRNb2Rlc1RvUGl4aS5tanMnO1xuZXhwb3J0IHsgR3B1U3RhdGVTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0YXRlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVTdGVuY2lsTW9kZXNUb1BpeGkgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0ZW5jaWxNb2Rlc1RvUGl4aS5tanMnO1xuZXhwb3J0IHsgR3B1VGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvdGV4dHVyZS9HcHVUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBibG9ja0RhdGFNYXAsIGdwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IGdwdVVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZEltYWdlU291cmNlLm1qcyc7XG5leHBvcnQgeyBncHVVcGxvYWRWaWRlb1Jlc291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRWaWRlb1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkR1BVQ29tcHJlc3NlZFRleHR1cmVGb3JtYXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3V0aWxzL2dldFN1cHBvcnRlZEdQVUNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgR3B1TWlwbWFwR2VuZXJhdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3V0aWxzL0dwdU1pcG1hcEdlbmVyYXRvci5tanMnO1xuZXhwb3J0IHsgV2ViR1BVUmVuZGVyZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L1dlYkdQVVJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJsZW5kTW9kZVBpcGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2JsZW5kTW9kZXMvQmxlbmRNb2RlUGlwZS5tanMnO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlclJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBmYXN0Q29weSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5leHBvcnQgeyBFeHRyYWN0U3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9leHRyYWN0L0V4dHJhY3RTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdlbmVyYXRlVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZXh0cmFjdC9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IERSQVdfTU9ERVMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IGJ1aWxkU2ltcGxlVXZzLCBidWlsZFV2cyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuZXhwb3J0IHsgZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2dldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBnZXRHZW9tZXRyeUJvdW5kcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZ2V0R2VvbWV0cnlCb3VuZHMubWpzJztcbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy90cmFuc2Zvcm1WZXJ0aWNlcy5tanMnO1xuZXhwb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2luc3RydWN0aW9ucy9JbnN0cnVjdGlvblNldC5tanMnO1xuZXhwb3J0IHsgR2xvYmFsVW5pZm9ybVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L0dsb2JhbFVuaWZvcm1TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGlzUmVuZGVyaW5nVG9TY3JlZW4gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9pc1JlbmRlcmluZ1RvU2NyZWVuLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IFJlbmRlclRhcmdldFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L1JlbmRlclRhcmdldFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgdmlld3BvcnRGcm9tRnJhbWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC92aWV3cG9ydEZyb21GcmFtZS5tanMnO1xuZXhwb3J0IHsgU2hhZGVyU3RhZ2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9jb25zdC5tanMnO1xuZXhwb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5leHBvcnQgeyBVYm9TeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9VYm9TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY0Z1bmN0aW9uLm1qcyc7XG5leHBvcnQgeyBnZXREZWZhdWx0VW5pZm9ybVZhbHVlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvZ2V0RGVmYXVsdFVuaWZvcm1WYWx1ZS5tanMnO1xuZXhwb3J0IHsgdWJvU3luY0Z1bmN0aW9uc1NURDQwLCB1Ym9TeW5jRnVuY3Rpb25zV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL3V0aWxzL3Vib1N5bmNGdW5jdGlvbnMubWpzJztcbmV4cG9ydCB7IHVuaWZvcm1QYXJzZXJzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvdW5pZm9ybVBhcnNlcnMubWpzJztcbmV4cG9ydCB7IEhlbGxvU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGFydHVwL0hlbGxvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBCTEVORF9UT19OUE0sIFNURU5DSUxfTU9ERVMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBnZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcyc7XG5leHBvcnQgeyBTdGF0ZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmV4cG9ydCB7IEFic3RyYWN0UmVuZGVyZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9BYnN0cmFjdFJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBTaGFyZWRSZW5kZXJQaXBlcywgU2hhcmVkU3lzdGVtcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL1NoYXJlZFN5c3RlbXMubWpzJztcbmV4cG9ydCB7IFN5c3RlbVJ1bm5lciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL1N5c3RlbVJ1bm5lci5tanMnO1xuZXhwb3J0IHsgQ2FudmFzUG9vbCwgQ2FudmFzUG9vbENsYXNzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmV4cG9ydCB7IERFUFJFQ0FURURfU0NBTEVfTU9ERVMsIERFUFJFQ0FURURfV1JBUF9NT0RFUywgTVNBQV9RVUFMSVRZLCBTQ0FMRV9NT0RFUywgV1JBUF9NT0RFUyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9jb25zdC5tanMnO1xuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9SZW5kZXJUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0J1ZmZlclNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ2FudmFzU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5leHBvcnQgeyBDb21wcmVzc2VkU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ29tcHJlc3NlZFNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSW1hZ2VTb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9JbWFnZVNvdXJjZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL1RleHR1cmVTb3VyY2UubWpzJztcbmV4cG9ydCB7IFZpZGVvU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvVmlkZW9Tb3VyY2UubWpzJztcbmV4cG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZUdDU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZU1hdHJpeCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlTWF0cml4Lm1qcyc7XG5leHBvcnQgeyBUZXh0dXJlUG9vbCwgVGV4dHVyZVBvb2xDbGFzcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlUG9vbC5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVN0eWxlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVTdHlsZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVV2cyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlVXZzLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVVJRCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy9nZW5lcmF0ZVVJRC5tanMnO1xuZXhwb3J0IHsgZ2V0Q2FudmFzVGV4dHVyZSwgaGFzQ2FjaGVkQ2FudmFzVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy9nZXRDYW52YXNUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBnZXRTdXBwb3J0ZWRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2V0U3VwcG9ydGVkQ29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLm1qcyc7XG5leHBvcnQgeyBnZXRTdXBwb3J0ZWRUZXh0dXJlRm9ybWF0cywgbm9uQ29tcHJlc3NlZEZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2V0U3VwcG9ydGVkVGV4dHVyZUZvcm1hdHMubWpzJztcbmV4cG9ydCB7IGF1dG9EZXRlY3RTb3VyY2UsIHJlc291cmNlVG9UZXh0dXJlLCB0ZXh0dXJlRnJvbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy90ZXh0dXJlRnJvbS5tanMnO1xuZXhwb3J0IHsgY3JlYXRlSWRGcm9tU3RyaW5nIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC91dGlscy9jcmVhdGVJZEZyb21TdHJpbmcubWpzJztcbmV4cG9ydCB7IHBhcnNlRnVuY3Rpb25Cb2R5IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC91dGlscy9wYXJzZUZ1bmN0aW9uQm9keS5tanMnO1xuZXhwb3J0IHsgVmlld1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdmlldy9WaWV3U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmV4cG9ydCB7IEJvdW5kcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9Cb3VuZHMubWpzJztcbmV4cG9ydCB7IF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUsIGdldEZhc3RHbG9iYWxCb3VuZHMgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanMnO1xuZXhwb3J0IHsgX2dldEdsb2JhbEJvdW5kcywgZ2V0R2xvYmFsQm91bmRzLCB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcyc7XG5leHBvcnQgeyBnZXRMb2NhbEJvdW5kcywgZ2V0UGFyZW50IH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldExvY2FsQm91bmRzLm1qcyc7XG5leHBvcnQgeyBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldFJlbmRlcmFibGVCb3VuZHMubWpzJztcbmV4cG9ydCB7IGJvdW5kc1Bvb2wsIG1hdHJpeFBvb2wgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuZXhwb3J0IHsgY2hpbGRyZW5IZWxwZXJNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvY2hpbGRyZW5IZWxwZXJNaXhpbi5tanMnO1xuZXhwb3J0IHsgZWZmZWN0c01peGluIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9lZmZlY3RzTWl4aW4ubWpzJztcbmV4cG9ydCB7IGZpbmRNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvZmluZE1peGluLm1qcyc7XG5leHBvcnQgeyBtZWFzdXJlTWl4aW4gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL21lYXN1cmVNaXhpbi5tanMnO1xuZXhwb3J0IHsgb25SZW5kZXJNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvb25SZW5kZXJNaXhpbi5tanMnO1xuZXhwb3J0IHsgc29ydE1peGluIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9zb3J0TWl4aW4ubWpzJztcbmV4cG9ydCB7IHRvTG9jYWxHbG9iYWxNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvdG9Mb2NhbEdsb2JhbE1peGluLm1qcyc7XG5leHBvcnQgeyBDb250YWluZXIsIFVQREFURV9CTEVORCwgVVBEQVRFX0NPTE9SLCBVUERBVEVfVFJBTlNGT1JNLCBVUERBVEVfVklTSUJMRSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuZXhwb3J0IHsgQ3VzdG9tUmVuZGVyUGlwZSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL0N1c3RvbVJlbmRlclBpcGUubWpzJztcbmV4cG9ydCB7IFJlbmRlckNvbnRhaW5lciB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL1JlbmRlckNvbnRhaW5lci5tanMnO1xuZXhwb3J0IHsgUmVuZGVyR3JvdXAgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJHcm91cC5tanMnO1xuZXhwb3J0IHsgUmVuZGVyR3JvdXBQaXBlIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvUmVuZGVyR3JvdXBQaXBlLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJHcm91cFN5c3RlbSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBhc3NpZ25XaXRoSWdub3JlIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvYXNzaWduV2l0aElnbm9yZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRJbnN0cnVjdGlvbnMsIGNvbGxlY3RBbGxSZW5kZXJhYmxlcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2J1aWxkSW5zdHJ1Y3Rpb25zLm1qcyc7XG5leHBvcnQgeyBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvY2hlY2tDaGlsZHJlbkRpZENoYW5nZS5tanMnO1xuZXhwb3J0IHsgY29sbGVjdFJlbmRlckdyb3VwcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2NvbGxlY3RSZW5kZXJHcm91cHMubWpzJztcbmV4cG9ydCB7IGRlZmluZWRQcm9wcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2RlZmluZWRQcm9wcy5tanMnO1xuZXhwb3J0IHsgZXhlY3V0ZUluc3RydWN0aW9ucyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2V4ZWN1dGVJbnN0cnVjdGlvbnMubWpzJztcbmV4cG9ydCB7IG1peENvbG9ycywgbWl4U3RhbmRhcmRBbmQzMkJpdENvbG9ycyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL21peENvbG9ycy5tanMnO1xuZXhwb3J0IHsgbWl4SGV4Q29sb3JzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvbWl4SGV4Q29sb3JzLm1qcyc7XG5leHBvcnQgeyBtdWx0aXBseUhleENvbG9ycyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL211bHRpcGx5SGV4Q29sb3JzLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVMb2NhbFRyYW5zZm9ybSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZUxvY2FsVHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybSwgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLCB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3Jtcy5tanMnO1xuZXhwb3J0IHsgdXBkYXRlV29ybGRUcmFuc2Zvcm0gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci91dGlscy91cGRhdGVXb3JsZFRyYW5zZm9ybS5tanMnO1xuZXhwb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3ZhbGlkYXRlUmVuZGVyYWJsZXMubWpzJztcbmV4cG9ydCB7IEdsR3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9nbC9HbEdyYXBoaWNzQWRhcHRvci5tanMnO1xuZXhwb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSwgY29sb3JUb1VuaWZvcm0gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuZXhwb3J0IHsgR3B1R3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9ncHUvR3B1R3JhcGhpY3NBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBCYXRjaGFibGVHcmFwaGljcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0JhdGNoYWJsZUdyYXBoaWNzLm1qcyc7XG5leHBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5leHBvcnQgeyBidWlsZEFkYXB0aXZlUXVhZHJhdGljIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlUXVhZHJhdGljLm1qcyc7XG5leHBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzJztcbmV4cG9ydCB7IGJ1aWxkQXJjVG8gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG8ubWpzJztcbmV4cG9ydCB7IGJ1aWxkQXJjVG9TdmcgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG9TdmcubWpzJztcbmV4cG9ydCB7IGJ1aWxkQ2lyY2xlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZExpbmUubWpzJztcbmV4cG9ydCB7IGJ1aWxkUG9seWdvbiB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRQb2x5Z29uLm1qcyc7XG5leHBvcnQgeyBidWlsZFJlY3RhbmdsZSB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzJztcbmV4cG9ydCB7IGJ1aWxkVHJpYW5nbGUgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkVHJpYW5nbGUubWpzJztcbmV4cG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvY29uc3QubWpzJztcbmV4cG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5leHBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbFBhdHRlcm4ubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3MubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzQ29udGV4dCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzQ29udGV4dC5tanMnO1xuZXhwb3J0IHsgR3B1R3JhcGhpY3NDb250ZXh0LCBHcmFwaGljc0NvbnRleHRSZW5kZXJEYXRhLCBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzUGlwZSB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzUGlwZS5tanMnO1xuZXhwb3J0IHsgR3JhcGhpY3NQYXRoIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvcGF0aC9HcmFwaGljc1BhdGgubWpzJztcbmV4cG9ydCB7IHJvdW5kZWRTaGFwZUFyYywgcm91bmRlZFNoYXBlUXVhZHJhdGljQ3VydmUgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL3JvdW5kU2hhcGUubWpzJztcbmV4cG9ydCB7IFNoYXBlUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvU2hhcGVQYXRoLm1qcyc7XG5leHBvcnQgeyBTVkdQYXJzZXIgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9zdmcvU1ZHUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBTVkdUb0dyYXBoaWNzUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanMnO1xuZXhwb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2J1aWxkQ29udGV4dEJhdGNoZXMubWpzJztcbmV4cG9ydCB7IGJ1aWxkR2VvbWV0cnlGcm9tUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2J1aWxkR2VvbWV0cnlGcm9tUGF0aC5tanMnO1xuZXhwb3J0IHsgY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcyc7XG5leHBvcnQgeyBnZXRPcmllbnRhdGlvbk9mUG9pbnRzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvZ2V0T3JpZW50YXRpb25PZlBvaW50cy5tanMnO1xuZXhwb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy90cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMnO1xuZXhwb3J0IHsgTWVzaFBsYW5lIH0gZnJvbSAnLi9zY2VuZS9tZXNoLXBsYW5lL01lc2hQbGFuZS5tanMnO1xuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBNZXNoUm9wZSB9IGZyb20gJy4vc2NlbmUvbWVzaC1zaW1wbGUvTWVzaFJvcGUubWpzJztcbmV4cG9ydCB7IE1lc2hTaW1wbGUgfSBmcm9tICcuL3NjZW5lL21lc2gtc2ltcGxlL01lc2hTaW1wbGUubWpzJztcbmV4cG9ydCB7IFJvcGVHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvbWVzaC1zaW1wbGUvUm9wZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBHbE1lc2hBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9tZXNoL2dsL0dsTWVzaEFkYXB0b3IubWpzJztcbmV4cG9ydCB7IEdwdU1lc2hBZGFwdGVyIH0gZnJvbSAnLi9zY2VuZS9tZXNoL2dwdS9HcHVNZXNoQWRhcHRlci5tanMnO1xuZXhwb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4vc2NlbmUvbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanMnO1xuZXhwb3J0IHsgZ2V0VGV4dHVyZURlZmF1bHRNYXRyaXggfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL2dldFRleHR1cmVEZWZhdWx0TWF0cml4Lm1qcyc7XG5leHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9zY2VuZS9tZXNoL3NoYXJlZC9NZXNoLm1qcyc7XG5leHBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgTWVzaFBpcGUgfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL01lc2hQaXBlLm1qcyc7XG5leHBvcnQgeyBBbmltYXRlZFNwcml0ZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLWFuaW1hdGVkL0FuaW1hdGVkU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBOaW5lU2xpY2VHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IE5pbmVTbGljZVBsYW5lLCBOaW5lU2xpY2VTcHJpdGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL05pbmVTbGljZVNwcml0ZS5tanMnO1xuZXhwb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlU3ByaXRlUGlwZS5tanMnO1xuZXhwb3J0IHsgdGlsaW5nQml0LCB0aWxpbmdCaXRHbCB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvdGlsaW5nQml0Lm1qcyc7XG5leHBvcnQgeyBUaWxpbmdTcHJpdGVTaGFkZXIgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL1RpbGluZ1Nwcml0ZVNoYWRlci5tanMnO1xuZXhwb3J0IHsgVGlsaW5nU3ByaXRlIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL1RpbGluZ1Nwcml0ZS5tanMnO1xuZXhwb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy9UaWxpbmdTcHJpdGVQaXBlLm1qcyc7XG5leHBvcnQgeyBhcHBseU1hdHJpeCB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9hcHBseU1hdHJpeC5tanMnO1xuZXhwb3J0IHsgUXVhZEdlb21ldHJ5IH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgc2V0UG9zaXRpb25zIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFBvc2l0aW9ucy5tanMnO1xuZXhwb3J0IHsgc2V0VXZzIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFV2cy5tanMnO1xuZXhwb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzJztcbmV4cG9ydCB7IFNwcml0ZVBpcGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS9TcHJpdGVQaXBlLm1qcyc7XG5leHBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL2Fzc2V0L2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250WE1MUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250Q2FjaGVQbHVnaW4sIGxvYWRCaXRtYXBGb250IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9sb2FkQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgQml0bWFwRm9udCB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgQml0bWFwRm9udE1hbmFnZXIgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnRNYW5hZ2VyLm1qcyc7XG5leHBvcnQgeyBCaXRtYXBUZXh0IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBUZXh0Lm1qcyc7XG5leHBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IER5bmFtaWNCaXRtYXBGb250IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9EeW5hbWljQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0Lm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFBpcGUgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSwgbnNzdmcsIG5zeGh0bWwgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFJlbmRlckRhdGEubWpzJztcbmV4cG9ydCB7IEhUTUxUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IdG1sVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZXh0cmFjdEZvbnRGYW1pbGllcy5tanMnO1xuZXhwb3J0IHsgRm9udFN0eWxlUHJvbWlzZUNhY2hlLCBnZXRGb250Q3NzIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0Rm9udENzcy5tanMnO1xuZXhwb3J0IHsgZ2V0U1ZHVXJsIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0U1ZHVXJsLm1qcyc7XG5leHBvcnQgeyBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzJztcbmV4cG9ydCB7IGxvYWRGb250QXNCYXNlNjQgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udEFzQmFzZTY0Lm1qcyc7XG5leHBvcnQgeyBsb2FkRm9udENTUyB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250Q1NTLm1qcyc7XG5leHBvcnQgeyBsb2FkU1ZHSW1hZ2UgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkU1ZHSW1hZ2UubWpzJztcbmV4cG9ydCB7IG1lYXN1cmVIdG1sVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL3V0aWxzL21lYXN1cmVIdG1sVGV4dC5tanMnO1xuZXhwb3J0IHsgdGV4dFN0eWxlVG9DU1MgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy90ZXh0U3R5bGVUb0NTUy5tanMnO1xuZXhwb3J0IHsgQWJzdHJhY3RUZXh0LCBlbnN1cmVPcHRpb25zIH0gZnJvbSAnLi9zY2VuZS90ZXh0L0Fic3RyYWN0VGV4dC5tanMnO1xuZXhwb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5leHBvcnQgeyBDYW52YXNUZXh0UGlwZSB9IGZyb20gJy4vc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IENhbnZhc1RleHRTeXN0ZW0gfSBmcm9tICcuL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuZXhwb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzJztcbmV4cG9ydCB7IFNkZlNoYWRlciB9IGZyb20gJy4vc2NlbmUvdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcyc7XG5leHBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmV4cG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuZXhwb3J0IHsgVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC9UZXh0Lm1qcyc7XG5leHBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBlbnN1cmVUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQvdXRpbHMvZW5zdXJlVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9IGZyb20gJy4vc2NlbmUvdGV4dC91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanMnO1xuZXhwb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuL3NjZW5lL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzJztcbmV4cG9ydCB7IFNwcml0ZXNoZWV0IH0gZnJvbSAnLi9zcHJpdGVzaGVldC9TcHJpdGVzaGVldC5tanMnO1xuZXhwb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9IGZyb20gJy4vc3ByaXRlc2hlZXQvc3ByaXRlc2hlZXRBc3NldC5tanMnO1xuZXhwb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi90aWNrZXIvY29uc3QubWpzJztcbmV4cG9ydCB7IFRpY2tlciB9IGZyb20gJy4vdGlja2VyL1RpY2tlci5tanMnO1xuZXhwb3J0IHsgVGlja2VyTGlzdGVuZXIgfSBmcm9tICcuL3RpY2tlci9UaWNrZXJMaXN0ZW5lci5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0VmlkZW9BbHBoYU1vZGUgfSBmcm9tICcuL3V0aWxzL2Jyb3dzZXIvZGV0ZWN0VmlkZW9BbHBoYU1vZGUubWpzJztcbmV4cG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi91dGlscy9icm93c2VyL2lzTW9iaWxlLm1qcyc7XG5leHBvcnQgeyBpc1NhZmFyaSB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9pc1NhZmFyaS5tanMnO1xuZXhwb3J0IHsgaXNXZWJHTFN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyBpc1dlYkdQVVN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9pc1dlYkdQVVN1cHBvcnRlZC5tanMnO1xuZXhwb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gJy4vdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcyc7XG5leHBvcnQgeyBEQVRBX1VSSSB9IGZyb20gJy4vdXRpbHMvY29uc3QubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5leHBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gJy4vdXRpbHMvZGF0YS9yZW1vdmVJdGVtcy5tanMnO1xuZXhwb3J0IHsgcmVzZXRVaWRzLCB1aWQgfSBmcm9tICcuL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH0gZnJvbSAnLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH0gZnJvbSAnLi91dGlscy9kYXRhL1ZpZXdhYmxlQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBsb2dEZWJ1Z1RleHR1cmUgfSBmcm9tICcuL3V0aWxzL2xvZ2dpbmcvbG9nRGVidWdUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBsb2dSZW5kZXJHcm91cFNjZW5lLCBsb2dTY2VuZSB9IGZyb20gJy4vdXRpbHMvbG9nZ2luZy9sb2dTY2VuZS5tanMnO1xuZXhwb3J0IHsgd2FybiB9IGZyb20gJy4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5leHBvcnQgeyBOT09QIH0gZnJvbSAnLi91dGlscy9taXNjL05PT1AubWpzJztcbmV4cG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJy4vdXRpbHMvbWlzYy9UcmFuc2Zvcm0ubWpzJztcbmV4cG9ydCB7IGdldFJlc29sdXRpb25PZlVybCB9IGZyb20gJy4vdXRpbHMvbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzJztcbmV4cG9ydCB7IHBhdGggfSBmcm9tICcuL3V0aWxzL3BhdGgubWpzJztcbmV4cG9ydCB7IFBvb2wgfSBmcm9tICcuL3V0aWxzL3Bvb2wvUG9vbC5tanMnO1xuZXhwb3J0IHsgQmlnUG9vbCwgUG9vbEdyb3VwQ2xhc3MgfSBmcm9tICcuL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5leHBvcnQgeyBWRVJTSU9OLCBzYXlIZWxsbyB9IGZyb20gJy4vdXRpbHMvc2F5SGVsbG8ubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZWFyY3V0IH0gZnJvbSAnZWFyY3V0JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChicm93c2VyRXh0LCB3ZWJ3b3JrZXJFeHQpO1xuXG5leHBvcnQgeyBicm93c2VyRXh0LCBleHRlbnNpb25zLCB3ZWJ3b3JrZXJFeHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3974\n')},5321:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   y: () => (/* binding */ Matrix)\n/* harmony export */ });\n/* harmony import */ var _misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5502);\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(_misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__/* .PI_2 */ ._b - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\n\n//# sourceMappingURL=Matrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyMS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUNFOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDJCQUEyQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDJCQUEyQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQUk7QUFDckM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSyxTQUFTLEtBQUssUUFBUTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21hdHJpeC9NYXRyaXgubWpzP2M5MTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUElfMiB9IGZyb20gJy4uL21pc2MvY29uc3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBNYXRyaXgge1xuICAvKipcbiAgICogQHBhcmFtIGEgLSB4IHNjYWxlXG4gICAqIEBwYXJhbSBiIC0geSBza2V3XG4gICAqIEBwYXJhbSBjIC0geCBza2V3XG4gICAqIEBwYXJhbSBkIC0geSBzY2FsZVxuICAgKiBAcGFyYW0gdHggLSB4IHRyYW5zbGF0aW9uXG4gICAqIEBwYXJhbSB0eSAtIHkgdHJhbnNsYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgY3VycmVudCBtYXRyaXguIE9ubHkgcG9wdWxhdGVkIHdoZW4gYHRvQXJyYXlgIGlzIGNhbGxlZCAqL1xuICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBhID0gYXJyYXlbMF1cbiAgICogYiA9IGFycmF5WzFdXG4gICAqIGMgPSBhcnJheVszXVxuICAgKiBkID0gYXJyYXlbNF1cbiAgICogdHggPSBhcnJheVsyXVxuICAgKiB0eSA9IGFycmF5WzVdXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBwb3B1bGF0ZWQgZnJvbS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gYSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIGIgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEBwYXJhbSBjIC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gZCAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIHR4IC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gdHkgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5kID0gZDtcbiAgICB0aGlzLnR4ID0gdHg7XG4gICAgdGhpcy50eSA9IHR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdC5cbiAgICogQHBhcmFtIHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICogQHBhcmFtIFtvdXQ9bmV3IEZsb2F0MzJBcnJheSg5KV0gLSBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBiZSBhc3NpZ25lZCB0byBvdXRcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1hdHJpeFxuICAgKi9cbiAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCkge1xuICAgIGlmICghdGhpcy5hcnJheSkge1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICBhcnJheVs1XSA9IDA7XG4gICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICBhcnJheVs4XSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICBhcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICBhcnJheVszXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgYXJyYXlbN10gPSAwO1xuICAgICAgYXJyYXlbOF0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgKi9cbiAgYXBwbHkocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eTtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIG5ldyBwb2ludCwgaW52ZXJzZS10cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAqL1xuICBhcHBseUludmVyc2UocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCB0eCA9IHRoaXMudHg7XG4gICAgY29uc3QgdHkgPSB0aGlzLnR5O1xuICAgIGNvbnN0IGlkID0gMSAvIChhICogZCArIGMgKiAtYik7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IGQgKiBpZCAqIHggKyAtYyAqIGlkICogeSArICh0eSAqIGMgLSB0eCAqIGQpICogaWQ7XG4gICAgbmV3UG9zLnkgPSBhICogaWQgKiB5ICsgLWIgKiBpZCAqIHggKyAoLXR5ICogYSArIHR4ICogYikgKiBpZDtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXG4gICAqIEBwYXJhbSB4IC0gSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICogQHBhcmFtIHkgLSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnR4ICs9IHg7XG4gICAgdGhpcy50eSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICogQHBhcmFtIHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIGhvcml6b250YWxseVxuICAgKiBAcGFyYW0geSAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgc2NhbGUoeCwgeSkge1xuICAgIHRoaXMuYSAqPSB4O1xuICAgIHRoaXMuZCAqPSB5O1xuICAgIHRoaXMuYyAqPSB4O1xuICAgIHRoaXMuYiAqPSB5O1xuICAgIHRoaXMudHggKj0geDtcbiAgICB0aGlzLnR5ICo9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbjtcbiAgICB0aGlzLmIgPSBhMSAqIHNpbiArIHRoaXMuYiAqIGNvcztcbiAgICB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcztcbiAgICB0aGlzLnR4ID0gdHgxICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBhcHBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzE7XG4gICAgdGhpcy5iID0gbWF0cml4LmEgKiBiMSArIG1hdHJpeC5iICogZDE7XG4gICAgdGhpcy5jID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDE7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0d28gbWF0cml4J3MgYW5kIHNldHMgdGhlIHJlc3VsdCB0byB0aGlzIG1hdHJpeC4gQUIgPSBBICogQlxuICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxuICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgYXBwZW5kRnJvbShhLCBiKSB7XG4gICAgY29uc3QgYTEgPSBhLmE7XG4gICAgY29uc3QgYjEgPSBhLmI7XG4gICAgY29uc3QgYzEgPSBhLmM7XG4gICAgY29uc3QgZDEgPSBhLmQ7XG4gICAgY29uc3QgdHggPSBhLnR4O1xuICAgIGNvbnN0IHR5ID0gYS50eTtcbiAgICBjb25zdCBhMiA9IGIuYTtcbiAgICBjb25zdCBiMiA9IGIuYjtcbiAgICBjb25zdCBjMiA9IGIuYztcbiAgICBjb25zdCBkMiA9IGIuZDtcbiAgICB0aGlzLmEgPSBhMSAqIGEyICsgYjEgKiBjMjtcbiAgICB0aGlzLmIgPSBhMSAqIGIyICsgYjEgKiBkMjtcbiAgICB0aGlzLmMgPSBjMSAqIGEyICsgZDEgKiBjMjtcbiAgICB0aGlzLmQgPSBjMSAqIGIyICsgZDEgKiBkMjtcbiAgICB0aGlzLnR4ID0gdHggKiBhMiArIHR5ICogYzIgKyBiLnR4O1xuICAgIHRoaXMudHkgPSB0eCAqIGIyICsgdHkgKiBkMiArIGIudHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBiYXNlZCBvbiBhbGwgdGhlIGF2YWlsYWJsZSBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB4IC0gUG9zaXRpb24gb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0geSAtIFBvc2l0aW9uIG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHBpdm90WCAtIFBpdm90IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHBpdm90WSAtIFBpdm90IG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHNjYWxlWCAtIFNjYWxlIG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHNjYWxlWSAtIFNjYWxlIG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gUm90YXRpb24gaW4gcmFkaWFuc1xuICAgKiBAcGFyYW0gc2tld1ggLSBTa2V3IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHNrZXdZIC0gU2tldyBvbiB0aGUgeSBheGlzXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XG4gICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5jID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyk7XG4gICAgdGhpcy50eSA9IHkgLSAocGl2b3RYICogdGhpcy5iICsgcGl2b3RZICogdGhpcy5kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gcHJlcGVuZFxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgcHJlcGVuZChtYXRyaXgpIHtcbiAgICBjb25zdCB0eDEgPSB0aGlzLnR4O1xuICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xuICAgICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgICBjb25zdCBjMSA9IHRoaXMuYztcbiAgICAgIHRoaXMuYSA9IGExICogbWF0cml4LmEgKyB0aGlzLmIgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuYiA9IGExICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZDtcbiAgICAgIHRoaXMuYyA9IGMxICogbWF0cml4LmEgKyB0aGlzLmQgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuZCA9IGMxICogbWF0cml4LmIgKyB0aGlzLmQgKiBtYXRyaXguZDtcbiAgICB9XG4gICAgdGhpcy50eCA9IHR4MSAqIG1hdHJpeC5hICsgdGhpcy50eSAqIG1hdHJpeC5jICsgbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSB0eDEgKiBtYXRyaXguYiArIHRoaXMudHkgKiBtYXRyaXguZCArIG1hdHJpeC50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVjb21wb3NlcyB0aGUgbWF0cml4ICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKSBhbmQgc2V0cyB0aGUgcHJvcGVydGllcyBvbiB0byBhIHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gdG8gYXBwbHkgdGhlIHByb3BlcnRpZXMgdG8uXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gd2l0aCB0aGUgbmV3bHkgYXBwbGllZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCBwaXZvdCA9IHRyYW5zZm9ybS5waXZvdDtcbiAgICBjb25zdCBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICBjb25zdCBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcbiAgICBpZiAoZGVsdGEgPCAxZS01IHx8IE1hdGguYWJzKFBJXzIgLSBkZWx0YSkgPCAxZS01KSB7XG4gICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSBza2V3WTtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gMDtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnggPSBza2V3WDtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnkgPSBza2V3WTtcbiAgICB9XG4gICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgdHJhbnNmb3JtLnNjYWxlLnkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLnggPSB0aGlzLnR4ICsgKHBpdm90LnggKiBhICsgcGl2b3QueSAqIGMpO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdGhpcy50eSArIChwaXZvdC54ICogYiArIHBpdm90LnkgKiBkKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoaXMgbWF0cml4XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpbnZlcnQoKSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICBjb25zdCBuID0gYTEgKiBkMSAtIGIxICogYzE7XG4gICAgdGhpcy5hID0gZDEgLyBuO1xuICAgIHRoaXMuYiA9IC1iMSAvIG47XG4gICAgdGhpcy5jID0gLWMxIC8gbjtcbiAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgdGhpcy50eCA9IChjMSAqIHRoaXMudHkgLSBkMSAqIHR4MSkgLyBuO1xuICAgIHRoaXMudHkgPSAtKGExICogdGhpcy50eSAtIGIxICogdHgxKSAvIG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIENoZWNrcyBpZiB0aGlzIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXggKi9cbiAgaXNJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5hID09PSAxICYmIHRoaXMuYiA9PT0gMCAmJiB0aGlzLmMgPT09IDAgJiYgdGhpcy5kID09PSAxICYmIHRoaXMudHggPT09IDAgJiYgdGhpcy50eSA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgTWF0cml4IHRvIGFuIGlkZW50aXR5IChkZWZhdWx0KSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpZGVudGl0eSgpIHtcbiAgICB0aGlzLmEgPSAxO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5jID0gMDtcbiAgICB0aGlzLmQgPSAxO1xuICAgIHRoaXMudHggPSAwO1xuICAgIHRoaXMudHkgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IGdpdmVuIGluIHBhcmFtZXRlciB3aXRoIGl0cyB2YWx1ZXMgdXBkYXRlZC5cbiAgICovXG4gIGNvcHlUbyhtYXRyaXgpIHtcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICBtYXRyaXguYyA9IHRoaXMuYztcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gZ2l2ZW4gbWF0cml4XG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgdGhpc1xuICAgKi9cbiAgY29weUZyb20obWF0cml4KSB7XG4gICAgdGhpcy5hID0gbWF0cml4LmE7XG4gICAgdGhpcy5iID0gbWF0cml4LmI7XG4gICAgdGhpcy5jID0gbWF0cml4LmM7XG4gICAgdGhpcy5kID0gbWF0cml4LmQ7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eDtcbiAgICB0aGlzLnR5ID0gbWF0cml4LnR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanM6TWF0cml4IGE9JHt0aGlzLmF9IGI9JHt0aGlzLmJ9IGM9JHt0aGlzLmN9IGQ9JHt0aGlzLmR9IHR4PSR7dGhpcy50eH0gdHk9JHt0aGlzLnR5fV1gO1xuICB9XG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgKGlkZW50aXR5KSBtYXRyaXguXG4gICAqXG4gICAqIFRoaXMgaXMgYSBzaGFyZWQgb2JqZWN0LCBpZiB5b3Ugd2FudCB0byBtb2RpZnkgaXQgY29uc2lkZXIgY3JlYXRpbmcgYSBuZXcgYE1hdHJpeGBcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgIHJldHVybiBpZGVudGl0eU1hdHJpeC5pZGVudGl0eSgpO1xuICB9XG4gIC8qKlxuICAgKiBBIHN0YXRpYyBNYXRyaXggdGhhdCBjYW4gYmUgdXNlZCB0byBhdm9pZCBjcmVhdGluZyBuZXcgb2JqZWN0cy5cbiAgICogV2lsbCBhbHdheXMgZW5zdXJlIHRoZSBtYXRyaXggaXMgcmVzZXQgdG8gaWRlbnRpdHkgd2hlbiByZXF1ZXN0ZWQuXG4gICAqIFVzZSB0aGlzIG9iamVjdCBmb3IgZmFzdCBidXQgdGVtcG9yYXJ5IGNhbGN1bGF0aW9ucywgYXMgaXQgbWF5IGJlIG11dGF0ZWQgbGF0ZXIgb24uXG4gICAqIFRoaXMgaXMgYSBkaWZmZXJlbnQgb2JqZWN0IHRvIHRoZSBgSURFTlRJVFlgIG9iamVjdCBhbmQgc28gY2FuIGJlIG1vZGlmaWVkIHdpdGhvdXQgY2hhbmdpbmcgYElERU5USVRZYC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICByZXR1cm4gdGVtcE1hdHJpeC5pZGVudGl0eSgpO1xuICB9XG59XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuY29uc3QgaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbmV4cG9ydCB7IE1hdHJpeCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0cml4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5321\n")},5502:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZX: () => (/* binding */ DEG_TO_RAD),\n/* harmony export */   _b: () => (/* binding */ PI_2),\n/* harmony export */   jl: () => (/* binding */ RAD_TO_DEG)\n/* harmony export */ });\n\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2MvY29uc3QubWpzP2YwY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBQSV8yID0gTWF0aC5QSSAqIDI7XG5jb25zdCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbmNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG5leHBvcnQgeyBERUdfVE9fUkFELCBQSV8yLCBSQURfVE9fREVHIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5502\n")},4181:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a9: () => (/* binding */ nextPow2),\n/* harmony export */   wv: () => (/* binding */ isPow2)\n/* harmony export */ });\n/* unused harmony export log2 */\n\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n\n//# sourceMappingURL=pow2.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2MvcG93Mi5tanM/MTI0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG5leHRQb3cyKHYpIHtcbiAgdiArPSB2ID09PSAwID8gMSA6IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5mdW5jdGlvbiBpc1BvdzIodikge1xuICByZXR1cm4gISh2ICYgdiAtIDEpICYmICEhdjtcbn1cbmZ1bmN0aW9uIGxvZzIodikge1xuICBsZXQgciA9ICh2ID4gNjU1MzUgPyAxIDogMCkgPDwgNDtcbiAgdiA+Pj49IHI7XG4gIGxldCBzaGlmdCA9ICh2ID4gMjU1ID8gMSA6IDApIDw8IDM7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDE1ID8gMSA6IDApIDw8IDI7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDMgPyAxIDogMCkgPDwgMTtcbiAgdiA+Pj49IHNoaWZ0O1xuICByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8IHYgPj4gMTtcbn1cblxuZXhwb3J0IHsgaXNQb3cyLCBsb2cyLCBuZXh0UG93MiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG93Mi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4181\n")},4973:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ObservablePoint)\n/* harmony export */ });\n\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUcsSUFBSSxHQUFHLFFBQVEsZUFBZTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9wb2ludC9PYnNlcnZhYmxlUG9pbnQubWpzPzk4ZjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgT2JzZXJ2YWJsZVBvaW50YFxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBwYXNzIHRvIGxpc3RlbiBmb3IgY2hhbmdlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCB4LCB5KSB7XG4gICAgdGhpcy5feCA9IHggfHwgMDtcbiAgICB0aGlzLl95ID0geSB8fCAwO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBPcHRpb25hbCBvYnNlcnZlciB0byBwYXNzIHRvIHRoZSBuZXcgb2JzZXJ2YWJsZSBwb2ludC5cbiAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgb2JzZXJ2YWJsZSBwb2ludFxuICAgKi9cbiAgY2xvbmUob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChvYnNlcnZlciA/PyB0aGlzLl9vYnNlcnZlciwgdGhpcy5feCwgdGhpcy5feSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IGB4YCBhbmQgYHlgIHBvc2l0aW9uLlxuICAgKiBJZiBgeWAgaXMgb21pdHRlZCwgYm90aCBgeGAgYW5kIGB5YCB3aWxsIGJlIHNldCB0byBgeGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT14XSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZhYmxlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgc2V0KHggPSAwLCB5ID0geCkge1xuICAgIGlmICh0aGlzLl94ICE9PSB4IHx8IHRoaXMuX3kgIT09IHkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl9vYnNlcnZlci5fb25VcGRhdGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludCAoYHBgKVxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb20uIENhbiBiZSBhbnkgb2YgdHlwZSB0aGF0IGlzIG9yIGV4dGVuZHMgYFBvaW50RGF0YWBcbiAgICogQHJldHVybnMgVGhlIG9ic2VydmFibGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBjb3B5RnJvbShwKSB7XG4gICAgaWYgKHRoaXMuX3ggIT09IHAueCB8fCB0aGlzLl95ICE9PSBwLnkpIHtcbiAgICAgIHRoaXMuX3ggPSBwLng7XG4gICAgICB0aGlzLl95ID0gcC55O1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuX29uVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9pbnQncyB4IGFuZCB5IGludG8gdGhhdCBvZiB0aGUgZ2l2ZW4gcG9pbnQgKGBwYClcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSB0by4gQ2FuIGJlIGFueSBvZiB0eXBlIHRoYXQgaXMgb3IgZXh0ZW5kcyBgUG9pbnREYXRhYFxuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgKGBwYCkgd2l0aCB2YWx1ZXMgdXBkYXRlZFxuICAgKi9cbiAgY29weVRvKHApIHtcbiAgICBwLnNldCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhbm90aGVyIHBvaW50IChgcGApIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGB4YCBhbmQgYHlgIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLl94ICYmIHAueSA9PT0gdGhpcy5feTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6T2JzZXJ2YWJsZVBvaW50IHg9JHswfSB5PSR7MH0gc2NvcGU9JHt0aGlzLl9vYnNlcnZlcn1dYDtcbiAgfVxuICAvKiogUG9zaXRpb24gb2YgdGhlIG9ic2VydmFibGUgcG9pbnQgb24gdGhlIHggYXhpcy4gKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgIHRoaXMuX29ic2VydmVyLl9vblVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHBvaW50IG9uIHRoZSB5IGF4aXMuICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3kgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgICB0aGlzLl9vYnNlcnZlci5fb25VcGRhdGUodGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IE9ic2VydmFibGVQb2ludCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZVBvaW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4973\n")},1134:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ Point)\n/* harmony export */ });\n\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\n\n//# sourceMappingURL=Point.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsSUFBSSxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9wb2ludC9Qb2ludC5tanM/ZTA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvaW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFBvaW50YFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzICovXG4gICAgdGhpcy54ID0gMDtcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMgKi9cbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICogQHJldHVybnMgQSBjbG9uZSBvZiB0aGlzIHBvaW50XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGB4YCBhbmQgYHlgIGZyb20gdGhlIGdpdmVuIHBvaW50IGludG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb21cbiAgICogQHJldHVybnMgVGhlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgY29weUZyb20ocCkge1xuICAgIHRoaXMuc2V0KHAueCwgcC55KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9pbnQncyB4IGFuZCB5IGludG8gdGhlIGdpdmVuIHBvaW50IChgcGApLlxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IHRvLiBDYW4gYmUgYW55IG9mIHR5cGUgdGhhdCBpcyBvciBleHRlbmRzIGBQb2ludERhdGFgXG4gICAqIEByZXR1cm5zIFRoZSBwb2ludCAoYHBgKSB3aXRoIHZhbHVlcyB1cGRhdGVkXG4gICAqL1xuICBjb3B5VG8ocCkge1xuICAgIHAuc2V0KHRoaXMueCwgdGhpcy55KTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhbm90aGVyIHBvaW50IChgcGApIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGB4YCBhbmQgYHlgIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLnggJiYgcC55ID09PSB0aGlzLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IGB4YCBhbmQgYHlgIHBvc2l0aW9uLlxuICAgKiBJZiBgeWAgaXMgb21pdHRlZCwgYm90aCBgeGAgYW5kIGB5YCB3aWxsIGJlIHNldCB0byBgeGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgYHhgIGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSBgeWAgYXhpc1xuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBzZXQoeCA9IDAsIHkgPSB4KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanMvbWF0aDpQb2ludCB4PSR7dGhpcy54fSB5PSR7dGhpcy55fV1gO1xuICB9XG4gIC8qKlxuICAgKiBBIHN0YXRpYyBQb2ludCBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCB2YWx1ZXMgb2YgYDBgLiBDYW4gYmUgdXNlZCB0byBhdm9pZCBjcmVhdGluZyBuZXcgb2JqZWN0cyBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICB0ZW1wUG9pbnQueCA9IDA7XG4gICAgdGVtcFBvaW50LnkgPSAwO1xuICAgIHJldHVybiB0ZW1wUG9pbnQ7XG4gIH1cbn1cbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBQb2ludCgpO1xuXG5leHBvcnQgeyBQb2ludCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1134\n")},3904:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n"use strict";\nconst tempPoints = [new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'rectangle\'\n     */\n    this.type = "rectangle";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can\'t intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Rectangle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTJDOztBQUUzQztBQUNBLHdCQUF3Qiw0REFBSyxRQUFRLDREQUFLLFFBQVEsNERBQUssUUFBUSw0REFBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUywrRUFBK0U7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxRQUFRLFFBQVEsWUFBWSxTQUFTLFlBQVk7QUFDckc7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcz81OWYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wUG9pbnRzID0gW25ldyBQb2ludCgpLCBuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIG5ldyBQb2ludCgpXTtcbmNsYXNzIFJlY3RhbmdsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncmVjdGFuZ2xlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwicmVjdGFuZ2xlXCI7XG4gICAgdGhpcy54ID0gTnVtYmVyKHgpO1xuICAgIHRoaXMueSA9IE51bWJlcih5KTtcbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKHdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE51bWJlcihoZWlnaHQpO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLiAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGUuICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMueTtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgUmVjdGFuZ2xlIGlzIGVtcHR5LiAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPT09IHRoaXMucmlnaHQgfHwgdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG4gIC8qKiBBIGNvbnN0YW50IGVtcHR5IHJlY3RhbmdsZS4gVGhpcyBpcyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgKi9cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUmVjdGFuZ2xlXG4gICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEJvdW5kcyBvYmplY3QgdG8gYSBSZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIGJvdW5kcyB0byBjb3B5IGFuZCBjb252ZXJ0IHRvIGEgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tQm91bmRzKGJvdW5kcykge1xuICAgIHRoaXMueCA9IGJvdW5kcy5taW5YO1xuICAgIHRoaXMueSA9IGJvdW5kcy5taW5ZO1xuICAgIHRoaXMud2lkdGggPSBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YO1xuICAgIHRoaXMuaGVpZ2h0ID0gYm91bmRzLm1heFkgLSBib3VuZHMubWluWTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGFub3RoZXIgcmVjdGFuZ2xlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IGZyb20uXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgY29weUZyb20ocmVjdGFuZ2xlKSB7XG4gICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHJlY3RhbmdsZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSB0by5cbiAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb3B5VG8ocmVjdGFuZ2xlKSB7XG4gICAgcmVjdGFuZ2xlLmNvcHlGcm9tKHRoaXMpO1xuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdGFuZ2xlIGluY2x1ZGluZyB0aGUgc3Ryb2tlLlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSBzdHJva2VXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHJlY3RhbmdsZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgX3ggPSB0aGlzLng7XG4gICAgY29uc3QgX3kgPSB0aGlzLnk7XG4gICAgY29uc3Qgb3V0ZXJMZWZ0ID0gX3ggLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3Qgb3V0ZXJSaWdodCA9IF94ICsgd2lkdGggKyBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3Qgb3V0ZXJUb3AgPSBfeSAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBvdXRlckJvdHRvbSA9IF95ICsgaGVpZ2h0ICsgc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyTGVmdCA9IF94ICsgc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyUmlnaHQgPSBfeCArIHdpZHRoIC0gc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyVG9wID0gX3kgKyBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaW5uZXJCb3R0b20gPSBfeSArIGhlaWdodCAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICByZXR1cm4geCA+PSBvdXRlckxlZnQgJiYgeCA8PSBvdXRlclJpZ2h0ICYmIHkgPj0gb3V0ZXJUb3AgJiYgeSA8PSBvdXRlckJvdHRvbSAmJiAhKHggPiBpbm5lckxlZnQgJiYgeCA8IGlubmVyUmlnaHQgJiYgeSA+IGlubmVyVG9wICYmIHkgPCBpbm5lckJvdHRvbSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYG90aGVyYCBSZWN0YW5nbGUgdHJhbnNmb3JtZWQgYnkgYHRyYW5zZm9ybWAgaW50ZXJzZWN0cyB3aXRoIGB0aGlzYCBSZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgYXJlYSBvZiB0aGUgaW50ZXJzZWN0aW9uIGlzID4wLCB0aGlzIG1lYW5zIHRoYXQgUmVjdGFuZ2xlc1xuICAgKiBzaGFyaW5nIGEgc2lkZSBhcmUgbm90IG92ZXJsYXBwaW5nLiBBbm90aGVyIHNpZGUgZWZmZWN0IGlzIHRoYXQgYW4gYXJlYWxlc3MgcmVjdGFuZ2xlXG4gICAqICh3aWR0aCBvciBoZWlnaHQgZXF1YWwgdG8gemVybykgY2FuJ3QgaW50ZXJzZWN0IGFueSBvdGhlciByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBvdGhlciAtIFRoZSBSZWN0YW5nbGUgdG8gaW50ZXJzZWN0IHdpdGggYHRoaXNgLlxuICAgKiBAcGFyYW0ge01hdHJpeH0gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiBgb3RoZXJgLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSB2YWx1ZSBvZiBgdHJ1ZWAgaWYgdGhlIHRyYW5zZm9ybWVkIGBvdGhlcmAgUmVjdGFuZ2xlIGludGVyc2VjdHMgd2l0aCBgdGhpc2A7IG90aGVyd2lzZSBgZmFsc2VgLlxuICAgKi9cbiAgaW50ZXJzZWN0cyhvdGhlciwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnN0IHgwMiA9IHRoaXMueCA8IG90aGVyLnggPyBvdGhlci54IDogdGhpcy54O1xuICAgICAgY29uc3QgeDEyID0gdGhpcy5yaWdodCA+IG90aGVyLnJpZ2h0ID8gb3RoZXIucmlnaHQgOiB0aGlzLnJpZ2h0O1xuICAgICAgaWYgKHgxMiA8PSB4MDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgeTAyID0gdGhpcy55IDwgb3RoZXIueSA/IG90aGVyLnkgOiB0aGlzLnk7XG4gICAgICBjb25zdCB5MTIgPSB0aGlzLmJvdHRvbSA+IG90aGVyLmJvdHRvbSA/IG90aGVyLmJvdHRvbSA6IHRoaXMuYm90dG9tO1xuICAgICAgcmV0dXJuIHkxMiA+IHkwMjtcbiAgICB9XG4gICAgY29uc3QgeDAgPSB0aGlzLmxlZnQ7XG4gICAgY29uc3QgeDEgPSB0aGlzLnJpZ2h0O1xuICAgIGNvbnN0IHkwID0gdGhpcy50b3A7XG4gICAgY29uc3QgeTEgPSB0aGlzLmJvdHRvbTtcbiAgICBpZiAoeDEgPD0geDAgfHwgeTEgPD0geTApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbHQgPSB0ZW1wUG9pbnRzWzBdLnNldChvdGhlci5sZWZ0LCBvdGhlci50b3ApO1xuICAgIGNvbnN0IGxiID0gdGVtcFBvaW50c1sxXS5zZXQob3RoZXIubGVmdCwgb3RoZXIuYm90dG9tKTtcbiAgICBjb25zdCBydCA9IHRlbXBQb2ludHNbMl0uc2V0KG90aGVyLnJpZ2h0LCBvdGhlci50b3ApO1xuICAgIGNvbnN0IHJiID0gdGVtcFBvaW50c1szXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLmJvdHRvbSk7XG4gICAgaWYgKHJ0LnggPD0gbHQueCB8fCBsYi55IDw9IGx0LnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcyA9IE1hdGguc2lnbih0cmFuc2Zvcm0uYSAqIHRyYW5zZm9ybS5kIC0gdHJhbnNmb3JtLmIgKiB0cmFuc2Zvcm0uYyk7XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtLmFwcGx5KGx0LCBsdCk7XG4gICAgdHJhbnNmb3JtLmFwcGx5KGxiLCBsYik7XG4gICAgdHJhbnNmb3JtLmFwcGx5KHJ0LCBydCk7XG4gICAgdHJhbnNmb3JtLmFwcGx5KHJiLCByYik7XG4gICAgaWYgKE1hdGgubWF4KGx0LngsIGxiLngsIHJ0LngsIHJiLngpIDw9IHgwIHx8IE1hdGgubWluKGx0LngsIGxiLngsIHJ0LngsIHJiLngpID49IHgxIHx8IE1hdGgubWF4KGx0LnksIGxiLnksIHJ0LnksIHJiLnkpIDw9IHkwIHx8IE1hdGgubWluKGx0LnksIGxiLnksIHJ0LnksIHJiLnkpID49IHkxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG54ID0gcyAqIChsYi55IC0gbHQueSk7XG4gICAgY29uc3QgbnkgPSBzICogKGx0LnggLSBsYi54KTtcbiAgICBjb25zdCBuMDAgPSBueCAqIHgwICsgbnkgKiB5MDtcbiAgICBjb25zdCBuMTAgPSBueCAqIHgxICsgbnkgKiB5MDtcbiAgICBjb25zdCBuMDEgPSBueCAqIHgwICsgbnkgKiB5MTtcbiAgICBjb25zdCBuMTEgPSBueCAqIHgxICsgbnkgKiB5MTtcbiAgICBpZiAoTWF0aC5tYXgobjAwLCBuMTAsIG4wMSwgbjExKSA8PSBueCAqIGx0LnggKyBueSAqIGx0LnkgfHwgTWF0aC5taW4objAwLCBuMTAsIG4wMSwgbjExKSA+PSBueCAqIHJiLnggKyBueSAqIHJiLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbXggPSBzICogKGx0LnkgLSBydC55KTtcbiAgICBjb25zdCBteSA9IHMgKiAocnQueCAtIGx0LngpO1xuICAgIGNvbnN0IG0wMCA9IG14ICogeDAgKyBteSAqIHkwO1xuICAgIGNvbnN0IG0xMCA9IG14ICogeDEgKyBteSAqIHkwO1xuICAgIGNvbnN0IG0wMSA9IG14ICogeDAgKyBteSAqIHkxO1xuICAgIGNvbnN0IG0xMSA9IG14ICogeDEgKyBteSAqIHkxO1xuICAgIGlmIChNYXRoLm1heChtMDAsIG0xMCwgbTAxLCBtMTEpIDw9IG14ICogbHQueCArIG15ICogbHQueSB8fCBNYXRoLm1pbihtMDAsIG0xMCwgbTAxLCBtMTEpID49IG14ICogcmIueCArIG15ICogcmIueSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKiBJZiBwYWRkaW5nWSBpcyBvbWl0dGVkLCBib3RoIHBhZGRpbmdYIGFuZCBwYWRkaW5nWSB3aWxsIGJlIHNldCB0byBwYWRkaW5nWC5cbiAgICogQHBhcmFtIHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwYXJhbSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgdGhpcy54IC09IHBhZGRpbmdYO1xuICAgIHRoaXMueSAtPSBwYWRkaW5nWTtcbiAgICB0aGlzLndpZHRoICs9IHBhZGRpbmdYICogMjtcbiAgICB0aGlzLmhlaWdodCArPSBwYWRkaW5nWSAqIDI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZpdHMgdGhpcyByZWN0YW5nbGUgYXJvdW5kIHRoZSBwYXNzZWQgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBmaXQuXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgZml0KHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgY29uc3QgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3RhbmdsZS55KTtcbiAgICBjb25zdCB5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHgxO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCh4MiAtIHgxLCAwKTtcbiAgICB0aGlzLnkgPSB5MTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHkyIC0geTEsIDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmxhcmdlcyByZWN0YW5nbGUgdGhhdCB3YXkgaXRzIGNvcm5lcnMgbGllIG9uIGdyaWRcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSByZXNvbHV0aW9uXG4gICAqIEBwYXJhbSBlcHMgLSBwcmVjaXNpb25cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjZWlsKHJlc29sdXRpb24gPSAxLCBlcHMgPSAxZS0zKSB7XG4gICAgY29uc3QgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCh0aGlzLnkgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueDtcbiAgICB0aGlzLmhlaWdodCA9IHkyIC0gdGhpcy55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmxhcmdlcyB0aGlzIHJlY3RhbmdsZSB0byBpbmNsdWRlIHRoZSBwYXNzZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBpbmNsdWRlLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGVubGFyZ2UocmVjdGFuZ2xlKSB7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHkxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcmVjdGFuZ2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcGFyYW0gb3V0IC0gb3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMob3V0KSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBSZWN0YW5nbGUoKTtcbiAgICBvdXQuY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6UmVjdGFuZ2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3904\n')},2971:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ BatchGeometry)\n/* harmony export */ });\n/* harmony import */ var _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7494);\n/* harmony import */ var _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n/* harmony import */ var _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n\n\n\n\n"use strict";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderBufferData,\n      label: "attribute-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.VERTEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderIndexData,\n      label: "index-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.INDEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 0,\n          location: 1\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 2 * 4,\n          location: 3\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: "unorm8x4",\n          stride,\n          offset: 4 * 4,\n          location: 0\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: "uint16x2",\n          stride,\n          offset: 5 * 4,\n          location: 2\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0U7QUFDSTtBQUNFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0ZBQVE7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxnRkFBTTtBQUN0QztBQUNBO0FBQ0EsYUFBYSxvRkFBVyxVQUFVLG9GQUFXO0FBQzdDO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixnRkFBTTtBQUNsQztBQUNBO0FBQ0EsYUFBYSxvRkFBVyxTQUFTLG9GQUFXO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvQmF0Y2hHZW9tZXRyeS5tanM/N2Q2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHBsYWNlSG9sZGVyQnVmZmVyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCBwbGFjZUhvbGRlckluZGV4RGF0YSA9IG5ldyBVaW50MzJBcnJheSgxKTtcbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHZlcnRleFNpemUgPSA2O1xuICAgIGNvbnN0IGF0dHJpYnV0ZUJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogcGxhY2VIb2xkZXJCdWZmZXJEYXRhLFxuICAgICAgbGFiZWw6IFwiYXR0cmlidXRlLWJhdGNoLWJ1ZmZlclwiLFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgc2hyaW5rVG9GaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHBsYWNlSG9sZGVySW5kZXhEYXRhLFxuICAgICAgbGFiZWw6IFwiaW5kZXgtYmF0Y2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuSU5ERVggfCBCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICAgIC8vIHwgQnVmZmVyVXNhZ2UuU1RBVElDLFxuICAgICAgc2hyaW5rVG9GaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3Qgc3RyaWRlID0gdmVydGV4U2l6ZSAqIDQ7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBhUG9zaXRpb246IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICBsb2NhdGlvbjogMVxuICAgICAgICB9LFxuICAgICAgICBhVVY6IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogMiAqIDQsXG4gICAgICAgICAgbG9jYXRpb246IDNcbiAgICAgICAgfSxcbiAgICAgICAgYUNvbG9yOiB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcInVub3JtOHg0XCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogNCAqIDQsXG4gICAgICAgICAgbG9jYXRpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgYVRleHR1cmVJZEFuZFJvdW5kOiB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcInVpbnQxNngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogNSAqIDQsXG4gICAgICAgICAgbG9jYXRpb246IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluZGV4QnVmZmVyXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2971\n')},3018:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ getTextureBatchBindGroup)\n/* harmony export */ });\n/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9818);\n/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4589);\n\n\n\n\n"use strict";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 0;\n  for (let i = 0; i < size; i++) {\n    uid = uid * 31 + textures[i].uid >>> 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, uid);\n}\nfunction generateTextureBatchBindGroup(textures, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  for (let i = 0; i < _shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A; i++) {\n    const texture = i < textures.length ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\n\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAxOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7QUFDQTtBQUNsQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLG9FQUFZLEVBQUU7QUFDcEMsd0RBQXdELG1GQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRkFBUztBQUNqQztBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L2dldFRleHR1cmVCYXRjaEJpbmRHcm91cC5tanM/YjAyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaW5kR3JvdXAgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvZ3B1L3NoYWRlci9CaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgTUFYX1RFWFRVUkVTIH0gZnJvbSAnLi4vc2hhcmVkL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY2FjaGVkR3JvdXBzID0ge307XG5mdW5jdGlvbiBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUpIHtcbiAgbGV0IHVpZCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdWlkID0gdWlkICogMzEgKyB0ZXh0dXJlc1tpXS51aWQgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZEdyb3Vwc1t1aWRdIHx8IGdlbmVyYXRlVGV4dHVyZUJhdGNoQmluZEdyb3VwKHRleHR1cmVzLCB1aWQpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIGtleSkge1xuICBjb25zdCBiaW5kR3JvdXBSZXNvdXJjZXMgPSB7fTtcbiAgbGV0IGJpbmRJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX1RFWFRVUkVTOyBpKyspIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gaSA8IHRleHR1cmVzLmxlbmd0aCA/IHRleHR1cmVzW2ldIDogVGV4dHVyZS5FTVBUWS5zb3VyY2U7XG4gICAgYmluZEdyb3VwUmVzb3VyY2VzW2JpbmRJbmRleCsrXSA9IHRleHR1cmUuc291cmNlO1xuICAgIGJpbmRHcm91cFJlc291cmNlc1tiaW5kSW5kZXgrK10gPSB0ZXh0dXJlLnN0eWxlO1xuICB9XG4gIGNvbnN0IGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoYmluZEdyb3VwUmVzb3VyY2VzKTtcbiAgY2FjaGVkR3JvdXBzW2tleV0gPSBiaW5kR3JvdXA7XG4gIHJldHVybiBiaW5kR3JvdXA7XG59XG5cbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3018\n')},2067:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  m: () => (/* binding */ Batcher)\n});\n\n// UNUSED EXPORTS: Batch\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs\n\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6633);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(2475);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\n\n\n"use strict";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === "no-premultiply-alpha") {\n    return state_const/* BLEND_TO_NPM */.f[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\n\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs\n\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs\nvar shared_const = __webpack_require__(4589);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs\n\n\n\n\n\n\n\n"use strict";\nclass Batch {\n  constructor() {\n    this.renderPipeId = "batch";\n    this.action = "startBatch";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = "normal";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = (0,uid/* uid */.h)("batcher");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart])\n      return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = "startBatch";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= shared_const/* MAX_TEXTURES */.A || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = "renderBatch";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    (0,fastCopy/* fastCopy */.T)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      (0,fastCopy/* fastCopy */.T)(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\n\n\n//# sourceMappingURL=Batcher.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsSUFBSSw0QkFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSw0QkFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2RhdGEvVmlld2FibGVCdWZmZXIubWpzPzNhMTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZC5tanM/ZDcwMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hUZXh0dXJlQXJyYXkubWpzP2JmMDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzPzcwZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBWaWV3YWJsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHNpemVPckJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZU9yQnVmZmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZU9yQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNpemVPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlci5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnJhd0JpbmFyeURhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEludDhBcnJheWAuICovXG4gIGdldCBpbnQ4VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDhWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQ4VmlldyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDhWaWV3O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgVWludDhBcnJheWAuICovXG4gIGdldCB1aW50OFZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl91aW50OFZpZXcpIHtcbiAgICAgIHRoaXMuX3VpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91aW50OFZpZXc7XG4gIH1cbiAgLyoqICBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50MTZBcnJheWAuICovXG4gIGdldCBpbnQxNlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQxNlZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDE2VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQxNlZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBJbnQzMkFycmF5YC4gKi9cbiAgZ2V0IGludDMyVmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDMyVmlldykge1xuICAgICAgdGhpcy5faW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDMyVmlldztcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEZsb2F0NjRBcnJheWAuICovXG4gIGdldCBmbG9hdDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2Zsb2F0NjRBcnJheSkge1xuICAgICAgdGhpcy5fZmxvYXQ2NEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmxvYXQ2NEFycmF5O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgQmlnVWludDY0QXJyYXlgLiAqL1xuICBnZXQgYmlnVWludDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2JpZ1VpbnQ2NEFycmF5KSB7XG4gICAgICB0aGlzLl9iaWdVaW50NjRBcnJheSA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmlnVWludDY0QXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpZXcgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIC0gT25lIG9mIGBpbnQ4YCwgYHVpbnQ4YCwgYGludDE2YCxcbiAgICogICAgYHVpbnQxNmAsIGBpbnQzMmAsIGB1aW50MzJgLCBhbmQgYGZsb2F0MzJgLlxuICAgKiBAcmV0dXJucyAtIHR5cGVkIGFycmF5IG9mIGdpdmVuIHR5cGVcbiAgICovXG4gIHZpZXcodHlwZSkge1xuICAgIHJldHVybiB0aGlzW2Ake3R5cGV9Vmlld2BdO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgYnVmZmVyIHJlZmVyZW5jZXMuIERvIG5vdCB1c2UgYWZ0ZXIgY2FsbGluZyB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IG51bGw7XG4gICAgdGhpcy5faW50OFZpZXcgPSBudWxsO1xuICAgIHRoaXMuX3VpbnQ4VmlldyA9IG51bGw7XG4gICAgdGhpcy5faW50MTZWaWV3ID0gbnVsbDtcbiAgICB0aGlzLnVpbnQxNlZpZXcgPSBudWxsO1xuICAgIHRoaXMuX2ludDMyVmlldyA9IG51bGw7XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbnVsbDtcbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gdHlwZSBpbiBieXRlcy5cbiAgICogQHBhcmFtIHR5cGUgLSBPbmUgb2YgYGludDhgLCBgdWludDhgLCBgaW50MTZgLFxuICAgKiAgIGB1aW50MTZgLCBgaW50MzJgLCBgdWludDMyYCwgYW5kIGBmbG9hdDMyYC5cbiAgICogQHJldHVybnMgLSBzaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzXG4gICAqL1xuICBzdGF0aWMgc2l6ZU9mKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzbid0IGEgdmFsaWQgdmlldyB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3YWJsZUJ1ZmZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCTEVORF9UT19OUE0gfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChibGVuZE1vZGUsIHRleHR1cmVTb3VyY2UpIHtcbiAgaWYgKHRleHR1cmVTb3VyY2UuYWxwaGFNb2RlID09PSBcIm5vLXByZW11bHRpcGx5LWFscGhhXCIpIHtcbiAgICByZXR1cm4gQkxFTkRfVE9fTlBNW2JsZW5kTW9kZV0gfHwgYmxlbmRNb2RlO1xuICB9XG4gIHJldHVybiBibGVuZE1vZGU7XG59XG5cbmV4cG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaFRleHR1cmVBcnJheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBSZXNwZWN0aXZlIGxvY2F0aW9ucyBmb3IgdGV4dHVyZXMuICovXG4gICAgdGhpcy5pZHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgLyoqIENsZWFyIHRoZSB0ZXh0dXJlcyBhbmQgdGhlaXIgbG9jYXRpb25zLiAqL1xuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdCA9IHRoaXMudGV4dHVyZXNbaV07XG4gICAgICB0aGlzLnRleHR1cmVzW2ldID0gbnVsbDtcbiAgICAgIHRoaXMuaWRzW3QudWlkXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFRleHR1cmVBcnJheS5tanMubWFwXG4iLCJpbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgVmlld2FibGVCdWZmZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL1ZpZXdhYmxlQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBmYXN0Q29weSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5pbXBvcnQgeyBnZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcyc7XG5pbXBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gJy4vQmF0Y2hUZXh0dXJlQXJyYXkubWpzJztcbmltcG9ydCB7IE1BWF9URVhUVVJFUyB9IGZyb20gJy4vY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJiYXRjaFwiO1xuICAgIHRoaXMuYWN0aW9uID0gXCJzdGFydEJhdGNoXCI7XG4gICAgLy8gVE9ETyAtIGV2ZW50dWFsbHkgdGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIGZsYWdnaW5nIGJhdGNoZXMgYXMgZGlydHkgYW5kIHRoZW4gb25seSByZWJ1aWxkaW5nIHRob3NlIG9uZXNcbiAgICAvLyBwdWJsaWMgZWxlbWVudFN0YXJ0ID0gMDtcbiAgICAvLyBwdWJsaWMgZWxlbWVudFNpemUgPSAwO1xuICAgIC8vIGZvciBkcmF3aW5nLi5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gXCJub3JtYWxcIjtcbiAgICB0aGlzLmNhbkJ1bmRsZSA9IHRydWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLmdwdUJpbmRHcm91cCA9IG51bGw7XG4gICAgdGhpcy5iaW5kR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gIH1cbn1cbmxldCBCQVRDSF9USUNLID0gMDtcbmNvbnN0IF9CYXRjaGVyID0gY2xhc3MgX0JhdGNoZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnVpZCA9IHVpZChcImJhdGNoZXJcIik7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5iYXRjaEluZGV4ID0gMDtcbiAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICAvLyBzcGVjaWZpY3MuXG4gICAgdGhpcy5fdmVydGV4U2l6ZSA9IDY7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9iYXRjaFBvb2wgPSBbXTtcbiAgICB0aGlzLl9iYXRjaFBvb2xJbmRleCA9IDA7XG4gICAgdGhpcy5fdGV4dHVyZUJhdGNoUG9vbCA9IFtdO1xuICAgIHRoaXMuX3RleHR1cmVCYXRjaFBvb2xJbmRleCA9IDA7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0JhdGNoZXIuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCB7IHZlcnRleFNpemUsIGluZGV4U2l6ZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcih2ZXJ0ZXhTaXplICogdGhpcy5fdmVydGV4U2l6ZSAqIDQpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoaW5kZXhTaXplKTtcbiAgfVxuICBiZWdpbigpIHtcbiAgICB0aGlzLmJhdGNoSW5kZXggPSAwO1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSAwO1xuICAgIHRoaXMuZWxlbWVudFN0YXJ0ID0gMDtcbiAgICB0aGlzLmluZGV4U2l6ZSA9IDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVTaXplID0gMDtcbiAgICB0aGlzLl9iYXRjaFBvb2xJbmRleCA9IDA7XG4gICAgdGhpcy5fdGV4dHVyZUJhdGNoUG9vbEluZGV4ID0gMDtcbiAgICB0aGlzLl9iYXRjaEluZGV4U3RhcnQgPSAwO1xuICAgIHRoaXMuX2JhdGNoSW5kZXhTaXplID0gMDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBhZGQoYmF0Y2hhYmxlT2JqZWN0KSB7XG4gICAgdGhpcy5fZWxlbWVudHNbdGhpcy5lbGVtZW50U2l6ZSsrXSA9IGJhdGNoYWJsZU9iamVjdDtcbiAgICBiYXRjaGFibGVPYmplY3QuaW5kZXhTdGFydCA9IHRoaXMuaW5kZXhTaXplO1xuICAgIGJhdGNoYWJsZU9iamVjdC5sb2NhdGlvbiA9IHRoaXMuYXR0cmlidXRlU2l6ZTtcbiAgICBiYXRjaGFibGVPYmplY3QuYmF0Y2hlciA9IHRoaXM7XG4gICAgdGhpcy5pbmRleFNpemUgKz0gYmF0Y2hhYmxlT2JqZWN0LmluZGV4U2l6ZTtcbiAgICB0aGlzLmF0dHJpYnV0ZVNpemUgKz0gYmF0Y2hhYmxlT2JqZWN0LnZlcnRleFNpemUgKiB0aGlzLl92ZXJ0ZXhTaXplO1xuICB9XG4gIGNoZWNrQW5kVXBkYXRlVGV4dHVyZShiYXRjaGFibGVPYmplY3QsIHRleHR1cmUpIHtcbiAgICBjb25zdCB0ZXh0dXJlSWQgPSBiYXRjaGFibGVPYmplY3QuYmF0Y2gudGV4dHVyZXMuaWRzW3RleHR1cmUuX3NvdXJjZS51aWRdO1xuICAgIGlmICghdGV4dHVyZUlkICYmIHRleHR1cmVJZCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBiYXRjaGFibGVPYmplY3QudGV4dHVyZUlkID0gdGV4dHVyZUlkO1xuICAgIGJhdGNoYWJsZU9iamVjdC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGVFbGVtZW50KGJhdGNoYWJsZU9iamVjdCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIGJhdGNoYWJsZU9iamVjdC5wYWNrQXR0cmlidXRlcyhcbiAgICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyLmZsb2F0MzJWaWV3LFxuICAgICAgdGhpcy5hdHRyaWJ1dGVCdWZmZXIudWludDMyVmlldyxcbiAgICAgIGJhdGNoYWJsZU9iamVjdC5sb2NhdGlvbixcbiAgICAgIGJhdGNoYWJsZU9iamVjdC50ZXh0dXJlSWRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBicmVha3MgdGhlIGJhdGNoZXIuIFRoaXMgaGFwcGVucyB3aGVuIGEgYmF0Y2ggZ2V0cyB0b28gYmlnLFxuICAgKiBvciB3ZSBuZWVkIHRvIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0eXBlIG9mIHJlbmRlcmluZyAoYSBmaWx0ZXIgZm9yIGV4YW1wbGUpXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvblNldFxuICAgKi9cbiAgYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzO1xuICAgIGxldCB0ZXh0dXJlQmF0Y2ggPSB0aGlzLl90ZXh0dXJlQmF0Y2hQb29sW3RoaXMuX3RleHR1cmVCYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2hUZXh0dXJlQXJyYXkoKTtcbiAgICB0ZXh0dXJlQmF0Y2guY2xlYXIoKTtcbiAgICBpZiAoIWVsZW1lbnRzW3RoaXMuZWxlbWVudFN0YXJ0XSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBlbGVtZW50c1t0aGlzLmVsZW1lbnRTdGFydF07XG4gICAgbGV0IGJsZW5kTW9kZSA9IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQoZmlyc3RFbGVtZW50LmJsZW5kTW9kZSwgZmlyc3RFbGVtZW50LnRleHR1cmUuX3NvdXJjZSk7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlU2l6ZSAqIDQgPiB0aGlzLmF0dHJpYnV0ZUJ1ZmZlci5zaXplKSB7XG4gICAgICB0aGlzLl9yZXNpemVBdHRyaWJ1dGVCdWZmZXIodGhpcy5hdHRyaWJ1dGVTaXplICogNCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluZGV4U2l6ZSA+IHRoaXMuaW5kZXhCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yZXNpemVJbmRleEJ1ZmZlcih0aGlzLmluZGV4U2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGYzMiA9IHRoaXMuYXR0cmlidXRlQnVmZmVyLmZsb2F0MzJWaWV3O1xuICAgIGNvbnN0IHUzMiA9IHRoaXMuYXR0cmlidXRlQnVmZmVyLnVpbnQzMlZpZXc7XG4gICAgY29uc3QgaUJ1ZmZlciA9IHRoaXMuaW5kZXhCdWZmZXI7XG4gICAgbGV0IHNpemUgPSB0aGlzLl9iYXRjaEluZGV4U2l6ZTtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLl9iYXRjaEluZGV4U3RhcnQ7XG4gICAgbGV0IGFjdGlvbiA9IFwic3RhcnRCYXRjaFwiO1xuICAgIGxldCBiYXRjaCA9IHRoaXMuX2JhdGNoUG9vbFt0aGlzLl9iYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2goKTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5lbGVtZW50U3RhcnQ7IGkgPCB0aGlzLmVsZW1lbnRTaXplOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGVsZW1lbnRzW2ldID0gbnVsbDtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBlbGVtZW50LnRleHR1cmU7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLl9zb3VyY2U7XG4gICAgICBjb25zdCBhZGp1c3RlZEJsZW5kTW9kZSA9IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQoZWxlbWVudC5ibGVuZE1vZGUsIHNvdXJjZSk7XG4gICAgICBjb25zdCBibGVuZE1vZGVDaGFuZ2UgPSBibGVuZE1vZGUgIT09IGFkanVzdGVkQmxlbmRNb2RlO1xuICAgICAgaWYgKHNvdXJjZS5fYmF0Y2hUaWNrID09PSBCQVRDSF9USUNLICYmICFibGVuZE1vZGVDaGFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC50ZXh0dXJlSWQgPSBzb3VyY2UuX3RleHR1cmVCaW5kTG9jYXRpb247XG4gICAgICAgIHNpemUgKz0gZWxlbWVudC5pbmRleFNpemU7XG4gICAgICAgIGVsZW1lbnQucGFja0F0dHJpYnV0ZXMoZjMyLCB1MzIsIGVsZW1lbnQubG9jYXRpb24sIGVsZW1lbnQudGV4dHVyZUlkKTtcbiAgICAgICAgZWxlbWVudC5wYWNrSW5kZXgoaUJ1ZmZlciwgZWxlbWVudC5pbmRleFN0YXJ0LCBlbGVtZW50LmxvY2F0aW9uIC8gdGhpcy5fdmVydGV4U2l6ZSk7XG4gICAgICAgIGVsZW1lbnQuYmF0Y2ggPSBiYXRjaDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuX2JhdGNoVGljayA9IEJBVENIX1RJQ0s7XG4gICAgICBpZiAodGV4dHVyZUJhdGNoLmNvdW50ID49IE1BWF9URVhUVVJFUyB8fCBibGVuZE1vZGVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoQmF0Y2goXG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgc2l6ZSAtIHN0YXJ0LFxuICAgICAgICAgIHRleHR1cmVCYXRjaCxcbiAgICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25TZXQsXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGFjdGlvbiA9IFwicmVuZGVyQmF0Y2hcIjtcbiAgICAgICAgc3RhcnQgPSBzaXplO1xuICAgICAgICBibGVuZE1vZGUgPSBhZGp1c3RlZEJsZW5kTW9kZTtcbiAgICAgICAgdGV4dHVyZUJhdGNoID0gdGhpcy5fdGV4dHVyZUJhdGNoUG9vbFt0aGlzLl90ZXh0dXJlQmF0Y2hQb29sSW5kZXgrK10gfHwgbmV3IEJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgICAgIHRleHR1cmVCYXRjaC5jbGVhcigpO1xuICAgICAgICBiYXRjaCA9IHRoaXMuX2JhdGNoUG9vbFt0aGlzLl9iYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2goKTtcbiAgICAgICAgKytCQVRDSF9USUNLO1xuICAgICAgfVxuICAgICAgZWxlbWVudC50ZXh0dXJlSWQgPSBzb3VyY2UuX3RleHR1cmVCaW5kTG9jYXRpb24gPSB0ZXh0dXJlQmF0Y2guY291bnQ7XG4gICAgICB0ZXh0dXJlQmF0Y2guaWRzW3NvdXJjZS51aWRdID0gdGV4dHVyZUJhdGNoLmNvdW50O1xuICAgICAgdGV4dHVyZUJhdGNoLnRleHR1cmVzW3RleHR1cmVCYXRjaC5jb3VudCsrXSA9IHNvdXJjZTtcbiAgICAgIGVsZW1lbnQuYmF0Y2ggPSBiYXRjaDtcbiAgICAgIHNpemUgKz0gZWxlbWVudC5pbmRleFNpemU7XG4gICAgICBlbGVtZW50LnBhY2tBdHRyaWJ1dGVzKGYzMiwgdTMyLCBlbGVtZW50LmxvY2F0aW9uLCBlbGVtZW50LnRleHR1cmVJZCk7XG4gICAgICBlbGVtZW50LnBhY2tJbmRleChpQnVmZmVyLCBlbGVtZW50LmluZGV4U3RhcnQsIGVsZW1lbnQubG9jYXRpb24gLyB0aGlzLl92ZXJ0ZXhTaXplKTtcbiAgICB9XG4gICAgaWYgKHRleHR1cmVCYXRjaC5jb3VudCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpbmlzaEJhdGNoKFxuICAgICAgICBiYXRjaCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHNpemUgLSBzdGFydCxcbiAgICAgICAgdGV4dHVyZUJhdGNoLFxuICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgIGluc3RydWN0aW9uU2V0LFxuICAgICAgICBhY3Rpb25cbiAgICAgICk7XG4gICAgICBzdGFydCA9IHNpemU7XG4gICAgICArK0JBVENIX1RJQ0s7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudFN0YXJ0ID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB0aGlzLl9iYXRjaEluZGV4U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9iYXRjaEluZGV4U2l6ZSA9IHNpemU7XG4gIH1cbiAgX2ZpbmlzaEJhdGNoKGJhdGNoLCBpbmRleFN0YXJ0LCBpbmRleFNpemUsIHRleHR1cmVCYXRjaCwgYmxlbmRNb2RlLCBpbnN0cnVjdGlvblNldCwgYWN0aW9uKSB7XG4gICAgYmF0Y2guZ3B1QmluZEdyb3VwID0gbnVsbDtcbiAgICBiYXRjaC5hY3Rpb24gPSBhY3Rpb247XG4gICAgYmF0Y2guYmF0Y2hlciA9IHRoaXM7XG4gICAgYmF0Y2gudGV4dHVyZXMgPSB0ZXh0dXJlQmF0Y2g7XG4gICAgYmF0Y2guYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIGJhdGNoLnN0YXJ0ID0gaW5kZXhTdGFydDtcbiAgICBiYXRjaC5zaXplID0gaW5kZXhTaXplO1xuICAgICsrQkFUQ0hfVElDSztcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoYmF0Y2gpO1xuICB9XG4gIGZpbmlzaChpbnN0cnVjdGlvblNldCkge1xuICAgIHRoaXMuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBhdHRyaWJ1dGUgYnVmZmVyIHRvIHRoZSBnaXZlbiBzaXplICgxID0gMSBmbG9hdDMyKVxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIGluIHZlcnRpY2VzIHRvIGVuc3VyZSAobm90IGJ5dGVzISlcbiAgICovXG4gIGVuc3VyZUF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XG4gICAgaWYgKHNpemUgKiA0IDw9IHRoaXMuYXR0cmlidXRlQnVmZmVyLnNpemUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVzaXplQXR0cmlidXRlQnVmZmVyKHNpemUgKiA0KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgaW5kZXggYnVmZmVyIHRvIHRoZSBnaXZlbiBzaXplICgxID0gMSBmbG9hdDMyKVxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIGluIHZlcnRpY2VzIHRvIGVuc3VyZSAobm90IGJ5dGVzISlcbiAgICovXG4gIGVuc3VyZUluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSB0aGlzLmluZGV4QnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9yZXNpemVJbmRleEJ1ZmZlcihzaXplKTtcbiAgfVxuICBfcmVzaXplQXR0cmlidXRlQnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCBuZXdTaXplID0gTWF0aC5tYXgoc2l6ZSwgdGhpcy5hdHRyaWJ1dGVCdWZmZXIuc2l6ZSAqIDIpO1xuICAgIGNvbnN0IG5ld0FycmF5QnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKG5ld1NpemUpO1xuICAgIGZhc3RDb3B5KHRoaXMuYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEsIG5ld0FycmF5QnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyID0gbmV3QXJyYXlCdWZmZXI7XG4gIH1cbiAgX3Jlc2l6ZUluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IHRoaXMuaW5kZXhCdWZmZXI7XG4gICAgbGV0IG5ld1NpemUgPSBNYXRoLm1heChzaXplLCBpbmRleEJ1ZmZlci5sZW5ndGggKiAxLjUpO1xuICAgIG5ld1NpemUgKz0gbmV3U2l6ZSAlIDI7XG4gICAgY29uc3QgbmV3SW5kZXhCdWZmZXIgPSBuZXdTaXplID4gNjU1MzUgPyBuZXcgVWludDMyQXJyYXkobmV3U2l6ZSkgOiBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XG4gICAgaWYgKG5ld0luZGV4QnVmZmVyLkJZVEVTX1BFUl9FTEVNRU5UICE9PSBpbmRleEJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdJbmRleEJ1ZmZlcltpXSA9IGluZGV4QnVmZmVyW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmYXN0Q29weShpbmRleEJ1ZmZlci5idWZmZXIsIG5ld0luZGV4QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXdJbmRleEJ1ZmZlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJhdGNoZXNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VsZW1lbnRzW2ldLmJhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudHMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG51bGw7XG4gIH1cbn07XG5fQmF0Y2hlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgdmVydGV4U2l6ZTogNCxcbiAgaW5kZXhTaXplOiA2XG59O1xubGV0IEJhdGNoZXIgPSBfQmF0Y2hlcjtcblxuZXhwb3J0IHsgQmF0Y2gsIEJhdGNoZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2067\n')},4589:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ MAX_TEXTURES)\n/* harmony export */ });\n\nconst MAX_TEXTURES = 16;\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU4OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL3NoYXJlZC9jb25zdC5tanM/MmEwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IE1BWF9URVhUVVJFUyA9IDE2O1xuXG5leHBvcnQgeyBNQVhfVEVYVFVSRVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4589\n")},8713:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(5263);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(5128);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs\n\n\n\n"use strict";\nconst tempBounds = new Bounds/* Bounds */.Y();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  (0,getGlobalBounds/* getGlobalBounds */.qW)(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\n\n//# sourceMappingURL=addMaskBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(3197);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs\n\n\n\n\n"use strict";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = matrixAndBoundsPool/* boundsPool */.W.get();\n  mask.measurable = true;\n  const tempMatrix = matrixAndBoundsPool/* matrixPool */.N.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  (0,getLocalBounds/* getLocalBounds */.a)(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixAndBoundsPool/* matrixPool */.N.return(tempMatrix);\n  matrixAndBoundsPool/* boundsPool */.W.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    (0,warn/* warn */.Z)("Mask bounds, renderable is not inside the root container");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\n\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs\n\n\n\n\n\n"use strict";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "alphaMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite/* Sprite */.j);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite/* Sprite */.j;\n  }\n}\nAlphaMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=AlphaMask.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs\n\n\n"use strict";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "colorMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === "number";\n  }\n}\nColorMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=ColorMask.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs\n\n\n\n\n\n"use strict";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "stencilMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container/* Container */.W2;\n  }\n}\nStencilMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=StencilMask.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs\nvar BufferSource = __webpack_require__(4758);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(6914);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs\nvar VideoSource = __webpack_require__(914);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4325);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(AlphaMask, ColorMask, StencilMask, VideoSource/* VideoSource */.L, ImageSource/* ImageSource */.c, CanvasSource/* CanvasSource */.D, BufferSource/* BufferImageSource */.A);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcxMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9FO0FBQ2tCOztBQUV0RjtBQUNBLHVCQUF1QixvQkFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJDQUFlO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFeUI7QUFDekI7Ozs7Ozs7OztBQ2RvRjtBQUNtQjtBQUNoRDs7QUFFdkQ7QUFDQTtBQUNBLHVCQUF1QixxQ0FBVTtBQUNqQztBQUNBLHFCQUFxQixxQ0FBVTtBQUMvQjtBQUNBLEVBQUUsd0NBQWM7QUFDaEI7QUFDQTtBQUNBLEVBQUUscUNBQVU7QUFDWixFQUFFLHFDQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUQ7QUFDekQ7OztBQzlCbUU7QUFDVDtBQUNDO0FBQ1U7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0JBQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQU07QUFDakM7QUFDQTtBQUNBLHNCQUFzQixnQ0FBYTs7QUFFZDtBQUNyQjs7O0FDN0NtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFhOztBQUVkO0FBQ3JCOzs7OztBQ3ZCbUU7QUFDQTtBQUNSO0FBQ1U7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBUztBQUNwQztBQUNBO0FBQ0Esd0JBQXdCLGdDQUFhOztBQUVkO0FBQ3ZCOzs7Ozs7Ozs7Ozs7O0FDNUMwRDtBQUNIO0FBQ0E7QUFDTTtBQUMyQjtBQUNMO0FBQ0Y7QUFDQTtBQUN2QjtBQUNwQjs7QUFFdEM7QUFDQSw2QkFBVSxLQUFLLFNBQVMsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLDhCQUFXLEVBQUUsOEJBQVcsRUFBRSxnQ0FBWSxFQUFFLHFDQUFpQjtBQUMzRyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9tYXNrL3V0aWxzL2FkZE1hc2tCb3VuZHMubWpzPzcxYWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svdXRpbHMvYWRkTWFza0xvY2FsQm91bmRzLm1qcz81NTM5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9tYXNrL2FscGhhL0FscGhhTWFzay5tanM/NWExYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvbWFzay9jb2xvci9Db2xvck1hc2subWpzP2IyOWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svc3RlbmNpbC9TdGVuY2lsTWFzay5tanM/NjY5YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvaW5pdC5tanM/OTlmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRHbG9iYWxCb3VuZHMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gYWRkTWFza0JvdW5kcyhtYXNrLCBib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgY29uc3QgYm91bmRzVG9NYXNrID0gdGVtcEJvdW5kcztcbiAgbWFzay5tZWFzdXJhYmxlID0gdHJ1ZTtcbiAgZ2V0R2xvYmFsQm91bmRzKG1hc2ssIHNraXBVcGRhdGVUcmFuc2Zvcm0sIGJvdW5kc1RvTWFzayk7XG4gIGJvdW5kcy5hZGRCb3VuZHNNYXNrKGJvdW5kc1RvTWFzayk7XG4gIG1hc2subWVhc3VyYWJsZSA9IGZhbHNlO1xufVxuXG5leHBvcnQgeyBhZGRNYXNrQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRNYXNrQm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCB7IGdldExvY2FsQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRMb2NhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgYm91bmRzUG9vbCwgbWF0cml4UG9vbCB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFkZE1hc2tMb2NhbEJvdW5kcyhtYXNrLCBib3VuZHMsIGxvY2FsUm9vdCkge1xuICBjb25zdCBib3VuZHNUb01hc2sgPSBib3VuZHNQb29sLmdldCgpO1xuICBtYXNrLm1lYXN1cmFibGUgPSB0cnVlO1xuICBjb25zdCB0ZW1wTWF0cml4ID0gbWF0cml4UG9vbC5nZXQoKS5pZGVudGl0eSgpO1xuICBjb25zdCByZWxhdGl2ZU1hc2sgPSBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50KG1hc2ssIGxvY2FsUm9vdCwgdGVtcE1hdHJpeCk7XG4gIGdldExvY2FsQm91bmRzKG1hc2ssIGJvdW5kc1RvTWFzaywgcmVsYXRpdmVNYXNrKTtcbiAgbWFzay5tZWFzdXJhYmxlID0gZmFsc2U7XG4gIGJvdW5kcy5hZGRCb3VuZHNNYXNrKGJvdW5kc1RvTWFzayk7XG4gIG1hdHJpeFBvb2wucmV0dXJuKHRlbXBNYXRyaXgpO1xuICBib3VuZHNQb29sLnJldHVybihib3VuZHNUb01hc2spO1xufVxuZnVuY3Rpb24gZ2V0TWF0cml4UmVsYXRpdmVUb1BhcmVudCh0YXJnZXQsIHJvb3QsIG1hdHJpeCkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHdhcm4oXCJNYXNrIGJvdW5kcywgcmVuZGVyYWJsZSBpcyBub3QgaW5zaWRlIHRoZSByb290IGNvbnRhaW5lclwiKTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIGlmICh0YXJnZXQgIT09IHJvb3QpIHtcbiAgICBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50KHRhcmdldC5wYXJlbnQsIHJvb3QsIG1hdHJpeCk7XG4gICAgdGFyZ2V0LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgbWF0cml4LmFwcGVuZCh0YXJnZXQubG9jYWxUcmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmV4cG9ydCB7IGFkZE1hc2tMb2NhbEJvdW5kcywgZ2V0TWF0cml4UmVsYXRpdmVUb1BhcmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkTWFza0xvY2FsQm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzJztcbmltcG9ydCB7IGFkZE1hc2tCb3VuZHMgfSBmcm9tICcuLi91dGlscy9hZGRNYXNrQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBhZGRNYXNrTG9jYWxCb3VuZHMgfSBmcm9tICcuLi91dGlscy9hZGRNYXNrTG9jYWxCb3VuZHMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBbHBoYU1hc2sge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5wcmlvcml0eSA9IDA7XG4gICAgdGhpcy5waXBlID0gXCJhbHBoYU1hc2tcIjtcbiAgICBpZiAob3B0aW9ucz8ubWFzaykge1xuICAgICAgdGhpcy5pbml0KG9wdGlvbnMubWFzayk7XG4gICAgfVxuICB9XG4gIGluaXQobWFzaykge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gICAgdGhpcy5yZW5kZXJNYXNrVG9UZXh0dXJlID0gIShtYXNrIGluc3RhbmNlb2YgU3ByaXRlKTtcbiAgICB0aGlzLm1hc2sucmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyTWFza1RvVGV4dHVyZTtcbiAgICB0aGlzLm1hc2suaW5jbHVkZUluQnVpbGQgPSAhdGhpcy5yZW5kZXJNYXNrVG9UZXh0dXJlO1xuICAgIHRoaXMubWFzay5tZWFzdXJhYmxlID0gZmFsc2U7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tYXNrLm1lYXN1cmFibGUgPSB0cnVlO1xuICAgIHRoaXMubWFzayA9IG51bGw7XG4gIH1cbiAgYWRkQm91bmRzKGJvdW5kcywgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgIGFkZE1hc2tCb3VuZHModGhpcy5tYXNrLCBib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pO1xuICB9XG4gIGFkZExvY2FsQm91bmRzKGJvdW5kcywgbG9jYWxSb290KSB7XG4gICAgYWRkTWFza0xvY2FsQm91bmRzKHRoaXMubWFzaywgYm91bmRzLCBsb2NhbFJvb3QpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQsIGhpdFRlc3RGbikge1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLm1hc2s7XG4gICAgcmV0dXJuIGhpdFRlc3RGbihtYXNrLCBwb2ludCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgc3RhdGljIHRlc3QobWFzaykge1xuICAgIHJldHVybiBtYXNrIGluc3RhbmNlb2YgU3ByaXRlO1xuICB9XG59XG5BbHBoYU1hc2suZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0O1xuXG5leHBvcnQgeyBBbHBoYU1hc2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFscGhhTWFzay5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ29sb3JNYXNrIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHRoaXMucGlwZSA9IFwiY29sb3JNYXNrXCI7XG4gICAgaWYgKG9wdGlvbnM/Lm1hc2spIHtcbiAgICAgIHRoaXMuaW5pdChvcHRpb25zLm1hc2spO1xuICAgIH1cbiAgfVxuICBpbml0KG1hc2spIHtcbiAgICB0aGlzLm1hc2sgPSBtYXNrO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbiAgc3RhdGljIHRlc3QobWFzaykge1xuICAgIHJldHVybiB0eXBlb2YgbWFzayA9PT0gXCJudW1iZXJcIjtcbiAgfVxufVxuQ29sb3JNYXNrLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuTWFza0VmZmVjdDtcblxuZXhwb3J0IHsgQ29sb3JNYXNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hc2subWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgYWRkTWFza0JvdW5kcyB9IGZyb20gJy4uL3V0aWxzL2FkZE1hc2tCb3VuZHMubWpzJztcbmltcG9ydCB7IGFkZE1hc2tMb2NhbEJvdW5kcyB9IGZyb20gJy4uL3V0aWxzL2FkZE1hc2tMb2NhbEJvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFN0ZW5jaWxNYXNrIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHRoaXMucGlwZSA9IFwic3RlbmNpbE1hc2tcIjtcbiAgICBpZiAob3B0aW9ucz8ubWFzaykge1xuICAgICAgdGhpcy5pbml0KG9wdGlvbnMubWFzayk7XG4gICAgfVxuICB9XG4gIGluaXQobWFzaykge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gICAgdGhpcy5tYXNrLmluY2x1ZGVJbkJ1aWxkID0gZmFsc2U7XG4gICAgdGhpcy5tYXNrLm1lYXN1cmFibGUgPSBmYWxzZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1hc2subWVhc3VyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXNrLmluY2x1ZGVJbkJ1aWxkID0gdHJ1ZTtcbiAgICB0aGlzLm1hc2sgPSBudWxsO1xuICB9XG4gIGFkZEJvdW5kcyhib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICBhZGRNYXNrQm91bmRzKHRoaXMubWFzaywgYm91bmRzLCBza2lwVXBkYXRlVHJhbnNmb3JtKTtcbiAgfVxuICBhZGRMb2NhbEJvdW5kcyhib3VuZHMsIGxvY2FsUm9vdCkge1xuICAgIGFkZE1hc2tMb2NhbEJvdW5kcyh0aGlzLm1hc2ssIGJvdW5kcywgbG9jYWxSb290KTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50LCBoaXRUZXN0Rm4pIHtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5tYXNrO1xuICAgIHJldHVybiBoaXRUZXN0Rm4obWFzaywgcG9pbnQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIHN0YXRpYyB0ZXN0KG1hc2spIHtcbiAgICByZXR1cm4gbWFzayBpbnN0YW5jZW9mIENvbnRhaW5lcjtcbiAgfVxufVxuU3RlbmNpbE1hc2suZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0O1xuXG5leHBvcnQgeyBTdGVuY2lsTWFzayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RlbmNpbE1hc2subWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQWxwaGFNYXNrIH0gZnJvbSAnLi9tYXNrL2FscGhhL0FscGhhTWFzay5tanMnO1xuaW1wb3J0IHsgQ29sb3JNYXNrIH0gZnJvbSAnLi9tYXNrL2NvbG9yL0NvbG9yTWFzay5tanMnO1xuaW1wb3J0IHsgU3RlbmNpbE1hc2sgfSBmcm9tICcuL21hc2svc3RlbmNpbC9TdGVuY2lsTWFzay5tanMnO1xuaW1wb3J0IHsgQnVmZmVySW1hZ2VTb3VyY2UgfSBmcm9tICcuL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0J1ZmZlclNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzU291cmNlIH0gZnJvbSAnLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9DYW52YXNTb3VyY2UubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9JbWFnZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVmlkZW9Tb3VyY2UgfSBmcm9tICcuL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL1ZpZGVvU291cmNlLm1qcyc7XG5pbXBvcnQgJy4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL3RleHR1cmVGcm9tLm1qcyc7XG5pbXBvcnQgJy4vbWFzay9NYXNrRWZmZWN0TWFuYWdlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEFscGhhTWFzaywgQ29sb3JNYXNrLCBTdGVuY2lsTWFzaywgVmlkZW9Tb3VyY2UsIEltYWdlU291cmNlLCBDYW52YXNTb3VyY2UsIEJ1ZmZlckltYWdlU291cmNlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8713\n')},6582:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ CLEAR)\n/* harmony export */ });\n\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";\n  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";\n  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";\n  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";\n  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";\n  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";\n  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";\n  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";\n  return CLEAR2;\n})(CLEAR || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOztBQUVHO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9jb25zdC5tanM/N2RjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBDTEVBUiA9IC8qIEBfX1BVUkVfXyAqLyAoKENMRUFSMikgPT4ge1xuICBDTEVBUjJbQ0xFQVIyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIENMRUFSMltDTEVBUjJbXCJDT0xPUlwiXSA9IDE2Mzg0XSA9IFwiQ09MT1JcIjtcbiAgQ0xFQVIyW0NMRUFSMltcIlNURU5DSUxcIl0gPSAxMDI0XSA9IFwiU1RFTkNJTFwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiREVQVEhcIl0gPSAyNTZdID0gXCJERVBUSFwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiQ09MT1JfREVQVEhcIl0gPSAxNjY0MF0gPSBcIkNPTE9SX0RFUFRIXCI7XG4gIENMRUFSMltDTEVBUjJbXCJDT0xPUl9TVEVOQ0lMXCJdID0gMTc0MDhdID0gXCJDT0xPUl9TVEVOQ0lMXCI7XG4gIENMRUFSMltDTEVBUjJbXCJERVBUSF9TVEVOQ0lMXCJdID0gMTI4MF0gPSBcIkRFUFRIX1NURU5DSUxcIjtcbiAgQ0xFQVIyW0NMRUFSMltcIkFMTFwiXSA9IDE3NjY0XSA9IFwiQUxMXCI7XG4gIHJldHVybiBDTEVBUjI7XG59KShDTEVBUiB8fCB7fSk7XG5cbmV4cG9ydCB7IENMRUFSIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6582\n')},9818:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ BindGroup)\n/* harmony export */ });\n\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join("|");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    resource.on?.("change", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to \'touch\' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange() {\n    this._dirty = true;\n    this._updateKey();\n  }\n}\n\n\n//# sourceMappingURL=BindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgxOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanM/MzIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpbmRHcm91cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UgZW9mIHRoZSBCaW5kIEdyb3VwLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIC0gVGhlIHJlc291cmNlcyB0aGF0IGFyZSBib3VuZCB0b2dldGhlciBmb3IgdXNlIGJ5IGEgc2hhZGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzb3VyY2VzKSB7XG4gICAgLyoqIFRoZSByZXNvdXJjZXMgdGhhdCBhcmUgYm91bmQgdG9nZXRoZXIgZm9yIHVzZSBieSBhIHNoYWRlci4gKi9cbiAgICB0aGlzLnJlc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2ldO1xuICAgICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSwgaW5kZXgrKyk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUtleSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBrZXkgaWYgaXRzIGZsYWdnZWQgYXMgZGlydHkuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvXG4gICAqIG1hdGNoIHRoaXMgYmluZCBncm91cCB0byBhIFdlYkdQVSBCaW5kR3JvdXAuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfdXBkYXRlS2V5KCkge1xuICAgIGlmICghdGhpcy5fZGlydHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICBjb25zdCBrZXlQYXJ0cyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMucmVzb3VyY2VzKSB7XG4gICAgICBrZXlQYXJ0c1tpbmRleCsrXSA9IHRoaXMucmVzb3VyY2VzW2ldLl9yZXNvdXJjZUlkO1xuICAgIH1cbiAgICB0aGlzLl9rZXkgPSBrZXlQYXJ0cy5qb2luKFwifFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgcmVzb3VyY2UgYXQgYSBnaXZlbiBpbmRleC4gdGhpcyBmdW5jdGlvbiB3aWxsXG4gICAqIGVuc3VyZSB0aGF0IGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgKiBhbmQgYWRkZWQgdG8gdGhlIG5ldyByZXNvdXJjZS5cbiAgICogQHBhcmFtIHJlc291cmNlIC0gVGhlIHJlc291cmNlIHRvIHNldC5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHNldCB0aGUgcmVzb3VyY2UgYXQuXG4gICAqL1xuICBzZXRSZXNvdXJjZShyZXNvdXJjZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50UmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1tpbmRleF07XG4gICAgaWYgKHJlc291cmNlID09PSBjdXJyZW50UmVzb3VyY2UpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2Uub2ZmPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgcmVzb3VyY2Uub24/LihcImNoYW5nZVwiLCB0aGlzLm9uUmVzb3VyY2VDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMucmVzb3VyY2VzW2luZGV4XSA9IHJlc291cmNlO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb3VyY2UgYXQgdGhlIGN1cnJlbnQgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJlc291cmNlIHRvIGdldC5cbiAgICogQHJldHVybnMgLSBUaGUgcmVzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICovXG4gIGdldFJlc291cmNlKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzW2luZGV4XTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbnRlcm5hbGx5IHRvICd0b3VjaCcgZWFjaCByZXNvdXJjZSwgdG8gZW5zdXJlIHRoYXQgdGhlIEdDXG4gICAqIGtub3dzIHRoYXQgYWxsIHJlc291cmNlcyBpbiB0aGlzIGJpbmQgZ3JvdXAgYXJlIHN0aWxsIGJlaW5nIHVzZWQuXG4gICAqIEBwYXJhbSB0aWNrIC0gVGhlIGN1cnJlbnQgdGljay5cbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF90b3VjaCh0aWNrKSB7XG4gICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5yZXNvdXJjZXM7XG4gICAgZm9yIChjb25zdCBpIGluIHJlc291cmNlcykge1xuICAgICAgcmVzb3VyY2VzW2ldLl90b3VjaGVkID0gdGljaztcbiAgICB9XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgYmluZCBncm91cCBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMucmVzb3VyY2VzO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2ldO1xuICAgICAgcmVzb3VyY2Uub2ZmPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvdXJjZXMgPSBudWxsO1xuICB9XG4gIG9uUmVzb3VyY2VDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZUtleSgpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9818\n')},7494:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ Buffer)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4146);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6258);\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n\n\n\n\n"use strict";\nclass Buffer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = "buffer";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    } else {\n      this.descriptor.usage &= ~_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit("update", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit("update", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n        this.emit("change", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit("update", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit("update", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.emit("destroy", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUM7QUFDWTtBQUNYOztBQUUxQztBQUNBLHFCQUFxQiw4REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNERBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFXO0FBQzFDLE1BQU07QUFDTixnQ0FBZ0MsNERBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDJCQUEyQixpRUFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzPzJlMjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4vY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCdWZmZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCdWZmZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvcHRpb25zIGZvciB0aGUgYnVmZmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHsgZGF0YSwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHVzYWdlLCBsYWJlbCwgc2hyaW5rVG9GaXQgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBlbWl0cyB3aGVuIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgY2hhbmdlZCBzaGFwZSAoaS5lLiByZXNpemVkKVxuICAgICAqIGxldHRpbmcgdGhlIHJlbmRlcmVyIGtub3cgdGhhdCBpdCBuZWVkcyB0byBkaXNjYXJkIHRoZSBvbGQgYnVmZmVyIG9uIHRoZSBHUFUgYW5kIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogZW1pdHMgd2hlbiB0aGUgdW5kZXJseWluZyBidWZmZXIgZGF0YSBoYXMgYmVlbiB1cGRhdGVkLiBsZXR0aW5nIHRoZSByZW5kZXJlciBrbm93XG4gICAgICogdGhhdCBpdCBuZWVkcyB0byB1cGRhdGUgdGhlIGJ1ZmZlciBvbiB0aGUgR1BVXG4gICAgICogQGV2ZW50IHVwZGF0ZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGVtaXRzIHdoZW4gdGhlIGJ1ZmZlciBpcyBkZXN0cm95ZWQuIGxldHRpbmcgdGhlIHJlbmRlcmVyIGtub3cgdGhhdCBpdCBuZWVkcyB0byBkZXN0cm95IHRoZSBidWZmZXIgb24gdGhlIEdQVVxuICAgICAqIEBldmVudCBkZXN0cm95XG4gICAgICovXG4gICAgLyoqXG4gICAgICogYSB1bmlxdWUgaWQgZm9yIHRoaXMgdW5pZm9ybSBncm91cCB1c2VkIHRocm91Z2ggdGhlIHJlbmRlcmVyXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiYnVmZmVyXCIpO1xuICAgIC8qKlxuICAgICAqIGEgcmVzb3VyY2UgdHlwZSwgdXNlZCB0byBpZGVudGlmeSBob3cgdG8gaGFuZGxlIGl0IHdoZW4gaXRzIGluIGEgYmluZCBncm91cCAvIHNoYWRlciByZXNvdXJjZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZVR5cGUgPSBcImJ1ZmZlclwiO1xuICAgIC8qKlxuICAgICAqIHRoZSByZXNvdXJjZSBpZCB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGJ1aWxkIGJpbmQgZ3JvdXAga2V5c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgLyoqXG4gICAgICogdXNlZCBpbnRlcm5hbGx5IHRvIGtub3cgaWYgYSB1bmlmb3JtIGdyb3VwIHdhcyB1c2VkIGluIHRoZSBsYXN0IHJlbmRlciBwYXNzXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVJRCA9IDE7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIHRoZSBHUFUgYnVmZmVyIGJlIHNocnVuayB3aGVuIHRoZSBkYXRhIGJlY29tZXMgc21hbGxlcj9cbiAgICAgKiBjaGFuZ2luZyB0aGlzIHdpbGwgY2F1c2UgdGhlIGJ1ZmZlciB0byBiZSBkZXN0cm95ZWQgYW5kIGEgbmV3IG9uZSBjcmVhdGVkIG9uIHRoZSBHUFVcbiAgICAgKiB0aGlzIGNhbiBiZSBleHBlbnNpdmUsIGVzcGVjaWFsbHkgaWYgdGhlIGJ1ZmZlciBpcyBhbHJlYWR5IGJpZyBlbm91Z2ghXG4gICAgICogc2V0dGluZyB0aGlzIHRvIGZhbHNlIHdpbGwgcHJldmVudCB0aGUgYnVmZmVyIGZyb20gYmVpbmcgc2hydW5rLiBUaGlzIHdpbGwgeWllbGQgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICogaWYgeW91IGFyZSBjb25zdGFudGx5IHNldHRpbmcgZGF0YSB0aGF0IGlzIGNoYW5naW5nIHNpemUgb2Z0ZW4uXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuc2hyaW5rVG9GaXQgPSB0cnVlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICBzaXplID0gc2l6ZSA/PyBkYXRhPy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IG1hcHBlZEF0Q3JlYXRpb24gPSAhIWRhdGE7XG4gICAgdGhpcy5kZXNjcmlwdG9yID0ge1xuICAgICAgc2l6ZSxcbiAgICAgIHVzYWdlLFxuICAgICAgbWFwcGVkQXRDcmVhdGlvbixcbiAgICAgIGxhYmVsXG4gICAgfTtcbiAgICB0aGlzLnNocmlua1RvRml0ID0gc2hyaW5rVG9GaXQgPz8gdHJ1ZTtcbiAgfVxuICAvKiogdGhlIGRhdGEgaW4gdGhlIGJ1ZmZlciAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0RGF0YVdpdGhTaXplKHZhbHVlLCB2YWx1ZS5sZW5ndGgsIHRydWUpO1xuICB9XG4gIC8qKiB3aGV0aGVyIHRoZSBidWZmZXIgaXMgc3RhdGljIG9yIG5vdCAqL1xuICBnZXQgc3RhdGljKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRlc2NyaXB0b3IudXNhZ2UgJiBCdWZmZXJVc2FnZS5TVEFUSUMpO1xuICB9XG4gIHNldCBzdGF0aWModmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSB8PSBCdWZmZXJVc2FnZS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSAmPSB+QnVmZmVyVXNhZ2UuU1RBVElDO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGF0YSBpbiB0aGUgYnVmZmVyIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVwZGF0ZSB0aGUgYnVmZmVyIG9uIHRoZSBHUFUuXG4gICAqIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgZGF0YS5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIGRhdGEgdG8gc2V0XG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGRhdGEgaW4gYnl0ZXNcbiAgICogQHBhcmFtIHN5bmNHUFUgLSBzaG91bGQgdGhlIGJ1ZmZlciBiZSB1cGRhdGVkIG9uIHRoZSBHUFUgaW1tZWRpYXRlbHk/XG4gICAqL1xuICBzZXREYXRhV2l0aFNpemUodmFsdWUsIHNpemUsIHN5bmNHUFUpIHtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplICogdmFsdWUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgaWYgKHRoaXMuX2RhdGEgPT09IHZhbHVlKSB7XG4gICAgICBpZiAoc3luY0dQVSlcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgaWYgKG9sZERhdGEubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5zaHJpbmtUb0ZpdCAmJiB2YWx1ZS5ieXRlTGVuZ3RoIDwgb2xkRGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzeW5jR1BVKVxuICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRvci5zaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzeW5jR1BVKVxuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiB1cGRhdGVzIHRoZSBidWZmZXIgb24gdGhlIEdQVSB0byByZWZsZWN0IHRoZSBkYXRhIGluIHRoZSBidWZmZXIuXG4gICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCB1cGRhdGUgdGhlIGVudGlyZSBidWZmZXIuIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsXG4gICAqIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHNpemVJbkJ5dGVzIC0gdGhlIG5ldyBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXNcbiAgICovXG4gIHVwZGF0ZShzaXplSW5CeXRlcykge1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplSW5CeXRlcyA/PyB0aGlzLl91cGRhdGVTaXplO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgYnVmZmVyICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7494\n')},5324:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ BufferUsage)\n/* harmony export */ });\n\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";\n  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";\n  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";\n  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";\n  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";\n  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";\n  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";\n  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";\n  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";\n  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";\n  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";\n  return BufferUsage2;\n})(BufferUsage || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7O0FBRUc7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzP2JkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQnVmZmVyVXNhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChCdWZmZXJVc2FnZTIpID0+IHtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIk1BUF9SRUFEXCJdID0gMV0gPSBcIk1BUF9SRUFEXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJNQVBfV1JJVEVcIl0gPSAyXSA9IFwiTUFQX1dSSVRFXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJDT1BZX1NSQ1wiXSA9IDRdID0gXCJDT1BZX1NSQ1wiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiQ09QWV9EU1RcIl0gPSA4XSA9IFwiQ09QWV9EU1RcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIklOREVYXCJdID0gMTZdID0gXCJJTkRFWFwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiVkVSVEVYXCJdID0gMzJdID0gXCJWRVJURVhcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlVOSUZPUk1cIl0gPSA2NF0gPSBcIlVOSUZPUk1cIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlNUT1JBR0VcIl0gPSAxMjhdID0gXCJTVE9SQUdFXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJJTkRJUkVDVFwiXSA9IDI1Nl0gPSBcIklORElSRUNUXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJRVUVSWV9SRVNPTFZFXCJdID0gNTEyXSA9IFwiUVVFUllfUkVTT0xWRVwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiU1RBVElDXCJdID0gMTAyNF0gPSBcIlNUQVRJQ1wiO1xuICByZXR1cm4gQnVmZmVyVXNhZ2UyO1xufSkoQnVmZmVyVXNhZ2UgfHwge30pO1xuXG5leHBvcnQgeyBCdWZmZXJVc2FnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5324\n')},6633:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ fastCopy)\n/* harmony export */ });\n\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\n\n//# sourceMappingURL=fastCopy.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYzMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvdXRpbHMvZmFzdENvcHkubWpzPzJhNTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBmYXN0Q29weShzb3VyY2VCdWZmZXIsIGRlc3RpbmF0aW9uQnVmZmVyKSB7XG4gIGNvbnN0IGxlbmd0aERvdWJsZSA9IHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoIC8gOCB8IDA7XG4gIGNvbnN0IHNvdXJjZUZsb2F0NjRWaWV3ID0gbmV3IEZsb2F0NjRBcnJheShzb3VyY2VCdWZmZXIsIDAsIGxlbmd0aERvdWJsZSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uRmxvYXQ2NFZpZXcgPSBuZXcgRmxvYXQ2NEFycmF5KGRlc3RpbmF0aW9uQnVmZmVyLCAwLCBsZW5ndGhEb3VibGUpO1xuICBkZXN0aW5hdGlvbkZsb2F0NjRWaWV3LnNldChzb3VyY2VGbG9hdDY0Vmlldyk7XG4gIGNvbnN0IHJlbWFpbmluZ0J5dGVzID0gc291cmNlQnVmZmVyLmJ5dGVMZW5ndGggLSBsZW5ndGhEb3VibGUgKiA4O1xuICBpZiAocmVtYWluaW5nQnl0ZXMgPiAwKSB7XG4gICAgY29uc3Qgc291cmNlVWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlQnVmZmVyLCBsZW5ndGhEb3VibGUgKiA4LCByZW1haW5pbmdCeXRlcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25VaW50OFZpZXcgPSBuZXcgVWludDhBcnJheShkZXN0aW5hdGlvbkJ1ZmZlciwgbGVuZ3RoRG91YmxlICogOCwgcmVtYWluaW5nQnl0ZXMpO1xuICAgIGRlc3RpbmF0aW9uVWludDhWaWV3LnNldChzb3VyY2VVaW50OFZpZXcpO1xuICB9XG59XG5cbmV4cG9ydCB7IGZhc3RDb3B5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYXN0Q29weS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6633\n")},1980:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ Geometry)\n});\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7494);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(5324);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs\n\n\n\n"use strict";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer/* Buffer */.l)) {\n    let usage = index ? buffer_const/* BufferUsage */.F.INDEX : buffer_const/* BufferUsage */.F.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.INDEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.VERTEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      }\n    }\n    buffer = new Buffer/* Buffer */.l({\n      data: buffer,\n      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",\n      usage\n    });\n  }\n  return buffer;\n}\n\n\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs\n\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getGeometryBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs\n\n\n\n\n\n\n\n"use strict";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer/* Buffer */.l || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends eventemitter3/* default */.Z {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = (0,uid/* uid */.h)("geometry");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on("update", this.onBufferUpdate, this);\n        attribute.buffer.on("change", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || "triangle-list";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit("update", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, "aPosition", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNJOztBQUVyRDtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFNO0FBQ2hDLHdCQUF3QiwrQkFBVyxTQUFTLCtCQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBVyxTQUFTLCtCQUFXO0FBQy9DLFFBQVE7QUFDUjtBQUNBLGdCQUFnQiwrQkFBVyxVQUFVLCtCQUFXO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQzFCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUN0Q3lDO0FBQzhCO0FBQ2xCO0FBQ1A7QUFDYztBQUNNOztBQUVsRTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLGVBQWUsa0JBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2Vuc3VyZUlzQnVmZmVyLm1qcz83YjhlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2dldEdlb21ldHJ5Qm91bmRzLm1qcz9hMjllIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcz9iOWQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uLy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vYnVmZmVyL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgbGV0IHVzYWdlID0gaW5kZXggPyBCdWZmZXJVc2FnZS5JTkRFWCA6IEJ1ZmZlclVzYWdlLlZFUlRFWDtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdXNhZ2UgPSBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICB1c2FnZSA9IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgIGxhYmVsOiBpbmRleCA/IFwiaW5kZXgtbWVzaC1idWZmZXJcIiA6IFwidmVydGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnN1cmVJc0J1ZmZlci5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldEdlb21ldHJ5Qm91bmRzKGdlb21ldHJ5LCBhdHRyaWJ1dGVJZCwgYm91bmRzKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVJZCk7XG4gIGlmICghYXR0cmlidXRlKSB7XG4gICAgYm91bmRzLm1pblggPSAwO1xuICAgIGJvdW5kcy5taW5ZID0gMDtcbiAgICBib3VuZHMubWF4WCA9IDA7XG4gICAgYm91bmRzLm1heFkgPSAwO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGF0dHJpYnV0ZS5idWZmZXIuZGF0YTtcbiAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gIGxldCBtYXhZID0gLUluZmluaXR5O1xuICBjb25zdCBieXRlU2l6ZSA9IGRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGNvbnN0IG9mZnNldCA9IChhdHRyaWJ1dGUub2Zmc2V0IHx8IDApIC8gYnl0ZVNpemU7XG4gIGNvbnN0IHN0cmlkZSA9IChhdHRyaWJ1dGUuc3RyaWRlIHx8IDIgKiA0KSAvIGJ5dGVTaXplO1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICB9XG4gIGJvdW5kcy5taW5YID0gbWluWDtcbiAgYm91bmRzLm1pblkgPSBtaW5ZO1xuICBib3VuZHMubWF4WCA9IG1heFg7XG4gIGJvdW5kcy5tYXhZID0gbWF4WTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZXhwb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdlb21ldHJ5Qm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfSBmcm9tICcuL3V0aWxzL2dldEdlb21ldHJ5Qm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBCdWZmZXIgfHwgQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpIHx8IGF0dHJpYnV0ZS5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgIGJ1ZmZlcjogYXR0cmlidXRlXG4gICAgfTtcbiAgfVxuICBhdHRyaWJ1dGUuYnVmZmVyID0gZW5zdXJlSXNCdWZmZXIoYXR0cmlidXRlLmJ1ZmZlciwgZmFsc2UpO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuY2xhc3MgR2VvbWV0cnkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgZ2VvbWV0cnlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGdlb21ldHJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgaW5kZXhCdWZmZXIsIHRvcG9sb2d5IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWQgb2YgdGhlIGdlb21ldHJ5LiAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiZ2VvbWV0cnlcIik7XG4gICAgLyoqXG4gICAgICogdGhlIGxheW91dCBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgV2ViR1BVIGFsbCBnZW9tZXRyaWVzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAgICAgKiB3aWxsIGhhdmUgdGhlIHNhbWUgbGF5b3V0IGtleS4gVGhpcyBpcyB1c2VkIHRvIGNhY2hlIHRoZSBwaXBlbGluZSBsYXlvdXRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fbGF5b3V0S2V5ID0gMDtcbiAgICAvKiogdGhlIGluc3RhbmNlIGNvdW50IG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3ICovXG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMTtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gb3B0aW9ucy5pbnN0YW5jZUNvdW50IHx8IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV0gPSBlbnN1cmVJc0F0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldKTtcbiAgICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYXR0cmlidXRlLmJ1ZmZlcik7XG4gICAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGF0dHJpYnV0ZS5idWZmZXIpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwidXBkYXRlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBlbnN1cmVJc0J1ZmZlcihpbmRleEJ1ZmZlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy50b3BvbG9neSA9IHRvcG9sb2d5IHx8IFwidHJpYW5nbGUtbGlzdFwiO1xuICB9XG4gIG9uQnVmZmVyVXBkYXRlKCkge1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHJldHVybnMgLSBUaGUgYXR0cmlidXRlIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldEF0dHJpYnV0ZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggYnVmZmVyLlxuICAgKi9cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBidWZmZXIuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgcmVxdWlyZWQuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJ1ZmZlciByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXRCdWZmZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoaWQpLmJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IGhvdyBtYW55IHZlcnRpY2VzIHRoZXJlIGFyZSBpbiB0aGlzIGdlb21ldHJ5XG4gICAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdlb21ldHJ5XG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG4gICAgICByZXR1cm4gYnVmZmVyLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgZ2VvbWV0cnkuICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKCF0aGlzLl9ib3VuZHNEaXJ0eSlcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICByZXR1cm4gZ2V0R2VvbWV0cnlCb3VuZHModGhpcywgXCJhUG9zaXRpb25cIiwgdGhpcy5fYm91bmRzKTtcbiAgfVxuICAvKipcbiAgICogZGVzdHJveXMgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gZGVzdHJveUJ1ZmZlcnMgLSBkZXN0cm95IHRoZSBidWZmZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGdlb21ldHJ5XG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCdWZmZXJzID0gZmFsc2UpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKGRlc3Ryb3lCdWZmZXJzKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiBidWZmZXIuZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1980\n')},1854:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ InstructionSet)\n/* harmony export */ });\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n"use strict";\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("instructionSet");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, ["type", "action"]);\n  }\n}\n\n\n//# sourceMappingURL=InstructionSet.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1NC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzP2ZkNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBJbnN0cnVjdGlvblNldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBhIHVuaXF1ZSBpZCBmb3IgdGhpcyBpbnN0cnVjdGlvbiBzZXQgdXNlZCB0aHJvdWdoIHRoZSByZW5kZXJlciAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiaW5zdHJ1Y3Rpb25TZXRcIik7XG4gICAgLyoqIHRoZSBhcnJheSBvZiBpbnN0cnVjdGlvbnMgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8qKiB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGFycmF5IChhbnkgaW5zdHJ1Y3Rpb25zIHBhc3NlZCB0aGlzIHNob3VsZCBiZSBpZ25vcmVkKSAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25TaXplID0gMDtcbiAgfVxuICAvKiogcmVzZXQgdGhlIGluc3RydWN0aW9uIHNldCBzbyBpdCBjYW4gYmUgcmV1c2VkIHNldCBzaXplIGJhY2sgdG8gMCAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9uU2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBpbnN0cnVjdGlvbiB0byB0aGUgc2V0XG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvbiAtIGFkZCBhbiBpbnN0cnVjdGlvbiB0byB0aGUgc2V0XG4gICAqL1xuICBhZGQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9uU2l6ZSsrXSA9IGluc3RydWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBMb2cgdGhlIGluc3RydWN0aW9ucyB0byB0aGUgY29uc29sZSAoZm9yIGRlYnVnZ2luZylcbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGxvZygpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLmluc3RydWN0aW9uU2l6ZTtcbiAgICBjb25zb2xlLnRhYmxlKHRoaXMuaW5zdHJ1Y3Rpb25zLCBbXCJ0eXBlXCIsIFwiYWN0aW9uXCJdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBJbnN0cnVjdGlvblNldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5zdHJ1Y3Rpb25TZXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1854\n')},2475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ STENCIL_MODES),\n/* harmony export */   f: () => (/* binding */ BLEND_TO_NPM)\n/* harmony export */ });\n\nconst BLEND_TO_NPM = {\n  normal: "normal-npm",\n  add: "add-npm",\n  screen: "screen-npm"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";\n  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";\n  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFaUI7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9jb25zdC5tanM/NmNhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEJMRU5EX1RPX05QTSA9IHtcbiAgbm9ybWFsOiBcIm5vcm1hbC1ucG1cIixcbiAgYWRkOiBcImFkZC1ucG1cIixcbiAgc2NyZWVuOiBcInNjcmVlbi1ucG1cIlxufTtcbnZhciBTVEVOQ0lMX01PREVTID0gLyogQF9fUFVSRV9fICovICgoU1RFTkNJTF9NT0RFUzIpID0+IHtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJESVNBQkxFRFwiXSA9IDBdID0gXCJESVNBQkxFRFwiO1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIlJFTkRFUklOR19NQVNLX0FERFwiXSA9IDFdID0gXCJSRU5ERVJJTkdfTUFTS19BRERcIjtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJNQVNLX0FDVElWRVwiXSA9IDJdID0gXCJNQVNLX0FDVElWRVwiO1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIlJFTkRFUklOR19NQVNLX1JFTU9WRVwiXSA9IDNdID0gXCJSRU5ERVJJTkdfTUFTS19SRU1PVkVcIjtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJOT05FXCJdID0gNF0gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIFNURU5DSUxfTU9ERVMyO1xufSkoU1RFTkNJTF9NT0RFUyB8fCB7fSk7XG5cbmV4cG9ydCB7IEJMRU5EX1RPX05QTSwgU1RFTkNJTF9NT0RFUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2475\n')},7199:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ AbstractRenderer)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8409);\n/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8400);\n/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1013);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _gl_const_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6582);\n/* harmony import */ var _SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7051);\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4146);\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultRunners = [\n  "init",\n  "destroy",\n  "contextChange",\n  "resolutionChange",\n  "reset",\n  "renderEnd",\n  "renderStart",\n  "render",\n  "update",\n  "postrender",\n  "prerender"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    const combinedRunners = [...defaultRunners, ...config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._addSystems(config.systems);\n    this._addPipes(config.renderPipes, config.renderPipeAdaptors);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Container */ .W2) {\n      options = { container: options };\n      if (deprecated) {\n        (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "passing a second argument is deprecated, please use render options instead");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Color */ .I.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit("resize", this.view.screen.width, this.view.screen.height);\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = _gl_const_mjs__WEBPACK_IMPORTED_MODULE_4__/* .CLEAR */ .E.ALL);\n    const { clear, clearColor, target } = options;\n    _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Color */ .I.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Color */ .I.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new _SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_5__/* .SystemRunner */ .P(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn\'t collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overrideable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_6__/* .unsafeEvalSupported */ .O)()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\n\n//# sourceMappingURL=AbstractRenderer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL0Fic3RyYWN0UmVuZGVyZXIubWpzP2IwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2Jyb3dzZXIvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vdXRpbHMvdXRpbHMubWpzJztcbmltcG9ydCB7IENMRUFSIH0gZnJvbSAnLi4vLi4vZ2wvY29uc3QubWpzJztcbmltcG9ydCB7IFN5c3RlbVJ1bm5lciB9IGZyb20gJy4vU3lzdGVtUnVubmVyLm1qcyc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRlZmF1bHRSdW5uZXJzID0gW1xuICBcImluaXRcIixcbiAgXCJkZXN0cm95XCIsXG4gIFwiY29udGV4dENoYW5nZVwiLFxuICBcInJlc29sdXRpb25DaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInJlbmRlckVuZFwiLFxuICBcInJlbmRlclN0YXJ0XCIsXG4gIFwicmVuZGVyXCIsXG4gIFwidXBkYXRlXCIsXG4gIFwicG9zdHJlbmRlclwiLFxuICBcInByZXJlbmRlclwiXG5dO1xuY29uc3QgX0Fic3RyYWN0UmVuZGVyZXIgPSBjbGFzcyBfQWJzdHJhY3RSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBTZXQgdXAgYSBzeXN0ZW0gd2l0aCBhIGNvbGxlY3Rpb24gb2YgU3lzdGVtQ2xhc3NlcyBhbmQgcnVubmVycy5cbiAgICogU3lzdGVtcyBhcmUgYXR0YWNoZWQgZHluYW1pY2FsbHkgdG8gdGhpcyBjbGFzcyB3aGVuIGFkZGVkLlxuICAgKiBAcGFyYW0gY29uZmlnIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHN5c3RlbSBtYW5hZ2VyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucnVubmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMucmVuZGVyUGlwZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9pbml0T3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50eXBlID0gY29uZmlnLnR5cGU7XG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgY29uc3QgY29tYmluZWRSdW5uZXJzID0gWy4uLmRlZmF1bHRSdW5uZXJzLCAuLi5jb25maWcucnVubmVycyA/PyBbXV07XG4gICAgdGhpcy5fYWRkUnVubmVycyguLi5jb21iaW5lZFJ1bm5lcnMpO1xuICAgIHRoaXMuX2FkZFN5c3RlbXMoY29uZmlnLnN5c3RlbXMpO1xuICAgIHRoaXMuX2FkZFBpcGVzKGNvbmZpZy5yZW5kZXJQaXBlcywgY29uZmlnLnJlbmRlclBpcGVBZGFwdG9ycyk7XG4gICAgdGhpcy5fdW5zYWZlRXZhbENoZWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHVzZSB0byBjcmVhdGUgdGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgYXN5bmMgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IHN5c3RlbU5hbWUgaW4gdGhpcy5fc3lzdGVtc0hhc2gpIHtcbiAgICAgIGNvbnN0IHN5c3RlbSA9IHRoaXMuX3N5c3RlbXNIYXNoW3N5c3RlbU5hbWVdO1xuICAgICAgY29uc3QgZGVmYXVsdFN5c3RlbU9wdGlvbnMgPSBzeXN0ZW0uY29uc3RydWN0b3IuZGVmYXVsdE9wdGlvbnM7XG4gICAgICBvcHRpb25zID0geyAuLi5kZWZhdWx0U3lzdGVtT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fQWJzdHJhY3RSZW5kZXJlci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gb3B0aW9ucy5yb3VuZFBpeGVscyA/IDEgOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uZXJzLmluaXQuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF3YWl0IHRoaXMucnVubmVycy5pbml0Lml0ZW1zW2ldLmluaXQob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICByZW5kZXIoYXJncywgZGVwcmVjYXRlZCkge1xuICAgIGxldCBvcHRpb25zID0gYXJncztcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGFpbmVyOiBvcHRpb25zIH07XG4gICAgICBpZiAoZGVwcmVjYXRlZCkge1xuICAgICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwicGFzc2luZyBhIHNlY29uZCBhcmd1bWVudCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlciBvcHRpb25zIGluc3RlYWRcIik7XG4gICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gZGVwcmVjYXRlZC5yZW5kZXJUZXh0dXJlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLnRhcmdldCB8fCAob3B0aW9ucy50YXJnZXQgPSB0aGlzLnZpZXcucmVuZGVyVGFyZ2V0KTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQgPT09IHRoaXMudmlldy5yZW5kZXJUYXJnZXQpIHtcbiAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgb3B0aW9ucy5jbGVhckNvbG9yID0gdGhpcy5iYWNrZ3JvdW5kLmNvbG9yUmdiYTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xlYXJDb2xvcikge1xuICAgICAgY29uc3QgaXNSR0JBQXJyYXkgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2xlYXJDb2xvcikgJiYgb3B0aW9ucy5jbGVhckNvbG9yLmxlbmd0aCA9PT0gNDtcbiAgICAgIG9wdGlvbnMuY2xlYXJDb2xvciA9IGlzUkdCQUFycmF5ID8gb3B0aW9ucy5jbGVhckNvbG9yIDogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKG9wdGlvbnMuY2xlYXJDb2xvcikudG9BcnJheSgpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHJhbnNmb3JtKSB7XG4gICAgICBvcHRpb25zLmNvbnRhaW5lci51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgb3B0aW9ucy50cmFuc2Zvcm0gPSBvcHRpb25zLmNvbnRhaW5lci5sb2NhbFRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5ydW5uZXJzLnByZXJlbmRlci5lbWl0KG9wdGlvbnMpO1xuICAgIHRoaXMucnVubmVycy5yZW5kZXJTdGFydC5lbWl0KG9wdGlvbnMpO1xuICAgIHRoaXMucnVubmVycy5yZW5kZXIuZW1pdChvcHRpb25zKTtcbiAgICB0aGlzLnJ1bm5lcnMucmVuZGVyRW5kLmVtaXQob3B0aW9ucyk7XG4gICAgdGhpcy5ydW5uZXJzLnBvc3RyZW5kZXIuZW1pdChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgV2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuV2lkdGggLSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbkhlaWdodCAtIFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci5cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnZpZXcucmVzaXplKGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgdGhpcy5lbWl0KFwicmVzaXplXCIsIHRoaXMudmlldy5zY3JlZW4ud2lkdGgsIHRoaXMudmlldy5zY3JlZW4uaGVpZ2h0KTtcbiAgfVxuICBjbGVhcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXM7XG4gICAgb3B0aW9ucy50YXJnZXQgfHwgKG9wdGlvbnMudGFyZ2V0ID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldCk7XG4gICAgb3B0aW9ucy5jbGVhckNvbG9yIHx8IChvcHRpb25zLmNsZWFyQ29sb3IgPSB0aGlzLmJhY2tncm91bmQuY29sb3JSZ2JhKTtcbiAgICBvcHRpb25zLmNsZWFyID8/IChvcHRpb25zLmNsZWFyID0gQ0xFQVIuQUxMKTtcbiAgICBjb25zdCB7IGNsZWFyLCBjbGVhckNvbG9yLCB0YXJnZXQgfSA9IG9wdGlvbnM7XG4gICAgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNsZWFyQ29sb3IgPz8gdGhpcy5iYWNrZ3JvdW5kLmNvbG9yUmdiYSk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNsZWFyKHRhcmdldCwgY2xlYXIsIENvbG9yLnNoYXJlZC50b0FycmF5KCkpO1xuICB9XG4gIC8qKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMudmlldy5yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5ydW5uZXJzLnJlc29sdXRpb25DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgYXMgdmlldy53aWR0aCwgYWN0dWFsIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGNhbnZhcyBieSBob3Jpem9udGFsLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVmYXVsdCA4MDBcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnRleHR1cmUuZnJhbWUud2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgYXMgdmlldy5oZWlnaHQsIGFjdHVhbCBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBjYW52YXMgYnkgdmVydGljYWwuXG4gICAqIEBkZWZhdWx0IDYwMFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICB9XG4gIC8vIE5PVEU6IHRoaXMgd2FzIGB2aWV3YCBpbiB2N1xuICAvKipcbiAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0by5cbiAgICogQHR5cGUge2Vudmlyb25tZW50LklDYW52YXN9XG4gICAqL1xuICBnZXQgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiB0aGUgbGFzdCBvYmplY3QgcmVuZGVyZWQgYnkgdGhlIHJlbmRlcmVyLiBVc2VmdWwgZm9yIG90aGVyIHBsdWdpbnMgbGlrZSBpbnRlcmFjdGlvbiBtYW5hZ2Vyc1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0T2JqZWN0UmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZDtcbiAgfVxuICAvKipcbiAgICogRmxhZyBpZiB3ZSBhcmUgcmVuZGVyaW5nIHRvIHRoZSBzY3JlZW4gdnMgcmVuZGVyVGV4dHVyZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZ2V0IHJlbmRlcmluZ1RvU2NyZWVuKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcztcbiAgICByZXR1cm4gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlcmluZ1RvU2NyZWVuO1xuICB9XG4gIC8qKlxuICAgKiBNZWFzdXJlbWVudHMgb2YgdGhlIHNjcmVlbi4gKDAsIDAsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpLlxuICAgKlxuICAgKiBJdHMgc2FmZSB0byB1c2UgYXMgZmlsdGVyQXJlYSBvciBoaXRBcmVhIGZvciB0aGUgd2hvbGUgc3RhZ2UuXG4gICAqL1xuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc2NyZWVuO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBidW5jaCBvZiBydW5uZXJzIGJhc2VkIG9mIGEgY29sbGVjdGlvbiBvZiBpZHNcbiAgICogQHBhcmFtIHJ1bm5lcklkcyAtIHRoZSBydW5uZXIgaWRzIHRvIGFkZFxuICAgKi9cbiAgX2FkZFJ1bm5lcnMoLi4ucnVubmVySWRzKSB7XG4gICAgcnVubmVySWRzLmZvckVhY2goKHJ1bm5lcklkKSA9PiB7XG4gICAgICB0aGlzLnJ1bm5lcnNbcnVubmVySWRdID0gbmV3IFN5c3RlbVJ1bm5lcihydW5uZXJJZCk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZFN5c3RlbXMoc3lzdGVtcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSBpbiBzeXN0ZW1zKSB7XG4gICAgICBjb25zdCB2YWwgPSBzeXN0ZW1zW2ldO1xuICAgICAgdGhpcy5fYWRkU3lzdGVtKHZhbC52YWx1ZSwgdmFsLm5hbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGEgbmV3IHN5c3RlbSB0byB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSBDbGFzc1JlZiAtIENsYXNzIHJlZmVyZW5jZVxuICAgKiBAcGFyYW0gbmFtZSAtIFByb3BlcnR5IG5hbWUgZm9yIHN5c3RlbSwgaWYgbm90IHNwZWNpZmllZFxuICAgKiAgICAgICAgd2lsbCB1c2UgYSBzdGF0aWMgYG5hbWVgIHByb3BlcnR5IG9uIHRoZSBjbGFzcyBpdHNlbGYuIFRoaXNcbiAgICogICAgICAgIG5hbWUgd2lsbCBiZSBhc3NpZ25lZCBhcyBzIHByb3BlcnR5IG9uIHRoZSBSZW5kZXJlciBzbyBtYWtlXG4gICAqICAgICAgICBzdXJlIGl0IGRvZXNuJ3QgY29sbGlkZSB3aXRoIHByb3BlcnRpZXMgb24gUmVuZGVyZXIuXG4gICAqIEByZXR1cm5zIFJldHVybiBpbnN0YW5jZSBvZiByZW5kZXJlclxuICAgKi9cbiAgX2FkZFN5c3RlbShDbGFzc1JlZiwgbmFtZSkge1xuICAgIGNvbnN0IHN5c3RlbSA9IG5ldyBDbGFzc1JlZih0aGlzKTtcbiAgICBpZiAodGhpc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaG9vcHMhIFRoZSBuYW1lIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgaW4gdXNlYCk7XG4gICAgfVxuICAgIHRoaXNbbmFtZV0gPSBzeXN0ZW07XG4gICAgdGhpcy5fc3lzdGVtc0hhc2hbbmFtZV0gPSBzeXN0ZW07XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMucnVubmVycykge1xuICAgICAgdGhpcy5ydW5uZXJzW2ldLmFkZChzeXN0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfYWRkUGlwZXMocGlwZXMsIHBpcGVBZGFwdG9ycykge1xuICAgIGNvbnN0IGFkYXB0b3JzID0gcGlwZUFkYXB0b3JzLnJlZHVjZSgoYWNjLCBhZGFwdG9yKSA9PiB7XG4gICAgICBhY2NbYWRhcHRvci5uYW1lXSA9IGFkYXB0b3IudmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBwaXBlcy5mb3JFYWNoKChwaXBlKSA9PiB7XG4gICAgICBjb25zdCBQaXBlQ2xhc3MgPSBwaXBlLnZhbHVlO1xuICAgICAgY29uc3QgbmFtZSA9IHBpcGUubmFtZTtcbiAgICAgIGNvbnN0IEFkYXB0b3IgPSBhZGFwdG9yc1tuYW1lXTtcbiAgICAgIHRoaXMucmVuZGVyUGlwZXNbbmFtZV0gPSBuZXcgUGlwZUNsYXNzKFxuICAgICAgICB0aGlzLFxuICAgICAgICBBZGFwdG9yID8gbmV3IEFkYXB0b3IoKSA6IG51bGxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zID0gZmFsc2UpIHtcbiAgICB0aGlzLnJ1bm5lcnMuZGVzdHJveS5pdGVtcy5yZXZlcnNlKCk7XG4gICAgdGhpcy5ydW5uZXJzLmRlc3Ryb3kuZW1pdChvcHRpb25zKTtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMucnVubmVycykuZm9yRWFjaCgocnVubmVyKSA9PiB7XG4gICAgICBydW5uZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclBpcGVzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0ZXh0dXJlIGZyb20gYSBjb250YWluZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBvciBjb250YWluZXIgdGFyZ2V0IHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdGhlIHRleHR1cmVcbiAgICogQHJldHVybnMgYSB0ZXh0dXJlXG4gICAqL1xuICBnZW5lcmF0ZVRleHR1cmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVHZW5lcmF0b3IuZ2VuZXJhdGVUZXh0dXJlKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZW5kZXJlciB3aWxsIHJvdW5kIGNvb3JkaW5hdGVzIHRvIHdob2xlIHBpeGVscyB3aGVuIHJlbmRlcmluZy5cbiAgICogQ2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXIgc2NlbmUgaXRlbSBiYXNpcy5cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGVhYmxlIGZ1bmN0aW9uIGJ5IGBwaXhpLmpzL3Vuc2FmZS1ldmFsYCB0byBzaWxlbmNlXG4gICAqIHRocm93aW5nIGFuIGVycm9yIGlmIHBsYXRmb3JtIGRvZXNuJ3Qgc3VwcG9ydCB1bnNhZmUtZXZhbHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF91bnNhZmVFdmFsQ2hlY2soKSB7XG4gICAgaWYgKCF1bnNhZmVFdmFsU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3QgYWxsb3cgdW5zYWZlLWV2YWwsIHBsZWFzZSB1c2UgcGl4aS5qcy91bnNhZmUtZXZhbCBtb2R1bGUgdG8gZW5hYmxlIHN1cHBvcnQuXCIpO1xuICAgIH1cbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgcmVuZGVyZXIuICovXG5fQWJzdHJhY3RSZW5kZXJlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIHJlc29sdXRpb246IDEsXG4gIC8qKlxuICAgKiBTaG91bGQgdGhlIGBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0YCBmbGFnIGJlIGVuYWJsZWQgYXMgYSBjb250ZXh0IG9wdGlvbiB1c2VkIGluIHRoZSBgaXNXZWJHTFN1cHBvcnRlZGBcbiAgICogZnVuY3Rpb24uIElmIHNldCB0byB0cnVlLCBhIFdlYkdMIHJlbmRlcmVyIGNhbiBmYWlsIHRvIGJlIGNyZWF0ZWQgaWYgdGhlIGJyb3dzZXIgdGhpbmtzIHRoZXJlIGNvdWxkIGJlXG4gICAqIHBlcmZvcm1hbmNlIGlzc3VlcyB3aGVuIHVzaW5nIFdlYkdMLlxuICAgKlxuICAgKiBJbiBQaXhpSlMgdjYgdGhpcyBoYXMgY2hhbmdlZCBmcm9tIHRydWUgdG8gZmFsc2UgYnkgZGVmYXVsdCwgdG8gYWxsb3cgV2ViR0wgdG8gd29yayBpbiBhcyBtYW55XG4gICAqIHNjZW5hcmlvcyBhcyBwb3NzaWJsZS4gSG93ZXZlciwgc29tZSB1c2VycyBtYXkgaGF2ZSBhIHBvb3IgZXhwZXJpZW5jZSwgZm9yIGV4YW1wbGUsIGlmIGEgdXNlciBoYXMgYSBncHUgb3JcbiAgICogZHJpdmVyIHZlcnNpb24gYmxhY2tsaXN0ZWQgYnkgdGhlXG4gICAqIGJyb3dzZXIuXG4gICAqXG4gICAqIElmIHlvdXIgYXBwbGljYXRpb24gcmVxdWlyZXMgaGlnaCBwZXJmb3JtYW5jZSByZW5kZXJpbmcsIHlvdSBtYXkgd2lzaCB0byBzZXQgdGhpcyB0byBmYWxzZS5cbiAgICogV2UgcmVjb21tZW5kIG9uZSBvZiB0d28gb3B0aW9ucyBpZiB5b3UgZGVjaWRlIHRvIHNldCB0aGlzIGZsYWcgdG8gZmFsc2U6XG4gICAqXG4gICAqIDE6IFVzZSB0aGUgQ2FudmFzIHJlbmRlcmVyIGFzIGEgZmFsbGJhY2sgaW4gY2FzZSBoaWdoIHBlcmZvcm1hbmNlIFdlYkdMIGlzXG4gICAqICAgIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIDI6IENhbGwgYGlzV2ViR0xTdXBwb3J0ZWRgICh3aGljaCBpZiBmb3VuZCBpbiB0aGUgdXRpbHMgcGFja2FnZSkgaW4geW91ciBjb2RlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhXG4gICAqICAgIFBpeGlKUyByZW5kZXJlciwgYW5kIHNob3cgYW4gZXJyb3IgbWVzc2FnZSB0byB0aGUgdXNlciBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgZXhwbGFpbmluZyB0aGF0IHRoZWlyXG4gICAqICAgIGRldmljZSAmIGJyb3dzZXIgY29tYmluYXRpb24gZG9lcyBub3Qgc3VwcG9ydCBoaWdoIHBlcmZvcm1hbmNlIFdlYkdMLlxuICAgKiAgICBUaGlzIGlzIGEgbXVjaCBiZXR0ZXIgc3RyYXRlZ3kgdGhhbiB0cnlpbmcgdG8gY3JlYXRlIGEgUGl4aUpTIHJlbmRlcmVyIGFuZCBmaW5kaW5nIGl0IHRoZW4gZmFpbHMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgLyoqXG4gICAqIFNob3VsZCByb3VuZCBwaXhlbHMgYmUgZm9yY2VkIHdoZW4gcmVuZGVyaW5nP1xuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcm91bmRQaXhlbHM6IGZhbHNlXG59O1xubGV0IEFic3RyYWN0UmVuZGVyZXIgPSBfQWJzdHJhY3RSZW5kZXJlcjtcblxuZXhwb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RSZW5kZXJlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7199\n')},7051:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ SystemRunner)\n/* harmony export */ });\n\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\n\n//# sourceMappingURL=SystemRunner.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA1MS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL1N5c3RlbVJ1bm5lci5tanM/Yzg5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFN5c3RlbVJ1bm5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBmdW5jdGlvbiBuYW1lIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBvbiB0aGUgbGlzdGVuZXJzIGFkZGVkIHRvIHRoaXMgUnVubmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLXBhcmFtLCBqc2RvYy9jaGVjay1wYXJhbS1uYW1lcyAqL1xuICAvKipcbiAgICogRGlzcGF0Y2gvQnJvYWRjYXN0IFJ1bm5lciB0byBhbGwgbGlzdGVuZXJzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtcyAtIChvcHRpb25hbCkgcGFyYW1ldGVycyB0byBwYXNzIHRvIGVhY2ggbGlzdGVuZXJcbiAgICovXG4gIC8qICBlc2xpbnQtZW5hYmxlIGpzZG9jL3JlcXVpcmUtcGFyYW0sIGpzZG9jL2NoZWNrLXBhcmFtLW5hbWVzICovXG4gIGVtaXQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgY29uc3QgeyBuYW1lLCBpdGVtcyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW1zW2ldW25hbWVdKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgUnVubmVyXG4gICAqXG4gICAqIFJ1bm5lcnMgZG8gbm90IG5lZWQgdG8gaGF2ZSBzY29wZSBvciBmdW5jdGlvbnMgcGFzc2VkIHRvIHRoZW0uXG4gICAqIEFsbCB0aGF0IGlzIHJlcXVpcmVkIGlzIHRvIHBhc3MgdGhlIGxpc3RlbmluZyBvYmplY3QgYW5kIGVuc3VyZSB0aGF0IGl0IGhhcyBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWVcbiAgICogYXMgdGhlIG5hbWUgcHJvdmlkZWQgdG8gdGhlIFJ1bm5lciB3aGVuIGl0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBFZyBBIGxpc3RlbmVyIHBhc3NlZCB0byB0aGlzIFJ1bm5lciB3aWxsIHJlcXVpcmUgYSAnY29tcGxldGUnIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IGNvbXBsZXRlID0gbmV3IFJ1bm5lcignY29tcGxldGUnKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBzY29wZSB1c2VkIHdpbGwgYmUgdGhlIG9iamVjdCBpdHNlbGYuXG4gICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgbGlzdGVuaW5nLlxuICAgKi9cbiAgYWRkKGl0ZW0pIHtcbiAgICBpZiAoaXRlbVt0aGlzLl9uYW1lXSkge1xuICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGxpc3RlbmVyIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGlzIGFscmVhZHkgaW4gdGhlIFJ1bm5lclxuICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBsaXN0ZW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIGNoZWNrLlxuICAgKi9cbiAgY29udGFpbnMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkgIT09IC0xO1xuICB9XG4gIC8qKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIHRoZSBSdW5uZXIgKi9cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuaXRlbXMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogUmVtb3ZlIGFsbCByZWZlcmVuY2VzLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBgdHJ1ZWAgaWYgdGhlcmUgYXJlIG5vIHRoaXMgUnVubmVyIGNvbnRhaW5zIG5vIGxpc3RlbmVyc1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBydW5uZXIuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3lzdGVtUnVubmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TeXN0ZW1SdW5uZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7051\n")},9853:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  x: () => (/* binding */ Texture)\n});\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs\n\n\n"use strict";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix/* Matrix */.y();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don\'t.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn\'t work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\n\n//# sourceMappingURL=groupD8.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/misc/NOOP.mjs\n\nconst NOOP = () => {\n};\n\n\n//# sourceMappingURL=NOOP.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs\nvar BufferSource = __webpack_require__(4758);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs\nvar TextureMatrix = __webpack_require__(575);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass Texture extends eventemitter3/* default */.Z {\n  /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = (0,uid/* uid */.h)("texture");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle/* Rectangle */.A();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on(\'update\', () => {});\n     */\n    this.noFrame = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource/* TextureSource */.p();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off("resize", this.update, this);\n    }\n    this._source = value;\n    value.on("resize", this.update, this);\n    this.emit("update", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix/* TextureMatrix */.U(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit("update", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Texture.baseTexture is now Texture.source");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: "EMPTY",\n  source: new TextureSource/* TextureSource */.p({\n    label: "EMPTY"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferSource/* BufferImageSource */.A({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: "premultiply-alpha-on-upload",\n    label: "WHITE"\n  }),\n  label: "WHITE"\n});\nTexture.WHITE.destroy = NOOP;\n\n\n//# sourceMappingURL=Texture.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0Isb0JBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7QUFDbkI7Ozs7Ozs7OztBQ3JRYTtBQUNiO0FBQ0E7O0FBRWdCO0FBQ2hCOzs7Ozs7Ozs7QUNMeUM7QUFDc0I7QUFDSTtBQUNkO0FBQzJCO0FBQ3pCO0FBQ1E7QUFDSDtBQUNSOztBQUVwRDtBQUNBLHNCQUFzQiw0QkFBWTtBQUNsQztBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLGVBQWUsa0JBQUc7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxhQUFhLE9BQU87QUFDMUMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMsZUFBZSxPQUFPO0FBQ3RCLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLGVBQWUsT0FBTztBQUN0Qix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyxlQUFlLE9BQU87QUFDdEIseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFhO0FBQzNCO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBLGNBQWMscUNBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLElBQUk7O0FBRVQ7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9tYXRyaXgvZ3JvdXBEOC5tanM/NzU5YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9taXNjL05PT1AubWpzPzdkZDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcz9kZDRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vTWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdXggPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMV07XG5jb25zdCB1eSA9IFswLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbmNvbnN0IHZ4ID0gWzAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xuY29uc3QgdnkgPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMV07XG5jb25zdCByb3RhdGlvbkNheWxleSA9IFtdO1xuY29uc3Qgcm90YXRpb25NYXRyaWNlcyA9IFtdO1xuY29uc3Qgc2lnbnVtID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gW107XG4gICAgcm90YXRpb25DYXlsZXkucHVzaChyb3cpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgY29uc3QgX3V4ID0gc2lnbnVtKHV4W2ldICogdXhbal0gKyB2eFtpXSAqIHV5W2pdKTtcbiAgICAgIGNvbnN0IF91eSA9IHNpZ251bSh1eVtpXSAqIHV4W2pdICsgdnlbaV0gKiB1eVtqXSk7XG4gICAgICBjb25zdCBfdnggPSBzaWdudW0odXhbaV0gKiB2eFtqXSArIHZ4W2ldICogdnlbal0pO1xuICAgICAgY29uc3QgX3Z5ID0gc2lnbnVtKHV5W2ldICogdnhbal0gKyB2eVtpXSAqIHZ5W2pdKTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMTY7IGsrKykge1xuICAgICAgICBpZiAodXhba10gPT09IF91eCAmJiB1eVtrXSA9PT0gX3V5ICYmIHZ4W2tdID09PSBfdnggJiYgdnlba10gPT09IF92eSkge1xuICAgICAgICAgIHJvdy5wdXNoKGspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICBtYXQuc2V0KHV4W2ldLCB1eVtpXSwgdnhbaV0sIHZ5W2ldLCAwLCAwKTtcbiAgICByb3RhdGlvbk1hdHJpY2VzLnB1c2gobWF0KTtcbiAgfVxufVxuaW5pdCgpO1xuY29uc3QgZ3JvdXBEOCA9IHtcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAwwrAgICAgICAgfCBFYXN0ICAgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgRTogMCxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCA0NcKw4oa7ICAgICB8IFNvdXRoZWFzdCB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBTRTogMSxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCA5MMKw4oa7ICAgICB8IFNvdXRoICAgICB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBTOiAyLFxuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDEzNcKw4oa7ICAgIHwgU291dGh3ZXN0IHxcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIFNXOiAzLFxuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDE4MMKwICAgICB8IFdlc3QgICAgICB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBXOiA0LFxuICAvKipcbiAgICogfCBSb3RhdGlvbiAgICB8IERpcmVjdGlvbiAgICB8XG4gICAqIHwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfFxuICAgKiB8IC0xMzXCsC8yMjXCsOKGuyB8IE5vcnRod2VzdCAgICB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBOVzogNSxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtOTDCsC8yNzDCsOKGuyAgfCBOb3J0aCAgICAgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTjogNixcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtNDXCsC8zMTXCsOKGuyAgfCBOb3J0aGVhc3QgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTkU6IDcsXG4gIC8qKlxuICAgKiBSZWZsZWN0aW9uIGFib3V0IFktYXhpcy5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIE1JUlJPUl9WRVJUSUNBTDogOCxcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgdGhlIG1haW4gZGlhZ29uYWwuXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBNQUlOX0RJQUdPTkFMOiAxMCxcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgWC1heGlzLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCByZXZlcnNlIGRpYWdvbmFsLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgUkVWRVJTRV9ESUFHT05BTDogMTQsXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gVGhlIFgtY29tcG9uZW50IG9mIHRoZSBVLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB1WDogKGluZCkgPT4gdXhbaW5kXSxcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IGluZCAtIHNwcml0ZSByb3RhdGlvbiBhbmdsZS5cbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBUaGUgWS1jb21wb25lbnQgb2YgdGhlIFUtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHVZOiAoaW5kKSA9PiB1eVtpbmRdLFxuICAvKipcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtHRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFRoZSBYLWNvbXBvbmVudCBvZiB0aGUgVi1heGlzXG4gICAqICAgIGFmdGVyIHJvdGF0aW5nIHRoZSBheGVzLlxuICAgKi9cbiAgdlg6IChpbmQpID0+IHZ4W2luZF0sXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gVGhlIFktY29tcG9uZW50IG9mIHRoZSBWLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB2WTogKGluZCkgPT4gdnlbaW5kXSxcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uIC0gc3ltbWV0cnkgd2hvc2Ugb3Bwb3NpdGVcbiAgICogICBpcyBuZWVkZWQuIE9ubHkgcm90YXRpb25zIGhhdmUgb3Bwb3NpdGUgc3ltbWV0cmllcyB3aGlsZVxuICAgKiAgIHJlZmxlY3Rpb25zIGRvbid0LlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFRoZSBvcHBvc2l0ZSBzeW1tZXRyeSBvZiBgcm90YXRpb25gXG4gICAqL1xuICBpbnY6IChyb3RhdGlvbikgPT4ge1xuICAgIGlmIChyb3RhdGlvbiAmIDgpIHtcbiAgICAgIHJldHVybiByb3RhdGlvbiAmIDE1O1xuICAgIH1cbiAgICByZXR1cm4gLXJvdGF0aW9uICYgNztcbiAgfSxcbiAgLyoqXG4gICAqIENvbXBvc2VzIHRoZSB0d28gRDggb3BlcmF0aW9ucy5cbiAgICpcbiAgICogVGFraW5nIGBeYCBhcyByZWZsZWN0aW9uOlxuICAgKlxuICAgKiB8ICAgICAgIHwgRT0wIHwgUz0yIHwgVz00IHwgTj02IHwgRV49OCB8IFNePTEwIHwgV149MTIgfCBOXj0xNCB8XG4gICAqIHwtLS0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tLXwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLXxcbiAgICogfCBFPTAgICB8IEUgICB8IFMgICB8IFcgICB8IE4gICB8IEVeICAgfCBTXiAgICB8IFdeICAgIHwgTl4gICAgfFxuICAgKiB8IFM9MiAgIHwgUyAgIHwgVyAgIHwgTiAgIHwgRSAgIHwgU14gICB8IFdeICAgIHwgTl4gICAgfCBFXiAgICB8XG4gICAqIHwgVz00ICAgfCBXICAgfCBOICAgfCBFICAgfCBTICAgfCBXXiAgIHwgTl4gICAgfCBFXiAgICB8IFNeICAgIHxcbiAgICogfCBOPTYgICB8IE4gICB8IEUgICB8IFMgICB8IFcgICB8IE5eICAgfCBFXiAgICB8IFNeICAgIHwgV14gICAgfFxuICAgKiB8IEVePTggIHwgRV4gIHwgTl4gIHwgV14gIHwgU14gIHwgRSAgICB8IE4gICAgIHwgVyAgICAgfCBTICAgICB8XG4gICAqIHwgU149MTAgfCBTXiAgfCBFXiAgfCBOXiAgfCBXXiAgfCBTICAgIHwgRSAgICAgfCBOICAgICB8IFcgICAgIHxcbiAgICogfCBXXj0xMiB8IFdeICB8IFNeICB8IEVeICB8IE5eICB8IFcgICAgfCBTICAgICB8IEUgICAgIHwgTiAgICAgfFxuICAgKiB8IE5ePTE0IHwgTl4gIHwgV14gIHwgU14gIHwgRV4gIHwgTiAgICB8IFcgICAgIHwgUyAgICAgfCBFICAgICB8XG4gICAqXG4gICAqIFtUaGlzIGlzIGEgQ2F5bGV5IHRhYmxlXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXlsZXlfdGFibGV9XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uU2Vjb25kIC0gU2Vjb25kIG9wZXJhdGlvbiwgd2hpY2hcbiAgICogICBpcyB0aGUgcm93IGluIHRoZSBhYm92ZSBjYXlsZXkgdGFibGUuXG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uRmlyc3QgLSBGaXJzdCBvcGVyYXRpb24sIHdoaWNoXG4gICAqICAgaXMgdGhlIGNvbHVtbiBpbiB0aGUgYWJvdmUgY2F5bGV5IHRhYmxlLlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IENvbXBvc2VkIG9wZXJhdGlvblxuICAgKi9cbiAgYWRkOiAocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpID0+IHJvdGF0aW9uQ2F5bGV5W3JvdGF0aW9uU2Vjb25kXVtyb3RhdGlvbkZpcnN0XSxcbiAgLyoqXG4gICAqIFJldmVyc2Ugb2YgYGFkZGAuXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uU2Vjb25kIC0gU2Vjb25kIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbkZpcnN0IC0gRmlyc3Qgb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gUmVzdWx0XG4gICAqL1xuICBzdWI6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW2dyb3VwRDguaW52KHJvdGF0aW9uRmlyc3QpXSxcbiAgLyoqXG4gICAqIEFkZHMgMTgwIGRlZ3JlZXMgdG8gcm90YXRpb24sIHdoaWNoIGlzIGEgY29tbXV0YXRpdmVcbiAgICogb3BlcmF0aW9uLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBUaGUgbnVtYmVyIHRvIHJvdGF0ZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUm90YXRlZCBudW1iZXJcbiAgICovXG4gIHJvdGF0ZTE4MDogKHJvdGF0aW9uKSA9PiByb3RhdGlvbiBeIDQsXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHJvdGF0aW9uIGFuZ2xlIGlzIHZlcnRpY2FsLCBpLmUuIHNvdXRoXG4gICAqIG9yIG5vcnRoLiBJdCBkb2Vzbid0IHdvcmsgZm9yIHJlZmxlY3Rpb25zLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiAocm90YXRpb24pID0+IChyb3RhdGlvbiAmIDMpID09PSAyLFxuICAvLyByb3RhdGlvbiAlIDQgPT09IDJcbiAgLyoqXG4gICAqIEFwcHJveGltYXRlcyB0aGUgdmVjdG9yIGBWKGR4LGR5KWAgaW50byBvbmUgb2YgdGhlXG4gICAqIGVpZ2h0IGRpcmVjdGlvbnMgcHJvdmlkZWQgYnkgYGdyb3VwRDhgLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBYLWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIFktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBBcHByb3hpbWF0aW9uIG9mIHRoZSB2ZWN0b3IgaW50b1xuICAgKiAgb25lIG9mIHRoZSBlaWdodCBzeW1tZXRyaWVzLlxuICAgKi9cbiAgYnlEaXJlY3Rpb246IChkeCwgZHkpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LlM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5OO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cEQ4Llc7XG4gICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguU0U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5TVztcbiAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwRDguTkU7XG4gICAgfVxuICAgIHJldHVybiBncm91cEQ4Lk5XO1xuICB9LFxuICAvKipcbiAgICogSGVscHMgc3ByaXRlIHRvIGNvbXBlbnNhdGUgdGV4dHVyZSBwYWNrZXIgcm90YXRpb24uXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggLSBzcHJpdGUgd29ybGQgbWF0cml4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIGZhY3RvciB0byB1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAtIHNwcml0ZSBhbmNob3JpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gc3ByaXRlIGFuY2hvcmluZ1xuICAgKi9cbiAgbWF0cml4QXBwZW5kUm90YXRpb25JbnY6IChtYXRyaXgsIHJvdGF0aW9uLCB0eCA9IDAsIHR5ID0gMCkgPT4ge1xuICAgIGNvbnN0IG1hdCA9IHJvdGF0aW9uTWF0cmljZXNbZ3JvdXBEOC5pbnYocm90YXRpb24pXTtcbiAgICBtYXQudHggPSB0eDtcbiAgICBtYXQudHkgPSB0eTtcbiAgICBtYXRyaXguYXBwZW5kKG1hdCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGdyb3VwRDggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwRDgubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcblxuZXhwb3J0IHsgTk9PUCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tk9PUC5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9ncm91cEQ4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IE5PT1AgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9taXNjL05PT1AubWpzJztcbmltcG9ydCB7IEJ1ZmZlckltYWdlU291cmNlIH0gZnJvbSAnLi9zb3VyY2VzL0J1ZmZlclNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlTWF0cml4IH0gZnJvbSAnLi9UZXh0dXJlTWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGV4dHVyZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RleHR1cmVPcHRpb25zfSBwYXJhbTAgLSBPcHRpb25zIGZvciB0aGUgdGV4dHVyZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHNvdXJjZSxcbiAgICBsYWJlbCxcbiAgICBmcmFtZSxcbiAgICBvcmlnLFxuICAgIHRyaW0sXG4gICAgZGVmYXVsdEFuY2hvcixcbiAgICBkZWZhdWx0Qm9yZGVycyxcbiAgICByb3RhdGVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIHRleHR1cmUgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcInRleHR1cmVcIik7XG4gICAgLyoqIEEgdXZzIG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZnJhbWUgYW5kIHRoZSB0ZXh0dXJlIHNvdXJjZSAqL1xuICAgIHRoaXMudXZzID0geyB4MDogMCwgeTA6IDAsIHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAwLCB4MzogMCwgeTM6IDAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAqXG4gICAgICogVGhpcyBtb2RlIGlzIGVuYWJsZWQgYXV0b21hdGljYWxseSBpZiBubyBmcmFtZSB3YXMgcGFzc2VkIGluc2lkZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgbW9kZSB0ZXh0dXJlIGlzIHN1YnNjcmliZWQgdG8gYmFzZVRleHR1cmUgZXZlbnRzLCBhbmQgZmlyZXMgYHVwZGF0ZWAgb24gYW55IGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEJld2FyZSwgYWZ0ZXIgbG9hZGluZyBvciByZXNpemUgb2YgYmFzZVRleHR1cmUgZXZlbnQgY2FuIGZpcmVkIHR3byB0aW1lcyFcbiAgICAgKiBJZiB5b3Ugd2FudCBtb3JlIGNvbnRyb2wsIHN1YnNjcmliZSBvbiBiYXNlVGV4dHVyZSBpdHNlbGYuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0ZXh0dXJlLm9uKCd1cGRhdGUnLCAoKSA9PiB7fSk7XG4gICAgICovXG4gICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG4gICAgLyoqIGlzIGl0IGEgdGV4dHVyZT8geWVzISB1c2VkIGZvciB0eXBlIGNoZWNraW5nICovXG4gICAgdGhpcy5pc1RleHR1cmUgPSB0cnVlO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZT8uc291cmNlID8/IG5ldyBUZXh0dXJlU291cmNlKCk7XG4gICAgdGhpcy5ub0ZyYW1lID0gIWZyYW1lO1xuICAgIGlmIChmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5jb3B5RnJvbShmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fc291cmNlO1xuICAgICAgdGhpcy5mcmFtZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5mcmFtZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMub3JpZyA9IG9yaWcgfHwgdGhpcy5mcmFtZTtcbiAgICB0aGlzLnRyaW0gPSB0cmltO1xuICAgIHRoaXMucm90YXRlID0gcm90YXRlID8/IDA7XG4gICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gZGVmYXVsdEFuY2hvcjtcbiAgICB0aGlzLmRlZmF1bHRCb3JkZXJzID0gZGVmYXVsdEJvcmRlcnM7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIHNldCBzb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwicmVzaXplXCIsIHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fc291cmNlID0gdmFsdWU7XG4gICAgdmFsdWUub24oXCJyZXNpemVcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogdGhlIHVuZGVybHlpbmcgc291cmNlIG9mIHRoZSB0ZXh0dXJlIChlcXVpdmFsZW50IG9mIGJhc2VUZXh0dXJlIGluIHY3KSAqL1xuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cbiAgLyoqIHJldHVybnMgYSBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIHRleHR1cmUuIEJ5IGRlZmF1bHQsIHRoYXQgb2JqZWN0IGlzIG5vdCBjcmVhdGVkIGJlY2F1c2UgaXRzIGhlYXZ5LiAqL1xuICBnZXQgdGV4dHVyZU1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3RleHR1cmVNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBuZXcgVGV4dHVyZU1hdHJpeCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVNYXRyaXg7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLmhlaWdodDtcbiAgfVxuICAvKiogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IGhhdmUgbW9kaWZpZWQgdGhlIGZyYW1lIG9mIHRoaXMgdGV4dHVyZS4gKi9cbiAgdXBkYXRlVXZzKCkge1xuICAgIGNvbnN0IHsgdXZzLCBmcmFtZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3NvdXJjZTtcbiAgICBjb25zdCBuWCA9IGZyYW1lLnggLyB3aWR0aDtcbiAgICBjb25zdCBuWSA9IGZyYW1lLnkgLyBoZWlnaHQ7XG4gICAgY29uc3QgblcgPSBmcmFtZS53aWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IG5IID0gZnJhbWUuaGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGxldCByb3RhdGUgPSB0aGlzLnJvdGF0ZTtcbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB3MiA9IG5XIC8gMjtcbiAgICAgIGNvbnN0IGgyID0gbkggLyAyO1xuICAgICAgY29uc3QgY1ggPSBuWCArIHcyO1xuICAgICAgY29uc3QgY1kgPSBuWSArIGgyO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCBncm91cEQ4Lk5XKTtcbiAgICAgIHV2cy54MCA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTAgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MSA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTEgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MiA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTIgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MyA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTMgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dnMueDAgPSBuWDtcbiAgICAgIHV2cy55MCA9IG5ZO1xuICAgICAgdXZzLngxID0gblggKyBuVztcbiAgICAgIHV2cy55MSA9IG5ZO1xuICAgICAgdXZzLngyID0gblggKyBuVztcbiAgICAgIHV2cy55MiA9IG5ZICsgbkg7XG4gICAgICB1dnMueDMgPSBuWDtcbiAgICAgIHV2cy55MyA9IG5ZICsgbkg7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICogQHBhcmFtIGRlc3Ryb3lTb3VyY2UgLSBEZXN0cm95IHRoZSBzb3VyY2Ugd2hlbiB0aGUgdGV4dHVyZSBpcyBkZXN0cm95ZWQuXG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lTb3VyY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChkZXN0cm95U291cmNlKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqIGNhbGwgdGhpcyBpZiB5b3UgaGF2ZSBtb2RpZmllZCB0aGUgYHRleHR1cmUgb3V0c2lkZWAgb2YgdGhlIGNvbnN0cnVjdG9yICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy5fc291cmNlLndpZHRoO1xuICAgICAgdGhpcy5mcmFtZS5oZWlnaHQgPSB0aGlzLl9zb3VyY2UuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgKi9cbiAgZ2V0IGJhc2VUZXh0dXJlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJUZXh0dXJlLmJhc2VUZXh0dXJlIGlzIG5vdyBUZXh0dXJlLnNvdXJjZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICB9XG59XG5UZXh0dXJlLkVNUFRZID0gbmV3IFRleHR1cmUoe1xuICBsYWJlbDogXCJFTVBUWVwiLFxuICBzb3VyY2U6IG5ldyBUZXh0dXJlU291cmNlKHtcbiAgICBsYWJlbDogXCJFTVBUWVwiXG4gIH0pXG59KTtcblRleHR1cmUuRU1QVFkuZGVzdHJveSA9IE5PT1A7XG5UZXh0dXJlLldISVRFID0gbmV3IFRleHR1cmUoe1xuICBzb3VyY2U6IG5ldyBCdWZmZXJJbWFnZVNvdXJjZSh7XG4gICAgcmVzb3VyY2U6IG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTVdKSxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgYWxwaGFNb2RlOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiLFxuICAgIGxhYmVsOiBcIldISVRFXCJcbiAgfSksXG4gIGxhYmVsOiBcIldISVRFXCJcbn0pO1xuVGV4dHVyZS5XSElURS5kZXN0cm95ID0gTk9PUDtcblxuZXhwb3J0IHsgVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9853\n')},575:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ TextureMatrix)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n\n\n"use strict";\nconst tempMat = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === "undefined") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener("update", this.update, this);\n    this._texture = value;\n    this._texture.addListener("update", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.pixelWidth;\n    this.uClampOffset[1] = offset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBNkQ7O0FBRTdEO0FBQ0Esb0JBQW9CLHFFQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxRUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlTWF0cml4Lm1qcz8zMzU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wTWF0ID0gbmV3IE1hdHJpeCgpO1xuY2xhc3MgVGV4dHVyZU1hdHJpeCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIG9ic2VydmVkIHRleHR1cmVcbiAgICogQHBhcmFtIGNsYW1wTWFyZ2luIC0gQ2hhbmdlcyBmcmFtZSBjbGFtcGluZywgMC41IGJ5IGRlZmF1bHQuIFVzZSAtMC41IGZvciBleHRyYSBib3JkZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBjbGFtcE1hcmdpbikge1xuICAgIHRoaXMubWFwQ29vcmQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy51Q2xhbXBGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgdGhpcy51Q2xhbXBPZmZzZXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmNsYW1wT2Zmc2V0ID0gMDtcbiAgICBpZiAodHlwZW9mIGNsYW1wTWFyZ2luID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmNsYW1wTWFyZ2luID0gdGV4dHVyZS53aWR0aCA8IDEwID8gMCA6IDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGFtcE1hcmdpbiA9IGNsYW1wTWFyZ2luO1xuICAgIH1cbiAgICB0aGlzLmlzU2ltcGxlID0gZmFsc2U7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgfVxuICAvKiogVGV4dHVyZSBwcm9wZXJ0eS4gKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90ZXh0dXJlPy5yZW1vdmVMaXN0ZW5lcihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuICAgIHRoaXMuX3RleHR1cmUuYWRkTGlzdGVuZXIoXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdXZzIGFycmF5IHRvIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0gdXZzIC0gbWVzaCB1dnNcbiAgICogQHBhcmFtIFtvdXQ9dXZzXSAtIG91dHB1dFxuICAgKiBAcmV0dXJucyAtIG91dHB1dFxuICAgKi9cbiAgbXVsdGlwbHlVdnModXZzLCBvdXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHtcbiAgICAgIG91dCA9IHV2cztcbiAgICB9XG4gICAgY29uc3QgbWF0ID0gdGhpcy5tYXBDb29yZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHV2c1tpXTtcbiAgICAgIGNvbnN0IHkgPSB1dnNbaSArIDFdO1xuICAgICAgb3V0W2ldID0geCAqIG1hdC5hICsgeSAqIG1hdC5jICsgbWF0LnR4O1xuICAgICAgb3V0W2kgKyAxXSA9IHggKiBtYXQuYiArIHkgKiBtYXQuZCArIG1hdC50eTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBtYXRyaWNlcyBpZiB0ZXh0dXJlIHdhcyBjaGFuZ2VkXG4gICAqIEByZXR1cm5zIC0gd2hldGhlciBvciBub3QgaXQgd2FzIHVwZGF0ZWRcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB0ZXggPSB0aGlzLl90ZXh0dXJlO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgY29uc3QgdXZzID0gdGV4LnV2cztcbiAgICB0aGlzLm1hcENvb3JkLnNldCh1dnMueDEgLSB1dnMueDAsIHV2cy55MSAtIHV2cy55MCwgdXZzLngzIC0gdXZzLngwLCB1dnMueTMgLSB1dnMueTAsIHV2cy54MCwgdXZzLnkwKTtcbiAgICBjb25zdCBvcmlnID0gdGV4Lm9yaWc7XG4gICAgY29uc3QgdHJpbSA9IHRleC50cmltO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB0ZW1wTWF0LnNldChcbiAgICAgICAgb3JpZy53aWR0aCAvIHRyaW0ud2lkdGgsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIG9yaWcuaGVpZ2h0IC8gdHJpbS5oZWlnaHQsXG4gICAgICAgIC10cmltLnggLyB0cmltLndpZHRoLFxuICAgICAgICAtdHJpbS55IC8gdHJpbS5oZWlnaHRcbiAgICAgICk7XG4gICAgICB0aGlzLm1hcENvb3JkLmFwcGVuZCh0ZW1wTWF0KTtcbiAgICB9XG4gICAgY29uc3QgdGV4QmFzZSA9IHRleC5zb3VyY2U7XG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLnVDbGFtcEZyYW1lO1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuY2xhbXBNYXJnaW4gLyB0ZXhCYXNlLl9yZXNvbHV0aW9uO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2xhbXBPZmZzZXQ7XG4gICAgZnJhbWVbMF0gPSAodGV4LmZyYW1lLnggKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICBmcmFtZVsxXSA9ICh0ZXguZnJhbWUueSArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcbiAgICBmcmFtZVsyXSA9ICh0ZXguZnJhbWUueCArIHRleC5mcmFtZS53aWR0aCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xuICAgIGZyYW1lWzNdID0gKHRleC5mcmFtZS55ICsgdGV4LmZyYW1lLmhlaWdodCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcbiAgICB0aGlzLnVDbGFtcE9mZnNldFswXSA9IG9mZnNldCAvIHRleEJhc2UucGl4ZWxXaWR0aDtcbiAgICB0aGlzLnVDbGFtcE9mZnNldFsxXSA9IG9mZnNldCAvIHRleEJhc2UucGl4ZWxIZWlnaHQ7XG4gICAgdGhpcy5pc1NpbXBsZSA9IHRleC5mcmFtZS53aWR0aCA9PT0gdGV4QmFzZS53aWR0aCAmJiB0ZXguZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodCAmJiB0ZXgucm90YXRlID09PSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHR1cmVNYXRyaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVNYXRyaXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///575\n')},4758:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ BufferImageSource)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3489);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n"use strict";\nclass BufferImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = "rgba32float";\n      } else if (buffer instanceof Int32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Uint32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Int16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Uint16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Int8Array) {\n        format = "bgra8unorm";\n      } else {\n        format = "bgra8unorm";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = "buffer";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=BufferSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc1OC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RTtBQUNyQjs7QUFFcEQ7QUFDQSxnQ0FBZ0Msc0VBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrRUFBYTs7QUFFZDtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9CdWZmZXJTb3VyY2UubWpzP2FiMGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJ1ZmZlckltYWdlU291cmNlIGV4dGVuZHMgVGV4dHVyZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBvcHRpb25zLnJlc291cmNlIHx8IG5ldyBGbG9hdDMyQXJyYXkob3B0aW9ucy53aWR0aCAqIG9wdGlvbnMuaGVpZ2h0ICogNCk7XG4gICAgbGV0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIGZvcm1hdCA9IFwicmdiYTMyZmxvYXRcIjtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICBmb3JtYXQgPSBcInJnYmEzMnVpbnRcIjtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJyZ2JhMzJ1aW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJyZ2JhMTZ1aW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGZvcm1hdCA9IFwicmdiYTE2dWludFwiO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJiZ3JhOHVub3JtXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBcImJncmE4dW5vcm1cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJlc291cmNlOiBidWZmZXIsXG4gICAgICBmb3JtYXRcbiAgICB9KTtcbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJidWZmZXJcIjtcbiAgfVxuICBzdGF0aWMgdGVzdChyZXNvdXJjZSkge1xuICAgIHJldHVybiByZXNvdXJjZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuQnVmZmVySW1hZ2VTb3VyY2UuZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5UZXh0dXJlU291cmNlO1xuXG5leHBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyU291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4758\n')},6914:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ CanvasSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3646);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3489);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n"use strict";\nclass CanvasSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter */ .z.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n}\nCanvasSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=CanvasSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkxNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0U7QUFDSztBQUNyQjs7QUFFcEQ7QUFDQSwyQkFBMkIsc0VBQWE7QUFDeEM7QUFDQTtBQUNBLHlCQUF5Qix5RUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRCxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtFQUFhOztBQUVkO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0NhbnZhc1NvdXJjZS5tanM/Y2QxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhbnZhc1NvdXJjZSBleHRlbmRzIFRleHR1cmVTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnJlc291cmNlKSB7XG4gICAgICBvcHRpb25zLnJlc291cmNlID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLndpZHRoKSB7XG4gICAgICBvcHRpb25zLndpZHRoID0gb3B0aW9ucy5yZXNvdXJjZS53aWR0aDtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRvRGVuc2l0eSkge1xuICAgICAgICBvcHRpb25zLndpZHRoIC89IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmhlaWdodCkge1xuICAgICAgb3B0aW9ucy5oZWlnaHQgPSBvcHRpb25zLnJlc291cmNlLmhlaWdodDtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRvRGVuc2l0eSkge1xuICAgICAgICBvcHRpb25zLmhlaWdodCAvPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBcImltYWdlXCI7XG4gICAgdGhpcy5hdXRvRGVuc2l0eSA9IG9wdGlvbnMuYXV0b0RlbnNpdHk7XG4gICAgY29uc3QgY2FudmFzID0gb3B0aW9ucy5yZXNvdXJjZTtcbiAgICBpZiAodGhpcy5waXhlbFdpZHRoICE9PSBjYW52YXMud2lkdGggfHwgdGhpcy5waXhlbFdpZHRoICE9PSBjYW52YXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gISFvcHRpb25zLnRyYW5zcGFyZW50O1xuICB9XG4gIHJlc2l6ZUNhbnZhcygpIHtcbiAgICBpZiAodGhpcy5hdXRvRGVuc2l0eSkge1xuICAgICAgdGhpcy5yZXNvdXJjZS5zdHlsZS53aWR0aCA9IGAke3RoaXMud2lkdGh9cHhgO1xuICAgICAgdGhpcy5yZXNvdXJjZS5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmhlaWdodH1weGA7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc291cmNlLndpZHRoICE9PSB0aGlzLnBpeGVsV2lkdGggfHwgdGhpcy5yZXNvdXJjZS5oZWlnaHQgIT09IHRoaXMucGl4ZWxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVzb3VyY2Uud2lkdGggPSB0aGlzLnBpeGVsV2lkdGg7XG4gICAgICB0aGlzLnJlc291cmNlLmhlaWdodCA9IHRoaXMucGl4ZWxIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJlc2l6ZSh3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LCByZXNvbHV0aW9uID0gdGhpcy5fcmVzb2x1dGlvbikge1xuICAgIGNvbnN0IGRpZFJlc2l6ZSA9IHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICBpZiAoZGlkUmVzaXplKSB7XG4gICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgIH1cbiAgICByZXR1cm4gZGlkUmVzaXplO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHJlc291cmNlKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTENhbnZhc0VsZW1lbnQgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCBnbG9iYWxUaGlzLk9mZnNjcmVlbkNhbnZhcyAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcztcbiAgfVxufVxuQ2FudmFzU291cmNlLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuVGV4dHVyZVNvdXJjZTtcblxuZXhwb3J0IHsgQ2FudmFzU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNTb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6914\n')},9160:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ ImageSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3646);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3489);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4796);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n\n"use strict";\nclass ImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter */ .z.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext("2d");\n      context.drawImage(options.resource, 0, 0);\n      options.resource = canvas;\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__/* .warn */ .Z)("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap;\n  }\n}\nImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=ImageSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9FO0FBQ0s7QUFDWjtBQUNUOztBQUVwRDtBQUNBLDBCQUEwQixzRUFBYTtBQUN2QztBQUNBO0FBQ0EscUJBQXFCLHlFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0VBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0VBQWE7O0FBRWQ7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzP2ZhMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuL1RleHR1cmVTb3VyY2UubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBJbWFnZVNvdXJjZSBleHRlbmRzIFRleHR1cmVTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVzb3VyY2UgJiYgKGdsb2JhbFRoaXMuSFRNTEltYWdlRWxlbWVudCAmJiBvcHRpb25zLnJlc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKG9wdGlvbnMucmVzb3VyY2Uud2lkdGgsIG9wdGlvbnMucmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2Uob3B0aW9ucy5yZXNvdXJjZSwgMCwgMCk7XG4gICAgICBvcHRpb25zLnJlc291cmNlID0gY2FudmFzO1xuICAgICAgd2FybihcIkltYWdlU291cmNlOiBJbWFnZSBlbGVtZW50IHBhc3NlZCwgY29udmVydGluZyB0byBjYW52YXMuIFVzZSBDYW52YXNTb3VyY2UgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBcImltYWdlXCI7XG4gICAgdGhpcy5hdXRvR2FyYmFnZUNvbGxlY3QgPSB0cnVlO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHJlc291cmNlKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTEltYWdlRWxlbWVudCAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gIH1cbn1cbkltYWdlU291cmNlLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuVGV4dHVyZVNvdXJjZTtcblxuZXhwb3J0IHsgSW1hZ2VTb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlU291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9160\n')},5206:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  p: () => (/* binding */ TextureSource)\n});\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs\n\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=definedProps.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs\n\n\n\n\n"use strict";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = (0,uid/* uid */.h)("resource");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = "textureSampler";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "TextureStyle.wrapMode is now TextureStyle.addressMode");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = "linear";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit("change", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: "clamp-to-edge",\n  scaleMode: "linear"\n};\nlet TextureStyle = _TextureStyle;\n\n\n//# sourceMappingURL=TextureStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs\n\n\n\n\n\n\n"use strict";\nconst _TextureSource = class _TextureSource extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = (0,uid/* uid */.h)("textureSource");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = "textureSource";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = "unknown";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = "rgba8unorm";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = "2d";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? "";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off("change", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on("change", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit("styleChange", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit("update", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    this.emit("unload", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit("resize", this);\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don\'t want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit("updateMipmaps", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = (0,pow2/* isPow2 */.wv)(this.pixelWidth) && (0,pow2/* isPow2 */.wv)(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error("Unimplemented");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: "bgra8unorm",\n  alphaMode: "premultiply-alpha-on-upload",\n  dimensions: "2d",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\n\n//# sourceMappingURL=TextureSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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IjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvZGVmaW5lZFByb3BzLm1qcz9mZTJmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVN0eWxlLm1qcz9hNmI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9UZXh0dXJlU291cmNlLm1qcz8zMTNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZGVmaW5lZFByb3BzKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9ialtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGRlZmluZWRQcm9wcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmaW5lZFByb3BzLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpZEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlSWRGcm9tU3RyaW5nKHZhbHVlKSB7XG4gIGNvbnN0IGlkID0gaWRIYXNoW3ZhbHVlXTtcbiAgaWYgKGlkID09PSB2b2lkIDApIHtcbiAgICBpZEhhc2hbdmFsdWVdID0gdWlkKFwicmVzb3VyY2VcIik7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuY29uc3QgX1RleHR1cmVTdHlsZSA9IGNsYXNzIF9UZXh0dXJlU3R5bGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgc3R5bGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJ0ZXh0dXJlU2FtcGxlclwiO1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbWF4aW11bSBhbmlzb3Ryb3B5IHZhbHVlIGNsYW1wIHVzZWQgYnkgdGhlIHNhbXBsZXIuXG4gICAgICogTm90ZTogTW9zdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCB7QGxpbmsgR1BVU2FtcGxlckRlc2NyaXB0b3IjbWF4QW5pc290cm9weX0gdmFsdWVzIGluIHJhbmdlXG4gICAgICogYmV0d2VlbiAxIGFuZCAxNiwgaW5jbHVzaXZlLiBUaGUgdXNlZCB2YWx1ZSBvZiB7QGxpbmsgR1BVU2FtcGxlckRlc2NyaXB0b3IjbWF4QW5pc290cm9weX0gd2lsbFxuICAgICAqIGJlIGNsYW1wZWQgdG8gdGhlIG1heGltdW0gdmFsdWUgdGhhdCB0aGUgcGxhdGZvcm0gc3VwcG9ydHMuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX21heEFuaXNvdHJvcHkgPSAxO1xuICAgIG9wdGlvbnMgPSB7IC4uLl9UZXh0dXJlU3R5bGUuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLmFkZHJlc3NNb2RlID0gb3B0aW9ucy5hZGRyZXNzTW9kZTtcbiAgICB0aGlzLmFkZHJlc3NNb2RlVSA9IG9wdGlvbnMuYWRkcmVzc01vZGVVID8/IHRoaXMuYWRkcmVzc01vZGVVO1xuICAgIHRoaXMuYWRkcmVzc01vZGVWID0gb3B0aW9ucy5hZGRyZXNzTW9kZVYgPz8gdGhpcy5hZGRyZXNzTW9kZVY7XG4gICAgdGhpcy5hZGRyZXNzTW9kZVcgPSBvcHRpb25zLmFkZHJlc3NNb2RlVyA/PyB0aGlzLmFkZHJlc3NNb2RlVztcbiAgICB0aGlzLnNjYWxlTW9kZSA9IG9wdGlvbnMuc2NhbGVNb2RlO1xuICAgIHRoaXMubWFnRmlsdGVyID0gb3B0aW9ucy5tYWdGaWx0ZXIgPz8gdGhpcy5tYWdGaWx0ZXI7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciA/PyB0aGlzLm1pbkZpbHRlcjtcbiAgICB0aGlzLm1pcG1hcEZpbHRlciA9IG9wdGlvbnMubWlwbWFwRmlsdGVyID8/IHRoaXMubWlwbWFwRmlsdGVyO1xuICAgIHRoaXMubG9kTWluQ2xhbXAgPSBvcHRpb25zLmxvZE1pbkNsYW1wO1xuICAgIHRoaXMubG9kTWF4Q2xhbXAgPSBvcHRpb25zLmxvZE1heENsYW1wO1xuICAgIHRoaXMuY29tcGFyZSA9IG9wdGlvbnMuY29tcGFyZTtcbiAgICB0aGlzLm1heEFuaXNvdHJvcHkgPSBvcHRpb25zLm1heEFuaXNvdHJvcHkgPz8gMTtcbiAgfVxuICBzZXQgYWRkcmVzc01vZGUodmFsdWUpIHtcbiAgICB0aGlzLmFkZHJlc3NNb2RlVSA9IHZhbHVlO1xuICAgIHRoaXMuYWRkcmVzc01vZGVWID0gdmFsdWU7XG4gICAgdGhpcy5hZGRyZXNzTW9kZVcgPSB2YWx1ZTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IHdyYXBNb2RlVSx3cmFwTW9kZVYgYW5kIHdyYXBNb2RlVyBhbGwgYXQgb25jZSEgKi9cbiAgZ2V0IGFkZHJlc3NNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNb2RlVTtcbiAgfVxuICBzZXQgd3JhcE1vZGUodmFsdWUpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiVGV4dHVyZVN0eWxlLndyYXBNb2RlIGlzIG5vdyBUZXh0dXJlU3R5bGUuYWRkcmVzc01vZGVcIik7XG4gICAgdGhpcy5hZGRyZXNzTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCB3cmFwTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzTW9kZTtcbiAgfVxuICBzZXQgc2NhbGVNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5tYWdGaWx0ZXIgPSB2YWx1ZTtcbiAgICB0aGlzLm1pbkZpbHRlciA9IHZhbHVlO1xuICAgIHRoaXMubWlwbWFwRmlsdGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqIHNldHRpbmcgdGhpcyB3aWxsIHNldCBtYWdGaWx0ZXIsbWluRmlsdGVyIGFuZCBtaXBtYXBGaWx0ZXIgYWxsIGF0IG9uY2UhICAqL1xuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1hZ0ZpbHRlcjtcbiAgfVxuICAvKiogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIGFuaXNvdHJvcHkgdmFsdWUgY2xhbXAgdXNlZCBieSB0aGUgc2FtcGxlci4gKi9cbiAgc2V0IG1heEFuaXNvdHJvcHkodmFsdWUpIHtcbiAgICB0aGlzLl9tYXhBbmlzb3Ryb3B5ID0gTWF0aC5taW4odmFsdWUsIDE2KTtcbiAgICBpZiAodGhpcy5fbWF4QW5pc290cm9weSA+IDEpIHtcbiAgICAgIHRoaXMuc2NhbGVNb2RlID0gXCJsaW5lYXJcIjtcbiAgICB9XG4gIH1cbiAgZ2V0IG1heEFuaXNvdHJvcHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heEFuaXNvdHJvcHk7XG4gIH1cbiAgLy8gVE9ETyAtIG1vdmUgdGhpcyB0byBXZWJHTD9cbiAgZ2V0IF9yZXNvdXJjZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGFyZWRSZXNvdXJjZUlkIHx8IHRoaXMuX2dlbmVyYXRlUmVzb3VyY2VJZCgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgdGhpcy5fc2hhcmVkUmVzb3VyY2VJZCA9IG51bGw7XG4gIH1cbiAgX2dlbmVyYXRlUmVzb3VyY2VJZCgpIHtcbiAgICBjb25zdCBiaWdLZXkgPSBgJHt0aGlzLmFkZHJlc3NNb2RlVX0tJHt0aGlzLmFkZHJlc3NNb2RlVn0tJHt0aGlzLmFkZHJlc3NNb2RlV30tJHt0aGlzLm1hZ0ZpbHRlcn0tJHt0aGlzLm1pbkZpbHRlcn0tJHt0aGlzLm1pcG1hcEZpbHRlcn0tJHt0aGlzLmxvZE1pbkNsYW1wfS0ke3RoaXMubG9kTWF4Q2xhbXB9LSR7dGhpcy5jb21wYXJlfS0ke3RoaXMuX21heEFuaXNvdHJvcHl9YDtcbiAgICB0aGlzLl9zaGFyZWRSZXNvdXJjZUlkID0gY3JlYXRlUmVzb3VyY2VJZEZyb21TdHJpbmcoYmlnS2V5KTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VJZDtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIHN0eWxlICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG59O1xuLyoqIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHN0eWxlICovXG5fVGV4dHVyZVN0eWxlLmRlZmF1bHRPcHRpb25zID0ge1xuICBhZGRyZXNzTW9kZTogXCJjbGFtcC10by1lZGdlXCIsXG4gIHNjYWxlTW9kZTogXCJsaW5lYXJcIlxufTtcbmxldCBUZXh0dXJlU3R5bGUgPSBfVGV4dHVyZVN0eWxlO1xuXG5leHBvcnQgeyBUZXh0dXJlU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgaXNQb3cyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5pbXBvcnQgeyBkZWZpbmVkUHJvcHMgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvdXRpbHMvZGVmaW5lZFByb3BzLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVN0eWxlIH0gZnJvbSAnLi4vVGV4dHVyZVN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1RleHR1cmVTb3VyY2UgPSBjbGFzcyBfVGV4dHVyZVNvdXJjZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgbmV3IFRleHR1cmVTb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIFRleHR1cmUgc291cmNlICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJ0ZXh0dXJlU291cmNlXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNvdXJjZSB0eXBlIHVzZWQgYnkgdGhpcyBUZXh0dXJlU291cmNlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIGJpbmQgZ3JvdXBzIHRvIGRldGVybWluZVxuICAgICAqIGhvdyB0byBoYW5kbGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJ0ZXh0dXJlU291cmNlXCI7XG4gICAgLyoqXG4gICAgICogaSB1bmlxdWUgcmVzb3VyY2UgaWQsIHVzZWQgYnkgdGhlIGJpbmQgZ3JvdXAgc3lzdGVtcy5cbiAgICAgKiBUaGlzIGNhbiBjaGFuZ2UgaWYgdGhlIHRleHR1cmUgaXMgcmVzaXplZCBvciBpdHMgcmVzb3VyY2UgY2hhbmdlc1xuICAgICAqL1xuICAgIHRoaXMuX3Jlc291cmNlSWQgPSB1aWQoXCJyZXNvdXJjZVwiKTtcbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGhvdyB0aGUgYmFja2VuZHMga25vdyBob3cgdG8gdXBsb2FkIHRoaXMgdGV4dHVyZSB0byB0aGUgR1BVXG4gICAgICogSXQgY2hhbmdlcyBkZXBlbmRpbmcgb24gdGhlIHJlc291cmNlIHR5cGUuIENsYXNzZXMgdGhhdCBleHRlbmQgVGV4dHVyZVNvdXJjZVxuICAgICAqIHNob3VsZCBvdmVycmlkZSB0aGlzIHByb3BlcnR5LlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gICAgLy8gZGltZW5zaW9uc1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSAxO1xuICAgIC8qKiB0aGUgcGl4ZWwgd2lkdGggb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZS4gVGhpcyBpcyB0aGUgUkVBTCBwdXJlIG51bWJlciwgbm90IGFjY291bnRpbmcgcmVzb2x1dGlvbiAqL1xuICAgIHRoaXMucGl4ZWxXaWR0aCA9IDE7XG4gICAgLyoqIHRoZSBwaXhlbCBoZWlnaHQgb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZS4gVGhpcyBpcyB0aGUgUkVBTCBwdXJlIG51bWJlciwgbm90IGFjY291bnRpbmcgcmVzb2x1dGlvbiAqL1xuICAgIHRoaXMucGl4ZWxIZWlnaHQgPSAxO1xuICAgIC8qKlxuICAgICAqIHRoZSB3aWR0aCBvZiB0aGlzIHRleHR1cmUgc291cmNlLCBhY2NvdW50aW5nIGZvciByZXNvbHV0aW9uXG4gICAgICogZWcgcGl4ZWxXaWR0aCAyMDAsIHJlc29sdXRpb24gMiwgdGhlbiB3aWR0aCB3aWxsIGJlIDEwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAxO1xuICAgIC8qKlxuICAgICAqIHRoZSBoZWlnaHQgb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZSwgYWNjb3VudGluZyBmb3IgcmVzb2x1dGlvblxuICAgICAqIGVnIHBpeGVsSGVpZ2h0IDIwMCwgcmVzb2x1dGlvbiAyLCB0aGVuIGhlaWdodCB3aWxsIGJlIDEwMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgb2YgYSBtdWx0aXNhbXBsZSB0ZXh0dXJlLiBUaGlzIGlzIGFsd2F5cyAxIGZvciBub24tbXVsdGlzYW1wbGUgdGV4dHVyZXMuXG4gICAgICogVG8gZW5hYmxlIG11bHRpc2FtcGxlIGZvciBhIHRleHR1cmUsIHNldCBhbnRpYWxpYXMgdG8gdHJ1ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLnNhbXBsZUNvdW50ID0gMTtcbiAgICAvKiogVGhlIG51bWJlciBvZiBtaXAgbGV2ZWxzIHRvIGdlbmVyYXRlIGZvciB0aGlzIHRleHR1cmUuIHRoaXMgaXMgIG92ZXJyaWRkZW4gaWYgYXV0b0dlbmVyYXRlTWlwbWFwcyBpcyB0cnVlICovXG4gICAgdGhpcy5taXBMZXZlbENvdW50ID0gMTtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgd2UgYXV0byBnZW5lcmF0ZSBtaXBtYXBzIGZvciB0aGlzIHRleHR1cmU/IFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIG1pcG1hcHNcbiAgICAgKiBmb3IgdGhpcyB0ZXh0dXJlIHdoZW4gdXBsb2FkaW5nIHRvIHRoZSBHUFUuIE1pcG1hcHBlZCB0ZXh0dXJlcyB0YWtlIHVwIG1vcmUgbWVtb3J5LCBidXRcbiAgICAgKiBjYW4gbG9vayBiZXR0ZXIgd2hlbiBzY2FsZWQgZG93bi5cbiAgICAgKlxuICAgICAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyByZWNvbW1lbmRlZCB0byBOT1QgdXNlIHRoaXMgd2l0aCBSZW5kZXJUZXh0dXJlcywgYXMgdGhleSBhcmUgb2Z0ZW4gdXBkYXRlZCBldmVyeSBmcmFtZS5cbiAgICAgKiBJZiB5b3UgZG8sIG1ha2Ugc3VyZSB0byBjYWxsIGB1cGRhdGVNaXBtYXBzYCBhZnRlciB5b3UgdXBkYXRlIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIHRoaXMuYXV0b0dlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIC8qKiB0aGUgZm9ybWF0IHRoYXQgdGhlIHRleHR1cmUgZGF0YSBoYXMgKi9cbiAgICB0aGlzLmZvcm1hdCA9IFwicmdiYTh1bm9ybVwiO1xuICAgIC8qKiBob3cgbWFueSBkaW1lbnNpb25zIGRvZXMgdGhpcyB0ZXh0dXJlIGhhdmU/IGN1cnJlbnRseSB2OCBvbmx5IHN1cHBvcnRzIDJkICovXG4gICAgdGhpcy5kaW1lbnNpb24gPSBcIjJkXCI7XG4gICAgLyoqXG4gICAgICogT25seSByZWFsbHkgYWZmZWN0cyBSZW5kZXJUZXh0dXJlcy5cbiAgICAgKiBTaG91bGQgd2UgdXNlIGFudGlhbGlhc2luZyBmb3IgdGhpcyB0ZXh0dXJlLiBJdCB3aWxsIGxvb2sgYmV0dGVyLCBidXQgbWF5IGltcGFjdCBwZXJmb3JtYW5jZSBhcyBhXG4gICAgICogQmxpdCBvcGVyYXRpb24gd2lsbCBiZSByZXF1aXJlZCB0byByZXNvbHZlIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIHRoaXMuYW50aWFsaWFzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBhdXRvbWF0aWMgdGV4dHVyZSBHYXJiYWdlIENvbGxlY3Rpb24sIHN0b3JlcyBsYXN0IEdDIHRpY2sgd2hlbiBpdCB3YXMgYm91bmRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fdG91Y2hlZCA9IDA7XG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgYmF0Y2hlciB0byBidWlsZCB0ZXh0dXJlIGJhdGNoZXMuIGZhc3RlciB0byBoYXZlIHRoZSB2YXJpYWJsZSBoZXJlIVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9iYXRjaFRpY2sgPSAtMTtcbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSBiYXRjaCBsb2NhdGlvbiBmb3IgdGhlIHRleHR1cmUgYmF0Y2hpbmcuIEhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgb25seSFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fdGV4dHVyZUJpbmRMb2NhdGlvbiA9IC0xO1xuICAgIG9wdGlvbnMgPSB7IC4uLl9UZXh0dXJlU291cmNlLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5sYWJlbCA9IG9wdGlvbnMubGFiZWwgPz8gXCJcIjtcbiAgICB0aGlzLnJlc291cmNlID0gb3B0aW9ucy5yZXNvdXJjZTtcbiAgICB0aGlzLmF1dG9HYXJiYWdlQ29sbGVjdCA9IG9wdGlvbnMuYXV0b0dhcmJhZ2VDb2xsZWN0O1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHRoaXMucGl4ZWxXaWR0aCA9IG9wdGlvbnMud2lkdGggKiB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpeGVsV2lkdGggPSB0aGlzLnJlc291cmNlID8gdGhpcy5yZXNvdXJjZVdpZHRoID8/IDEgOiAxO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgIHRoaXMucGl4ZWxIZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGl4ZWxIZWlnaHQgPSB0aGlzLnJlc291cmNlID8gdGhpcy5yZXNvdXJjZUhlaWdodCA/PyAxIDogMTtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucGl4ZWxXaWR0aCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBpeGVsSGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIHRoaXMuZGltZW5zaW9uID0gb3B0aW9ucy5kaW1lbnNpb25zO1xuICAgIHRoaXMubWlwTGV2ZWxDb3VudCA9IG9wdGlvbnMubWlwTGV2ZWxDb3VudDtcbiAgICB0aGlzLmF1dG9HZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zLmF1dG9HZW5lcmF0ZU1pcG1hcHM7XG4gICAgdGhpcy5zYW1wbGVDb3VudCA9IG9wdGlvbnMuc2FtcGxlQ291bnQ7XG4gICAgdGhpcy5hbnRpYWxpYXMgPSBvcHRpb25zLmFudGlhbGlhcztcbiAgICB0aGlzLmFscGhhTW9kZSA9IG9wdGlvbnMuYWxwaGFNb2RlO1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgVGV4dHVyZVN0eWxlKGRlZmluZWRQcm9wcyhvcHRpb25zKSk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gIH1cbiAgLyoqIHJldHVybnMgaXRzZWxmICovXG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIHRoZSBzdHlsZSBvZiB0aGUgdGV4dHVyZSAqL1xuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0eWxlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zdHlsZT8ub2ZmKFwiY2hhbmdlXCIsIHRoaXMuX29uU3R5bGVDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMuX3N0eWxlID0gdmFsdWU7XG4gICAgdGhpcy5fc3R5bGU/Lm9uKFwiY2hhbmdlXCIsIHRoaXMuX29uU3R5bGVDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMuX29uU3R5bGVDaGFuZ2UoKTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IHdyYXBNb2RlVSx3cmFwTW9kZVYgYW5kIHdyYXBNb2RlVyBhbGwgYXQgb25jZSEgKi9cbiAgZ2V0IGFkZHJlc3NNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5hZGRyZXNzTW9kZTtcbiAgfVxuICBzZXQgYWRkcmVzc01vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5hZGRyZXNzTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBzZXR0aW5nIHRoaXMgd2lsbCBzZXQgd3JhcE1vZGVVLHdyYXBNb2RlViBhbmQgd3JhcE1vZGVXIGFsbCBhdCBvbmNlISAqL1xuICBnZXQgcmVwZWF0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUuYWRkcmVzc01vZGU7XG4gIH1cbiAgc2V0IHJlcGVhdE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5hZGRyZXNzTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBTcGVjaWZpZXMgdGhlIHNhbXBsaW5nIGJlaGF2aW9yIHdoZW4gdGhlIHNhbXBsZSBmb290cHJpbnQgaXMgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIG9uZSB0ZXhlbC4gKi9cbiAgZ2V0IG1hZ0ZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubWFnRmlsdGVyO1xuICB9XG4gIHNldCBtYWdGaWx0ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKiogU3BlY2lmaWVzIHRoZSBzYW1wbGluZyBiZWhhdmlvciB3aGVuIHRoZSBzYW1wbGUgZm9vdHByaW50IGlzIGxhcmdlciB0aGFuIG9uZSB0ZXhlbC4gKi9cbiAgZ2V0IG1pbkZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubWluRmlsdGVyO1xuICB9XG4gIHNldCBtaW5GaWx0ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5taW5GaWx0ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKiogU3BlY2lmaWVzIGJlaGF2aW9yIGZvciBzYW1wbGluZyBiZXR3ZWVuIG1pcG1hcCBsZXZlbHMuICovXG4gIGdldCBtaXBtYXBGaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLm1pcG1hcEZpbHRlcjtcbiAgfVxuICBzZXQgbWlwbWFwRmlsdGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubWlwbWFwRmlsdGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqIFNwZWNpZmllcyB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZXZlbHMgb2YgZGV0YWlsLCByZXNwZWN0aXZlbHksIHVzZWQgaW50ZXJuYWxseSB3aGVuIHNhbXBsaW5nIGEgdGV4dHVyZS4gKi9cbiAgZ2V0IGxvZE1pbkNsYW1wKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5sb2RNaW5DbGFtcDtcbiAgfVxuICBzZXQgbG9kTWluQ2xhbXAodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5sb2RNaW5DbGFtcCA9IHZhbHVlO1xuICB9XG4gIC8qKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGV2ZWxzIG9mIGRldGFpbCwgcmVzcGVjdGl2ZWx5LCB1c2VkIGludGVybmFsbHkgd2hlbiBzYW1wbGluZyBhIHRleHR1cmUuICovXG4gIGdldCBsb2RNYXhDbGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubG9kTWF4Q2xhbXA7XG4gIH1cbiAgc2V0IGxvZE1heENsYW1wKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubG9kTWF4Q2xhbXAgPSB2YWx1ZTtcbiAgfVxuICBfb25TdHlsZUNoYW5nZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJzdHlsZUNoYW5nZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogY2FsbCB0aGlzIGlmIHlvdSBoYXZlIG1vZGlmaWVkIHRoZSB0ZXh0dXJlIG91dHNpZGUgb2YgdGhlIGNvbnN0cnVjdG9yICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuX3Jlc29sdXRpb247XG4gICAgICBjb25zdCBkaWRSZXNpemUgPSB0aGlzLnJlc2l6ZSh0aGlzLnJlc291cmNlV2lkdGggLyByZXNvbHV0aW9uLCB0aGlzLnJlc291cmNlSGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgICBpZiAoZGlkUmVzaXplKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyB0ZXh0dXJlIHNvdXJjZSAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIGlmICh0aGlzLl9zdHlsZSkge1xuICAgICAgdGhpcy5fc3R5bGUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gbnVsbDtcbiAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgdW5sb2FkIHRoZSBUZXh0dXJlIHNvdXJjZSBmcm9tIHRoZSBHUFUuIFRoaXMgd2lsbCBmcmVlIHVwIHRoZSBHUFUgbWVtb3J5XG4gICAqIEFzIHNvb24gYXMgaXQgaXMgcmVxdWlyZWQgZm9yZSByZW5kZXJpbmcsIGl0IHdpbGwgYmUgcmUtdXBsb2FkZWQuXG4gICAqL1xuICB1bmxvYWQoKSB7XG4gICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoXCJ1bmxvYWRcIiwgdGhpcyk7XG4gIH1cbiAgLyoqIHRoZSB3aWR0aCBvZiB0aGUgcmVzb3VyY2UuIFRoaXMgaXMgdGhlIFJFQUwgcHVyZSBudW1iZXIsIG5vdCBhY2NvdW50aW5nIHJlc29sdXRpb24gICAqL1xuICBnZXQgcmVzb3VyY2VXaWR0aCgpIHtcbiAgICBjb25zdCB7IHJlc291cmNlIH0gPSB0aGlzO1xuICAgIHJldHVybiByZXNvdXJjZS5uYXR1cmFsV2lkdGggfHwgcmVzb3VyY2UudmlkZW9XaWR0aCB8fCByZXNvdXJjZS5kaXNwbGF5V2lkdGggfHwgcmVzb3VyY2Uud2lkdGg7XG4gIH1cbiAgLyoqIHRoZSBoZWlnaHQgb2YgdGhlIHJlc291cmNlLiBUaGlzIGlzIHRoZSBSRUFMIHB1cmUgbnVtYmVyLCBub3QgYWNjb3VudGluZyByZXNvbHV0aW9uICovXG4gIGdldCByZXNvdXJjZUhlaWdodCgpIHtcbiAgICBjb25zdCB7IHJlc291cmNlIH0gPSB0aGlzO1xuICAgIHJldHVybiByZXNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHJlc291cmNlLnZpZGVvSGVpZ2h0IHx8IHJlc291cmNlLmRpc3BsYXlIZWlnaHQgfHwgcmVzb3VyY2UuaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS4gQ2hhbmdpbmcgdGhpcyBudW1iZXIsIHdpbGwgbm90IGNoYW5nZSB0aGUgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgYWN0dWFsIHRleHR1cmVcbiAgICogYnV0IHdpbGwgdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgd2hlbiByZW5kZXJlZC5cbiAgICpcbiAgICogY2hhbmdpbmcgdGhlIHJlc29sdXRpb24gb2YgdGhpcyB0ZXh0dXJlIHRvIDIgZm9yIGV4YW1wbGUgd2lsbCBtYWtlIGl0IGFwcGVhciB0d2ljZSBhcyBzbWFsbCB3aGVuIHJlbmRlcmVkIChhcyBwaXhlbFxuICAgKiBkZW5zaXR5IHdpbGwgaGF2ZSBpbmNyZWFzZWQpXG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdXRpb24gPT09IHJlc29sdXRpb24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucGl4ZWxXaWR0aCAvIHJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBpeGVsSGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVzaXplIHRoZSB0ZXh0dXJlLCB0aGlzIGlzIGhhbmR5IGlmIHlvdSB3YW50IHRvIHVzZSB0aGUgdGV4dHVyZSBhcyBhIHJlbmRlciB0ZXh0dXJlXG4gICAqIEBwYXJhbSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gdGhlIG5ldyByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlXG4gICAqIEByZXR1cm5zIC0gaWYgdGhlIHRleHR1cmUgd2FzIHJlc2l6ZWRcbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG5ld1BpeGVsV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgbmV3UGl4ZWxIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHJlc29sdXRpb24pO1xuICAgIHRoaXMud2lkdGggPSBuZXdQaXhlbFdpZHRoIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1BpeGVsSGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBpZiAodGhpcy5waXhlbFdpZHRoID09PSBuZXdQaXhlbFdpZHRoICYmIHRoaXMucGl4ZWxIZWlnaHQgPT09IG5ld1BpeGVsSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICB0aGlzLnBpeGVsV2lkdGggPSBuZXdQaXhlbFdpZHRoO1xuICAgIHRoaXMucGl4ZWxIZWlnaHQgPSBuZXdQaXhlbEhlaWdodDtcbiAgICB0aGlzLmVtaXQoXCJyZXNpemVcIiwgdGhpcyk7XG4gICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogTGV0cyB0aGUgcmVuZGVyZXIga25vdyB0aGF0IHRoaXMgdGV4dHVyZSBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgbWlwbWFwcyBzaG91bGQgYmUgcmUtZ2VuZXJhdGVkLlxuICAgKiBUaGlzIGlzIG9ubHkgaW1wb3J0YW50IGZvciBSZW5kZXJUZXh0dXJlIGluc3RhbmNlcywgYXMgc3RhbmRhcmQgVGV4dHVyZSBpbnN0YW5jZXMgd2lsbCBoYXZlIHRoZWlyXG4gICAqIG1pcG1hcHMgZ2VuZXJhdGVkIG9uIHVwbG9hZC4gWW91IHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGFmdGVyIHlvdSBtYWtlIGFueSBjaGFuZ2UgdG8gdGhlIHRleHR1cmVcbiAgICpcbiAgICogVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyBpcyBjYW4gYmUgcXVpdGUgZXhwZW5zaXZlIHRvIHVwZGF0ZSBtaXBtYXBzIGZvciBhIHRleHR1cmUuIFNvIGJ5IGRlZmF1bHQsXG4gICAqIFdlIHdhbnQgeW91LCB0aGUgZGV2ZWxvcGVyIHRvIHNwZWNpZnkgd2hlbiB0aGlzIGFjdGlvbiBzaG91bGQgaGFwcGVuLlxuICAgKlxuICAgKiBHZW5lcmFsbHkgeW91IGRvbid0IHdhbnQgdG8gaGF2ZSBtaXBtYXBzIGdlbmVyYXRlZCBvbiBSZW5kZXIgdGFyZ2V0cyB0aGF0IGFyZSBjaGFuZ2VkIGV2ZXJ5IGZyYW1lLFxuICAgKi9cbiAgdXBkYXRlTWlwbWFwcygpIHtcbiAgICBpZiAodGhpcy5hdXRvR2VuZXJhdGVNaXBtYXBzICYmIHRoaXMubWlwTGV2ZWxDb3VudCA+IDEpIHtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZU1pcG1hcHNcIiwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHNldCB3cmFwTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX3N0eWxlLndyYXBNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHdyYXBNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS53cmFwTW9kZTtcbiAgfVxuICBzZXQgc2NhbGVNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUuc2NhbGVNb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqIHNldHRpbmcgdGhpcyB3aWxsIHNldCBtYWdGaWx0ZXIsbWluRmlsdGVyIGFuZCBtaXBtYXBGaWx0ZXIgYWxsIGF0IG9uY2UhICAqL1xuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5zY2FsZU1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZnJlc2ggY2hlY2sgZm9yIGlzUG93ZXJPZlR3byB0ZXh0dXJlIGJhc2VkIG9uIHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWZyZXNoUE9UKCkge1xuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gaXNQb3cyKHRoaXMucGl4ZWxXaWR0aCkgJiYgaXNQb3cyKHRoaXMucGl4ZWxIZWlnaHQpO1xuICB9XG4gIHN0YXRpYyB0ZXN0KF9yZXNvdXJjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWRcIik7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyB1c2VkIHdoZW4gY3JlYXRpbmcgYSBuZXcgVGV4dHVyZVNvdXJjZS4gb3ZlcnJpZGUgdGhlc2UgdG8gYWRkIHlvdXIgb3duIGRlZmF1bHRzICovXG5fVGV4dHVyZVNvdXJjZS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogMSxcbiAgZm9ybWF0OiBcImJncmE4dW5vcm1cIixcbiAgYWxwaGFNb2RlOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiLFxuICBkaW1lbnNpb25zOiBcIjJkXCIsXG4gIG1pcExldmVsQ291bnQ6IDEsXG4gIGF1dG9HZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICBzYW1wbGVDb3VudDogMSxcbiAgYW50aWFsaWFzOiBmYWxzZSxcbiAgYXV0b0dhcmJhZ2VDb2xsZWN0OiBmYWxzZVxufTtcbmxldCBUZXh0dXJlU291cmNlID0gX1RleHR1cmVTb3VyY2U7XG5cbmV4cG9ydCB7IFRleHR1cmVTb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVTb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5206\n')},914:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ VideoSource)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3489);\n/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9366);\n/* harmony import */ var _utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5447);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n\n"use strict";\nconst _VideoSource = class _VideoSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = "video";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker */ .v.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener("play", this._onPlayStart);\n    source.addEventListener("pause", this._onPlayStop);\n    source.addEventListener("seeked", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener("canplay", this._onCanPlay);\n      }\n      source.addEventListener("canplaythrough", this._onCanPlayThrough);\n      source.addEventListener("error", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await (0,_utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_2__/* .detectVideoAlphaMode */ .D)();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener("error", this._onError, true);\n    this.emit("error", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener("canplay", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener("canplaythrough", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener("play", this._onPlayStart);\n      source.removeEventListener("pause", this._onPlayStop);\n      source.removeEventListener("seeked", this._onSeeked);\n      source.removeEventListener("canplay", this._onCanPlay);\n      source.removeEventListener("canplaythrough", this._onCanPlayThrough);\n      source.removeEventListener("error", this._onError, true);\n      source.pause();\n      source.src = "";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser\'s native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video\'s state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn\'t playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.source.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker */ .v.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker */ .v.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Ticker */ .v.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n};\n_VideoSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ExtensionType */ .nw.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ..._TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can\'t be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\nlet VideoSource = _VideoSource;\n\n\n//# sourceMappingURL=VideoSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUU7QUFDZjtBQUNtQztBQUN6Qzs7QUFFcEQ7QUFDQSxnREFBZ0Qsc0VBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkJBQTJCLHNHQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUJBQXlCO0FBQ2pHLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrRUFBYTtBQUN0QztBQUNBO0FBQ0EsS0FBSyxzRUFBYTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL1ZpZGVvU291cmNlLm1qcz81NWY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRpY2tlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3RpY2tlci9UaWNrZXIubWpzJztcbmltcG9ydCB7IGRldGVjdFZpZGVvQWxwaGFNb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvYnJvd3Nlci9kZXRlY3RWaWRlb0FscGhhTW9kZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9WaWRlb1NvdXJjZSA9IGNsYXNzIF9WaWRlb1NvdXJjZSBleHRlbmRzIFRleHR1cmVTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgLy8gUHVibGljXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5LiAqL1xuICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgIC8qKiBUaGUgdXBsb2FkIG1ldGhvZCBmb3IgdGhpcyB0ZXh0dXJlLiAqL1xuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBcInZpZGVvXCI7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLl9WaWRlb1NvdXJjZS5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGVGUFMgPSBvcHRpb25zLnVwZGF0ZUZQUyB8fCAwO1xuICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2U7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSBvcHRpb25zLmFscGhhTW9kZSA/PyBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgPSB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9vbkNhblBsYXkgPSB0aGlzLl9vbkNhblBsYXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNhblBsYXlUaHJvdWdoID0gdGhpcy5fb25DYW5QbGF5VGhyb3VnaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25QbGF5U3RhcnQgPSB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUGxheVN0b3AgPSB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TZWVrZWQgPSB0aGlzLl9vblNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdm9pZCB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqIFVwZGF0ZSB0aGUgdmlkZW8gZnJhbWUgaWYgdGhlIHNvdXJjZSBpcyBub3QgZGVzdHJveWVkIGFuZCBtZWV0cyBjZXJ0YWluIGNvbmRpdGlvbnMuICovXG4gIHVwZGF0ZUZyYW1lKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdXBkYXRlRlBTKSB7XG4gICAgICBjb25zdCBlbGFwc2VkTVMgPSBUaWNrZXIuc2hhcmVkLmVsYXBzZWRNUyAqIHRoaXMucmVzb3VyY2UucGxheWJhY2tSYXRlO1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSBNYXRoLmZsb29yKHRoaXMuX21zVG9OZXh0VXBkYXRlIC0gZWxhcHNlZE1TKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl91cGRhdGVGUFMgfHwgdGhpcy5fbXNUb05leHRVcGRhdGUgPD0gMCkge1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSB0aGlzLl91cGRhdGVGUFMgPyBNYXRoLmZsb29yKDFlMyAvIHRoaXMuX3VwZGF0ZUZQUykgOiAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICAvKiogQ2FsbGJhY2sgdG8gdXBkYXRlIHRoZSB2aWRlbyBmcmFtZSBhbmQgcG90ZW50aWFsbHkgcmVxdWVzdCB0aGUgbmV4dCBmcmFtZSB1cGRhdGUuICovXG4gIF92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrKCkge1xuICAgIHRoaXMudXBkYXRlRnJhbWUoKTtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gdGhpcy5zb3VyY2UucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhcbiAgICAgICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcmVzb3VyY2UgaGFzIHZhbGlkIGRpbWVuc2lvbnMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZXNvdXJjZS52aWRlb1dpZHRoICYmICEhdGhpcy5yZXNvdXJjZS52aWRlb0hlaWdodDtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgcHJlbG9hZGluZyB0aGUgdmlkZW8gcmVzb3VyY2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHRoaXM+fSBIYW5kbGUgdGhlIHZhbGlkYXRlIGV2ZW50XG4gICAqL1xuICBhc3luYyBsb2FkKCkge1xuICAgIGlmICh0aGlzLl9sb2FkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgoc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0VOT1VHSF9EQVRBIHx8IHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9GVVRVUkVfREFUQSkgJiYgc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpIHtcbiAgICAgIHNvdXJjZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydCk7XG4gICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB0aGlzLl9vblBsYXlTdG9wKTtcbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCB0aGlzLl9vblNlZWtlZCk7XG4gICAgaWYgKCF0aGlzLl9pc1NvdXJjZVJlYWR5KCkpIHtcbiAgICAgIGlmICghb3B0aW9ucy5wcmVsb2FkKSB7XG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgfVxuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9vbkNhblBsYXlUaHJvdWdoKTtcbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21lZGlhUmVhZHkoKTtcbiAgICB9XG4gICAgdGhpcy5hbHBoYU1vZGUgPSBhd2FpdCBkZXRlY3RWaWRlb0FscGhhTW9kZSgpO1xuICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICBpZiAob3B0aW9ucy5wcmVsb2FkVGltZW91dE1zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLl9wcmVsb2FkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3JFdmVudChgUHJlbG9hZCBleGNlZWRlZCB0aW1lb3V0IG9mICR7b3B0aW9ucy5wcmVsb2FkVGltZW91dE1zfW1zYCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZS5sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSB2aWRlbyBlcnJvciBldmVudHMuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBlcnJvciBldmVudFxuICAgKi9cbiAgX29uRXJyb3IoZXZlbnQpIHtcbiAgICB0aGlzLnJlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCB0cnVlKTtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBldmVudCk7XG4gICAgaWYgKHRoaXMuX3JlamVjdCkge1xuICAgICAgdGhpcy5fcmVqZWN0KGV2ZW50KTtcbiAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcGxheWluZy5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBwbGF5aW5nLlxuICAgKi9cbiAgX2lzU291cmNlUGxheWluZygpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIHJldHVybiAhc291cmNlLnBhdXNlZCAmJiAhc291cmNlLmVuZGVkO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGlzIHJlYWR5IGZvciBwbGF5aW5nLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHJlYWR5LlxuICAgKi9cbiAgX2lzU291cmNlUmVhZHkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICByZXR1cm4gc291cmNlLnJlYWR5U3RhdGUgPiAyO1xuICB9XG4gIC8qKiBSdW5zIHRoZSB1cGRhdGUgbG9vcCB3aGVuIHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5LiAqL1xuICBfb25QbGF5U3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHRoaXMuX21lZGlhUmVhZHkoKTtcbiAgICB9XG4gICAgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICB9XG4gIC8qKiBTdG9wcyB0aGUgdXBkYXRlIGxvb3Agd2hlbiBhIHBhdXNlIGV2ZW50IGlzIHRyaWdnZXJlZC4gKi9cbiAgX29uUGxheVN0b3AoKSB7XG4gICAgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICB9XG4gIC8qKiBIYW5kbGVzIGJlaGF2aW9yIHdoZW4gdGhlIHZpZGVvIGNvbXBsZXRlcyBzZWVraW5nIHRvIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uLiAqL1xuICBfb25TZWVrZWQoKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzU291cmNlUGxheWluZygpKSB7XG4gICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgICB0aGlzLnVwZGF0ZUZyYW1lKCk7XG4gICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgfVxuICB9XG4gIF9vbkNhblBsYXkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICB0aGlzLl9tZWRpYVJlYWR5KCk7XG4gIH1cbiAgX29uQ2FuUGxheVRocm91Z2goKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgaWYgKHRoaXMuX3ByZWxvYWRUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcHJlbG9hZFRpbWVvdXQpO1xuICAgICAgdGhpcy5fcHJlbG9hZFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuX21lZGlhUmVhZHkoKTtcbiAgfVxuICAvKiogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgbG9hZGVkIGFuZCByZWFkeSB0byBwbGF5LiAqL1xuICBfbWVkaWFSZWFkeSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc291cmNlO1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZShzb3VyY2UudmlkZW9XaWR0aCwgc291cmNlLnZpZGVvSGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgIHRoaXMudXBkYXRlRnJhbWUoKTtcbiAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmUodGhpcyk7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgdGhpcy5fb25QbGF5U3RhcnQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b1BsYXkpIHtcbiAgICAgIHZvaWQgdGhpcy5yZXNvdXJjZS5wbGF5KCk7XG4gICAgfVxuICB9XG4gIC8qKiBDbGVhbnMgdXAgcmVzb3VyY2VzIGFuZCBldmVudCBsaXN0ZW5lcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGV4dHVyZS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jb25maWd1cmVBdXRvVXBkYXRlKCk7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBsYXlcIiwgdGhpcy5fb25QbGF5U3RhcnQpO1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB0aGlzLl9vblBsYXlTdG9wKTtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX29uU2Vla2VkKTtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9vbkNhblBsYXlUaHJvdWdoKTtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgdHJ1ZSk7XG4gICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIHNvdXJjZS5zcmMgPSBcIlwiO1xuICAgICAgc291cmNlLmxvYWQoKTtcbiAgICB9XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIC8qKiBTaG91bGQgdGhlIGJhc2UgdGV4dHVyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZSBpdHNlbGYsIHNldCB0byB0cnVlIGJ5IGRlZmF1bHQuICovXG4gIGdldCBhdXRvVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICB9XG4gIHNldCBhdXRvVXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWU7XG4gICAgICB0aGlzLl9jb25maWd1cmVBdXRvVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIb3cgbWFueSB0aW1lcyBhIHNlY29uZCB0byB1cGRhdGUgdGhlIHRleHR1cmUgZnJvbSB0aGUgdmlkZW8uXG4gICAqIExlYXZlIGF0IDAgdG8gdXBkYXRlIGF0IGV2ZXJ5IHJlbmRlci5cbiAgICogQSBsb3dlciBmcHMgY2FuIGhlbHAgcGVyZm9ybWFuY2UsIGFzIHVwZGF0aW5nIHRoZSB0ZXh0dXJlIGF0IDYwZnBzIG9uIGEgMzBwcyB2aWRlbyBtYXkgbm90IGJlIGVmZmljaWVudC5cbiAgICovXG4gIGdldCB1cGRhdGVGUFMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZQUztcbiAgfVxuICBzZXQgdXBkYXRlRlBTKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl91cGRhdGVGUFMpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUZQUyA9IHZhbHVlO1xuICAgICAgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgdXBkYXRpbmcgbWVjaGFuaXNtIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBzZXR0aW5ncy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGVjaWRlcyBiZXR3ZWVuIHVzaW5nIHRoZSBicm93c2VyJ3MgbmF0aXZlIHZpZGVvIGZyYW1lIGNhbGxiYWNrIG9yIGEgY3VzdG9tIHRpY2tlclxuICAgKiBmb3IgdXBkYXRpbmcgdGhlIHZpZGVvIGZyYW1lLiBJdCBlbnN1cmVzIG9wdGltYWwgcGVyZm9ybWFuY2UgYW5kIHJlc3BvbnNpdmVuZXNzXG4gICAqIGJhc2VkIG9uIHRoZSB2aWRlbydzIHN0YXRlLCBwbGF5YmFjayBzdGF0dXMsIGFuZCB0aGUgZGVzaXJlZCBmcmFtZXMtcGVyLXNlY29uZCBzZXR0aW5nLlxuICAgKlxuICAgKiAtIElmIGBfYXV0b1VwZGF0ZWAgaXMgZW5hYmxlZCBhbmQgdGhlIHZpZGVvIHNvdXJjZSBpcyBwbGF5aW5nOlxuICAgKiAgIC0gSXQgd2lsbCBwcmVmZXIgdGhlIG5hdGl2ZSB2aWRlbyBmcmFtZSBjYWxsYmFjayBpZiBhdmFpbGFibGUgYW5kIG5vIHNwZWNpZmljIEZQUyBpcyBzZXQuXG4gICAqICAgLSBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIGEgY3VzdG9tIHRpY2tlciBmb3IgbWFudWFsIHVwZGF0ZXMuXG4gICAqIC0gSWYgYF9hdXRvVXBkYXRlYCBpcyBkaXNhYmxlZCBvciB0aGUgdmlkZW8gaXNuJ3QgcGxheWluZywgYW55IGFjdGl2ZSB1cGRhdGUgbWVjaGFuaXNtcyBhcmUgaGFsdGVkLlxuICAgKi9cbiAgX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgdGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcbiAgICAgIGlmICghdGhpcy5fdXBkYXRlRlBTICYmIHRoaXMuc291cmNlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgICBUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZUZyYW1lLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IHRoaXMuc291cmNlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soXG4gICAgICAgICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZS5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2sodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSk7XG4gICAgICAgICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICAgICAgVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGVGcmFtZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc291cmNlLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlKTtcbiAgICAgICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgICBUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZUZyYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0ZXN0KHJlc291cmNlKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTFZpZGVvRWxlbWVudCAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHwgZ2xvYmFsVGhpcy5WaWRlb0ZyYW1lICYmIHJlc291cmNlIGluc3RhbmNlb2YgVmlkZW9GcmFtZTtcbiAgfVxufTtcbl9WaWRlb1NvdXJjZS5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLlRleHR1cmVTb3VyY2U7XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdmlkZW8gc291cmNlcy4gKi9cbl9WaWRlb1NvdXJjZS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLi4uVGV4dHVyZVNvdXJjZS5kZWZhdWx0T3B0aW9ucyxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIHN0YXJ0IGxvYWRpbmcgaW1tZWRpYXRlbHkuICovXG4gIGF1dG9Mb2FkOiB0cnVlLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgc3RhcnQgcGxheWluZyBhcyBzb29uIGFzIGl0IGlzIGxvYWRlZC4gKi9cbiAgYXV0b1BsYXk6IHRydWUsXG4gIC8qKiBUaGUgbnVtYmVyIG9mIHRpbWVzIGEgc2Vjb25kIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSB2aWRlby4gTGVhdmUgYXQgMCB0byB1cGRhdGUgYXQgZXZlcnkgcmVuZGVyLiAqL1xuICB1cGRhdGVGUFM6IDAsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBiZSBsb2FkZWQgd2l0aCB0aGUgYGNyb3Nzb3JpZ2luYCBhdHRyaWJ1dGUuICovXG4gIGNyb3Nzb3JpZ2luOiB0cnVlLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgbG9vcCB3aGVuIGl0IGVuZHMuICovXG4gIGxvb3A6IGZhbHNlLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgYmUgbXV0ZWQuICovXG4gIG11dGVkOiB0cnVlLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgcGxheSBpbmxpbmUuICovXG4gIHBsYXlzaW5saW5lOiB0cnVlLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgYmUgcHJlbG9hZGVkLiAqL1xuICBwcmVsb2FkOiBmYWxzZVxufTtcbi8qKlxuICogTWFwIG9mIHZpZGVvIE1JTUUgdHlwZXMgdGhhdCBjYW4ndCBiZSBkaXJlY3RseSBkZXJpdmVkIGZyb20gZmlsZSBleHRlbnNpb25zLlxuICogQHJlYWRvbmx5XG4gKi9cbl9WaWRlb1NvdXJjZS5NSU1FX1RZUEVTID0ge1xuICBvZ3Y6IFwidmlkZW8vb2dnXCIsXG4gIG1vdjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgbTR2OiBcInZpZGVvL21wNFwiXG59O1xubGV0IFZpZGVvU291cmNlID0gX1ZpZGVvU291cmNlO1xuXG5leHBvcnQgeyBWaWRlb1NvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlkZW9Tb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///914\n')},4325:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* unused harmony exports autoDetectSource, resourceToTexture, textureFrom */\n/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4162);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3489);\n/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5206);\n/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9853);\n\n\n\n\n\n"use strict";\nconst sources = [];\n_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .extensions */ .Rw.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType */ .nw.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.has(resource)) {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.get(resource);\n  }\n  const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: autoDetectSource(opts) });\n  texture.on("destroy", () => {\n    if (_assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.has(resource)) {\n      _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === "string") {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.get(id);\n  } else if (id instanceof _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__/* .TextureSource */ .p) {\n    return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\n_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x.from = textureFrom;\n\n\n//# sourceMappingURL=textureFrom.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMyNS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUN1QjtBQUN4QjtBQUNwQjs7QUFFekM7QUFDQTtBQUNBLDRFQUFVLGNBQWMsK0VBQWE7QUFDckMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQkFBb0IsbUVBQUs7QUFDekIsV0FBVyxtRUFBSztBQUNoQjtBQUNBLHNCQUFzQiwwREFBTyxHQUFHLGdDQUFnQztBQUNoRTtBQUNBLFFBQVEsbUVBQUs7QUFDYixNQUFNLG1FQUFLO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLG1FQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQUs7QUFDaEIsSUFBSSx1QkFBdUIsOEVBQWE7QUFDeEMsZUFBZSwwREFBTyxHQUFHLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMERBQU87O0FBRXFEO0FBQzVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy90ZXh0dXJlRnJvbS5tanM/OWFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgZXh0ZW5zaW9ucywgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4uL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL1RleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzb3VyY2VzID0gW107XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLlRleHR1cmVTb3VyY2UsIHNvdXJjZXMpO1xuZnVuY3Rpb24gYXV0b0RldGVjdFNvdXJjZShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaGFzUmVzb3VyY2UgPSBvcHRpb25zICYmIG9wdGlvbnMucmVzb3VyY2U7XG4gIGNvbnN0IHJlcyA9IGhhc1Jlc291cmNlID8gb3B0aW9ucy5yZXNvdXJjZSA6IG9wdGlvbnM7XG4gIGNvbnN0IG9wdHMgPSBoYXNSZXNvdXJjZSA/IG9wdGlvbnMgOiB7IHJlc291cmNlOiBvcHRpb25zIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKFNvdXJjZS50ZXN0KHJlcykpIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlKG9wdHMpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgc291cmNlIHR5cGUgZm9yIHJlc291cmNlOiAke29wdHMucmVzb3VyY2V9YCk7XG59XG5mdW5jdGlvbiByZXNvdXJjZVRvVGV4dHVyZShvcHRpb25zID0ge30sIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGhhc1Jlc291cmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc291cmNlO1xuICBjb25zdCByZXNvdXJjZSA9IGhhc1Jlc291cmNlID8gb3B0aW9ucy5yZXNvdXJjZSA6IG9wdGlvbnM7XG4gIGNvbnN0IG9wdHMgPSBoYXNSZXNvdXJjZSA/IG9wdGlvbnMgOiB7IHJlc291cmNlOiBvcHRpb25zIH07XG4gIGlmICghc2tpcENhY2hlICYmIENhY2hlLmhhcyhyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gQ2FjaGUuZ2V0KHJlc291cmNlKTtcbiAgfVxuICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoeyBzb3VyY2U6IGF1dG9EZXRlY3RTb3VyY2Uob3B0cykgfSk7XG4gIHRleHR1cmUub24oXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICBpZiAoQ2FjaGUuaGFzKHJlc291cmNlKSkge1xuICAgICAgQ2FjaGUucmVtb3ZlKHJlc291cmNlKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXNraXBDYWNoZSkge1xuICAgIENhY2hlLnNldChyZXNvdXJjZSwgdGV4dHVyZSk7XG4gIH1cbiAgcmV0dXJuIHRleHR1cmU7XG59XG5mdW5jdGlvbiB0ZXh0dXJlRnJvbShpZCwgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgaWYgKHR5cGVvZiBpZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBDYWNoZS5nZXQoaWQpO1xuICB9IGVsc2UgaWYgKGlkIGluc3RhbmNlb2YgVGV4dHVyZVNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgVGV4dHVyZSh7IHNvdXJjZTogaWQgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc291cmNlVG9UZXh0dXJlKGlkLCBza2lwQ2FjaGUpO1xufVxuVGV4dHVyZS5mcm9tID0gdGV4dHVyZUZyb207XG5cbmV4cG9ydCB7IGF1dG9EZXRlY3RTb3VyY2UsIHJlc291cmNlVG9UZXh0dXJlLCB0ZXh0dXJlRnJvbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZUZyb20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4325\n')},8400:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  W2: () => (/* binding */ Container),\n  pA: () => (/* binding */ UPDATE_BLEND),\n  wO: () => (/* binding */ UPDATE_COLOR),\n  Jm: () => (/* binding */ UPDATE_VISIBLE)\n});\n\n// UNUSED EXPORTS: UPDATE_TRANSFORM\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/culling/cullingMixin.mjs\n\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\n\n//# sourceMappingURL=cullingMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/const.mjs\nvar misc_const = __webpack_require__(5502);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs\nvar ObservablePoint = __webpack_require__(4973);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/removeItems.mjs\nvar removeItems = __webpack_require__(7040);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs\n\n\n\n"use strict";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        if (this.renderGroup) {\n          this.renderGroup.removeChild(child);\n        }\n        removed.push(child);\n        child.parent = null;\n      }\n      (0,removeItems/* removeItems */.E)(this.children, beginIndex, end);\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit("childRemoved", removed[i], this, i);\n        removed[i].emit("removed", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error("The supplied Container must be a child of the caller");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "addChildAt: Only Containers will be allowed to add children in v8.0.0");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit("childAdded", child, this, index);\n    child.emit("added", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n};\n\n\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/FilterEffect.mjs\nvar FilterEffect = __webpack_require__(6282);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs\n\n\n\n"use strict";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return PoolGroup/* BigPool */.u.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    PoolGroup/* BigPool */.u.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.MaskEffect, MaskEffectManager._effectClasses);\n\n\n//# sourceMappingURL=MaskEffectManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs\n\n\n\n\n"use strict";\nconst effectsMixin = {\n  _mask: null,\n  _filters: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    if (this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (!this.isRenderGroupRoot && this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    this._mask || (this._mask = { mask: null, effect: null });\n    if (this._mask.mask === value)\n      return;\n    if (this._mask.effect) {\n      this.removeEffect(this._mask.effect);\n      MaskEffectManager.returnMaskEffect(this._mask.effect);\n      this._mask.effect = null;\n    }\n    this._mask.mask = value;\n    if (value === null || value === void 0)\n      return;\n    const effect = MaskEffectManager.getMaskEffect(value);\n    this._mask.effect = effect;\n    this.addEffect(effect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container\'s width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from \'pixi.js\';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._mask?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    value = value;\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    const hasFilters = value?.length > 0;\n    const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    this._filters.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        const effect = PoolGroup/* BigPool */.u.get(FilterEffect/* FilterEffect */.U);\n        this._filters.effect = effect;\n        this.addEffect(effect);\n      } else {\n        const effect = this._filters.effect;\n        this.removeEffect(effect);\n        effect.filterArea = null;\n        effect.filters = null;\n        this._filters.effect = null;\n        PoolGroup/* BigPool */.u.return(effect);\n      }\n    }\n    if (hasFilters) {\n      this._filters.effect.filters = value;\n      this._filters.effect.filterArea = this.filterArea;\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `\'null\'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filters?.filters;\n  },\n  set filterArea(value) {\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    this._filters.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filters?.filterArea;\n  }\n};\n\n\n//# sourceMappingURL=effectsMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs\n\n\n"use strict";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Container.name property has been removed, use Container.label instead");\n    return this.label;\n  },\n  set name(value) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Container.name property has been removed, use Container.label instead");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\n\n//# sourceMappingURL=findMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(5128);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(3197);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs\n\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;\n    if (previousData.data[previousData.index] !== changeId) {\n      previousData.data[previousData.index] = changeId;\n      previousData.didChange = true;\n    }\n    previousData.index++;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\n\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs\n\n\n\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds/* Bounds */.Y()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didChangeId >> 12;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      (0,getLocalBounds/* getLocalBounds */.a)(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return (0,getGlobalBounds/* getGlobalBounds */.qW)(this, skipUpdate, bounds || new Bounds/* Bounds */.Y());\n  }\n};\n\n\n//# sourceMappingURL=measureMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs\n\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and "updateTransform" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\n\n//# sourceMappingURL=onRenderMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs\n\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child\'s zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\n\n//# sourceMappingURL=sortMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs\n\n\n\n\n"use strict";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point/* Point */.E(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\n\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs\n\n\n\n"use strict";\nclass RenderGroup {\n  constructor(root) {\n    this.renderPipeId = "renderGroup";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this._children = [];\n    this.worldTransform = new Matrix/* Matrix */.y();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet/* InstructionSet */.h();\n    this._onRenderContainers = [];\n    this.root = root;\n    this.addChild(root);\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.onChildUpdate(renderGroupChild.root);\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.root.didChange) {\n      this._removeChildFromUpdate(renderGroupChild.root);\n    }\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    if (child !== this.root) {\n      this._children.push(child);\n      child.updateTick = -1;\n      if (child.parent === this.root) {\n        child.relativeRenderGroupDepth = 1;\n      } else {\n        child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n      }\n      if (child._onRender) {\n        this.addOnRender(child);\n      }\n    }\n    if (child.renderGroup) {\n      if (child.renderGroup.root === child) {\n        this.addRenderGroupChild(child.renderGroup);\n        return;\n      }\n    } else {\n      child.renderGroup = this;\n      child.didChange = true;\n    }\n    const children = child.children;\n    if (!child.isRenderGroupRoot) {\n      this.onChildUpdate(child);\n    }\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      this.removeOnRender(child);\n    }\n    if (child.renderGroup.root !== child) {\n      const children = child.children;\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      if (child.didChange) {\n        child.renderGroup._removeChildFromUpdate(child);\n      }\n      child.renderGroup = null;\n    } else {\n      this._removeRenderGroupChild(child.renderGroup);\n    }\n    const index = this._children.indexOf(child);\n    if (index > -1) {\n      this._children.splice(index, 1);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7)\n      return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  _removeChildFromUpdate(child) {\n    const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      return;\n    }\n    const index = childrenToUpdate.list.indexOf(child);\n    if (index > -1) {\n      childrenToUpdate.list.splice(index, 1);\n    }\n    childrenToUpdate.index--;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined \'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n}\n\n\n//# sourceMappingURL=RenderGroup.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs\n\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\n\n//# sourceMappingURL=assignWithIgnore.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultSkew = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultPivot = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultScale = new ObservablePoint/* ObservablePoint */.A(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends eventemitter3/* default */.Z {\n  constructor(options = {}) {\n    super();\n    /** @private */\n    this.uid = (0,uid/* uid */.h)("renderable");\n    /** @private */\n    this._updateFlags = 15;\n    // is this container the root of a renderGroup?\n    // TODO implement this in a few more places\n    /** @private */\n    this.isRenderGroupRoot = false;\n    // the render group this container belongs to OR owns\n    /** @private */\n    this.renderGroup = null;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix/* Matrix */.y();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix/* Matrix */.y();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = "inherit";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = "normal";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    this._didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    this.effects = [];\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "addChild: Only Containers will be allowed to add children in v8.0.0");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.renderGroup && !this.isRenderGroupRoot) {\n        this.renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    this.emit("childAdded", child, this, this.children.length - 1);\n    child.emit("added", this);\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit("childRemoved", child, this, index);\n      child.emit("removed", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didChangeId++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.isRenderGroupRoot) {\n      const renderGroupParent = this.renderGroup.renderGroupParent;\n      if (renderGroupParent) {\n        renderGroupParent.onChildUpdate(this);\n      }\n    } else if (this.renderGroup) {\n      this.renderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (this.isRenderGroupRoot && value === false) {\n      throw new Error("[Pixi] cannot undo a render group just yet");\n    }\n    if (value) {\n      this.enableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return this.isRenderGroupRoot;\n  }\n  /** This enables the container to be rendered as a render group. */\n  enableRenderGroup() {\n    if (this.renderGroup && this.renderGroup.root === this)\n      return;\n    this.isRenderGroupRoot = true;\n    const parentRenderGroup = this.renderGroup;\n    if (parentRenderGroup) {\n      parentRenderGroup.removeChild(this);\n    }\n    this.renderGroup = new RenderGroup(this);\n    if (parentRenderGroup) {\n      for (let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++) {\n        const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n        let parent = childRenderGroup.root;\n        while (parent) {\n          if (parent === this) {\n            this.renderGroup.addRenderGroupChild(childRenderGroup);\n            break;\n          }\n          parent = parent.parent;\n        }\n      }\n      parentRenderGroup.addRenderGroupChild(this.renderGroup);\n    }\n    this._updateIsSimple();\n    this.groupTransform = Matrix/* Matrix */.y.IDENTITY;\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix/* Matrix */.y());\n    if (this.renderGroup) {\n      if (this.isRenderGroupRoot) {\n        this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n      } else {\n        this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n      }\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * misc_const/* RAD_TO_DEG */.jl;\n  }\n  set angle(value) {\n    this.rotation = value * misc_const/* DEG_TO_RAD */.ZX;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent\'s local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== "object") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, size.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, size.height);\n    }\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === "number" ? opts.x : this.position.x,\n      typeof opts.y === "number" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === "number" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    if ((this._didLocalTransformChangeId & 15) === this._didChangeId)\n      return;\n    this._didLocalTransformChangeId = this._didChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color/* Color */.I.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `\'normal\'` to reset the blend mode.\n   * @default \'normal\'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 2) >> 1 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 4) >> 2 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    this.removeFromParent();\n    this.parent = null;\n    this._mask = null;\n    this._filters = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit("destroyed", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === "boolean" ? options : options?.children;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\n\n//# sourceMappingURL=Container.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBLHNCQUFzQixrREFBa0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQVU7QUFDckM7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixZQUFZOztBQUV1RDtBQUNuRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcz9jZTYwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2NoaWxkcmVuSGVscGVyTWl4aW4ubWpzP2VkODMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzPzQ0YzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvZWZmZWN0c01peGluLm1qcz85YTlkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2ZpbmRNaXhpbi5tanM/Nzc1NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvY2hlY2tDaGlsZHJlbkRpZENoYW5nZS5tanM/MjM4YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9tZWFzdXJlTWl4aW4ubWpzPzU4NGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvb25SZW5kZXJNaXhpbi5tanM/MGM4MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9zb3J0TWl4aW4ubWpzPzA5YWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvdG9Mb2NhbEdsb2JhbE1peGluLm1qcz8wNzE3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJHcm91cC5tanM/NzcxYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvYXNzaWduV2l0aElnbm9yZS5tanM/YTc1YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcz83ZjM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY3VsbGluZ01peGluID0ge1xuICBjdWxsQXJlYTogbnVsbCxcbiAgY3VsbGFibGU6IGZhbHNlLFxuICBjdWxsYWJsZUNoaWxkcmVuOiB0cnVlXG59O1xuXG5leHBvcnQgeyBjdWxsaW5nTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1bGxpbmdNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RhdGEvcmVtb3ZlSXRlbXMubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY2hpbGRyZW5IZWxwZXJNaXhpbiA9IHtcbiAgYWxsb3dDaGlsZHJlbjogdHJ1ZSxcbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBjb250YWluZXIgdGhhdCBhcmUgd2l0aGluIHRoZSBiZWdpbiBhbmQgZW5kIGluZGV4ZXMuXG4gICAqIEBwYXJhbSBiZWdpbkluZGV4IC0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGVuZEluZGV4IC0gVGhlIGVuZGluZyBwb3NpdGlvbi4gRGVmYXVsdCB2YWx1ZSBpcyBzaXplIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm5zIC0gTGlzdCBvZiByZW1vdmVkIGNoaWxkcmVuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICByZW1vdmVDaGlsZHJlbihiZWdpbkluZGV4ID0gMCwgZW5kSW5kZXgpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRJbmRleCA/PyB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBjb25zdCByYW5nZSA9IGVuZCAtIGJlZ2luSW5kZXg7XG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICBmb3IgKGxldCBpID0gZW5kIC0gMTsgaSA+PSBiZWdpbkluZGV4OyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyR3JvdXAucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZWQucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBiZWdpbkluZGV4LCBlbmQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCByZW1vdmVkW2ldLCB0aGlzLCBpKTtcbiAgICAgICAgcmVtb3ZlZFtpXS5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS5cIik7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBmcm9tXG4gICAqIEByZXR1cm5zIFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGF0XG4gICAqIEByZXR1cm5zIC0gVGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgYW55LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Q2hpbGRBdDogSW5kZXggKCR7aW5kZXh9KSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICB9LFxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgYW4gZXhpc3RpbmcgY2hpbGQgaW4gdGhlIGNvbnRhaW5lciBjb250YWluZXJcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIGNoaWxkIENvbnRhaW5lciBpbnN0YW5jZSBmb3Igd2hpY2ggeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIHJlc3VsdGluZyBpbmRleCBudW1iZXIgZm9yIHRoZSBjaGlsZCBjb250YWluZXJcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIHRoaXMuYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggcG9zaXRpb24gb2YgYSBjaGlsZCBDb250YWluZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIENvbnRhaW5lciBpbnN0YW5jZSB0byBpZGVudGlmeVxuICAgKiBAcmV0dXJucyAtIFRoZSBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgY29udGFpbmVyIHRvIGlkZW50aWZ5XG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwbGllZCBDb250YWluZXIgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfSxcbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogSWYgdGhlIGNoaWxkIGlzIGFscmVhZHkgaW4gdGhpcyBjb250YWluZXIsIGl0IHdpbGwgYmUgbW92ZWQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtDb250YWluZXJ9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGFkZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGFic29sdXRlIGluZGV4IHdoZXJlIHRoZSBjaGlsZCB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBhZGRDaGlsZEF0KGNoaWxkLCBpbmRleCkge1xuICAgIGlmICghdGhpcy5hbGxvd0NoaWxkcmVuKSB7XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiYWRkQ2hpbGRBdDogT25seSBDb250YWluZXJzIHdpbGwgYmUgYWxsb3dlZCB0byBhZGQgY2hpbGRyZW4gaW4gdjguMC4wXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH1hZGRDaGlsZEF0OiBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke2NoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY2hpbGQucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcyAmJiBjdXJyZW50SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoY3VycmVudEluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICB9XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICBjaGlsZC5kaWRDaGFuZ2UgPSB0cnVlO1xuICAgIGNoaWxkLmRpZFZpZXdVcGRhdGUgPSBmYWxzZTtcbiAgICBjaGlsZC5fdXBkYXRlRmxhZ3MgPSAxNTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5hZGRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNvcnRhYmxlQ2hpbGRyZW4pXG4gICAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2FwcyB0aGUgcG9zaXRpb24gb2YgMiBDb250YWluZXJzIHdpdGhpbiB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIGNoaWxkIC0gRmlyc3QgY29udGFpbmVyIHRvIHN3YXBcbiAgICogQHBhcmFtIGNoaWxkMiAtIFNlY29uZCBjb250YWluZXIgdG8gc3dhcFxuICAgKi9cbiAgc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICBpZiAoY2hpbGQgPT09IGNoaWxkMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIGNvbnN0IGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgQ29udGFpbmVyIGZyb20gaXRzIHBhcmVudCBDb250YWluZXIuIElmIHRoZSBDb250YWluZXIgaGFzIG5vIHBhcmVudCwgZG8gbm90aGluZy5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHJlbW92ZUZyb21QYXJlbnQoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG59O1xuXG5leHBvcnQgeyBjaGlsZHJlbkhlbHBlck1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZHJlbkhlbHBlck1peGluLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE1hc2tFZmZlY3RNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VmZmVjdENsYXNzZXMgPSBbXTtcbiAgICB0aGlzLl90ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2VmZmVjdENsYXNzZXMuZm9yRWFjaCgodGVzdCkgPT4ge1xuICAgICAgdGhpcy5hZGQoe1xuICAgICAgICB0ZXN0OiB0ZXN0LnRlc3QsXG4gICAgICAgIG1hc2tDbGFzczogdGVzdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkKHRlc3QpIHtcbiAgICB0aGlzLl90ZXN0cy5wdXNoKHRlc3QpO1xuICB9XG4gIGdldE1hc2tFZmZlY3QoaXRlbSkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXN0ID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICBpZiAodGVzdC50ZXN0KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBCaWdQb29sLmdldCh0ZXN0Lm1hc2tDbGFzcywgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIHJldHVybk1hc2tFZmZlY3QoZWZmZWN0KSB7XG4gICAgQmlnUG9vbC5yZXR1cm4oZWZmZWN0KTtcbiAgfVxufVxuY29uc3QgTWFza0VmZmVjdE1hbmFnZXIgPSBuZXcgTWFza0VmZmVjdE1hbmFnZXJDbGFzcygpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0LCBNYXNrRWZmZWN0TWFuYWdlci5fZWZmZWN0Q2xhc3Nlcyk7XG5cbmV4cG9ydCB7IE1hc2tFZmZlY3RNYW5hZ2VyLCBNYXNrRWZmZWN0TWFuYWdlckNsYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXNrRWZmZWN0TWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXJFZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuaW1wb3J0IHsgTWFza0VmZmVjdE1hbmFnZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvbWFzay9NYXNrRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZWZmZWN0c01peGluID0ge1xuICBfbWFzazogbnVsbCxcbiAgX2ZpbHRlcnM6IG51bGwsXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAdHlwZSB7QXJyYXk8RWZmZWN0Pn1cbiAgICovXG4gIGVmZmVjdHM6IFtdLFxuICAvKipcbiAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICogQHBhcmFtIGVmZmVjdCAtIFRoZSBlZmZlY3QgdG8gYWRkLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBhZGRFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB0aGlzLmVmZmVjdHMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgIGlmICh0aGlzLnJlbmRlckdyb3VwKSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUlzU2ltcGxlKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKiBAcGFyYW0gZWZmZWN0IC0gVGhlIGVmZmVjdCB0byByZW1vdmUuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlbW92ZUVmZmVjdChlZmZlY3QpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmVmZmVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpZiAoIXRoaXMuaXNSZW5kZXJHcm91cFJvb3QgJiYgdGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVJc1NpbXBsZSgpO1xuICB9LFxuICBzZXQgbWFzayh2YWx1ZSkge1xuICAgIHRoaXMuX21hc2sgfHwgKHRoaXMuX21hc2sgPSB7IG1hc2s6IG51bGwsIGVmZmVjdDogbnVsbCB9KTtcbiAgICBpZiAodGhpcy5fbWFzay5tYXNrID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5fbWFzay5lZmZlY3QpIHtcbiAgICAgIHRoaXMucmVtb3ZlRWZmZWN0KHRoaXMuX21hc2suZWZmZWN0KTtcbiAgICAgIE1hc2tFZmZlY3RNYW5hZ2VyLnJldHVybk1hc2tFZmZlY3QodGhpcy5fbWFzay5lZmZlY3QpO1xuICAgICAgdGhpcy5fbWFzay5lZmZlY3QgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9tYXNrLm1hc2sgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlZmZlY3QgPSBNYXNrRWZmZWN0TWFuYWdlci5nZXRNYXNrRWZmZWN0KHZhbHVlKTtcbiAgICB0aGlzLl9tYXNrLmVmZmVjdCA9IGVmZmVjdDtcbiAgICB0aGlzLmFkZEVmZmVjdChlZmZlY3QpO1xuICB9LFxuICAvKipcbiAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuXG4gICAqIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC4gSW4gUGl4aUpTIGEgcmVndWxhciBtYXNrIG11c3QgYmUgYVxuICAgKiB7QGxpbmsgR3JhcGhpY3N9IG9yIGEge0BsaW5rIFNwcml0ZX0gb2JqZWN0LiBUaGlzIGFsbG93cyBmb3IgbXVjaCBmYXN0ZXIgbWFza2luZyBpbiBjYW52YXMgYXMgaXRcbiAgICogdXRpbGl0aWVzIHNoYXBlIGNsaXBwaW5nLiBGdXJ0aGVybW9yZSwgYSBtYXNrIG9mIGFuIG9iamVjdCBtdXN0IGJlIGluIHRoZSBzdWJ0cmVlIG9mIGl0cyBwYXJlbnQuXG4gICAqIE90aGVyd2lzZSwgYGdldExvY2FsQm91bmRzYCBtYXkgY2FsY3VsYXRlIGluY29ycmVjdCBib3VuZHMsIHdoaWNoIG1ha2VzIHRoZSBjb250YWluZXIncyB3aWR0aCBhbmQgaGVpZ2h0IHdyb25nLlxuICAgKiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXG4gICAqXG4gICAqIEZvciBzcHJpdGUgbWFzayBib3RoIGFscGhhIGFuZCByZWQgY2hhbm5lbCBhcmUgdXNlZC4gQmxhY2sgbWFzayBpcyB0aGUgc2FtZSBhcyB0cmFuc3BhcmVudCBtYXNrLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBHcmFwaGljcywgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKCk7XG4gICAqIGdyYXBoaWNzLmJlZ2luRmlsbCgweEZGMzMwMCk7XG4gICAqIGdyYXBoaWNzLmRyYXdSZWN0KDUwLCAyNTAsIDEwMCwgMTAwKTtcbiAgICogZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgKlxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlKHRleHR1cmUpO1xuICAgKiBzcHJpdGUubWFzayA9IGdyYXBoaWNzO1xuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s/Lm1hc2s7XG4gIH0sXG4gIHNldCBmaWx0ZXJzKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSlcbiAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICB2YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX2ZpbHRlcnMgfHwgKHRoaXMuX2ZpbHRlcnMgPSB7IGZpbHRlcnM6IG51bGwsIGVmZmVjdDogbnVsbCwgZmlsdGVyQXJlYTogbnVsbCB9KTtcbiAgICBjb25zdCBoYXNGaWx0ZXJzID0gdmFsdWU/Lmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZGlkQ2hhbmdlID0gdGhpcy5fZmlsdGVycy5lZmZlY3QgJiYgIWhhc0ZpbHRlcnMgfHwgIXRoaXMuX2ZpbHRlcnMuZWZmZWN0ICYmIGhhc0ZpbHRlcnM7XG4gICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKDApIDogdmFsdWU7XG4gICAgdGhpcy5fZmlsdGVycy5maWx0ZXJzID0gT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgaWYgKGhhc0ZpbHRlcnMpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gQmlnUG9vbC5nZXQoRmlsdGVyRWZmZWN0KTtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5lZmZlY3QgPSBlZmZlY3Q7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9maWx0ZXJzLmVmZmVjdDtcbiAgICAgICAgdGhpcy5yZW1vdmVFZmZlY3QoZWZmZWN0KTtcbiAgICAgICAgZWZmZWN0LmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICBlZmZlY3QuZmlsdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuZWZmZWN0ID0gbnVsbDtcbiAgICAgICAgQmlnUG9vbC5yZXR1cm4oZWZmZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0ZpbHRlcnMpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnMuZWZmZWN0LmZpbHRlcnMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2ZpbHRlcnMuZWZmZWN0LmZpbHRlckFyZWEgPSB0aGlzLmZpbHRlckFyZWE7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAqIElNUE9SVEFOVDogVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgJ251bGwnYC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBmaWx0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJzPy5maWx0ZXJzO1xuICB9LFxuICBzZXQgZmlsdGVyQXJlYSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZpbHRlcnMgfHwgKHRoaXMuX2ZpbHRlcnMgPSB7IGZpbHRlcnM6IG51bGwsIGVmZmVjdDogbnVsbCwgZmlsdGVyQXJlYTogbnVsbCB9KTtcbiAgICB0aGlzLl9maWx0ZXJzLmZpbHRlckFyZWEgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pemF0aW9uXG4gICAqIHJhdGhlciB0aGFuIGZpZ3VyaW5nIG91dCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGlzcGxheU9iamVjdCBlYWNoIGZyYW1lIHlvdSBjYW4gc2V0IHRoaXMgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBBbHNvIHdvcmtzIGFzIGFuIGludGVyYWN0aW9uIG1hc2suXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXQgZmlsdGVyQXJlYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVycz8uZmlsdGVyQXJlYTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZWZmZWN0c01peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZmZlY3RzTWl4aW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmaW5kTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgbGFiZWwgb2YgdGhlIG9iamVjdC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBsYWJlbFxuICAgKi9cbiAgbGFiZWw6IG51bGwsXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgbmFtZSBvZiB0aGUgb2JqZWN0LlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMFxuICAgKiBAc2VlIHNjZW5lLkNvbnRhaW5lciNsYWJlbFxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJDb250YWluZXIubmFtZSBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkLCB1c2UgQ29udGFpbmVyLmxhYmVsIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gIH0sXG4gIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkNvbnRhaW5lci5uYW1lIHByb3BlcnR5IGhhcyBiZWVuIHJlbW92ZWQsIHVzZSBDb250YWluZXIubGFiZWwgaW5zdGVhZFwiKTtcbiAgICB0aGlzLmxhYmVsID0gdmFsdWU7XG4gIH0sXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldENoaWxkQnlOYW1lXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gSW5zdGFuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufVtkZWVwPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2VhcmNoIHJlY3Vyc2l2ZWx5XG4gICAqIEByZXR1cm5zIHtDb250YWluZXJ9IFRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICogQHNlZSBzY2VuZS5Db250YWluZXIjZ2V0Q2hpbGRCeUxhYmVsXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRDaGlsZEJ5TmFtZShuYW1lLCBkZWVwID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGlsZEJ5TGFiZWwobmFtZSwgZGVlcCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiB0aGUgY29udGFpbmVyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICpcbiAgICogUmVjdXJzaXZlIHNlYXJjaGVzIGFyZSBkb25lIGluIGEgcHJlLW9yZGVyIHRyYXZlcnNhbC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBsYWJlbCAtIEluc3RhbmNlIGxhYmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59W2RlZXA9ZmFsc2VdIC0gV2hldGhlciB0byBzZWFyY2ggcmVjdXJzaXZlbHlcbiAgICogQHJldHVybnMge0NvbnRhaW5lcn0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICovXG4gIGdldENoaWxkQnlMYWJlbChsYWJlbCwgZGVlcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQubGFiZWwgPT09IGxhYmVsIHx8IGxhYmVsIGluc3RhbmNlb2YgUmVnRXhwICYmIGxhYmVsLnRlc3QoY2hpbGQubGFiZWwpKVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IGZvdW5kID0gY2hpbGQuZ2V0Q2hpbGRCeUxhYmVsKGxhYmVsLCB0cnVlKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbnRhaW5lciB3aXRoIHRoZSBzcGVjaWZpZWQgbGFiZWwuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gbGFiZWwgLSBJbnN0YW5jZSBsYWJlbC5cbiAgICogQHBhcmFtIHtib29sZWFufVtkZWVwPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2VhcmNoIHJlY3Vyc2l2ZWx5XG4gICAqIEBwYXJhbSB7Q29udGFpbmVyW119IFtvdXQ9W11dIC0gVGhlIGFycmF5IHRvIHN0b3JlIG1hdGNoaW5nIGNoaWxkcmVuIGluLlxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyW119IEFuIGFycmF5IG9mIGNoaWxkcmVuIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICovXG4gIGdldENoaWxkcmVuQnlMYWJlbChsYWJlbCwgZGVlcCA9IGZhbHNlLCBvdXQgPSBbXSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLmxhYmVsID09PSBsYWJlbCB8fCBsYWJlbCBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBsYWJlbC50ZXN0KGNoaWxkLmxhYmVsKSkge1xuICAgICAgICBvdXQucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLmdldENoaWxkcmVuQnlMYWJlbChsYWJlbCwgdHJ1ZSwgb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgZmluZE1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlKGNvbnRhaW5lciwgcHJldmlvdXNEYXRhKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBjaGFuZ2VJZCA9IChjaGlsZC51aWQgJiAyNTUpIDw8IDI0IHwgY2hpbGQuX2RpZENoYW5nZUlkICYgMTY3NzcyMTU7XG4gICAgaWYgKHByZXZpb3VzRGF0YS5kYXRhW3ByZXZpb3VzRGF0YS5pbmRleF0gIT09IGNoYW5nZUlkKSB7XG4gICAgICBwcmV2aW91c0RhdGEuZGF0YVtwcmV2aW91c0RhdGEuaW5kZXhdID0gY2hhbmdlSWQ7XG4gICAgICBwcmV2aW91c0RhdGEuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJldmlvdXNEYXRhLmluZGV4Kys7XG4gICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY2hlY2tDaGlsZHJlbkRpZENoYW5nZShjaGlsZCwgcHJldmlvdXNEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZXZpb3VzRGF0YS5kaWRDaGFuZ2U7XG59XG5cbmV4cG9ydCB7IGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzL2dldEdsb2JhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0TG9jYWxCb3VuZHMgfSBmcm9tICcuLi9ib3VuZHMvZ2V0TG9jYWxCb3VuZHMubWpzJztcbmltcG9ydCB7IGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UgfSBmcm9tICcuLi91dGlscy9jaGVja0NoaWxkcmVuRGlkQ2hhbmdlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNvbnN0IG1lYXN1cmVNaXhpbiA9IHtcbiAgX2xvY2FsQm91bmRzQ2FjaGVJZDogLTEsXG4gIF9sb2NhbEJvdW5kc0NhY2hlRGF0YTogbnVsbCxcbiAgX3NldFdpZHRoKHZhbHVlLCBsb2NhbFdpZHRoKSB7XG4gICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgaWYgKGxvY2FsV2lkdGggIT09IDApIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gbG9jYWxXaWR0aCAqIHNpZ247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHNpZ247XG4gICAgfVxuICB9LFxuICBfc2V0SGVpZ2h0KHZhbHVlLCBsb2NhbEhlaWdodCkge1xuICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24odGhpcy5zY2FsZS55KSB8fCAxO1xuICAgIGlmIChsb2NhbEhlaWdodCAhPT0gMCkge1xuICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyBsb2NhbEhlaWdodCAqIHNpZ247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueSA9IHNpZ247XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGNvbnRhaW5lciBhcyBhIEJvdW5kcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJvdW5kaW5nIGFyZWEuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRMb2NhbEJvdW5kcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzQ2FjaGVEYXRhKSB7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kc0NhY2hlRGF0YSA9IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGluZGV4OiAxLFxuICAgICAgICBkaWRDaGFuZ2U6IGZhbHNlLFxuICAgICAgICBsb2NhbEJvdW5kczogbmV3IEJvdW5kcygpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBsb2NhbEJvdW5kc0NhY2hlRGF0YSA9IHRoaXMuX2xvY2FsQm91bmRzQ2FjaGVEYXRhO1xuICAgIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmluZGV4ID0gMTtcbiAgICBsb2NhbEJvdW5kc0NhY2hlRGF0YS5kaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICBpZiAobG9jYWxCb3VuZHNDYWNoZURhdGEuZGF0YVswXSAhPT0gdGhpcy5fZGlkQ2hhbmdlSWQgPj4gMTIpIHtcbiAgICAgIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmRpZENoYW5nZSA9IHRydWU7XG4gICAgICBsb2NhbEJvdW5kc0NhY2hlRGF0YS5kYXRhWzBdID0gdGhpcy5fZGlkQ2hhbmdlSWQgPj4gMTI7XG4gICAgfVxuICAgIGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UodGhpcywgbG9jYWxCb3VuZHNDYWNoZURhdGEpO1xuICAgIGlmIChsb2NhbEJvdW5kc0NhY2hlRGF0YS5kaWRDaGFuZ2UpIHtcbiAgICAgIGdldExvY2FsQm91bmRzKHRoaXMsIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmxvY2FsQm91bmRzLCB0ZW1wTWF0cml4KTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmxvY2FsQm91bmRzO1xuICB9LFxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgKHdvcmxkKSBib3VuZHMgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGEgW1JlY3RhbmdsZV17QGxpbmsgUmVjdGFuZ2xlfS5cbiAgICogQHBhcmFtIHNraXBVcGRhdGUgLSBTZXR0aW5nIHRvIGB0cnVlYCB3aWxsIHN0b3AgdGhlIHRyYW5zZm9ybXMgb2YgdGhlIHNjZW5lIGdyYXBoIGZyb21cbiAgICogIGJlaW5nIHVwZGF0ZWQuIFRoaXMgbWVhbnMgdGhlIGNhbGN1bGF0aW9uIHJldHVybmVkIE1BWSBiZSBvdXQgb2YgZGF0ZSBCVVQgd2lsbCBnaXZlIHlvdSBhXG4gICAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gT3B0aW9uYWwgYm91bmRzIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICogQHJldHVybnMgLSBUaGUgbWluaW11bSBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGluIHdvcmxkIHNwYWNlIHRoYXQgZml0cyBhcm91bmQgdGhpcyBvYmplY3QuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRCb3VuZHMoc2tpcFVwZGF0ZSwgYm91bmRzKSB7XG4gICAgcmV0dXJuIGdldEdsb2JhbEJvdW5kcyh0aGlzLCBza2lwVXBkYXRlLCBib3VuZHMgfHwgbmV3IEJvdW5kcygpKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgbWVhc3VyZU1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWFzdXJlTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBvblJlbmRlck1peGluID0ge1xuICBfb25SZW5kZXI6IG51bGwsXG4gIHNldCBvblJlbmRlcihmdW5jKSB7XG4gICAgY29uc3QgcmVuZGVyR3JvdXAgPSB0aGlzLnJlbmRlckdyb3VwO1xuICAgIGlmICghZnVuYykge1xuICAgICAgaWYgKHRoaXMuX29uUmVuZGVyKSB7XG4gICAgICAgIHJlbmRlckdyb3VwPy5yZW1vdmVPblJlbmRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29uUmVuZGVyID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vblJlbmRlcikge1xuICAgICAgcmVuZGVyR3JvdXA/LmFkZE9uUmVuZGVyKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlbmRlciA9IGZ1bmM7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGNhbGxiYWNrIGlzIHVzZWQgd2hlbiB0aGUgY29udGFpbmVyIGlzIHJlbmRlcmVkLiBUaGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgYWRkIHlvdXIgY3VzdG9tXG4gICAqIGxvZ2ljIHRoYXQgaXMgbmVlZGVkIHRvIGJlIHJ1biBldmVyeSBmcmFtZS5cbiAgICpcbiAgICogSW4gdjcgbWFueSB1c2VycyB1c2VkIGB1cGRhdGVUcmFuc2Zvcm1gIGZvciB0aGlzLCBob3dldmVyIHRoZSB3YXkgdjggcmVuZGVycyBvYmplY3RzIGlzIGRpZmZlcmVudFxuICAgKiBhbmQgXCJ1cGRhdGVUcmFuc2Zvcm1cIiBpcyBubyBsb25nZXIgY2FsbGVkIGV2ZXJ5IGZyYW1lXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoKTtcbiAgICogY29udGFpbmVyLm9uUmVuZGVyID0gKCkgPT4ge1xuICAgKiAgICBjb250YWluZXIucm90YXRpb24gKz0gMC4wMTtcbiAgICogfTtcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBvblJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25SZW5kZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IG9uUmVuZGVyTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uUmVuZGVyTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzb3J0TWl4aW4gPSB7XG4gIF96SW5kZXg6IDAsXG4gIC8qKlxuICAgKiBTaG91bGQgY2hpbGRyZW4gYmUgc29ydGVkIGJ5IHpJbmRleCBhdCB0aGUgbmV4dCByZW5kZXIgY2FsbC5cbiAgICpcbiAgICogV2lsbCBnZXQgYXV0b21hdGljYWxseSBzZXQgdG8gdHJ1ZSBpZiBhIG5ldyBjaGlsZCBpcyBhZGRlZCwgb3IgaWYgYSBjaGlsZCdzIHpJbmRleCBjaGFuZ2VzLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNvcnREaXJ0eTogZmFsc2UsXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGNvbnRhaW5lciB3aWxsIHNvcnQgaXRzIGNoaWxkcmVuIGJ5IGB6SW5kZXhgIHZhbHVlXG4gICAqIHdoZW4gdGhlIG5leHQgcmVuZGVyIGlzIGNhbGxlZCwgb3IgbWFudWFsbHkgaWYgYHNvcnRDaGlsZHJlbigpYCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgYWN0dWFsbHkgY2hhbmdlcyB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBzbyBzaG91bGQgYmUgdHJlYXRlZFxuICAgKiBhcyBhIGJhc2ljIHNvbHV0aW9uIHRoYXQgaXMgbm90IHBlcmZvcm1hbnQgY29tcGFyZWQgdG8gb3RoZXIgc29sdXRpb25zLFxuICAgKiBzdWNoIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL2xheWVycyBQaXhpSlMgTGF5ZXJzfVxuICAgKlxuICAgKiBBbHNvIGJlIGF3YXJlIG9mIHRoYXQgdGhpcyBtYXkgbm90IHdvcmsgbmljZWx5IHdpdGggdGhlIGBhZGRDaGlsZEF0KClgIGZ1bmN0aW9uLFxuICAgKiBhcyB0aGUgYHpJbmRleGAgc29ydGluZyBtYXkgY2F1c2UgdGhlIGNoaWxkIHRvIGF1dG9tYXRpY2FsbHkgc29ydGVkIHRvIGFub3RoZXIgcG9zaXRpb24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgc29ydGFibGVDaGlsZHJlbjogZmFsc2UsXG4gIC8qKlxuICAgKiBUaGUgekluZGV4IG9mIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSwgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgcGFyZW50IHRvIGJlIHNvcnRhYmxlLiBDaGlsZHJlbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcbiAgICogYW5kIHRodXMgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGRpc3BsYXkgb2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxuICAgKiBAc2VlIHNjZW5lLkNvbnRhaW5lciNzb3J0YWJsZUNoaWxkcmVuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXQgekluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl96SW5kZXg7XG4gIH0sXG4gIHNldCB6SW5kZXgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fekluZGV4ID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl96SW5kZXggPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoT2ZDaGlsZE1vZGlmaWVkKCk7XG4gIH0sXG4gIGRlcHRoT2ZDaGlsZE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc29ydGFibGVDaGlsZHJlbiA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCAmJiAhdGhpcy5pc1JlbmRlckdyb3VwUm9vdCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNvcnRzIGNoaWxkcmVuIGJ5IHpJbmRleC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNvcnRDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuc29ydERpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRDaGlsZHJlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBzb3J0Q2hpbGRyZW4oYSwgYikge1xuICByZXR1cm4gYS5fekluZGV4IC0gYi5fekluZGV4O1xufVxuXG5leHBvcnQgeyBzb3J0TWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfSBmcm9tICcuLi9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG9Mb2NhbEdsb2JhbE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBvcHRpb25hbCBwb2ludCB0byB3cml0ZSB0aGUgZ2xvYmFsIHZhbHVlIHRvLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyAtIFRoZSB1cGRhdGVkIHBvaW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0R2xvYmFsUG9zaXRpb24ocG9pbnQgPSBuZXcgUG9pbnQoKSwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC50b0dsb2JhbCh0aGlzLl9wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludC54ID0gdGhpcy5fcG9zaXRpb24ueDtcbiAgICAgIHBvaW50LnkgPSB0aGlzLl9wb3NpdGlvbi55O1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0sXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbS5cbiAgICogQHBhcmFtIHBvaW50IC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbFxuICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXG4gICAqIEBwYXJhbSBza2lwVXBkYXRlIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIC0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICBjb25zdCBnbG9iYWxNYXRyaXggPSB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHModGhpcywgbmV3IE1hdHJpeCgpKTtcbiAgICAgIGdsb2JhbE1hdHJpeC5hcHBlbmQodGhpcy5sb2NhbFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gZ2xvYmFsTWF0cml4LmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gIH0sXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnQuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIENvbnRhaW5lciB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcG9pbnQgLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXG4gICAqICAob3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgbmV3IFBvaW50KS5cbiAgICogQHBhcmFtIHNraXBVcGRhdGUgLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHRvTG9jYWwocG9zaXRpb24sIGZyb20sIHBvaW50LCBza2lwVXBkYXRlKSB7XG4gICAgaWYgKGZyb20pIHtcbiAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH1cbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IGdsb2JhbE1hdHJpeCA9IHVwZGF0ZVRyYW5zZm9ybUJhY2t3YXJkcyh0aGlzLCBuZXcgTWF0cml4KCkpO1xuICAgICAgZ2xvYmFsTWF0cml4LmFwcGVuZCh0aGlzLmxvY2FsVHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiBnbG9iYWxNYXRyaXguYXBwbHlJbnZlcnNlKHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG59O1xuXG5leHBvcnQgeyB0b0xvY2FsR2xvYmFsTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvTG9jYWxHbG9iYWxNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBJbnN0cnVjdGlvblNldCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2luc3RydWN0aW9ucy9JbnN0cnVjdGlvblNldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJlbmRlckdyb3VwIHtcbiAgY29uc3RydWN0b3Iocm9vdCkge1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJyZW5kZXJHcm91cFwiO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlckdyb3VwUGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy53b3JsZENvbG9yQWxwaGEgPSA0Mjk0OTY3Mjk1O1xuICAgIHRoaXMud29ybGRDb2xvciA9IDE2Nzc3MjE1O1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG4gICAgLy8gdGhlc2UgdXBkYXRlcyBhcmUgdHJhbnNmb3JtIGNoYW5nZXMuLlxuICAgIHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudXBkYXRlVGljayA9IDA7XG4gICAgLy8gdGhlc2UgdXBkYXRlIGFyZSByZW5kZXJhYmxlIGNoYW5nZXMuLlxuICAgIHRoaXMuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlID0geyBsaXN0OiBbXSwgaW5kZXg6IDAgfTtcbiAgICAvLyBvdGhlclxuICAgIHRoaXMuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RydWN0aW9uU2V0ID0gbmV3IEluc3RydWN0aW9uU2V0KCk7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzID0gW107XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmFkZENoaWxkKHJvb3QpO1xuICB9XG4gIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LmxvY2FsVHJhbnNmb3JtO1xuICB9XG4gIGFkZFJlbmRlckdyb3VwQ2hpbGQocmVuZGVyR3JvdXBDaGlsZCkge1xuICAgIGlmIChyZW5kZXJHcm91cENoaWxkLnJlbmRlckdyb3VwUGFyZW50KSB7XG4gICAgICByZW5kZXJHcm91cENoaWxkLnJlbmRlckdyb3VwUGFyZW50Ll9yZW1vdmVSZW5kZXJHcm91cENoaWxkKHJlbmRlckdyb3VwQ2hpbGQpO1xuICAgIH1cbiAgICByZW5kZXJHcm91cENoaWxkLnJlbmRlckdyb3VwUGFyZW50ID0gdGhpcztcbiAgICB0aGlzLm9uQ2hpbGRVcGRhdGUocmVuZGVyR3JvdXBDaGlsZC5yb290KTtcbiAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4ucHVzaChyZW5kZXJHcm91cENoaWxkKTtcbiAgfVxuICBfcmVtb3ZlUmVuZGVyR3JvdXBDaGlsZChyZW5kZXJHcm91cENoaWxkKSB7XG4gICAgaWYgKHJlbmRlckdyb3VwQ2hpbGQucm9vdC5kaWRDaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUNoaWxkRnJvbVVwZGF0ZShyZW5kZXJHcm91cENoaWxkLnJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVuZGVyR3JvdXBDaGlsZHJlbi5pbmRleE9mKHJlbmRlckdyb3VwQ2hpbGQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmVuZGVyR3JvdXBDaGlsZC5yZW5kZXJHcm91cFBhcmVudCA9IG51bGw7XG4gIH1cbiAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgaWYgKGNoaWxkICE9PSB0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgY2hpbGQudXBkYXRlVGljayA9IC0xO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgIGNoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGggPSBjaGlsZC5wYXJlbnQucmVsYXRpdmVSZW5kZXJHcm91cERlcHRoICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5fb25SZW5kZXIpIHtcbiAgICAgICAgdGhpcy5hZGRPblJlbmRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGlsZC5yZW5kZXJHcm91cCkge1xuICAgICAgaWYgKGNoaWxkLnJlbmRlckdyb3VwLnJvb3QgPT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuYWRkUmVuZGVyR3JvdXBDaGlsZChjaGlsZC5yZW5kZXJHcm91cCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQucmVuZGVyR3JvdXAgPSB0aGlzO1xuICAgICAgY2hpbGQuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbjtcbiAgICBpZiAoIWNoaWxkLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICB0aGlzLm9uQ2hpbGRVcGRhdGUoY2hpbGQpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgaWYgKGNoaWxkLl9vblJlbmRlcikge1xuICAgICAgdGhpcy5yZW1vdmVPblJlbmRlcihjaGlsZCk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5yZW5kZXJHcm91cC5yb290ICE9PSBjaGlsZCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuZGlkQ2hhbmdlKSB7XG4gICAgICAgIGNoaWxkLnJlbmRlckdyb3VwLl9yZW1vdmVDaGlsZEZyb21VcGRhdGUoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQucmVuZGVyR3JvdXAgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVSZW5kZXJHcm91cENoaWxkKGNoaWxkLnJlbmRlckdyb3VwKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgb25DaGlsZFVwZGF0ZShjaGlsZCkge1xuICAgIGxldCBjaGlsZHJlblRvVXBkYXRlID0gdGhpcy5jaGlsZHJlblRvVXBkYXRlW2NoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aF07XG4gICAgaWYgKCFjaGlsZHJlblRvVXBkYXRlKSB7XG4gICAgICBjaGlsZHJlblRvVXBkYXRlID0gdGhpcy5jaGlsZHJlblRvVXBkYXRlW2NoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aF0gPSB7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBsaXN0OiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2hpbGRyZW5Ub1VwZGF0ZS5saXN0W2NoaWxkcmVuVG9VcGRhdGUuaW5kZXgrK10gPSBjaGlsZDtcbiAgfVxuICAvLyBTSE9VTEQgVEhJUyBCRSBIRVJFP1xuICB1cGRhdGVSZW5kZXJhYmxlKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cyA8IDcpXG4gICAgICByZXR1cm47XG4gICAgY29udGFpbmVyLmRpZFZpZXdVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmluc3RydWN0aW9uU2V0LnJlbmRlclBpcGVzW2NvbnRhaW5lci5yZW5kZXJQaXBlSWRdLnVwZGF0ZVJlbmRlcmFibGUoY29udGFpbmVyKTtcbiAgfVxuICBvbkNoaWxkVmlld1VwZGF0ZShjaGlsZCkge1xuICAgIHRoaXMuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlLmxpc3RbdGhpcy5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGUuaW5kZXgrK10gPSBjaGlsZDtcbiAgfVxuICBfcmVtb3ZlQ2hpbGRGcm9tVXBkYXRlKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRyZW5Ub1VwZGF0ZSA9IHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZVtjaGlsZC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGhdO1xuICAgIGlmICghY2hpbGRyZW5Ub1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGNoaWxkcmVuVG9VcGRhdGUubGlzdC5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgY2hpbGRyZW5Ub1VwZGF0ZS5saXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGNoaWxkcmVuVG9VcGRhdGUuaW5kZXgtLTtcbiAgfVxuICBnZXQgaXNSZW5kZXJhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QubG9jYWxEaXNwbGF5U3RhdHVzID09PSA3ICYmIHRoaXMud29ybGRBbHBoYSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIGFkZGluZyBhIGNvbnRhaW5lciB0byB0aGUgb25SZW5kZXIgbGlzdCB3aWxsIG1ha2Ugc3VyZSB0aGUgdXNlciBmdW5jdGlvblxuICAgKiBwYXNzZWQgaW4gdG8gdGhlIHVzZXIgZGVmaW5lZCAnb25SZW5kZXJgIGNhbGxCYWNrXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSB0aGUgY29udGFpbmVyIHRvIGFkZCB0byB0aGUgb25SZW5kZXIgbGlzdFxuICAgKi9cbiAgYWRkT25SZW5kZXIoY29udGFpbmVyKSB7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzLnB1c2goY29udGFpbmVyKTtcbiAgfVxuICByZW1vdmVPblJlbmRlcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9vblJlbmRlckNvbnRhaW5lcnMuc3BsaWNlKHRoaXMuX29uUmVuZGVyQ29udGFpbmVycy5pbmRleE9mKGNvbnRhaW5lciksIDEpO1xuICB9XG4gIHJ1bk9uUmVuZGVyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb25SZW5kZXJDb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vblJlbmRlckNvbnRhaW5lcnNbaV0uX29uUmVuZGVyKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFJlbmRlckdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJHcm91cC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFzc2lnbldpdGhJZ25vcmUodGFyZ2V0LCBvcHRpb25zLCBpZ25vcmUgPSB7fSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCFpZ25vcmVba2V5XSAmJiBvcHRpb25zW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGFzc2lnbldpdGhJZ25vcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2lnbldpdGhJZ25vcmUubWpzLm1hcFxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IGN1bGxpbmdNaXhpbiB9IGZyb20gJy4uLy4uL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBSQURfVE9fREVHLCBERUdfVE9fUkFEIH0gZnJvbSAnLi4vLi4vbWF0aHMvbWlzYy9jb25zdC5tanMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH0gZnJvbSAnLi4vLi4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IGNoaWxkcmVuSGVscGVyTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvY2hpbGRyZW5IZWxwZXJNaXhpbi5tanMnO1xuaW1wb3J0IHsgZWZmZWN0c01peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL2VmZmVjdHNNaXhpbi5tanMnO1xuaW1wb3J0IHsgZmluZE1peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL2ZpbmRNaXhpbi5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZU1peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL21lYXN1cmVNaXhpbi5tanMnO1xuaW1wb3J0IHsgb25SZW5kZXJNaXhpbiB9IGZyb20gJy4vY29udGFpbmVyLW1peGlucy9vblJlbmRlck1peGluLm1qcyc7XG5pbXBvcnQgeyBzb3J0TWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvc29ydE1peGluLm1qcyc7XG5pbXBvcnQgeyB0b0xvY2FsR2xvYmFsTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvdG9Mb2NhbEdsb2JhbE1peGluLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJHcm91cCB9IGZyb20gJy4vUmVuZGVyR3JvdXAubWpzJztcbmltcG9ydCB7IGFzc2lnbldpdGhJZ25vcmUgfSBmcm9tICcuL3V0aWxzL2Fzc2lnbldpdGhJZ25vcmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBkZWZhdWx0U2tldyA9IG5ldyBPYnNlcnZhYmxlUG9pbnQobnVsbCk7XG5jb25zdCBkZWZhdWx0UGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KG51bGwpO1xuY29uc3QgZGVmYXVsdFNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludChudWxsLCAxLCAxKTtcbmNvbnN0IFVQREFURV9DT0xPUiA9IDE7XG5jb25zdCBVUERBVEVfQkxFTkQgPSAyO1xuY29uc3QgVVBEQVRFX1ZJU0lCTEUgPSA0O1xuY29uc3QgVVBEQVRFX1RSQU5TRk9STSA9IDg7XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwicmVuZGVyYWJsZVwiKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl91cGRhdGVGbGFncyA9IDE1O1xuICAgIC8vIGlzIHRoaXMgY29udGFpbmVyIHRoZSByb290IG9mIGEgcmVuZGVyR3JvdXA/XG4gICAgLy8gVE9ETyBpbXBsZW1lbnQgdGhpcyBpbiBhIGZldyBtb3JlIHBsYWNlc1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuaXNSZW5kZXJHcm91cFJvb3QgPSBmYWxzZTtcbiAgICAvLyB0aGUgcmVuZGVyIGdyb3VwIHRoaXMgY29udGFpbmVyIGJlbG9uZ3MgdG8gT1Igb3duc1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMucmVuZGVyR3JvdXAgPSBudWxsO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIHRoZSBjb250YWluZXIgaGFzIGNoYW5nZWQuIEl0IGlzIHJlc2V0IG9uY2UgdGhlIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAvLyBieSB0aGUgdHJhbnNmb3JtIHN5c3RlbVxuICAgIC8vIGl0cyBoZXJlIHRvIHN0b3AgZW5zdXJlIHRoYXQgd2hlbiB0aGluZ3MgY2hhbmdlLCBvbmx5IG9uZSB1cGRhdGUgZ2V0cyByZWdpc3RlcnMgd2l0aCB0aGUgdHJhbnNmb3JtIHN5c3RlbVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuZGlkQ2hhbmdlID0gZmFsc2U7XG4gICAgLy8gc2FtZSBhcyBhYm92ZSwgYnV0IGZvciB0aGUgcmVuZGVyYWJsZVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuZGlkVmlld1VwZGF0ZSA9IGZhbHNlO1xuICAgIC8vIGhvdyBkZWVwIGlzIHRoZSBjb250YWluZXIgcmVsYXRpdmUgdG8gaXRzIHJlbmRlciBncm91cC4uXG4gICAgLy8gdW5sZXNzIHRoZSBlbGVtZW50IGlzIHRoZSByb290IHJlbmRlciBncm91cCAtIGl0IHdpbGwgYmUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudFxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMucmVsYXRpdmVSZW5kZXJHcm91cERlcHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIC8qKiBUaGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdC4gKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgLy8gdXNlZCBpbnRlcm5hbGx5IGZvciBjaGFuZ2luZyB1cCB0aGUgcmVuZGVyIG9yZGVyLi4gbWFpbmx5IGZvciBtYXNrcyBhbmQgZmlsdGVyc1xuICAgIC8vIFRPRE8gc2V0dGluZyB0aGlzIHNob3VsZCBjYXVzZSBhIHJlYnVpbGQ/P1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuaW5jbHVkZUluQnVpbGQgPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMubWVhc3VyYWJsZSA9IHRydWU7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5pc1NpbXBsZSA9IHRydWU7XG4gICAgLy8gLyAvLy8vLy8vLy8vLy8vVHJhbnNmb3JtIHJlbGF0ZWQgcHJvcHMvLy8vLy8vLy8vLy8vL1xuICAgIC8vIHVzZWQgYnkgdGhlIHRyYW5zZm9ybSBzeXN0ZW0gdG8gY2hlY2sgaWYgYSBjb250YWluZXIgbmVlZHMgdG8gYmUgdXBkYXRlZCB0aGF0IGZyYW1lXG4gICAgLy8gaWYgdGhlIHRpY2sgbWF0Y2hlcyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gc3lzdGVtIHRpY2ssIGl0IGlzIG5vdCB1cGRhdGVkIGFnYWluXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlVGljayA9IC0xO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9jYWwgZmFjdG9yczogcG9zaXRpb24sIHNjYWxlLCBvdGhlciBzdHVmZi5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBncm91cCB0cmFuc2Zvcm0gaXMgYSB0cmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIHJlbmRlciBncm91cCBpdCBiZWxvbmdzIHRvby4gSXQgd2lsbCBpbmNsdWRlIGFsbCBwYXJlbnRcbiAgICAgKiB0cmFuc2Zvcm1zIGFuZCB1cCB0byB0aGUgcmVuZGVyIGdyb3VwICh0aGluayBvZiBpdCBhcyBraW5kIG9mIGxpa2UgYSBzdGFnZSAtIGJ1dCB0aGUgc3RhZ2UgY2FuIGJlIG5lc3RlZCkuXG4gICAgICogSWYgdGhpcyBjb250YWluZXIgaXMgaXMgc2VsZiBhIHJlbmRlciBncm91cCBtYXRyaXggd2lsbCBiZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IHJlbmRlciBncm91cFxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZ3JvdXAgdHJhbnNmb3JtIGlzIGEgdHJhbnNmb3JtIHJlbGF0aXZlIHRvIHRoZSByZW5kZXIgZ3JvdXAgaXQgYmVsb25ncyB0b28uXG4gICAgICogSWYgdGhpcyBjb250YWluZXIgaXMgcmVuZGVyIGdyb3VwIHRoZW4gdGhpcyB3aWxsIGJlIGFuIGlkZW50aXR5IG1hdHJpeC4gb3RoZXIgd2lzZSBpdFxuICAgICAqIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0uXG4gICAgICogVXNlIHRoaXMgdmFsdWUgd2hlbiBhY3R1YWxseSByZW5kZXJpbmcgdGhpbmdzIHRvIHRoZSBzY3JlZW5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwVHJhbnNmb3JtID0gdGhpcy5yZWxhdGl2ZUdyb3VwVHJhbnNmb3JtO1xuICAgIC8qKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCB2aWEgZGVzdHJveSgpLiBJZiB0cnVlLCBpdCBzaG91bGQgbm90IGJlIHVzZWQuICovXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAvLyB0cmFuc2Zvcm0gZGF0YS4uXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcG9zaXRpb24gPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fc2NhbGUgPSBkZWZhdWx0U2NhbGU7XG4gICAgLyoqXG4gICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBjb250YWluZXIgdGhhdCBpdCByb3RhdGVzIGFyb3VuZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcGl2b3QgPSBkZWZhdWx0UGl2b3Q7XG4gICAgLyoqXG4gICAgICogVGhlIHNrZXcgYW1vdW50LCBvbiB0aGUgeCBhbmQgeSBheGlzLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9za2V3ID0gZGVmYXVsdFNrZXc7XG4gICAgLyoqXG4gICAgICogVGhlIFgtY29vcmRpbmF0ZSB2YWx1ZSBvZiB0aGUgbm9ybWFsaXplZCBsb2NhbCBYIGF4aXMsXG4gICAgICogdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IHdpdGhvdXQgYSBzY2FsZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fY3ggPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBZLWNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIG5vcm1hbGl6ZWQgbG9jYWwgWCBheGlzLFxuICAgICAqIHRoZSBmaXJzdCBjb2x1bW4gb2YgdGhlIGxvY2FsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB3aXRob3V0IGEgc2NhbGUuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3N4ID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgWC1jb29yZGluYXRlIHZhbHVlIG9mIHRoZSBub3JtYWxpemVkIGxvY2FsIFkgYXhpcyxcbiAgICAgKiB0aGUgc2Vjb25kIGNvbHVtbiBvZiB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IHdpdGhvdXQgYSBzY2FsZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fY3kgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBZLWNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIG5vcm1hbGl6ZWQgbG9jYWwgWSBheGlzLFxuICAgICAqIHRoZSBzZWNvbmQgY29sdW1uIG9mIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggd2l0aG91dCBhIHNjYWxlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9zeSA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHJvdGF0aW9uIGFtb3VudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcm90YXRpb24gPSAwO1xuICAgIC8vIC8gQ09MT1IgcmVsYXRlZCBwcm9wcyAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIGNvbG9yIHN0b3JlZCBhcyBBQkdSXG4gICAgdGhpcy5sb2NhbENvbG9yID0gMTY3NzcyMTU7XG4gICAgdGhpcy5sb2NhbEFscGhhID0gMTtcbiAgICB0aGlzLmdyb3VwQWxwaGEgPSAxO1xuICAgIC8vIEFcbiAgICB0aGlzLmdyb3VwQ29sb3IgPSAxNjc3NzIxNTtcbiAgICAvLyBCR1JcbiAgICB0aGlzLmdyb3VwQ29sb3JBbHBoYSA9IDQyOTQ5NjcyOTU7XG4gICAgLy8gQUJHUlxuICAgIC8vIC8gQkxFTkQgcmVsYXRlZCBwcm9wcyAvLy8vLy8vLy8vLy8vL1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQmxlbmRNb2RlID0gXCJpbmhlcml0XCI7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXBCbGVuZE1vZGUgPSBcIm5vcm1hbFwiO1xuICAgIC8vIC8gVklTSUJJTElUWSByZWxhdGVkIHByb3BzIC8vLy8vLy8vLy8vLy8vXG4gICAgLy8gdmlzaWJpbGl0eVxuICAgIC8vIDBiMTFcbiAgICAvLyBmaXJzdCBiaXQgaXMgdmlzaWJsZSwgc2Vjb25kIGJpdCBpcyByZW5kZXJhYmxlXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBob2xkcyB0aHJlZSBiaXRzOiBjdWxsZWQsIHZpc2libGUsIHJlbmRlcmFibGVcbiAgICAgKiB0aGUgdGhpcmQgYml0IHJlcHJlc2VudHMgY3VsbGluZyAoMCA9IGN1bGxlZCwgMSA9IG5vdCBjdWxsZWQpIDBiMTAwXG4gICAgICogdGhlIHNlY29uZCBiaXQgcmVwcmVzZW50cyB2aXNpYmlsaXR5ICgwID0gbm90IHZpc2libGUsIDEgPSB2aXNpYmxlKSAwYjAxMFxuICAgICAqIHRoZSBmaXJzdCBiaXQgcmVwcmVzZW50cyByZW5kZXJhYmxlICgwID0gcmVuZGVyYWJsZSwgMSA9IG5vdCByZW5kZXJhYmxlKSAwYjAwMVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsRGlzcGxheVN0YXR1cyA9IDc7XG4gICAgLy8gMGIxMSB8IDBiMTAgfCAwYjAxIHwgMGIwMFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbERpc3BsYXlTdGF0dXMgPSA3O1xuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgdGhhdCBpbmNyZW1lbnRzIGVhY2ggdGltZSB0aGUgY29udGFpbmVyIGlzIG1vZGlmaWVkXG4gICAgICogdGhlIGZpcnN0IDEyIGJpdHMgcmVwcmVzZW50IHRoZSBjb250YWluZXIgY2hhbmdlcyAoZWcgdHJhbnNmb3JtLCBhbHBoYSwgdmlzaWJsZSBldGMpXG4gICAgICogdGhlIHNlY29uZCAxMiBiaXRzIHJlcHJlc2VudCB0aGUgdmlldyBjaGFuZ2VzIChlZyB0ZXh0dXJlIHN3YXAsIGdlb21ldHJ5IGNoYW5nZSBldGMpXG4gICAgICpcbiAgICAgKiAgdmlldyAgICAgICAgICBjb250YWluZXJcbiAgICAgKiBbMDAwMDAwMDAwMDAwXVswMDAwMDAwMDAwMF1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fZGlkQ2hhbmdlSWQgPSAwO1xuICAgIC8qKlxuICAgICAqIHByb3BlcnR5IHRoYXQgdHJhY2tzIGlmIHRoZSBjb250YWluZXIgdHJhbnNmb3JtIGhhcyBjaGFuZ2VkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgPSAtMTtcbiAgICBhc3NpZ25XaXRoSWdub3JlKHRoaXMsIG9wdGlvbnMsIHtcbiAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgcGFyZW50OiB0cnVlLFxuICAgICAgZWZmZWN0czogdHJ1ZVxuICAgIH0pO1xuICAgIG9wdGlvbnMuY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLmFkZENoaWxkKGNoaWxkKSk7XG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgb3B0aW9ucy5wYXJlbnQ/LmFkZENoaWxkKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNaXhlcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZyb20gYSBzb3VyY2Ugb2JqZWN0IHRvIENvbnRhaW5lci5cbiAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0byBtaXggaW4uXG4gICAqL1xuICBzdGF0aWMgbWl4aW4oc291cmNlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29udGFpbmVyLnByb3RvdHlwZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgY2hpbGRyZW4gdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxuICAgKiBAcGFyYW0gey4uLkNvbnRhaW5lcn0gY2hpbGRyZW4gLSBUaGUgQ29udGFpbmVyKHMpIHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gICAqIEByZXR1cm5zIHtDb250YWluZXJ9IC0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgYWRkQ2hpbGQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMuYWxsb3dDaGlsZHJlbikge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcImFkZENoaWxkOiBPbmx5IENvbnRhaW5lcnMgd2lsbCBiZSBhbGxvd2VkIHRvIGFkZCBjaGlsZHJlbiBpbiB2OC4wLjBcIik7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIDEpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICh0aGlzLnJlbmRlckdyb3VwICYmICF0aGlzLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICAgIHRoaXMucmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICBpZiAodGhpcy5zb3J0YWJsZUNoaWxkcmVuKVxuICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgY2hpbGQuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICBjaGlsZC5kaWRWaWV3VXBkYXRlID0gZmFsc2U7XG4gICAgY2hpbGQuX3VwZGF0ZUZsYWdzID0gMTU7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAuYWRkQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGlsZEFkZGVkXCIsIGNoaWxkLCB0aGlzLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICBpZiAoY2hpbGQuX3pJbmRleCAhPT0gMCkge1xuICAgICAgY2hpbGQuZGVwdGhPZkNoaWxkTW9kaWZpZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHsuLi5Db250YWluZXJ9IGNoaWxkcmVuIC0gVGhlIENvbnRhaW5lcihzKSB0byByZW1vdmVcbiAgICogQHJldHVybnMge0NvbnRhaW5lcn0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVDaGlsZCguLi5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgICAgdGhpcy5yZW5kZXJHcm91cC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgICBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIF9vblVwZGF0ZShwb2ludCkge1xuICAgIGlmIChwb2ludCkge1xuICAgICAgaWYgKHBvaW50ID09PSB0aGlzLl9za2V3KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNrZXcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlkQ2hhbmdlSWQrKztcbiAgICBpZiAodGhpcy5kaWRDaGFuZ2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh0aGlzLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICBjb25zdCByZW5kZXJHcm91cFBhcmVudCA9IHRoaXMucmVuZGVyR3JvdXAucmVuZGVyR3JvdXBQYXJlbnQ7XG4gICAgICBpZiAocmVuZGVyR3JvdXBQYXJlbnQpIHtcbiAgICAgICAgcmVuZGVyR3JvdXBQYXJlbnQub25DaGlsZFVwZGF0ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAub25DaGlsZFVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0IGlzUmVuZGVyR3JvdXAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc1JlbmRlckdyb3VwUm9vdCAmJiB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltQaXhpXSBjYW5ub3QgdW5kbyBhIHJlbmRlciBncm91cCBqdXN0IHlldFwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmVuYWJsZVJlbmRlckdyb3VwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb250YWluZXIgaXMgYSByZW5kZXIgZ3JvdXAuXG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgc2VwYXJhdGUgcGFzcywgd2l0aCBpdHMgb3duIHNldCBvZiBpbnN0cnVjdGlvbnNcbiAgICovXG4gIGdldCBpc1JlbmRlckdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVuZGVyR3JvdXBSb290O1xuICB9XG4gIC8qKiBUaGlzIGVuYWJsZXMgdGhlIGNvbnRhaW5lciB0byBiZSByZW5kZXJlZCBhcyBhIHJlbmRlciBncm91cC4gKi9cbiAgZW5hYmxlUmVuZGVyR3JvdXAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXAgJiYgdGhpcy5yZW5kZXJHcm91cC5yb290ID09PSB0aGlzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNSZW5kZXJHcm91cFJvb3QgPSB0cnVlO1xuICAgIGNvbnN0IHBhcmVudFJlbmRlckdyb3VwID0gdGhpcy5yZW5kZXJHcm91cDtcbiAgICBpZiAocGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHBhcmVudFJlbmRlckdyb3VwLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckdyb3VwID0gbmV3IFJlbmRlckdyb3VwKHRoaXMpO1xuICAgIGlmIChwYXJlbnRSZW5kZXJHcm91cCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRSZW5kZXJHcm91cC5yZW5kZXJHcm91cENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUmVuZGVyR3JvdXAgPSBwYXJlbnRSZW5kZXJHcm91cC5yZW5kZXJHcm91cENoaWxkcmVuW2ldO1xuICAgICAgICBsZXQgcGFyZW50ID0gY2hpbGRSZW5kZXJHcm91cC5yb290O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcm91cC5hZGRSZW5kZXJHcm91cENoaWxkKGNoaWxkUmVuZGVyR3JvdXApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcmVudFJlbmRlckdyb3VwLmFkZFJlbmRlckdyb3VwQ2hpbGQodGhpcy5yZW5kZXJHcm91cCk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUlzU2ltcGxlKCk7XG4gICAgdGhpcy5ncm91cFRyYW5zZm9ybSA9IE1hdHJpeC5JREVOVElUWTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBfdXBkYXRlSXNTaW1wbGUoKSB7XG4gICAgdGhpcy5pc1NpbXBsZSA9ICF0aGlzLmlzUmVuZGVyR3JvdXBSb290ICYmIHRoaXMuZWZmZWN0cy5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9ycy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5fd29ybGRUcmFuc2Zvcm0gfHwgKHRoaXMuX3dvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpKTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICAgICAgdGhpcy5fd29ybGRUcmFuc2Zvcm0uY29weUZyb20odGhpcy5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93b3JsZFRyYW5zZm9ybS5hcHBlbmRGcm9tKHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybSwgdGhpcy5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93b3JsZFRyYW5zZm9ybTtcbiAgfVxuICAvLyAvIC8vLy8vLyB0cmFuc2Zvcm0gcmVsYXRlZCBzdHVmZlxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICogQW4gYWxpYXMgdG8gcG9zaXRpb24ueFxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uLng7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLl9wb3NpdGlvbi54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnlcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbi55O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy5fcG9zaXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gIH1cbiAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcG9zaXRpb24uY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLl9vblVwZGF0ZSh0aGlzLl9za2V3KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmdsZSBvZiB0aGUgb2JqZWN0IGluIGRlZ3JlZXMuXG4gICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGlvbiAqIFJBRF9UT19ERUc7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHZhbHVlICogREVHX1RPX1JBRDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNlbnRlciBvZiByb3RhdGlvbiwgc2NhbGluZywgYW5kIHNrZXdpbmcgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QgaW4gaXRzIGxvY2FsIHNwYWNlLiBUaGUgYHBvc2l0aW9uYFxuICAgKiBpcyB0aGUgcHJvamVjdGlvbiBvZiBgcGl2b3RgIGluIHRoZSBwYXJlbnQncyBsb2NhbCBzcGFjZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHBpdm90IGlzIHRoZSBvcmlnaW4gKDAsIDApLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwaXZvdCgpIHtcbiAgICBpZiAodGhpcy5fcGl2b3QgPT09IGRlZmF1bHRQaXZvdCkge1xuICAgICAgdGhpcy5fcGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGl2b3Q7XG4gIH1cbiAgc2V0IHBpdm90KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3Bpdm90ID09PSBkZWZhdWx0UGl2b3QpIHtcbiAgICAgIHRoaXMuX3Bpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdGhpcy5fcGl2b3Quc2V0KHZhbHVlKSA6IHRoaXMuX3Bpdm90LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNrZXcgZmFjdG9yIGZvciB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cbiAgZ2V0IHNrZXcoKSB7XG4gICAgaWYgKHRoaXMuX3NrZXcgPT09IGRlZmF1bHRTa2V3KSB7XG4gICAgICB0aGlzLl9za2V3ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NrZXc7XG4gIH1cbiAgc2V0IHNrZXcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2tldyA9PT0gZGVmYXVsdFNrZXcpIHtcbiAgICAgIHRoaXMuX3NrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIH1cbiAgICB0aGlzLl9za2V3LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjYWxlIGZhY3RvcnMgb2YgdGhpcyBvYmplY3QgYWxvbmcgdGhlIGxvY2FsIGNvb3JkaW5hdGUgYXhlcy5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgc2NhbGUgaXMgKDEsIDEpLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICBpZiAodGhpcy5fc2NhbGUgPT09IGRlZmF1bHRTY2FsZSkge1xuICAgICAgdGhpcy5fc2NhbGUgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NjYWxlID09PSBkZWZhdWx0U2NhbGUpIHtcbiAgICAgIHRoaXMuX3NjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdGhpcy5fc2NhbGUuc2V0KHZhbHVlKSA6IHRoaXMuX3NjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGgpO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsV2lkdGggPSB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgdGhpcy5fc2V0V2lkdGgodmFsdWUsIGxvY2FsV2lkdGgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodCk7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsSGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICB0aGlzLl9zZXRIZWlnaHQodmFsdWUsIGxvY2FsSGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgYXMgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBUaGlzIGlzIGZhc3RlciB0aGFuIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gb3V0IC0gT3B0aW9uYWwgb2JqZWN0IHRvIHN0b3JlIHRoZSBzaXplIGluLlxuICAgKiBAcmV0dXJucyAtIFRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRTaXplKG91dCkge1xuICAgIGlmICghb3V0KSB7XG4gICAgICBvdXQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuICAgIG91dC53aWR0aCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueCAqIGJvdW5kcy53aWR0aCk7XG4gICAgb3V0LmhlaWdodCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueSAqIGJvdW5kcy5oZWlnaHQpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGlzIGNhbiBiZSBlaXRoZXIgYSBudW1iZXIgb3IgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZXQuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgd2lkdGhgIGlmIG5vdCBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNldFNpemUodmFsdWUsIGhlaWdodCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG4gICAgbGV0IGNvbnZlcnRlZFdpZHRoO1xuICAgIGxldCBjb252ZXJ0ZWRIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29udmVydGVkV2lkdGggPSB2YWx1ZTtcbiAgICAgIGNvbnZlcnRlZEhlaWdodCA9IGhlaWdodCA/PyB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udmVydGVkV2lkdGggPSB2YWx1ZS53aWR0aDtcbiAgICAgIGNvbnZlcnRlZEhlaWdodCA9IHZhbHVlLmhlaWdodCA/PyB2YWx1ZS53aWR0aDtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZFdpZHRoICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX3NldFdpZHRoKGNvbnZlcnRlZFdpZHRoLCBzaXplLndpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZEhlaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zZXRIZWlnaHQoY29udmVydGVkSGVpZ2h0LCBzaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKiBDYWxsZWQgd2hlbiB0aGUgc2tldyBvciB0aGUgcm90YXRpb24gY2hhbmdlcy4gKi9cbiAgX3VwZGF0ZVNrZXcoKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLl9yb3RhdGlvbjtcbiAgICBjb25zdCBza2V3ID0gdGhpcy5fc2tldztcbiAgICB0aGlzLl9jeCA9IE1hdGguY29zKHJvdGF0aW9uICsgc2tldy5feSk7XG4gICAgdGhpcy5fc3ggPSBNYXRoLnNpbihyb3RhdGlvbiArIHNrZXcuX3kpO1xuICAgIHRoaXMuX2N5ID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tldy5feCk7XG4gICAgdGhpcy5fc3kgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXcuX3gpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBvZiB0aGUgY29udGFpbmVyIChhY2NlcHRzIHBhcnRpYWwgdmFsdWVzKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyBmb3IgdXBkYXRpbmcgdGhlIHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMueCAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnkgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY2FsZVggLSBUaGUgc2NhbGUgZmFjdG9yIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjYWxlWSAtIFRoZSBzY2FsZSBmYWN0b3Igb24gdGhlIHktYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucm90YXRpb24gLSBUaGUgcm90YXRpb24gb2YgdGhlIGNvbnRhaW5lciwgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2tld1ggLSBUaGUgc2tldyBmYWN0b3Igb24gdGhlIHgtYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2tld1kgLSBUaGUgc2tldyBmYWN0b3Igb24gdGhlIHktYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucGl2b3RYIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcGl2b3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnBpdm90WSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBpdm90IHBvaW50LlxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtKG9wdHMpIHtcbiAgICB0aGlzLnBvc2l0aW9uLnNldChcbiAgICAgIHR5cGVvZiBvcHRzLnggPT09IFwibnVtYmVyXCIgPyBvcHRzLnggOiB0aGlzLnBvc2l0aW9uLngsXG4gICAgICB0eXBlb2Ygb3B0cy55ID09PSBcIm51bWJlclwiID8gb3B0cy55IDogdGhpcy5wb3NpdGlvbi55XG4gICAgKTtcbiAgICB0aGlzLnNjYWxlLnNldChcbiAgICAgIHR5cGVvZiBvcHRzLnNjYWxlWCA9PT0gXCJudW1iZXJcIiA/IG9wdHMuc2NhbGVYIHx8IDEgOiB0aGlzLnNjYWxlLngsXG4gICAgICB0eXBlb2Ygb3B0cy5zY2FsZVkgPT09IFwibnVtYmVyXCIgPyBvcHRzLnNjYWxlWSB8fCAxIDogdGhpcy5zY2FsZS55XG4gICAgKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gdHlwZW9mIG9wdHMucm90YXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHRzLnJvdGF0aW9uIDogdGhpcy5yb3RhdGlvbjtcbiAgICB0aGlzLnNrZXcuc2V0KFxuICAgICAgdHlwZW9mIG9wdHMuc2tld1ggPT09IFwibnVtYmVyXCIgPyBvcHRzLnNrZXdYIDogdGhpcy5za2V3LngsXG4gICAgICB0eXBlb2Ygb3B0cy5za2V3WSA9PT0gXCJudW1iZXJcIiA/IG9wdHMuc2tld1kgOiB0aGlzLnNrZXcueVxuICAgICk7XG4gICAgdGhpcy5waXZvdC5zZXQoXG4gICAgICB0eXBlb2Ygb3B0cy5waXZvdFggPT09IFwibnVtYmVyXCIgPyBvcHRzLnBpdm90WCA6IHRoaXMucGl2b3QueCxcbiAgICAgIHR5cGVvZiBvcHRzLnBpdm90WSA9PT0gXCJudW1iZXJcIiA/IG9wdHMucGl2b3RZIDogdGhpcy5waXZvdC55XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIHVzaW5nIHRoZSBnaXZlbiBtYXRyaXguXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIHVzZSBmb3IgdXBkYXRpbmcgdGhlIHRyYW5zZm9ybS5cbiAgICovXG4gIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtLiAqL1xuICB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICBpZiAoKHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgJiAxNSkgPT09IHRoaXMuX2RpZENoYW5nZUlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgPSB0aGlzLl9kaWRDaGFuZ2VJZDtcbiAgICBjb25zdCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY2FsZTtcbiAgICBjb25zdCBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgY29uc3Qgc3ggPSBzY2FsZS5feDtcbiAgICBjb25zdCBzeSA9IHNjYWxlLl95O1xuICAgIGNvbnN0IHB4ID0gcGl2b3QuX3g7XG4gICAgY29uc3QgcHkgPSBwaXZvdC5feTtcbiAgICBsdC5hID0gdGhpcy5fY3ggKiBzeDtcbiAgICBsdC5iID0gdGhpcy5fc3ggKiBzeDtcbiAgICBsdC5jID0gdGhpcy5fY3kgKiBzeTtcbiAgICBsdC5kID0gdGhpcy5fc3kgKiBzeTtcbiAgICBsdC50eCA9IHBvc2l0aW9uLl94IC0gKHB4ICogbHQuYSArIHB5ICogbHQuYyk7XG4gICAgbHQudHkgPSBwb3NpdGlvbi5feSAtIChweCAqIGx0LmIgKyBweSAqIGx0LmQpO1xuICB9XG4gIC8vIC8gLy8vLy8gY29sb3IgcmVsYXRlZCBzdHVmZlxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubG9jYWxBbHBoYSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxvY2FsQWxwaGEgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVGbGFncyB8PSBVUERBVEVfQ09MT1I7XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC4gKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsQWxwaGE7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICBjb25zdCB0ZW1wQ29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUgPz8gMTY3NzcyMTUpO1xuICAgIGNvbnN0IGJnciA9IHRlbXBDb2xvci50b0Jnck51bWJlcigpO1xuICAgIGlmIChiZ3IgPT09IHRoaXMubG9jYWxDb2xvcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxvY2FsQ29sb3IgPSBiZ3I7XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX0NPTE9SO1xuICAgIHRoaXMuX29uVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cbiAgICpcbiAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICBjb25zdCBiZ3IgPSB0aGlzLmxvY2FsQ29sb3I7XG4gICAgcmV0dXJuICgoYmdyICYgMjU1KSA8PCAxNikgKyAoYmdyICYgNjUyODApICsgKGJnciA+PiAxNiAmIDI1NSk7XG4gIH1cbiAgLy8gLyAvLy8vLy8vLy8vLy8vLy8vIGJsZW5kIHJlbGF0ZWQgc3R1ZmZcbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmxvY2FsQmxlbmRNb2RlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCAmJiAhdGhpcy5pc1JlbmRlckdyb3VwUm9vdCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVGbGFncyB8PSBVUERBVEVfQkxFTkQ7XG4gICAgdGhpcy5sb2NhbEJsZW5kTW9kZSA9IHZhbHVlO1xuICAgIHRoaXMuX29uVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gQXBwbHkgYSB2YWx1ZSBvZiBgJ25vcm1hbCdgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgKiBAZGVmYXVsdCAnbm9ybWFsJ1xuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbEJsZW5kTW9kZTtcbiAgfVxuICAvLyAvIC8vLy8vLy8vLyBWSVNJQklMSVRZIC8gUkVOREVSQUJMRSAvLy8vLy8vLy8vLy8vLy8vL1xuICAvKiogVGhlIHZpc2liaWxpdHkgb2YgdGhlIG9iamVjdC4gSWYgZmFsc2UgdGhlIG9iamVjdCB3aWxsIG5vdCBiZSBkcmF3biwgYW5kIHRoZSB0cmFuc2Zvcm0gd2lsbCBub3QgYmUgdXBkYXRlZC4gKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgMik7XG4gIH1cbiAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZU51bWJlciA9IHZhbHVlID8gMSA6IDA7XG4gICAgaWYgKCh0aGlzLmxvY2FsRGlzcGxheVN0YXR1cyAmIDIpID4+IDEgPT09IHZhbHVlTnVtYmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlbmRlckdyb3VwICYmICF0aGlzLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUZsYWdzIHw9IFVQREFURV9WSVNJQkxFO1xuICAgIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzIF49IDI7XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBnZXQgY3VsbGVkKCkge1xuICAgIHJldHVybiAhKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgNCk7XG4gIH1cbiAgLyoqIEBpZ25vcmUgKi9cbiAgc2V0IGN1bGxlZCh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gdmFsdWUgPyAxIDogMDtcbiAgICBpZiAoKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgNCkgPj4gMiA9PT0gdmFsdWVOdW1iZXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXAgJiYgIXRoaXMuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX1ZJU0lCTEU7XG4gICAgdGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgXj0gNDtcbiAgICB0aGlzLl9vblVwZGF0ZSgpO1xuICB9XG4gIC8qKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWQsIGlmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24gYnV0IHRoZSB0cmFuc2Zvcm0gd2lsbCBzdGlsbCBiZSB1cGRhdGVkLiAqL1xuICBnZXQgcmVuZGVyYWJsZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgJiAxKTtcbiAgfVxuICBzZXQgcmVuZGVyYWJsZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gdmFsdWUgPyAxIDogMDtcbiAgICBpZiAoKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgMSkgPT09IHZhbHVlTnVtYmVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3VwZGF0ZUZsYWdzIHw9IFVQREFURV9WSVNJQkxFO1xuICAgIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzIF49IDE7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXAgJiYgIXRoaXMuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBzaG91bGQgYmUgcmVuZGVyZWQuICovXG4gIGdldCBpc1JlbmRlcmFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzID09PSA3ICYmIHRoaXMuZ3JvdXBBbHBoYSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBhcyB3ZWxsIGFzIHJlbW92ZXMgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuICAgKiBEbyBub3QgdXNlIGEgQ29udGFpbmVyIGFmdGVyIGNhbGxpbmcgYGRlc3Ryb3lgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XG4gICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGRyZW4gd2l0aCB0ZXh0dXJlcyBlLmcuIFNwcml0ZXMuIElmIG9wdGlvbnMuY2hpbGRyZW5cbiAgICogaXMgc2V0IHRvIHRydWUgaXQgc2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIHRleHR1cmVzIGUuZy4gU3ByaXRlcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSBpdCBzaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRleHQ9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIGdyYXBoaWNzQ29udGV4dHMgZS5nLiBHcmFwaGljcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSBpdCBzaG91bGQgZGVzdHJveSB0aGUgY29udGV4dCBvZiB0aGUgY2hpbGQgZ3JhcGhpY3NcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG4gICAgdGhpcy5lZmZlY3RzID0gbnVsbDtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuICAgIHRoaXMuX3Bpdm90ID0gbnVsbDtcbiAgICB0aGlzLl9za2V3ID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95ZWRcIiwgdGhpcyk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBkZXN0cm95Q2hpbGRyZW4gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8uY2hpbGRyZW47XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBpZiAoZGVzdHJveUNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG9sZENoaWxkcmVuW2ldLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5Db250YWluZXIubWl4aW4oY2hpbGRyZW5IZWxwZXJNaXhpbik7XG5Db250YWluZXIubWl4aW4odG9Mb2NhbEdsb2JhbE1peGluKTtcbkNvbnRhaW5lci5taXhpbihvblJlbmRlck1peGluKTtcbkNvbnRhaW5lci5taXhpbihtZWFzdXJlTWl4aW4pO1xuQ29udGFpbmVyLm1peGluKGVmZmVjdHNNaXhpbik7XG5Db250YWluZXIubWl4aW4oZmluZE1peGluKTtcbkNvbnRhaW5lci5taXhpbihzb3J0TWl4aW4pO1xuQ29udGFpbmVyLm1peGluKGN1bGxpbmdNaXhpbik7XG5cbmV4cG9ydCB7IENvbnRhaW5lciwgVVBEQVRFX0JMRU5ELCBVUERBVEVfQ09MT1IsIFVQREFURV9UUkFOU0ZPUk0sIFVQREFURV9WSVNJQkxFIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8400\n')},535:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Y: () => (/* binding */ Bounds)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3904);\n\n\n\n"use strict";\nconst defaultMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Rectangle */ .A();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Bounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBEO0FBQ007O0FBRWhFO0FBQ0EsMEJBQTBCLHFFQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkVBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXLE9BQU8sV0FBVyxPQUFPLFdBQVcsT0FBTyxXQUFXLFFBQVEsWUFBWSxTQUFTLFlBQVk7QUFDN0k7QUFDQTs7QUFFa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanM/MmQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZGVmYXVsdE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIEJvdW5kcyB7XG4gIGNvbnN0cnVjdG9yKG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5KSB7XG4gICAgLyoqIEBkZWZhdWx0IEluZmluaXR5ICovXG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgLyoqIEBkZWZhdWx0IEluZmluaXR5ICovXG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgLyoqIEBkZWZhdWx0IC1JbmZpbml0eSAqL1xuICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICAvKiogQGRlZmF1bHQgLUluZmluaXR5ICovXG4gICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuICAgIHRoaXMubWF0cml4ID0gZGVmYXVsdE1hdHJpeDtcbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYm91bmRzIGFyZSBlbXB0eS5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WTtcbiAgfVxuICAvKiogVGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgcmVjdGFuZ2xlKCkge1xuICAgIGlmICghdGhpcy5fcmVjdGFuZ2xlKSB7XG4gICAgICB0aGlzLl9yZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IHRoaXMuX3JlY3RhbmdsZTtcbiAgICBpZiAodGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WSkge1xuICAgICAgcmVjdGFuZ2xlLnggPSAwO1xuICAgICAgcmVjdGFuZ2xlLnkgPSAwO1xuICAgICAgcmVjdGFuZ2xlLndpZHRoID0gMDtcbiAgICAgIHJlY3RhbmdsZS5oZWlnaHQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0YW5nbGUuY29weUZyb21Cb3VuZHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgLyoqIENsZWFycyB0aGUgYm91bmRzIGFuZCByZXNldHMuICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG4gICAgdGhpcy5tYXRyaXggPSBkZWZhdWx0TWF0cml4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBib3VuZHMuXG4gICAqIEBwYXJhbSB4MCAtIGxlZnQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTAgLSB0b3AgWSBvZiBmcmFtZVxuICAgKiBAcGFyYW0geDEgLSByaWdodCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MSAtIGJvdHRvbSBZIG9mIGZyYW1lXG4gICAqL1xuICBzZXQoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLm1pblggPSB4MDtcbiAgICB0aGlzLm1pblkgPSB5MDtcbiAgICB0aGlzLm1heFggPSB4MTtcbiAgICB0aGlzLm1heFkgPSB5MTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzcHJpdGUgZnJhbWVcbiAgICogQHBhcmFtIHgwIC0gbGVmdCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MCAtIHRvcCBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB4MSAtIHJpZ2h0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkxIC0gYm90dG9tIFkgb2YgZnJhbWVcbiAgICogQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgYWRkRnJhbWUoeDAsIHkwLCB4MSwgeTEsIG1hdHJpeCkge1xuICAgIG1hdHJpeCB8fCAobWF0cml4ID0gdGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBsZXQgeCA9IGEgKiB4MCArIGMgKiB5MCArIHR4O1xuICAgIGxldCB5ID0gYiAqIHgwICsgZCAqIHkwICsgdHk7XG4gICAgaWYgKHggPCBtaW5YKVxuICAgICAgbWluWCA9IHg7XG4gICAgaWYgKHkgPCBtaW5ZKVxuICAgICAgbWluWSA9IHk7XG4gICAgaWYgKHggPiBtYXhYKVxuICAgICAgbWF4WCA9IHg7XG4gICAgaWYgKHkgPiBtYXhZKVxuICAgICAgbWF4WSA9IHk7XG4gICAgeCA9IGEgKiB4MSArIGMgKiB5MCArIHR4O1xuICAgIHkgPSBiICogeDEgKyBkICogeTAgKyB0eTtcbiAgICBpZiAoeCA8IG1pblgpXG4gICAgICBtaW5YID0geDtcbiAgICBpZiAoeSA8IG1pblkpXG4gICAgICBtaW5ZID0geTtcbiAgICBpZiAoeCA+IG1heFgpXG4gICAgICBtYXhYID0geDtcbiAgICBpZiAoeSA+IG1heFkpXG4gICAgICBtYXhZID0geTtcbiAgICB4ID0gYSAqIHgwICsgYyAqIHkxICsgdHg7XG4gICAgeSA9IGIgKiB4MCArIGQgKiB5MSArIHR5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIHggPSBhICogeDEgKyBjICogeTEgKyB0eDtcbiAgICB5ID0gYiAqIHgxICsgZCAqIHkxICsgdHk7XG4gICAgaWYgKHggPCBtaW5YKVxuICAgICAgbWluWCA9IHg7XG4gICAgaWYgKHkgPCBtaW5ZKVxuICAgICAgbWluWSA9IHk7XG4gICAgaWYgKHggPiBtYXhYKVxuICAgICAgbWF4WCA9IHg7XG4gICAgaWYgKHkgPiBtYXhZKVxuICAgICAgbWF4WSA9IHk7XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlY3RhbmdsZSB0byB0aGUgYm91bmRzLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBib3VuZHMuXG4gICAqL1xuICBhZGRSZWN0KHJlY3QsIG1hdHJpeCkge1xuICAgIHRoaXMuYWRkRnJhbWUocmVjdC54LCByZWN0LnksIHJlY3QueCArIHJlY3Qud2lkdGgsIHJlY3QueSArIHJlY3QuaGVpZ2h0LCBtYXRyaXgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIHtAbGluayBCb3VuZHN9LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIEJvdW5kcyB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzLCBtYXRyaXgpIHtcbiAgICB0aGlzLmFkZEZyYW1lKGJvdW5kcy5taW5YLCBib3VuZHMubWluWSwgYm91bmRzLm1heFgsIGJvdW5kcy5tYXhZLCBtYXRyaXgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzLlxuICAgKiBAcGFyYW0gbWFzayAtIFRoZSBCb3VuZHMgdG8gYmUgYWRkZWQuXG4gICAqL1xuICBhZGRCb3VuZHNNYXNrKG1hc2spIHtcbiAgICB0aGlzLm1pblggPSB0aGlzLm1pblggPiBtYXNrLm1pblggPyB0aGlzLm1pblggOiBtYXNrLm1pblg7XG4gICAgdGhpcy5taW5ZID0gdGhpcy5taW5ZID4gbWFzay5taW5ZID8gdGhpcy5taW5ZIDogbWFzay5taW5ZO1xuICAgIHRoaXMubWF4WCA9IHRoaXMubWF4WCA8IG1hc2subWF4WCA/IHRoaXMubWF4WCA6IG1hc2subWF4WDtcbiAgICB0aGlzLm1heFkgPSB0aGlzLm1heFkgPCBtYXNrLm1heFkgPyB0aGlzLm1heFkgOiBtYXNrLm1heFk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtdWx0aXBsaWVkIHdpdGggbWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBseSB0byB0aGUgYm91bmRzLlxuICAgKi9cbiAgYXBwbHlNYXRyaXgobWF0cml4KSB7XG4gICAgY29uc3QgbWluWCA9IHRoaXMubWluWDtcbiAgICBjb25zdCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGNvbnN0IG1heFggPSB0aGlzLm1heFg7XG4gICAgY29uc3QgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIHR4LCB0eSB9ID0gbWF0cml4O1xuICAgIGxldCB4ID0gYSAqIG1pblggKyBjICogbWluWSArIHR4O1xuICAgIGxldCB5ID0gYiAqIG1pblggKyBkICogbWluWSArIHR5O1xuICAgIHRoaXMubWluWCA9IHg7XG4gICAgdGhpcy5taW5ZID0geTtcbiAgICB0aGlzLm1heFggPSB4O1xuICAgIHRoaXMubWF4WSA9IHk7XG4gICAgeCA9IGEgKiBtYXhYICsgYyAqIG1pblkgKyB0eDtcbiAgICB5ID0gYiAqIG1heFggKyBkICogbWluWSArIHR5O1xuICAgIHRoaXMubWluWCA9IHggPCB0aGlzLm1pblggPyB4IDogdGhpcy5taW5YO1xuICAgIHRoaXMubWluWSA9IHkgPCB0aGlzLm1pblkgPyB5IDogdGhpcy5taW5ZO1xuICAgIHRoaXMubWF4WCA9IHggPiB0aGlzLm1heFggPyB4IDogdGhpcy5tYXhYO1xuICAgIHRoaXMubWF4WSA9IHkgPiB0aGlzLm1heFkgPyB5IDogdGhpcy5tYXhZO1xuICAgIHggPSBhICogbWluWCArIGMgKiBtYXhZICsgdHg7XG4gICAgeSA9IGIgKiBtaW5YICsgZCAqIG1heFkgKyB0eTtcbiAgICB0aGlzLm1pblggPSB4IDwgdGhpcy5taW5YID8geCA6IHRoaXMubWluWDtcbiAgICB0aGlzLm1pblkgPSB5IDwgdGhpcy5taW5ZID8geSA6IHRoaXMubWluWTtcbiAgICB0aGlzLm1heFggPSB4ID4gdGhpcy5tYXhYID8geCA6IHRoaXMubWF4WDtcbiAgICB0aGlzLm1heFkgPSB5ID4gdGhpcy5tYXhZID8geSA6IHRoaXMubWF4WTtcbiAgICB4ID0gYSAqIG1heFggKyBjICogbWF4WSArIHR4O1xuICAgIHkgPSBiICogbWF4WCArIGQgKiBtYXhZICsgdHk7XG4gICAgdGhpcy5taW5YID0geCA8IHRoaXMubWluWCA/IHggOiB0aGlzLm1pblg7XG4gICAgdGhpcy5taW5ZID0geSA8IHRoaXMubWluWSA/IHkgOiB0aGlzLm1pblk7XG4gICAgdGhpcy5tYXhYID0geCA+IHRoaXMubWF4WCA/IHggOiB0aGlzLm1heFg7XG4gICAgdGhpcy5tYXhZID0geSA+IHRoaXMubWF4WSA/IHkgOiB0aGlzLm1heFk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGJvdW5kcyBvYmplY3QgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gYmUgaW5jbHVkZWQuXG4gICAqL1xuICBmaXQocmVjdCkge1xuICAgIGlmICh0aGlzLm1pblggPCByZWN0LmxlZnQpXG4gICAgICB0aGlzLm1pblggPSByZWN0LmxlZnQ7XG4gICAgaWYgKHRoaXMubWF4WCA+IHJlY3QucmlnaHQpXG4gICAgICB0aGlzLm1heFggPSByZWN0LnJpZ2h0O1xuICAgIGlmICh0aGlzLm1pblkgPCByZWN0LnRvcClcbiAgICAgIHRoaXMubWluWSA9IHJlY3QudG9wO1xuICAgIGlmICh0aGlzLm1heFkgPiByZWN0LmJvdHRvbSlcbiAgICAgIHRoaXMubWF4WSA9IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYWRzIGJvdW5kcyBvYmplY3QsIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKiBJZiBwYWRkaW5nWSBpcyBvbWl0dGVkLCBib3RoIHBhZGRpbmdYIGFuZCBwYWRkaW5nWSB3aWxsIGJlIHNldCB0byBwYWRkaW5nWC5cbiAgICogQHBhcmFtIHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwYXJhbSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICovXG4gIHBhZChwYWRkaW5nWCwgcGFkZGluZ1kgPSBwYWRkaW5nWCkge1xuICAgIHRoaXMubWluWCAtPSBwYWRkaW5nWDtcbiAgICB0aGlzLm1heFggKz0gcGFkZGluZ1g7XG4gICAgdGhpcy5taW5ZIC09IHBhZGRpbmdZO1xuICAgIHRoaXMubWF4WSArPSBwYWRkaW5nWTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogQ2VpbHMgdGhlIGJvdW5kcy4gKi9cbiAgY2VpbCgpIHtcbiAgICB0aGlzLm1pblggPSBNYXRoLmZsb29yKHRoaXMubWluWCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5mbG9vcih0aGlzLm1pblkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGguY2VpbCh0aGlzLm1heFgpO1xuICAgIHRoaXMubWF4WSA9IE1hdGguY2VpbCh0aGlzLm1heFkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBDbG9uZXMgdGhlIGJvdW5kcy4gKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZHModGhpcy5taW5YLCB0aGlzLm1pblksIHRoaXMubWF4WCwgdGhpcy5tYXhZKTtcbiAgfVxuICAvKipcbiAgICogU2NhbGVzIHRoZSBib3VuZHMgYnkgdGhlIGdpdmVuIHZhbHVlc1xuICAgKiBAcGFyYW0geCAtIFRoZSBYIHZhbHVlIHRvIHNjYWxlIGJ5LlxuICAgKiBAcGFyYW0geSAtIFRoZSBZIHZhbHVlIHRvIHNjYWxlIGJ5LlxuICAgKi9cbiAgc2NhbGUoeCwgeSA9IHgpIHtcbiAgICB0aGlzLm1pblggKj0geDtcbiAgICB0aGlzLm1pblkgKj0geTtcbiAgICB0aGlzLm1heFggKj0geDtcbiAgICB0aGlzLm1heFkgKj0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogdGhlIHggdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWDtcbiAgfVxuICBzZXQgeCh2YWx1ZSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YO1xuICAgIHRoaXMubWluWCA9IHZhbHVlO1xuICAgIHRoaXMubWF4WCA9IHZhbHVlICsgd2lkdGg7XG4gIH1cbiAgLyoqIHRoZSB5IHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLm1pblk7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG4gICAgdGhpcy5taW5ZID0gdmFsdWU7XG4gICAgdGhpcy5tYXhZID0gdmFsdWUgKyBoZWlnaHQ7XG4gIH1cbiAgLyoqIHRoZSB3aWR0aCB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLm1heFggPSB0aGlzLm1pblggKyB2YWx1ZTtcbiAgfVxuICAvKiogdGhlIGhlaWdodCB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMubWF4WSA9IHRoaXMubWluWSArIHZhbHVlO1xuICB9XG4gIC8qKiB0aGUgbGVmdCB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YO1xuICB9XG4gIC8qKiB0aGUgcmlnaHQgdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1heFg7XG4gIH1cbiAgLyoqIHRoZSB0b3AgdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5ZO1xuICB9XG4gIC8qKiB0aGUgYm90dG9tIHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WTtcbiAgfVxuICAvKiogSXMgdGhlIGJvdW5kcyBwb3NpdGl2ZS4gKi9cbiAgZ2V0IGlzUG9zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWCA+IDAgJiYgdGhpcy5tYXhZIC0gdGhpcy5taW5ZID4gMDtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YICsgdGhpcy5taW5ZICE9PSBJbmZpbml0eTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzY3JlZW4gdmVydGljZXMgZnJvbSBhcnJheVxuICAgKiBAcGFyYW0gdmVydGV4RGF0YSAtIGNhbGN1bGF0ZWQgdmVydGljZXNcbiAgICogQHBhcmFtIGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBlbmQgb2Zmc2V0LCBleGNsdWRlZFxuICAgKiBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBhZGRWZXJ0ZXhEYXRhKHZlcnRleERhdGEsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQsIG1hdHJpeCkge1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGxldCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGxldCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGxldCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIG1hdHJpeCB8fCAobWF0cml4ID0gdGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBmb3IgKGxldCBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgbG9jYWxYID0gdmVydGV4RGF0YVtpXTtcbiAgICAgIGNvbnN0IGxvY2FsWSA9IHZlcnRleERhdGFbaSArIDFdO1xuICAgICAgY29uc3QgeCA9IGEgKiBsb2NhbFggKyBjICogbG9jYWxZICsgdHg7XG4gICAgICBjb25zdCB5ID0gYiAqIGxvY2FsWCArIGQgKiBsb2NhbFkgKyB0eTtcbiAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGJvdW5kcy5cbiAgICogQHBhcmFtIHggLSB4IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHkgLSB5IGNvb3JkaW5hdGVcbiAgICovXG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIGlmICh0aGlzLm1pblggPD0geCAmJiB0aGlzLm1pblkgPD0geSAmJiB0aGlzLm1heFggPj0geCAmJiB0aGlzLm1heFkgPj0geSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzOkJvdW5kcyBtaW5YPSR7dGhpcy5taW5YfSBtaW5ZPSR7dGhpcy5taW5ZfSBtYXhYPSR7dGhpcy5tYXhYfSBtYXhZPSR7dGhpcy5tYXhZfSB3aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IEJvdW5kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///535\n')},5128:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I_: () => (/* binding */ updateTransformBackwards),\n/* harmony export */   qW: () => (/* binding */ getGlobalBounds)\n/* harmony export */ });\n/* unused harmony export _getGlobalBounds */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2692);\n\n\n\n"use strict";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool */ .W.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\n\n//# sourceMappingURL=getGlobalBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBEO0FBQ2U7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtFQUFVO0FBQy9CO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLHFFQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLElBQUksK0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0VBQVU7QUFDL0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLG1DQUFtQyxxRUFBTTtBQUN6QyxJQUFJLCtFQUFVO0FBQ2Q7QUFDQTtBQUNBLElBQUksK0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RTtBQUN2RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcz84ZmE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IG1hdHJpeFBvb2wsIGJvdW5kc1Bvb2wgfSBmcm9tICcuL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRHbG9iYWxCb3VuZHModGFyZ2V0LCBza2lwVXBkYXRlVHJhbnNmb3JtLCBib3VuZHMpIHtcbiAgYm91bmRzLmNsZWFyKCk7XG4gIGxldCBwYXJlbnRUcmFuc2Zvcm07XG4gIGxldCBwb29sZWRNYXRyaXg7XG4gIGlmICh0YXJnZXQucGFyZW50KSB7XG4gICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICBwb29sZWRNYXRyaXggPSBtYXRyaXhQb29sLmdldCgpLmlkZW50aXR5KCk7XG4gICAgICBwYXJlbnRUcmFuc2Zvcm0gPSB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHModGFyZ2V0LCBwb29sZWRNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRUcmFuc2Zvcm0gPSB0YXJnZXQucGFyZW50LndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmFuc2Zvcm0gPSBNYXRyaXguSURFTlRJVFk7XG4gIH1cbiAgX2dldEdsb2JhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcywgcGFyZW50VHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtKTtcbiAgaWYgKHBvb2xlZE1hdHJpeCkge1xuICAgIG1hdHJpeFBvb2wucmV0dXJuKHBvb2xlZE1hdHJpeCk7XG4gIH1cbiAgaWYgKCFib3VuZHMuaXNWYWxpZCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRHbG9iYWxCb3VuZHModGFyZ2V0LCBib3VuZHMsIHBhcmVudFRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICBpZiAoIXRhcmdldC52aXNpYmxlIHx8ICF0YXJnZXQubWVhc3VyYWJsZSlcbiAgICByZXR1cm47XG4gIGxldCB3b3JsZFRyYW5zZm9ybTtcbiAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgdGFyZ2V0LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXhQb29sLmdldCgpO1xuICAgIHdvcmxkVHJhbnNmb3JtLmFwcGVuZEZyb20odGFyZ2V0LmxvY2FsVHJhbnNmb3JtLCBwYXJlbnRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIHdvcmxkVHJhbnNmb3JtID0gdGFyZ2V0LndvcmxkVHJhbnNmb3JtO1xuICB9XG4gIGNvbnN0IHBhcmVudEJvdW5kcyA9IGJvdW5kcztcbiAgY29uc3QgcHJlc2VydmVCb3VuZHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgaWYgKHByZXNlcnZlQm91bmRzKSB7XG4gICAgYm91bmRzID0gYm91bmRzUG9vbC5nZXQoKS5jbGVhcigpO1xuICB9XG4gIGlmICh0YXJnZXQuYm91bmRzQXJlYSkge1xuICAgIGJvdW5kcy5hZGRSZWN0KHRhcmdldC5ib3VuZHNBcmVhLCB3b3JsZFRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRhcmdldC5hZGRCb3VuZHMpIHtcbiAgICAgIGJvdW5kcy5tYXRyaXggPSB3b3JsZFRyYW5zZm9ybTtcbiAgICAgIHRhcmdldC5hZGRCb3VuZHMoYm91bmRzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9nZXRHbG9iYWxCb3VuZHModGFyZ2V0LmNoaWxkcmVuW2ldLCBib3VuZHMsIHdvcmxkVHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlcnZlQm91bmRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQuZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0LmVmZmVjdHNbaV0uYWRkQm91bmRzPy4oYm91bmRzKTtcbiAgICB9XG4gICAgcGFyZW50Qm91bmRzLmFkZEJvdW5kcyhib3VuZHMsIE1hdHJpeC5JREVOVElUWSk7XG4gICAgYm91bmRzUG9vbC5yZXR1cm4oYm91bmRzKTtcbiAgfVxuICBpZiAoIXNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICBtYXRyaXhQb29sLnJldHVybih3b3JsZFRyYW5zZm9ybSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zZm9ybUJhY2t3YXJkcyh0YXJnZXQsIHBhcmVudFRyYW5zZm9ybSkge1xuICBjb25zdCBwYXJlbnQgPSB0YXJnZXQucGFyZW50O1xuICBpZiAocGFyZW50KSB7XG4gICAgdXBkYXRlVHJhbnNmb3JtQmFja3dhcmRzKHBhcmVudCwgcGFyZW50VHJhbnNmb3JtKTtcbiAgICBwYXJlbnQudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICBwYXJlbnRUcmFuc2Zvcm0uYXBwZW5kKHBhcmVudC5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHBhcmVudFRyYW5zZm9ybTtcbn1cblxuZXhwb3J0IHsgX2dldEdsb2JhbEJvdW5kcywgZ2V0R2xvYmFsQm91bmRzLCB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdsb2JhbEJvdW5kcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5128\n')},3197:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getLocalBounds)\n/* harmony export */ });\n/* unused harmony export getParent */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2692);\n\n\n\n\n"use strict";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool */ .W.return(bounds);\n  }\n  _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn("Item is not inside the root container");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\n\n//# sourceMappingURL=getLocalBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEQ7QUFDSDtBQUNrQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFFQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtFQUFVO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QiwrRUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUMscUVBQU07QUFDekMsSUFBSSwrRUFBVTtBQUNkO0FBQ0EsRUFBRSwrRUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0TG9jYWxCb3VuZHMubWpzPzQwNjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgbWF0cml4UG9vbCwgYm91bmRzUG9vbCB9IGZyb20gJy4vdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHRhcmdldCwgYm91bmRzLCByZWxhdGl2ZU1hdHJpeCkge1xuICBib3VuZHMuY2xlYXIoKTtcbiAgcmVsYXRpdmVNYXRyaXggfHwgKHJlbGF0aXZlTWF0cml4ID0gTWF0cml4LklERU5USVRZKTtcbiAgX2dldExvY2FsQm91bmRzKHRhcmdldCwgYm91bmRzLCByZWxhdGl2ZU1hdHJpeCwgdGFyZ2V0LCB0cnVlKTtcbiAgaWYgKCFib3VuZHMuaXNWYWxpZCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRMb2NhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcywgcGFyZW50VHJhbnNmb3JtLCByb290Q29udGFpbmVyLCBpc1Jvb3QpIHtcbiAgbGV0IHJlbGF0aXZlVHJhbnNmb3JtO1xuICBpZiAoIWlzUm9vdCkge1xuICAgIGlmICghdGFyZ2V0LnZpc2libGUgfHwgIXRhcmdldC5tZWFzdXJhYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgIGNvbnN0IGxvY2FsVHJhbnNmb3JtID0gdGFyZ2V0LmxvY2FsVHJhbnNmb3JtO1xuICAgIHJlbGF0aXZlVHJhbnNmb3JtID0gbWF0cml4UG9vbC5nZXQoKTtcbiAgICByZWxhdGl2ZVRyYW5zZm9ybS5hcHBlbmRGcm9tKGxvY2FsVHJhbnNmb3JtLCBwYXJlbnRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIHJlbGF0aXZlVHJhbnNmb3JtID0gbWF0cml4UG9vbC5nZXQoKTtcbiAgICByZWxhdGl2ZVRyYW5zZm9ybSA9IHBhcmVudFRyYW5zZm9ybS5jb3B5VG8ocmVsYXRpdmVUcmFuc2Zvcm0pO1xuICB9XG4gIGNvbnN0IHBhcmVudEJvdW5kcyA9IGJvdW5kcztcbiAgY29uc3QgcHJlc2VydmVCb3VuZHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgaWYgKHByZXNlcnZlQm91bmRzKSB7XG4gICAgYm91bmRzID0gYm91bmRzUG9vbC5nZXQoKS5jbGVhcigpO1xuICB9XG4gIGlmICh0YXJnZXQuYm91bmRzQXJlYSkge1xuICAgIGJvdW5kcy5hZGRSZWN0KHRhcmdldC5ib3VuZHNBcmVhLCByZWxhdGl2ZVRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRhcmdldC5yZW5kZXJQaXBlSWQpIHtcbiAgICAgIGJvdW5kcy5tYXRyaXggPSByZWxhdGl2ZVRyYW5zZm9ybTtcbiAgICAgIHRhcmdldC5hZGRCb3VuZHMoYm91bmRzKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgX2dldExvY2FsQm91bmRzKGNoaWxkcmVuW2ldLCBib3VuZHMsIHJlbGF0aXZlVHJhbnNmb3JtLCByb290Q29udGFpbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZXJ2ZUJvdW5kcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldC5lZmZlY3RzW2ldLmFkZExvY2FsQm91bmRzPy4oYm91bmRzLCByb290Q29udGFpbmVyKTtcbiAgICB9XG4gICAgcGFyZW50Qm91bmRzLmFkZEJvdW5kcyhib3VuZHMsIE1hdHJpeC5JREVOVElUWSk7XG4gICAgYm91bmRzUG9vbC5yZXR1cm4oYm91bmRzKTtcbiAgfVxuICBtYXRyaXhQb29sLnJldHVybihyZWxhdGl2ZVRyYW5zZm9ybSk7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnQodGFyZ2V0LCByb290LCBtYXRyaXgpIHtcbiAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgaWYgKCFwYXJlbnQpIHtcbiAgICB3YXJuKFwiSXRlbSBpcyBub3QgaW5zaWRlIHRoZSByb290IGNvbnRhaW5lclwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmVudCAhPT0gcm9vdCkge1xuICAgIGdldFBhcmVudChwYXJlbnQsIHJvb3QsIG1hdHJpeCk7XG4gICAgcGFyZW50LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgbWF0cml4LmFwcGVuZChwYXJlbnQubG9jYWxUcmFuc2Zvcm0pO1xuICB9XG59XG5cbmV4cG9ydCB7IGdldExvY2FsQm91bmRzLCBnZXRQYXJlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldExvY2FsQm91bmRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3197\n')},2692:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: () => (/* binding */ matrixPool),\n/* harmony export */   W: () => (/* binding */ boundsPool)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5374);\n/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(535);\n\n\n\n\n"use strict";\nconst matrixPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y);\nconst boundsPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Bounds */ .Y);\n\n\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ047QUFDaEI7O0FBRXZDO0FBQ0EsdUJBQXVCLCtEQUFJLENBQUMscUVBQU07QUFDbEMsdUJBQXVCLCtEQUFJLENBQUMsd0RBQU07O0FBRUE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzPzcxODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9vbCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbC5tanMnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi4vQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgbWF0cml4UG9vbCA9IG5ldyBQb29sKE1hdHJpeCk7XG5jb25zdCBib3VuZHNQb29sID0gbmV3IFBvb2woQm91bmRzKTtcblxuZXhwb3J0IHsgYm91bmRzUG9vbCwgbWF0cml4UG9vbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0cml4QW5kQm91bmRzUG9vbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2692\n')},9676:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  D: () => (/* binding */ mixColors)\n});\n\n// UNUSED EXPORTS: mixStandardAnd32BitColors\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs\n\nfunction mixHexColors_mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\n\n//# sourceMappingURL=mixHexColors.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs\n\n\n"use strict";\nconst WHITE_WHITE = 16777215 + (16777215 << 32);\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {\n    if (localBGRColor === 16777215) {\n      return parentBGRColor;\n    } else if (parentBGRColor === 16777215) {\n      return localBGRColor;\n    }\n    return mixHexColors_mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return 16777215;\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor = 16777215;\n  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {\n    if (localBGRColor === 16777215) {\n      sharedBGRColor = parentBGRColor;\n    } else if (parentBGRColor === 16777215) {\n      sharedBGRColor = localBGRColor;\n    } else {\n      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n    }\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\n\n//# sourceMappingURL=mixColors.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY3Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLFNBQVMseUJBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEI7OztBQ2ZrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxXQUFXLHlCQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDtBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9taXhIZXhDb2xvcnMubWpzPzUwMTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL3V0aWxzL21peENvbG9ycy5tanM/ZDViYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1peEhleENvbG9ycyhjb2xvcjEsIGNvbG9yMiwgcmF0aW8pIHtcbiAgY29uc3QgcjEgPSBjb2xvcjEgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcxID0gY29sb3IxID4+IDggJiAyNTU7XG4gIGNvbnN0IGIxID0gY29sb3IxICYgMjU1O1xuICBjb25zdCByMiA9IGNvbG9yMiA+PiAxNiAmIDI1NTtcbiAgY29uc3QgZzIgPSBjb2xvcjIgPj4gOCAmIDI1NTtcbiAgY29uc3QgYjIgPSBjb2xvcjIgJiAyNTU7XG4gIGNvbnN0IHIgPSByMSArIChyMiAtIHIxKSAqIHJhdGlvO1xuICBjb25zdCBnID0gZzEgKyAoZzIgLSBnMSkgKiByYXRpbztcbiAgY29uc3QgYiA9IGIxICsgKGIyIC0gYjEpICogcmF0aW87XG4gIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG59XG5cbmV4cG9ydCB7IG1peEhleENvbG9ycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl4SGV4Q29sb3JzLm1qcy5tYXBcbiIsImltcG9ydCB7IG1peEhleENvbG9ycyB9IGZyb20gJy4vbWl4SGV4Q29sb3JzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgV0hJVEVfV0hJVEUgPSAxNjc3NzIxNSArICgxNjc3NzIxNSA8PCAzMik7XG5mdW5jdGlvbiBtaXhDb2xvcnMobG9jYWxCR1JDb2xvciwgcGFyZW50QkdSQ29sb3IpIHtcbiAgaWYgKGxvY2FsQkdSQ29sb3IgKyAocGFyZW50QkdSQ29sb3IgPDwgMzIpICE9PSBXSElURV9XSElURSkge1xuICAgIGlmIChsb2NhbEJHUkNvbG9yID09PSAxNjc3NzIxNSkge1xuICAgICAgcmV0dXJuIHBhcmVudEJHUkNvbG9yO1xuICAgIH0gZWxzZSBpZiAocGFyZW50QkdSQ29sb3IgPT09IDE2Nzc3MjE1KSB7XG4gICAgICByZXR1cm4gbG9jYWxCR1JDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIG1peEhleENvbG9ycyhsb2NhbEJHUkNvbG9yLCBwYXJlbnRCR1JDb2xvciwgMC41KTtcbiAgfVxuICByZXR1cm4gMTY3NzcyMTU7XG59XG5mdW5jdGlvbiBtaXhTdGFuZGFyZEFuZDMyQml0Q29sb3JzKGxvY2FsQ29sb3JSR0IsIGxvY2FsQWxwaGEsIHBhcmVudENvbG9yKSB7XG4gIGNvbnN0IHBhcmVudEFscGhhID0gKHBhcmVudENvbG9yID4+IDI0ICYgMjU1KSAvIDI1NTtcbiAgY29uc3QgZ2xvYmFsQWxwaGEgPSBsb2NhbEFscGhhICogcGFyZW50QWxwaGEgKiAyNTU7XG4gIGNvbnN0IGxvY2FsQkdSQ29sb3IgPSAoKGxvY2FsQ29sb3JSR0IgJiAyNTUpIDw8IDE2KSArIChsb2NhbENvbG9yUkdCICYgNjUyODApICsgKGxvY2FsQ29sb3JSR0IgPj4gMTYgJiAyNTUpO1xuICBjb25zdCBwYXJlbnRCR1JDb2xvciA9IHBhcmVudENvbG9yICYgMTY3NzcyMTU7XG4gIGxldCBzaGFyZWRCR1JDb2xvciA9IDE2Nzc3MjE1O1xuICBpZiAobG9jYWxCR1JDb2xvciArIChwYXJlbnRCR1JDb2xvciA8PCAzMikgIT09IFdISVRFX1dISVRFKSB7XG4gICAgaWYgKGxvY2FsQkdSQ29sb3IgPT09IDE2Nzc3MjE1KSB7XG4gICAgICBzaGFyZWRCR1JDb2xvciA9IHBhcmVudEJHUkNvbG9yO1xuICAgIH0gZWxzZSBpZiAocGFyZW50QkdSQ29sb3IgPT09IDE2Nzc3MjE1KSB7XG4gICAgICBzaGFyZWRCR1JDb2xvciA9IGxvY2FsQkdSQ29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJlZEJHUkNvbG9yID0gbWl4SGV4Q29sb3JzKGxvY2FsQkdSQ29sb3IsIHBhcmVudEJHUkNvbG9yLCAwLjUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hhcmVkQkdSQ29sb3IgKyAoZ2xvYmFsQWxwaGEgPDwgMjQpO1xufVxuXG5leHBvcnQgeyBtaXhDb2xvcnMsIG1peFN0YW5kYXJkQW5kMzJCaXRDb2xvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peENvbG9ycy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9676\n')},26:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ BatchableGraphics)\n/* harmony export */ });\n/* harmony import */ var _container_utils_mixColors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9676);\n\n\n"use strict";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return "normal";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = (0,_container_utils_mixColors_mjs__WEBPACK_IMPORTED_MODULE_0__/* .mixColors */ .D)(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\n\n//# sourceMappingURL=BatchableGraphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtGQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9CYXRjaGFibGVHcmFwaGljcy5tanM/NGQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtaXhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvdXRpbHMvbWl4Q29sb3JzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hhYmxlR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhdGNoZXIgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSAwO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmFibGUuZ3JvdXBCbGVuZE1vZGU7XG4gICAgfVxuICAgIHJldHVybiBcIm5vcm1hbFwiO1xuICB9XG4gIHBhY2tJbmRleChpbmRleEJ1ZmZlciwgaW5kZXgsIGluZGljZXNPZmZzZXQpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeURhdGEuaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXhTaXplOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2luZGV4KytdID0gaW5kaWNlc1tpICsgdGhpcy5pbmRleE9mZnNldF0gKyBpbmRpY2VzT2Zmc2V0IC0gdGhpcy52ZXJ0ZXhPZmZzZXQ7XG4gICAgfVxuICB9XG4gIHBhY2tBdHRyaWJ1dGVzKGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleCwgdGV4dHVyZUlkKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5RGF0YTtcbiAgICBjb25zdCBncmFwaGljcyA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBjb25zdCB1dnMgPSBnZW9tZXRyeS51dnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy52ZXJ0ZXhPZmZzZXQgKiAyO1xuICAgIGNvbnN0IHZlcnRTaXplID0gKHRoaXMudmVydGV4T2Zmc2V0ICsgdGhpcy52ZXJ0ZXhTaXplKSAqIDI7XG4gICAgY29uc3QgcmdiID0gdGhpcy5jb2xvcjtcbiAgICBjb25zdCBiZ3IgPSByZ2IgPj4gMTYgfCByZ2IgJiA2NTI4MCB8IChyZ2IgJiAyNTUpIDw8IDE2O1xuICAgIGlmICh0aGlzLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCBhcmdiID0gbWl4Q29sb3JzKGJnciwgZ3JhcGhpY3MuZ3JvdXBDb2xvcikgKyAodGhpcy5hbHBoYSAqIGdyYXBoaWNzLmdyb3VwQWxwaGEgKiAyNTUgPDwgMjQpO1xuICAgICAgY29uc3Qgd3QgPSBncmFwaGljcy5ncm91cFRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IHRleHR1cmVJZEFuZFJvdW5kID0gdGV4dHVyZUlkIDw8IDE2IHwgdGhpcy5yb3VuZFBpeGVscyAmIDY1NTM1O1xuICAgICAgY29uc3QgYSA9IHd0LmE7XG4gICAgICBjb25zdCBiID0gd3QuYjtcbiAgICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgICBjb25zdCB0eCA9IHd0LnR4O1xuICAgICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB2ZXJ0U2l6ZTsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhcmdiO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWRBbmRSb3VuZDtcbiAgICAgICAgaW5kZXggKz0gNjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXJnYiA9IGJnciArICh0aGlzLmFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB2ZXJ0U2l6ZTsgaSArPSAyKSB7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4XSA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhcmdiO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWQgPDwgMTY7XG4gICAgICAgIGluZGV4ICs9IDY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRPRE8gcmVuYW1lIHRvIHZlcnRleFNpemVcbiAgZ2V0IHZlcnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRleFNpemU7XG4gIH1cbiAgY29weVRvKGdwdUJ1ZmZlcikge1xuICAgIGdwdUJ1ZmZlci5pbmRleE9mZnNldCA9IHRoaXMuaW5kZXhPZmZzZXQ7XG4gICAgZ3B1QnVmZmVyLmluZGV4U2l6ZSA9IHRoaXMuaW5kZXhTaXplO1xuICAgIGdwdUJ1ZmZlci52ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRleE9mZnNldDtcbiAgICBncHVCdWZmZXIudmVydGV4U2l6ZSA9IHRoaXMudmVydGV4U2l6ZTtcbiAgICBncHVCdWZmZXIuY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGdwdUJ1ZmZlci5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgZ3B1QnVmZmVyLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgZ3B1QnVmZmVyLmdlb21ldHJ5RGF0YSA9IHRoaXMuZ2VvbWV0cnlEYXRhO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoYWJsZUdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaGFibGVHcmFwaGljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},6475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ Graphics)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8400);\n/* harmony import */ var _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6653);\n\n\n\n\n"use strict";\nclass Graphics extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: "Graphics",\n      ...rest\n    });\n    this.canBundle = true;\n    this.renderPipeId = "graphics";\n    this._roundPixels = 0;\n    if (!context) {\n      this._context = this._ownedContext = new _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g();\n    } else {\n      this._context = context;\n    }\n    this._context.on("update", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off("update", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod("setFillStyle", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod("setStrokeStyle", args);\n  }\n  fill(...args) {\n    return this._callContextMethod("fill", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod("stroke", args);\n  }\n  texture(...args) {\n    return this._callContextMethod("texture", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod("beginPath", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod("cut", []);\n  }\n  arc(...args) {\n    return this._callContextMethod("arc", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod("arcTo", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod("arcToSvg", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod("bezierCurveTo", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod("closePath", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod("ellipse", args);\n  }\n  circle(...args) {\n    return this._callContextMethod("circle", args);\n  }\n  path(...args) {\n    return this._callContextMethod("path", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod("lineTo", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod("moveTo", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod("quadraticCurveTo", args);\n  }\n  rect(...args) {\n    return this._callContextMethod("rect", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod("roundRect", args);\n  }\n  poly(...args) {\n    return this._callContextMethod("poly", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod("regularPoly", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod("roundPoly", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod("roundShape", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod("filletRect", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod("chamferRect", args);\n  }\n  star(...args) {\n    return this._callContextMethod("star", args);\n  }\n  svg(...args) {\n    return this._callContextMethod("svg", args);\n  }\n  restore(...args) {\n    return this._callContextMethod("restore", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod("save", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod("resetTransform", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod("rotate", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod("scale", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod("setTransform", args);\n  }\n  transform(...args) {\n    return this._callContextMethod("transform", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod("translate", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod("clear", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.width || strokeStyle.color !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.color || strokeStyle.alpha !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawCircle has been renamed to Graphics#circle");\n    return this._callContextMethod("circle", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawEllipse has been renamed to Graphics#ellipse");\n    return this._callContextMethod("ellipse", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawPolygon has been renamed to Graphics#poly");\n    return this._callContextMethod("poly", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRect has been renamed to Graphics#rect");\n    return this._callContextMethod("rect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");\n    return this._callContextMethod("roundRect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawStar has been renamed to Graphics#star");\n    return this._callContextMethod("star", args);\n  }\n}\n\n\n//# sourceMappingURL=Graphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDbkI7QUFDRjs7QUFFeEQ7QUFDQSx1QkFBdUIseUVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQWU7QUFDMUMsa0JBQWtCO0FBQ2xCO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBFQUFlO0FBQzlELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQWUsbURBQW1ELDBFQUFlLG1EQUFtRCwwRUFBZTtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljcy5tanM/NDZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0IH0gZnJvbSAnLi9HcmFwaGljc0NvbnRleHQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBHcmFwaGljcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGV4dDogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQsIHJvdW5kUGl4ZWxzLCAuLi5yZXN0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHtcbiAgICAgIGxhYmVsOiBcIkdyYXBoaWNzXCIsXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJncmFwaGljc1wiO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gMDtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9vd25lZENvbnRleHQgPSBuZXcgR3JhcGhpY3NDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLmFsbG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHMgPz8gZmFsc2U7XG4gIH1cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB0aGlzLl9jb250ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbnRleHQub2ZmKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgYm91bmRzIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBib3VuZHMgb2YgdGhpcyBvYmplY3QgdG8gdGhlIGJvdW5kcyBvYmplY3QuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUaGUgb3V0cHV0IGJvdW5kcyBvYmplY3QuXG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyh0aGlzLl9jb250ZXh0LmJvdW5kcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY29udGFpbnNQb2ludChwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqICBXaGV0aGVyIG9yIG5vdCB0byByb3VuZCB0aGUgeC95IHBvc2l0aW9uIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgb25WaWV3VXBkYXRlKCkge1xuICAgIHRoaXMuX2RpZENoYW5nZUlkICs9IDEgPDwgMTI7XG4gICAgdGhpcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5vbkNoaWxkVmlld1VwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgZ3JhcGhpY3MgcmVuZGVyYWJsZSBhbmQgb3B0aW9uYWxseSBpdHMgY29udGV4dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqXG4gICAqIElmIHRoZSBjb250ZXh0IHdhcyBjcmVhdGVkIGJ5IHRoaXMgZ3JhcGhpY3MgYW5kIGBkZXN0cm95KGZhbHNlKWAgb3IgYGRlc3Ryb3koKWAgaXMgY2FsbGVkXG4gICAqIHRoZW4gdGhlIGNvbnRleHQgd2lsbCBzdGlsbCBiZSBkZXN0cm95ZWQuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIGV4cGxpY2l0bHkgbm90IGRlc3Ryb3kgdGhpcyBjb250ZXh0IHRoYXQgdGhpcyBncmFwaGljcyBjcmVhdGVkLFxuICAgKiB0aGVuIHlvdSBzaG91bGQgcGFzcyBkZXN0cm95KHsgY29udGV4dDogZmFsc2UgfSlcbiAgICpcbiAgICogSWYgdGhlIGNvbnRleHQgd2FzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IgdGhlbiBpdCB3aWxsIG5vdCBiZSBkZXN0cm95ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb250ZXh0PWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSBjb250ZXh0XG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fb3duZWRDb250ZXh0ICYmICFvcHRpb25zKSB7XG4gICAgICB0aGlzLl9vd25lZENvbnRleHQuZGVzdHJveShvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUgfHwgb3B0aW9ucz8uY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fY29udGV4dC5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLl9vd25lZENvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbiAgX2NhbGxDb250ZXh0TWV0aG9kKG1ldGhvZCwgYXJncykge1xuICAgIHRoaXMuY29udGV4dFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHcmFwaGljc0NvbnRleHQgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgZmlsbCBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gVGhlIGZpbGwgc3R5bGUgY2FuIGJlIGEgY29sb3IsIGdyYWRpZW50LFxuICAgKiBwYXR0ZXJuLCBvciBhIG1vcmUgY29tcGxleCBzdHlsZSBkZWZpbmVkIGJ5IGEgRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSBUaGUgZmlsbCBzdHlsZSB0byBhcHBseS4gVGhpcyBjYW4gYmUgYSBzaW1wbGUgY29sb3IsIGEgZ3JhZGllbnQgb3JcbiAgICogcGF0dGVybiBvYmplY3QsIG9yIGEgRmlsbFN0eWxlIG9yIENvbnZlcnRlZEZpbGxTdHlsZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNldEZpbGxTdHlsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2V0RmlsbFN0eWxlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gU2ltaWxhciB0byBmaWxsIHN0eWxlcywgc3Ryb2tlIHN0eWxlcyBjYW5cbiAgICogZW5jb21wYXNzIGNvbG9ycywgZ3JhZGllbnRzLCBwYXR0ZXJucywgb3IgbW9yZSBkZXRhaWxlZCBjb25maWd1cmF0aW9ucyB2aWEgYSBTdHJva2VTdHlsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RmlsbFN0eWxlSW5wdXRzfSBhcmdzIC0gVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBjb2xvciwgYSBncmFkaWVudCBvciBwYXR0ZXJuLFxuICAgKiBvciBhIFN0cm9rZVN0eWxlIG9yIENvbnZlcnRlZFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0U3Ryb2tlU3R5bGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNldFN0cm9rZVN0eWxlXCIsIGFyZ3MpO1xuICB9XG4gIGZpbGwoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImZpbGxcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cm9rZXMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS4gVGhpcyBtZXRob2QgY2FuIHRha2UgYW4gb3B0aW9uYWxcbiAgICogRmlsbFN0eWxlSW5wdXRzIHBhcmFtZXRlciB0byBkZWZpbmUgdGhlIHN0cm9rZSdzIGFwcGVhcmFuY2UsIGluY2x1ZGluZyBpdHMgY29sb3IsIHdpZHRoLCBhbmQgb3RoZXIgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSAoT3B0aW9uYWwpIFRoZSBzdHJva2Ugc3R5bGUgdG8gYXBwbHkuIENhbiBiZSBkZWZpbmVkIGFzIGEgc2ltcGxlIGNvbG9yIG9yIGEgbW9yZVxuICAgKiBjb21wbGV4IHN0eWxlIG9iamVjdC4gSWYgb21pdHRlZCwgdXNlcyB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHN0cm9rZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic3Ryb2tlXCIsIGFyZ3MpO1xuICB9XG4gIHRleHR1cmUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInRleHR1cmVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCBwYXRoLiBBbnkgcHJldmlvdXMgcGF0aCBhbmQgaXRzIGNvbW1hbmRzIGFyZSBkaXNjYXJkZWQgYW5kIGEgbmV3IHBhdGggaXNcbiAgICogc3RhcnRlZC4gVGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkIGJlZm9yZSBiZWdpbm5pbmcgYSBuZXcgc2hhcGUgb3Igc2VyaWVzIG9mIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGJlZ2luUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJiZWdpblBhdGhcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgY3V0b3V0IHRvIHRoZSBsYXN0IGRyYXduIHNoYXBlLiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGhvbGVzIG9yIGNvbXBsZXggc2hhcGVzIGJ5XG4gICAqIHN1YnRyYWN0aW5nIGEgcGF0aCBmcm9tIHRoZSBwcmV2aW91c2x5IGRyYXduIHBhdGguIElmIGEgaG9sZSBpcyBub3QgY29tcGxldGVseSBpbiBhIHNoYXBlLCBpdCB3aWxsXG4gICAqIGZhaWwgdG8gY3V0IGNvcnJlY3RseSFcbiAgICovXG4gIGN1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjdXRcIiwgW10pO1xuICB9XG4gIGFyYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjXCIsIGFyZ3MpO1xuICB9XG4gIGFyY1RvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJhcmNUb1wiLCBhcmdzKTtcbiAgfVxuICBhcmNUb1N2ZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjVG9TdmdcIiwgYXJncyk7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYmV6aWVyQ3VydmVUb1wiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNsb3NlUGF0aFwiLCBbXSk7XG4gIH1cbiAgZWxsaXBzZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiZWxsaXBzZVwiLCBhcmdzKTtcbiAgfVxuICBjaXJjbGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNpcmNsZVwiLCBhcmdzKTtcbiAgfVxuICBwYXRoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwYXRoXCIsIGFyZ3MpO1xuICB9XG4gIGxpbmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwibGluZVRvXCIsIGFyZ3MpO1xuICB9XG4gIG1vdmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwibW92ZVRvXCIsIGFyZ3MpO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInF1YWRyYXRpY0N1cnZlVG9cIiwgYXJncyk7XG4gIH1cbiAgcmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVjdFwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUmVjdFwiLCBhcmdzKTtcbiAgfVxuICBwb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwb2x5XCIsIGFyZ3MpO1xuICB9XG4gIHJlZ3VsYXJQb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWd1bGFyUG9seVwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFBvbHkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUG9seVwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFNoYXBlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3VuZFNoYXBlXCIsIGFyZ3MpO1xuICB9XG4gIGZpbGxldFJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImZpbGxldFJlY3RcIiwgYXJncyk7XG4gIH1cbiAgY2hhbWZlclJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNoYW1mZXJSZWN0XCIsIGFyZ3MpO1xuICB9XG4gIHN0YXIoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInN0YXJcIiwgYXJncyk7XG4gIH1cbiAgc3ZnKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdmdcIiwgYXJncyk7XG4gIH1cbiAgcmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVzdG9yZVwiLCBhcmdzKTtcbiAgfVxuICAvKiogU2F2ZXMgdGhlIGN1cnJlbnQgZ3JhcGhpY3Mgc3RhdGUsIGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnMsIGZpbGwgc3R5bGVzLCBhbmQgc3Ryb2tlIHN0eWxlcywgb250byBhIHN0YWNrLiAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNhdmVcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgZ2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmdcbiAgICogYW55IHRyYW5zZm9ybWF0aW9ucyAocm90YXRpb24sIHNjYWxpbmcsIHRyYW5zbGF0aW9uKSBwcmV2aW91c2x5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlc2V0VHJhbnNmb3JtXCIsIFtdKTtcbiAgfVxuICByb3RhdGVUcmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdGF0ZVwiLCBhcmdzKTtcbiAgfVxuICBzY2FsZVRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2NhbGVcIiwgYXJncyk7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzZXRUcmFuc2Zvcm1cIiwgYXJncyk7XG4gIH1cbiAgdHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0cmFuc2Zvcm1cIiwgYXJncyk7XG4gIH1cbiAgdHJhbnNsYXRlVHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0cmFuc2xhdGVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgZHJhd2luZyBjb21tYW5kcyBmcm9tIHRoZSBncmFwaGljcyBjb250ZXh0LCBlZmZlY3RpdmVseSByZXNldHRpbmcgaXQuIFRoaXMgaW5jbHVkZXMgY2xlYXJpbmcgdGhlIHBhdGgsXG4gICAqIGFuZCBvcHRpb25hbGx5IHJlc2V0dGluZyB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2xlYXJcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZmlsbCBzdHlsZSB0byB1c2UuXG4gICAqIEB0eXBlIHtDb252ZXJ0ZWRGaWxsU3R5bGV9XG4gICAqL1xuICBnZXQgZmlsbFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZTtcbiAgfVxuICBzZXQgZmlsbFN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cm9rZSBzdHlsZSB0byB1c2UuXG4gICAqIEB0eXBlIHtDb252ZXJ0ZWRTdHJva2VTdHlsZX1cbiAgICovXG4gIGdldCBzdHJva2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5zdHJva2VTdHlsZTtcbiAgfVxuICBzZXQgc3Ryb2tlU3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3Mgb2JqZWN0LlxuICAgKiBOb3RlIHRoYXQgb25seSB0aGUgY29udGV4dCBvZiB0aGUgb2JqZWN0IGlzIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICogQHBhcmFtIGRlZXAgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIGRlZXAgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdC4gSWYgZmFsc2UsIHRoZSBjb250ZXh0XG4gICAqIHdpbGwgYmUgc2hhcmVkIGJldHdlZW4gdGhlIHR3byBvYmplY3RzIChkZWZhdWx0IGZhbHNlKS4gSWYgdHJ1ZSwgdGhlIGNvbnRleHQgd2lsbCBiZVxuICAgKiBjbG9uZWQgKHJlY29tbWVuZGVkIGlmIHlvdSBuZWVkIHRvIG1vZGlmeSB0aGUgY29udGV4dCBpbiBhbnkgd2F5KS5cbiAgICogQHJldHVybnMgLSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICovXG4gIGNsb25lKGRlZXAgPSBmYWxzZSkge1xuICAgIGlmIChkZWVwKSB7XG4gICAgICByZXR1cm4gbmV3IEdyYXBoaWNzKHRoaXMuX2NvbnRleHQuY2xvbmUoKSk7XG4gICAgfVxuICAgIHRoaXMuX293bmVkQ29udGV4dCA9IG51bGw7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgR3JhcGhpY3ModGhpcy5fY29udGV4dCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8vIC0tLS0tLS0tIHY3IGRlcHJlY2F0aW9ucyAtLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gY29sb3JcbiAgICogQHBhcmFtIGFscGhhXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGV9IGluc3RlYWRcbiAgICovXG4gIGxpbmVTdHlsZSh3aWR0aCwgY29sb3IsIGFscGhhKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2xpbmVTdHlsZSBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGUgdG8gc2V0IHRoZSBzdHJva2Ugc3R5bGUuXCIpO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0ge307XG4gICAgd2lkdGggJiYgKHN0cm9rZVN0eWxlLndpZHRoID0gd2lkdGgpO1xuICAgIGNvbG9yICYmIChzdHJva2VTdHlsZS5jb2xvciA9IGNvbG9yKTtcbiAgICBhbHBoYSAmJiAoc3Ryb2tlU3R5bGUuYWxwaGEgPSBhbHBoYSk7XG4gICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBjb2xvclxuICAgKiBAcGFyYW0gYWxwaGFcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNmaWxsfSBpbnN0ZWFkXG4gICAqL1xuICBiZWdpbkZpbGwoY29sb3IsIGFscGhhKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2JlZ2luRmlsbCBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3MjZmlsbCB0byBmaWxsIHRoZSBzaGFwZSB3aXRoIHRoZSBkZXNpcmVkIHN0eWxlLlwiKTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSB7fTtcbiAgICBjb2xvciAmJiAoZmlsbFN0eWxlLmNvbG9yID0gY29sb3IpO1xuICAgIGFscGhhICYmIChmaWxsU3R5bGUuYWxwaGEgPSBhbHBoYSk7XG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNmaWxsfSBpbnN0ZWFkXG4gICAqL1xuICBlbmRGaWxsKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNlbmRGaWxsIGlzIG5vIGxvbmdlciBuZWVkZWQuIFVzZSBHcmFwaGljcyNmaWxsIHRvIGZpbGwgdGhlIHNoYXBlIHdpdGggdGhlIGRlc2lyZWQgc3R5bGUuXCIpO1xuICAgIHRoaXMuY29udGV4dC5maWxsKCk7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKHN0cm9rZVN0eWxlLndpZHRoICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLndpZHRoIHx8IHN0cm9rZVN0eWxlLmNvbG9yICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLmNvbG9yIHx8IHN0cm9rZVN0eWxlLmFscGhhICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLmFscGhhKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2NpcmNsZX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd0NpcmNsZSguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdDaXJjbGUgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNjaXJjbGVcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2lyY2xlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2VsbGlwc2V9IGluc3RlYWRcbiAgICovXG4gIGRyYXdFbGxpcHNlKC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd0VsbGlwc2UgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNlbGxpcHNlXCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImVsbGlwc2VcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjcG9seX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1BvbHlnb24oLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3UG9seWdvbiBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI3BvbHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicG9seVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNyZWN0fSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3UmVjdCguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdSZWN0IGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3MjcmVjdFwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWN0XCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3JvdW5kUmVjdH0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1JvdW5kZWRSZWN0KC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd1JvdW5kZWRSZWN0IGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3Mjcm91bmRSZWN0XCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUmVjdFwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNzdGFyfSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3U3RhciguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdTdGFyIGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3Mjc3RhclwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdGFyXCIsIGFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCB7IEdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6475\n')},6653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  g: () => (/* binding */ GraphicsContext)\n});\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/parse-svg-path/index.js\nvar parse_svg_path = __webpack_require__(1379);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs\n\n\n\n"use strict";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse_svg_path(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case "M":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "m":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "H":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "h":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "V":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "v":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "L":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "l":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "C":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case "c":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case "S":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "s":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "Q":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "q":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "T":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "t":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "A":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "a":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "Z":\n      case "z":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        (0,warn/* warn */.Z)(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== "Z" && type !== "z") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\n\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Circle.mjs\n\n\n"use strict";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'circle\'\n     */\n    this.type = "circle";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs\n\n\n"use strict";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'ellipse\'\n     */\n    this.type = "ellipse";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle/* Rectangle */.A(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs\n\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\n\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs\n\n\n\n"use strict";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'polygon\'\n     */\n    this.type = "polygon";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    for (let i = 0; i < points.length; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs\n\n\n"use strict";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'roundedRectangle\'\n     */\n    this.type = "roundedRectangle";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs\n\n\n"use strict";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs\n\n\n"use strict";\nconst buildAdaptiveQuadratic_RECURSION_LIMIT = 8;\nconst buildAdaptiveQuadratic_FLT_EPSILON = 11920929e-14;\nconst buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON = 1;\nconst buildAdaptiveQuadratic_curveAngleToleranceEpsilon = 0.01;\nconst buildAdaptiveQuadratic_mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  buildAdaptiveQuadratic_recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction buildAdaptiveQuadratic_recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > buildAdaptiveQuadratic_RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > buildAdaptiveQuadratic_FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (buildAdaptiveQuadratic_mAngleTolerance < buildAdaptiveQuadratic_curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < buildAdaptiveQuadratic_mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  buildAdaptiveQuadratic_recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  buildAdaptiveQuadratic_recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs\n\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\n\n//# sourceMappingURL=buildArc.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs\n\n\n"use strict";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\n\n//# sourceMappingURL=buildArcTo.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs\n\n\n"use strict";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\n\n//# sourceMappingURL=buildArcToSvg.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\n\n//# sourceMappingURL=roundShape.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRectangle = new Rectangle/* Rectangle */.A();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle/* Rectangle */.A(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (!lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\n\n//# sourceMappingURL=ShapePath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = (0,uid/* uid */.h)("graphicsPath");\n    this._dirty = true;\n    if (typeof instructions === "string") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: "addPath", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: "arc", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: "arcTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: "arcToSvg", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: "bezierCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== "bezierCurveTo") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: "closePath", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: "ellipse", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: "lineTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: "moveTo", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: "quadraticCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== "quadraticCurveTo") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: "roundRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: "poly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: "regularPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: "roundPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: "roundShape", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: "filletRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: "chamferRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path\'s geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation\'s effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path\'s appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case "moveTo":\n        case "lineTo":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case "bezierCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case "quadraticCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case "arcToSvg":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case "circle":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case "rect":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case "ellipse":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case "roundRect":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case "addPath":\n          data[0].transform(matrix);\n          break;\n        case "poly":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          (0,warn/* warn */.Z)("unknown transform action", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path\'s current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point\'s position is accurately determined regardless of the path\'s complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point\'s coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point\'s coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === "closePath") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case "moveTo":\n      case "lineTo":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case "quadraticCurveTo":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case "bezierCurveTo":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case "arc":\n      case "arcToSvg":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case "addPath":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\n\n//# sourceMappingURL=GraphicsPath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs\n\n\n\n"use strict";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === "string") {\n    const div = document.createElement("div");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector("svg");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case "path":\n      d = svg.getAttribute("d");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "circle":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      r = parseFloatAttribute(svg, "r", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "rect":\n      x = parseFloatAttribute(svg, "x", 0);\n      y = parseFloatAttribute(svg, "y", 0);\n      width = parseFloatAttribute(svg, "width", 0);\n      height = parseFloatAttribute(svg, "height", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "ellipse":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "line":\n      x1 = parseFloatAttribute(svg, "x1", 0);\n      y1 = parseFloatAttribute(svg, "y1", 0);\n      x2 = parseFloatAttribute(svg, "x2", 0);\n      y2 = parseFloatAttribute(svg, "y2", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polygon":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polyline":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "g":\n    case "svg":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute("style");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(";");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(":");\n      switch (key) {\n        case "stroke":\n          if (value !== "none") {\n            strokeStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case "stroke-width":\n          strokeStyle.width = Number(value);\n          break;\n        case "fill":\n          if (value !== "none") {\n            useFill = true;\n            fillStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n          }\n          break;\n        case "fill-opacity":\n          fillStyle.alpha = Number(value);\n          break;\n        case "stroke-opacity":\n          strokeStyle.alpha = Number(value);\n          break;\n        case "opacity":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute("stroke");\n    if (stroke && stroke !== "none") {\n      useStroke = true;\n      strokeStyle.color = Color/* Color */.I.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);\n    }\n    const fill = svg.getAttribute("fill");\n    if (fill && fill !== "none") {\n      useFill = true;\n      fillStyle.color = Color/* Color */.I.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\n\n//# sourceMappingURL=SVGParser.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs\nvar convertFillInputToFillStyle = __webpack_require__(4915);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tmpPoint = new Point/* Point */.E();\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst _GraphicsContext = class _GraphicsContext extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    this.uid = (0,uid/* uid */.h)("graphicsContext");\n    this.dirty = true;\n    this.batchMode = "auto";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix/* Matrix */.y();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: "texture",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color/* Color */.I.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style) {\n      if (alpha !== void 0 && typeof style === "number") {\n        (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: "fill",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point/* Point */.E.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style) {\n      this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: "stroke",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The arc\'s radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc\'s radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === "moveTo") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit("update", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === "fill") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === "texture") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === "stroke") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it\'s contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === "fill") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: "butt",\n  /** The line join style to use. */\n  join: "miter",\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\n\n//# sourceMappingURL=GraphicsContext.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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STtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEI7OztBQ3hCMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsUUFBUTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdEI7OztBQzVDZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMscUJBQXFCO0FBQ3JCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanM/ZTg2YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvQ2lyY2xlLm1qcz9jZWU0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL3NoYXBlcy9FbGxpcHNlLm1qcz8wNTQwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2Mvc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanM/YzAzNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUG9seWdvbi5tanM/NjBkNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanM/ZTE0MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcz8yMGNhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQWRhcHRpdmVRdWFkcmF0aWMubWpzPzY5MzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzPzZjZjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmNUby5tanM/NTg4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvU3ZnLm1qcz9hZDllIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL3JvdW5kU2hhcGUubWpzPzY2ODIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvU2hhcGVQYXRoLm1qcz81NjMwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL0dyYXBoaWNzUGF0aC5tanM/MjlhOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvc3ZnL1NWR1BhcnNlci5tanM/MjRmNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0Lm1qcz83ZjA0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICdwYXJzZS1zdmctcGF0aCc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gU1ZHVG9HcmFwaGljc1BhdGgoc3ZnUGF0aCwgcGF0aCkge1xuICBjb25zdCBjb21tYW5kcyA9IHBhcnNlKHN2Z1BhdGgpO1xuICBjb25zdCBzdWJwYXRocyA9IFtdO1xuICBsZXQgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICBsZXQgbGFzdFggPSAwO1xuICBsZXQgbGFzdFkgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSBjb21tYW5kWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBjb21tYW5kO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgbGFzdFggPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSA9IGRhdGFbMl07XG4gICAgICAgIHBhdGgubW92ZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVsxXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5tb3ZlVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVlwiOlxuICAgICAgICBsYXN0WSA9IGRhdGFbMV07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgbGFzdFkgKz0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVs1XTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzZdO1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF0sXG4gICAgICAgICAgbGFzdFggKyBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RZICsgZGF0YVs2XVxuICAgICAgICApO1xuICAgICAgICBsYXN0WCArPSBkYXRhWzVdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzZdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzRdO1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG9TaG9ydChcbiAgICAgICAgICBkYXRhWzFdLFxuICAgICAgICAgIGRhdGFbMl0sXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICBwYXRoLmJlemllckN1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF1cbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFggKz0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUVwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbM107XG4gICAgICAgIGxhc3RZID0gZGF0YVs0XTtcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF1cbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFggKz0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvU2hvcnQoXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVs2XTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzddO1xuICAgICAgICBwYXRoLmFyY1RvU3ZnKFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBkYXRhWzNdLFxuICAgICAgICAgIGRhdGFbNF0sXG4gICAgICAgICAgZGF0YVs1XSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIGxhc3RYICs9IGRhdGFbNl07XG4gICAgICAgIGxhc3RZICs9IGRhdGFbN107XG4gICAgICAgIHBhdGguYXJjVG9TdmcoXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlpcIjpcbiAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChzdWJwYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudFN1YlBhdGggPSBzdWJwYXRocy5wb3AoKTtcbiAgICAgICAgICBpZiAoY3VycmVudFN1YlBhdGgpIHtcbiAgICAgICAgICAgIGxhc3RYID0gY3VycmVudFN1YlBhdGguc3RhcnRYO1xuICAgICAgICAgICAgbGFzdFkgPSBjdXJyZW50U3ViUGF0aC5zdGFydFk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RYID0gMDtcbiAgICAgICAgICAgIGxhc3RZID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYFVua25vd24gU1ZHIHBhdGggY29tbWFuZDogJHt0eXBlfWApO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gXCJaXCIgJiYgdHlwZSAhPT0gXCJ6XCIpIHtcbiAgICAgIGlmIChjdXJyZW50U3ViUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50U3ViUGF0aCA9IHsgc3RhcnRYOiBsYXN0WCwgc3RhcnRZOiBsYXN0WSB9O1xuICAgICAgICBzdWJwYXRocy5wdXNoKGN1cnJlbnRTdWJQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCB7IFNWR1RvR3JhcGhpY3NQYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TVkdUb0dyYXBoaWNzUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENpcmNsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHJhZGl1cyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICogQGRlZmF1bHQgJ2NpcmNsZSdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcImNpcmNsZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGUgQ2lyY2xlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIGxldCBkeCA9IHRoaXMueCAtIHg7XG4gICAgbGV0IGR5ID0gdGhpcy55IC0geTtcbiAgICBkeCAqPSBkeDtcbiAgICBkeSAqPSBkeTtcbiAgICByZXR1cm4gZHggKyBkeSA8PSByMjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGUgaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBzdHJva2VDb250YWlucyh4LCB5LCB3aWR0aCkge1xuICAgIGlmICh0aGlzLnJhZGl1cyA9PT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkeCA9IHRoaXMueCAtIHg7XG4gICAgY29uc3QgZHkgPSB0aGlzLnkgLSB5O1xuICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCB3MiA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgcmV0dXJuIGRpc3RhbmNlIDwgciArIHcyICYmIGRpc3RhbmNlID4gciAtIHcyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcGFyYW0gb3V0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgb3V0LnggPSB0aGlzLnggLSB0aGlzLnJhZGl1cztcbiAgICBvdXQueSA9IHRoaXMueSAtIHRoaXMucmFkaXVzO1xuICAgIG91dC53aWR0aCA9IHRoaXMucmFkaXVzICogMjtcbiAgICBvdXQuaGVpZ2h0ID0gdGhpcy5yYWRpdXMgKiAyO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIGNpcmNsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIGNpcmNsZSAtIFRoZSBjaXJjbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKGNpcmNsZSkge1xuICAgIHRoaXMueCA9IGNpcmNsZS54O1xuICAgIHRoaXMueSA9IGNpcmNsZS55O1xuICAgIHRoaXMucmFkaXVzID0gY2lyY2xlLnJhZGl1cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgY2lyY2xlIHRvIGFub3RoZXIgb25lLlxuICAgKiBAcGFyYW0gY2lyY2xlIC0gVGhlIGNpcmNsZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhjaXJjbGUpIHtcbiAgICBjaXJjbGUuY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6Q2lyY2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHJhZGl1cz0ke3RoaXMucmFkaXVzfV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IENpcmNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4vUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRWxsaXBzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSBoYWxmV2lkdGggLSBUaGUgaGFsZiB3aWR0aCBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIGhhbGZIZWlnaHQgLSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhpcyBlbGxpcHNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIGhhbGZXaWR0aCA9IDAsIGhhbGZIZWlnaHQgPSAwKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqIEBkZWZhdWx0ICdlbGxpcHNlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwiZWxsaXBzZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGhhbGZXaWR0aDtcbiAgICB0aGlzLmhhbGZIZWlnaHQgPSBoYWxmSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtFbGxpcHNlfSBBIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy5oYWxmV2lkdGgsIHRoaXMuaGFsZkhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5oYWxmV2lkdGggPD0gMCB8fCB0aGlzLmhhbGZIZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLmhhbGZXaWR0aDtcbiAgICBsZXQgbm9ybXkgPSAoeSAtIHRoaXMueSkgLyB0aGlzLmhhbGZIZWlnaHQ7XG4gICAgbm9ybXggKj0gbm9ybXg7XG4gICAgbm9ybXkgKj0gbm9ybXk7XG4gICAgcmV0dXJuIG5vcm14ICsgbm9ybXkgPD0gMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlIGluY2x1ZGluZyBzdHJva2VcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgd2lkdGgpIHtcbiAgICBjb25zdCB7IGhhbGZXaWR0aCwgaGFsZkhlaWdodCB9ID0gdGhpcztcbiAgICBpZiAoaGFsZldpZHRoIDw9IDAgfHwgaGFsZkhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lckEgPSBoYWxmV2lkdGggLSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgaW5uZXJCID0gaGFsZkhlaWdodCAtIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBvdXRlckEgPSBoYWxmV2lkdGggKyBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgY29uc3Qgb3V0ZXJCID0gaGFsZkhlaWdodCArIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBub3JtYWxpemVkWCA9IHggLSB0aGlzLng7XG4gICAgY29uc3Qgbm9ybWFsaXplZFkgPSB5IC0gdGhpcy55O1xuICAgIGNvbnN0IGlubmVyRWxsaXBzZSA9IG5vcm1hbGl6ZWRYICogbm9ybWFsaXplZFggLyAoaW5uZXJBICogaW5uZXJBKSArIG5vcm1hbGl6ZWRZICogbm9ybWFsaXplZFkgLyAoaW5uZXJCICogaW5uZXJCKTtcbiAgICBjb25zdCBvdXRlckVsbGlwc2UgPSBub3JtYWxpemVkWCAqIG5vcm1hbGl6ZWRYIC8gKG91dGVyQSAqIG91dGVyQSkgKyBub3JtYWxpemVkWSAqIG5vcm1hbGl6ZWRZIC8gKG91dGVyQiAqIG91dGVyQik7XG4gICAgcmV0dXJuIGlubmVyRWxsaXBzZSA+IDEgJiYgb3V0ZXJFbGxpcHNlIDw9IDE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLmhhbGZXaWR0aCwgdGhpcy55IC0gdGhpcy5oYWxmSGVpZ2h0LCB0aGlzLmhhbGZXaWR0aCAqIDIsIHRoaXMuaGFsZkhlaWdodCAqIDIpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciBlbGxpcHNlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gZWxsaXBzZSAtIFRoZSBlbGxpcHNlIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbShlbGxpcHNlKSB7XG4gICAgdGhpcy54ID0gZWxsaXBzZS54O1xuICAgIHRoaXMueSA9IGVsbGlwc2UueTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgIHRoaXMuaGFsZkhlaWdodCA9IGVsbGlwc2UuaGFsZkhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgZWxsaXBzZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIGVsbGlwc2UgLSBUaGUgZWxsaXBzZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhlbGxpcHNlKSB7XG4gICAgZWxsaXBzZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gZWxsaXBzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6RWxsaXBzZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSBoYWxmV2lkdGg9JHt0aGlzLmhhbGZXaWR0aH0gaGFsZkhlaWdodD0ke3RoaXMuaGFsZkhlaWdodH1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBFbGxpcHNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBhID0geCAtIHgxO1xuICBjb25zdCBiID0geSAtIHkxO1xuICBjb25zdCBjID0geDIgLSB4MTtcbiAgY29uc3QgZCA9IHkyIC0geTE7XG4gIGNvbnN0IGRvdCA9IGEgKiBjICsgYiAqIGQ7XG4gIGNvbnN0IGxlblNxID0gYyAqIGMgKyBkICogZDtcbiAgbGV0IHBhcmFtID0gLTE7XG4gIGlmIChsZW5TcSAhPT0gMCkge1xuICAgIHBhcmFtID0gZG90IC8gbGVuU3E7XG4gIH1cbiAgbGV0IHh4O1xuICBsZXQgeXk7XG4gIGlmIChwYXJhbSA8IDApIHtcbiAgICB4eCA9IHgxO1xuICAgIHl5ID0geTE7XG4gIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgeHggPSB4MjtcbiAgICB5eSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHh4ID0geDEgKyBwYXJhbSAqIGM7XG4gICAgeXkgPSB5MSArIHBhcmFtICogZDtcbiAgfVxuICBjb25zdCBkeCA9IHggLSB4eDtcbiAgY29uc3QgZHkgPSB5IC0geXk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZXhwb3J0IHsgc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi4vbWlzYy9zcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvbHlnb24ge1xuICAvKipcbiAgICogQHBhcmFtIHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgKiAgdGhhdCBmb3JtIHRoZSBwb2x5Z29uLCBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvclxuICAgKiAgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy5cbiAgICogIGBuZXcgUG9seWdvbihuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgKiAgeCx5IHZhbHVlcyBlLmcuIGBuZXcgUG9seWdvbih4LHksIHgseSwgeCx5LCAuLi4pYCB3aGVyZSBgeGAgYW5kIGB5YCBhcmUgTnVtYmVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncG9seWdvbidcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInBvbHlnb25cIjtcbiAgICBsZXQgZmxhdCA9IEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSA/IHBvaW50c1swXSA6IHBvaW50cztcbiAgICBpZiAodHlwZW9mIGZsYXRbMF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGZsYXQubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwLnB1c2goZmxhdFtpXS54LCBmbGF0W2ldLnkpO1xuICAgICAgfVxuICAgICAgZmxhdCA9IHA7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzID0gZmxhdDtcbiAgICB0aGlzLmNsb3NlUGF0aCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKTtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICBwb2x5Z29uLmNsb3NlUGF0aCA9IHRoaXMuY2xvc2VQYXRoO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvbi5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIGNvbnN0IHhpID0gdGhpcy5wb2ludHNbaSAqIDJdO1xuICAgICAgY29uc3QgeWkgPSB0aGlzLnBvaW50c1tpICogMiArIDFdO1xuICAgICAgY29uc3QgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICBjb25zdCB5aiA9IHRoaXMucG9pbnRzW2ogKiAyICsgMV07XG4gICAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKCh5IC0geWkpIC8gKHlqIC0geWkpKSArIHhpO1xuICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24gaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHN0cm9rZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaGFsZlN0cm9rZVdpZHRoU3FyZCA9IGhhbGZTdHJva2VXaWR0aCAqIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCB7IHBvaW50cyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeDEgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCB5MSA9IHBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCB4MiA9IHBvaW50c1soaSArIDIpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgICBjb25zdCB5MiA9IHBvaW50c1soaSArIDMpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgICBjb25zdCBkaXN0YW5jZVNxcmQgPSBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIGlmIChkaXN0YW5jZVNxcmQgPD0gaGFsZlN0cm9rZVdpZHRoU3FyZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcG9seWdvbiBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHBhcmFtIG91dCAtIG9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgfVxuICAgIG91dC54ID0gbWluWDtcbiAgICBvdXQud2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICBvdXQueSA9IG1pblk7XG4gICAgb3V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHBvbHlnb24gdG8gdGhpcyBvbmUuXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHBvbHlnb24gdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHBvbHlnb24pIHtcbiAgICB0aGlzLnBvaW50cyA9IHBvbHlnb24ucG9pbnRzLnNsaWNlKCk7XG4gICAgdGhpcy5jbG9zZVBhdGggPSBwb2x5Z29uLmNsb3NlUGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9seWdvbiB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUgcG9seWdvbiB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhwb2x5Z29uKSB7XG4gICAgcG9seWdvbi5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6UG9seWdvbmNsb3NlU3Ryb2tlPSR7dGhpcy5jbG9zZVBhdGh9cG9pbnRzPSR7dGhpcy5wb2ludHMucmVkdWNlKChwb2ludHNEZXNjLCBjdXJyZW50UG9pbnQpID0+IGAke3BvaW50c0Rlc2N9LCAke2N1cnJlbnRQb2ludH1gLCBcIlwiKX1dYDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvblxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMl07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdFkoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvblxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAyXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9seWdvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9seWdvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGlzQ29ybmVyV2l0aGluU3Ryb2tlID0gKHBYLCBwWSwgY29ybmVyWCwgY29ybmVyWSwgcmFkaXVzLCBoYWxmU3Ryb2tlV2lkdGgpID0+IHtcbiAgY29uc3QgZHggPSBwWCAtIGNvcm5lclg7XG4gIGNvbnN0IGR5ID0gcFkgLSBjb3JuZXJZO1xuICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHJldHVybiBkaXN0YW5jZSA+PSByYWRpdXMgLSBoYWxmU3Ryb2tlV2lkdGggJiYgZGlzdGFuY2UgPD0gcmFkaXVzICsgaGFsZlN0cm9rZVdpZHRoO1xufTtcbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICAvKipcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIENvbnRyb2xzIHRoZSByYWRpdXMgb2YgdGhlIHJvdW5kZWQgY29ybmVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAsIHJhZGl1cyA9IDIwKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqIEBkZWZhdWx0ICdyb3VuZGVkUmVjdGFuZ2xlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwicm91bmRlZFJlY3RhbmdsZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHBhcmFtIG91dCAtIG9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgb3V0LnggPSB0aGlzLng7XG4gICAgb3V0LnkgPSB0aGlzLnk7XG4gICAgb3V0LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBvdXQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUm91bmRlZCBSZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGFub3RoZXIgcmVjdGFuZ2xlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IGZyb20uXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgY29weUZyb20ocmVjdGFuZ2xlKSB7XG4gICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHJlY3RhbmdsZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSB0by5cbiAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb3B5VG8ocmVjdGFuZ2xlKSB7XG4gICAgcmVjdGFuZ2xlLmNvcHlGcm9tKHRoaXMpO1xuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZS5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5yYWRpdXMsIE1hdGgubWluKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDIpKTtcbiAgICAgICAgaWYgKHkgPj0gdGhpcy55ICsgcmFkaXVzICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMgfHwgeCA+PSB0aGlzLnggKyByYWRpdXMgJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBsZXQgZHkgPSB5IC0gKHRoaXMueSArIHJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHJhZGl1czIgPSByYWRpdXMgKiByYWRpdXM7XG4gICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHRoaXMud2lkdGggLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHJhZGl1cyk7XG4gICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZSBpbmNsdWRpbmcgdGhlIHN0cm9rZS5cbiAgICogQHBhcmFtIHBYIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gcFkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSBzdHJva2VXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHJlY3RhbmdsZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMocFgsIHBZLCBzdHJva2VXaWR0aCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lclggPSB4ICsgcmFkaXVzO1xuICAgIGNvbnN0IGlubmVyWSA9IHkgKyByYWRpdXM7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IHdpZHRoIC0gcmFkaXVzICogMjtcbiAgICBjb25zdCBpbm5lckhlaWdodCA9IGhlaWdodCAtIHJhZGl1cyAqIDI7XG4gICAgY29uc3QgcmlnaHRCb3VuZCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b21Cb3VuZCA9IHkgKyBoZWlnaHQ7XG4gICAgaWYgKChwWCA+PSB4IC0gaGFsZlN0cm9rZVdpZHRoICYmIHBYIDw9IHggKyBoYWxmU3Ryb2tlV2lkdGggfHwgcFggPj0gcmlnaHRCb3VuZCAtIGhhbGZTdHJva2VXaWR0aCAmJiBwWCA8PSByaWdodEJvdW5kICsgaGFsZlN0cm9rZVdpZHRoKSAmJiBwWSA+PSBpbm5lclkgJiYgcFkgPD0gaW5uZXJZICsgaW5uZXJIZWlnaHQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHBZID49IHkgLSBoYWxmU3Ryb2tlV2lkdGggJiYgcFkgPD0geSArIGhhbGZTdHJva2VXaWR0aCB8fCBwWSA+PSBib3R0b21Cb3VuZCAtIGhhbGZTdHJva2VXaWR0aCAmJiBwWSA8PSBib3R0b21Cb3VuZCArIGhhbGZTdHJva2VXaWR0aCkgJiYgcFggPj0gaW5uZXJYICYmIHBYIDw9IGlubmVyWCArIGlubmVyV2lkdGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gVG9wLWxlZnRcbiAgICAgIHBYIDwgaW5uZXJYICYmIHBZIDwgaW5uZXJZICYmIGlzQ29ybmVyV2l0aGluU3Ryb2tlKHBYLCBwWSwgaW5uZXJYLCBpbm5lclksIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKSB8fCBwWCA+IHJpZ2h0Qm91bmQgLSByYWRpdXMgJiYgcFkgPCBpbm5lclkgJiYgaXNDb3JuZXJXaXRoaW5TdHJva2UocFgsIHBZLCByaWdodEJvdW5kIC0gcmFkaXVzLCBpbm5lclksIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKSB8fCBwWCA+IHJpZ2h0Qm91bmQgLSByYWRpdXMgJiYgcFkgPiBib3R0b21Cb3VuZCAtIHJhZGl1cyAmJiBpc0Nvcm5lcldpdGhpblN0cm9rZShwWCwgcFksIHJpZ2h0Qm91bmQgLSByYWRpdXMsIGJvdHRvbUJvdW5kIC0gcmFkaXVzLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aCkgfHwgcFggPCBpbm5lclggJiYgcFkgPiBib3R0b21Cb3VuZCAtIHJhZGl1cyAmJiBpc0Nvcm5lcldpdGhpblN0cm9rZShwWCwgcFksIGlubmVyWCwgYm90dG9tQm91bmQgLSByYWRpdXMsIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKVxuICAgICk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qcy9tYXRoOlJvdW5kZWRSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX13aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3VuZGVkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IEdyYXBoaWNzQ29udGV4dFN5c3RlbSB9IGZyb20gJy4uL0dyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDg7XG5jb25zdCBGTFRfRVBTSUxPTiA9IDExOTIwOTI5ZS0xNDtcbmNvbnN0IFBBVEhfRElTVEFOQ0VfRVBTSUxPTiA9IDE7XG5jb25zdCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbiA9IDAuMDE7XG5jb25zdCBtQW5nbGVUb2xlcmFuY2UgPSAwO1xuY29uc3QgbUN1c3BMaW1pdCA9IDA7XG5mdW5jdGlvbiBidWlsZEFkYXB0aXZlQmV6aWVyKHBvaW50cywgc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHNtb290aG5lc3MpIHtcbiAgY29uc3Qgc2NhbGUgPSAxO1xuICBjb25zdCBzbW9vdGhpbmcgPSBNYXRoLm1pbihcbiAgICAwLjk5LFxuICAgIC8vIGEgdmFsdWUgb2YgMS4wIGFjdHVhbGx5IGludmVydHMgc21vb3RoaW5nLCBzbyB3ZSBjYXAgaXQgYXQgMC45OVxuICAgIE1hdGgubWF4KDAsIHNtb290aG5lc3MgPz8gR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MpXG4gICk7XG4gIGxldCBkaXN0YW5jZVRvbGVyYW5jZSA9IChQQVRIX0RJU1RBTkNFX0VQU0lMT04gLSBzbW9vdGhpbmcpIC8gc2NhbGU7XG4gIGRpc3RhbmNlVG9sZXJhbmNlICo9IGRpc3RhbmNlVG9sZXJhbmNlO1xuICBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICByZWN1cnNpdmUoc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIDApO1xuICBwb2ludHMucHVzaChlWCwgZVkpO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBpID0gTWF0aC5QSTtcbiAgY29uc3QgeDEyID0gKHgxICsgeDIpIC8gMjtcbiAgY29uc3QgeTEyID0gKHkxICsgeTIpIC8gMjtcbiAgY29uc3QgeDIzID0gKHgyICsgeDMpIC8gMjtcbiAgY29uc3QgeTIzID0gKHkyICsgeTMpIC8gMjtcbiAgY29uc3QgeDM0ID0gKHgzICsgeDQpIC8gMjtcbiAgY29uc3QgeTM0ID0gKHkzICsgeTQpIC8gMjtcbiAgY29uc3QgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMjtcbiAgY29uc3QgeTEyMyA9ICh5MTIgKyB5MjMpIC8gMjtcbiAgY29uc3QgeDIzNCA9ICh4MjMgKyB4MzQpIC8gMjtcbiAgY29uc3QgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMjtcbiAgY29uc3QgeDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMjtcbiAgY29uc3QgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMjtcbiAgaWYgKGxldmVsID4gMCkge1xuICAgIGxldCBkeCA9IHg0IC0geDE7XG4gICAgbGV0IGR5ID0geTQgLSB5MTtcbiAgICBjb25zdCBkMiA9IE1hdGguYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpO1xuICAgIGNvbnN0IGQzID0gTWF0aC5hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeCk7XG4gICAgbGV0IGRhMTtcbiAgICBsZXQgZGEyO1xuICAgIGlmIChkMiA+IEZMVF9FUFNJTE9OICYmIGQzID4gRkxUX0VQU0lMT04pIHtcbiAgICAgIGlmICgoZDIgKyBkMykgKiAoZDIgKyBkMykgPD0gZGlzdGFuY2VUb2xlcmFuY2UgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgICAgIGlmIChtQW5nbGVUb2xlcmFuY2UgPCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbikge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGEyMyA9IE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4Mik7XG4gICAgICAgIGRhMSA9IE1hdGguYWJzKGEyMyAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpO1xuICAgICAgICBkYTIgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gYTIzKTtcbiAgICAgICAgaWYgKGRhMSA+PSBwaSlcbiAgICAgICAgICBkYTEgPSAyICogcGkgLSBkYTE7XG4gICAgICAgIGlmIChkYTIgPj0gcGkpXG4gICAgICAgICAgZGEyID0gMiAqIHBpIC0gZGEyO1xuICAgICAgICBpZiAoZGExICsgZGEyIDwgbUFuZ2xlVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDEyMzQsIHkxMjM0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1DdXNwTGltaXQgIT09IDApIHtcbiAgICAgICAgICBpZiAoZGExID4gbUN1c3BMaW1pdCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDIsIHkyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhMiA+IG1DdXNwTGltaXQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgzLCB5Myk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkMiA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICBpZiAoZDIgKiBkMiA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICAgICAgaWYgKG1BbmdsZVRvbGVyYW5jZSA8IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDEyMzQsIHkxMjM0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpO1xuICAgICAgICBpZiAoZGExID49IHBpKVxuICAgICAgICAgIGRhMSA9IDIgKiBwaSAtIGRhMTtcbiAgICAgICAgaWYgKGRhMSA8IG1BbmdsZVRvbGVyYW5jZSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDMsIHkzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1DdXNwTGltaXQgIT09IDApIHtcbiAgICAgICAgICBpZiAoZGExID4gbUN1c3BMaW1pdCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDIsIHkyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGQzID4gRkxUX0VQU0lMT04pIHtcbiAgICAgIGlmIChkMyAqIGQzIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgICAgICBpZiAobUFuZ2xlVG9sZXJhbmNlIDwgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24pIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MTIzNCwgeTEyMzQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYTEgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSk7XG4gICAgICAgIGlmIChkYTEgPj0gcGkpXG4gICAgICAgICAgZGExID0gMiAqIHBpIC0gZGExO1xuICAgICAgICBpZiAoZGExIDwgbUFuZ2xlVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDIsIHkyKTtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MywgeTMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobUN1c3BMaW1pdCAhPT0gMCkge1xuICAgICAgICAgIGlmIChkYTEgPiBtQ3VzcExpbWl0KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4MywgeTMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkeCA9IHgxMjM0IC0gKHgxICsgeDQpIC8gMjtcbiAgICAgIGR5ID0geTEyMzQgLSAoeTEgKyB5NCkgLyAyO1xuICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IGRpc3RhbmNlVG9sZXJhbmNlKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVjdXJzaXZlKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbiAgcmVjdXJzaXZlKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRBZGFwdGl2ZUJlemllciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBZGFwdGl2ZUJlemllci5tanMubWFwXG4iLCJpbXBvcnQgeyBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuLi9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSA4O1xuY29uc3QgRkxUX0VQU0lMT04gPSAxMTkyMDkyOWUtMTQ7XG5jb25zdCBQQVRIX0RJU1RBTkNFX0VQU0lMT04gPSAxO1xuY29uc3QgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24gPSAwLjAxO1xuY29uc3QgbUFuZ2xlVG9sZXJhbmNlID0gMDtcbmZ1bmN0aW9uIGJ1aWxkQWRhcHRpdmVRdWFkcmF0aWMocG9pbnRzLCBzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgc21vb3RobmVzcykge1xuICBjb25zdCBzY2FsZSA9IDE7XG4gIGNvbnN0IHNtb290aGluZyA9IE1hdGgubWluKFxuICAgIDAuOTksXG4gICAgLy8gYSB2YWx1ZSBvZiAxLjAgYWN0dWFsbHkgaW52ZXJ0cyBzbW9vdGhpbmcsIHNvIHdlIGNhcCBpdCBhdCAwLjk5XG4gICAgTWF0aC5tYXgoMCwgc21vb3RobmVzcyA/PyBHcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuYmV6aWVyU21vb3RobmVzcylcbiAgKTtcbiAgbGV0IGRpc3RhbmNlVG9sZXJhbmNlID0gKFBBVEhfRElTVEFOQ0VfRVBTSUxPTiAtIHNtb290aGluZykgLyBzY2FsZTtcbiAgZGlzdGFuY2VUb2xlcmFuY2UgKj0gZGlzdGFuY2VUb2xlcmFuY2U7XG4gIGJlZ2luKHNYLCBzWSwgY3AxeCwgY3AxeSwgZVgsIGVZLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIGJlZ2luKHNYLCBzWSwgY3AxeCwgY3AxeSwgZVgsIGVZLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlKSB7XG4gIHJlY3Vyc2l2ZShwb2ludHMsIHNYLCBzWSwgY3AxeCwgY3AxeSwgZVgsIGVZLCBkaXN0YW5jZVRvbGVyYW5jZSwgMCk7XG4gIHBvaW50cy5wdXNoKGVYLCBlWSk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmUocG9pbnRzLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBpID0gTWF0aC5QSTtcbiAgY29uc3QgeDEyID0gKHgxICsgeDIpIC8gMjtcbiAgY29uc3QgeTEyID0gKHkxICsgeTIpIC8gMjtcbiAgY29uc3QgeDIzID0gKHgyICsgeDMpIC8gMjtcbiAgY29uc3QgeTIzID0gKHkyICsgeTMpIC8gMjtcbiAgY29uc3QgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMjtcbiAgY29uc3QgeTEyMyA9ICh5MTIgKyB5MjMpIC8gMjtcbiAgbGV0IGR4ID0geDMgLSB4MTtcbiAgbGV0IGR5ID0geTMgLSB5MTtcbiAgY29uc3QgZCA9IE1hdGguYWJzKCh4MiAtIHgzKSAqIGR5IC0gKHkyIC0geTMpICogZHgpO1xuICBpZiAoZCA+IEZMVF9FUFNJTE9OKSB7XG4gICAgaWYgKGQgKiBkIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgICAgaWYgKG1BbmdsZVRvbGVyYW5jZSA8IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxMjMsIHkxMjMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGEgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHkzIC0geTIsIHgzIC0geDIpIC0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSk7XG4gICAgICBpZiAoZGEgPj0gcGkpXG4gICAgICAgIGRhID0gMiAqIHBpIC0gZGE7XG4gICAgICBpZiAoZGEgPCBtQW5nbGVUb2xlcmFuY2UpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goeDEyMywgeTEyMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZHggPSB4MTIzIC0gKHgxICsgeDMpIC8gMjtcbiAgICBkeSA9IHkxMjMgLSAoeTEgKyB5MykgLyAyO1xuICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICAgICAgcG9pbnRzLnB1c2goeDEyMywgeTEyMyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlY3Vyc2l2ZShwb2ludHMsIHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIGRpc3RhbmNlVG9sZXJhbmNlLCBsZXZlbCArIDEpO1xuICByZWN1cnNpdmUocG9pbnRzLCB4MTIzLCB5MTIzLCB4MjMsIHkyMywgeDMsIHkzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBZGFwdGl2ZVF1YWRyYXRpYy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGJ1aWxkQXJjKHBvaW50cywgeCwgeSwgcmFkaXVzLCBzdGFydCwgZW5kLCBjbG9ja3dpc2UsIHN0ZXBzKSB7XG4gIGxldCBkaXN0ID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICBpZiAoIWNsb2Nrd2lzZSAmJiBzdGFydCA+IGVuZCkge1xuICAgIGRpc3QgPSAyICogTWF0aC5QSSAtIGRpc3Q7XG4gIH0gZWxzZSBpZiAoY2xvY2t3aXNlICYmIGVuZCA+IHN0YXJ0KSB7XG4gICAgZGlzdCA9IDIgKiBNYXRoLlBJIC0gZGlzdDtcbiAgfVxuICBzdGVwcyA9IHN0ZXBzIHx8IE1hdGgubWF4KDYsIE1hdGguZmxvb3IoNiAqIE1hdGgucG93KHJhZGl1cywgMSAvIDMpICogKGRpc3QgLyBNYXRoLlBJKSkpO1xuICBzdGVwcyA9IE1hdGgubWF4KHN0ZXBzLCAzKTtcbiAgbGV0IGYgPSBkaXN0IC8gc3RlcHM7XG4gIGxldCB0ID0gc3RhcnQ7XG4gIGYgKj0gY2xvY2t3aXNlID8gLTEgOiAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzICsgMTsgaSsrKSB7XG4gICAgY29uc3QgY3MgPSBNYXRoLmNvcyh0KTtcbiAgICBjb25zdCBzbiA9IE1hdGguc2luKHQpO1xuICAgIGNvbnN0IG54ID0geCArIGNzICogcmFkaXVzO1xuICAgIGNvbnN0IG55ID0geSArIHNuICogcmFkaXVzO1xuICAgIHBvaW50cy5wdXNoKG54LCBueSk7XG4gICAgdCArPSBmO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkQXJjIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEFyYy5tanMubWFwXG4iLCJpbXBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4vYnVpbGRBcmMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBidWlsZEFyY1RvKHBvaW50cywgeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgY29uc3QgYTEgPSBmcm9tWSAtIHkxO1xuICBjb25zdCBiMSA9IGZyb21YIC0geDE7XG4gIGNvbnN0IGEyID0geTIgLSB5MTtcbiAgY29uc3QgYjIgPSB4MiAtIHgxO1xuICBjb25zdCBtbSA9IE1hdGguYWJzKGExICogYjIgLSBiMSAqIGEyKTtcbiAgaWYgKG1tIDwgMWUtOCB8fCByYWRpdXMgPT09IDApIHtcbiAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0geTEpIHtcbiAgICAgIHBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZCA9IGExICogYTEgKyBiMSAqIGIxO1xuICBjb25zdCBjYyA9IGEyICogYTIgKyBiMiAqIGIyO1xuICBjb25zdCB0dCA9IGExICogYTIgKyBiMSAqIGIyO1xuICBjb25zdCBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgY29uc3QgazIgPSByYWRpdXMgKiBNYXRoLnNxcnQoY2MpIC8gbW07XG4gIGNvbnN0IGoxID0gazEgKiB0dCAvIGRkO1xuICBjb25zdCBqMiA9IGsyICogdHQgLyBjYztcbiAgY29uc3QgY3ggPSBrMSAqIGIyICsgazIgKiBiMTtcbiAgY29uc3QgY3kgPSBrMSAqIGEyICsgazIgKiBhMTtcbiAgY29uc3QgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgY29uc3QgcHkgPSBhMSAqIChrMiArIGoxKTtcbiAgY29uc3QgcXggPSBiMiAqIChrMSArIGoyKTtcbiAgY29uc3QgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XG4gIGNvbnN0IGVuZEFuZ2xlID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcbiAgYnVpbGRBcmMoXG4gICAgcG9pbnRzLFxuICAgIGN4ICsgeDEsXG4gICAgY3kgKyB5MSxcbiAgICByYWRpdXMsXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSxcbiAgICBiMSAqIGEyID4gYjIgKiBhMVxuICApO1xufVxuXG5leHBvcnQgeyBidWlsZEFyY1RvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEFyY1RvLm1qcy5tYXBcbiIsImltcG9ydCB7IGJ1aWxkQWRhcHRpdmVCZXppZXIgfSBmcm9tICcuL2J1aWxkQWRhcHRpdmVCZXppZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBUQVUgPSBNYXRoLlBJICogMjtcbmNvbnN0IG91dCA9IHtcbiAgY2VudGVyWDogMCxcbiAgY2VudGVyWTogMCxcbiAgYW5nMTogMCxcbiAgYW5nMjogMFxufTtcbmNvbnN0IG1hcFRvRWxsaXBzZSA9ICh7IHgsIHkgfSwgcngsIHJ5LCBjb3NQaGksIHNpblBoaSwgY2VudGVyWCwgY2VudGVyWSwgb3V0MikgPT4ge1xuICB4ICo9IHJ4O1xuICB5ICo9IHJ5O1xuICBjb25zdCB4cCA9IGNvc1BoaSAqIHggLSBzaW5QaGkgKiB5O1xuICBjb25zdCB5cCA9IHNpblBoaSAqIHggKyBjb3NQaGkgKiB5O1xuICBvdXQyLnggPSB4cCArIGNlbnRlclg7XG4gIG91dDIueSA9IHlwICsgY2VudGVyWTtcbiAgcmV0dXJuIG91dDI7XG59O1xuZnVuY3Rpb24gYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKSB7XG4gIGNvbnN0IGExID0gYW5nMiA9PT0gLTEuNTcwNzk2MzI2Nzk0ODk2NiA/IC0wLjU1MTkxNTAyNDQ5NCA6IDQgLyAzICogTWF0aC50YW4oYW5nMiAvIDQpO1xuICBjb25zdCBhID0gYW5nMiA9PT0gMS41NzA3OTYzMjY3OTQ4OTY2ID8gMC41NTE5MTUwMjQ0OTQgOiBhMTtcbiAgY29uc3QgeDEgPSBNYXRoLmNvcyhhbmcxKTtcbiAgY29uc3QgeTEgPSBNYXRoLnNpbihhbmcxKTtcbiAgY29uc3QgeDIgPSBNYXRoLmNvcyhhbmcxICsgYW5nMik7XG4gIGNvbnN0IHkyID0gTWF0aC5zaW4oYW5nMSArIGFuZzIpO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHg6IHgxIC0geTEgKiBhLFxuICAgICAgeTogeTEgKyB4MSAqIGFcbiAgICB9LFxuICAgIHtcbiAgICAgIHg6IHgyICsgeTIgKiBhLFxuICAgICAgeTogeTIgLSB4MiAqIGFcbiAgICB9LFxuICAgIHtcbiAgICAgIHg6IHgyLFxuICAgICAgeTogeTJcbiAgICB9XG4gIF07XG59XG5jb25zdCB2ZWN0b3JBbmdsZSA9ICh1eCwgdXksIHZ4LCB2eSkgPT4ge1xuICBjb25zdCBzaWduID0gdXggKiB2eSAtIHV5ICogdnggPCAwID8gLTEgOiAxO1xuICBsZXQgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XG4gIGlmIChkb3QgPiAxKSB7XG4gICAgZG90ID0gMTtcbiAgfVxuICBpZiAoZG90IDwgLTEpIHtcbiAgICBkb3QgPSAtMTtcbiAgfVxuICByZXR1cm4gc2lnbiAqIE1hdGguYWNvcyhkb3QpO1xufTtcbmNvbnN0IGdldEFyY0NlbnRlciA9IChweCwgcHksIGN4LCBjeSwgcngsIHJ5LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgc2luUGhpLCBjb3NQaGksIHB4cCwgcHlwLCBvdXQyKSA9PiB7XG4gIGNvbnN0IHJ4U3EgPSBNYXRoLnBvdyhyeCwgMik7XG4gIGNvbnN0IHJ5U3EgPSBNYXRoLnBvdyhyeSwgMik7XG4gIGNvbnN0IHB4cFNxID0gTWF0aC5wb3cocHhwLCAyKTtcbiAgY29uc3QgcHlwU3EgPSBNYXRoLnBvdyhweXAsIDIpO1xuICBsZXQgcmFkaWNhbnQgPSByeFNxICogcnlTcSAtIHJ4U3EgKiBweXBTcSAtIHJ5U3EgKiBweHBTcTtcbiAgaWYgKHJhZGljYW50IDwgMCkge1xuICAgIHJhZGljYW50ID0gMDtcbiAgfVxuICByYWRpY2FudCAvPSByeFNxICogcHlwU3EgKyByeVNxICogcHhwU3E7XG4gIHJhZGljYW50ID0gTWF0aC5zcXJ0KHJhZGljYW50KSAqIChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSk7XG4gIGNvbnN0IGNlbnRlclhwID0gcmFkaWNhbnQgKiByeCAvIHJ5ICogcHlwO1xuICBjb25zdCBjZW50ZXJZcCA9IHJhZGljYW50ICogLXJ5IC8gcnggKiBweHA7XG4gIGNvbnN0IGNlbnRlclggPSBjb3NQaGkgKiBjZW50ZXJYcCAtIHNpblBoaSAqIGNlbnRlcllwICsgKHB4ICsgY3gpIC8gMjtcbiAgY29uc3QgY2VudGVyWSA9IHNpblBoaSAqIGNlbnRlclhwICsgY29zUGhpICogY2VudGVyWXAgKyAocHkgKyBjeSkgLyAyO1xuICBjb25zdCB2eDEgPSAocHhwIC0gY2VudGVyWHApIC8gcng7XG4gIGNvbnN0IHZ5MSA9IChweXAgLSBjZW50ZXJZcCkgLyByeTtcbiAgY29uc3QgdngyID0gKC1weHAgLSBjZW50ZXJYcCkgLyByeDtcbiAgY29uc3QgdnkyID0gKC1weXAgLSBjZW50ZXJZcCkgLyByeTtcbiAgY29uc3QgYW5nMSA9IHZlY3RvckFuZ2xlKDEsIDAsIHZ4MSwgdnkxKTtcbiAgbGV0IGFuZzIgPSB2ZWN0b3JBbmdsZSh2eDEsIHZ5MSwgdngyLCB2eTIpO1xuICBpZiAoc3dlZXBGbGFnID09PSAwICYmIGFuZzIgPiAwKSB7XG4gICAgYW5nMiAtPSBUQVU7XG4gIH1cbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhbmcyIDwgMCkge1xuICAgIGFuZzIgKz0gVEFVO1xuICB9XG4gIG91dDIuY2VudGVyWCA9IGNlbnRlclg7XG4gIG91dDIuY2VudGVyWSA9IGNlbnRlclk7XG4gIG91dDIuYW5nMSA9IGFuZzE7XG4gIG91dDIuYW5nMiA9IGFuZzI7XG59O1xuZnVuY3Rpb24gYnVpbGRBcmNUb1N2Zyhwb2ludHMsIHB4LCBweSwgY3gsIGN5LCByeCwgcnksIHhBeGlzUm90YXRpb24gPSAwLCBsYXJnZUFyY0ZsYWcgPSAwLCBzd2VlcEZsYWcgPSAwKSB7XG4gIGlmIChyeCA9PT0gMCB8fCByeSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uICogVEFVIC8gMzYwKTtcbiAgY29uc3QgY29zUGhpID0gTWF0aC5jb3MoeEF4aXNSb3RhdGlvbiAqIFRBVSAvIDM2MCk7XG4gIGNvbnN0IHB4cCA9IGNvc1BoaSAqIChweCAtIGN4KSAvIDIgKyBzaW5QaGkgKiAocHkgLSBjeSkgLyAyO1xuICBjb25zdCBweXAgPSAtc2luUGhpICogKHB4IC0gY3gpIC8gMiArIGNvc1BoaSAqIChweSAtIGN5KSAvIDI7XG4gIGlmIChweHAgPT09IDAgJiYgcHlwID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgY29uc3QgbGFtYmRhID0gTWF0aC5wb3cocHhwLCAyKSAvIE1hdGgucG93KHJ4LCAyKSArIE1hdGgucG93KHB5cCwgMikgLyBNYXRoLnBvdyhyeSwgMik7XG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gIH1cbiAgZ2V0QXJjQ2VudGVyKFxuICAgIHB4LFxuICAgIHB5LFxuICAgIGN4LFxuICAgIGN5LFxuICAgIHJ4LFxuICAgIHJ5LFxuICAgIGxhcmdlQXJjRmxhZyxcbiAgICBzd2VlcEZsYWcsXG4gICAgc2luUGhpLFxuICAgIGNvc1BoaSxcbiAgICBweHAsXG4gICAgcHlwLFxuICAgIG91dFxuICApO1xuICBsZXQgeyBhbmcxLCBhbmcyIH0gPSBvdXQ7XG4gIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSB9ID0gb3V0O1xuICBsZXQgcmF0aW8gPSBNYXRoLmFicyhhbmcyKSAvIChUQVUgLyA0KTtcbiAgaWYgKE1hdGguYWJzKDEgLSByYXRpbykgPCAxZS03KSB7XG4gICAgcmF0aW8gPSAxO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gTWF0aC5tYXgoTWF0aC5jZWlsKHJhdGlvKSwgMSk7XG4gIGFuZzIgLz0gc2VnbWVudHM7XG4gIGxldCBsYXN0WCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gIGxldCBsYXN0WSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG91dEN1cnZlUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgY29uc3QgY3VydmUgPSBhcHByb3hVbml0QXJjKGFuZzEsIGFuZzIpO1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBtYXBUb0VsbGlwc2UoY3VydmVbMF0sIHJ4LCByeSwgY29zUGhpLCBzaW5QaGksIGNlbnRlclgsIGNlbnRlclksIG91dEN1cnZlUG9pbnQpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBtYXBUb0VsbGlwc2UoY3VydmVbMV0sIHJ4LCByeSwgY29zUGhpLCBzaW5QaGksIGNlbnRlclgsIGNlbnRlclksIG91dEN1cnZlUG9pbnQpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwVG9FbGxpcHNlKGN1cnZlWzJdLCByeCwgcnksIGNvc1BoaSwgc2luUGhpLCBjZW50ZXJYLCBjZW50ZXJZLCBvdXRDdXJ2ZVBvaW50KTtcbiAgICBidWlsZEFkYXB0aXZlQmV6aWVyKFxuICAgICAgcG9pbnRzLFxuICAgICAgbGFzdFgsXG4gICAgICBsYXN0WSxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICApO1xuICAgIGxhc3RYID0geDtcbiAgICBsYXN0WSA9IHk7XG4gICAgYW5nMSArPSBhbmcyO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkQXJjVG9TdmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQXJjVG9TdmcubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiByb3VuZGVkU2hhcGVBcmMoZywgcG9pbnRzLCByYWRpdXMpIHtcbiAgY29uc3QgdmVjRnJvbSA9IChwLCBwcCkgPT4ge1xuICAgIGNvbnN0IHggPSBwcC54IC0gcC54O1xuICAgIGNvbnN0IHkgPSBwcC55IC0gcC55O1xuICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjb25zdCBueCA9IHggLyBsZW47XG4gICAgY29uc3QgbnkgPSB5IC8gbGVuO1xuICAgIHJldHVybiB7IGxlbiwgbngsIG55IH07XG4gIH07XG4gIGNvbnN0IHNoYXJwQ29ybmVyID0gKGksIHApID0+IHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZy5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnLmxpbmVUbyhwLngsIHAueSk7XG4gICAgfVxuICB9O1xuICBsZXQgcDEgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAyID0gcG9pbnRzW2kgJSBwb2ludHMubGVuZ3RoXTtcbiAgICBjb25zdCBwUmFkaXVzID0gcDIucmFkaXVzID8/IHJhZGl1cztcbiAgICBpZiAocFJhZGl1cyA8PSAwKSB7XG4gICAgICBzaGFycENvcm5lcihpLCBwMik7XG4gICAgICBwMSA9IHAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHAzID0gcG9pbnRzWyhpICsgMSkgJSBwb2ludHMubGVuZ3RoXTtcbiAgICBjb25zdCB2MSA9IHZlY0Zyb20ocDIsIHAxKTtcbiAgICBjb25zdCB2MiA9IHZlY0Zyb20ocDIsIHAzKTtcbiAgICBpZiAodjEubGVuIDwgMWUtNCB8fCB2Mi5sZW4gPCAxZS00KSB7XG4gICAgICBzaGFycENvcm5lcihpLCBwMik7XG4gICAgICBwMSA9IHAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBhbmdsZSA9IE1hdGguYXNpbih2MS5ueCAqIHYyLm55IC0gdjEubnkgKiB2Mi5ueCk7XG4gICAgbGV0IHJhZERpcmVjdGlvbiA9IDE7XG4gICAgbGV0IGRyYXdEaXJlY3Rpb24gPSBmYWxzZTtcbiAgICBpZiAodjEubnggKiB2Mi5ueCAtIHYxLm55ICogLXYyLm55IDwgMCkge1xuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IE1hdGguUEkgKyBhbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlID0gTWF0aC5QSSAtIGFuZ2xlO1xuICAgICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJhZERpcmVjdGlvbiA9IC0xO1xuICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMjtcbiAgICBsZXQgY1JhZGl1cztcbiAgICBsZXQgbGVuT3V0ID0gTWF0aC5hYnMoXG4gICAgICBNYXRoLmNvcyhoYWxmQW5nbGUpICogcFJhZGl1cyAvIE1hdGguc2luKGhhbGZBbmdsZSlcbiAgICApO1xuICAgIGlmIChsZW5PdXQgPiBNYXRoLm1pbih2MS5sZW4gLyAyLCB2Mi5sZW4gLyAyKSkge1xuICAgICAgbGVuT3V0ID0gTWF0aC5taW4odjEubGVuIC8gMiwgdjIubGVuIC8gMik7XG4gICAgICBjUmFkaXVzID0gTWF0aC5hYnMobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSAvIE1hdGguY29zKGhhbGZBbmdsZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjUmFkaXVzID0gcFJhZGl1cztcbiAgICB9XG4gICAgY29uc3QgY1ggPSBwMi54ICsgdjIubnggKiBsZW5PdXQgKyAtdjIubnkgKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICAgIGNvbnN0IGNZID0gcDIueSArIHYyLm55ICogbGVuT3V0ICsgdjIubnggKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHYxLm55LCB2MS5ueCkgKyBNYXRoLlBJIC8gMiAqIHJhZERpcmVjdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIodjIubnksIHYyLm54KSAtIE1hdGguUEkgLyAyICogcmFkRGlyZWN0aW9uO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLm1vdmVUbyhcbiAgICAgICAgY1ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIGNSYWRpdXMsXG4gICAgICAgIGNZICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiBjUmFkaXVzXG4gICAgICApO1xuICAgIH1cbiAgICBnLmFyYyhjWCwgY1ksIGNSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBkcmF3RGlyZWN0aW9uKTtcbiAgICBwMSA9IHAyO1xuICB9XG59XG5mdW5jdGlvbiByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZShnLCBwb2ludHMsIHJhZGl1cywgc21vb3RobmVzcykge1xuICBjb25zdCBkaXN0YW5jZSA9IChwMSwgcDIpID0+IE1hdGguc3FydCgocDEueCAtIHAyLngpICoqIDIgKyAocDEueSAtIHAyLnkpICoqIDIpO1xuICBjb25zdCBwb2ludExlcnAgPSAocDEsIHAyLCB0KSA9PiAoe1xuICAgIHg6IHAxLnggKyAocDIueCAtIHAxLngpICogdCxcbiAgICB5OiBwMS55ICsgKHAyLnkgLSBwMS55KSAqIHRcbiAgfSk7XG4gIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzUG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIG51bVBvaW50c107XG4gICAgY29uc3QgcFJhZGl1cyA9IHRoaXNQb2ludC5yYWRpdXMgPz8gcmFkaXVzO1xuICAgIGlmIChwUmFkaXVzIDw9IDApIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGcubW92ZVRvKHRoaXNQb2ludC54LCB0aGlzUG9pbnQueSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnLmxpbmVUbyh0aGlzUG9pbnQueCwgdGhpc1BvaW50LnkpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tpXTtcbiAgICBjb25zdCBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAyKSAlIG51bVBvaW50c107XG4gICAgY29uc3QgbGFzdEVkZ2VMZW5ndGggPSBkaXN0YW5jZShsYXN0UG9pbnQsIHRoaXNQb2ludCk7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGlmIChsYXN0RWRnZUxlbmd0aCA8IDFlLTQpIHtcbiAgICAgIHN0YXJ0ID0gdGhpc1BvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0T2Zmc2V0RGlzdGFuY2UgPSBNYXRoLm1pbihsYXN0RWRnZUxlbmd0aCAvIDIsIHBSYWRpdXMpO1xuICAgICAgc3RhcnQgPSBwb2ludExlcnAoXG4gICAgICAgIHRoaXNQb2ludCxcbiAgICAgICAgbGFzdFBvaW50LFxuICAgICAgICBsYXN0T2Zmc2V0RGlzdGFuY2UgLyBsYXN0RWRnZUxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEVkZ2VMZW5ndGggPSBkaXN0YW5jZShuZXh0UG9pbnQsIHRoaXNQb2ludCk7XG4gICAgbGV0IGVuZDtcbiAgICBpZiAobmV4dEVkZ2VMZW5ndGggPCAxZS00KSB7XG4gICAgICBlbmQgPSB0aGlzUG9pbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5leHRPZmZzZXREaXN0YW5jZSA9IE1hdGgubWluKG5leHRFZGdlTGVuZ3RoIC8gMiwgcFJhZGl1cyk7XG4gICAgICBlbmQgPSBwb2ludExlcnAoXG4gICAgICAgIHRoaXNQb2ludCxcbiAgICAgICAgbmV4dFBvaW50LFxuICAgICAgICBuZXh0T2Zmc2V0RGlzdGFuY2UgLyBuZXh0RWRnZUxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGcubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnLmxpbmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICB9XG4gICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKHRoaXNQb2ludC54LCB0aGlzUG9pbnQueSwgZW5kLngsIGVuZC55LCBzbW9vdGhuZXNzKTtcbiAgfVxufVxuXG5leHBvcnQgeyByb3VuZGVkU2hhcGVBcmMsIHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3VuZFNoYXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IENpcmNsZSB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9DaXJjbGUubWpzJztcbmltcG9ydCB7IEVsbGlwc2UgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvRWxsaXBzZS5tanMnO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9Qb2x5Z29uLm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFkYXB0aXZlUXVhZHJhdGljIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlUXVhZHJhdGljLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzJztcbmltcG9ydCB7IGJ1aWxkQXJjVG8gfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG8ubWpzJztcbmltcG9ydCB7IGJ1aWxkQXJjVG9TdmcgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG9TdmcubWpzJztcbmltcG9ydCB7IHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlLCByb3VuZGVkU2hhcGVBcmMgfSBmcm9tICcuL3JvdW5kU2hhcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgpO1xuY2xhc3MgU2hhcGVQYXRoIHtcbiAgY29uc3RydWN0b3IoZ3JhcGhpY3NQYXRoMkQpIHtcbiAgICAvKiogVGhlIGxpc3Qgb2Ygc2hhcGUgcHJpbWl0aXZlcyB0aGF0IG1ha2UgdXAgdGhlIHBhdGguICovXG4gICAgdGhpcy5zaGFwZVByaW1pdGl2ZXMgPSBbXTtcbiAgICB0aGlzLl9jdXJyZW50UG9seSA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICAgIHRoaXMuX2dyYXBoaWNzUGF0aDJEID0gZ3JhcGhpY3NQYXRoMkQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBhIG5ldyBzdWItcGF0aC4gQW55IHN1YnNlcXVlbnQgZHJhd2luZyBjb21tYW5kcyBhcmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoaXMgcGF0aC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIGZvciB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBmb3IgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5zdGFydFBvbHkoeCwgeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBjdXJyZW50IHBvaW50IHRvIGEgbmV3IHBvaW50IHdpdGggYSBzdHJhaWdodCBsaW5lLiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl9lbnN1cmVQb2x5KCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY3VycmVudFBvbHkucG9pbnRzO1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGZyb21YICE9PSB4IHx8IGZyb21ZICE9PSB5KSB7XG4gICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBwYXRoLiBUaGUgYXJjIGlzIGNlbnRlcmVkIGF0ICh4LCB5KVxuICAgKiAgcG9zaXRpb24gd2l0aCByYWRpdXMgYHJhZGl1c2Agc3RhcnRpbmcgYXQgYHN0YXJ0QW5nbGVgIGFuZCBlbmRpbmcgYXQgYGVuZEFuZ2xlYC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBjZW50ZXIuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgY2VudGVyLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjLlxuICAgKiBAcGFyYW0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgYXJjLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlIG9mIHRoZSBhcmMsIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSBjb3VudGVyY2xvY2t3aXNlIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGFyYyBzaG91bGQgYmUgZHJhd24gaW4gdGhlIGFudGljbG9ja3dpc2UgZGlyZWN0aW9uLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyY2xvY2t3aXNlKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seShmYWxzZSk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY3VycmVudFBvbHkucG9pbnRzO1xuICAgIGJ1aWxkQXJjKHBvaW50cywgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlcmNsb2Nrd2lzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBwYXRoIHdpdGggdGhlIGFyYyB0YW5nZW50IHRvIHRoZSBsaW5lIGpvaW5pbmcgdHdvIHNwZWNpZmllZCBwb2ludHMuXG4gICAqIFRoZSBhcmMgcmFkaXVzIGlzIHNwZWNpZmllZCBieSBgcmFkaXVzYC5cbiAgICogQHBhcmFtIHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB5MSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyYy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBidWlsZEFyY1RvKHBvaW50cywgeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gU1ZHLXN0eWxlIGFyYyB0byB0aGUgcGF0aCwgYWxsb3dpbmcgZm9yIGVsbGlwdGljYWwgYXJjcyBiYXNlZCBvbiB0aGUgU1ZHIHNwZWMuXG4gICAqIEBwYXJhbSByeCAtIFRoZSB4LXJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJ5IC0gVGhlIHktcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geEF4aXNSb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZWxsaXBzZSdzIHgtYXhpcyByZWxhdGl2ZVxuICAgKiB0byB0aGUgeC1heGlzIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSwgaW4gZGVncmVlcy5cbiAgICogQHBhcmFtIGxhcmdlQXJjRmxhZyAtIERldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGxlc3MgdGhhbiAxODAgZGVncmVlcy5cbiAgICogQHBhcmFtIHN3ZWVwRmxhZyAtIERldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgc3dlcHQgaW4gYSBwb3NpdGl2ZSBhbmdsZSBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGVuZCBwb2ludC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUb1N2ZyhyeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY3VycmVudFBvbHkucG9pbnRzO1xuICAgIGJ1aWxkQXJjVG9TdmcoXG4gICAgICBwb2ludHMsXG4gICAgICB0aGlzLl9jdXJyZW50UG9seS5sYXN0WCxcbiAgICAgIHRoaXMuX2N1cnJlbnRQb2x5Lmxhc3RZLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGxhcmdlQXJjRmxhZyxcbiAgICAgIHN3ZWVwRmxhZ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjdWJpYyBCZXppZXIgY3VydmUgdG8gdGhlIHBhdGguXG4gICAqIEl0IHJlcXVpcmVzIHRocmVlIHBvaW50czogdGhlIGZpcnN0IHR3byBhcmUgY29udHJvbCBwb2ludHMgYW5kIHRoZSB0aGlyZCBvbmUgaXMgdGhlIGVuZCBwb2ludC5cbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcDF4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMXkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5LCBzbW9vdGhuZXNzKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IGN1cnJlbnRQb2x5ID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgYnVpbGRBZGFwdGl2ZUJlemllcihcbiAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cyxcbiAgICAgIGN1cnJlbnRQb2x5Lmxhc3RYLFxuICAgICAgY3VycmVudFBvbHkubGFzdFksXG4gICAgICBjcDF4LFxuICAgICAgY3AxeSxcbiAgICAgIGNwMngsXG4gICAgICBjcDJ5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBzbW9vdGhuZXNzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgcGF0aC4gSXQgcmVxdWlyZXMgdHdvIHBvaW50czogdGhlIGNvbnRyb2wgcG9pbnQgYW5kIHRoZSBlbmQgcG9pbnQuXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3AxeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDF5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RoaW5nIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbyhjcDF4LCBjcDF5LCB4LCB5LCBzbW9vdGhpbmcpIHtcbiAgICB0aGlzLl9lbnN1cmVQb2x5KCk7XG4gICAgY29uc3QgY3VycmVudFBvbHkgPSB0aGlzLl9jdXJyZW50UG9seTtcbiAgICBidWlsZEFkYXB0aXZlUXVhZHJhdGljKFxuICAgICAgdGhpcy5fY3VycmVudFBvbHkucG9pbnRzLFxuICAgICAgY3VycmVudFBvbHkubGFzdFgsXG4gICAgICBjdXJyZW50UG9seS5sYXN0WSxcbiAgICAgIGNwMXgsXG4gICAgICBjcDF5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBzbW9vdGhpbmdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBkcmF3aW5nIGEgc3RyYWlnaHQgbGluZSBiYWNrIHRvIHRoZSBzdGFydC5cbiAgICogSWYgdGhlIHNoYXBlIGlzIGFscmVhZHkgY2xvc2VkIG9yIHRoZXJlIGFyZSBubyBwb2ludHMgaW4gdGhlIHBhdGgsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5lbmRQb2x5KHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgcGF0aCB0byB0aGUgY3VycmVudCBwYXRoLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjb21iaW5hdGlvbiBvZiBtdWx0aXBsZSBwYXRocyBpbnRvIG9uZS5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgYEdyYXBoaWNzUGF0aGAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byBhZGQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcGF0aCBiZWZvcmUgYWRkaW5nIGl0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZFBhdGgocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5lbmRQb2x5KCk7XG4gICAgaWYgKHRyYW5zZm9ybSAmJiAhdHJhbnNmb3JtLmlzSWRlbnRpdHkoKSkge1xuICAgICAgcGF0aCA9IHBhdGguY2xvbmUodHJ1ZSk7XG4gICAgICBwYXRoLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGguaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHBhdGguaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdGhpc1tpbnN0cnVjdGlvbi5hY3Rpb25dKC4uLmluc3RydWN0aW9uLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBkcmF3aW5nIG9mIHRoZSBjdXJyZW50IHBhdGguIE9wdGlvbmFsbHksIGl0IGNhbiBjbG9zZSB0aGUgcGF0aC5cbiAgICogQHBhcmFtIGNsb3NlUGF0aCAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHBhdGggYWZ0ZXIgZmluaXNoaW5nLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKi9cbiAgZmluaXNoKGNsb3NlUGF0aCA9IGZhbHNlKSB7XG4gICAgdGhpcy5lbmRQb2x5KGNsb3NlUGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHJlY3RhbmdsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGUoeCwgeSwgdywgaCksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IGNpcmNsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBDaXJjbGUoeCwgeSwgcmFkaXVzKSwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHNoYXBlLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvbiBvZiBjb21wbGV4IHBvbHlnb25zIGJ5IHNwZWNpZnlpbmcgYSBzZXF1ZW5jZSBvZiBwb2ludHMuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBvciBhbiBhcnJheSBvZiBQb2ludERhdGEgb2JqZWN0cyBlZyBbe3gseX0sIHt4LHl9LCB7eCx5fV1cbiAgICogcmVwcmVzZW50aW5nIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uJ3MgdmVydGljZXMsIGluIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0gY2xvc2UgLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNsb3NlIHRoZSBwb2x5Z29uIHBhdGguIFRydWUgYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHBvbHkocG9pbnRzLCBjbG9zZSwgdHJhbnNmb3JtKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgcG9seWdvbi5jbG9zZVBhdGggPSBjbG9zZTtcbiAgICB0aGlzLmRyYXdTaGFwZShwb2x5Z29uLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlZ3VsYXIgcG9seWdvbiB3aXRoIGEgc3BlY2lmaWVkIG51bWJlciBvZiBzaWRlcy4gQWxsIHNpZGVzIGFuZCBhbmdsZXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgcG9seWdvbiwgaW4gcmFkaWFucy4gWmVybyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24gPSAwLCB0cmFuc2Zvcm0pIHtcbiAgICBzaWRlcyA9IE1hdGgubWF4KHNpZGVzIHwgMCwgMyk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IC0xICogTWF0aC5QSSAvIDIgKyByb3RhdGlvbjtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gICAgY29uc3QgcG9seWdvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY29uc3QgYW5nbGUgPSBpICogZGVsdGEgKyBzdGFydEFuZ2xlO1xuICAgICAgcG9seWdvbi5wdXNoKFxuICAgICAgICB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBvbHkocG9seWdvbiwgdHJ1ZSwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBTaW1pbGFyIHRvIGByZWd1bGFyUG9seWAgYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gcm91bmQgdGhlIGNvcm5lcnMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmN1bXNjcmliZWQgY2lyY2xlIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gc2lkZXMgLSBUaGUgbnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBNdXN0IGJlIDMgb3IgbW9yZS5cbiAgICogQHBhcmFtIGNvcm5lciAtIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kaW5nIG9mIHRoZSBjb3JuZXJzLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSByb3VuZGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgY29ybmVyLCByb3RhdGlvbiA9IDAsIHNtb290aG5lc3MpIHtcbiAgICBzaWRlcyA9IE1hdGgubWF4KHNpZGVzIHwgMCwgMyk7XG4gICAgaWYgKGNvcm5lciA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWd1bGFyUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCByb3RhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHNpZGVMZW5ndGggPSByYWRpdXMgKiBNYXRoLnNpbihNYXRoLlBJIC8gc2lkZXMpIC0gMWUtMztcbiAgICBjb3JuZXIgPSBNYXRoLm1pbihjb3JuZXIsIHNpZGVMZW5ndGgpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyICsgcm90YXRpb247XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIHNpZGVzO1xuICAgIGNvbnN0IGludGVybmFsQW5nbGUgPSAoc2lkZXMgLSAyKSAqIE1hdGguUEkgLyBzaWRlcyAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgKiBkZWx0YSArIHN0YXJ0QW5nbGU7XG4gICAgICBjb25zdCB4MCA9IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBjb25zdCB5MCA9IHkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICBjb25zdCBhMSA9IGFuZ2xlICsgTWF0aC5QSSArIGludGVybmFsQW5nbGU7XG4gICAgICBjb25zdCBhMiA9IGFuZ2xlIC0gTWF0aC5QSSAtIGludGVybmFsQW5nbGU7XG4gICAgICBjb25zdCB4MSA9IHgwICsgY29ybmVyICogTWF0aC5jb3MoYTEpO1xuICAgICAgY29uc3QgeTEgPSB5MCArIGNvcm5lciAqIE1hdGguc2luKGExKTtcbiAgICAgIGNvbnN0IHgzID0geDAgKyBjb3JuZXIgKiBNYXRoLmNvcyhhMik7XG4gICAgICBjb25zdCB5MyA9IHkwICsgY29ybmVyICogTWF0aC5zaW4oYTIpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGluZVRvKHgxLCB5MSk7XG4gICAgICB9XG4gICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oeDAsIHkwLCB4MywgeTMsIHNtb290aG5lc3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZVBhdGgoKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzaGFwZSB3aXRoIHJvdW5kZWQgY29ybmVycy4gVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjdXN0b20gcmFkaXVzIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgc2hhcGUuXG4gICAqIE9wdGlvbmFsbHksIGNvcm5lcnMgY2FuIGJlIHJvdW5kZWQgdXNpbmcgYSBxdWFkcmF0aWMgY3VydmUgaW5zdGVhZCBvZiBhbiBhcmMsIHByb3ZpZGluZyBhIGRpZmZlcmVudCBhZXN0aGV0aWMuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBgUm91bmRlZFBvaW50YCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHNoYXBlIHRvIGRyYXcuXG4gICAqIEEgbWluaW11bSBvZiAzIHBvaW50cyBpcyByZXF1aXJlZC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBkZWZhdWx0IHJhZGl1cyBmb3IgdGhlIGNvcm5lcnMuXG4gICAqIFRoaXMgcmFkaXVzIGlzIGFwcGxpZWQgdG8gYWxsIGNvcm5lcnMgdW5sZXNzIG92ZXJyaWRkZW4gaW4gYHBvaW50c2AuXG4gICAqIEBwYXJhbSB1c2VRdWFkcmF0aWMgLSBJZiBzZXQgdG8gdHJ1ZSwgcm91bmRlZCBjb3JuZXJzIGFyZSBkcmF3biB1c2luZyBhIHF1YWRyYXRpY0N1cnZlXG4gICAqICBtZXRob2QgaW5zdGVhZCBvZiBhbiBhcmMgbWV0aG9kLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBTcGVjaWZpZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlIHdoZW4gYHVzZVF1YWRyYXRpY2AgaXMgdHJ1ZS5cbiAgICogSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBjdXJ2ZSBzbW9vdGhlci5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFNoYXBlKHBvaW50cywgcmFkaXVzLCB1c2VRdWFkcmF0aWMgPSBmYWxzZSwgc21vb3RobmVzcykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh1c2VRdWFkcmF0aWMpIHtcbiAgICAgIHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlKHRoaXMsIHBvaW50cywgcmFkaXVzLCBzbW9vdGhuZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRlZFNoYXBlQXJjKHRoaXMsIHBvaW50cywgcmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgUmVjdGFuZ2xlIHdpdGggZmlsbGV0IGNvcm5lcnMuIFRoaXMgaXMgbXVjaCBsaWtlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIGhvd2V2ZXIgaXQgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzIGFzIHdlbGwgZm9yIHRoZSBjb3JuZXIgcmFkaXVzLlxuICAgKiBAcGFyYW0geCAtIFVwcGVyIGxlZnQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHkgLSBVcHBlciByaWdodCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiByZWN0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgcmVjdFxuICAgKiBAcGFyYW0gZmlsbGV0IC0gYWNjZXB0IG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHZhbHVlc1xuICAgKi9cbiAgZmlsbGV0UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsZXQpIHtcbiAgICBpZiAoZmlsbGV0ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBtYXhGaWxsZXQgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgY29uc3QgaW5zZXQgPSBNYXRoLm1pbihtYXhGaWxsZXQsIE1hdGgubWF4KC1tYXhGaWxsZXQsIGZpbGxldCkpO1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIHdpZHRoO1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBoZWlnaHQ7XG4gICAgY29uc3QgZGlyID0gaW5zZXQgPCAwID8gLWluc2V0IDogMDtcbiAgICBjb25zdCBzaXplID0gTWF0aC5hYnMoaW5zZXQpO1xuICAgIHJldHVybiB0aGlzLm1vdmVUbyh4LCB5ICsgc2l6ZSkuYXJjVG8oeCArIGRpciwgeSArIGRpciwgeCArIHNpemUsIHksIHNpemUpLmxpbmVUbyhyaWdodCAtIHNpemUsIHkpLmFyY1RvKHJpZ2h0IC0gZGlyLCB5ICsgZGlyLCByaWdodCwgeSArIHNpemUsIHNpemUpLmxpbmVUbyhyaWdodCwgYm90dG9tIC0gc2l6ZSkuYXJjVG8ocmlnaHQgLSBkaXIsIGJvdHRvbSAtIGRpciwgeCArIHdpZHRoIC0gc2l6ZSwgYm90dG9tLCBzaXplKS5saW5lVG8oeCArIHNpemUsIGJvdHRvbSkuYXJjVG8oeCArIGRpciwgYm90dG9tIC0gZGlyLCB4LCBib3R0b20gLSBzaXplLCBzaXplKS5jbG9zZVBhdGgoKTtcbiAgfVxuICAvKipcbiAgICogRHJhdyBSZWN0YW5nbGUgd2l0aCBjaGFtZmVyIGNvcm5lcnMuIFRoZXNlIGFyZSBhbmdsZWQgY29ybmVycy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGNoYW1mZXIgLSBub24temVybyByZWFsIG51bWJlciwgc2l6ZSBvZiBjb3JuZXIgY3V0b3V0XG4gICAqIEBwYXJhbSB0cmFuc2Zvcm1cbiAgICovXG4gIGNoYW1mZXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGNoYW1mZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmIChjaGFtZmVyIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGluc2V0ID0gTWF0aC5taW4oY2hhbWZlciwgTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyKTtcbiAgICBjb25zdCByaWdodCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgaGVpZ2h0O1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgIHggKyBpbnNldCxcbiAgICAgIHksXG4gICAgICByaWdodCAtIGluc2V0LFxuICAgICAgeSxcbiAgICAgIHJpZ2h0LFxuICAgICAgeSArIGluc2V0LFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20gLSBpbnNldCxcbiAgICAgIHJpZ2h0IC0gaW5zZXQsXG4gICAgICBib3R0b20sXG4gICAgICB4ICsgaW5zZXQsXG4gICAgICBib3R0b20sXG4gICAgICB4LFxuICAgICAgYm90dG9tIC0gaW5zZXQsXG4gICAgICB4LFxuICAgICAgeSArIGluc2V0XG4gICAgXTtcbiAgICBmb3IgKGxldCBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMjsgaSAtPSAyKSB7XG4gICAgICBpZiAocG9pbnRzW2ldID09PSBwb2ludHNbaSAtIDJdICYmIHBvaW50c1tpIC0gMV0gPT09IHBvaW50c1tpIC0gM10pIHtcbiAgICAgICAgcG9pbnRzLnNwbGljZShpIC0gMSwgMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvbHkocG9pbnRzLCB0cnVlLCB0cmFuc2Zvcm0pO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhbiBlbGxpcHNlIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gYW5kIHdpdGggdGhlIGdpdmVuIHggYW5kIHkgcmFkaWkuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCBhbGxvd2luZyBmb3Igcm90YXRpb24sIHNjYWxpbmcsIGFuZCB0cmFuc2xhdGlvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gcmFkaXVzWCAtIFRoZSBob3Jpem9udGFsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1kgLSBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGVsbGlwc2UuIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IEVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBUaGUgY29ybmVyIHJhZGl1cyBjYW4gYmUgc3BlY2lmaWVkIHRvIGRldGVybWluZSBob3cgcm91bmRlZCB0aGUgY29ybmVycyBzaG91bGQgYmUuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCB3aGljaCBhbGxvd3MgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24gb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGUncyBjb3JuZXJzLiBJZiBub3Qgc3BlY2lmaWVkLCBjb3JuZXJzIHdpbGwgYmUgc2hhcnAuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBSb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHcsIGgsIHJhZGl1cyksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgZ2l2ZW4gc2hhcGUgb24gdGhlIGNhbnZhcy5cbiAgICogVGhpcyBpcyBhIGdlbmVyaWMgbWV0aG9kIHRoYXQgY2FuIGRyYXcgYW55IHR5cGUgb2Ygc2hhcGUgc3BlY2lmaWVkIGJ5IHRoZSBgU2hhcGVQcmltaXRpdmVgIHBhcmFtZXRlci5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZSwgYWxsb3dpbmcgZm9yIGNvbXBsZXggdHJhbnNmb3JtYXRpb25zLlxuICAgKiBAcGFyYW0gc2hhcGUgLSBUaGUgc2hhcGUgdG8gZHJhdywgZGVmaW5lZCBhcyBhIGBTaGFwZVByaW1pdGl2ZWAgb2JqZWN0LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgZm9yIHRyYW5zZm9ybWluZyB0aGUgc2hhcGUuIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLFxuICAgKiBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGRyYXdTaGFwZShzaGFwZSwgbWF0cml4KSB7XG4gICAgdGhpcy5lbmRQb2x5KCk7XG4gICAgdGhpcy5zaGFwZVByaW1pdGl2ZXMucHVzaCh7IHNoYXBlLCB0cmFuc2Zvcm06IG1hdHJpeCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIGEgbmV3IHBvbHlnb24gcGF0aCBmcm9tIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgcG9pbnQuXG4gICAqIFRoaXMgbWV0aG9kIGluaXRpYWxpemVzIGEgbmV3IHBvbHlnb24gb3IgZW5kcyB0aGUgY3VycmVudCBvbmUgaWYgaXQgZXhpc3RzLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBuZXcgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbmV3IHBvbHlnb24uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgc3RhcnRQb2x5KHgsIHkpIHtcbiAgICBsZXQgY3VycmVudFBvbHkgPSB0aGlzLl9jdXJyZW50UG9seTtcbiAgICBpZiAoY3VycmVudFBvbHkpIHtcbiAgICAgIHRoaXMuZW5kUG9seSgpO1xuICAgIH1cbiAgICBjdXJyZW50UG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgY3VycmVudFBvbHkucG9pbnRzLnB1c2goeCwgeSk7XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBjdXJyZW50UG9seTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5kcyB0aGUgY3VycmVudCBwb2x5Z29uIHBhdGguIElmIGBjbG9zZVBhdGhgIGlzIHNldCB0byB0cnVlLFxuICAgKiB0aGUgcGF0aCBpcyBjbG9zZWQgYnkgY29ubmVjdGluZyB0aGUgbGFzdCBwb2ludCB0byB0aGUgZmlyc3Qgb25lLlxuICAgKiBUaGlzIG1ldGhvZCBmaW5hbGl6ZXMgdGhlIGN1cnJlbnQgcG9seWdvbiBhbmQgcHJlcGFyZXMgaXQgZm9yIGRyYXdpbmcgb3IgYWRkaW5nIHRvIHRoZSBzaGFwZSBwcmltaXRpdmVzLlxuICAgKiBAcGFyYW0gY2xvc2VQYXRoIC0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBjbG9zZSB0aGUgcG9seWdvbiBieSBjb25uZWN0aW5nIHRoZSBsYXN0IHBvaW50XG4gICAqICBiYWNrIHRvIHRoZSBzdGFydGluZyBwb2ludC4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBlbmRQb2x5KGNsb3NlUGF0aCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9jdXJyZW50UG9seTtcbiAgICBpZiAoc2hhcGUgJiYgc2hhcGUucG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHNoYXBlLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLnB1c2goeyBzaGFwZSB9KTtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9lbnN1cmVQb2x5KHN0YXJ0ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50UG9seSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jdXJyZW50UG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBjb25zdCBsYXN0U2hhcGUgPSB0aGlzLnNoYXBlUHJpbWl0aXZlc1t0aGlzLnNoYXBlUHJpbWl0aXZlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0U2hhcGUpIHtcbiAgICAgICAgbGV0IGx4ID0gbGFzdFNoYXBlLnNoYXBlLng7XG4gICAgICAgIGxldCBseSA9IGxhc3RTaGFwZS5zaGFwZS55O1xuICAgICAgICBpZiAoIWxhc3RTaGFwZS50cmFuc2Zvcm0uaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGxhc3RTaGFwZS50cmFuc2Zvcm07XG4gICAgICAgICAgY29uc3QgdGVtcFggPSBseDtcbiAgICAgICAgICBseCA9IHQuYSAqIGx4ICsgdC5jICogbHkgKyB0LnR4O1xuICAgICAgICAgIGx5ID0gdC5iICogdGVtcFggKyB0LmQgKiBseSArIHQudHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudFBvbHkucG9pbnRzLnB1c2gobHgsIGx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cy5wdXNoKDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQnVpbGRzIHRoZSBwYXRoLiAqL1xuICBidWlsZFBhdGgoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuX2dyYXBoaWNzUGF0aDJEO1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gcGF0aC5pbnN0cnVjdGlvbnNbaV07XG4gICAgICB0aGlzW2luc3RydWN0aW9uLmFjdGlvbl0oLi4uaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKCk7XG4gIH1cbiAgLyoqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgcGF0aC4gKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgY29uc3Qgc2hhcGVQcmltaXRpdmVzID0gdGhpcy5zaGFwZVByaW1pdGl2ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZVByaW1pdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlUHJpbWl0aXZlID0gc2hhcGVQcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgYm91bmRzUmVjdCA9IHNoYXBlUHJpbWl0aXZlLnNoYXBlLmdldEJvdW5kcyh0ZW1wUmVjdGFuZ2xlKTtcbiAgICAgIGlmIChzaGFwZVByaW1pdGl2ZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgYm91bmRzLmFkZFJlY3QoYm91bmRzUmVjdCwgc2hhcGVQcmltaXRpdmUudHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5hZGRSZWN0KGJvdW5kc1JlY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59XG5cbmV4cG9ydCB7IFNoYXBlUGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhcGVQYXRoLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBTVkdUb0dyYXBoaWNzUGF0aCB9IGZyb20gJy4uL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanMnO1xuaW1wb3J0IHsgU2hhcGVQYXRoIH0gZnJvbSAnLi9TaGFwZVBhdGgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljc1BhdGgge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGBHcmFwaGljc1BhdGhgIGluc3RhbmNlIG9wdGlvbmFsbHkgZnJvbSBhbiBTVkcgcGF0aCBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgYFBhdGhJbnN0cnVjdGlvbmAuXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvbnMgLSBBbiBTVkcgcGF0aCBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgYFBhdGhJbnN0cnVjdGlvbmAgb2JqZWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluc3RydWN0aW9ucykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgdGhpcy51aWQgPSB1aWQoXCJncmFwaGljc1BhdGhcIik7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBTVkdUb0dyYXBoaWNzUGF0aChpbnN0cnVjdGlvbnMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucz8uc2xpY2UoKSA/PyBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgaW50ZXJuYWwgc2hhcGUgcGF0aCwgZW5zdXJpbmcgaXQgaXMgdXAtdG8tZGF0ZSB3aXRoIHRoZSBjdXJyZW50IGluc3RydWN0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGBTaGFwZVBhdGhgIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGBHcmFwaGljc1BhdGhgLlxuICAgKi9cbiAgZ2V0IHNoYXBlUGF0aCgpIHtcbiAgICBpZiAoIXRoaXMuX3NoYXBlUGF0aCkge1xuICAgICAgdGhpcy5fc2hhcGVQYXRoID0gbmV3IFNoYXBlUGF0aCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2hhcGVQYXRoLmJ1aWxkUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcGVQYXRoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgYEdyYXBoaWNzUGF0aGAgdG8gdGhpcyBwYXRoLCBvcHRpb25hbGx5IGFwcGx5aW5nIGEgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIHRvIGFkZC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBhZGRlZCBwYXRoLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZFBhdGgocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgcGF0aCA9IHBhdGguY2xvbmUoKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImFkZFBhdGhcIiwgZGF0YTogW3BhdGgsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyYyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJhcmNcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG9TdmcoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjVG9TdmdcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJiZXppZXJDdXJ2ZVRvXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgY3ViaWMgQmV6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxuICAgKiBJdCByZXF1aXJlcyB0d28gcG9pbnRzOiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgYW5kIHRoZSBlbmQgcG9pbnQuIFRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcDJ4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvU2hvcnQoY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIGxldCBjcDF4ID0gMDtcbiAgICBsZXQgY3AxeSA9IDA7XG4gICAgaWYgKCFsYXN0IHx8IGxhc3QuYWN0aW9uICE9PSBcImJlemllckN1cnZlVG9cIikge1xuICAgICAgY3AxeCA9IGxhc3RQb2ludC54O1xuICAgICAgY3AxeSA9IGxhc3RQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjcDF4ID0gbGFzdC5kYXRhWzJdO1xuICAgICAgY3AxeSA9IGxhc3QuZGF0YVszXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gbGFzdFBvaW50Lng7XG4gICAgICBjb25zdCBjdXJyZW50WSA9IGxhc3RQb2ludC55O1xuICAgICAgY3AxeCA9IGN1cnJlbnRYICsgKGN1cnJlbnRYIC0gY3AxeCk7XG4gICAgICBjcDF5ID0gY3VycmVudFkgKyAoY3VycmVudFkgLSBjcDF5KTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJiZXppZXJDdXJ2ZVRvXCIsIGRhdGE6IFtjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5LCBzbW9vdGhuZXNzXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoIGJ5IGRyYXdpbmcgYSBzdHJhaWdodCBsaW5lIGJhY2sgdG8gdGhlIHN0YXJ0LlxuICAgKiBJZiB0aGUgc2hhcGUgaXMgYWxyZWFkeSBjbG9zZWQgb3IgdGhlcmUgYXJlIG5vIHBvaW50cyBpbiB0aGUgcGF0aCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImNsb3NlUGF0aFwiLCBkYXRhOiBbXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZWxsaXBzZSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJlbGxpcHNlXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpbmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJsaW5lVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbW92ZVRvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcIm1vdmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicXVhZHJhdGljQ3VydmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgcGF0aC4gSXQgdXNlcyB0aGUgcHJldmlvdXMgcG9pbnQgYXMgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvU2hvcnQoeCwgeSwgc21vb3RobmVzcykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIGxldCBjcHgxID0gMDtcbiAgICBsZXQgY3B5MSA9IDA7XG4gICAgaWYgKCFsYXN0IHx8IGxhc3QuYWN0aW9uICE9PSBcInF1YWRyYXRpY0N1cnZlVG9cIikge1xuICAgICAgY3B4MSA9IGxhc3RQb2ludC54O1xuICAgICAgY3B5MSA9IGxhc3RQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjcHgxID0gbGFzdC5kYXRhWzBdO1xuICAgICAgY3B5MSA9IGxhc3QuZGF0YVsxXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gbGFzdFBvaW50Lng7XG4gICAgICBjb25zdCBjdXJyZW50WSA9IGxhc3RQb2ludC55O1xuICAgICAgY3B4MSA9IGN1cnJlbnRYICsgKGN1cnJlbnRYIC0gY3B4MSk7XG4gICAgICBjcHkxID0gY3VycmVudFkgKyAoY3VycmVudFkgLSBjcHkxKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJxdWFkcmF0aWNDdXJ2ZVRvXCIsIGRhdGE6IFtjcHgxLCBjcHkxLCB4LCB5LCBzbW9vdGhuZXNzXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHJlY3RhbmdsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicmVjdFwiLCBkYXRhOiBbeCwgeSwgdywgaCwgdHJhbnNmb3JtXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IGNpcmNsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiY2lyY2xlXCIsIGRhdGE6IFt4LCB5LCByYWRpdXMsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kUmVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFJlY3RcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJwb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ3VsYXJQb2x5KC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcInJlZ3VsYXJQb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kUG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFBvbHlcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm91bmRTaGFwZSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFNoYXBlXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbGxldFJlY3QoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiZmlsbGV0UmVjdFwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjaGFtZmVyUmVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJjaGFtZmVyUmVjdFwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IGEgc3BlY2lmaWVkIGxvY2F0aW9uLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvblxuICAgKiAgb2Ygc3RhcnMgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBwb2ludHMsIG91dGVyIHJhZGl1cywgb3B0aW9uYWwgaW5uZXIgcmFkaXVzLCBhbmQgcm90YXRpb24uXG4gICAqIFRoZSBzdGFyIGlzIGRyYXduIGFzIGEgY2xvc2VkIHBvbHlnb24gd2l0aCBhbHRlcm5hdGluZyBvdXRlciBhbmQgaW5uZXIgdmVydGljZXMgdG8gY3JlYXRlIHRoZSBzdGFyJ3MgcG9pbnRzLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCB0byBzY2FsZSwgcm90YXRlLCBvciB0cmFuc2xhdGUgdGhlIHN0YXIgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgbnVtYmVyIG9mIHBvaW50cyBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIgKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgb3V0ZXIgcG9pbnRzKS5cbiAgICogQHBhcmFtIGlubmVyUmFkaXVzIC0gT3B0aW9uYWwuIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN0YXJcbiAgICogKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgaW5uZXIgcG9pbnRzIGJldHdlZW4gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gaGFsZiBvZiB0aGUgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIE9wdGlvbmFsLiBUaGUgcm90YXRpb24gb2YgdGhlIHN0YXIgaW4gcmFkaWFucywgd2hlcmUgMCBpcyBhbGlnbmVkIHdpdGggdGhlIHktYXhpcy5cbiAgICogRGVmYXVsdHMgdG8gMCwgbWVhbmluZyBvbmUgcG9pbnQgaXMgZGlyZWN0bHkgdXB3YXJkLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHN0YXIuXG4gICAqIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZyBmdXJ0aGVyIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBzdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cywgcm90YXRpb24sIHRyYW5zZm9ybSkge1xuICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgcmFkaXVzIC8gMjtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gLTEgKiBNYXRoLlBJIC8gMiArIHJvdGF0aW9uO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cyAqIDI7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIGxlbjtcbiAgICBjb25zdCBwb2x5Z29uID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgciA9IGkgJSAyID8gaW5uZXJSYWRpdXMgOiByYWRpdXM7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgKiBkZWx0YSArIHN0YXJ0QW5nbGU7XG4gICAgICBwb2x5Z29uLnB1c2goXG4gICAgICAgIHggKyByICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5ICsgciAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wb2x5KHBvbHlnb24sIHRydWUsIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGBHcmFwaGljc1BhdGhgIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2xvbmluZy5cbiAgICogQSBzaGFsbG93IGNsb25lIGNvcGllcyB0aGUgcmVmZXJlbmNlIG9mIHRoZSBpbnN0cnVjdGlvbnMgYXJyYXksIHdoaWxlIGEgZGVlcCBjbG9uZSBjcmVhdGVzIGEgbmV3IGFycmF5IGFuZFxuICAgKiBjb3BpZXMgZWFjaCBpbnN0cnVjdGlvbiBpbmRpdmlkdWFsbHksIGVuc3VyaW5nIHRoYXQgbW9kaWZpY2F0aW9ucyB0byB0aGUgaW5zdHJ1Y3Rpb25zIG9mIHRoZSBjbG9uZWQgYEdyYXBoaWNzUGF0aGBcbiAgICogZG8gbm90IGFmZmVjdCB0aGUgb3JpZ2luYWwgYEdyYXBoaWNzUGF0aGAgYW5kIHZpY2UgdmVyc2EuXG4gICAqIEBwYXJhbSBkZWVwIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjbG9uZSBzaG91bGQgYmUgZGVlcC5cbiAgICogQHJldHVybnMgQSBuZXcgYEdyYXBoaWNzUGF0aGAgaW5zdGFuY2UgdGhhdCBpcyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKi9cbiAgY2xvbmUoZGVlcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbmV3R3JhcGhpY3NQYXRoMkQgPSBuZXcgR3JhcGhpY3NQYXRoKCk7XG4gICAgaWYgKCFkZWVwKSB7XG4gICAgICBuZXdHcmFwaGljc1BhdGgyRC5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIG5ld0dyYXBoaWNzUGF0aDJELmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBpbnN0cnVjdGlvbi5hY3Rpb24sIGRhdGE6IGluc3RydWN0aW9uLmRhdGEuc2xpY2UoKSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0dyYXBoaWNzUGF0aDJEO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucyB3aXRoaW4gdGhlIGBHcmFwaGljc1BhdGhgLlxuICAgKiBUaGlzIG1ldGhvZCBlbmFibGVzIHRoZSBtb2RpZmljYXRpb24gb2YgdGhlIHBhdGgncyBnZW9tZXRyeSBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gICAqIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCwgd2hpY2ggY2FuIGluY2x1ZGUgdHJhbnNsYXRpb25zLCByb3RhdGlvbnMsIHNjYWxpbmcsIGFuZCBza2V3aW5nLlxuICAgKlxuICAgKiBFYWNoIGRyYXdpbmcgaW5zdHJ1Y3Rpb24gaW4gdGhlIHBhdGggaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSB0cmFuc2Zvcm1hdGlvbixcbiAgICogZW5zdXJpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGF0aCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGFwcGxpZWQgbWF0cml4LlxuICAgKlxuICAgKiBOb3RlOiBUaGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgY29vcmRpbmF0ZXMgYW5kIGNvbnRyb2wgcG9pbnRzIG9mIHRoZSBkcmF3aW5nIGluc3RydWN0aW9ucyxcbiAgICogbm90IHRvIHRoZSBwYXRoIGFzIGEgd2hvbGUuIFRoaXMgbWVhbnMgdGhlIHRyYW5zZm9ybWF0aW9uJ3MgZWZmZWN0cyBhcmUgYmFrZWQgaW50byB0aGUgaW5kaXZpZHVhbCBpbnN0cnVjdGlvbnMsXG4gICAqIGFsbG93aW5nIGZvciBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBwYXRoJ3MgYXBwZWFyYW5jZS5cbiAgICogQHBhcmFtIG1hdHJpeCAtIEEgYE1hdHJpeGAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nIGZ1cnRoZXIgb3BlcmF0aW9ucy5cbiAgICovXG4gIHRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICBpZiAobWF0cml4LmlzSWRlbnRpdHkoKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjcHgxID0gMDtcbiAgICBsZXQgY3B5MSA9IDA7XG4gICAgbGV0IGNweDIgPSAwO1xuICAgIGxldCBjcHkyID0gMDtcbiAgICBsZXQgcnggPSAwO1xuICAgIGxldCByeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgc3dpdGNoIChpbnN0cnVjdGlvbi5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcIm1vdmVUb1wiOlxuICAgICAgICBjYXNlIFwibGluZVRvXCI6XG4gICAgICAgICAgeCA9IGRhdGFbMF07XG4gICAgICAgICAgeSA9IGRhdGFbMV07XG4gICAgICAgICAgZGF0YVswXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmV6aWVyQ3VydmVUb1wiOlxuICAgICAgICAgIGNweDEgPSBkYXRhWzBdO1xuICAgICAgICAgIGNweTEgPSBkYXRhWzFdO1xuICAgICAgICAgIGNweDIgPSBkYXRhWzJdO1xuICAgICAgICAgIGNweTIgPSBkYXRhWzNdO1xuICAgICAgICAgIHggPSBkYXRhWzRdO1xuICAgICAgICAgIHkgPSBkYXRhWzVdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogY3B4MSArIGMgKiBjcHkxICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiBjcHgxICsgZCAqIGNweTEgKyB0eTtcbiAgICAgICAgICBkYXRhWzJdID0gYSAqIGNweDIgKyBjICogY3B5MiArIHR4O1xuICAgICAgICAgIGRhdGFbM10gPSBiICogY3B4MiArIGQgKiBjcHkyICsgdHk7XG4gICAgICAgICAgZGF0YVs0XSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzVdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicXVhZHJhdGljQ3VydmVUb1wiOlxuICAgICAgICAgIGNweDEgPSBkYXRhWzBdO1xuICAgICAgICAgIGNweTEgPSBkYXRhWzFdO1xuICAgICAgICAgIHggPSBkYXRhWzJdO1xuICAgICAgICAgIHkgPSBkYXRhWzNdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogY3B4MSArIGMgKiBjcHkxICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiBjcHgxICsgZCAqIGNweTEgKyB0eTtcbiAgICAgICAgICBkYXRhWzJdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgICAgIGRhdGFbM10gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcmNUb1N2Z1wiOlxuICAgICAgICAgIHggPSBkYXRhWzVdO1xuICAgICAgICAgIHkgPSBkYXRhWzZdO1xuICAgICAgICAgIHJ4ID0gZGF0YVswXTtcbiAgICAgICAgICByeSA9IGRhdGFbMV07XG4gICAgICAgICAgZGF0YVswXSA9IGEgKiByeCArIGMgKiByeTtcbiAgICAgICAgICBkYXRhWzFdID0gYiAqIHJ4ICsgZCAqIHJ5O1xuICAgICAgICAgIGRhdGFbNV0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgICAgZGF0YVs2XSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIGRhdGFbNF0gPSBhZGp1c3RUcmFuc2Zvcm0oZGF0YVszXSwgbWF0cml4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgICBkYXRhWzRdID0gYWRqdXN0VHJhbnNmb3JtKGRhdGFbNF0sIG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgZGF0YVs4XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzhdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm91bmRSZWN0XCI6XG4gICAgICAgICAgZGF0YVs1XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzVdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWRkUGF0aFwiOlxuICAgICAgICAgIGRhdGFbMF0udHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb2x5XCI6XG4gICAgICAgICAgZGF0YVsyXSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzJdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdhcm4oXCJ1bmtub3duIHRyYW5zZm9ybSBhY3Rpb25cIiwgaW5zdHJ1Y3Rpb24uYWN0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhcGVQYXRoLmJvdW5kcztcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBpbnN0cnVjdGlvbnMgaW4gdGhlIGBHcmFwaGljc1BhdGhgLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIG9wZXJhdGlvbnMgdGhhdCBkZXBlbmQgb24gdGhlIHBhdGgncyBjdXJyZW50IGVuZHBvaW50LFxuICAgKiBzdWNoIGFzIGNvbm5lY3Rpbmcgc3Vic2VxdWVudCBzaGFwZXMgb3IgcGF0aHMuIEl0IHN1cHBvcnRzIHZhcmlvdXMgZHJhd2luZyBpbnN0cnVjdGlvbnMsXG4gICAqIGVuc3VyaW5nIHRoZSBsYXN0IHBvaW50J3MgcG9zaXRpb24gaXMgYWNjdXJhdGVseSBkZXRlcm1pbmVkIHJlZ2FyZGxlc3Mgb2YgdGhlIHBhdGgncyBjb21wbGV4aXR5LlxuICAgKlxuICAgKiBJZiB0aGUgbGFzdCBpbnN0cnVjdGlvbiBpcyBhIGBjbG9zZVBhdGhgLCB0aGUgbWV0aG9kIGl0ZXJhdGVzIGJhY2t3YXJkIHRocm91Z2ggdGhlIGluc3RydWN0aW9uc1xuICAgKiAgdW50aWwgaXQgZmluZHMgYW4gYWN0aW9uYWJsZSBpbnN0cnVjdGlvbiB0aGF0IGRlZmluZXMgYSBwb2ludCAoZS5nLiwgYG1vdmVUb2AsIGBsaW5lVG9gLFxuICAgKiBgcXVhZHJhdGljQ3VydmVUb2AsIGV0Yy4pLiBGb3IgY29tcG91bmQgcGF0aHMgYWRkZWQgdmlhIGBhZGRQYXRoYCwgaXQgcmVjdXJzaXZlbHkgcmV0cmlldmVzXG4gICAqIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIG5lc3RlZCBwYXRoLlxuICAgKiBAcGFyYW0gb3V0IC0gQSBgUG9pbnRgIG9iamVjdCB3aGVyZSB0aGUgbGFzdCBwb2ludCdzIGNvb3JkaW5hdGVzIHdpbGwgYmUgc3RvcmVkLlxuICAgKiBUaGlzIG9iamVjdCBpcyBtb2RpZmllZCBkaXJlY3RseSB0byBjb250YWluIHRoZSByZXN1bHQuXG4gICAqIEByZXR1cm5zIFRoZSBgUG9pbnRgIG9iamVjdCBjb250YWluaW5nIHRoZSBsYXN0IHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRMYXN0UG9pbnQob3V0KSB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaW5kZXhdO1xuICAgIGlmICghbGFzdEluc3RydWN0aW9uKSB7XG4gICAgICBvdXQueCA9IDA7XG4gICAgICBvdXQueSA9IDA7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB3aGlsZSAobGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJjbG9zZVBhdGhcIikge1xuICAgICAgaW5kZXgtLTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgb3V0LnggPSAwO1xuICAgICAgICBvdXQueSA9IDA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICBsYXN0SW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpbmRleF07XG4gICAgfVxuICAgIHN3aXRjaCAobGFzdEluc3RydWN0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBcIm1vdmVUb1wiOlxuICAgICAgY2FzZSBcImxpbmVUb1wiOlxuICAgICAgICBvdXQueCA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzBdO1xuICAgICAgICBvdXQueSA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJxdWFkcmF0aWNDdXJ2ZVRvXCI6XG4gICAgICAgIG91dC54ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbMl07XG4gICAgICAgIG91dC55ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJlemllckN1cnZlVG9cIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs0XTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs1XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXJjXCI6XG4gICAgICBjYXNlIFwiYXJjVG9TdmdcIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs1XTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs2XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWRkUGF0aFwiOlxuICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVswXS5nZXRMYXN0UG9pbnQob3V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFRyYW5zZm9ybShjdXJyZW50TWF0cml4LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKGN1cnJlbnRNYXRyaXgpIHtcbiAgICByZXR1cm4gY3VycmVudE1hdHJpeC5wcmVwZW5kKHRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybS5jbG9uZSgpO1xufVxuXG5leHBvcnQgeyBHcmFwaGljc1BhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BhdGggfSBmcm9tICcuLi9wYXRoL0dyYXBoaWNzUGF0aC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIFNWR1BhcnNlcihzdmcsIGdyYXBoaWNzQ29udGV4dCkge1xuICBpZiAodHlwZW9mIHN2ZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmlubmVySFRNTCA9IHN2Zy50cmltKCk7XG4gICAgc3ZnID0gZGl2LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIik7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICBjb250ZXh0OiBncmFwaGljc0NvbnRleHQsXG4gICAgcGF0aDogbmV3IEdyYXBoaWNzUGF0aCgpXG4gIH07XG4gIHJlbmRlckNoaWxkcmVuKHN2Zywgc2Vzc2lvbiwgbnVsbCwgbnVsbCk7XG4gIHJldHVybiBncmFwaGljc0NvbnRleHQ7XG59XG5mdW5jdGlvbiByZW5kZXJDaGlsZHJlbihzdmcsIHNlc3Npb24sIGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBzdmcuY2hpbGRyZW47XG4gIGNvbnN0IHsgZmlsbFN0eWxlOiBmMSwgc3Ryb2tlU3R5bGU6IHMxIH0gPSBwYXJzZVN0eWxlKHN2Zyk7XG4gIGlmIChmMSAmJiBmaWxsU3R5bGUpIHtcbiAgICBmaWxsU3R5bGUgPSB7IC4uLmZpbGxTdHlsZSwgLi4uZjEgfTtcbiAgfSBlbHNlIGlmIChmMSkge1xuICAgIGZpbGxTdHlsZSA9IGYxO1xuICB9XG4gIGlmIChzMSAmJiBzdHJva2VTdHlsZSkge1xuICAgIHN0cm9rZVN0eWxlID0geyAuLi5zdHJva2VTdHlsZSwgLi4uczEgfTtcbiAgfSBlbHNlIGlmIChzMSkge1xuICAgIHN0cm9rZVN0eWxlID0gczE7XG4gIH1cbiAgc2Vzc2lvbi5jb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIGxldCB4O1xuICBsZXQgeTtcbiAgbGV0IHgxO1xuICBsZXQgeTE7XG4gIGxldCB4MjtcbiAgbGV0IHkyO1xuICBsZXQgY3g7XG4gIGxldCBjeTtcbiAgbGV0IHI7XG4gIGxldCByeDtcbiAgbGV0IHJ5O1xuICBsZXQgcG9pbnRzO1xuICBsZXQgcG9pbnRzU3RyaW5nO1xuICBsZXQgZDtcbiAgbGV0IGdyYXBoaWNzUGF0aDtcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBzd2l0Y2ggKHN2Zy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICAgIGQgPSBzdmcuZ2V0QXR0cmlidXRlKFwiZFwiKTtcbiAgICAgIGdyYXBoaWNzUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoZCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQucGF0aChncmFwaGljc1BhdGgpO1xuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgY3ggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJjeFwiLCAwKTtcbiAgICAgIGN5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3lcIiwgMCk7XG4gICAgICByID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiclwiLCAwKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5lbGxpcHNlKGN4LCBjeSwgciwgcik7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInhcIiwgMCk7XG4gICAgICB5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieVwiLCAwKTtcbiAgICAgIHdpZHRoID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwid2lkdGhcIiwgMCk7XG4gICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJoZWlnaHRcIiwgMCk7XG4gICAgICByeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInJ4XCIsIDApO1xuICAgICAgcnkgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeVwiLCAwKTtcbiAgICAgIGlmIChyeCB8fCByeSkge1xuICAgICAgICBzZXNzaW9uLmNvbnRleHQucm91bmRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJ4IHx8IHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlc3Npb24uY29udGV4dC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgIGN4ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3hcIiwgMCk7XG4gICAgICBjeSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcImN5XCIsIDApO1xuICAgICAgcnggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeFwiLCAwKTtcbiAgICAgIHJ5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwicnlcIiwgMCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuZWxsaXBzZShjeCwgY3ksIHJ4LCByeSk7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGluZVwiOlxuICAgICAgeDEgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ4MVwiLCAwKTtcbiAgICAgIHkxID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieTFcIiwgMCk7XG4gICAgICB4MiA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcIngyXCIsIDApO1xuICAgICAgeTIgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ5MlwiLCAwKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgIHBvaW50c1N0cmluZyA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIik7XG4gICAgICBwb2ludHMgPSBwb2ludHNTdHJpbmcubWF0Y2goL1xcZCsvZykubWFwKChuKSA9PiBwYXJzZUludChuLCAxMCkpO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LnBvbHkocG9pbnRzLCB0cnVlKTtcbiAgICAgIGlmIChmaWxsU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5maWxsKCk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwb2x5bGluZVwiOlxuICAgICAgcG9pbnRzU3RyaW5nID0gc3ZnLmdldEF0dHJpYnV0ZShcInBvaW50c1wiKTtcbiAgICAgIHBvaW50cyA9IHBvaW50c1N0cmluZy5tYXRjaCgvXFxkKy9nKS5tYXAoKG4pID0+IHBhcnNlSW50KG4sIDEwKSk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQucG9seShwb2ludHMsIGZhbHNlKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwic3ZnXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zb2xlLmluZm8oYFtTVkcgcGFyc2VyXSA8JHtzdmcubm9kZU5hbWV9PiBlbGVtZW50cyB1bnN1cHBvcnRlZGApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICByZW5kZXJDaGlsZHJlbihjaGlsZHJlbltpXSwgc2Vzc2lvbiwgZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBpZCwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbHVlID0gc3ZnLmdldEF0dHJpYnV0ZShpZCk7XG4gIHJldHVybiB2YWx1ZSA/IE51bWJlcih2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN2Zykge1xuICBjb25zdCBzdHlsZSA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB7fTtcbiAgY29uc3QgZmlsbFN0eWxlID0ge307XG4gIGxldCB1c2VGaWxsID0gZmFsc2U7XG4gIGxldCB1c2VTdHJva2UgPSBmYWxzZTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgY29uc3Qgc3R5bGVQYXJ0cyA9IHN0eWxlLnNwbGl0KFwiO1wiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0eWxlUGFydCA9IHN0eWxlUGFydHNbaV07XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBzdHlsZVBhcnQuc3BsaXQoXCI6XCIpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcInN0cm9rZVwiOlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHZhbHVlKS50b051bWJlcigpO1xuICAgICAgICAgICAgdXNlU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJva2Utd2lkdGhcIjpcbiAgICAgICAgICBzdHJva2VTdHlsZS53aWR0aCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdXNlRmlsbCA9IHRydWU7XG4gICAgICAgICAgICBmaWxsU3R5bGUuY29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmlsbC1vcGFjaXR5XCI6XG4gICAgICAgICAgZmlsbFN0eWxlLmFscGhhID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cm9rZS1vcGFjaXR5XCI6XG4gICAgICAgICAgc3Ryb2tlU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib3BhY2l0eVwiOlxuICAgICAgICAgIGZpbGxTdHlsZS5hbHBoYSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgc3Ryb2tlU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJva2UgPSBzdmcuZ2V0QXR0cmlidXRlKFwic3Ryb2tlXCIpO1xuICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlICE9PSBcIm5vbmVcIikge1xuICAgICAgdXNlU3Ryb2tlID0gdHJ1ZTtcbiAgICAgIHN0cm9rZVN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZSkudG9OdW1iZXIoKTtcbiAgICAgIHN0cm9rZVN0eWxlLndpZHRoID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwic3Ryb2tlLXdpZHRoXCIsIDEpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsID0gc3ZnLmdldEF0dHJpYnV0ZShcImZpbGxcIik7XG4gICAgaWYgKGZpbGwgJiYgZmlsbCAhPT0gXCJub25lXCIpIHtcbiAgICAgIHVzZUZpbGwgPSB0cnVlO1xuICAgICAgZmlsbFN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGZpbGwpLnRvTnVtYmVyKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3Ryb2tlU3R5bGU6IHVzZVN0cm9rZSA/IHN0cm9rZVN0eWxlIDogbnVsbCxcbiAgICBmaWxsU3R5bGU6IHVzZUZpbGwgPyBmaWxsU3R5bGUgOiBudWxsXG4gIH07XG59XG5cbmV4cG9ydCB7IFNWR1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHUGFyc2VyLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BhdGggfSBmcm9tICcuL3BhdGgvR3JhcGhpY3NQYXRoLm1qcyc7XG5pbXBvcnQgeyBTVkdQYXJzZXIgfSBmcm9tICcuL3N2Zy9TVkdQYXJzZXIubWpzJztcbmltcG9ydCB7IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSB9IGZyb20gJy4vdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jb25zdCBfR3JhcGhpY3NDb250ZXh0ID0gY2xhc3MgX0dyYXBoaWNzQ29udGV4dCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy51aWQgPSB1aWQoXCJncmFwaGljc0NvbnRleHRcIik7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5iYXRjaE1vZGUgPSBcImF1dG9cIjtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGggPSBuZXcgR3JhcGhpY3NQYXRoKCk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IHsgLi4uX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlIH07XG4gICAgdGhpcy5fc3Ryb2tlU3R5bGUgPSB7IC4uLl9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlIH07XG4gICAgdGhpcy5fc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMuX3RpY2sgPSAwO1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgICB0aGlzLl9ib3VuZHNEaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3NDb250ZXh0IG9iamVjdCB0aGF0IGlzIGEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZSwgY29weWluZyBhbGwgcHJvcGVydGllcyxcbiAgICogaW5jbHVkaW5nIHRoZSBjdXJyZW50IGRyYXdpbmcgc3RhdGUsIHRyYW5zZm9ybWF0aW9ucywgc3R5bGVzLCBhbmQgaW5zdHJ1Y3Rpb25zLlxuICAgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljc0NvbnRleHQgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFuZCBzdGF0ZSBhcyB0aGlzIG9uZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IF9HcmFwaGljc0NvbnRleHQoKTtcbiAgICBjbG9uZS5iYXRjaE1vZGUgPSB0aGlzLmJhdGNoTW9kZTtcbiAgICBjbG9uZS5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5zbGljZSgpO1xuICAgIGNsb25lLl9hY3RpdmVQYXRoID0gdGhpcy5fYWN0aXZlUGF0aC5jbG9uZSgpO1xuICAgIGNsb25lLl90cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKTtcbiAgICBjbG9uZS5fZmlsbFN0eWxlID0geyAuLi50aGlzLl9maWxsU3R5bGUgfTtcbiAgICBjbG9uZS5fc3Ryb2tlU3R5bGUgPSB7IC4uLnRoaXMuX3N0cm9rZVN0eWxlIH07XG4gICAgY2xvbmUuX3N0YXRlU3RhY2sgPSB0aGlzLl9zdGF0ZVN0YWNrLnNsaWNlKCk7XG4gICAgY2xvbmUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcy5jbG9uZSgpO1xuICAgIGNsb25lLl9ib3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBmaWxsIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGlzIGNhbiBiZSBhIGNvbG9yLCBncmFkaWVudCwgcGF0dGVybiwgb3IgYSBtb3JlIGNvbXBsZXggc3R5bGUgZGVmaW5lZCBieSBhIEZpbGxTdHlsZSBvYmplY3QuXG4gICAqL1xuICBnZXQgZmlsbFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsU3R5bGU7XG4gIH1cbiAgc2V0IGZpbGxTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSh2YWx1ZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBTaW1pbGFyIHRvIGZpbGwgc3R5bGVzLCBzdHJva2Ugc3R5bGVzIGNhbiBlbmNvbXBhc3MgY29sb3JzLCBncmFkaWVudHMsIHBhdHRlcm5zLCBvciBtb3JlIGRldGFpbGVkIGNvbmZpZ3VyYXRpb25zIHZpYSBhIFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICovXG4gIGdldCBzdHJva2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlU3R5bGU7XG4gIH1cbiAgc2V0IHN0cm9rZVN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3Ryb2tlU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBmaWxsIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGUgZmlsbCBzdHlsZSBjYW4gYmUgYSBjb2xvciwgZ3JhZGllbnQsXG4gICAqIHBhdHRlcm4sIG9yIGEgbW9yZSBjb21wbGV4IHN0eWxlIGRlZmluZWQgYnkgYSBGaWxsU3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgZmlsbCBzdHlsZSB0byBhcHBseS4gVGhpcyBjYW4gYmUgYSBzaW1wbGUgY29sb3IsIGEgZ3JhZGllbnQgb3IgcGF0dGVybiBvYmplY3QsXG4gICAqICAgICAgICAgICAgICAgIG9yIGEgRmlsbFN0eWxlIG9yIENvbnZlcnRlZEZpbGxTdHlsZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNldEZpbGxTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShzdHlsZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUgb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuIFNpbWlsYXIgdG8gZmlsbCBzdHlsZXMsIHN0cm9rZSBzdHlsZXMgY2FuXG4gICAqIGVuY29tcGFzcyBjb2xvcnMsIGdyYWRpZW50cywgcGF0dGVybnMsIG9yIG1vcmUgZGV0YWlsZWQgY29uZmlndXJhdGlvbnMgdmlhIGEgU3Ryb2tlU3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3Ryb2tlIHN0eWxlIHRvIGFwcGx5LiBDYW4gYmUgZGVmaW5lZCBhcyBhIGNvbG9yLCBhIGdyYWRpZW50IG9yIHBhdHRlcm4sXG4gICAqICAgICAgICAgICAgICAgIG9yIGEgU3Ryb2tlU3R5bGUgb3IgQ29udmVydGVkU3Ryb2tlU3R5bGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzZXRTdHJva2VTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlKHN0eWxlLCBfR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGV4dHVyZSh0ZXh0dXJlLCB0aW50LCBkeCwgZHksIGR3LCBkaCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcInRleHR1cmVcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaW1hZ2U6IHRleHR1cmUsXG4gICAgICAgIGR4OiBkeCB8fCAwLFxuICAgICAgICBkeTogZHkgfHwgMCxcbiAgICAgICAgZHc6IGR3IHx8IHRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICAgIGRoOiBkaCB8fCB0ZXh0dXJlLmZyYW1lLmhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSxcbiAgICAgICAgYWxwaGE6IHRoaXMuX2ZpbGxTdHlsZS5hbHBoYSxcbiAgICAgICAgc3R5bGU6IHRpbnQgPyBDb2xvci5zaGFyZWQuc2V0VmFsdWUodGludCkudG9OdW1iZXIoKSA6IDE2Nzc3MjE1XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgcGF0aC4gQW55IHByZXZpb3VzIHBhdGggYW5kIGl0cyBjb21tYW5kcyBhcmUgZGlzY2FyZGVkIGFuZCBhIG5ldyBwYXRoIGlzXG4gICAqIHN0YXJ0ZWQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBiZWZvcmUgYmVnaW5uaW5nIGEgbmV3IHNoYXBlIG9yIHNlcmllcyBvZiBkcmF3aW5nIGNvbW1hbmRzLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBiZWdpblBhdGgoKSB7XG4gICAgdGhpcy5fYWN0aXZlUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaWxsKHN0eWxlLCBhbHBoYSkge1xuICAgIGxldCBwYXRoO1xuICAgIGNvbnN0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0aGlzLl90aWNrID09PSAwICYmIGxhc3RJbnN0cnVjdGlvbiAmJiBsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBwYXRoID0gbGFzdEluc3RydWN0aW9uLmRhdGEucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAoYWxwaGEgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc3R5bGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzQ29udGV4dC5maWxsKGNvbG9yLCBhbHBoYSkgaXMgZGVwcmVjYXRlZCwgdXNlIEdyYXBoaWNzQ29udGV4dC5maWxsKHsgY29sb3IsIGFscGhhIH0pIGluc3RlYWRcIik7XG4gICAgICAgIHN0eWxlID0geyBjb2xvcjogc3R5bGUsIGFscGhhIH07XG4gICAgICB9XG4gICAgICB0aGlzLl9maWxsU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUoc3R5bGUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcImZpbGxcIixcbiAgICAgIC8vIFRPRE8gY29weSBmaWxsIHN0eWxlIVxuICAgICAgZGF0YTogeyBzdHlsZTogdGhpcy5maWxsU3R5bGUsIHBhdGggfVxuICAgIH0pO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICB0aGlzLl9pbml0TmV4dFBhdGhMb2NhdGlvbigpO1xuICAgIHRoaXMuX3RpY2sgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0TmV4dFBhdGhMb2NhdGlvbigpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX2FjdGl2ZVBhdGguZ2V0TGFzdFBvaW50KFBvaW50LnNoYXJlZCk7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5jbGVhcigpO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgubW92ZVRvKHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBTdHJva2VzIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuIFRoaXMgbWV0aG9kIGNhbiB0YWtlIGFuIG9wdGlvbmFsXG4gICAqIEZpbGxTdHlsZUlucHV0cyBwYXJhbWV0ZXIgdG8gZGVmaW5lIHRoZSBzdHJva2UncyBhcHBlYXJhbmNlLCBpbmNsdWRpbmcgaXRzIGNvbG9yLCB3aWR0aCwgYW5kIG90aGVyIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBzdHlsZSAtIChPcHRpb25hbCkgVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBzaW1wbGUgY29sb3Igb3IgYSBtb3JlIGNvbXBsZXggc3R5bGUgb2JqZWN0LiBJZiBvbWl0dGVkLCB1c2VzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc3Ryb2tlKHN0eWxlKSB7XG4gICAgbGV0IHBhdGg7XG4gICAgY29uc3QgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRoaXMuX3RpY2sgPT09IDAgJiYgbGFzdEluc3RydWN0aW9uICYmIGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICBwYXRoID0gbGFzdEluc3RydWN0aW9uLmRhdGEucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB0aGlzLl9zdHJva2VTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShzdHlsZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgIGFjdGlvbjogXCJzdHJva2VcIixcbiAgICAgIC8vIFRPRE8gY29weSBmaWxsIHN0eWxlIVxuICAgICAgZGF0YTogeyBzdHlsZTogdGhpcy5zdHJva2VTdHlsZSwgcGF0aCB9XG4gICAgfSk7XG4gICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgIHRoaXMuX2luaXROZXh0UGF0aExvY2F0aW9uKCk7XG4gICAgdGhpcy5fdGljayA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjdXRvdXQgdG8gdGhlIGxhc3QgZHJhd24gc2hhcGUuIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgaG9sZXMgb3IgY29tcGxleCBzaGFwZXMgYnlcbiAgICogc3VidHJhY3RpbmcgYSBwYXRoIGZyb20gdGhlIHByZXZpb3VzbHkgZHJhd24gcGF0aC4gSWYgYSBob2xlIGlzIG5vdCBjb21wbGV0ZWx5IGluIGEgc2hhcGUsIGl0IHdpbGxcbiAgICogZmFpbCB0byBjdXQgY29ycmVjdGx5IVxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBjdXQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGNvbnN0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgIGNvbnN0IGhvbGVQYXRoID0gdGhpcy5fYWN0aXZlUGF0aC5jbG9uZSgpO1xuICAgICAgaWYgKGxhc3RJbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAobGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIiB8fCBsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcImZpbGxcIikge1xuICAgICAgICAgIGlmIChsYXN0SW5zdHJ1Y3Rpb24uZGF0YS5ob2xlKSB7XG4gICAgICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YS5ob2xlLmFkZFBhdGgoaG9sZVBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YS5ob2xlID0gaG9sZVBhdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW5pdE5leHRQYXRoTG9jYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhcmMgdG8gdGhlIGN1cnJlbnQgcGF0aCwgd2hpY2ggaXMgY2VudGVyZWQgYXQgKHgsIHkpIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMsXG4gICAqIHN0YXJ0aW5nIGFuZCBlbmRpbmcgYW5nbGVzLCBhbmQgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGNlbnRlci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBjZW50ZXIuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgYXJjJ3MgcmFkaXVzLlxuICAgKiBAcGFyYW0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIGNvdW50ZXJjbG9ja3dpc2UgLSAoT3B0aW9uYWwpIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBhcmMgaXMgZHJhd24gY291bnRlcmNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBhcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlcmNsb2Nrd2lzZSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguYXJjKFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5LFxuICAgICAgcmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgY291bnRlcmNsb2Nrd2lzZVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgZ2l2ZW4gY29udHJvbCBwb2ludHMgYW5kIHJhZGl1cywgY29ubmVjdGVkIHRvIHRoZSBwcmV2aW91cyBwb2ludFxuICAgKiBieSBhIHN0cmFpZ2h0IGxpbmUgaWYgbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0geDEgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHkyIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgYXJjJ3MgcmFkaXVzLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5hcmNUbyhcbiAgICAgIHQuYSAqIHgxICsgdC5jICogeTEgKyB0LnR4LFxuICAgICAgdC5iICogeDEgKyB0LmQgKiB5MSArIHQudHksXG4gICAgICB0LmEgKiB4MiArIHQuYyAqIHkyICsgdC50eCxcbiAgICAgIHQuYiAqIHgyICsgdC5kICogeTIgKyB0LnR5LFxuICAgICAgcmFkaXVzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBTVkctc3R5bGUgYXJjIHRvIHRoZSBwYXRoLCBhbGxvd2luZyBmb3IgZWxsaXB0aWNhbCBhcmNzIGJhc2VkIG9uIHRoZSBTVkcgc3BlYy5cbiAgICogQHBhcmFtIHJ4IC0gVGhlIHgtcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gcnkgLSBUaGUgeS1yYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB4QXhpc1JvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBlbGxpcHNlJ3MgeC1heGlzIHJlbGF0aXZlXG4gICAqIHRvIHRoZSB4LWF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtLCBpbiBkZWdyZWVzLlxuICAgKiBAcGFyYW0gbGFyZ2VBcmNGbGFnIC0gRGV0ZXJtaW5lcyBpZiB0aGUgYXJjIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgbGVzcyB0aGFuIDE4MCBkZWdyZWVzLlxuICAgKiBAcGFyYW0gc3dlZXBGbGFnIC0gRGV0ZXJtaW5lcyBpZiB0aGUgYXJjIHNob3VsZCBiZSBzd2VwdCBpbiBhIHBvc2l0aXZlIGFuZ2xlIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgZW5kIHBvaW50LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFyY1RvU3ZnKHJ4LCByeSwgeEF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmFyY1RvU3ZnKFxuICAgICAgcngsXG4gICAgICByeSxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICAvLyBzaG91bGQgd2Ugcm90YXRlIHRoaXMgd2l0aCB0cmFuc2Zvcm0/P1xuICAgICAgbGFyZ2VBcmNGbGFnLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGN1YmljIEJlemllciBjdXJ2ZSB0byB0aGUgcGF0aC5cbiAgICogSXQgcmVxdWlyZXMgdGhyZWUgcG9pbnRzOiB0aGUgZmlyc3QgdHdvIGFyZSBjb250cm9sIHBvaW50cyBhbmQgdGhlIHRoaXJkIG9uZSBpcyB0aGUgZW5kIHBvaW50LlxuICAgKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgaW4gdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIGNwMXggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AxeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHksIHNtb290aG5lc3MpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmJlemllckN1cnZlVG8oXG4gICAgICB0LmEgKiBjcDF4ICsgdC5jICogY3AxeSArIHQudHgsXG4gICAgICB0LmIgKiBjcDF4ICsgdC5kICogY3AxeSArIHQudHksXG4gICAgICB0LmEgKiBjcDJ4ICsgdC5jICogY3AyeSArIHQudHgsXG4gICAgICB0LmIgKiBjcDJ4ICsgdC5kICogY3AyeSArIHQudHksXG4gICAgICB0LmEgKiB4ICsgdC5jICogeSArIHQudHgsXG4gICAgICB0LmIgKiB4ICsgdC5kICogeSArIHQudHksXG4gICAgICBzbW9vdGhuZXNzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoPy5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYW4gZWxsaXBzZSBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIGFuZCB3aXRoIHRoZSBnaXZlbiB4IGFuZCB5IHJhZGlpLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgYWxsb3dpbmcgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1ggLSBUaGUgaG9yaXpvbnRhbCByYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByYWRpdXNZIC0gVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBlbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1kpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5lbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBjaXJjbGUgc2hhcGUuIFRoaXMgbWV0aG9kIGFkZHMgYSBuZXcgY2lyY2xlIHBhdGggdG8gdGhlIGN1cnJlbnQgZHJhd2luZy5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguY2lyY2xlKHgsIHksIHJhZGl1cywgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgYEdyYXBoaWNzUGF0aGAgdG8gdGhpcyBwYXRoLCBvcHRpb25hbGx5IGFwcGx5aW5nIGEgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIHRvIGFkZC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBwYXRoKHBhdGgpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5hZGRQYXRoKHBhdGgsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIGN1cnJlbnQgcG9pbnQgdG8gYSBuZXcgcG9pbnQgd2l0aCBhIHN0cmFpZ2h0IGxpbmUuIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9pbnQgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9pbnQgdG8gY29ubmVjdCB0by5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgubGluZVRvKFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGEgbmV3IHN1Yi1wYXRoLiBBbnkgc3Vic2VxdWVudCBkcmF3aW5nIGNvbW1hbmRzIGFyZSBjb25zaWRlcmVkIHBhcnQgb2YgdGhpcyBwYXRoLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIGZvciB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLl9hY3RpdmVQYXRoLmluc3RydWN0aW9ucztcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFggPSB0LmEgKiB4ICsgdC5jICogeSArIHQudHg7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRZID0gdC5iICogeCArIHQuZCAqIHkgKyB0LnR5O1xuICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxICYmIGluc3RydWN0aW9uc1swXS5hY3Rpb24gPT09IFwibW92ZVRvXCIpIHtcbiAgICAgIGluc3RydWN0aW9uc1swXS5kYXRhWzBdID0gdHJhbnNmb3JtZWRYO1xuICAgICAgaW5zdHJ1Y3Rpb25zWzBdLmRhdGFbMV0gPSB0cmFuc2Zvcm1lZFk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5tb3ZlVG8oXG4gICAgICB0cmFuc2Zvcm1lZFgsXG4gICAgICB0cmFuc2Zvcm1lZFlcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcXVhZHJhdGljIGN1cnZlIHRvIHRoZSBwYXRoLiBJdCByZXF1aXJlcyB0d28gcG9pbnRzOiB0aGUgY29udHJvbCBwb2ludCBhbmQgdGhlIGVuZCBwb2ludC5cbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3B5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RobmVzcyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHksIHNtb290aG5lc3MpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICB0LmEgKiBjcHggKyB0LmMgKiBjcHkgKyB0LnR4LFxuICAgICAgdC5iICogY3B4ICsgdC5kICogY3B5ICsgdC50eSxcbiAgICAgIHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eCxcbiAgICAgIHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eSxcbiAgICAgIHNtb290aG5lc3NcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyByZWN0YW5nbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yZWN0KHgsIHksIHcsIGgsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuXG4gICAqIFRoZSBjb3JuZXIgcmFkaXVzIGNhbiBiZSBzcGVjaWZpZWQgdG8gZGV0ZXJtaW5lIGhvdyByb3VuZGVkIHRoZSBjb3JuZXJzIHNob3VsZCBiZS5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGFwcGxpZWQsIHdoaWNoIGFsbG93cyBmb3Igcm90YXRpb24sIHNjYWxpbmcsIGFuZCB0cmFuc2xhdGlvbiBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSdzIGNvcm5lcnMuIElmIG5vdCBzcGVjaWZpZWQsIGNvcm5lcnMgd2lsbCBiZSBzaGFycC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGl1cywgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHBvbHlnb24gc2hhcGUgYnkgc3BlY2lmeWluZyBhIHNlcXVlbmNlIG9mIHBvaW50cy4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2YgY29tcGxleCBwb2x5Z29ucyxcbiAgICogd2hpY2ggY2FuIGJlIGJvdGggb3BlbiBhbmQgY2xvc2VkLiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgZW5hYmxpbmcgdGhlIHBvbHlnb24gdG8gYmUgc2NhbGVkLFxuICAgKiByb3RhdGVkLCBvciB0cmFuc2xhdGVkIGFzIG5lZWRlZC5cbiAgICogQHBhcmFtIHBvaW50cyAtIEFuIGFycmF5IG9mIG51bWJlcnMsIG9yIGFuIGFycmF5IG9mIFBvaW50RGF0YSBvYmplY3RzIGVnIFt7eCx5fSwge3gseX0sIHt4LHl9XVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMsIG9mIHRoZSBwb2x5Z29uJ3MgdmVydGljZXMsIGluIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0gY2xvc2UgLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNsb3NlIHRoZSBwb2x5Z29uIHBhdGguIFRydWUgYnkgZGVmYXVsdC5cbiAgICovXG4gIHBvbHkocG9pbnRzLCBjbG9zZSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnBvbHkocG9pbnRzLCBjbG9zZSwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlZ3VsYXIgcG9seWdvbiB3aXRoIGEgc3BlY2lmaWVkIG51bWJlciBvZiBzaWRlcy4gQWxsIHNpZGVzIGFuZCBhbmdsZXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgcG9seWdvbiwgaW4gcmFkaWFucy4gWmVybyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24gPSAwLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yZWd1bGFyUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCByb3RhdGlvbiwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBTaW1pbGFyIHRvIGByZWd1bGFyUG9seWAgYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gcm91bmQgdGhlIGNvcm5lcnMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmN1bXNjcmliZWQgY2lyY2xlIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gc2lkZXMgLSBUaGUgbnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBNdXN0IGJlIDMgb3IgbW9yZS5cbiAgICogQHBhcmFtIGNvcm5lciAtIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kaW5nIG9mIHRoZSBjb3JuZXJzLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgY29ybmVyLCByb3RhdGlvbikge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnJvdW5kUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCBjb3JuZXIsIHJvdGF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzaGFwZSB3aXRoIHJvdW5kZWQgY29ybmVycy4gVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjdXN0b20gcmFkaXVzIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgc2hhcGUuXG4gICAqIE9wdGlvbmFsbHksIGNvcm5lcnMgY2FuIGJlIHJvdW5kZWQgdXNpbmcgYSBxdWFkcmF0aWMgY3VydmUgaW5zdGVhZCBvZiBhbiBhcmMsIHByb3ZpZGluZyBhIGRpZmZlcmVudCBhZXN0aGV0aWMuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBgUm91bmRlZFBvaW50YCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHNoYXBlIHRvIGRyYXcuXG4gICAqIEEgbWluaW11bSBvZiAzIHBvaW50cyBpcyByZXF1aXJlZC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBkZWZhdWx0IHJhZGl1cyBmb3IgdGhlIGNvcm5lcnMuXG4gICAqIFRoaXMgcmFkaXVzIGlzIGFwcGxpZWQgdG8gYWxsIGNvcm5lcnMgdW5sZXNzIG92ZXJyaWRkZW4gaW4gYHBvaW50c2AuXG4gICAqIEBwYXJhbSB1c2VRdWFkcmF0aWMgLSBJZiBzZXQgdG8gdHJ1ZSwgcm91bmRlZCBjb3JuZXJzIGFyZSBkcmF3biB1c2luZyBhIHF1YWRyYXRpY0N1cnZlXG4gICAqICBtZXRob2QgaW5zdGVhZCBvZiBhbiBhcmMgbWV0aG9kLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBTcGVjaWZpZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlIHdoZW4gYHVzZVF1YWRyYXRpY2AgaXMgdHJ1ZS5cbiAgICogSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBjdXJ2ZSBzbW9vdGhlci5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFNoYXBlKHBvaW50cywgcmFkaXVzLCB1c2VRdWFkcmF0aWMsIHNtb290aG5lc3MpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yb3VuZFNoYXBlKHBvaW50cywgcmFkaXVzLCB1c2VRdWFkcmF0aWMsIHNtb290aG5lc3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IFJlY3RhbmdsZSB3aXRoIGZpbGxldCBjb3JuZXJzLiBUaGlzIGlzIG11Y2ggbGlrZSByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBob3dldmVyIGl0IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVycyBhcyB3ZWxsIGZvciB0aGUgY29ybmVyIHJhZGl1cy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGZpbGxldCAtIGFjY2VwdCBuZWdhdGl2ZSBvciBwb3NpdGl2ZSB2YWx1ZXNcbiAgICovXG4gIGZpbGxldFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgZmlsbGV0KSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguZmlsbGV0UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IFJlY3RhbmdsZSB3aXRoIGNoYW1mZXIgY29ybmVycy4gVGhlc2UgYXJlIGFuZ2xlZCBjb3JuZXJzLlxuICAgKiBAcGFyYW0geCAtIFVwcGVyIGxlZnQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHkgLSBVcHBlciByaWdodCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiByZWN0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgcmVjdFxuICAgKiBAcGFyYW0gY2hhbWZlciAtIG5vbi16ZXJvIHJlYWwgbnVtYmVyLCBzaXplIG9mIGNvcm5lciBjdXRvdXRcbiAgICogQHBhcmFtIHRyYW5zZm9ybVxuICAgKi9cbiAgY2hhbWZlclJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbWZlciwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguY2hhbWZlclJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbWZlciwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IGEgc3BlY2lmaWVkIGxvY2F0aW9uLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvblxuICAgKiAgb2Ygc3RhcnMgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBwb2ludHMsIG91dGVyIHJhZGl1cywgb3B0aW9uYWwgaW5uZXIgcmFkaXVzLCBhbmQgcm90YXRpb24uXG4gICAqIFRoZSBzdGFyIGlzIGRyYXduIGFzIGEgY2xvc2VkIHBvbHlnb24gd2l0aCBhbHRlcm5hdGluZyBvdXRlciBhbmQgaW5uZXIgdmVydGljZXMgdG8gY3JlYXRlIHRoZSBzdGFyJ3MgcG9pbnRzLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCB0byBzY2FsZSwgcm90YXRlLCBvciB0cmFuc2xhdGUgdGhlIHN0YXIgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgbnVtYmVyIG9mIHBvaW50cyBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIgKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgb3V0ZXIgcG9pbnRzKS5cbiAgICogQHBhcmFtIGlubmVyUmFkaXVzIC0gT3B0aW9uYWwuIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN0YXJcbiAgICogKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgaW5uZXIgcG9pbnRzIGJldHdlZW4gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gaGFsZiBvZiB0aGUgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIE9wdGlvbmFsLiBUaGUgcm90YXRpb24gb2YgdGhlIHN0YXIgaW4gcmFkaWFucywgd2hlcmUgMCBpcyBhbGlnbmVkIHdpdGggdGhlIHktYXhpcy5cbiAgICogRGVmYXVsdHMgdG8gMCwgbWVhbmluZyBvbmUgcG9pbnQgaXMgZGlyZWN0bHkgdXB3YXJkLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZyBmdXJ0aGVyIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqL1xuICBzdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cyA9IDAsIHJvdGF0aW9uID0gMCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnN0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzLCByb3RhdGlvbiwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIHJlbmRlcnMgYW4gU1ZHIHN0cmluZyBpbnRvIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGlzIGFsbG93cyBmb3IgY29tcGxleCBzaGFwZXMgYW5kIHBhdGhzXG4gICAqIGRlZmluZWQgaW4gU1ZHIGZvcm1hdCB0byBiZSBkcmF3biB3aXRoaW4gdGhlIGdyYXBoaWNzIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBUaGUgU1ZHIHN0cmluZyB0byBiZSBwYXJzZWQgYW5kIHJlbmRlcmVkLlxuICAgKi9cbiAgc3ZnKHN2Zykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBTVkdQYXJzZXIoc3ZnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIG1vc3QgcmVjZW50bHkgc2F2ZWQgZ3JhcGhpY3Mgc3RhdGUgYnkgcG9wcGluZyB0aGUgdG9wIG9mIHRoZSBncmFwaGljcyBzdGF0ZSBzdGFjay5cbiAgICogVGhpcyBpbmNsdWRlcyB0cmFuc2Zvcm1hdGlvbnMsIGZpbGwgc3R5bGVzLCBhbmQgc3Ryb2tlIHN0eWxlcy5cbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtO1xuICAgICAgdGhpcy5fZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgICAgdGhpcy5fc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIFNhdmVzIHRoZSBjdXJyZW50IGdyYXBoaWNzIHN0YXRlLCBpbmNsdWRpbmcgdHJhbnNmb3JtYXRpb25zLCBmaWxsIHN0eWxlcywgYW5kIHN0cm9rZSBzdHlsZXMsIG9udG8gYSBzdGFjay4gKi9cbiAgc2F2ZSgpIHtcbiAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2goe1xuICAgICAgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSxcbiAgICAgIGZpbGxTdHlsZTogeyAuLi50aGlzLl9maWxsU3R5bGUgfSxcbiAgICAgIHN0cm9rZVN0eWxlOiB7IC4uLnRoaXMuX3N0cm9rZVN0eWxlIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICovXG4gIGdldFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHRoZSBpZGVudGl0eSBtYXRyaXgsIGVmZmVjdGl2ZWx5IHJlbW92aW5nIGFueSB0cmFuc2Zvcm1hdGlvbnMgKHJvdGF0aW9uLCBzY2FsaW5nLCB0cmFuc2xhdGlvbikgcHJldmlvdXNseSBhcHBsaWVkLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICByZXNldFRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBncmFwaGljcyBjb250ZXh0IGFyb3VuZCB0aGUgY3VycmVudCBvcmlnaW4uXG4gICAqIEBwYXJhbSBhbmdsZSAtIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICByb3RhdGUoYW5nbGUpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0ucm90YXRlKGFuZ2xlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHNjYWxpbmcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGdyYXBoaWNzIGNvbnRleHQsIHNjYWxpbmcgZHJhd2luZ3MgYnkgeCBob3Jpem9udGFsbHkgYW5kIGJ5IHkgdmVydGljYWxseS5cbiAgICogQHBhcmFtIHggLSBUaGUgc2NhbGUgZmFjdG9yIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHkgLSAoT3B0aW9uYWwpIFRoZSBzY2FsZSBmYWN0b3IgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHggdmFsdWUgaXMgdXNlZCBmb3IgYm90aCBkaXJlY3Rpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzY2FsZSh4LCB5ID0geCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybS5zY2FsZSh4LCB5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZHgsIGR5KSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybS5zZXQoYS5hLCBhLmIsIGEuYywgYS5kLCBhLnR4LCBhLnR5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl90cmFuc2Zvcm0uc2V0KGEsIGIsIGMsIGQsIGR4LCBkeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGR4LCBkeSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0uYXBwZW5kKGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRlbXBNYXRyaXguc2V0KGEsIGIsIGMsIGQsIGR4LCBkeSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtLmFwcGVuZCh0ZW1wTWF0cml4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHRyYW5zbGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBncmFwaGljcyBjb250ZXh0LCBtb3ZpbmcgdGhlIG9yaWdpbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXG4gICAqIEBwYXJhbSB4IC0gVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geSAtIChPcHRpb25hbCkgVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHggdmFsdWUgaXMgdXNlZCBmb3IgYm90aCBkaXJlY3Rpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICB0cmFuc2xhdGUoeCwgeSA9IHgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0udHJhbnNsYXRlKHgsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGRyYXdpbmcgY29tbWFuZHMgZnJvbSB0aGUgZ3JhcGhpY3MgY29udGV4dCwgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIGl0LiBUaGlzIGluY2x1ZGVzIGNsZWFyaW5nIHRoZSBwYXRoLFxuICAgKiBhbmQgb3B0aW9uYWxseSByZXNldHRpbmcgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBpZGVudGl0eSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvblVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcywgMTYpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKiogVGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZS4gKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBpZiAoIXRoaXMuX2JvdW5kc0RpcnR5KVxuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGluc3RydWN0aW9uLmFjdGlvbjtcbiAgICAgIGlmIChhY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBib3VuZHMuYWRkQm91bmRzKGRhdGEucGF0aC5ib3VuZHMpO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBib3VuZHMuYWRkRnJhbWUoZGF0YS5keCwgZGF0YS5keSwgZGF0YS5keCArIGRhdGEuZHcsIGRhdGEuZHkgKyBkYXRhLmRoLCBkYXRhLnRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gZGF0YS5zdHlsZS53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IF9ib3VuZHMgPSBkYXRhLnBhdGguYm91bmRzO1xuICAgICAgICBib3VuZHMuYWRkRnJhbWUoXG4gICAgICAgICAgX2JvdW5kcy5taW5YIC0gcGFkZGluZyxcbiAgICAgICAgICBfYm91bmRzLm1pblkgLSBwYWRkaW5nLFxuICAgICAgICAgIF9ib3VuZHMubWF4WCArIHBhZGRpbmcsXG4gICAgICAgICAgX2JvdW5kcy5tYXhZICsgcGFkZGluZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSBwb2ludCAtIFBvaW50IHRvIGNoZWNrIGlmIGl0J3MgY29udGFpbmVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGdlb21ldHJ5LlxuICAgKi9cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGlmICghdGhpcy5ib3VuZHMuY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICBsZXQgaGFzSGl0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2tdO1xuICAgICAgY29uc3QgZGF0YSA9IGluc3RydWN0aW9uLmRhdGE7XG4gICAgICBjb25zdCBwYXRoID0gZGF0YS5wYXRoO1xuICAgICAgaWYgKCFpbnN0cnVjdGlvbi5hY3Rpb24gfHwgIXBhdGgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgICAgY29uc3Qgc2hhcGVzID0gcGF0aC5zaGFwZVBhdGguc2hhcGVQcmltaXRpdmVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZXNbaV0uc2hhcGU7XG4gICAgICAgIGlmICghc3R5bGUgfHwgIXNoYXBlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzaGFwZXNbaV0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdG1wUG9pbnQpIDogcG9pbnQ7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgaGFzSGl0ID0gc2hhcGUuY29udGFpbnModHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0hpdCA9IHNoYXBlLnN0cm9rZUNvbnRhaW5zKHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBzdHlsZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9sZXMgPSBkYXRhLmhvbGU7XG4gICAgICAgIGlmIChob2xlcykge1xuICAgICAgICAgIGNvbnN0IGhvbGVTaGFwZXMgPSBob2xlcy5zaGFwZVBhdGg/LnNoYXBlUHJpbWl0aXZlcztcbiAgICAgICAgICBpZiAoaG9sZVNoYXBlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBob2xlU2hhcGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChob2xlU2hhcGVzW2pdLnNoYXBlLmNvbnRhaW5zKHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIGhhc0hpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIaXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzSGl0O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3NEYXRhIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlP1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgc291cmNlIG9mIHRoZSBmaWxsL3N0cm9rZSBzdHlsZT9cbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmU7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95VGV4dHVyZVNvdXJjZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlU291cmNlO1xuICAgICAgaWYgKHRoaXMuX2ZpbGxTdHlsZS50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0cm9rZVN0eWxlLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlU3R5bGUudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmlsbFN0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9zdHJva2VTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGggPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGVTdGFjayA9IG51bGw7XG4gICAgdGhpcy5jdXN0b21TaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG51bGw7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgZmlsbCBzdHlsZSB0byB1c2Ugd2hlbiBub25lIGlzIHByb3ZpZGVkLiAqL1xuX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlID0ge1xuICAvKiogVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIGNvbG9yOiAxNjc3NzIxNSxcbiAgLyoqIFRoZSBhbHBoYSB2YWx1ZSB0byB1c2UgZm9yIHRoZSBmaWxsLiAqL1xuICBhbHBoYTogMSxcbiAgLyoqIFRoZSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gIC8qKiBUaGUgbWF0cml4IHRvIGFwcGx5LiAqL1xuICBtYXRyaXg6IG51bGwsXG4gIC8qKiBUaGUgZmlsbCBwYXR0ZXJuIHRvIHVzZS4gKi9cbiAgZmlsbDogbnVsbFxufTtcbi8qKiBUaGUgZGVmYXVsdCBzdHJva2Ugc3R5bGUgdG8gdXNlIHdoZW4gbm9uZSBpcyBwcm92aWRlZC4gKi9cbl9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlID0ge1xuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UuICovXG4gIHdpZHRoOiAxLFxuICAvKiogVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIHN0cm9rZS4gKi9cbiAgY29sb3I6IDE2Nzc3MjE1LFxuICAvKiogVGhlIGFscGhhIHZhbHVlIHRvIHVzZSBmb3IgdGhlIHN0cm9rZS4gKi9cbiAgYWxwaGE6IDEsXG4gIC8qKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBzdHJva2UuICovXG4gIGFsaWdubWVudDogMC41LFxuICAvKiogVGhlIG1pdGVyIGxpbWl0IHRvIHVzZS4gKi9cbiAgbWl0ZXJMaW1pdDogMTAsXG4gIC8qKiBUaGUgbGluZSBjYXAgc3R5bGUgdG8gdXNlLiAqL1xuICBjYXA6IFwiYnV0dFwiLFxuICAvKiogVGhlIGxpbmUgam9pbiBzdHlsZSB0byB1c2UuICovXG4gIGpvaW46IFwibWl0ZXJcIixcbiAgLyoqIFRoZSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gIC8qKiBUaGUgbWF0cml4IHRvIGFwcGx5LiAqL1xuICBtYXRyaXg6IG51bGwsXG4gIC8qKiBUaGUgZmlsbCBwYXR0ZXJuIHRvIHVzZS4gKi9cbiAgZmlsbDogbnVsbFxufTtcbmxldCBHcmFwaGljc0NvbnRleHQgPSBfR3JhcGhpY3NDb250ZXh0O1xuXG5leHBvcnQgeyBHcmFwaGljc0NvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzQ29udGV4dC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6653\n')},4108:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  hJ: () => (/* binding */ GraphicsContextSystem)\n});\n\n// UNUSED EXPORTS: GpuGraphicsContext, GraphicsContextRenderData\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs\nvar BatchGeometry = __webpack_require__(2971);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(3018);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs + 3 modules\nvar Batcher = __webpack_require__(2067);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs\n\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=buildUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs\n\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\n\n//# sourceMappingURL=transformVertices.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\nvar BatchableGraphics = __webpack_require__(26);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs\n\nconst buildCircle = {\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === "circle") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === "ellipse") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs\n\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs\n\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\n\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs\n\n\n\n\n"use strict";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point/* Point */.E(points[0], points[1]);\n  const lastPoint = new Point/* Point */.E(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === "round") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === "round") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === "round") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs\n\n\n"use strict";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\n\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs\n\n\n"use strict";\nconst emptyArray = [];\nconst buildPolygon = {\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\n\n//# sourceMappingURL=buildPolygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs\n\nconst buildRectangle = {\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs\n\nconst buildTriangle = {\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildTriangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nconst tempRect = new Rectangle/* Rectangle */.A();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === "texture") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === "fill" || instruction.action === "stroke") {\n      const isStroke = instruction.action === "stroke";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = buildMap.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn("[Pixi Graphics] only the last shape have be cut out");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture/* Texture */.x.WHITE) {\n      const textureMatrix = style.matrix;\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = buildMap[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\n\n//# sourceMappingURL=buildContextBatches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry/* BatchGeometry */.J();\n    this.instructions = new InstructionSet/* InstructionSet */.h();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._activeBatchers = [];\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    this._needsContextNeedsRebuild = [];\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  prerender() {\n    this._returnActiveBatchers();\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === "no-batch") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === "auto") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _returnActiveBatchers() {\n    for (let i = 0; i < this._activeBatchers.length; i++) {\n      PoolGroup/* BigPool */.u.return(this._activeBatchers[i]);\n    }\n    this._activeBatchers.length = 0;\n  }\n  _initContextRenderData(context) {\n    const graphicsData = PoolGroup/* BigPool */.u.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = PoolGroup/* BigPool */.u.get(Batcher/* Batcher */.m);\n    this._activeBatchers.push(batcher);\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on("update", this.onGraphicsContextUpdate, this);\n    context.on("destroy", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextUpdate(context) {\n    this._needsContextNeedsRebuild.push(context);\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off("update", this.onGraphicsContextUpdate, this);\n    context.off("destroy", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        PoolGroup/* BigPool */.u.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        PoolGroup/* BigPool */.u.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const context of this._needsContextNeedsRebuild) {\n      if (this._gpuContextHash[context.uid]) {\n        this.onGraphicsContextDestroy(context);\n      }\n    }\n    this._needsContextNeedsRebuild.length = 0;\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "graphicsContext"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\n\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JELE1BQU0sd0JBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTztBQUNoQyxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0Esb0JBQW9CLHdCQUFPLEtBQUssc0JBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQU87QUFDZixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Y7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9idWlsZFV2cy5tanM/MjBmOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy90cmFuc2Zvcm1WZXJ0aWNlcy5tanM/OTQ5ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanM/YmExZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvY29uc3QubWpzPzA2ODQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2dldE9yaWVudGF0aW9uT2ZQb2ludHMubWpzPzI2YTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRMaW5lLm1qcz8zMWY3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy90cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanM/YjVkMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZFBvbHlnb24ubWpzPzIzZGQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzPzRkYzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRUcmlhbmdsZS5tanM/N2FiYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvYnVpbGRDb250ZXh0QmF0Y2hlcy5tanM/OWI5NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcz83YmNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYnVpbGRVdnModmVydGljZXMsIHZlcnRpY2VzU3RyaWRlLCB2ZXJ0aWNlc09mZnNldCwgdXZzLCB1dnNPZmZzZXQsIHV2c1N0cmlkZSwgc2l6ZSwgbWF0cml4ID0gbnVsbCkge1xuICBsZXQgaW5kZXggPSAwO1xuICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICBjb25zdCBiID0gbWF0cml4LmI7XG4gIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gIHdoaWxlIChpbmRleCA8IHNpemUpIHtcbiAgICBjb25zdCB4ID0gdmVydGljZXNbdmVydGljZXNPZmZzZXRdO1xuICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIDFdO1xuICAgIHV2c1t1dnNPZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHV2c1t1dnNPZmZzZXQgKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICB1dnNPZmZzZXQgKz0gdXZzU3RyaWRlO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGV4Kys7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkU2ltcGxlVXZzKHV2cywgdXZzT2Zmc2V0LCB1dnNTdHJpZGUsIHNpemUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIHV2c1t1dnNPZmZzZXRdID0gMDtcbiAgICB1dnNbdXZzT2Zmc2V0ICsgMV0gPSAwO1xuICAgIHV2c09mZnNldCArPSB1dnNTdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZFNpbXBsZVV2cywgYnVpbGRVdnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVXZzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGljZXModmVydGljZXMsIG0sIG9mZnNldCwgc3RyaWRlLCBzaXplKSB7XG4gIGNvbnN0IGEgPSBtLmE7XG4gIGNvbnN0IGIgPSBtLmI7XG4gIGNvbnN0IGMgPSBtLmM7XG4gIGNvbnN0IGQgPSBtLmQ7XG4gIGNvbnN0IHR4ID0gbS50eDtcbiAgY29uc3QgdHkgPSBtLnR5O1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgc3RyaWRlID0gc3RyaWRlIHx8IDI7XG4gIHNpemUgPSBzaXplIHx8IHZlcnRpY2VzLmxlbmd0aCAvIHN0cmlkZSAtIG9mZnNldDtcbiAgbGV0IGluZGV4ID0gb2Zmc2V0ICogc3RyaWRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpbmRleF07XG4gICAgY29uc3QgeSA9IHZlcnRpY2VzW2luZGV4ICsgMV07XG4gICAgdmVydGljZXNbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgaW5kZXggKz0gc3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1WZXJ0aWNlcy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJ1aWxkQ2lyY2xlID0ge1xuICBidWlsZChzaGFwZSwgcG9pbnRzKSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IGR4O1xuICAgIGxldCBkeTtcbiAgICBsZXQgcng7XG4gICAgbGV0IHJ5O1xuICAgIGlmIChzaGFwZS50eXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBzaGFwZTtcbiAgICAgIHggPSBjaXJjbGUueDtcbiAgICAgIHkgPSBjaXJjbGUueTtcbiAgICAgIHJ4ID0gcnkgPSBjaXJjbGUucmFkaXVzO1xuICAgICAgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIGlmIChzaGFwZS50eXBlID09PSBcImVsbGlwc2VcIikge1xuICAgICAgY29uc3QgZWxsaXBzZSA9IHNoYXBlO1xuICAgICAgeCA9IGVsbGlwc2UueDtcbiAgICAgIHkgPSBlbGxpcHNlLnk7XG4gICAgICByeCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgICAgcnkgPSBlbGxpcHNlLmhhbGZIZWlnaHQ7XG4gICAgICBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBzaGFwZTtcbiAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHJvdW5kZWRSZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgeCA9IHJvdW5kZWRSZWN0LnggKyBoYWxmV2lkdGg7XG4gICAgICB5ID0gcm91bmRlZFJlY3QueSArIGhhbGZIZWlnaHQ7XG4gICAgICByeCA9IHJ5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm91bmRlZFJlY3QucmFkaXVzLCBNYXRoLm1pbihoYWxmV2lkdGgsIGhhbGZIZWlnaHQpKSk7XG4gICAgICBkeCA9IGhhbGZXaWR0aCAtIHJ4O1xuICAgICAgZHkgPSBoYWxmSGVpZ2h0IC0gcnk7XG4gICAgfVxuICAgIGlmICghKHJ4ID49IDAgJiYgcnkgPj0gMCAmJiBkeCA+PSAwICYmIGR5ID49IDApKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKDIuMyAqIE1hdGguc3FydChyeCArIHJ5KSk7XG4gICAgY29uc3QgbSA9IG4gKiA4ICsgKGR4ID8gNCA6IDApICsgKGR5ID8gNCA6IDApO1xuICAgIGlmIChtID09PSAwKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzZdID0geCArIGR4O1xuICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzNdID0geSArIGR5O1xuICAgICAgcG9pbnRzWzJdID0gcG9pbnRzWzRdID0geCAtIGR4O1xuICAgICAgcG9pbnRzWzVdID0gcG9pbnRzWzddID0geSAtIGR5O1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgbGV0IGoxID0gMDtcbiAgICBsZXQgajIgPSBuICogNCArIChkeCA/IDIgOiAwKSArIDI7XG4gICAgbGV0IGozID0gajI7XG4gICAgbGV0IGo0ID0gbTtcbiAgICBsZXQgeDAgPSBkeCArIHJ4O1xuICAgIGxldCB5MCA9IGR5O1xuICAgIGxldCB4MSA9IHggKyB4MDtcbiAgICBsZXQgeDIgPSB4IC0geDA7XG4gICAgbGV0IHkxID0geSArIHkwO1xuICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgIHBvaW50c1tqMSsrXSA9IHkxO1xuICAgIHBvaW50c1stLWoyXSA9IHkxO1xuICAgIHBvaW50c1stLWoyXSA9IHgyO1xuICAgIGlmIChkeSkge1xuICAgICAgY29uc3QgeTIyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2ozKytdID0geDI7XG4gICAgICBwb2ludHNbajMrK10gPSB5MjI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLlBJIC8gMiAqIChpIC8gbik7XG4gICAgICBjb25zdCB4MDIgPSBkeCArIE1hdGguY29zKGEpICogcng7XG4gICAgICBjb25zdCB5MDIgPSBkeSArIE1hdGguc2luKGEpICogcnk7XG4gICAgICBjb25zdCB4MTIgPSB4ICsgeDAyO1xuICAgICAgY29uc3QgeDIyID0geCAtIHgwMjtcbiAgICAgIGNvbnN0IHkxMiA9IHkgKyB5MDI7XG4gICAgICBjb25zdCB5MjIgPSB5IC0geTAyO1xuICAgICAgcG9pbnRzW2oxKytdID0geDEyO1xuICAgICAgcG9pbnRzW2oxKytdID0geTEyO1xuICAgICAgcG9pbnRzWy0tajJdID0geTEyO1xuICAgICAgcG9pbnRzWy0tajJdID0geDIyO1xuICAgICAgcG9pbnRzW2ozKytdID0geDIyO1xuICAgICAgcG9pbnRzW2ozKytdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDEyO1xuICAgIH1cbiAgICB4MCA9IGR4O1xuICAgIHkwID0gZHkgKyByeTtcbiAgICB4MSA9IHggKyB4MDtcbiAgICB4MiA9IHggLSB4MDtcbiAgICB5MSA9IHkgKyB5MDtcbiAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICBwb2ludHNbajErK10gPSB4MTtcbiAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICBpZiAoZHgpIHtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgyO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHgyO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2VudGVyWCA9IDA7XG4gICAgbGV0IGNlbnRlclkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjZW50ZXJYICs9IHBvaW50c1tpXTtcbiAgICAgIGNlbnRlclkgKz0gcG9pbnRzW2kgKyAxXTtcbiAgICB9XG4gICAgY2VudGVyWCAvPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICBjZW50ZXJZIC89IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIGxldCBjb3VudCA9IHZlcnRpY2VzT2Zmc2V0O1xuICAgIHZlcnRpY2VzW2NvdW50ICogdmVydGljZXNTdHJpZGVdID0gY2VudGVyWDtcbiAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlICsgMV0gPSBjZW50ZXJZO1xuICAgIGNvbnN0IGNlbnRlckluZGV4ID0gY291bnQrKztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmVydGljZXNbY291bnQgKiB2ZXJ0aWNlc1N0cmlkZV0gPSBwb2ludHNbaV07XG4gICAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlICsgMV0gPSBwb2ludHNbaSArIDFdO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50O1xuICAgICAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSBjZW50ZXJJbmRleDtcbiAgICAgICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY291bnQgLSAxO1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY2VudGVySW5kZXggKyAxO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNlbnRlckluZGV4O1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50IC0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRDaXJjbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQ2lyY2xlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY2xvc2VQb2ludEVwcyA9IDFlLTQ7XG5jb25zdCBjdXJ2ZUVwcyA9IDFlLTQ7XG5cbmV4cG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldE9yaWVudGF0aW9uT2ZQb2ludHMocG9pbnRzKSB7XG4gIGNvbnN0IG0gPSBwb2ludHMubGVuZ3RoO1xuICBpZiAobSA8IDYpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCB4MSA9IHBvaW50c1ttIC0gMl0sIHkxID0gcG9pbnRzW20gLSAxXTsgaSA8IG07IGkgKz0gMikge1xuICAgIGNvbnN0IHgyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IHkyID0gcG9pbnRzW2kgKyAxXTtcbiAgICBhcmVhICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgaWYgKGFyZWEgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBnZXRPcmllbnRhdGlvbk9mUG9pbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IGdldE9yaWVudGF0aW9uT2ZQb2ludHMgfSBmcm9tICcuLi91dGlscy9nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlKHgsIHksIG54LCBueSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBjbG9ja3dpc2UsIHZlcnRzKSB7XG4gIGNvbnN0IGl4ID0geCAtIG54ICogaW5uZXJXZWlnaHQ7XG4gIGNvbnN0IGl5ID0geSAtIG55ICogaW5uZXJXZWlnaHQ7XG4gIGNvbnN0IG94ID0geCArIG54ICogb3V0ZXJXZWlnaHQ7XG4gIGNvbnN0IG95ID0geSArIG55ICogb3V0ZXJXZWlnaHQ7XG4gIGxldCBleHg7XG4gIGxldCBleXk7XG4gIGlmIChjbG9ja3dpc2UpIHtcbiAgICBleHggPSBueTtcbiAgICBleXkgPSAtbng7XG4gIH0gZWxzZSB7XG4gICAgZXh4ID0gLW55O1xuICAgIGV5eSA9IG54O1xuICB9XG4gIGNvbnN0IGVpeCA9IGl4ICsgZXh4O1xuICBjb25zdCBlaXkgPSBpeSArIGV5eTtcbiAgY29uc3QgZW94ID0gb3ggKyBleHg7XG4gIGNvbnN0IGVveSA9IG95ICsgZXl5O1xuICB2ZXJ0cy5wdXNoKGVpeCwgZWl5KTtcbiAgdmVydHMucHVzaChlb3gsIGVveSk7XG4gIHJldHVybiAyO1xufVxuZnVuY3Rpb24gcm91bmQoY3gsIGN5LCBzeCwgc3ksIGV4LCBleSwgdmVydHMsIGNsb2Nrd2lzZSkge1xuICBjb25zdCBjeDJwMHggPSBzeCAtIGN4O1xuICBjb25zdCBjeTJwMHkgPSBzeSAtIGN5O1xuICBsZXQgYW5nbGUwID0gTWF0aC5hdGFuMihjeDJwMHgsIGN5MnAweSk7XG4gIGxldCBhbmdsZTEgPSBNYXRoLmF0YW4yKGV4IC0gY3gsIGV5IC0gY3kpO1xuICBpZiAoY2xvY2t3aXNlICYmIGFuZ2xlMCA8IGFuZ2xlMSkge1xuICAgIGFuZ2xlMCArPSBNYXRoLlBJICogMjtcbiAgfSBlbHNlIGlmICghY2xvY2t3aXNlICYmIGFuZ2xlMCA+IGFuZ2xlMSkge1xuICAgIGFuZ2xlMSArPSBNYXRoLlBJICogMjtcbiAgfVxuICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlMDtcbiAgY29uc3QgYW5nbGVEaWZmID0gYW5nbGUxIC0gYW5nbGUwO1xuICBjb25zdCBhYnNBbmdsZURpZmYgPSBNYXRoLmFicyhhbmdsZURpZmYpO1xuICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoY3gycDB4ICogY3gycDB4ICsgY3kycDB5ICogY3kycDB5KTtcbiAgY29uc3Qgc2VnQ291bnQgPSAoMTUgKiBhYnNBbmdsZURpZmYgKiBNYXRoLnNxcnQocmFkaXVzKSAvIE1hdGguUEkgPj4gMCkgKyAxO1xuICBjb25zdCBhbmdsZUluYyA9IGFuZ2xlRGlmZiAvIHNlZ0NvdW50O1xuICBzdGFydEFuZ2xlICs9IGFuZ2xlSW5jO1xuICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIHZlcnRzLnB1c2goc3gsIHN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3gsIGN5KTtcbiAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgIGN4ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgICBjeSArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1c1xuICAgICAgKTtcbiAgICB9XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIHZlcnRzLnB1c2goZXgsIGV5KTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJ0cy5wdXNoKHN4LCBzeSk7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYykge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzXG4gICAgICApO1xuICAgICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGV4LCBleSk7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICB9XG4gIHJldHVybiBzZWdDb3VudCAqIDI7XG59XG5mdW5jdGlvbiBidWlsZExpbmUocG9pbnRzLCBsaW5lU3R5bGUsIGZsaXBBbGlnbm1lbnQsIGNsb3NlZCwgdmVydGljZXMsIF92ZXJ0aWNlc1N0cmlkZSwgX3ZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBfaW5kaWNlc09mZnNldCkge1xuICBjb25zdCBlcHMgPSBjbG9zZVBvaW50RXBzO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdHlsZSA9IGxpbmVTdHlsZTtcbiAgbGV0IGFsaWdubWVudCA9IHN0eWxlLmFsaWdubWVudDtcbiAgaWYgKGxpbmVTdHlsZS5hbGlnbm1lbnQgIT09IDAuNSkge1xuICAgIGxldCBvcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uT2ZQb2ludHMocG9pbnRzKTtcbiAgICBpZiAoZmxpcEFsaWdubWVudClcbiAgICAgIG9yaWVudGF0aW9uICo9IC0xO1xuICAgIGFsaWdubWVudCA9IChhbGlnbm1lbnQgLSAwLjUpICogb3JpZW50YXRpb24gKyAwLjU7XG4gIH1cbiAgY29uc3QgZmlyc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gIGNvbnN0IGxhc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY2xvc2VkU2hhcGUgPSBjbG9zZWQ7XG4gIGNvbnN0IGNsb3NlZFBhdGggPSBNYXRoLmFicyhmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgPCBlcHMgJiYgTWF0aC5hYnMoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpIDwgZXBzO1xuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcbiAgICBpZiAoY2xvc2VkUGF0aCkge1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgbGFzdFBvaW50LnNldChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY29uc3QgbWlkUG9pbnRYID0gKGZpcnN0UG9pbnQueCArIGxhc3RQb2ludC54KSAqIDAuNTtcbiAgICBjb25zdCBtaWRQb2ludFkgPSAobGFzdFBvaW50LnkgKyBmaXJzdFBvaW50LnkpICogMC41O1xuICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gIH1cbiAgY29uc3QgdmVydHMgPSB2ZXJ0aWNlcztcbiAgY29uc3QgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIGxldCBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gIGNvbnN0IHdpZHRoID0gc3R5bGUud2lkdGggLyAyO1xuICBjb25zdCB3aWR0aFNxdWFyZWQgPSB3aWR0aCAqIHdpZHRoO1xuICBjb25zdCBtaXRlckxpbWl0U3F1YXJlZCA9IHN0eWxlLm1pdGVyTGltaXQgKiBzdHlsZS5taXRlckxpbWl0O1xuICBsZXQgeDAgPSBwb2ludHNbMF07XG4gIGxldCB5MCA9IHBvaW50c1sxXTtcbiAgbGV0IHgxID0gcG9pbnRzWzJdO1xuICBsZXQgeTEgPSBwb2ludHNbM107XG4gIGxldCB4MiA9IDA7XG4gIGxldCB5MiA9IDA7XG4gIGxldCBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gIGxldCBwZXJwWSA9IHgwIC0geDE7XG4gIGxldCBwZXJwMXggPSAwO1xuICBsZXQgcGVycDF5ID0gMDtcbiAgbGV0IGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICBwZXJwWCAvPSBkaXN0O1xuICBwZXJwWSAvPSBkaXN0O1xuICBwZXJwWCAqPSB3aWR0aDtcbiAgcGVycFkgKj0gd2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gYWxpZ25tZW50O1xuICBjb25zdCBpbm5lcldlaWdodCA9ICgxIC0gcmF0aW8pICogMjtcbiAgY29uc3Qgb3V0ZXJXZWlnaHQgPSByYXRpbyAqIDI7XG4gIGlmICghY2xvc2VkU2hhcGUpIHtcbiAgICBpZiAoc3R5bGUuY2FwID09PSBcInJvdW5kXCIpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgIHgwIC0gcGVycFggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgICAgIHkwIC0gcGVycFkgKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgICAgIHgwIC0gcGVycFggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTAgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB4MCArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkwICsgcGVycFkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgdmVydHMsXG4gICAgICAgIHRydWVcbiAgICAgICkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBcInNxdWFyZVwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MCwgeTAsIHBlcnBYLCBwZXJwWSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCB0cnVlLCB2ZXJ0cyk7XG4gICAgfVxuICB9XG4gIHZlcnRzLnB1c2goXG4gICAgeDAgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgIHkwIC0gcGVycFkgKiBpbm5lcldlaWdodFxuICApO1xuICB2ZXJ0cy5wdXNoKFxuICAgIHgwICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICB5MCArIHBlcnBZICogb3V0ZXJXZWlnaHRcbiAgKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICB4MCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgeTAgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXTtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gICAgcGVycFkgPSB4MCAtIHgxO1xuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICAgIHBlcnBYIC89IGRpc3Q7XG4gICAgcGVycFkgLz0gZGlzdDtcbiAgICBwZXJwWCAqPSB3aWR0aDtcbiAgICBwZXJwWSAqPSB3aWR0aDtcbiAgICBwZXJwMXggPSAtKHkxIC0geTIpO1xuICAgIHBlcnAxeSA9IHgxIC0geDI7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJwMXggKiBwZXJwMXggKyBwZXJwMXkgKiBwZXJwMXkpO1xuICAgIHBlcnAxeCAvPSBkaXN0O1xuICAgIHBlcnAxeSAvPSBkaXN0O1xuICAgIHBlcnAxeCAqPSB3aWR0aDtcbiAgICBwZXJwMXkgKj0gd2lkdGg7XG4gICAgY29uc3QgZHgwID0geDEgLSB4MDtcbiAgICBjb25zdCBkeTAgPSB5MCAtIHkxO1xuICAgIGNvbnN0IGR4MSA9IHgxIC0geDI7XG4gICAgY29uc3QgZHkxID0geTIgLSB5MTtcbiAgICBjb25zdCBkb3QgPSBkeDAgKiBkeDEgKyBkeTAgKiBkeTE7XG4gICAgY29uc3QgY3Jvc3MgPSBkeTAgKiBkeDEgLSBkeTEgKiBkeDA7XG4gICAgY29uc3QgY2xvY2t3aXNlID0gY3Jvc3MgPCAwO1xuICAgIGlmIChNYXRoLmFicyhjcm9zcykgPCAxZS0zICogTWF0aC5hYnMoZG90KSkge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHRcbiAgICAgICk7XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkxICsgcGVycFkgKiBvdXRlcldlaWdodFxuICAgICAgKTtcbiAgICAgIGlmIChkb3QgPj0gMCkge1xuICAgICAgICBpZiAoc3R5bGUuam9pbiA9PT0gXCJyb3VuZFwiKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICB4MSAtIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgIHkxIC0gcGVycDF5ICogb3V0ZXJXZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICB4MSArIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgIHkxICsgcGVycDF5ICogaW5uZXJXZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjMSA9ICgtcGVycFggKyB4MCkgKiAoLXBlcnBZICsgeTEpIC0gKC1wZXJwWCArIHgxKSAqICgtcGVycFkgKyB5MCk7XG4gICAgY29uc3QgYzIgPSAoLXBlcnAxeCArIHgyKSAqICgtcGVycDF5ICsgeTEpIC0gKC1wZXJwMXggKyB4MSkgKiAoLXBlcnAxeSArIHkyKTtcbiAgICBjb25zdCBweCA9IChkeDAgKiBjMiAtIGR4MSAqIGMxKSAvIGNyb3NzO1xuICAgIGNvbnN0IHB5ID0gKGR5MSAqIGMxIC0gZHkwICogYzIpIC8gY3Jvc3M7XG4gICAgY29uc3QgcERpc3QgPSAocHggLSB4MSkgKiAocHggLSB4MSkgKyAocHkgLSB5MSkgKiAocHkgLSB5MSk7XG4gICAgY29uc3QgaW14ID0geDEgKyAocHggLSB4MSkgKiBpbm5lcldlaWdodDtcbiAgICBjb25zdCBpbXkgPSB5MSArIChweSAtIHkxKSAqIGlubmVyV2VpZ2h0O1xuICAgIGNvbnN0IG9teCA9IHgxIC0gKHB4IC0geDEpICogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgb215ID0geTEgLSAocHkgLSB5MSkgKiBvdXRlcldlaWdodDtcbiAgICBjb25zdCBzbWFsbGVySW5zaWRlU2VnbWVudFNxID0gTWF0aC5taW4oZHgwICogZHgwICsgZHkwICogZHkwLCBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICAgIGNvbnN0IGluc2lkZVdlaWdodCA9IGNsb2Nrd2lzZSA/IGlubmVyV2VpZ2h0IDogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgc21hbGxlckluc2lkZURpYWdvbmFsU3EgPSBzbWFsbGVySW5zaWRlU2VnbWVudFNxICsgaW5zaWRlV2VpZ2h0ICogaW5zaWRlV2VpZ2h0ICogd2lkdGhTcXVhcmVkO1xuICAgIGNvbnN0IGluc2lkZU1pdGVyT2sgPSBwRGlzdCA8PSBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcTtcbiAgICBpZiAoaW5zaWRlTWl0ZXJPaykge1xuICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IFwiYmV2ZWxcIiB8fCBwRGlzdCAvIHdpZHRoU3F1YXJlZCA+IG1pdGVyTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycFggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCk7XG4gICAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5qb2luID09PSBcInJvdW5kXCIpIHtcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSArIDQ7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSk7XG4gICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycFggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IFwicm91bmRcIikge1xuICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSArIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUuam9pbiA9PT0gXCJtaXRlclwiICYmIHBEaXN0IC8gd2lkdGhTcXVhcmVkIDw9IG1pdGVyTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQpO1xuICAgICAgdmVydHMucHVzaCh4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICB9XG4gIH1cbiAgeDAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMl07XG4gIHkwID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDIgKyAxXTtcbiAgeDEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMl07XG4gIHkxID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDIgKyAxXTtcbiAgcGVycFggPSAtKHkwIC0geTEpO1xuICBwZXJwWSA9IHgwIC0geDE7XG4gIGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICBwZXJwWCAvPSBkaXN0O1xuICBwZXJwWSAvPSBkaXN0O1xuICBwZXJwWCAqPSB3aWR0aDtcbiAgcGVycFkgKj0gd2lkdGg7XG4gIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICB2ZXJ0cy5wdXNoKHgxICsgcGVycFggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0KTtcbiAgaWYgKCFjbG9zZWRTaGFwZSkge1xuICAgIGlmIChzdHlsZS5jYXAgPT09IFwicm91bmRcIikge1xuICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgeDEgLSBwZXJwWCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeTEgLSBwZXJwWSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHgxICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB2ZXJ0cyxcbiAgICAgICAgZmFsc2VcbiAgICAgICkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBcInNxdWFyZVwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MSwgeTEsIHBlcnBYLCBwZXJwWSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBmYWxzZSwgdmVydHMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBlcHMyID0gY3VydmVFcHMgKiBjdXJ2ZUVwcztcbiAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQ7IGkgPCBpbmRleENvdW50ICsgaW5kZXhTdGFydCAtIDI7ICsraSkge1xuICAgIHgwID0gdmVydHNbaSAqIDJdO1xuICAgIHkwID0gdmVydHNbaSAqIDIgKyAxXTtcbiAgICB4MSA9IHZlcnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MSA9IHZlcnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgeDIgPSB2ZXJ0c1soaSArIDIpICogMl07XG4gICAgeTIgPSB2ZXJ0c1soaSArIDIpICogMiArIDFdO1xuICAgIGlmIChNYXRoLmFicyh4MCAqICh5MSAtIHkyKSArIHgxICogKHkyIC0geTApICsgeDIgKiAoeTAgLSB5MSkpIDwgZXBzMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIpO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkTGluZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRMaW5lLm1qcy5tYXBcbiIsImltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB0cmlhbmd1bGF0ZVdpdGhIb2xlcyhwb2ludHMsIGhvbGVzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gIGNvbnN0IHRyaWFuZ2xlcyA9IGVhcmN1dChwb2ludHMsIGhvbGVzLCAyKTtcbiAgaWYgKCF0cmlhbmdsZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaV0gKyB2ZXJ0aWNlc09mZnNldDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaSArIDFdICsgdmVydGljZXNPZmZzZXQ7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdHJpYW5nbGVzW2kgKyAyXSArIHZlcnRpY2VzT2Zmc2V0O1xuICB9XG4gIGxldCBpbmRleCA9IHZlcnRpY2VzT2Zmc2V0ICogdmVydGljZXNTdHJpZGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnRzW2ldO1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBwb2ludHNbaSArIDFdO1xuICAgIGluZGV4ICs9IHZlcnRpY2VzU3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyaWFuZ3VsYXRlV2l0aEhvbGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMubWFwXG4iLCJpbXBvcnQgeyB0cmlhbmd1bGF0ZVdpdGhIb2xlcyB9IGZyb20gJy4uL3V0aWxzL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZW1wdHlBcnJheSA9IFtdO1xuY29uc3QgYnVpbGRQb2x5Z29uID0ge1xuICBidWlsZChzaGFwZSwgcG9pbnRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvaW50c1tpXSA9IHNoYXBlLnBvaW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgdHJpYW5ndWxhdGVXaXRoSG9sZXMocG9pbnRzLCBlbXB0eUFycmF5LCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRQb2x5Z29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFBvbHlnb24ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBidWlsZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIGNvbnN0IHJlY3REYXRhID0gc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgaWYgKCEod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkpIHtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHBvaW50c1swXSA9IHg7XG4gICAgcG9pbnRzWzFdID0geTtcbiAgICBwb2ludHNbMl0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzNdID0geTtcbiAgICBwb2ludHNbNF0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzVdID0geSArIGhlaWdodDtcbiAgICBwb2ludHNbNl0gPSB4O1xuICAgIHBvaW50c1s3XSA9IHkgKyBoZWlnaHQ7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1swXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbMV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbMl07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzNdO1xuICAgIGNvdW50ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzZdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1s3XTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1s0XTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbNV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgY29uc3QgdmVydGljZXNJbmRleCA9IHZlcnRpY2VzT2Zmc2V0IC8gdmVydGljZXNTdHJpZGU7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMztcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRUcmlhbmdsZSA9IHtcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIHBvaW50c1swXSA9IHNoYXBlLng7XG4gICAgcG9pbnRzWzFdID0gc2hhcGUueTtcbiAgICBwb2ludHNbMl0gPSBzaGFwZS54MjtcbiAgICBwb2ludHNbM10gPSBzaGFwZS55MjtcbiAgICBwb2ludHNbNF0gPSBzaGFwZS54MztcbiAgICBwb2ludHNbNV0gPSBzaGFwZS55MztcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICo9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzBdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1sxXTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1syXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbM107XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbNF07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzVdO1xuICAgIGNvbnN0IHZlcnRpY2VzSW5kZXggPSB2ZXJ0aWNlc09mZnNldCAvIHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IHZlcnRpY2VzSW5kZXg7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDE7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJ1aWxkVHJpYW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVHJpYW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRVdnMsIGJ1aWxkU2ltcGxlVXZzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvdHJhbnNmb3JtVmVydGljZXMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuLi9CYXRjaGFibGVHcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZExpbmUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkTGluZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRQb2x5Z29uIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZFBvbHlnb24ubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZFJlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRUcmlhbmdsZSB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRUcmlhbmdsZS5tanMnO1xuaW1wb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfSBmcm9tICcuL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRNYXAgPSB7XG4gIHJlY3RhbmdsZTogYnVpbGRSZWN0YW5nbGUsXG4gIHBvbHlnb246IGJ1aWxkUG9seWdvbixcbiAgdHJpYW5nbGU6IGJ1aWxkVHJpYW5nbGUsXG4gIGNpcmNsZTogYnVpbGRDaXJjbGUsXG4gIGVsbGlwc2U6IGJ1aWxkQ2lyY2xlLFxuICByb3VuZGVkUmVjdGFuZ2xlOiBidWlsZENpcmNsZVxufTtcbmNvbnN0IHRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuZnVuY3Rpb24gYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KSB7XG4gIGNvbnN0IHsgZ2VvbWV0cnlEYXRhLCBiYXRjaGVzIH0gPSBncHVDb250ZXh0O1xuICBiYXRjaGVzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS5pbmRpY2VzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS52ZXJ0aWNlcy5sZW5ndGggPSAwO1xuICBnZW9tZXRyeURhdGEudXZzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGNvbnRleHQuaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoaW5zdHJ1Y3Rpb24uZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJmaWxsXCIgfHwgaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBjb25zdCBpc1N0cm9rZSA9IGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIjtcbiAgICAgIGNvbnN0IHNoYXBlUGF0aCA9IGluc3RydWN0aW9uLmRhdGEucGF0aC5zaGFwZVBhdGg7XG4gICAgICBjb25zdCBzdHlsZSA9IGluc3RydWN0aW9uLmRhdGEuc3R5bGU7XG4gICAgICBjb25zdCBob2xlID0gaW5zdHJ1Y3Rpb24uZGF0YS5ob2xlO1xuICAgICAgaWYgKGlzU3Ryb2tlICYmIGhvbGUpIHtcbiAgICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoaG9sZS5zaGFwZVBhdGgsIHN0eWxlLCBudWxsLCB0cnVlLCBiYXRjaGVzLCBnZW9tZXRyeURhdGEpO1xuICAgICAgfVxuICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoc2hhcGVQYXRoLCBzdHlsZSwgaG9sZSwgaXNTdHJva2UsIGJhdGNoZXMsIGdlb21ldHJ5RGF0YSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBpbmRleE9mZnNldCA9IGluZGljZXMubGVuZ3RoO1xuICBjb25zdCB2ZXJ0T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IGJ1aWxkID0gYnVpbGRNYXAucmVjdGFuZ2xlO1xuICBjb25zdCByZWN0ID0gdGVtcFJlY3Q7XG4gIGNvbnN0IHRleHR1cmUgPSBkYXRhLmltYWdlO1xuICByZWN0LnggPSBkYXRhLmR4O1xuICByZWN0LnkgPSBkYXRhLmR5O1xuICByZWN0LndpZHRoID0gZGF0YS5kdztcbiAgcmVjdC5oZWlnaHQgPSBkYXRhLmRoO1xuICBjb25zdCBtYXRyaXggPSBkYXRhLnRyYW5zZm9ybTtcbiAgYnVpbGQuYnVpbGQocmVjdCwgcG9pbnRzKTtcbiAgaWYgKG1hdHJpeCkge1xuICAgIHRyYW5zZm9ybVZlcnRpY2VzKHBvaW50cywgbWF0cml4KTtcbiAgfVxuICBidWlsZC50cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCBpbmRpY2VzLCBpbmRleE9mZnNldCk7XG4gIGNvbnN0IHRleHR1cmVVdnMgPSB0ZXh0dXJlLnV2cztcbiAgdXZzLnB1c2goXG4gICAgdGV4dHVyZVV2cy54MCxcbiAgICB0ZXh0dXJlVXZzLnkwLFxuICAgIHRleHR1cmVVdnMueDEsXG4gICAgdGV4dHVyZVV2cy55MSxcbiAgICB0ZXh0dXJlVXZzLngzLFxuICAgIHRleHR1cmVVdnMueTMsXG4gICAgdGV4dHVyZVV2cy54MixcbiAgICB0ZXh0dXJlVXZzLnkyXG4gICk7XG4gIGNvbnN0IGdyYXBoaWNzQmF0Y2ggPSBCaWdQb29sLmdldChCYXRjaGFibGVHcmFwaGljcyk7XG4gIGdyYXBoaWNzQmF0Y2guaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldDtcbiAgZ3JhcGhpY3NCYXRjaC5pbmRleFNpemUgPSBpbmRpY2VzLmxlbmd0aCAtIGluZGV4T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLnZlcnRleE9mZnNldCA9IHZlcnRPZmZzZXQ7XG4gIGdyYXBoaWNzQmF0Y2gudmVydGV4U2l6ZSA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLmNvbG9yID0gZGF0YS5zdHlsZTtcbiAgZ3JhcGhpY3NCYXRjaC5hbHBoYSA9IGRhdGEuYWxwaGE7XG4gIGdyYXBoaWNzQmF0Y2gudGV4dHVyZSA9IHRleHR1cmU7XG4gIGdyYXBoaWNzQmF0Y2guZ2VvbWV0cnlEYXRhID0gZ2VvbWV0cnlEYXRhO1xuICBiYXRjaGVzLnB1c2goZ3JhcGhpY3NCYXRjaCk7XG59XG5mdW5jdGlvbiBhZGRTaGFwZVBhdGhUb0dlb21ldHJ5RGF0YShzaGFwZVBhdGgsIHN0eWxlLCBob2xlLCBpc1N0cm9rZSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBsYXN0SW5kZXggPSBzaGFwZVBhdGguc2hhcGVQcmltaXRpdmVzLmxlbmd0aCAtIDE7XG4gIHNoYXBlUGF0aC5zaGFwZVByaW1pdGl2ZXMuZm9yRWFjaCgoeyBzaGFwZSwgdHJhbnNmb3JtOiBtYXRyaXggfSwgaSkgPT4ge1xuICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmVydE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgY29uc3QgYnVpbGQgPSBidWlsZE1hcFtzaGFwZS50eXBlXTtcbiAgICBidWlsZC5idWlsZChzaGFwZSwgcG9pbnRzKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICB0cmFuc2Zvcm1WZXJ0aWNlcyhwb2ludHMsIG1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgIGlmIChob2xlICYmIGxhc3RJbmRleCA9PT0gaSkge1xuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW1BpeGkgR3JhcGhpY3NdIG9ubHkgdGhlIGxhc3Qgc2hhcGUgaGF2ZSBiZSBjdXQgb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvbGVJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IG90aGVyUG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGhvbGVBcnJheXMgPSBnZXRIb2xlQXJyYXlzKGhvbGUuc2hhcGVQYXRoKTtcbiAgICAgICAgaG9sZUFycmF5cy5mb3JFYWNoKChob2xlUG9pbnRzKSA9PiB7XG4gICAgICAgICAgaG9sZUluZGljZXMucHVzaChvdGhlclBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgICBvdGhlclBvaW50cy5wdXNoKC4uLmhvbGVQb2ludHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJpYW5ndWxhdGVXaXRoSG9sZXMob3RoZXJQb2ludHMsIGhvbGVJbmRpY2VzLCB2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgaW5kaWNlcywgaW5kZXhPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVpbGQudHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgaW5kaWNlcywgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjbG9zZSA9IHNoYXBlLmNsb3NlUGF0aCA/PyB0cnVlO1xuICAgICAgY29uc3QgbGluZVN0eWxlID0gc3R5bGU7XG4gICAgICBidWlsZExpbmUocG9pbnRzLCBsaW5lU3R5bGUsIGZhbHNlLCBjbG9zZSwgdmVydGljZXMsIDIsIHZlcnRPZmZzZXQsIGluZGljZXMsIGluZGV4T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgdXZzT2Zmc2V0ID0gdXZzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgdGV4dHVyZSA9IHN0eWxlLnRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgIT09IFRleHR1cmUuV0hJVEUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVNYXRyaXggPSBzdHlsZS5tYXRyaXg7XG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIHRleHR1cmVNYXRyaXguYXBwZW5kKG1hdHJpeC5jbG9uZSgpLmludmVydCgpKTtcbiAgICAgIH1cbiAgICAgIGJ1aWxkVXZzKHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCB1dnMsIHV2c09mZnNldCwgMiwgdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQsIHRleHR1cmVNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWlsZFNpbXBsZVV2cyh1dnMsIHV2c09mZnNldCwgMiwgdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBncmFwaGljc0JhdGNoID0gQmlnUG9vbC5nZXQoQmF0Y2hhYmxlR3JhcGhpY3MpO1xuICAgIGdyYXBoaWNzQmF0Y2guaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldDtcbiAgICBncmFwaGljc0JhdGNoLmluZGV4U2l6ZSA9IGluZGljZXMubGVuZ3RoIC0gaW5kZXhPZmZzZXQ7XG4gICAgZ3JhcGhpY3NCYXRjaC52ZXJ0ZXhPZmZzZXQgPSB2ZXJ0T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2gudmVydGV4U2l6ZSA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2guY29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICBncmFwaGljc0JhdGNoLmFscGhhID0gc3R5bGUuYWxwaGE7XG4gICAgZ3JhcGhpY3NCYXRjaC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBncmFwaGljc0JhdGNoLmdlb21ldHJ5RGF0YSA9IGdlb21ldHJ5RGF0YTtcbiAgICBiYXRjaGVzLnB1c2goZ3JhcGhpY3NCYXRjaCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SG9sZUFycmF5cyhzaGFwZSkge1xuICBpZiAoIXNoYXBlKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgaG9sZVByaW1pdGl2ZXMgPSBzaGFwZS5zaGFwZVByaW1pdGl2ZXM7XG4gIGNvbnN0IGhvbGVBcnJheXMgPSBbXTtcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBob2xlUHJpbWl0aXZlcy5sZW5ndGg7IGsrKykge1xuICAgIGNvbnN0IGhvbGVQcmltaXRpdmUgPSBob2xlUHJpbWl0aXZlc1trXS5zaGFwZTtcbiAgICBjb25zdCBob2xlUG9pbnRzID0gW107XG4gICAgY29uc3QgaG9sZUJ1aWxkZXIgPSBidWlsZE1hcFtob2xlUHJpbWl0aXZlLnR5cGVdO1xuICAgIGhvbGVCdWlsZGVyLmJ1aWxkKGhvbGVQcmltaXRpdmUsIGhvbGVQb2ludHMpO1xuICAgIGhvbGVBcnJheXMucHVzaChob2xlUG9pbnRzKTtcbiAgfVxuICByZXR1cm4gaG9sZUFycmF5cztcbn1cblxuZXhwb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDb250ZXh0QmF0Y2hlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L0JhdGNoR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IEJhdGNoZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlci5tanMnO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGRDb250ZXh0QmF0Y2hlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUdyYXBoaWNzQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuZ2VvbWV0cnlEYXRhID0ge1xuICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgdXZzOiBbXSxcbiAgICAgIGluZGljZXM6IFtdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgQmF0Y2hHZW9tZXRyeSgpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gbmV3IEluc3RydWN0aW9uU2V0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5yZXNldCgpO1xuICB9XG59XG5jb25zdCBfR3JhcGhpY3NDb250ZXh0U3lzdGVtID0gY2xhc3MgX0dyYXBoaWNzQ29udGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIHRoZSByb290IGNvbnRleHQgYmF0Y2hlcywgdXNlZCB0byBlaXRoZXIgbWFrZSBhIGJhdGNoIG9yIGdlb21ldHJ5XG4gICAgLy8gYWxsIGdyYXBoaWNzIHVzZSB0aGlzIGFzIGEgYmFzZVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXJzID0gW107XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2ggPSB7fTtcbiAgICAvLyB1c2VkIGZvciBub24tYmF0Y2hhYmxlIGdyYXBoaWNzXG4gICAgdGhpcy5fZ3JhcGhpY3NEYXRhQ29udGV4dEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9uZWVkc0NvbnRleHROZWVkc1JlYnVpbGQgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUnVubmVyIGluaXQgY2FsbGVkLCB1cGRhdGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBfR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MgPSBvcHRpb25zPy5iZXppZXJTbW9vdGhuZXNzID8/IF9HcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuYmV6aWVyU21vb3RobmVzcztcbiAgfVxuICBwcmVyZW5kZXIoKSB7XG4gICAgdGhpcy5fcmV0dXJuQWN0aXZlQmF0Y2hlcnMoKTtcbiAgfVxuICBnZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dFJlbmRlckRhdGEoY29udGV4dCk7XG4gIH1cbiAgLy8gQ29udGV4dCBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICB1cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICBsZXQgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC5kaXJ0eSkge1xuICAgICAgaWYgKGdwdUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5HcmFwaGljc0NvbnRleHREYXRhKGNvbnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3B1Q29udGV4dCA9IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KTtcbiAgICAgIGNvbnN0IGJhdGNoTW9kZSA9IGNvbnRleHQuYmF0Y2hNb2RlO1xuICAgICAgaWYgKGNvbnRleHQuY3VzdG9tU2hhZGVyIHx8IGJhdGNoTW9kZSA9PT0gXCJuby1iYXRjaFwiKSB7XG4gICAgICAgIGdwdUNvbnRleHQuaXNCYXRjaGFibGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2hNb2RlID09PSBcImF1dG9cIikge1xuICAgICAgICBncHVDb250ZXh0LmlzQmF0Y2hhYmxlID0gZ3B1Q29udGV4dC5nZW9tZXRyeURhdGEudmVydGljZXMubGVuZ3RoIDwgNDAwO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZ3B1Q29udGV4dDtcbiAgfVxuICBnZXRHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdIHx8IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICB9XG4gIF9yZXR1cm5BY3RpdmVCYXRjaGVycygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZUJhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBCaWdQb29sLnJldHVybih0aGlzLl9hY3RpdmVCYXRjaGVyc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX2luaXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gQmlnUG9vbC5nZXQoR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSk7XG4gICAgY29uc3QgeyBiYXRjaGVzLCBnZW9tZXRyeURhdGEgfSA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgICBjb25zdCB2ZXJ0ZXhTaXplID0gZ2VvbWV0cnlEYXRhLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBpbmRleFNpemUgPSBnZW9tZXRyeURhdGEuaW5kaWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXRjaGVzW2ldLmFwcGx5VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoZXIgPSBCaWdQb29sLmdldChCYXRjaGVyKTtcbiAgICB0aGlzLl9hY3RpdmVCYXRjaGVycy5wdXNoKGJhdGNoZXIpO1xuICAgIGJhdGNoZXIuZW5zdXJlQXR0cmlidXRlQnVmZmVyKHZlcnRleFNpemUpO1xuICAgIGJhdGNoZXIuZW5zdXJlSW5kZXhCdWZmZXIoaW5kZXhTaXplKTtcbiAgICBiYXRjaGVyLmJlZ2luKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBiYXRjaGVyLmFkZChiYXRjaCk7XG4gICAgfVxuICAgIGJhdGNoZXIuZmluaXNoKGdyYXBoaWNzRGF0YS5pbnN0cnVjdGlvbnMpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZ3JhcGhpY3NEYXRhLmdlb21ldHJ5O1xuICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyLnNldERhdGFXaXRoU2l6ZShiYXRjaGVyLmluZGV4QnVmZmVyLCBiYXRjaGVyLmluZGV4U2l6ZSwgdHJ1ZSk7XG4gICAgZ2VvbWV0cnkuYnVmZmVyc1swXS5zZXREYXRhV2l0aFNpemUoYmF0Y2hlci5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXcsIGJhdGNoZXIuYXR0cmlidXRlU2l6ZSwgdHJ1ZSk7XG4gICAgY29uc3QgZHJhd0JhdGNoZXMgPSBiYXRjaGVyLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3QmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBkcmF3QmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoLmJpbmRHcm91cCA9IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cChiYXRjaC50ZXh0dXJlcy50ZXh0dXJlcywgYmF0Y2gudGV4dHVyZXMuY291bnQpO1xuICAgIH1cbiAgICB0aGlzLl9ncmFwaGljc0RhdGFDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0gPSBncmFwaGljc0RhdGE7XG4gICAgcmV0dXJuIGdyYXBoaWNzRGF0YTtcbiAgfVxuICBfaW5pdENvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSBuZXcgR3B1R3JhcGhpY3NDb250ZXh0KCk7XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdID0gZ3B1Q29udGV4dDtcbiAgICBjb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25HcmFwaGljc0NvbnRleHRVcGRhdGUsIHRoaXMpO1xuICAgIGNvbnRleHQub24oXCJkZXN0cm95XCIsIHRoaXMub25HcmFwaGljc0NvbnRleHREZXN0cm95LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdO1xuICB9XG4gIG9uR3JhcGhpY3NDb250ZXh0VXBkYXRlKGNvbnRleHQpIHtcbiAgICB0aGlzLl9uZWVkc0NvbnRleHROZWVkc1JlYnVpbGQucHVzaChjb250ZXh0KTtcbiAgfVxuICBvbkdyYXBoaWNzQ29udGV4dERlc3Ryb3koY29udGV4dCkge1xuICAgIHRoaXMuX2NsZWFuR3JhcGhpY3NDb250ZXh0RGF0YShjb250ZXh0KTtcbiAgICBjb250ZXh0Lm9mZihcInVwZGF0ZVwiLCB0aGlzLm9uR3JhcGhpY3NDb250ZXh0VXBkYXRlLCB0aGlzKTtcbiAgICBjb250ZXh0Lm9mZihcImRlc3Ryb3lcIiwgdGhpcy5vbkdyYXBoaWNzQ29udGV4dERlc3Ryb3ksIHRoaXMpO1xuICAgIHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSA9IG51bGw7XG4gIH1cbiAgX2NsZWFuR3JhcGhpY3NDb250ZXh0RGF0YShjb250ZXh0KSB7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgICBpZiAoIWdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIGlmICh0aGlzLl9ncmFwaGljc0RhdGFDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0pIHtcbiAgICAgICAgQmlnUG9vbC5yZXR1cm4odGhpcy5nZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSk7XG4gICAgICAgIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmJhdGNoZXMpIHtcbiAgICAgIGdwdUNvbnRleHQuYmF0Y2hlcy5mb3JFYWNoKChiYXRjaCkgPT4ge1xuICAgICAgICBCaWdQb29sLnJldHVybihiYXRjaCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgdGhpcy5fbmVlZHNDb250ZXh0TmVlZHNSZWJ1aWxkKSB7XG4gICAgICBpZiAodGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdKSB7XG4gICAgICAgIHRoaXMub25HcmFwaGljc0NvbnRleHREZXN0cm95KGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc0NvbnRleHROZWVkc1JlYnVpbGQubGVuZ3RoID0gMDtcbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fR3JhcGhpY3NDb250ZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJncmFwaGljc0NvbnRleHRcIlxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgR3JhcGhpY3NDb250ZXh0U3lzdGVtLiAqL1xuX0dyYXBoaWNzQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEEgdmFsdWUgZnJvbSAwIHRvIDEgdGhhdCBjb250cm9scyB0aGUgc21vb3RobmVzcyBvZiBiZXppZXIgY3VydmVzICh0aGUgaGlnaGVyIHRoZSBzbW9vdGhlcilcbiAgICogQGRlZmF1bHQgMC41XG4gICAqL1xuICBiZXppZXJTbW9vdGhuZXNzOiAwLjVcbn07XG5sZXQgR3JhcGhpY3NDb250ZXh0U3lzdGVtID0gX0dyYXBoaWNzQ29udGV4dFN5c3RlbTtcblxuZXhwb3J0IHsgR3B1R3JhcGhpY3NDb250ZXh0LCBHcmFwaGljc0NvbnRleHRSZW5kZXJEYXRhLCBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4108\n')},557:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ FillGradient)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3646);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9160);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n\n\n\n\n"use strict";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillGradient");\n    this.type = "linear";\n    this.gradientStops = [];\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(color).toHex() });\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext("2d");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x({\n      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__/* .ImageSource */ .c({\n        resource: canvas,\n        addressModeU: "clamp-to-edge",\n        addressModeV: "repeat"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__/* .Matrix */ .y();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\n\n//# sourceMappingURL=FillGradient.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNhO0FBQ0o7QUFDd0M7QUFDaEI7QUFDaEM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlLDREQUFLLGlDQUFpQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsbUJBQW1CLHlFQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZGQUFPO0FBQzlCLGtCQUFrQiw2R0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFlBQVksaUJBQWlCO0FBQzdCLGtCQUFrQixxRUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsR3JhZGllbnQubWpzPzg2YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9GaWxsR3JhZGllbnQgPSBjbGFzcyBfRmlsbEdyYWRpZW50IHtcbiAgY29uc3RydWN0b3IoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLnVpZCA9IHVpZChcImZpbGxHcmFkaWVudFwiKTtcbiAgICB0aGlzLnR5cGUgPSBcImxpbmVhclwiO1xuICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IFtdO1xuICAgIHRoaXMueDAgPSB4MDtcbiAgICB0aGlzLnkwID0geTA7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgfVxuICBhZGRDb2xvclN0b3Aob2Zmc2V0LCBjb2xvcikge1xuICAgIHRoaXMuZ3JhZGllbnRTdG9wcy5wdXNoKHsgb2Zmc2V0LCBjb2xvcjogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b0hleCgpIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIFRPRE8gbW92ZSB0byB0aGUgc3lzdGVtIVxuICBidWlsZExpbmVhckdyYWRpZW50KCkge1xuICAgIGNvbnN0IGRlZmF1bHRTaXplID0gX0ZpbGxHcmFkaWVudC5kZWZhdWx0VGV4dHVyZVNpemU7XG4gICAgY29uc3QgeyBncmFkaWVudFN0b3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gZGVmYXVsdFNpemU7XG4gICAgY2FudmFzLmhlaWdodCA9IGRlZmF1bHRTaXplO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgX0ZpbGxHcmFkaWVudC5kZWZhdWx0VGV4dHVyZVNpemUsIDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhZGllbnRTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RvcCA9IGdyYWRpZW50U3RvcHNbaV07XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIHN0b3AuY29sb3IpO1xuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGRlZmF1bHRTaXplLCBkZWZhdWx0U2l6ZSk7XG4gICAgdGhpcy50ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgSW1hZ2VTb3VyY2Uoe1xuICAgICAgICByZXNvdXJjZTogY2FudmFzLFxuICAgICAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICAgICAgICBhZGRyZXNzTW9kZVY6IFwicmVwZWF0XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc3QgeyB4MCwgeTAsIHgxLCB5MSB9ID0gdGhpcztcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeCgpO1xuICAgIGNvbnN0IGR4ID0geDEgLSB4MDtcbiAgICBjb25zdCBkeSA9IHkxIC0geTA7XG4gICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgbS50cmFuc2xhdGUoLXgwLCAteTApO1xuICAgIG0uc2NhbGUoMSAvIGRlZmF1bHRTaXplLCAxIC8gZGVmYXVsdFNpemUpO1xuICAgIG0ucm90YXRlKC1hbmdsZSk7XG4gICAgbS5zY2FsZSgyNTYgLyBkaXN0LCAxKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIH1cbn07XG5fRmlsbEdyYWRpZW50LmRlZmF1bHRUZXh0dXJlU2l6ZSA9IDI1NjtcbmxldCBGaWxsR3JhZGllbnQgPSBfRmlsbEdyYWRpZW50O1xuXG5leHBvcnQgeyBGaWxsR3JhZGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxHcmFkaWVudC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///557\n')},1261:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ FillPattern)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n"use strict";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: "repeat",\n    addressModeV: "repeat"\n  },\n  "repeat-x": {\n    addressModeU: "repeat",\n    addressModeV: "clamp-to-edge"\n  },\n  "repeat-y": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "repeat"\n  },\n  "no-repeat": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "clamp-to-edge"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillPattern");\n    this.transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y();\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n  }\n}\n\n\n//# sourceMappingURL=FillPattern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDtBQUNSOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCLHlCQUF5QixxRUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxQYXR0ZXJuLm1qcz8yZGVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcmVwZXRpdGlvbk1hcCA9IHtcbiAgcmVwZWF0OiB7XG4gICAgYWRkcmVzc01vZGVVOiBcInJlcGVhdFwiLFxuICAgIGFkZHJlc3NNb2RlVjogXCJyZXBlYXRcIlxuICB9LFxuICBcInJlcGVhdC14XCI6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwicmVwZWF0XCIsXG4gICAgYWRkcmVzc01vZGVWOiBcImNsYW1wLXRvLWVkZ2VcIlxuICB9LFxuICBcInJlcGVhdC15XCI6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICAgIGFkZHJlc3NNb2RlVjogXCJyZXBlYXRcIlxuICB9LFxuICBcIm5vLXJlcGVhdFwiOiB7XG4gICAgYWRkcmVzc01vZGVVOiBcImNsYW1wLXRvLWVkZ2VcIixcbiAgICBhZGRyZXNzTW9kZVY6IFwiY2xhbXAtdG8tZWRnZVwiXG4gIH1cbn07XG5jbGFzcyBGaWxsUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIHJlcGV0aXRpb24pIHtcbiAgICB0aGlzLnVpZCA9IHVpZChcImZpbGxQYXR0ZXJuXCIpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUoXG4gICAgICAxIC8gdGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLmhlaWdodFxuICAgICk7XG4gICAgaWYgKHJlcGV0aXRpb24pIHtcbiAgICAgIHRleHR1cmUuc291cmNlLnN0eWxlLmFkZHJlc3NNb2RlVSA9IHJlcGV0aXRpb25NYXBbcmVwZXRpdGlvbl0uYWRkcmVzc01vZGVVO1xuICAgICAgdGV4dHVyZS5zb3VyY2Uuc3R5bGUuYWRkcmVzc01vZGVWID0gcmVwZXRpdGlvbk1hcFtyZXBldGl0aW9uXS5hZGRyZXNzTW9kZVY7XG4gICAgfVxuICB9XG4gIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIHRoaXMudHJhbnNmb3JtLmNvcHlGcm9tKHRyYW5zZm9ybSk7XG4gICAgdGhpcy50cmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUoXG4gICAgICAxIC8gdGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLmhlaWdodFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmlsbFBhdHRlcm4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxQYXR0ZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1261\n')},4915:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ convertFillInputToFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(557);\n/* harmony import */ var _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1261);\n\n\n\n\n\n\n"use strict";\nfunction convertFillInputToFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  let fillStyleToParse;\n  let styleToMerge;\n  if (value?.fill) {\n    styleToMerge = value.fill;\n    fillStyleToParse = { ...defaultStyle, ...value };\n  } else {\n    styleToMerge = value;\n    fillStyleToParse = defaultStyle;\n  }\n  if (_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.isColorLike(styleToMerge)) {\n    const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(styleToMerge ?? 0);\n    const opts = {\n      ...fillStyleToParse,\n      color: temp.toNumber(),\n      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n      texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.WHITE\n    };\n    return opts;\n  } else if (styleToMerge instanceof _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_2__/* .FillPattern */ .h) {\n    const pattern = styleToMerge;\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: pattern.texture,\n      matrix: pattern.transform,\n      fill: fillStyleToParse.fill ?? null\n    };\n  } else if (styleToMerge instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillGradient */ .f) {\n    const gradient = styleToMerge;\n    gradient.buildLinearGradient();\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: gradient.texture,\n      matrix: gradient.transform\n    };\n  }\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.WHITE) {\n      const m = style.matrix?.invert() || new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Matrix */ .y();\n      m.scale(\n        1 / style.texture.frame.width,\n        1 / style.texture.frame.height\n      );\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === "clamp-to-edge") {\n      sourceStyle.addressMode = "repeat";\n    }\n  }\n  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\n\n\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkxNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzdCO0FBQ0Y7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBSztBQUNYLGlCQUFpQiw0REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkZBQU87QUFDdEI7QUFDQTtBQUNBLElBQUksaUNBQWlDLHVFQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQyx5RUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwwQkFBMEIsNkZBQU87QUFDakMsOENBQThDLHFFQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcz81ODVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4uL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4uL2ZpbGwvRmlsbFBhdHRlcm4ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIGRlZmF1bHRTdHlsZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBmaWxsU3R5bGVUb1BhcnNlO1xuICBsZXQgc3R5bGVUb01lcmdlO1xuICBpZiAodmFsdWU/LmZpbGwpIHtcbiAgICBzdHlsZVRvTWVyZ2UgPSB2YWx1ZS5maWxsO1xuICAgIGZpbGxTdHlsZVRvUGFyc2UgPSB7IC4uLmRlZmF1bHRTdHlsZSwgLi4udmFsdWUgfTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZVRvTWVyZ2UgPSB2YWx1ZTtcbiAgICBmaWxsU3R5bGVUb1BhcnNlID0gZGVmYXVsdFN0eWxlO1xuICB9XG4gIGlmIChDb2xvci5pc0NvbG9yTGlrZShzdHlsZVRvTWVyZ2UpKSB7XG4gICAgY29uc3QgdGVtcCA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdHlsZVRvTWVyZ2UgPz8gMCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmZpbGxTdHlsZVRvUGFyc2UsXG4gICAgICBjb2xvcjogdGVtcC50b051bWJlcigpLFxuICAgICAgYWxwaGE6IHRlbXAuYWxwaGEgPT09IDEgPyBmaWxsU3R5bGVUb1BhcnNlLmFscGhhIDogdGVtcC5hbHBoYSxcbiAgICAgIHRleHR1cmU6IFRleHR1cmUuV0hJVEVcbiAgICB9O1xuICAgIHJldHVybiBvcHRzO1xuICB9IGVsc2UgaWYgKHN0eWxlVG9NZXJnZSBpbnN0YW5jZW9mIEZpbGxQYXR0ZXJuKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHN0eWxlVG9NZXJnZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmlsbFN0eWxlVG9QYXJzZSxcbiAgICAgIGNvbG9yOiAxNjc3NzIxNSxcbiAgICAgIHRleHR1cmU6IHBhdHRlcm4udGV4dHVyZSxcbiAgICAgIG1hdHJpeDogcGF0dGVybi50cmFuc2Zvcm0sXG4gICAgICBmaWxsOiBmaWxsU3R5bGVUb1BhcnNlLmZpbGwgPz8gbnVsbFxuICAgIH07XG4gIH0gZWxzZSBpZiAoc3R5bGVUb01lcmdlIGluc3RhbmNlb2YgRmlsbEdyYWRpZW50KSB7XG4gICAgY29uc3QgZ3JhZGllbnQgPSBzdHlsZVRvTWVyZ2U7XG4gICAgZ3JhZGllbnQuYnVpbGRMaW5lYXJHcmFkaWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5maWxsU3R5bGVUb1BhcnNlLFxuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgdGV4dHVyZTogZ3JhZGllbnQudGV4dHVyZSxcbiAgICAgIG1hdHJpeDogZ3JhZGllbnQudHJhbnNmb3JtXG4gICAgfTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHsgLi4uZGVmYXVsdFN0eWxlLCAuLi52YWx1ZSB9O1xuICBpZiAoc3R5bGUudGV4dHVyZSkge1xuICAgIGlmIChzdHlsZS50ZXh0dXJlICE9PSBUZXh0dXJlLldISVRFKSB7XG4gICAgICBjb25zdCBtID0gc3R5bGUubWF0cml4Py5pbnZlcnQoKSB8fCBuZXcgTWF0cml4KCk7XG4gICAgICBtLnNjYWxlKFxuICAgICAgICAxIC8gc3R5bGUudGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgICAgMSAvIHN0eWxlLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgICApO1xuICAgICAgc3R5bGUubWF0cml4ID0gbTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlU3R5bGUgPSBzdHlsZS50ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICBpZiAoc291cmNlU3R5bGUuYWRkcmVzc01vZGUgPT09IFwiY2xhbXAtdG8tZWRnZVwiKSB7XG4gICAgICBzb3VyY2VTdHlsZS5hZGRyZXNzTW9kZSA9IFwicmVwZWF0XCI7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0eWxlLmNvbG9yKTtcbiAgc3R5bGUuYWxwaGEgKj0gY29sb3IuYWxwaGE7XG4gIHN0eWxlLmNvbG9yID0gY29sb3IudG9OdW1iZXIoKTtcbiAgc3R5bGUubWF0cml4ID0gc3R5bGUubWF0cml4ID8gc3R5bGUubWF0cml4LmNsb25lKCkgOiBudWxsO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmV4cG9ydCB7IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4915\n')},5263:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   j: () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4973);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3747);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8400);\n\n\n\n\n\n"use strict";\nclass Sprite extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY) {\n    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      options = { texture: options };\n    }\n    const { texture, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: "Sprite",\n      ...rest\n    });\n    this.renderPipeId = "sprite";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._boundsDirty = true;\n    this._sourceBoundsDirty = true;\n    this._roundPixels = 0;\n    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ObservablePoint */ .A(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width)\n      this.width = width;\n    if (height)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      return new Sprite(source);\n    }\n    return new Sprite(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY);\n    if (this._texture === value)\n      return;\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture\'s trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    (0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__/* .updateQuadBounds */ .w)(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite\'s origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== "object") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this._texture.orig.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n  }\n}\n\n\n//# sourceMappingURL=Sprite.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI2My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBQ087QUFDTjtBQUNsQjs7QUFFdkQ7QUFDQSxxQkFBcUIseUVBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZGQUFPO0FBQy9CLDJCQUEyQiw2RkFBTztBQUNsQyxrQkFBa0I7QUFDbEI7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0ZBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZGQUFPO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0IsNkZBQU87QUFDN0I7QUFDQTtBQUNBLHNCQUFzQiw2RkFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJGQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzPzU4NjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH0gZnJvbSAnLi4vLi4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YS91cGRhdGVRdWFkQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBzcHJpdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0gVGV4dHVyZS5FTVBUWSkge1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgb3B0aW9ucyA9IHsgdGV4dHVyZTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IHRleHR1cmUsIGFuY2hvciwgcm91bmRQaXhlbHMsIHdpZHRoLCBoZWlnaHQsIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoe1xuICAgICAgbGFiZWw6IFwiU3ByaXRlXCIsXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJQaXBlSWQgPSBcInNwcml0ZVwiO1xuICAgIHRoaXMuYmF0Y2hlZCA9IHRydWU7XG4gICAgdGhpcy5fZGlkU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRzID0geyBtaW5YOiAwLCBtYXhYOiAxLCBtaW5ZOiAwLCBtYXhZOiAwIH07XG4gICAgdGhpcy5fc291cmNlQm91bmRzID0geyBtaW5YOiAwLCBtYXhYOiAxLCBtaW5ZOiAwLCBtYXhZOiAwIH07XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IDA7XG4gICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludChcbiAgICAgIHtcbiAgICAgICAgX29uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vblZpZXdVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGFuY2hvcilcbiAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5hbGxvd0NoaWxkcmVuID0gZmFsc2U7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IHJvdW5kUGl4ZWxzID8/IGZhbHNlO1xuICAgIGlmICh3aWR0aClcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICBpZiAoaGVpZ2h0KVxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgc3ByaXRlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlLCB2aWRlbywgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIHRleHR1cmVcbiAgICogQHBhcmFtIHNvdXJjZSAtIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAqIEBwYXJhbSBbc2tpcENhY2hlXSAtIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgb3Igbm90XG4gICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHNwcml0ZVxuICAgKi9cbiAgc3RhdGljIGZyb20oc291cmNlLCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNwcml0ZShUZXh0dXJlLmZyb20oc291cmNlLCBza2lwQ2FjaGUpKTtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHZhbHVlIHx8ICh2YWx1ZSA9IFRleHR1cmUuRU1QVFkpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XG4gICAgdGhpcy5vblZpZXdVcGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nLiAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kc0RpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZSwgdGFraW5nIHRoZSB0ZXh0dXJlJ3MgdHJpbSBpbnRvIGFjY291bnQuXG4gICAqIEB0eXBlIHtyZW5kZXJpbmcuQm91bmRzfVxuICAgKi9cbiAgZ2V0IHNvdXJjZUJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5fc291cmNlQm91bmRzRGlydHkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZUJvdW5kcygpO1xuICAgICAgdGhpcy5fc291cmNlQm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUJvdW5kcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICovXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLnNvdXJjZUJvdW5kcztcbiAgICBpZiAocG9pbnQueCA+PSBib3VuZHMubWF4WCAmJiBwb2ludC54IDw9IGJvdW5kcy5taW5YKSB7XG4gICAgICBpZiAocG9pbnQueSA+PSBib3VuZHMubWF4WSAmJiBwb2ludC55IDw9IGJvdW5kcy5taW5ZKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGJvdW5kcyBvZiB0aGlzIG9iamVjdCB0byB0aGUgYm91bmRzIG9iamVjdC5cbiAgICogQHBhcmFtIGJvdW5kcyAtIFRoZSBvdXRwdXQgYm91bmRzIG9iamVjdC5cbiAgICovXG4gIGFkZEJvdW5kcyhib3VuZHMpIHtcbiAgICBjb25zdCBfYm91bmRzID0gdGhpcy5fdGV4dHVyZS50cmltID8gdGhpcy5zb3VyY2VCb3VuZHMgOiB0aGlzLmJvdW5kcztcbiAgICBib3VuZHMuYWRkRnJhbWUoX2JvdW5kcy5taW5YLCBfYm91bmRzLm1pblksIF9ib3VuZHMubWF4WCwgX2JvdW5kcy5tYXhZKTtcbiAgfVxuICBvblZpZXdVcGRhdGUoKSB7XG4gICAgdGhpcy5fZGlkQ2hhbmdlSWQgKz0gMSA8PCAxMjtcbiAgICB0aGlzLl9kaWRTcHJpdGVVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kc0RpcnR5ID0gdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5vbkNoaWxkVmlld1VwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUJvdW5kcygpIHtcbiAgICB1cGRhdGVRdWFkQm91bmRzKHRoaXMuX2JvdW5kcywgdGhpcy5fYW5jaG9yLCB0aGlzLl90ZXh0dXJlLCAwKTtcbiAgfVxuICBfdXBkYXRlU291cmNlQm91bmRzKCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBjb25zdCBzb3VyY2VCb3VuZHMgPSB0aGlzLl9zb3VyY2VCb3VuZHM7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0ZXh0dXJlLm9yaWc7XG4gICAgc291cmNlQm91bmRzLm1heFggPSAtYW5jaG9yLl94ICogd2lkdGg7XG4gICAgc291cmNlQm91bmRzLm1pblggPSBzb3VyY2VCb3VuZHMubWF4WCArIHdpZHRoO1xuICAgIHNvdXJjZUJvdW5kcy5tYXhZID0gLWFuY2hvci5feSAqIGhlaWdodDtcbiAgICBzb3VyY2VCb3VuZHMubWluWSA9IHNvdXJjZUJvdW5kcy5tYXhZICsgaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSByZW5kZXJhYmxlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgcmVuZGVyYWJsZSBhcyB3ZWxsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZVNvdXJjZSBvZiB0aGUgcmVuZGVyYWJsZSBhcyB3ZWxsXG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMgPSBmYWxzZSkge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgY29uc3QgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlU291cmNlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmVTb3VyY2U7XG4gICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5fYW5jaG9yID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHNwcml0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFRleHR1cmV9XG4gICAqIGFuZCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpcyBgKDAsMClgLCB0aGlzIG1lYW5zIHRoZSBzcHJpdGUncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0LlxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgwLjUsMC41KWAgbWVhbnMgdGhlIHNwcml0ZSdzIG9yaWdpbiBpcyBjZW50ZXJlZC5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMSwxKWAgd291bGQgbWVhbiB0aGUgc3ByaXRlJ3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIG9ubHkgc2luZ2xlIHBhcmFtZXRlciwgaXQgd2lsbCBzZXQgYm90aCB4IGFuZCB5IHRvIHRoZSBzYW1lIHZhbHVlIGFzIHNob3duIGluIHRoZSBleGFtcGxlIGJlbG93LlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh7dGV4dHVyZTogVGV4dHVyZS5XSElURX0pO1xuICAgKiBzcHJpdGUuYW5jaG9yLnNldCgwLjUpOyAvLyBUaGlzIHdpbGwgc2V0IHRoZSBvcmlnaW4gdG8gY2VudGVyLiAoMC41KSBpcyBzYW1lIGFzICgwLjUsIDAuNSkuXG4gICAqL1xuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHRoaXMuX2FuY2hvci5zZXQodmFsdWUpIDogdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogIFdoZXRoZXIgb3Igbm90IHRvIHJvdW5kIHRoZSB4L3kgcG9zaXRpb24gb2YgdGhlIHNwcml0ZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XG4gICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRXaWR0aCh2YWx1ZSwgdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoKTtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3NldEhlaWdodCh2YWx1ZSwgdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiB0aGUgU3ByaXRlIGFzIGEgW1NpemVde0BsaW5rIFNpemV9IG9iamVjdC5cbiAgICogVGhpcyBpcyBmYXN0ZXIgdGhhbiBnZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgc2VwYXJhdGVseS5cbiAgICogQHBhcmFtIG91dCAtIE9wdGlvbmFsIG9iamVjdCB0byBzdG9yZSB0aGUgc2l6ZSBpbi5cbiAgICogQHJldHVybnMgLSBUaGUgc2l6ZSBvZiB0aGUgU3ByaXRlLlxuICAgKi9cbiAgZ2V0U2l6ZShvdXQpIHtcbiAgICBpZiAoIW91dCkge1xuICAgICAgb3V0ID0ge307XG4gICAgfVxuICAgIG91dC53aWR0aCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgb3V0LmhlaWdodCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIFNwcml0ZSB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGlzIGNhbiBiZSBlaXRoZXIgYSBudW1iZXIgb3IgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZXQuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgd2lkdGhgIGlmIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIHNldFNpemUodmFsdWUsIGhlaWdodCkge1xuICAgIGxldCBjb252ZXJ0ZWRXaWR0aDtcbiAgICBsZXQgY29udmVydGVkSGVpZ2h0O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnZlcnRlZFdpZHRoID0gdmFsdWU7XG4gICAgICBjb252ZXJ0ZWRIZWlnaHQgPSBoZWlnaHQgPz8gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnZlcnRlZFdpZHRoID0gdmFsdWUud2lkdGg7XG4gICAgICBjb252ZXJ0ZWRIZWlnaHQgPSB2YWx1ZS5oZWlnaHQgPz8gdmFsdWUud2lkdGg7XG4gICAgfVxuICAgIGlmIChjb252ZXJ0ZWRXaWR0aCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zZXRXaWR0aChjb252ZXJ0ZWRXaWR0aCwgdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZEhlaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zZXRIZWlnaHQoY29udmVydGVkSGVpZ2h0LCB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgU3ByaXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5263\n')},9154:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs + 1 modules\nvar Resolver = __webpack_require__(651);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(8479);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs\n\n\n\n"use strict";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture/* Texture */.x ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle/* Rectangle */.A(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle/* Rectangle */.A(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture/* Texture */.x({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don\'t use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst validImages = [\n  "jpg",\n  "png",\n  "jpeg",\n  "avif",\n  "webp",\n  "basis",\n  "etc2",\n  "bc7",\n  "bc6h",\n  "bc5",\n  "bc4",\n  "bc3",\n  "bc2",\n  "bc1",\n  "eac",\n  "astc"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path/* path */.E.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: Extensions/* ExtensionType */.nw.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    test: (value) => {\n      const tempURL = value.split("?")[0];\n      const split = tempURL.split(".");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === "json" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(".");\n      return {\n        resolution: parseFloat(Resolver/* Resolver */.H.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: "spritesheetLoader",\n    extension: {\n      type: Extensions/* ExtensionType */.nw.LoadParser,\n      priority: LoaderParser/* LoaderParserPriority */.Q.Normal\n    },\n    async testParse(asset, options) {\n      return path/* path */.E.extname(options.src).toLowerCase() === ".json" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path/* path */.E.dirname(options.src);\n      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {\n        basePath += "/";\n      }\n      let texture;\n      if (imageTexture instanceof Texture/* Texture */.x) {\n        texture = imageTexture;\n      } else {\n        const imagePath = (0,copySearchParams/* copySearchParams */.u)(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== "string") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = (0,copySearchParams/* copySearchParams */.u)(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    unload(spritesheet) {\n      spritesheet.destroy(true);\n    }\n  }\n};\n\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUM5STBEO0FBQ0E7O0FBRTFEO0FBQ0EsNkJBQVUsS0FBSyxnQkFBZ0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zcHJpdGVzaGVldC9TcHJpdGVzaGVldC5tanM/MWIwMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zcHJpdGVzaGVldC9zcHJpdGVzaGVldEFzc2V0Lm1qcz9iNzc0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3Nwcml0ZXNoZWV0L2luaXQubWpzPzA3ODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9TcHJpdGVzaGVldCA9IGNsYXNzIF9TcHJpdGVzaGVldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFJlZmVyZW5jZSB0byB0aGUgc291cmNlIEJhc2VUZXh0dXJlIG9iamVjdC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBTcHJpdGVzaGVldCBpbWFnZSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgZGF0YSkge1xuICAgIC8qKiBGb3IgbXVsdGktcGFja2VkIHNwcml0ZXNoZWV0cywgdGhpcyBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhbGwgdGhlIG90aGVyIHNwcml0ZXNoZWV0cyBpdCBkZXBlbmRzIG9uLiAqL1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlID8gdGV4dHVyZSA6IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlU291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG4gICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgY29uc3QgbWV0YVJlc29sdXRpb24gPSBwYXJzZUZsb2F0KGRhdGEubWV0YS5zY2FsZSk7XG4gICAgaWYgKG1ldGFSZXNvbHV0aW9uKSB7XG4gICAgICB0aGlzLnJlc29sdXRpb24gPSBtZXRhUmVzb2x1dGlvbjtcbiAgICAgIHRleHR1cmUuc291cmNlLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIH1cbiAgICB0aGlzLl9mcmFtZXMgPSB0aGlzLmRhdGEuZnJhbWVzO1xuICAgIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyk7XG4gICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXIgc3ByaXRlc2hlZXQgZnJvbSBsb2FkZWQgZGF0YS4gVGhpcyBpcyBkb25lIGFzeW5jaHJvbm91c2x5XG4gICAqIHRvIHByZXZlbnQgY3JlYXRpbmcgdG9vIG1hbnkgVGV4dHVyZSB3aXRoaW4gYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICovXG4gIHBhcnNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICBpZiAodGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA8PSBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSkge1xuICAgICAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKDApO1xuICAgICAgICB0aGlzLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xuICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhIGJhdGNoIG9mIGZyYW1lc1xuICAgKiBAcGFyYW0gaW5pdGlhbEZyYW1lSW5kZXggLSBUaGUgaW5kZXggb2YgZnJhbWUgdG8gc3RhcnQuXG4gICAqL1xuICBfcHJvY2Vzc0ZyYW1lcyhpbml0aWFsRnJhbWVJbmRleCkge1xuICAgIGxldCBmcmFtZUluZGV4ID0gaW5pdGlhbEZyYW1lSW5kZXg7XG4gICAgY29uc3QgbWF4RnJhbWVzID0gX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkU7XG4gICAgd2hpbGUgKGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2ZyYW1lS2V5c1tmcmFtZUluZGV4XTtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9mcmFtZXNbaV07XG4gICAgICBjb25zdCByZWN0ID0gZGF0YS5mcmFtZTtcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIGxldCBmcmFtZSA9IG51bGw7XG4gICAgICAgIGxldCB0cmltID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc291cmNlU2l6ZSA9IGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zb3VyY2VTaXplID8gZGF0YS5zb3VyY2VTaXplIDogZGF0YS5mcmFtZTtcbiAgICAgICAgY29uc3Qgb3JpZyA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGguZmxvb3Ioc291cmNlU2l6ZS53KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHNvdXJjZVNpemUuaCkgLyB0aGlzLnJlc29sdXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRhdGEucm90YXRlZCkge1xuICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNwcml0ZVNvdXJjZVNpemUpIHtcbiAgICAgICAgICB0cmltID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIE1hdGguZmxvb3IoZGF0YS5zcHJpdGVTb3VyY2VTaXplLngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueSkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBuZXcgVGV4dHVyZSh7XG4gICAgICAgICAgc291cmNlOiB0aGlzLnRleHR1cmVTb3VyY2UsXG4gICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgb3JpZyxcbiAgICAgICAgICB0cmltLFxuICAgICAgICAgIHJvdGF0ZTogZGF0YS5yb3RhdGVkID8gMiA6IDAsXG4gICAgICAgICAgZGVmYXVsdEFuY2hvcjogZGF0YS5hbmNob3IsXG4gICAgICAgICAgZGVmYXVsdEJvcmRlcnM6IGRhdGEuYm9yZGVycyxcbiAgICAgICAgICBsYWJlbDogaS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnJhbWVJbmRleCsrO1xuICAgIH1cbiAgfVxuICAvKiogUGFyc2UgYW5pbWF0aW9ucyBjb25maWcuICovXG4gIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XG4gICAgZm9yIChjb25zdCBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1hdGlvbnNbYW5pbU5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lTmFtZSA9IGFuaW1hdGlvbnNbYW5pbU5hbWVdW2ldO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdLnB1c2godGhpcy50ZXh0dXJlc1tmcmFtZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLiAqL1xuICBfcGFyc2VDb21wbGV0ZSgpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudGV4dHVyZXMpO1xuICB9XG4gIC8qKiBCZWdpbiB0aGUgbmV4dCBiYXRjaCBvZiB0ZXh0dXJlcy4gKi9cbiAgX25leHRCYXRjaCgpIHtcbiAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKHRoaXMuX2JhdGNoSW5kZXggKiBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSk7XG4gICAgdGhpcy5fYmF0Y2hJbmRleCsrO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2JhdGNoSW5kZXggKiBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbmV4dEJhdGNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xuICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgU3ByaXRlc2hlZXQgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCYXNlID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlcykge1xuICAgICAgdGhpcy50ZXh0dXJlc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lcyA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVLZXlzID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZXMgPSBudWxsO1xuICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgdGhpcy5fdGV4dHVyZT8uZGVzdHJveSgpO1xuICAgICAgdGhpcy50ZXh0dXJlU291cmNlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlU291cmNlID0gbnVsbDtcbiAgICB0aGlzLmxpbmtlZFNoZWV0cyA9IFtdO1xuICB9XG59O1xuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUZXh0dXJlcyB0byBidWlsZCBwZXIgcHJvY2Vzcy4gKi9cbl9TcHJpdGVzaGVldC5CQVRDSF9TSVpFID0gMWUzO1xubGV0IFNwcml0ZXNoZWV0ID0gX1Nwcml0ZXNoZWV0O1xuXG5leHBvcnQgeyBTcHJpdGVzaGVldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlc2hlZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBSZXNvbHZlciB9IGZyb20gJy4uL2Fzc2V0cy9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgY29weVNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2Fzc2V0cy91dGlscy9jb3B5U2VhcmNoUGFyYW1zLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5tanMnO1xuaW1wb3J0IHsgU3ByaXRlc2hlZXQgfSBmcm9tICcuL1Nwcml0ZXNoZWV0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsaWRJbWFnZXMgPSBbXG4gIFwianBnXCIsXG4gIFwicG5nXCIsXG4gIFwianBlZ1wiLFxuICBcImF2aWZcIixcbiAgXCJ3ZWJwXCIsXG4gIFwiYmFzaXNcIixcbiAgXCJldGMyXCIsXG4gIFwiYmM3XCIsXG4gIFwiYmM2aFwiLFxuICBcImJjNVwiLFxuICBcImJjNFwiLFxuICBcImJjM1wiLFxuICBcImJjMlwiLFxuICBcImJjMVwiLFxuICBcImVhY1wiLFxuICBcImFzdGNcIlxuXTtcbmZ1bmN0aW9uIGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCwgaWdub3JlTXVsdGlQYWNrKSB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG91dFtrZXldID0gYXNzZXQ7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhhc3NldC50ZXh0dXJlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3V0W2tleV0gPSBhc3NldC50ZXh0dXJlc1trZXldO1xuICB9KTtcbiAgaWYgKCFpZ25vcmVNdWx0aVBhY2spIHtcbiAgICBjb25zdCBiYXNlUGF0aCA9IHBhdGguZGlybmFtZShrZXlzWzBdKTtcbiAgICBhc3NldC5saW5rZWRTaGVldHMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qgb3V0MiA9IGdldENhY2hlYWJsZUFzc2V0cyhbYCR7YmFzZVBhdGh9LyR7YXNzZXQuZGF0YS5tZXRhLnJlbGF0ZWRfbXVsdGlfcGFja3NbaV19YF0sIGl0ZW0sIHRydWUpO1xuICAgICAgT2JqZWN0LmFzc2lnbihvdXQsIG91dDIpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5jb25zdCBzcHJpdGVzaGVldEFzc2V0ID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuQXNzZXQsXG4gIC8qKiBIYW5kbGUgdGhlIGNhY2hpbmcgb2YgdGhlIHJlbGF0ZWQgU3ByaXRlc2hlZXQgVGV4dHVyZXMgKi9cbiAgY2FjaGU6IHtcbiAgICB0ZXN0OiAoYXNzZXQpID0+IGFzc2V0IGluc3RhbmNlb2YgU3ByaXRlc2hlZXQsXG4gICAgZ2V0Q2FjaGVhYmxlQXNzZXRzOiAoa2V5cywgYXNzZXQpID0+IGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCwgZmFsc2UpXG4gIH0sXG4gIC8qKiBSZXNvbHZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBhc3NldC4gKi9cbiAgcmVzb2x2ZXI6IHtcbiAgICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBVUkwgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF07XG4gICAgICBjb25zdCBzcGxpdCA9IHRlbXBVUkwuc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gc3BsaXQucG9wKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBzcGxpdC5wb3AoKTtcbiAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwianNvblwiICYmIHZhbGlkSW1hZ2VzLmluY2x1ZGVzKGZvcm1hdCk7XG4gICAgfSxcbiAgICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoUmVzb2x2ZXIuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgICAgZm9ybWF0OiBzcGxpdFtzcGxpdC5sZW5ndGggLSAyXSxcbiAgICAgICAgc3JjOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBMb2FkZXIgcGx1Z2luIHRoYXQgcGFyc2VzIHNwcml0ZSBzaGVldHMhXG4gICAqIG9uY2UgdGhlIEpTT04gaGFzIGJlZW4gbG9hZGVkIHRoaXMgY2hlY2tzIHRvIHNlZSBpZiB0aGUgSlNPTiBpcyBzcHJpdGVzaGVldCBkYXRhLlxuICAgKiBJZiBpdCBpcywgd2UgbG9hZCB0aGUgc3ByaXRlc2hlZXRzIGltYWdlIGFuZCBwYXJzZSB0aGUgZGF0YSBpbnRvIFNwcml0ZXNoZWV0XG4gICAqIEFsbCB0ZXh0dXJlcyBpbiB0aGUgc3ByaXRlIHNoZWV0IGFyZSB0aGVuIGFkZGVkIHRvIHRoZSBjYWNoZVxuICAgKi9cbiAgbG9hZGVyOiB7XG4gICAgbmFtZTogXCJzcHJpdGVzaGVldExvYWRlclwiLFxuICAgIGV4dGVuc2lvbjoge1xuICAgICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICAgIH0sXG4gICAgYXN5bmMgdGVzdFBhcnNlKGFzc2V0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcGF0aC5leHRuYW1lKG9wdGlvbnMuc3JjKS50b0xvd2VyQ2FzZSgpID09PSBcIi5qc29uXCIgJiYgISFhc3NldC5mcmFtZXM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZShhc3NldCwgb3B0aW9ucywgbG9hZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRleHR1cmU6IGltYWdlVGV4dHVyZSxcbiAgICAgICAgLy8gaWYgdXNlciBuZWVkIHRvIHVzZSBwcmVsb2FkZWQgdGV4dHVyZVxuICAgICAgICBpbWFnZUZpbGVuYW1lXG4gICAgICAgIC8vIGlmIHVzZXIgbmVlZCB0byB1c2UgY3VzdG9tIGZpbGVuYW1lIChub3QgZnJvbSBqc29uRmlsZS5tZXRhLmltYWdlKVxuICAgICAgfSA9IG9wdGlvbnM/LmRhdGEgPz8ge307XG4gICAgICBsZXQgYmFzZVBhdGggPSBwYXRoLmRpcm5hbWUob3B0aW9ucy5zcmMpO1xuICAgICAgaWYgKGJhc2VQYXRoICYmIGJhc2VQYXRoLmxhc3RJbmRleE9mKFwiL1wiKSAhPT0gYmFzZVBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBiYXNlUGF0aCArPSBcIi9cIjtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0dXJlO1xuICAgICAgaWYgKGltYWdlVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgdGV4dHVyZSA9IGltYWdlVGV4dHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGltYWdlUGF0aCA9IGNvcHlTZWFyY2hQYXJhbXMoYmFzZVBhdGggKyAoaW1hZ2VGaWxlbmFtZSA/PyBhc3NldC5tZXRhLmltYWdlKSwgb3B0aW9ucy5zcmMpO1xuICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCBsb2FkZXIubG9hZChbaW1hZ2VQYXRoXSk7XG4gICAgICAgIHRleHR1cmUgPSBhc3NldHNbaW1hZ2VQYXRoXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0KFxuICAgICAgICB0ZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgYXNzZXRcbiAgICAgICk7XG4gICAgICBhd2FpdCBzcHJpdGVzaGVldC5wYXJzZSgpO1xuICAgICAgY29uc3QgbXVsdGlQYWNrcyA9IGFzc2V0Py5tZXRhPy5yZWxhdGVkX211bHRpX3BhY2tzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXVsdGlQYWNrcykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG11bHRpUGFja3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaXRlbVVybCA9IGJhc2VQYXRoICsgaXRlbTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhPy5pZ25vcmVNdWx0aVBhY2spIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtVXJsID0gY29weVNlYXJjaFBhcmFtcyhpdGVtVXJsLCBvcHRpb25zLnNyYyk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzcmM6IGl0ZW1VcmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlnbm9yZU11bHRpUGFjazogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cyA9IHJlcztcbiAgICAgICAgcmVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmxpbmtlZFNoZWV0cyA9IFtzcHJpdGVzaGVldF0uY29uY2F0KHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cy5maWx0ZXIoKHNwKSA9PiBzcCAhPT0gaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcHJpdGVzaGVldDtcbiAgICB9LFxuICAgIHVubG9hZChzcHJpdGVzaGVldCkge1xuICAgICAgc3ByaXRlc2hlZXQuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCB7IHNwcml0ZXNoZWV0QXNzZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZXNoZWV0QXNzZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9IGZyb20gJy4vc3ByaXRlc2hlZXRBc3NldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKHNwcml0ZXNoZWV0QXNzZXQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9154\n')},9366:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  v: () => (/* binding */ Ticker)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/ticker/TickerListener.mjs\n\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs\n\n\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = ticker_const/* UPDATE_PRIORITY */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = ticker_const/* UPDATE_PRIORITY */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\n\n//# sourceMappingURL=Ticker.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3RpY2tlci9UaWNrZXJMaXN0ZW5lci5tanM/YzQ0ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi90aWNrZXIvVGlja2VyLm1qcz84NDM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyTGlzdGVuZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgKiBAcGFyYW0gb25jZSAtIElmIHRoZSBoYW5kbGVyIHNob3VsZCBmaXJlIG9uY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZuLCBjb250ZXh0ID0gbnVsbCwgcHJpb3JpdHkgPSAwLCBvbmNlID0gZmFsc2UpIHtcbiAgICAvKiogVGhlIG5leHQgaXRlbSBpbiBjaGFpbi4gKi9cbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIC8qKiBUaGUgcHJldmlvdXMgaXRlbSBpbiBjaGFpbi4gKi9cbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAvKiogYHRydWVgIGlmIHRoaXMgbGlzdGVuZXIgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHkuICovXG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgdGhpcy5fb25jZSA9IG9uY2U7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXBsZSBjb21wYXJlIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgYSBmdW5jdGlvbiBhbmQgY29udGV4dCBtYXRjaC5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBsaXN0ZW5lciBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAqL1xuICBtYXRjaChmbiwgY29udGV4dCA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fZm4gPT09IGZuICYmIHRoaXMuX2NvbnRleHQgPT09IGNvbnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYnkgY2FsbGluZyB0aGUgY3VycmVudCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHRpY2tlciAtIFRoZSB0aWNrZXIgZW1pdHRpbmcuXG4gICAqIEByZXR1cm5zIE5leHQgdGlja2VyXG4gICAqL1xuICBlbWl0KHRpY2tlcikge1xuICAgIGlmICh0aGlzLl9mbikge1xuICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB0aWNrZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZm4odGlja2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG4gICAgaWYgKHRoaXMuX29uY2UpIHtcbiAgICAgIHRoaXMuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcHJldmlvdXMgLSBJbnB1dCBub2RlLCBwcmV2aW91cyBsaXN0ZW5lclxuICAgKi9cbiAgY29ubmVjdChwcmV2aW91cykge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICBpZiAocHJldmlvdXMubmV4dCkge1xuICAgICAgcHJldmlvdXMubmV4dC5wcmV2aW91cyA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQ7XG4gICAgcHJldmlvdXMubmV4dCA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgKiBAcGFyYW0gaGFyZCAtIGB0cnVlYCB0byByZW1vdmUgdGhlIGBuZXh0YCByZWZlcmVuY2UsIHRoaXNcbiAgICogICAgICAgIGlzIGNvbnNpZGVyZWQgYSBoYXJkIGRlc3Ryb3kuIFNvZnQgZGVzdHJveSBtYWludGFpbnMgdGhlIG5leHQgcmVmZXJlbmNlLlxuICAgKiBAcmV0dXJucyBUaGUgbGlzdGVuZXIgdG8gcmVkaXJlY3Qgd2hpbGUgZW1pdHRpbmcgb3IgcmVtb3ZpbmcuXG4gICAqL1xuICBkZXN0cm95KGhhcmQgPSBmYWxzZSkge1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3Q7XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG59XG5cbmV4cG9ydCB7IFRpY2tlckxpc3RlbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJMaXN0ZW5lci5tanMubWFwXG4iLCJpbXBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXJMaXN0ZW5lciB9IGZyb20gJy4vVGlja2VyTGlzdGVuZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVGlja2VyID0gY2xhc3MgX1RpY2tlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGlja2VyIHNob3VsZCBpbnZva2UgdGhlIG1ldGhvZFxuICAgICAqIHtAbGluayB0aWNrZXIuVGlja2VyI3N0YXJ0fHN0YXJ0fSBhdXRvbWF0aWNhbGx5IHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNjYWxhciB0aW1lIHZhbHVlIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIHRpY2tlci5UaWNrZXIjbWluRlBTfG1pbkZQU31cbiAgICAgKiBhbmQgaXMgc2NhbGVkIHdpdGgge0BsaW5rIHRpY2tlci5UaWNrZXIjc3BlZWR8c3BlZWR9LlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FwIG1heSBiZSBleGNlZWRlZCBieSBzY2FsaW5nLlxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB0aW1lIHtAbGluayB0aWNrZXIuVGlja2VyI3VwZGF0ZXx1cGRhdGV9IHdhcyBpbnZva2VkLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWxzbyByZXNldCBpbnRlcm5hbGx5IG91dHNpZGUgb2YgaW52b2tpbmdcbiAgICAgKiB1cGRhdGUsIGJ1dCBvbmx5IHdoZW4gYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZC5cbiAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcbiAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUaW1lID0gLTE7XG4gICAgLyoqXG4gICAgICogRmFjdG9yIG9mIGN1cnJlbnQge0BsaW5rIHRpY2tlci5UaWNrZXIjZGVsdGFUaW1lfGRlbHRhVGltZX0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTY2FsZXMgdGlja2VyLmRlbHRhVGltZSB0byB3aGF0IHdvdWxkIGJlXG4gICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXG4gICAgICogdGlja2VyLnNwZWVkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAqIGB0cnVlYCBpZiB7QGxpbmsgdGlja2VyLlRpY2tlciNzdGFydHxzdGFydH0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqIGBmYWxzZWAgaWYge0BsaW5rIHRpY2tlci5UaWNrZXIjc3RvcHxTdG9wfSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogV2hpbGUgYGZhbHNlYCwgdGhpcyB2YWx1ZSBtYXkgY2hhbmdlIHRvIGB0cnVlYCBpbiB0aGVcbiAgICAgKiBldmVudCBvZiB7QGxpbmsgdGlja2VyLlRpY2tlciNhdXRvU3RhcnR8YXV0b1N0YXJ0fSBiZWluZyBgdHJ1ZWBcbiAgICAgKiBhbmQgYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAvKiogSW50ZXJuYWwgY3VycmVudCBmcmFtZSByZXF1ZXN0IElEICovXG4gICAgdGhpcy5fcmVxdWVzdElkID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1pbkZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgKiBUaGlzIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdXBkYXRlcy5cbiAgICAgKi9cbiAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxMDA7XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdmFsdWUgbWFuYWdlZCBieSBtaW5GUFMgcHJvcGVydHkgc2V0dGVyIGFuZCBnZXR0ZXIuXG4gICAgICogVGhpcyBpcyB0aGUgbWluaW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICovXG4gICAgdGhpcy5fbWluRWxhcHNlZE1TID0gMDtcbiAgICAvKiogSWYgZW5hYmxlZCwgZGVsZXRpbmcgaXMgZGlzYWJsZWQuKi9cbiAgICB0aGlzLl9wcm90ZWN0ZWQgPSBmYWxzZTtcbiAgICAvKiogVGhlIGxhc3QgdGltZSBrZXlmcmFtZSB3YXMgZXhlY3V0ZWQuIE1haW50YWlucyBhIHJlbGF0aXZlbHkgZml4ZWQgaW50ZXJ2YWwgd2l0aCB0aGUgcHJldmlvdXMgdmFsdWUuICovXG4gICAgdGhpcy5fbGFzdEZyYW1lID0gLTE7XG4gICAgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcihudWxsLCBudWxsLCBJbmZpbml0eSk7XG4gICAgdGhpcy5kZWx0YU1TID0gMSAvIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICB0aGlzLmVsYXBzZWRNUyA9IDEgLyBfVGlja2VyLnRhcmdldEZQTVM7XG4gICAgdGhpcy5fdGljayA9ICh0aW1lKSA9PiB7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aW1lKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCAmJiB0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAqIElmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsXG4gICAqIGVtaXR0ZXIgaGFzIGxpc3RlbmVycywgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcXVlc3RJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5sYXN0VGltZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgY2FuY2VscyBhIHBlbmRpbmcgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbmNlbElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAqIElmIHRoZSB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZCBpdCBjaGVja3MgaWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHlcbiAgICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxuICAgKiBjb25kaXRpb25zIGFyZSBtZXQsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC4gSWYgdGhlIHRpY2tlciBoYXMgbm90XG4gICAqIGJlZW4gc3RhcnRlZCwgYnV0IGF1dG9TdGFydCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRpY2tlciBzdGFydHMgbm93LFxuICAgKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydElmUG9zc2libGUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dG9TdGFydCkge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciB0aWNrIGV2ZW50cy4gQ2FsbHMgY29udGludW91c2x5IHVubGVzc1xuICAgKiBpdCBpcyByZW1vdmVkIG9yIHRoZSB0aWNrZXIgaXMgc3RvcHBlZC5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciB1cGRhdGVzXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgYWRkKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IFVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSkpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciB0aGUgdGljayBldmVudCB3aGljaCBpcyBvbmx5IGV4ZWN1dGUgb25jZS5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgYWRkT25jZShmbiwgY29udGV4dCwgcHJpb3JpdHkgPSBVUERBVEVfUFJJT1JJVFkuTk9STUFMKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lcihmbiwgY29udGV4dCwgcHJpb3JpdHksIHRydWUpKTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWxseSBhZGRzIHRoZSBldmVudCBoYW5kbGVyIHNvIHRoYXQgaXQgY2FuIGJlIHNvcnRlZCBieSBwcmlvcml0eS5cbiAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cbiAgICogYmVmb3JlIHRoZSByZW5kZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEN1cnJlbnQgbGlzdGVuZXIgYmVpbmcgYWRkZWQuXG4gICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICovXG4gIF9hZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIGxldCBwcmV2aW91cyA9IHRoaXMuX2hlYWQ7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyLnByaW9yaXR5ID4gY3VycmVudC5wcmlvcml0eSkge1xuICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmICghbGlzdGVuZXIucHJldmlvdXMpIHtcbiAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSBoYW5kbGVycyBtYXRjaGluZyB0aGUgZnVuY3Rpb24gYW5kIGNvbnRleHQgcGFyYW1ldGVycy5cbiAgICogSWYgbm8gaGFuZGxlcnMgYXJlIGxlZnQgYWZ0ZXIgcmVtb3ZpbmcsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgcmVtb3ZlKGZuLCBjb250ZXh0KSB7XG4gICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyLm1hdGNoKGZuLCBjb250ZXh0KSkge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9oZWFkLm5leHQpIHtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvbiB0aGlzIHRpY2tlciwgY2FsY3VsYXRlZCBieSB3YWxraW5nIHRocm91Z2ggbGlua2VkIGxpc3RcbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQubmV4dCkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIC8qKiBTdGFydHMgdGhlIHRpY2tlci4gSWYgdGhlIHRpY2tlciBoYXMgbGlzdGVuZXJzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQgYXQgdGhpcyBwb2ludC4gKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZCBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC4gKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICB9XG4gIC8qKiBEZXN0cm95IHRoZSB0aWNrZXIgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLiBDYWxsaW5nIHRoaXMgbWV0aG9kIHJlbW92ZXMgYWxsIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZXZlbnRzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5fcHJvdGVjdGVkKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcnMgYW4gdXBkYXRlLiBBbiB1cGRhdGUgZW50YWlscyBzZXR0aW5nIHRoZVxuICAgKiBjdXJyZW50IHtAbGluayB0aWNrZXIuVGlja2VyI2VsYXBzZWRNU3xlbGFwc2VkTVN9LFxuICAgKiB0aGUgY3VycmVudCB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfSxcbiAgICogaW52b2tpbmcgYWxsIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZGVsdGFUaW1lLFxuICAgKiBhbmQgdGhlbiBmaW5hbGx5IHNldHRpbmcge0BsaW5rIHRpY2tlci5UaWNrZXIjbGFzdFRpbWV8bGFzdFRpbWV9XG4gICAqIHdpdGggdGhlIHZhbHVlIG9mIGN1cnJlbnRUaW1lIHRoYXQgd2FzIHByb3ZpZGVkLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IGFuaW1hdGlvblxuICAgKiBmcmFtZSBjYWxsYmFja3MgaWYgdGhlIHRpY2tlciBpbnN0YW5jZSBoYXMgYmVlbiBzdGFydGVkXG4gICAqIGFuZCBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnJlbnRUaW1lPXBlcmZvcm1hbmNlLm5vdygpXSAtIHRoZSBjdXJyZW50IHRpbWUgb2YgZXhlY3V0aW9uXG4gICAqL1xuICB1cGRhdGUoY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSkge1xuICAgIGxldCBlbGFwc2VkTVM7XG4gICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0VGltZSkge1xuICAgICAgZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICBpZiAoZWxhcHNlZE1TID4gdGhpcy5fbWF4RWxhcHNlZE1TKSB7XG4gICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIGVsYXBzZWRNUyAqPSB0aGlzLnNwZWVkO1xuICAgICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fbGFzdEZyYW1lIHwgMDtcbiAgICAgICAgaWYgKGRlbHRhIDwgdGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGN1cnJlbnRUaW1lIC0gZGVsdGEgJSB0aGlzLl9taW5FbGFwc2VkTVM7XG4gICAgICB9XG4gICAgICB0aGlzLmRlbHRhTVMgPSBlbGFwc2VkTVM7XG4gICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZGVsdGFNUyAqIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgbGV0IGxpc3RlbmVyID0gaGVhZC5uZXh0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZW1pdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGVhZC5uZXh0KSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xuICAgIH1cbiAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmcmFtZXMgcGVyIHNlY29uZCBhdCB3aGljaCB0aGlzIHRpY2tlciBpcyBydW5uaW5nLlxuICAgKiBUaGUgZGVmYXVsdCBpcyBhcHByb3hpbWF0ZWx5IDYwIGluIG1vc3QgbW9kZXJuIGJyb3dzZXJzLlxuICAgKiAqKk5vdGU6KiogVGhpcyBkb2VzIG5vdCBmYWN0b3IgaW4gdGhlIHZhbHVlIG9mXG4gICAqIHtAbGluayB0aWNrZXIuVGlja2VyI3NwZWVkfHNwZWVkfSwgd2hpY2ggaXMgc3BlY2lmaWNcbiAgICogdG8gc2NhbGluZyB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfS5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBGUFMoKSB7XG4gICAgcmV0dXJuIDFlMyAvIHRoaXMuZWxhcHNlZE1TO1xuICB9XG4gIC8qKlxuICAgKiBNYW5hZ2VzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xuICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgdGlja2VyLlRpY2tlciN1cGRhdGV8dXBkYXRlfS5cbiAgICogVGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGNhcCB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfSxcbiAgICogYnV0IGRvZXMgbm90IGVmZmVjdCB0aGUgbWVhc3VyZWQgdmFsdWUgb2Yge0BsaW5rIHRpY2tlci5UaWNrZXIjRlBTfEZQU30uXG4gICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIGAwYCBhbmQgYFRpY2tlci50YXJnZXRGUE1TICogMTAwMGAuXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQGRlZmF1bHQgMTBcbiAgICovXG4gIGdldCBtaW5GUFMoKSB7XG4gICAgcmV0dXJuIDFlMyAvIHRoaXMuX21heEVsYXBzZWRNUztcbiAgfVxuICBzZXQgbWluRlBTKGZwcykge1xuICAgIGNvbnN0IG1pbkZQUyA9IE1hdGgubWluKHRoaXMubWF4RlBTLCBmcHMpO1xuICAgIGNvbnN0IG1pbkZQTVMgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtaW5GUFMpIC8gMWUzLCBfVGlja2VyLnRhcmdldEZQTVMpO1xuICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEgLyBtaW5GUE1TO1xuICB9XG4gIC8qKlxuICAgKiBNYW5hZ2VzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgcmVxdWlyZWQgdG9cbiAgICogZWxhcHNlIGJldHdlZW4gaW52b2tpbmcge0BsaW5rIHRpY2tlci5UaWNrZXIjdXBkYXRlfHVwZGF0ZX0uXG4gICAqIFRoaXMgd2lsbCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayB0aWNrZXIuVGlja2VyI0ZQU3xGUFN9LlxuICAgKiBJZiBpdCBpcyBzZXQgdG8gYDBgLCB0aGVuIHRoZXJlIGlzIG5vIGxpbWl0OyBQaXhpSlMgd2lsbCByZW5kZXIgYXMgbWFueSBmcmFtZXMgYXMgaXQgY2FuLlxuICAgKiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhdCBsZWFzdCBgbWluRlBTYFxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBtYXhGUFMoKSB7XG4gICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoMWUzIC8gdGhpcy5fbWluRWxhcHNlZE1TKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc2V0IG1heEZQUyhmcHMpIHtcbiAgICBpZiAoZnBzID09PSAwKSB7XG4gICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhGUFMgPSBNYXRoLm1heCh0aGlzLm1pbkZQUywgZnBzKTtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyAobWF4RlBTIC8gMWUzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIEFuaW1hdGVkU3ByaXRlfSBhbmQgYnlcbiAgICoge0BsaW5rIFZpZGVvUmVzb3VyY2V9IHRvIHVwZGF0ZSBhbmltYXRpb24gZnJhbWVzIC8gdmlkZW8gdGV4dHVyZXMuXG4gICAqXG4gICAqIEl0IG1heSBhbHNvIGJlIHVzZWQgYnkge0BsaW5rIEFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogVGhlIHByb3BlcnR5IHtAbGluayB0aWNrZXIuVGlja2VyI2F1dG9TdGFydHxhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWAgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFRpY2tlciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCB0aWNrZXIgPSBUaWNrZXIuc2hhcmVkO1xuICAgKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAgICogLy8gQnkgZGVmYXVsdCB0aGlzIGlzIHRydWUgb25seSBmb3IgdGhlIFRpY2tlci5zaGFyZWQgaW5zdGFuY2UuXG4gICAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAgICpcbiAgICogLy8gRllJLCBjYWxsIHRoaXMgdG8gZW5zdXJlIHRoZSB0aWNrZXIgaXMgc3RvcHBlZC4gSXQgc2hvdWxkIGJlIHN0b3BwZWRcbiAgICogLy8gaWYgeW91IGhhdmUgbm90IGF0dGVtcHRlZCB0byByZW5kZXIgYW55dGhpbmcgeWV0LlxuICAgKiB0aWNrZXIuc3RvcCgpO1xuICAgKlxuICAgKiAvLyBDYWxsIHRoaXMgd2hlbiB5b3UgYXJlIHJlYWR5IGZvciBhIHJ1bm5pbmcgc2hhcmVkIHRpY2tlci5cbiAgICogdGlja2VyLnN0YXJ0KCk7XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciwgQ29udGFpbmVyIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIFlvdSBtYXkgdXNlIHRoZSBzaGFyZWQgdGlja2VyIHRvIHJlbmRlci4uLlxuICAgKiBjb25zdCByZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlcigpO1xuICAgKiBjb25zdCBzdGFnZSA9IG5ldyBDb250YWluZXIoKTtcbiAgICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcbiAgICogdGlja2VyLmFkZCgodGltZSkgPT4gcmVuZGVyZXIucmVuZGVyKHN0YWdlKSk7XG4gICAqXG4gICAqIC8vIE9yIHlvdSBjYW4ganVzdCB1cGRhdGUgaXQgbWFudWFsbHkuXG4gICAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAgICogdGlja2VyLnN0b3AoKTtcbiAgICogY29uc3QgYW5pbWF0ZSA9ICh0aW1lKSA9PiB7XG4gICAqICAgICB0aWNrZXIudXBkYXRlKHRpbWUpO1xuICAgKiAgICAgcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcbiAgICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICogfTtcbiAgICogYW5pbWF0ZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAqIEBtZW1iZXIge3RpY2tlci5UaWNrZXJ9XG4gICAqIEByZWFkb25seVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICBpZiAoIV9UaWNrZXIuX3NoYXJlZCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gX1RpY2tlci5fc2hhcmVkID0gbmV3IF9UaWNrZXIoKTtcbiAgICAgIHNoYXJlZC5hdXRvU3RhcnQgPSB0cnVlO1xuICAgICAgc2hhcmVkLl9wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlci5fc2hhcmVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHRpY2tlciBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBCYXNlUHJlcGFyZX0gZm9yIGNvcmUgdGltaW5nXG4gICAqIGZ1bmN0aW9uYWxpdHkgdGhhdCBzaG91bGRuJ3QgdXN1YWxseSBuZWVkIHRvIGJlIHBhdXNlZCwgdW5saWtlIHRoZSBgc2hhcmVkYFxuICAgKiB0aWNrZXIgd2hpY2ggZHJpdmVzIHZpc3VhbCBhbmltYXRpb25zIGFuZCByZW5kZXJpbmcgd2hpY2ggbWF5IHdhbnQgdG8gYmUgcGF1c2VkLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkge0BsaW5rIHRpY2tlci5UaWNrZXIjYXV0b1N0YXJ0fGF1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQG1lbWJlciB7dGlja2VyLlRpY2tlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgIGlmICghX1RpY2tlci5fc3lzdGVtKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSBfVGlja2VyLl9zeXN0ZW0gPSBuZXcgX1RpY2tlcigpO1xuICAgICAgc3lzdGVtLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICBzeXN0ZW0uX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfVGlja2VyLl9zeXN0ZW07XG4gIH1cbn07XG4vKipcbiAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxuICogQHN0YXRpY1xuICovXG5fVGlja2VyLnRhcmdldEZQTVMgPSAwLjA2O1xubGV0IFRpY2tlciA9IF9UaWNrZXI7XG5cbmV4cG9ydCB7IFRpY2tlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9366\n")},901:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ UPDATE_PRIORITY)\n/* harmony export */ });\n\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qjs7QUFFRztBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3RpY2tlci9jb25zdC5tanM/MTA3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBVUERBVEVfUFJJT1JJVFkgPSAvKiBAX19QVVJFX18gKi8gKChVUERBVEVfUFJJT1JJVFkyKSA9PiB7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIklOVEVSQUNUSU9OXCJdID0gNTBdID0gXCJJTlRFUkFDVElPTlwiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJISUdIXCJdID0gMjVdID0gXCJISUdIXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIk5PUk1BTFwiXSA9IDBdID0gXCJOT1JNQUxcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiTE9XXCJdID0gLTI1XSA9IFwiTE9XXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIlVUSUxJVFlcIl0gPSAtNTBdID0gXCJVVElMSVRZXCI7XG4gIHJldHVybiBVUERBVEVfUFJJT1JJVFkyO1xufSkoVVBEQVRFX1BSSU9SSVRZIHx8IHt9KTtcblxuZXhwb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///901\n')},5447:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ detectVideoAlphaMode)\n/* harmony export */ });\n\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement("canvas");\n    const gl = canvas.getContext("webgl");\n    if (!gl) {\n      return "premultiply-alpha-on-upload";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement("video");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = "anonymous";\n      video2.preload = "auto";\n      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";\n      video2.load();\n    });\n    if (!video) {\n      return "premultiply-alpha-on-upload";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension("WEBGL_lose_context")?.loseContext();\n    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";\n  })());\n  return promise;\n}\n\n\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9kZXRlY3RWaWRlb0FscGhhTW9kZS5tanM/YmM4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmxldCBwcm9taXNlO1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0VmlkZW9BbHBoYU1vZGUoKSB7XG4gIHByb21pc2UgPz8gKHByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHJldHVybiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICAgIH1cbiAgICBjb25zdCB2aWRlbyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICB2aWRlbzIub25sb2FkZWRkYXRhID0gKCkgPT4gcmVzb2x2ZSh2aWRlbzIpO1xuICAgICAgdmlkZW8yLm9uZXJyb3IgPSAoKSA9PiByZXNvbHZlKG51bGwpO1xuICAgICAgdmlkZW8yLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgICB2aWRlbzIuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgdmlkZW8yLnByZWxvYWQgPSBcImF1dG9cIjtcbiAgICAgIHZpZGVvMi5zcmMgPSBcImRhdGE6dmlkZW8vd2VibTtiYXNlNjQsR2tYZm81OUNob0VCUXZlQkFVTHlnUVJDODRFSVFvS0VkMlZpYlVLSGdRSkNoWUVDR0ZPQVp3RUFBQUFBQUFIVEVVMmJkTHBOdTR0VHE0UVZTYWxtVTZ5Qm9VMjdpMU9yaEJaVXJtdFRySUhHVGJ1TVU2dUVFbFREWjFPc2dnRVhUYnVNVTZ1RUhGTzdhMU9zZ2dHOTdBRUFBQUFBQUFCWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVlNhbG1vQ3JYc1lNUFFrQk5nSVJNWVhabVYwR0VUR0YyWmtTSmlFQkVBQUFBQUFBQUZsU3VhOHl1QVFBQUFBQUFBRVBYZ1FGenhZZ0FBQUFBQUFBQUFaeUJBQ0sxbklOMWJtU0lnUUNHaFZaZlZsQTVnNEVCSStPRGhBSmlXZ0RnbExDQkFycUJBcHFCQWxQQWdRRlZzSVJWdVlFQkVsVERaOVZ6YzlKandJdGp4WWdBQUFBQUFBQUFBV2ZJbkVXamgwVk9RMDlFUlZKRWg0OU1ZWFpqSUd4cFluWndlQzEyY0RsbnlLSkZvNGhFVlZKQlZFbFBUa1NIbERBd09qQXdPakF3TGpBME1EQXdNREF3TUFBQUgwTzJkY2ZuZ1FDZ3dxR2dnUUFBQUlKSmcwSUFBQkFBRmdBNEpCd1lTZ0FBSUNBQUViLy8vNHIrQUFCMW9aMm1tKzZCQWFXV2drbURRZ0FBRUFBV0FEZ2tIQmhLQUFBZ0lBQklRQnhUdTJ1UnU0K3pnUUMzaXZlQkFmR0NBWEh3Z1FNPVwiO1xuICAgICAgdmlkZW8yLmxvYWQoKTtcbiAgICB9KTtcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIHRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBnbC5OT05FKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHZpZGVvKTtcbiAgICBjb25zdCBwaXhlbCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWwpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKTtcbiAgICByZXR1cm4gcGl4ZWxbMF0gPD0gcGl4ZWxbM10gPyBcInByZW11bHRpcGxpZWQtYWxwaGFcIiA6IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCI7XG4gIH0pKCkpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZXhwb3J0IHsgZGV0ZWN0VmlkZW9BbHBoYU1vZGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFZpZGVvQWxwaGFNb2RlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5447\n')},1013:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ unsafeEvalSupported)\n/* harmony export */ });\n\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === "boolean") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");\n    unsafeEval = func({ a: "b" }, "a", "b") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Rix3QkFBd0IsUUFBUTtBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcz8zODQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubGV0IHVuc2FmZUV2YWw7XG5mdW5jdGlvbiB1bnNhZmVFdmFsU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHVuc2FmZUV2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHVuc2FmZUV2YWw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicGFyYW0xXCIsIFwicGFyYW0yXCIsIFwicGFyYW0zXCIsIFwicmV0dXJuIHBhcmFtMVtwYXJhbTJdID09PSBwYXJhbTM7XCIpO1xuICAgIHVuc2FmZUV2YWwgPSBmdW5jKHsgYTogXCJiXCIgfSwgXCJhXCIsIFwiYlwiKSA9PT0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVuc2FmZUV2YWwgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdW5zYWZlRXZhbDtcbn1cblxuZXhwb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5zYWZlRXZhbFN1cHBvcnRlZC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1013\n')},7040:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ removeItems)\n/* harmony export */ });\n\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n\n//# sourceMappingURL=removeItems.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0MC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9kYXRhL3JlbW92ZUl0ZW1zLm1qcz9hMjFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgbGV0IGk7XG4gIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVtb3ZlQ291bnQgPSBzdGFydElkeCArIHJlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoIC0gc3RhcnRJZHggOiByZW1vdmVDb3VudDtcbiAgY29uc3QgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG4gIGZvciAoaSA9IHN0YXJ0SWR4OyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgfVxuICBhcnIubGVuZ3RoID0gbGVuO1xufVxuXG5leHBvcnQgeyByZW1vdmVJdGVtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlSXRlbXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7040\n")},6258:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ uid)\n/* harmony export */ });\n/* unused harmony export resetUids */\n\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = "default") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\n\n//# sourceMappingURL=uid.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1OC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2RhdGEvdWlkLm1qcz8wODkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdWlkQ2FjaGUgPSB7XG4gIGRlZmF1bHQ6IC0xXG59O1xuZnVuY3Rpb24gdWlkKG5hbWUgPSBcImRlZmF1bHRcIikge1xuICBpZiAodWlkQ2FjaGVbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgIHVpZENhY2hlW25hbWVdID0gLTE7XG4gIH1cbiAgcmV0dXJuICsrdWlkQ2FjaGVbbmFtZV07XG59XG5mdW5jdGlvbiByZXNldFVpZHMoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHVpZENhY2hlKSB7XG4gICAgZGVsZXRlIHVpZENhY2hlW2tleV07XG4gIH1cbn1cblxuZXhwb3J0IHsgcmVzZXRVaWRzLCB1aWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpZC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6258\n')},3747:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ updateQuadBounds)\n/* harmony export */ });\n\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\n\n//# sourceMappingURL=updateQuadBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzP2RiM2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB1cGRhdGVRdWFkQm91bmRzKGJvdW5kcywgYW5jaG9yLCB0ZXh0dXJlLCBwYWRkaW5nKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZS5vcmlnO1xuICBjb25zdCB0cmltID0gdGV4dHVyZS50cmltO1xuICBpZiAodHJpbSkge1xuICAgIGNvbnN0IHNvdXJjZVdpZHRoID0gdHJpbS53aWR0aDtcbiAgICBjb25zdCBzb3VyY2VIZWlnaHQgPSB0cmltLmhlaWdodDtcbiAgICBib3VuZHMubWluWCA9IHRyaW0ueCAtIGFuY2hvci5feCAqIHdpZHRoIC0gcGFkZGluZztcbiAgICBib3VuZHMubWF4WCA9IGJvdW5kcy5taW5YICsgc291cmNlV2lkdGg7XG4gICAgYm91bmRzLm1pblkgPSB0cmltLnkgLSBhbmNob3IuX3kgKiBoZWlnaHQgLSBwYWRkaW5nO1xuICAgIGJvdW5kcy5tYXhZID0gYm91bmRzLm1pblkgKyBzb3VyY2VIZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzLm1pblggPSAtYW5jaG9yLl94ICogd2lkdGggLSBwYWRkaW5nO1xuICAgIGJvdW5kcy5tYXhYID0gYm91bmRzLm1pblggKyB3aWR0aDtcbiAgICBib3VuZHMubWluWSA9IC1hbmNob3IuX3kgKiBoZWlnaHQgLSBwYWRkaW5nO1xuICAgIGJvdW5kcy5tYXhZID0gYm91bmRzLm1pblkgKyBoZWlnaHQ7XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5leHBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVRdWFkQm91bmRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3747\n")},156:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ v8_0_0),\n/* harmony export */   a: () => (/* binding */ deprecation)\n/* harmony export */ });\n\nconst warnings = {};\nconst v8_0_0 = "8.0.0";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === "undefined") {\n    console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split("\\n").splice(ignoreDepth).join("\\n");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        "%cPixiJS Deprecation Warning: %c%s",\n        "color:#614108;background:#fffbe6",\n        "font-weight:normal;color:#614108;background:#fffbe6",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\n\n//# sourceMappingURL=deprecation.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0JBQW9CLFFBQVE7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDRCQUE0QixjQUFjO0FBQzFDLFdBQVc7QUFDWCxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0RBQXNEO0FBQ3RELG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanM/MWJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHdhcm5pbmdzID0ge307XG5jb25zdCB2OF8wXzAgPSBcIjguMC4wXCI7XG5mdW5jdGlvbiBkZXByZWNhdGlvbih2ZXJzaW9uLCBtZXNzYWdlLCBpZ25vcmVEZXB0aCA9IDMpIHtcbiAgaWYgKHdhcm5pbmdzW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICBpZiAodHlwZW9mIHN0YWNrID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6IFwiLCBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWApO1xuICB9IGVsc2Uge1xuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoXCJcXG5cIikuc3BsaWNlKGlnbm9yZURlcHRoKS5qb2luKFwiXFxuXCIpO1xuICAgIGlmIChjb25zb2xlLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgICBcIiVjUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6ICVjJXNcIixcbiAgICAgICAgXCJjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0Om5vcm1hbDtjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLFxuICAgICAgICBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLndhcm4oc3RhY2spO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogXCIsIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YCk7XG4gICAgICBjb25zb2xlLndhcm4oc3RhY2spO1xuICAgIH1cbiAgfVxuICB3YXJuaW5nc1ttZXNzYWdlXSA9IHRydWU7XG59XG5cbmV4cG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0aW9uLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///156\n')},4796:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (/* binding */ warn)\n/* harmony export */ });\n\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");\n  } else {\n    console.warn("PixiJS Warning: ", ...args);\n  }\n}\n\n\n//# sourceMappingURL=warn.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanM/Njg0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmxldCB3YXJuQ291bnQgPSAwO1xuY29uc3QgbWF4V2FybmluZ3MgPSA1MDA7XG5mdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgaWYgKHdhcm5Db3VudCA9PT0gbWF4V2FybmluZ3MpXG4gICAgcmV0dXJuO1xuICB3YXJuQ291bnQrKztcbiAgaWYgKHdhcm5Db3VudCA9PT0gbWF4V2FybmluZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgV2FybmluZzogdG9vIG1hbnkgd2FybmluZ3MsIG5vIG1vcmUgd2FybmluZ3Mgd2lsbCBiZSByZXBvcnRlZCB0byB0aGUgY29uc29sZSBieSBQaXhpSlMuXCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIlBpeGlKUyBXYXJuaW5nOiBcIiwgLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgd2FybiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fybi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4796\n')},1718:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ path)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n\n\n"use strict";\nfunction assertPath(path2) {\n  if (typeof path2 !== "string") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split("?")[0];\n  return re.split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf("/");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = "";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = "";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += "/..";\n          } else {\n            res = "..";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith("blob:");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return "";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it\'s not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith("/")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving \'..\' and \'.\' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith("/");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += "/";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith("/");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return ".";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return ".";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return "//";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/"))\n      root = "/";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith("/"))\n        root += "/";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return "";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return "";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the \'root\', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: "/",\n  delimiter: ":",\n  joinExtensions: [".html"]\n};\n\n\n//# sourceMappingURL=path.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9wYXRoLm1qcz8yMGE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoMikge1xuICBpZiAodHlwZW9mIHBhdGgyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHBhdGgyKX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVXJsUGFyYW1zKHVybCkge1xuICBjb25zdCByZSA9IHVybC5zcGxpdChcIj9cIilbMF07XG4gIHJldHVybiByZS5zcGxpdChcIiNcIilbMF07XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChzdHIsIGZpbmQsIHJlcGxhY2UpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGZpbmQpLCBcImdcIiksIHJlcGxhY2UpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aDIsIGFsbG93QWJvdmVSb290KSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBsZXQgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICBsZXQgbGFzdFNsYXNoID0gLTE7XG4gIGxldCBkb3RzID0gMDtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aDIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgyLmxlbmd0aCkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSA0NztcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlcyArPSBcIi8uLlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBcIi4uXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzICs9IGAvJHtwYXRoMi5zbGljZShsYXN0U2xhc2ggKyAxLCBpKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHBhdGgyLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICB9XG4gICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgZG90cyA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NiAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBwYXRoID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSBwYXRoIHRvIHBvc2l4IGZvcm1hdC5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjb252ZXJ0IHRvIHBvc2l4XG4gICAqL1xuICB0b1Bvc2l4KHBhdGgyKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VBbGwocGF0aDIsIFwiXFxcXFwiLCBcIi9cIik7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaXMgYSBVUkwgZS5nLiBodHRwOi8vLCBodHRwczovL1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBpc1VybChwYXRoMikge1xuICAgIHJldHVybiAvXmh0dHBzPzovLnRlc3QodGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaXMgYSBkYXRhIFVSTFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBpc0RhdGFVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gL15kYXRhOihbYS16XStcXC9bYS16MC05LSsuXSsoO1thLXowLTktLiEjJCUqKy57fXx+YF0rPVthLXowLTktLiEjJCUqKy57fSgpX3x+YF0rKSopPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHM8Pl0qPykkL2kudGVzdChwYXRoMik7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaXMgYSBibG9iIFVSTFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBpc0Jsb2JVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gcGF0aDIuc3RhcnRzV2l0aChcImJsb2I6XCIpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGhhcyBhIHByb3RvY29sIGUuZy4gaHR0cDovLywgaHR0cHM6Ly8sIGZpbGU6Ly8vLCBkYXRhOiwgYmxvYjosIEM6L1xuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIHdpbmRvd3MgZmlsZSBwYXRoc1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBoYXNQcm90b2NvbChwYXRoMikge1xuICAgIHJldHVybiAvXlteLzpdKzovLnRlc3QodGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm90b2NvbCBvZiB0aGUgcGF0aCBlLmcuIGh0dHA6Ly8sIGh0dHBzOi8vLCBmaWxlOi8vLywgZGF0YTosIGJsb2I6LCBDOi9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBnZXQgdGhlIHByb3RvY29sIGZyb21cbiAgICovXG4gIGdldFByb3RvY29sKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGNvbnN0IG1hdGNoRmlsZSA9IC9eZmlsZTpcXC9cXC9cXC8vLmV4ZWMocGF0aDIpO1xuICAgIGlmIChtYXRjaEZpbGUpIHtcbiAgICAgIHJldHVybiBtYXRjaEZpbGVbMF07XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoUHJvdG9jb2wgPSAvXlteLzpdKzpcXC97MCwyfS8uZXhlYyhwYXRoMik7XG4gICAgaWYgKG1hdGNoUHJvdG9jb2wpIHtcbiAgICAgIHJldHVybiBtYXRjaFByb3RvY29sWzBdO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnRzIFVSTCB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBXaGVuIGxvYWRpbmcgZnJvbSBhIFdlYiBXb3JrZXIsIHdlIG11c3QgdXNlIGFic29sdXRlIHBhdGhzLlxuICAgKiBJZiB0aGUgVVJMIGlzIGFscmVhZHkgYWJzb2x1dGUgd2UgcmV0dXJuIGl0IGFzIGlzXG4gICAqIElmIGl0J3Mgbm90LCB3ZSBjb252ZXJ0IGl0XG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHRlc3RcbiAgICogQHBhcmFtIGN1c3RvbUJhc2VVcmwgLSBUaGUgYmFzZSBVUkwgdG8gdXNlXG4gICAqIEBwYXJhbSBjdXN0b21Sb290VXJsIC0gVGhlIHJvb3QgVVJMIHRvIHVzZVxuICAgKi9cbiAgdG9BYnNvbHV0ZSh1cmwsIGN1c3RvbUJhc2VVcmwsIGN1c3RvbVJvb3RVcmwpIHtcbiAgICBhc3NlcnRQYXRoKHVybCk7XG4gICAgaWYgKHRoaXMuaXNEYXRhVXJsKHVybCkgfHwgdGhpcy5pc0Jsb2JVcmwodXJsKSlcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgYmFzZVVybCA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgoY3VzdG9tQmFzZVVybCA/PyBET01BZGFwdGVyLmdldCgpLmdldEJhc2VVcmwoKSkpO1xuICAgIGNvbnN0IHJvb3RVcmwgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KGN1c3RvbVJvb3RVcmwgPz8gdGhpcy5yb290bmFtZShiYXNlVXJsKSkpO1xuICAgIHVybCA9IHRoaXMudG9Qb3NpeCh1cmwpO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4ocm9vdFVybCwgdXJsLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVQYXRoID0gdGhpcy5pc0Fic29sdXRlKHVybCkgPyB1cmwgOiB0aGlzLmpvaW4oYmFzZVVybCwgdXJsKTtcbiAgICByZXR1cm4gYWJzb2x1dGVQYXRoO1xuICB9LFxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gcGF0aCwgcmVzb2x2aW5nICcuLicgYW5kICcuJyBzZWdtZW50c1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIG5vcm1hbGl6ZVxuICAgKi9cbiAgbm9ybWFsaXplKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBpZiAodGhpcy5pc0RhdGFVcmwocGF0aDIpIHx8IHRoaXMuaXNCbG9iVXJsKHBhdGgyKSlcbiAgICAgIHJldHVybiBwYXRoMjtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHByb3RvY29sID0gXCJcIjtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gICAgaWYgKHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKSB7XG4gICAgICBwcm90b2NvbCA9IHRoaXMucm9vdG5hbWUocGF0aDIpO1xuICAgICAgcGF0aDIgPSBwYXRoMi5zbGljZShwcm90b2NvbC5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGgyLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBwYXRoMiA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgyLCBmYWxzZSk7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpXG4gICAgICBwYXRoMiArPSBcIi9cIjtcbiAgICBpZiAoaXNBYnNvbHV0ZSlcbiAgICAgIHJldHVybiBgLyR7cGF0aDJ9YDtcbiAgICByZXR1cm4gcHJvdG9jb2wgKyBwYXRoMjtcbiAgfSxcbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgcGF0aCBpcyBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBBYnNvbHV0ZSBwYXRocyBjYW4gYmUgdXJscywgZGF0YSB1cmxzLCBvciBwYXRocyBvbiBkaXNrXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGVzdFxuICAgKi9cbiAgaXNBYnNvbHV0ZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBpZiAodGhpcy5oYXNQcm90b2NvbChwYXRoMikpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gIH0sXG4gIC8qKlxuICAgKiBKb2lucyBhbGwgZ2l2ZW4gcGF0aCBzZWdtZW50cyB0b2dldGhlciB1c2luZyB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgc2VwYXJhdG9yIGFzIGEgZGVsaW1pdGVyLFxuICAgKiB0aGVuIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoXG4gICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byBqb2luXG4gICAqL1xuICBqb2luKC4uLnNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgICBsZXQgam9pbmVkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGFyZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHZvaWQgMClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByZXZBcmcgPSBzZWdtZW50c1tpIC0gMV0gPz8gXCJcIjtcbiAgICAgICAgICBpZiAodGhpcy5qb2luRXh0ZW5zaW9ucy5pbmNsdWRlcyh0aGlzLmV4dG5hbWUocHJldkFyZykudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGpvaW5lZCArPSBgLy4uLyR7YXJnfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpvaW5lZCArPSBgLyR7YXJnfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHBhcnNlXG4gICAqL1xuICBkaXJuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGhhc1Jvb3QgPSBjb2RlID09PSA0NztcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgY29uc3QgcHJvdG8gPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKTtcbiAgICBjb25zdCBvcmlncGF0aCA9IHBhdGgyO1xuICAgIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG8ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgcmV0dXJuIGhhc1Jvb3QgPyBcIi9cIiA6IHRoaXMuaXNVcmwob3JpZ3BhdGgpID8gcHJvdG8gKyBwYXRoMiA6IHByb3RvO1xuICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSlcbiAgICAgIHJldHVybiBcIi8vXCI7XG4gICAgcmV0dXJuIHByb3RvICsgcGF0aDIuc2xpY2UoMCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgb2YgdGhlIHBhdGggZS5nLiAvLCBDOi8sIGZpbGU6Ly8vLCBodHRwOi8vZG9tYWluLmNvbS9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgcm9vdG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHJvb3QgPSBcIlwiO1xuICAgIGlmIChwYXRoMi5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgIHJvb3QgPSBcIi9cIjtcbiAgICBlbHNlIHtcbiAgICAgIHJvb3QgPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcmwocGF0aDIpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhdGgyLmluZGV4T2YoXCIvXCIsIHJvb3QubGVuZ3RoKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcm9vdCA9IHBhdGgyLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByb290ID0gcGF0aDI7XG4gICAgICBpZiAoIXJvb3QuZW5kc1dpdGgoXCIvXCIpKVxuICAgICAgICByb290ICs9IFwiL1wiO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgcG9ydGlvbiBvZiBhIHBhdGhcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0ZXN0XG4gICAqIEBwYXJhbSBleHQgLSBPcHRpb25hbCBleHRlbnNpb24gdG8gcmVtb3ZlXG4gICAqL1xuICBiYXNlbmFtZShwYXRoMiwgZXh0KSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKGV4dClcbiAgICAgIGFzc2VydFBhdGgoZXh0KTtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgaTtcbiAgICBpZiAoZXh0ICE9PSB2b2lkIDAgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoMi5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoMi5sZW5ndGggJiYgZXh0ID09PSBwYXRoMilcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpXG4gICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICBlbHNlIGlmIChlbmQgPT09IC0xKVxuICAgICAgICBlbmQgPSBwYXRoMi5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAocGF0aDIuY2hhckNvZGVBdChpKSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBwYXRoMi5zbGljZShzdGFydCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGF0aCwgZnJvbSB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHRoZSAuIChwZXJpb2QpIGNoYXJhY3RlciB0byBlbmQgb2Ygc3RyaW5nIGluIHRoZSBsYXN0XG4gICAqIHBvcnRpb24gb2YgdGhlIHBhdGguIElmIHRoZXJlIGlzIG5vIC4gaW4gdGhlIGxhc3QgcG9ydGlvbiBvZiB0aGUgcGF0aCwgb3IgaWYgdGhlcmUgYXJlIG5vIC4gY2hhcmFjdGVycyBvdGhlciB0aGFuXG4gICAqIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGJhc2VuYW1lIG9mIHBhdGgsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgZXh0bmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgIGxldCBzdGFydFBhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8IHByZURvdFN0YXRlID09PSAwIHx8IHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuICAvKipcbiAgICogUGFyc2VzIGEgcGF0aCBpbnRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSAncm9vdCcsIGBkaXJgLCBgYmFzZWAsIGBleHRgLCBhbmQgYG5hbWVgIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcGFyc2VcbiAgICovXG4gIHBhcnNlKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgY29uc3QgcmV0ID0geyByb290OiBcIlwiLCBkaXI6IFwiXCIsIGJhc2U6IFwiXCIsIGV4dDogXCJcIiwgbmFtZTogXCJcIiB9O1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gcmV0O1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gdGhpcy5pc0Fic29sdXRlKHBhdGgyKTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBcIlwiO1xuICAgIHJldC5yb290ID0gdGhpcy5yb290bmFtZShwYXRoMik7XG4gICAgaWYgKGlzQWJzb2x1dGUgfHwgdGhpcy5oYXNQcm90b2NvbChwYXRoMikpIHtcbiAgICAgIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxO1xuICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8IHByZURvdFN0YXRlID09PSAwIHx8IHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpXG4gICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKDEsIGVuZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aDIuc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGgyLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cbiAgICByZXQuZGlyID0gdGhpcy5kaXJuYW1lKHBhdGgyKTtcbiAgICBpZiAocHJvdG9jb2wpXG4gICAgICByZXQuZGlyID0gcHJvdG9jb2wgKyByZXQuZGlyO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHNlcDogXCIvXCIsXG4gIGRlbGltaXRlcjogXCI6XCIsXG4gIGpvaW5FeHRlbnNpb25zOiBbXCIuaHRtbFwiXVxufTtcblxuZXhwb3J0IHsgcGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1718\n')},5374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   K: () => (/* binding */ Pool)\n/* harmony export */ });\n\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n}\n\n\n//# sourceMappingURL=Pool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9wb29sL1Bvb2wubWpzPzEzNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBQb29sIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgUG9vbC5cbiAgICogQHBhcmFtIENsYXNzVHlwZSAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgaXRlbXMgaW4gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5pdGlhbFNpemVdIC0gVGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgcG9vbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKENsYXNzVHlwZSwgaW5pdGlhbFNpemUpIHtcbiAgICB0aGlzLl9wb29sID0gW107XG4gICAgdGhpcy5fY291bnQgPSAwO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICB0aGlzLl9jbGFzc1R5cGUgPSBDbGFzc1R5cGU7XG4gICAgaWYgKGluaXRpYWxTaXplKSB7XG4gICAgICB0aGlzLnByZXBvcHVsYXRlKGluaXRpYWxTaXplKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByZXBvcHVsYXRlcyB0aGUgcG9vbCB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIGl0ZW1zLlxuICAgKiBAcGFyYW0gdG90YWwgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICovXG4gIHByZXBvcHVsYXRlKHRvdGFsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICB0aGlzLl9wb29sW3RoaXMuX2luZGV4KytdID0gbmV3IHRoaXMuX2NsYXNzVHlwZSgpO1xuICAgIH1cbiAgICB0aGlzLl9jb3VudCArPSB0b3RhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIHBvb2wuIENhbGxzIHRoZSBpdGVtJ3MgYGluaXRgIG1ldGhvZCBpZiBpdCBleGlzdHMuXG4gICAqIElmIHRoZXJlIGFyZSBubyBpdGVtcyBsZWZ0IGluIHRoZSBwb29sLCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtkYXRhXSAtIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgaXRlbSdzIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7VH0gVGhlIGl0ZW0gZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGdldChkYXRhKSB7XG4gICAgbGV0IGl0ZW07XG4gICAgaWYgKHRoaXMuX2luZGV4ID4gMCkge1xuICAgICAgaXRlbSA9IHRoaXMuX3Bvb2xbLS10aGlzLl9pbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0gPSBuZXcgdGhpcy5fY2xhc3NUeXBlKCk7XG4gICAgfVxuICAgIGl0ZW0uaW5pdD8uKGRhdGEpO1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGl0ZW0gdG8gdGhlIHBvb2wuIENhbGxzIHRoZSBpdGVtJ3MgYHJlc2V0YCBtZXRob2QgaWYgaXQgZXhpc3RzLlxuICAgKiBAcGFyYW0ge1R9IGl0ZW0gLSBUaGUgaXRlbSB0byByZXR1cm4gdG8gdGhlIHBvb2wuXG4gICAqL1xuICByZXR1cm4oaXRlbSkge1xuICAgIGl0ZW0ucmVzZXQ/LigpO1xuICAgIHRoaXMuX3Bvb2xbdGhpcy5faW5kZXgrK10gPSBpdGVtO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBvb2wuXG4gICAqIEByZWFkb25seVxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdG90YWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwb29sIHRoYXQgYXJlIGZyZWUgdG8gdXNlIHdpdGhvdXQgbmVlZGluZyB0byBjcmVhdGUgbW9yZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCB0b3RhbEZyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBvb2wgdGhhdCBhcmUgY3VycmVudGx5IGluIHVzZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCB0b3RhbFVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50IC0gdGhpcy5faW5kZXg7XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9vbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9vbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5374\n")},5906:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ BigPool)\n/* harmony export */ });\n/* unused harmony export PoolGroupClass */\n/* harmony import */ var _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5374);\n\n\n"use strict";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item\'s constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\n\n//# sourceMappingURL=PoolGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkwNi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLFNBQVM7QUFDdEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcz9lNmNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvb2wgfSBmcm9tICcuL1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBQb29sR3JvdXBDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEEgbWFwIHRvIHN0b3JlIHRoZSBwb29scyBieSB0aGVpciBjbGFzcyB0eXBlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcG9vbHNCeUNsYXNzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKipcbiAgICogUHJlcG9wdWxhdGVzIGEgc3BlY2lmaWMgcG9vbCB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIGl0ZW1zLlxuICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBpdGVtcyBpbiB0aGUgcG9vbC4gTXVzdCBleHRlbmQgUG9vbEl0ZW0uXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1Db25zdHJ1Y3RvcjxUPn0gQ2xhc3MgLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGl0ZW1zIGluIHRoZSBwb29sLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWwgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICovXG4gIHByZXBvcHVsYXRlKENsYXNzLCB0b3RhbCkge1xuICAgIGNvbnN0IGNsYXNzUG9vbCA9IHRoaXMuZ2V0UG9vbChDbGFzcyk7XG4gICAgY2xhc3NQb29sLnByZXBvcHVsYXRlKHRvdGFsKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIGZyb20gYSBzcGVjaWZpYyBwb29sLlxuICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBpdGVtcyBpbiB0aGUgcG9vbC4gTXVzdCBleHRlbmQgUG9vbEl0ZW0uXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1Db25zdHJ1Y3RvcjxUPn0gQ2xhc3MgLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGl0ZW1zIGluIHRoZSBwb29sLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtkYXRhXSAtIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgaXRlbSdzIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7VH0gVGhlIGl0ZW0gZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGdldChDbGFzcywgZGF0YSkge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmdldFBvb2woQ2xhc3MpO1xuICAgIHJldHVybiBwb29sLmdldChkYXRhKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBpdGVtIHRvIGl0cyByZXNwZWN0aXZlIHBvb2wuXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byByZXR1cm4gdG8gdGhlIHBvb2wuXG4gICAqL1xuICByZXR1cm4oaXRlbSkge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmdldFBvb2woaXRlbS5jb25zdHJ1Y3Rvcik7XG4gICAgcG9vbC5yZXR1cm4oaXRlbSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzcGVjaWZpYyBwb29sIGJhc2VkIG9uIHRoZSBjbGFzcyB0eXBlLlxuICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBpdGVtcyBpbiB0aGUgcG9vbC4gTXVzdCBleHRlbmQgUG9vbEl0ZW0uXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1Db25zdHJ1Y3RvcjxUPn0gQ2xhc3NUeXBlIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpdGVtcyBpbiB0aGUgcG9vbC5cbiAgICogQHJldHVybnMge1Bvb2w8VD59IFRoZSBwb29sIG9mIHRoZSBnaXZlbiBjbGFzcyB0eXBlLlxuICAgKi9cbiAgZ2V0UG9vbChDbGFzc1R5cGUpIHtcbiAgICBpZiAoIXRoaXMuX3Bvb2xzQnlDbGFzcy5oYXMoQ2xhc3NUeXBlKSkge1xuICAgICAgdGhpcy5fcG9vbHNCeUNsYXNzLnNldChDbGFzc1R5cGUsIG5ldyBQb29sKENsYXNzVHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9vbHNCeUNsYXNzLmdldChDbGFzc1R5cGUpO1xuICB9XG4gIC8qKiBnZXRzIHRoZSB1c2FnZSBzdGF0cyBvZiBlYWNoIHBvb2wgaW4gdGhlIHN5c3RlbSAqL1xuICBzdGF0cygpIHtcbiAgICBjb25zdCBzdGF0cyA9IHt9O1xuICAgIHRoaXMuX3Bvb2xzQnlDbGFzcy5mb3JFYWNoKChwb29sKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gc3RhdHNbcG9vbC5fY2xhc3NUeXBlLm5hbWVdID8gcG9vbC5fY2xhc3NUeXBlLm5hbWUgKyBwb29sLl9jbGFzc1R5cGUuSUQgOiBwb29sLl9jbGFzc1R5cGUubmFtZTtcbiAgICAgIHN0YXRzW25hbWVdID0ge1xuICAgICAgICBmcmVlOiBwb29sLnRvdGFsRnJlZSxcbiAgICAgICAgdXNlZDogcG9vbC50b3RhbFVzZWQsXG4gICAgICAgIHNpemU6IHBvb2wudG90YWxTaXplXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0cztcbiAgfVxufVxuY29uc3QgQmlnUG9vbCA9IG5ldyBQb29sR3JvdXBDbGFzcygpO1xuXG5leHBvcnQgeyBCaWdQb29sLCBQb29sR3JvdXBDbGFzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9vbEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5906\n')},2768:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  jP: () => (/* reexport */ BezierUtil),\n  hp: () => (/* reexport */ Particle),\n  F8: () => (/* reexport */ ParticleGenerator),\n  mG: () => (/* reexport */ ParticleWay)\n});\n\n// UNUSED EXPORTS: GenerationModeManager, MultipleParticleWays, MultipleParticleWaysOption, ParticleContainer, ParticleGeneratorOption\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/Particle.js\n/**\n * パーティクルを表すクラス。\n * このクラス自体には描画のための機能はない。\n * 各種の描画ライブラリと組み合わせて利用する。\n */\nclass Particle {\n    /**\n     * 指定されたパスに沿って移動するパーティクルを生成する。\n     * @param path\n     */\n    constructor(path) {\n        this._ratio = 0.0;\n        this._visible = true;\n        this.path = path;\n    }\n    /**\n     * パーティクルの位置を更新する。\n     * @param t パーティクルのパス上の位置。入力に制限はないが、ParticleWay側で0.0~1.0の間に丸め込まれる。\n     * @return n ease関数で補正済みのt。\n     */\n    update(t) {\n        this._ratio = t;\n        if (this.ease == null) {\n            return this._ratio;\n        }\n        return this.ease(this._ratio);\n    }\n    /**\n     * パーティクル位置を指定された量移動する。\n     * @param t 移動量 0.0 ~ 1.0\n     */\n    add(t) {\n        return this.update(this._ratio + t);\n    }\n    /**\n     * 現在位置を取得する\n     * @return number\n     */\n    get ratio() {\n        return this._ratio;\n    }\n    get visible() {\n        return this._visible;\n    }\n    set visible(value) {\n        this._visible = value;\n    }\n    dispose() { }\n}\nParticle.MAX_RATIO = 1.0;\nParticle.MIN_RATIO = 0.0;\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/ParticleWay.js\n/**\n * 中間点の座標の算出が可能な経路を表すクラス\n */\n\nclass ParticleWay {\n    /**\n     * コンストラクタ\n     * @param points 経路を表す座標の配列。要素数によってどのようなパスかが判定される。\n     *   要素数2 : 2次元パス\n     *   要素数3 : 3次元パス\n     *   要素数6 : 平面3次元ベジェ曲線\n     */\n    constructor(points) {\n        this.name = "";\n        this.points = points;\n    }\n    /**\n     * 経路の座標配列を更新する。\n     * @param points\n     */\n    set points(points) {\n        this._points = points;\n        this.onSetPoints();\n    }\n    warnPoints() {\n        if (this._points.length === 0) {\n            console.warn("ParticleWay : 長さゼロの配列が指定されました。座標が算出できないため、getPoint関数は常にnullを返します。");\n        }\n        if (this._points.length === 1) {\n            console.warn("ParticleWay : 長さ1の配列が指定されました。座標が算出できないため、getPoint関数は常に固定の座標を返します。");\n        }\n    }\n    /**\n     * pointsが更新された際の処理。\n     * set pointsをトリガーにして実行される。\n     */\n    onSetPoints() {\n        this.warnPoints();\n        const sumTable = new Array(this._points.length).fill(0);\n        this._points.forEach((val, index, array) => {\n            if (index === 0)\n                return;\n            sumTable[index] =\n                ParticleWay.getDistance(array[index - 1], val) + sumTable[index - 1];\n        });\n        const total = sumTable[sumTable.length - 1];\n        this._ratioTable = sumTable.map((val) => {\n            return val / total;\n        });\n    }\n    get points() {\n        return this._points;\n    }\n    /**\n     * 2点間の距離を取得する。\n     * @param pos1\n     * @param pos2\n     */\n    static getDistance(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        switch (pos2.length) {\n            case 6:\n                return BezierUtil.getLengthFromCommand(pos1, pos2);\n            case 3:\n                const dz = pos2[2] - pos1[2];\n                return Math.sqrt(dx * dx + dy * dy + dz * dz);\n            case 2:\n                return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n    /**\n     * 経路上の中間点座標を取得する。\n     * @param t 算出する座標の位置。0.0(始点) ~ 1.0(終点)の間。\n     */\n    getPoint(t) {\n        t = ParticleWayUtil.clampRatio(t);\n        const limited = this.getLimitPoint(t);\n        if (limited !== false)\n            return limited;\n        const i = ParticleWayUtil.getTIndex(t, this._ratioTable);\n        const floorPoint = this._points[i];\n        const ceilPoint = this._points[i + 1];\n        const ratioBase = this._ratioTable[i];\n        return this.getCenterPoint(floorPoint, ceilPoint, (t - ratioBase) / (this._ratioTable[i + 1] - ratioBase));\n    }\n    /**\n     * getPointのうち、制限にかかる値を取得する。\n     * @param t\n     * @private\n     */\n    getLimitPoint(t) {\n        if (!this._points || this._points.length === 0) {\n            return null;\n        }\n        if (t === Particle.MAX_RATIO) {\n            return ParticleWayUtil.getPositionWithMaxT(this._points);\n        }\n        if (this._points.length === 1 || t === Particle.MIN_RATIO) {\n            return [...this._points[0]];\n        }\n        return false;\n    }\n    /**\n     * 線分上の中間点座標を取得する\n     * @param pos1 線分の始点\n     * @param pos2 線分の終点\n     * @param t 算出する座標の位置。0.0(始点) ~ 1.0(終点)の間。\n     */\n    getCenterPoint(pos1, pos2, t) {\n        const rt = 1.0 - t;\n        let pos = [pos1[0] * rt + pos2[0] * t, pos1[1] * rt + pos2[1] * t];\n        switch (pos2.length) {\n            case 6:\n                return BezierUtil.getPointFromCommand(t, pos1, pos2);\n            case 3:\n                pos.push(pos1[2] * rt + pos2[2] * t);\n                return pos;\n            case 2:\n                return pos;\n        }\n    }\n}\nclass ParticleWayUtil {\n    static clamp(val, max, min) {\n        return Math.min(Math.max(val, min), max);\n    }\n    static clampRatio(val) {\n        return this.clamp(val, Particle.MAX_RATIO, Particle.MIN_RATIO);\n    }\n    static getPositionWithMaxT(points) {\n        const n = points.length;\n        let result = points[n - 1];\n        if (result.length === 6) {\n            result = result.slice(-2);\n        }\n        return [...result];\n    }\n    static getTIndex(t, ratioTable) {\n        let i = 1;\n        const n = ratioTable.length;\n        for (i; i < n; i++) {\n            if (ratioTable[i] >= t)\n                break;\n        }\n        i--;\n        return i;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/BezierUtil.js\n\nclass BezierUtil {\n    /**\n     * ベジェ曲線の中間座標を取得する。\n     *\n     * @param t 媒介変数 0.0 ~ 1.0\n     * @param from 始点\n     * @param c1 コントロールポイント1\n     * @param c2 コントロールポイント2\n     * @param to 終点\n     */\n    static getPoint(t, from, c1, c2, to) {\n        const addPoint = (p1, p2, coefficient) => {\n            p1[0] += coefficient * p2[0];\n            p1[1] += coefficient * p2[1];\n        };\n        const result = [0, 0];\n        const difT = 1 - t;\n        let v = Math.pow(difT, 3);\n        addPoint(result, from, v);\n        v = 3 * Math.pow(difT, 2) * t;\n        addPoint(result, c1, v);\n        v = 3 * Math.pow(t, 2) * difT;\n        addPoint(result, c2, v);\n        v = Math.pow(t, 3);\n        addPoint(result, to, v);\n        return result;\n    }\n    /**\n     * ベジェ曲線描画コマンドから、ベジェ曲線の中間座標を取得する。\n     * @param t\n     * @param command1 始点側の描画コマンド 要素数2もしくは6の配列\n     * @param command2 終点側の描画コマンド 要素数6の配列\n     */\n    static getPointFromCommand(t, command1, command2) {\n        return this.getPoint(t, command1.slice(-2), command2.slice(0, 2), command2.slice(2, 4), command2.slice(-2));\n    }\n    /**\n     * ベジェ曲線の長さを取得する。\n     * divの数だけベジェ曲線を分割し、直線の集合として距離を測る。\n     *\n     * @param from 始点\n     * @param c1 コントロールポイント1\n     * @param c2 コントロールポイント2\n     * @param to 終点\n     * @param div 分割数 多いほど精度が向上し、計算負荷は上昇する。 既定値16\n     */\n    static getLength(from, c1, c2, to, div = 16) {\n        let result = 0;\n        let prevPoint;\n        for (let i = 0; i < div + 1; i++) {\n            const p = this.getPoint(i / div, from, c1, c2, to);\n            if (prevPoint) {\n                result += ParticleWay.getDistance(prevPoint, p);\n            }\n            prevPoint = p;\n        }\n        return result;\n    }\n    /**\n     * ベジェ曲線描画コマンドから、ベジェ曲線の長さを取得する。\n     *\n     * @param command1 始点側の描画コマンド 要素数2もしくは6の配列\n     * @param command2 終点側の描画コマンド 要素数6の配列\n     * @param div 分割数 多いほど精度が向上し、計算負荷は上昇する。 既定値16\n     */\n    static getLengthFromCommand(command1, command2, div = 16) {\n        return this.getLength(command1.slice(-2), command2.slice(0, 2), command2.slice(2, 4), command2.slice(-2), div);\n    }\n    /**\n     * 3次ベジェ曲線を2次元座標の配列に分解する。\n     * @param commands\n     * @param div 分割数 デフォルトは16\n     */\n    static subdivide(commands, div = 16) {\n        const points = [];\n        for (let i = 1; i < commands.length; i++) {\n            let sub = this.subdivideSubPath(commands[i - 1], commands[i], div);\n            if (i !== 1) {\n                sub = sub.slice(1);\n            }\n            points.push(...sub);\n        }\n        return points;\n    }\n    static subdivideSubPath(command1, command2, div = 16) {\n        const points = [];\n        for (let i = 0; i < div + 1; i++) {\n            points.push(this.getPointFromCommand(i / div, command1, command2));\n        }\n        return points;\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/raf-ticker/esm/RAFTickerEvent.js\nclass RAFTickerEventContext {\n    constructor(timestamp, delta) {\n        this.timestamp = timestamp;\n        this.delta = delta;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/raf-ticker/esm/RAFTicker.js\nvar _a;\n\n\nclass RAFTicker {\n    static initialize() {\n        if (this._dispatcher == null) {\n            this._dispatcher = new eventemitter3/* EventEmitter */.v();\n        }\n        this.start();\n    }\n    static reset() {\n        this._dispatcher.removeAllListeners();\n        this.stop();\n        this.start();\n    }\n    static start() {\n        if (!_a._id) {\n            this._lastUpdateTimestamp = undefined;\n            _a.onTick(performance.now());\n        }\n    }\n    static stop() {\n        cancelAnimationFrame(_a._id);\n        this._id = undefined;\n        this._lastUpdateTimestamp = undefined;\n    }\n    static addListener(type, listener) {\n        this._dispatcher.on(type, listener);\n    }\n    /**\n     *\n     * @param type\n     * @param listener\n     */\n    static hasListener(type, listener) {\n        const listeners = this._dispatcher.listeners(type);\n        return listeners.includes(listener);\n    }\n    /**\n     * Removes the specified listener\n     *\n     * @param type\n     * @param listener\n     */\n    static removeListener(type, listener) {\n        this._dispatcher.removeListener(type, listener);\n    }\n    /**\n     * イベントを発効する。\n     * この関数はアプリケーションから利用することはなく、主に単体テストのために使用する。\n     *\n     * @param type\n     * @param event\n     */\n    static emit(type, event) {\n        this._dispatcher.emit(type, event);\n    }\n    static emitTickEvent(timestamp) {\n        if (_a._lastUpdateTimestamp == null) {\n            _a._lastUpdateTimestamp = timestamp;\n        }\n        const delta = timestamp - _a._lastUpdateTimestamp;\n        this._dispatcher.emit("onBeforeTick", new RAFTickerEventContext(timestamp, delta));\n        this._dispatcher.emit("tick", new RAFTickerEventContext(timestamp, delta));\n        this._dispatcher.emit("onAfterTick", new RAFTickerEventContext(timestamp, delta));\n        _a._lastUpdateTimestamp = timestamp;\n    }\n}\n_a = RAFTicker;\n/**\n * Alias for addListener\n *\n * @param type\n * @param listener\n */\nRAFTicker.on = _a.addListener;\n/**\n * Alias for removeListener\n *\n * @param type\n * @param listener\n */\nRAFTicker.off = _a.removeListener;\nRAFTicker.onTick = (timestamp) => {\n    _a.emitTickEvent(timestamp);\n    _a._id = requestAnimationFrame(_a.onTick);\n};\nRAFTicker.initialize();\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/raf-ticker/esm/index.js\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/GenerationModeManager.js\n\nclass GenerationModeManager extends eventemitter3/* EventEmitter */.v {\n    get mode() {\n        return this._mode;\n    }\n    set mode(value) {\n        if (value === this._mode)\n            return;\n        this._mode = value;\n        this.emit("change", this._mode);\n    }\n    constructor() {\n        super();\n        this._mode = "sequential";\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/MultipleParticleWays.js\n/**\n * このクラスは、ParticleGeneratorに設定された複数の経路を管理するためのものです。\n */\nclass MultipleParticleWays {\n    constructor(option) {\n        this.waySelectionCount = 0;\n        MultipleParticleWaysOption.initOption(option);\n        this.ways = option.ways;\n        this.waySelectType = option.type;\n    }\n    countUp() {\n        this.waySelectionCount = (this.waySelectionCount + 1) % this.ways.length;\n    }\n    getParticleWay() {\n        let index;\n        switch (this.waySelectType) {\n            case "sequential":\n                index = this.waySelectionCount;\n                break;\n            case "random":\n                index = Math.floor(Math.random() * this.ways.length);\n                break;\n        }\n        return this.ways[index];\n    }\n}\nclass MultipleParticleWaysOption {\n    static initOption(option) {\n        option ??= {};\n        option.ways ??= [];\n        if (!Array.isArray(option.ways)) {\n            option.ways = [option.ways];\n        }\n        option.type ??= "sequential";\n        return option;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleGeneratorUtility.js\n/**\n * ParticleGeneratorで利用する各種の値を算出するヘルパークラス\n */\nclass ParticleGeneratorUtility {\n    /**\n     * パーティクルの生成インターバルと経路上の数から、移動速度を算出する\n     * @param interval\n     * @param particleNum\n     */\n    static getSpeed(interval, particleNum) {\n        return (1.0 / (interval * particleNum)) * 1000;\n    }\n    /**\n     * パーティクルの移動速度と経路上の数から、生成インターバルを算出する\n     * @param speed\n     * @param particleNum\n     */\n    static getInterval(speed, particleNum) {\n        return (1.0 / speed / particleNum) * 1000;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleAnimator.js\n\nclass ParticleAnimator {\n    get generationInterval() {\n        return this._generationInterval;\n    }\n    set generationInterval(value) {\n        if (this._generationInterval === value)\n            return;\n        this._generationInterval = value;\n        if (this._modeManager.mode === "loop") {\n            console.warn("ParticleGenerator : ループ指定中にパーティクル生成間隔を再設定しても反映されません。設定を反映するためにパーティクルを削除して再生成してください。");\n            console.trace();\n        }\n    }\n    get ease() {\n        return this._ease;\n    }\n    constructor(modeManager, particleContainer) {\n        this._generationInterval = 300;\n        this.speedPerSec = 0.07;\n        this._particleContainer = particleContainer;\n        this._modeManager = modeManager;\n    }\n    /**\n     * 生成インターバルと経路上のパーティクル数から移動スピードを算出し設定する。\n     * loop時に破綻しない値が得られる。\n     * @param interval\n     * @param particleNum\n     */\n    setSpeed(interval, particleNum) {\n        this._generationInterval = interval;\n        this.speedPerSec = ParticleGeneratorUtility.getSpeed(interval, particleNum);\n    }\n    /**\n     * 移動スピードと経路上のパーティクル数から生成インターバルを算出し設定する。\n     * loop時に破綻しない値が得られる。\n     * @param speed\n     * @param particleNum\n     */\n    setGenerationInterval(speed, particleNum) {\n        this.speedPerSec = speed;\n        this._generationInterval = ParticleGeneratorUtility.getInterval(speed, particleNum);\n    }\n    /**\n     * パーティクルの位置を経過時間分移動する。\n     * @param delta 前回アニメーションが実行されてからの経過時間 単位ms\n     */\n    move(delta) {\n        const movement = (delta / 1000) * this.speedPerSec;\n        this._particleContainer.move(movement);\n    }\n    /**\n     * 各パーティクルのEase関数を更新する。\n     * @param ease イージング関数。\n     * @param override 現存するパーティクルのEase関数を上書きするか否か。規定値はtrue。\n     */\n    updateEase(ease, override = true) {\n        this._ease = ease;\n        if (!override && this._modeManager.mode === "loop") {\n            console.warn("ParticleGenerator : ループ指定中にEase関数を再設定すると、既存のパーティクルのEase関数は常に上書きされます。");\n            console.trace();\n        }\n        if (override || this._modeManager.mode === "loop") {\n            this._particleContainer.overrideEase(ease);\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleContainer.js\n/**\n * 複数のパーティクルを格納、移動、管理するためのクラスです。\n *\n * 主にParticleGeneratorで生成されたパーティクルを管理します。\n * @see {@link ParticleGenerator}\n */\nclass ParticleContainer {\n    get particles() {\n        return this._particles;\n    }\n    get visible() {\n        return this._visible;\n    }\n    set visible(value) {\n        this._visible = value;\n        this._particles.forEach((p) => {\n            p.visible = this._visible;\n        });\n    }\n    constructor(modeManager) {\n        this._particles = [];\n        this._visible = true;\n        modeManager.on("change", (mode) => {\n            if (mode === "loop") {\n                this.removeAll();\n            }\n        });\n    }\n    /**\n     * パーティクルを格納する。\n     * @param particle\n     */\n    add(particle) {\n        this._particles.push(particle);\n        particle.visible = this._visible;\n    }\n    /**\n     * 格納されたすべてのパーティクルを移動させる。\n     * @see {@link Particle.add}\n     * @param t\n     */\n    move(t) {\n        this._particles.forEach((p) => {\n            p.add(t);\n        });\n    }\n    /**\n     * 寿命切れのパーティクルを一括で削除する。\n     */\n    removeCompletedParticles() {\n        //remove particles\n        this._particles\n            .filter((p) => {\n            return p.ratio >= 1.0;\n        })\n            .forEach((p) => {\n            p.dispose();\n        });\n        //update particle array\n        this._particles = this._particles.filter((p) => {\n            return p.ratio < 1.0;\n        });\n    }\n    /**\n     * 指定されたパーティクルを削除する。\n     * @param particle\n     */\n    remove(particle) {\n        const i = this._particles.indexOf(particle);\n        const popped = this._particles.splice(i, 1);\n        popped.forEach((val) => {\n            val.dispose();\n        });\n    }\n    /**\n     * 格納されたすべてのパーティクルを削除する。\n     */\n    removeAll() {\n        this._particles.forEach((p) => {\n            p.dispose();\n        });\n        this._particles = [];\n    }\n    /**\n     * 終端にたどり着いたパーティクルを始点に巻き戻す。\n     */\n    rollupParticles() {\n        this._particles.forEach((p) => {\n            p.update(p.ratio % 1);\n        });\n    }\n    overrideEase(ease) {\n        this._particles.forEach((p) => {\n            p.ease = ease;\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleValve.js\n/**\n * パーティクル新規生成のバルブ開閉を行うクラス\n * @see {@link ParticleGenerator}\n */\nclass ParticleValve {\n    get isOpen() {\n        return this._isOpen;\n    }\n    constructor(modeManager) {\n        this._isOpen = true;\n        this._modeManager = modeManager;\n    }\n    /**\n     * パーティクル生成を開始する。\n     */\n    open() {\n        if (this._isOpen)\n            return;\n        this._isOpen = true;\n        this.warnUpdateValveMode();\n    }\n    /**\n     * パーティクル生成を停止する。\n     * アニメーションは続行される。\n     */\n    close() {\n        if (!this._isOpen)\n            return;\n        this._isOpen = false;\n        this.warnUpdateValveMode();\n    }\n    warnUpdateValveMode() {\n        if (this._modeManager.mode !== "loop")\n            return;\n        console.warn("ParticleGenerator : ループ指定中にバルブ開閉操作を行いました。この操作はループ指定中には反映されません。");\n        console.trace();\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/generator/ParticleGenerator.js\n\n\n\n\n\n\n\n/**\n * 一定間隔でパーティクルを生成し、アニメーションさせるクラス。\n * パーティクルインスタンスの生成と管理を行う。\n */\nclass ParticleGenerator {\n    get isPlaying() {\n        return this._isPlaying;\n    }\n    /**\n     * コンストラクタ\n     * @param path\n     * @param option\n     */\n    constructor(path, option) {\n        this._isPlaying = false;\n        /**\n         * 前回パーティクル生成時からの経過時間 単位ms\n         * @private\n         */\n        this.elapsedFromGenerate = 0;\n        this._isDisposed = false;\n        /**\n         * パーティクルをアニメーションさせる。\n         * @param e\n         */\n        this.animate = (e) => {\n            if (this._isDisposed)\n                return;\n            this.animator.move(e.delta);\n            this.particleContainer.removeCompletedParticles();\n            this.addParticle(e.delta);\n        };\n        /**\n         * パーティクルをループアニメーションさせる。\n         * @param e\n         */\n        this.loop = (e) => {\n            if (this._isDisposed)\n                return;\n            if (this.particleContainer.particles.length === 0) {\n                this.generateAll();\n            }\n            this.animator.move(e.delta);\n            this.particleContainer.rollupParticles();\n        };\n        this.modeManager = new GenerationModeManager();\n        this.multipleWays = new MultipleParticleWays({ ways: path });\n        this.particleContainer = new ParticleContainer(this.modeManager);\n        this.valve = new ParticleValve(this.modeManager);\n        this.animator = new ParticleAnimator(this.modeManager, this.particleContainer);\n        this.modeManager.on("change", (val) => {\n            if (this._isPlaying) {\n                this.stop();\n                this.play();\n            }\n        });\n        option = ParticleGeneratorOption.initOption(option);\n        this.modeManager.mode = option.generationMode;\n        this.animator.updateEase(option.ease);\n        this.probability = option.probability;\n    }\n    /**\n     * パーティクルアニメーションを開始する。\n     */\n    play() {\n        if (this._isPlaying)\n            return;\n        this._isPlaying = true;\n        switch (this.modeManager.mode) {\n            case "loop":\n                RAFTicker.addListener("tick", this.loop);\n                break;\n            case "sequential":\n                RAFTicker.addListener("tick", this.animate);\n                break;\n        }\n    }\n    /**\n     * パーティクルアニメーションを停止する。\n     */\n    stop() {\n        if (!this._isPlaying)\n            return;\n        this._isPlaying = false;\n        RAFTicker.removeListener("tick", this.loop);\n        RAFTicker.removeListener("tick", this.animate);\n    }\n    /**\n     * アニメーションに伴い、新規パーティクルを追加する。\n     * @param delta\n     */\n    addParticle(delta) {\n        if (!this.valve.isOpen)\n            return;\n        const anim = this.animator;\n        this.elapsedFromGenerate += delta;\n        while (this.elapsedFromGenerate > anim.generationInterval) {\n            this.elapsedFromGenerate -= anim.generationInterval;\n            const move = (this.elapsedFromGenerate * anim.speedPerSec) / 1000;\n            //すでに寿命切れのパーティクルは生成をスキップ。\n            if (move > Particle.MAX_RATIO) {\n                continue;\n            }\n            const particle = this.generate();\n            particle?.add(move);\n        }\n    }\n    /**\n     * パーティクルを1つ追加する。\n     */\n    generate() {\n        this.multipleWays.countUp();\n        //発生確率に応じて生成の可否を判定する。\n        if (this.probability !== 1.0) {\n            if (Math.random() > this.probability)\n                return null;\n        }\n        const path = this.multipleWays.getParticleWay();\n        const particle = this.generateParticle(path);\n        if (this.animator.ease != null) {\n            particle.ease = this.animator.ease;\n        }\n        this.particleContainer.add(particle);\n        return particle;\n    }\n    /**\n     * パーティクルを生成する。\n     * generate関数の内部処理。\n     * @param path\n     */\n    generateParticle(path) {\n        const particle = new Particle(path);\n        //TODO ここでコンテナに挿入。\n        return particle;\n    }\n    /**\n     * 経路上にパーティクルを敷き詰める。\n     */\n    generateAll() {\n        //パーティクルの最大生存期間 単位ミリ秒\n        let lifeTime = 1000.0 / this.animator.speedPerSec;\n        while (lifeTime > 0.0) {\n            const particle = this.generate();\n            if (particle)\n                particle.update((lifeTime / 1000) * this.animator.speedPerSec);\n            lifeTime -= this.animator.generationInterval;\n        }\n        this.elapsedFromGenerate = 0;\n    }\n    /**\n     * パーティクル生成の停止とパーティクルの破棄を行う。\n     */\n    dispose() {\n        this.stop();\n        this._isDisposed = true;\n        this.particleContainer.removeAll();\n        this.particleContainer = null;\n        this.multipleWays = null;\n    }\n}\n/**\n * パーティクル生成方法を指定するオプション\n */\nclass ParticleGeneratorOption {\n    static initOption(option) {\n        option ??= {};\n        option.generationMode ??= "sequential";\n        option.probability ??= 1.0;\n        return option;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@masatomakino/particle-waypoint/esm/index.js\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQ2hHQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDcUQ7QUFDZDtBQUM2QjtBQUNIO0FBQ1I7QUFDRTtBQUNSO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQsZ0NBQWdDLG9CQUFvQixHQUFHLFlBQVk7QUFDbkUscUNBQXFDLGlCQUFpQjtBQUN0RCx5QkFBeUIsYUFBYTtBQUN0Qyw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQixRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakw4QjtBQUNHO0FBQ0Q7QUFDaUI7QUFDRztBQUNIO0FBQ0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9QYXJ0aWNsZS5qcz82YjNmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcGFydGljbGUtd2F5cG9pbnQvZXNtL1BhcnRpY2xlV2F5LmpzPzhlODYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vQmV6aWVyVXRpbC5qcz9hNzI0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcmFmLXRpY2tlci9lc20vUkFGVGlja2VyRXZlbnQuanM/YTRiMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3JhZi10aWNrZXIvZXNtL1JBRlRpY2tlci5qcz8wM2EzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcmFmLXRpY2tlci9lc20vaW5kZXguanM/MjFlMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9nZW5lcmF0b3IvR2VuZXJhdGlvbk1vZGVNYW5hZ2VyLmpzPzQ4MGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vZ2VuZXJhdG9yL011bHRpcGxlUGFydGljbGVXYXlzLmpzPzNiMmIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vZ2VuZXJhdG9yL1BhcnRpY2xlR2VuZXJhdG9yVXRpbGl0eS5qcz8yNmM1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0BtYXNhdG9tYWtpbm8vcGFydGljbGUtd2F5cG9pbnQvZXNtL2dlbmVyYXRvci9QYXJ0aWNsZUFuaW1hdG9yLmpzP2EzNmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vZ2VuZXJhdG9yL1BhcnRpY2xlQ29udGFpbmVyLmpzPzNlY2EiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvQG1hc2F0b21ha2luby9wYXJ0aWNsZS13YXlwb2ludC9lc20vZ2VuZXJhdG9yL1BhcnRpY2xlVmFsdmUuanM/NTUwNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9nZW5lcmF0b3IvUGFydGljbGVHZW5lcmF0b3IuanM/ZjIyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9AbWFzYXRvbWFraW5vL3BhcnRpY2xlLXdheXBvaW50L2VzbS9pbmRleC5qcz8yYjI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog44OR44O844OG44Kj44Kv44Or44KS6KGo44GZ44Kv44Op44K544CCXG4gKiDjgZPjga7jgq/jg6njgrnoh6rkvZPjgavjga/mj4/nlLvjga7jgZ/jgoHjga7mqZ/og73jga/jgarjgYTjgIJcbiAqIOWQhOeoruOBruaPj+eUu+ODqeOCpOODluODqeODquOBqOe1hOOBv+WQiOOCj+OBm+OBpuWIqeeUqOOBmeOCi+OAglxuICovXG5leHBvcnQgY2xhc3MgUGFydGljbGUge1xuICAgIC8qKlxuICAgICAqIOaMh+WumuOBleOCjOOBn+ODkeOCueOBq+ayv+OBo+OBpuenu+WLleOBmeOCi+ODkeODvOODhuOCo+OCr+ODq+OCkueUn+aIkOOBmeOCi+OAglxuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0aCkge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IDAuMDtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+OBruS9jee9ruOCkuabtOaWsOOBmeOCi+OAglxuICAgICAqIEBwYXJhbSB0IOODkeODvOODhuOCo+OCr+ODq+OBruODkeOCueS4iuOBruS9jee9ruOAguWFpeWKm+OBq+WItumZkOOBr+OBquOBhOOBjOOAgVBhcnRpY2xlV2F55YG044GnMC4wfjEuMOOBrumWk+OBq+S4uOOCgei+vOOBvuOCjOOCi+OAglxuICAgICAqIEByZXR1cm4gbiBlYXNl6Zai5pWw44Gn6KOc5q2j5riI44G/44GudOOAglxuICAgICAqL1xuICAgIHVwZGF0ZSh0KSB7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gdDtcbiAgICAgICAgaWYgKHRoaXMuZWFzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZSh0aGlzLl9yYXRpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+S9jee9ruOCkuaMh+WumuOBleOCjOOBn+mHj+enu+WLleOBmeOCi+OAglxuICAgICAqIEBwYXJhbSB0IOenu+WLlemHjyAwLjAgfiAxLjBcbiAgICAgKi9cbiAgICBhZGQodCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUodGhpcy5fcmF0aW8gKyB0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog54++5Zyo5L2N572u44KS5Y+W5b6X44GZ44KLXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgcmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYXRpbztcbiAgICB9XG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7IH1cbn1cblBhcnRpY2xlLk1BWF9SQVRJTyA9IDEuMDtcblBhcnRpY2xlLk1JTl9SQVRJTyA9IDAuMDtcbiIsIi8qKlxuICog5Lit6ZaT54K544Gu5bqn5qiZ44Gu566X5Ye644GM5Y+v6IO944Gq57WM6Lev44KS6KGo44GZ44Kv44Op44K5XG4gKi9cbmltcG9ydCB7IFBhcnRpY2xlLCBCZXppZXJVdGlsIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmV4cG9ydCBjbGFzcyBQYXJ0aWNsZVdheSB7XG4gICAgLyoqXG4gICAgICog44Kz44Oz44K544OI44Op44Kv44K/XG4gICAgICogQHBhcmFtIHBvaW50cyDntYzot6/jgpLooajjgZnluqfmqJnjga7phY3liJfjgILopoHntKDmlbDjgavjgojjgaPjgabjganjga7jgojjgYbjgarjg5HjgrnjgYvjgYzliKTlrprjgZXjgozjgovjgIJcbiAgICAgKiAgIOimgee0oOaVsDIgOiAy5qyh5YWD44OR44K5XG4gICAgICogICDopoHntKDmlbAzIDogM+asoeWFg+ODkeOCuVxuICAgICAqICAg6KaB57Sg5pWwNiA6IOW5s+mdojPmrKHlhYPjg5njgrjjgqfmm7Lnt5pcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOe1jOi3r+OBruW6p+aomemFjeWIl+OCkuabtOaWsOOBmeOCi+OAglxuICAgICAqIEBwYXJhbSBwb2ludHNcbiAgICAgKi9cbiAgICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMub25TZXRQb2ludHMoKTtcbiAgICB9XG4gICAgd2FyblBvaW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlBhcnRpY2xlV2F5IDog6ZW344GV44K844Ot44Gu6YWN5YiX44GM5oyH5a6a44GV44KM44G+44GX44Gf44CC5bqn5qiZ44GM566X5Ye644Gn44GN44Gq44GE44Gf44KB44CBZ2V0UG9pbnTplqLmlbDjga/luLjjgatudWxs44KS6L+U44GX44G+44GZ44CCXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQYXJ0aWNsZVdheSA6IOmVt+OBlTHjga7phY3liJfjgYzmjIflrprjgZXjgozjgb7jgZfjgZ/jgILluqfmqJnjgYznrpflh7rjgafjgY3jgarjgYTjgZ/jgoHjgIFnZXRQb2ludOmWouaVsOOBr+W4uOOBq+WbuuWumuOBruW6p+aomeOCkui/lOOBl+OBvuOBmeOAglwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBwb2ludHPjgYzmm7TmlrDjgZXjgozjgZ/pmpvjga7lh6bnkIbjgIJcbiAgICAgKiBzZXQgcG9pbnRz44KS44OI44Oq44Ks44O844Gr44GX44Gm5a6f6KGM44GV44KM44KL44CCXG4gICAgICovXG4gICAgb25TZXRQb2ludHMoKSB7XG4gICAgICAgIHRoaXMud2FyblBvaW50cygpO1xuICAgICAgICBjb25zdCBzdW1UYWJsZSA9IG5ldyBBcnJheSh0aGlzLl9wb2ludHMubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICB0aGlzLl9wb2ludHMuZm9yRWFjaCgodmFsLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdW1UYWJsZVtpbmRleF0gPVxuICAgICAgICAgICAgICAgIFBhcnRpY2xlV2F5LmdldERpc3RhbmNlKGFycmF5W2luZGV4IC0gMV0sIHZhbCkgKyBzdW1UYWJsZVtpbmRleCAtIDFdO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBzdW1UYWJsZVtzdW1UYWJsZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5fcmF0aW9UYWJsZSA9IHN1bVRhYmxlLm1hcCgodmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsIC8gdG90YWw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAy54K56ZaT44Gu6Led6Zui44KS5Y+W5b6X44GZ44KL44CCXG4gICAgICogQHBhcmFtIHBvczFcbiAgICAgKiBAcGFyYW0gcG9zMlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREaXN0YW5jZShwb3MxLCBwb3MyKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XG4gICAgICAgIHN3aXRjaCAocG9zMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQmV6aWVyVXRpbC5nZXRMZW5ndGhGcm9tQ29tbWFuZChwb3MxLCBwb3MyKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjb25zdCBkeiA9IHBvczJbMl0gLSBwb3MxWzJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDntYzot6/kuIrjga7kuK3plpPngrnluqfmqJnjgpLlj5blvpfjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gdCDnrpflh7rjgZnjgovluqfmqJnjga7kvY3nva7jgIIwLjAo5aeL54K5KSB+IDEuMCjntYLngrkp44Gu6ZaT44CCXG4gICAgICovXG4gICAgZ2V0UG9pbnQodCkge1xuICAgICAgICB0ID0gUGFydGljbGVXYXlVdGlsLmNsYW1wUmF0aW8odCk7XG4gICAgICAgIGNvbnN0IGxpbWl0ZWQgPSB0aGlzLmdldExpbWl0UG9pbnQodCk7XG4gICAgICAgIGlmIChsaW1pdGVkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBsaW1pdGVkO1xuICAgICAgICBjb25zdCBpID0gUGFydGljbGVXYXlVdGlsLmdldFRJbmRleCh0LCB0aGlzLl9yYXRpb1RhYmxlKTtcbiAgICAgICAgY29uc3QgZmxvb3JQb2ludCA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgY29uc3QgY2VpbFBvaW50ID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgcmF0aW9CYXNlID0gdGhpcy5fcmF0aW9UYWJsZVtpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQoZmxvb3JQb2ludCwgY2VpbFBvaW50LCAodCAtIHJhdGlvQmFzZSkgLyAodGhpcy5fcmF0aW9UYWJsZVtpICsgMV0gLSByYXRpb0Jhc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UG9pbnTjga7jgYbjgaHjgIHliLbpmZDjgavjgYvjgYvjgovlgKTjgpLlj5blvpfjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGltaXRQb2ludCh0KSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9pbnRzIHx8IHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ID09PSBQYXJ0aWNsZS5NQVhfUkFUSU8pIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJ0aWNsZVdheVV0aWwuZ2V0UG9zaXRpb25XaXRoTWF4VCh0aGlzLl9wb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAxIHx8IHQgPT09IFBhcnRpY2xlLk1JTl9SQVRJTykge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9wb2ludHNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog57ea5YiG5LiK44Gu5Lit6ZaT54K55bqn5qiZ44KS5Y+W5b6X44GZ44KLXG4gICAgICogQHBhcmFtIHBvczEg57ea5YiG44Gu5aeL54K5XG4gICAgICogQHBhcmFtIHBvczIg57ea5YiG44Gu57WC54K5XG4gICAgICogQHBhcmFtIHQg566X5Ye644GZ44KL5bqn5qiZ44Gu5L2N572u44CCMC4wKOWni+eCuSkgfiAxLjAo57WC54K5KeOBrumWk+OAglxuICAgICAqL1xuICAgIGdldENlbnRlclBvaW50KHBvczEsIHBvczIsIHQpIHtcbiAgICAgICAgY29uc3QgcnQgPSAxLjAgLSB0O1xuICAgICAgICBsZXQgcG9zID0gW3BvczFbMF0gKiBydCArIHBvczJbMF0gKiB0LCBwb3MxWzFdICogcnQgKyBwb3MyWzFdICogdF07XG4gICAgICAgIHN3aXRjaCAocG9zMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQmV6aWVyVXRpbC5nZXRQb2ludEZyb21Db21tYW5kKHQsIHBvczEsIHBvczIpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHBvcy5wdXNoKHBvczFbMl0gKiBydCArIHBvczJbMl0gKiB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBQYXJ0aWNsZVdheVV0aWwge1xuICAgIHN0YXRpYyBjbGFtcCh2YWwsIG1heCwgbWluKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG4gICAgfVxuICAgIHN0YXRpYyBjbGFtcFJhdGlvKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFtcCh2YWwsIFBhcnRpY2xlLk1BWF9SQVRJTywgUGFydGljbGUuTUlOX1JBVElPKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFBvc2l0aW9uV2l0aE1heFQocG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcG9pbnRzW24gLSAxXTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgtMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHRdO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VEluZGV4KHQsIHJhdGlvVGFibGUpIHtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBjb25zdCBuID0gcmF0aW9UYWJsZS5sZW5ndGg7XG4gICAgICAgIGZvciAoaTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHJhdGlvVGFibGVbaV0gPj0gdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFBhcnRpY2xlV2F5IH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmV4cG9ydCBjbGFzcyBCZXppZXJVdGlsIHtcbiAgICAvKipcbiAgICAgKiDjg5njgrjjgqfmm7Lnt5rjga7kuK3plpPluqfmqJnjgpLlj5blvpfjgZnjgovjgIJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0IOWqkuS7i+WkieaVsCAwLjAgfiAxLjBcbiAgICAgKiBAcGFyYW0gZnJvbSDlp4vngrlcbiAgICAgKiBAcGFyYW0gYzEg44Kz44Oz44OI44Ot44O844Or44Od44Kk44Oz44OIMVxuICAgICAqIEBwYXJhbSBjMiDjgrPjg7Pjg4jjg63jg7zjg6vjg53jgqTjg7Pjg4gyXG4gICAgICogQHBhcmFtIHRvIOe1gueCuVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQb2ludCh0LCBmcm9tLCBjMSwgYzIsIHRvKSB7XG4gICAgICAgIGNvbnN0IGFkZFBvaW50ID0gKHAxLCBwMiwgY29lZmZpY2llbnQpID0+IHtcbiAgICAgICAgICAgIHAxWzBdICs9IGNvZWZmaWNpZW50ICogcDJbMF07XG4gICAgICAgICAgICBwMVsxXSArPSBjb2VmZmljaWVudCAqIHAyWzFdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbMCwgMF07XG4gICAgICAgIGNvbnN0IGRpZlQgPSAxIC0gdDtcbiAgICAgICAgbGV0IHYgPSBNYXRoLnBvdyhkaWZULCAzKTtcbiAgICAgICAgYWRkUG9pbnQocmVzdWx0LCBmcm9tLCB2KTtcbiAgICAgICAgdiA9IDMgKiBNYXRoLnBvdyhkaWZULCAyKSAqIHQ7XG4gICAgICAgIGFkZFBvaW50KHJlc3VsdCwgYzEsIHYpO1xuICAgICAgICB2ID0gMyAqIE1hdGgucG93KHQsIDIpICogZGlmVDtcbiAgICAgICAgYWRkUG9pbnQocmVzdWx0LCBjMiwgdik7XG4gICAgICAgIHYgPSBNYXRoLnBvdyh0LCAzKTtcbiAgICAgICAgYWRkUG9pbnQocmVzdWx0LCB0bywgdik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODmeOCuOOCp+absue3muaPj+eUu+OCs+ODnuODs+ODieOBi+OCieOAgeODmeOCuOOCp+absue3muOBruS4remWk+W6p+aomeOCkuWPluW+l+OBmeOCi+OAglxuICAgICAqIEBwYXJhbSB0XG4gICAgICogQHBhcmFtIGNvbW1hbmQxIOWni+eCueWBtOOBruaPj+eUu+OCs+ODnuODs+ODiSDopoHntKDmlbAy44KC44GX44GP44GvNuOBrumFjeWIl1xuICAgICAqIEBwYXJhbSBjb21tYW5kMiDntYLngrnlgbTjga7mj4/nlLvjgrPjg57jg7Pjg4kg6KaB57Sg5pWwNuOBrumFjeWIl1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQb2ludEZyb21Db21tYW5kKHQsIGNvbW1hbmQxLCBjb21tYW5kMikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCh0LCBjb21tYW5kMS5zbGljZSgtMiksIGNvbW1hbmQyLnNsaWNlKDAsIDIpLCBjb21tYW5kMi5zbGljZSgyLCA0KSwgY29tbWFuZDIuc2xpY2UoLTIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OZ44K444Kn5puy57ea44Gu6ZW344GV44KS5Y+W5b6X44GZ44KL44CCXG4gICAgICogZGl244Gu5pWw44Gg44GR44OZ44K444Kn5puy57ea44KS5YiG5Ymy44GX44CB55u057ea44Gu6ZuG5ZCI44Go44GX44Gm6Led6Zui44KS5ris44KL44CCXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbSDlp4vngrlcbiAgICAgKiBAcGFyYW0gYzEg44Kz44Oz44OI44Ot44O844Or44Od44Kk44Oz44OIMVxuICAgICAqIEBwYXJhbSBjMiDjgrPjg7Pjg4jjg63jg7zjg6vjg53jgqTjg7Pjg4gyXG4gICAgICogQHBhcmFtIHRvIOe1gueCuVxuICAgICAqIEBwYXJhbSBkaXYg5YiG5Ymy5pWwIOWkmuOBhOOBu+OBqeeyvuW6puOBjOWQkeS4iuOBl+OAgeioiOeul+iyoOiNt+OBr+S4iuaYh+OBmeOCi+OAgiDml6LlrprlgKQxNlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRMZW5ndGgoZnJvbSwgYzEsIGMyLCB0bywgZGl2ID0gMTYpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGxldCBwcmV2UG9pbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGl2ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRQb2ludChpIC8gZGl2LCBmcm9tLCBjMSwgYzIsIHRvKTtcbiAgICAgICAgICAgIGlmIChwcmV2UG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gUGFydGljbGVXYXkuZ2V0RGlzdGFuY2UocHJldlBvaW50LCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQb2ludCA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OZ44K444Kn5puy57ea5o+P55S744Kz44Oe44Oz44OJ44GL44KJ44CB44OZ44K444Kn5puy57ea44Gu6ZW344GV44KS5Y+W5b6X44GZ44KL44CCXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tbWFuZDEg5aeL54K55YG044Gu5o+P55S744Kz44Oe44Oz44OJIOimgee0oOaVsDLjgoLjgZfjgY/jga8244Gu6YWN5YiXXG4gICAgICogQHBhcmFtIGNvbW1hbmQyIOe1gueCueWBtOOBruaPj+eUu+OCs+ODnuODs+ODiSDopoHntKDmlbA244Gu6YWN5YiXXG4gICAgICogQHBhcmFtIGRpdiDliIblibLmlbAg5aSa44GE44G744Gp57K+5bqm44GM5ZCR5LiK44GX44CB6KiI566X6LKg6I2344Gv5LiK5piH44GZ44KL44CCIOaXouWumuWApDE2XG4gICAgICovXG4gICAgc3RhdGljIGdldExlbmd0aEZyb21Db21tYW5kKGNvbW1hbmQxLCBjb21tYW5kMiwgZGl2ID0gMTYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGVuZ3RoKGNvbW1hbmQxLnNsaWNlKC0yKSwgY29tbWFuZDIuc2xpY2UoMCwgMiksIGNvbW1hbmQyLnNsaWNlKDIsIDQpLCBjb21tYW5kMi5zbGljZSgtMiksIGRpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIDPmrKHjg5njgrjjgqfmm7Lnt5rjgpIy5qyh5YWD5bqn5qiZ44Gu6YWN5YiX44Gr5YiG6Kej44GZ44KL44CCXG4gICAgICogQHBhcmFtIGNvbW1hbmRzXG4gICAgICogQHBhcmFtIGRpdiDliIblibLmlbAg44OH44OV44Kp44Or44OI44GvMTZcbiAgICAgKi9cbiAgICBzdGF0aWMgc3ViZGl2aWRlKGNvbW1hbmRzLCBkaXYgPSAxNikge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN1YiA9IHRoaXMuc3ViZGl2aWRlU3ViUGF0aChjb21tYW5kc1tpIC0gMV0sIGNvbW1hbmRzW2ldLCBkaXYpO1xuICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSBzdWIuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaCguLi5zdWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHN0YXRpYyBzdWJkaXZpZGVTdWJQYXRoKGNvbW1hbmQxLCBjb21tYW5kMiwgZGl2ID0gMTYpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGl2ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLmdldFBvaW50RnJvbUNvbW1hbmQoaSAvIGRpdiwgY29tbWFuZDEsIGNvbW1hbmQyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG59XG4iLCJleHBvcnQgY2xhc3MgUkFGVGlja2VyRXZlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lc3RhbXAsIGRlbHRhKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XG4gICAgfVxufVxuIiwidmFyIF9hO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbmltcG9ydCB7IFJBRlRpY2tlckV2ZW50Q29udGV4dCB9IGZyb20gXCIuL1JBRlRpY2tlckV2ZW50LmpzXCI7XG5leHBvcnQgY2xhc3MgUkFGVGlja2VyIHtcbiAgICBzdGF0aWMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0YXRpYyByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIV9hLl9pZCkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFVwZGF0ZVRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF9hLm9uVGljayhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHN0b3AoKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF9hLl9pZCk7XG4gICAgICAgIHRoaXMuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sYXN0VXBkYXRlVGltZXN0YW1wID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdGF0aWMgYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZGlzcGF0Y2hlci5saXN0ZW5lcnModHlwZSk7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnMuaW5jbHVkZXMobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjgqTjg5njg7Pjg4jjgpLnmbrlirnjgZnjgovjgIJcbiAgICAgKiDjgZPjga7plqLmlbDjga/jgqLjg5fjg6rjgrHjg7zjgrfjg6fjg7PjgYvjgonliKnnlKjjgZnjgovjgZPjgajjga/jgarjgY/jgIHkuLvjgavljZjkvZPjg4bjgrnjg4jjga7jgZ/jgoHjgavkvb/nlKjjgZnjgovjgIJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgc3RhdGljIGVtaXQodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hlci5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICB9XG4gICAgc3RhdGljIGVtaXRUaWNrRXZlbnQodGltZXN0YW1wKSB7XG4gICAgICAgIGlmIChfYS5fbGFzdFVwZGF0ZVRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfYS5fbGFzdFVwZGF0ZVRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRpbWVzdGFtcCAtIF9hLl9sYXN0VXBkYXRlVGltZXN0YW1wO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyLmVtaXQoXCJvbkJlZm9yZVRpY2tcIiwgbmV3IFJBRlRpY2tlckV2ZW50Q29udGV4dCh0aW1lc3RhbXAsIGRlbHRhKSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZW1pdChcInRpY2tcIiwgbmV3IFJBRlRpY2tlckV2ZW50Q29udGV4dCh0aW1lc3RhbXAsIGRlbHRhKSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoZXIuZW1pdChcIm9uQWZ0ZXJUaWNrXCIsIG5ldyBSQUZUaWNrZXJFdmVudENvbnRleHQodGltZXN0YW1wLCBkZWx0YSkpO1xuICAgICAgICBfYS5fbGFzdFVwZGF0ZVRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9XG59XG5fYSA9IFJBRlRpY2tlcjtcbi8qKlxuICogQWxpYXMgZm9yIGFkZExpc3RlbmVyXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICovXG5SQUZUaWNrZXIub24gPSBfYS5hZGRMaXN0ZW5lcjtcbi8qKlxuICogQWxpYXMgZm9yIHJlbW92ZUxpc3RlbmVyXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICovXG5SQUZUaWNrZXIub2ZmID0gX2EucmVtb3ZlTGlzdGVuZXI7XG5SQUZUaWNrZXIub25UaWNrID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgIF9hLmVtaXRUaWNrRXZlbnQodGltZXN0YW1wKTtcbiAgICBfYS5faWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2Eub25UaWNrKTtcbn07XG5SQUZUaWNrZXIuaW5pdGlhbGl6ZSgpO1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vUkFGVGlja2VyLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SQUZUaWNrZXJFdmVudC5qc1wiO1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbmV4cG9ydCBjbGFzcyBHZW5lcmF0aW9uTW9kZU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgc2V0IG1vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9tb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tb2RlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzLl9tb2RlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX21vZGUgPSBcInNlcXVlbnRpYWxcIjtcbiAgICB9XG59XG4iLCIvKipcbiAqIOOBk+OBruOCr+ODqeOCueOBr+OAgVBhcnRpY2xlR2VuZXJhdG9y44Gr6Kit5a6a44GV44KM44Gf6KSH5pWw44Gu57WM6Lev44KS566h55CG44GZ44KL44Gf44KB44Gu44KC44Gu44Gn44GZ44CCXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aXBsZVBhcnRpY2xlV2F5cyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uKSB7XG4gICAgICAgIHRoaXMud2F5U2VsZWN0aW9uQ291bnQgPSAwO1xuICAgICAgICBNdWx0aXBsZVBhcnRpY2xlV2F5c09wdGlvbi5pbml0T3B0aW9uKG9wdGlvbik7XG4gICAgICAgIHRoaXMud2F5cyA9IG9wdGlvbi53YXlzO1xuICAgICAgICB0aGlzLndheVNlbGVjdFR5cGUgPSBvcHRpb24udHlwZTtcbiAgICB9XG4gICAgY291bnRVcCgpIHtcbiAgICAgICAgdGhpcy53YXlTZWxlY3Rpb25Db3VudCA9ICh0aGlzLndheVNlbGVjdGlvbkNvdW50ICsgMSkgJSB0aGlzLndheXMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRQYXJ0aWNsZVdheSgpIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBzd2l0Y2ggKHRoaXMud2F5U2VsZWN0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInNlcXVlbnRpYWxcIjpcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMud2F5U2VsZWN0aW9uQ291bnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmFuZG9tXCI6XG4gICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLndheXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53YXlzW2luZGV4XTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTXVsdGlwbGVQYXJ0aWNsZVdheXNPcHRpb24ge1xuICAgIHN0YXRpYyBpbml0T3B0aW9uKG9wdGlvbikge1xuICAgICAgICBvcHRpb24gPz89IHt9O1xuICAgICAgICBvcHRpb24ud2F5cyA/Pz0gW107XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb24ud2F5cykpIHtcbiAgICAgICAgICAgIG9wdGlvbi53YXlzID0gW29wdGlvbi53YXlzXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb24udHlwZSA/Pz0gXCJzZXF1ZW50aWFsXCI7XG4gICAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxufVxuIiwiLyoqXG4gKiBQYXJ0aWNsZUdlbmVyYXRvcuOBp+WIqeeUqOOBmeOCi+WQhOeoruOBruWApOOCkueul+WHuuOBmeOCi+ODmOODq+ODkeODvOOCr+ODqeOCuVxuICovXG5leHBvcnQgY2xhc3MgUGFydGljbGVHZW5lcmF0b3JVdGlsaXR5IHtcbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjga7nlJ/miJDjgqTjg7Pjgr/jg7zjg5Djg6vjgajntYzot6/kuIrjga7mlbDjgYvjgonjgIHnp7vli5XpgJ/luqbjgpLnrpflh7rjgZnjgotcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxcbiAgICAgKiBAcGFyYW0gcGFydGljbGVOdW1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3BlZWQoaW50ZXJ2YWwsIHBhcnRpY2xlTnVtKSB7XG4gICAgICAgIHJldHVybiAoMS4wIC8gKGludGVydmFsICogcGFydGljbGVOdW0pKSAqIDEwMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+OBruenu+WLlemAn+W6puOBqOe1jOi3r+S4iuOBruaVsOOBi+OCieOAgeeUn+aIkOOCpOODs+OCv+ODvOODkOODq+OCkueul+WHuuOBmeOCi1xuICAgICAqIEBwYXJhbSBzcGVlZFxuICAgICAqIEBwYXJhbSBwYXJ0aWNsZU51bVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnRlcnZhbChzcGVlZCwgcGFydGljbGVOdW0pIHtcbiAgICAgICAgcmV0dXJuICgxLjAgLyBzcGVlZCAvIHBhcnRpY2xlTnVtKSAqIDEwMDA7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUGFydGljbGVHZW5lcmF0b3JVdGlsaXR5IH0gZnJvbSBcIi4vUGFydGljbGVHZW5lcmF0b3JVdGlsaXR5LmpzXCI7XG5leHBvcnQgY2xhc3MgUGFydGljbGVBbmltYXRvciB7XG4gICAgZ2V0IGdlbmVyYXRpb25JbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRpb25JbnRlcnZhbDtcbiAgICB9XG4gICAgc2V0IGdlbmVyYXRpb25JbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fZ2VuZXJhdGlvbkludGVydmFsID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGlvbkludGVydmFsID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlTWFuYWdlci5tb2RlID09PSBcImxvb3BcIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUGFydGljbGVHZW5lcmF0b3IgOiDjg6vjg7zjg5fmjIflrprkuK3jgavjg5Hjg7zjg4bjgqPjgq/jg6vnlJ/miJDplpPpmpTjgpLlho3oqK3lrprjgZfjgabjgoLlj43mmKDjgZXjgozjgb7jgZvjgpPjgILoqK3lrprjgpLlj43mmKDjgZnjgovjgZ/jgoHjgavjg5Hjg7zjg4bjgqPjgq/jg6vjgpLliYrpmaTjgZfjgablho3nlJ/miJDjgZfjgabjgY/jgaDjgZXjgYTjgIJcIik7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lYXNlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlTWFuYWdlciwgcGFydGljbGVDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGlvbkludGVydmFsID0gMzAwO1xuICAgICAgICB0aGlzLnNwZWVkUGVyU2VjID0gMC4wNztcbiAgICAgICAgdGhpcy5fcGFydGljbGVDb250YWluZXIgPSBwYXJ0aWNsZUNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fbW9kZU1hbmFnZXIgPSBtb2RlTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog55Sf5oiQ44Kk44Oz44K/44O844OQ44Or44Go57WM6Lev5LiK44Gu44OR44O844OG44Kj44Kv44Or5pWw44GL44KJ56e75YuV44K544OU44O844OJ44KS566X5Ye644GX6Kit5a6a44GZ44KL44CCXG4gICAgICogbG9vcOaZguOBq+egtOe2u+OBl+OBquOBhOWApOOBjOW+l+OCieOCjOOCi+OAglxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFxuICAgICAqIEBwYXJhbSBwYXJ0aWNsZU51bVxuICAgICAqL1xuICAgIHNldFNwZWVkKGludGVydmFsLCBwYXJ0aWNsZU51bSkge1xuICAgICAgICB0aGlzLl9nZW5lcmF0aW9uSW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5zcGVlZFBlclNlYyA9IFBhcnRpY2xlR2VuZXJhdG9yVXRpbGl0eS5nZXRTcGVlZChpbnRlcnZhbCwgcGFydGljbGVOdW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDnp7vli5Xjgrnjg5Tjg7zjg4njgajntYzot6/kuIrjga7jg5Hjg7zjg4bjgqPjgq/jg6vmlbDjgYvjgonnlJ/miJDjgqTjg7Pjgr/jg7zjg5Djg6vjgpLnrpflh7rjgZfoqK3lrprjgZnjgovjgIJcbiAgICAgKiBsb29w5pmC44Gr56C057a744GX44Gq44GE5YCk44GM5b6X44KJ44KM44KL44CCXG4gICAgICogQHBhcmFtIHNwZWVkXG4gICAgICogQHBhcmFtIHBhcnRpY2xlTnVtXG4gICAgICovXG4gICAgc2V0R2VuZXJhdGlvbkludGVydmFsKHNwZWVkLCBwYXJ0aWNsZU51bSkge1xuICAgICAgICB0aGlzLnNwZWVkUGVyU2VjID0gc3BlZWQ7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRpb25JbnRlcnZhbCA9IFBhcnRpY2xlR2VuZXJhdG9yVXRpbGl0eS5nZXRJbnRlcnZhbChzcGVlZCwgcGFydGljbGVOdW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjga7kvY3nva7jgpLntYzpgY7mmYLplpPliIbnp7vli5XjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gZGVsdGEg5YmN5Zue44Ki44OL44Oh44O844K344On44Oz44GM5a6f6KGM44GV44KM44Gm44GL44KJ44Gu57WM6YGO5pmC6ZaTIOWNmOS9jW1zXG4gICAgICovXG4gICAgbW92ZShkZWx0YSkge1xuICAgICAgICBjb25zdCBtb3ZlbWVudCA9IChkZWx0YSAvIDEwMDApICogdGhpcy5zcGVlZFBlclNlYztcbiAgICAgICAgdGhpcy5fcGFydGljbGVDb250YWluZXIubW92ZShtb3ZlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWQhOODkeODvOODhuOCo+OCr+ODq+OBrkVhc2XplqLmlbDjgpLmm7TmlrDjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gZWFzZSDjgqTjg7zjgrjjg7PjgrDplqLmlbDjgIJcbiAgICAgKiBAcGFyYW0gb3ZlcnJpZGUg54++5a2Y44GZ44KL44OR44O844OG44Kj44Kv44Or44GuRWFzZemWouaVsOOCkuS4iuabuOOBjeOBmeOCi+OBi+WQpuOBi+OAguimj+WumuWApOOBr3RydWXjgIJcbiAgICAgKi9cbiAgICB1cGRhdGVFYXNlKGVhc2UsIG92ZXJyaWRlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9lYXNlID0gZWFzZTtcbiAgICAgICAgaWYgKCFvdmVycmlkZSAmJiB0aGlzLl9tb2RlTWFuYWdlci5tb2RlID09PSBcImxvb3BcIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUGFydGljbGVHZW5lcmF0b3IgOiDjg6vjg7zjg5fmjIflrprkuK3jgatFYXNl6Zai5pWw44KS5YaN6Kit5a6a44GZ44KL44Go44CB5pei5a2Y44Gu44OR44O844OG44Kj44Kv44Or44GuRWFzZemWouaVsOOBr+W4uOOBq+S4iuabuOOBjeOBleOCjOOBvuOBmeOAglwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGUgfHwgdGhpcy5fbW9kZU1hbmFnZXIubW9kZSA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlQ29udGFpbmVyLm92ZXJyaWRlRWFzZShlYXNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICog6KSH5pWw44Gu44OR44O844OG44Kj44Kv44Or44KS5qC857SN44CB56e75YuV44CB566h55CG44GZ44KL44Gf44KB44Gu44Kv44Op44K544Gn44GZ44CCXG4gKlxuICog5Li744GrUGFydGljbGVHZW5lcmF0b3LjgafnlJ/miJDjgZXjgozjgZ/jg5Hjg7zjg4bjgqPjgq/jg6vjgpLnrqHnkIbjgZfjgb7jgZnjgIJcbiAqIEBzZWUge0BsaW5rIFBhcnRpY2xlR2VuZXJhdG9yfVxuICovXG5leHBvcnQgY2xhc3MgUGFydGljbGVDb250YWluZXIge1xuICAgIGdldCBwYXJ0aWNsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWNsZXM7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG4gICAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXJ0aWNsZXMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgcC52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcyA9IFtdO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgbW9kZU1hbmFnZXIub24oXCJjaGFuZ2VcIiwgKG1vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcImxvb3BcIikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjgpLmoLzntI3jgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gcGFydGljbGVcbiAgICAgKi9cbiAgICBhZGQocGFydGljbGUpIHtcbiAgICAgICAgdGhpcy5fcGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgICAgICBwYXJ0aWNsZS52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5qC857SN44GV44KM44Gf44GZ44G544Gm44Gu44OR44O844OG44Kj44Kv44Or44KS56e75YuV44GV44Gb44KL44CCXG4gICAgICogQHNlZSB7QGxpbmsgUGFydGljbGUuYWRkfVxuICAgICAqIEBwYXJhbSB0XG4gICAgICovXG4gICAgbW92ZSh0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLmFkZCh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWvv+WRveWIh+OCjOOBruODkeODvOODhuOCo+OCr+ODq+OCkuS4gOaLrOOBp+WJiumZpOOBmeOCi+OAglxuICAgICAqL1xuICAgIHJlbW92ZUNvbXBsZXRlZFBhcnRpY2xlcygpIHtcbiAgICAgICAgLy9yZW1vdmUgcGFydGljbGVzXG4gICAgICAgIHRoaXMuX3BhcnRpY2xlc1xuICAgICAgICAgICAgLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHAucmF0aW8gPj0gMS4wO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIHAuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy91cGRhdGUgcGFydGljbGUgYXJyYXlcbiAgICAgICAgdGhpcy5fcGFydGljbGVzID0gdGhpcy5fcGFydGljbGVzLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHAucmF0aW8gPCAxLjA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDmjIflrprjgZXjgozjgZ/jg5Hjg7zjg4bjgqPjgq/jg6vjgpLliYrpmaTjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gcGFydGljbGVcbiAgICAgKi9cbiAgICByZW1vdmUocGFydGljbGUpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuX3BhcnRpY2xlcy5pbmRleE9mKHBhcnRpY2xlKTtcbiAgICAgICAgY29uc3QgcG9wcGVkID0gdGhpcy5fcGFydGljbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcG9wcGVkLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOagvOe0jeOBleOCjOOBn+OBmeOBueOBpuOBruODkeODvOODhuOCo+OCr+ODq+OCkuWJiumZpOOBmeOCi+OAglxuICAgICAqL1xuICAgIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5fcGFydGljbGVzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIHAuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGFydGljbGVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOe1guerr+OBq+OBn+OBqeOCiuedgOOBhOOBn+ODkeODvOODhuOCo+OCr+ODq+OCkuWni+eCueOBq+W3u+OBjeaIu+OBmeOAglxuICAgICAqL1xuICAgIHJvbGx1cFBhcnRpY2xlcygpIHtcbiAgICAgICAgdGhpcy5fcGFydGljbGVzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIHAudXBkYXRlKHAucmF0aW8gJSAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG92ZXJyaWRlRWFzZShlYXNlKSB7XG4gICAgICAgIHRoaXMuX3BhcnRpY2xlcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLmVhc2UgPSBlYXNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKipcbiAqIOODkeODvOODhuOCo+OCr+ODq+aWsOimj+eUn+aIkOOBruODkOODq+ODlumWi+mWieOCkuihjOOBhuOCr+ODqeOCuVxuICogQHNlZSB7QGxpbmsgUGFydGljbGVHZW5lcmF0b3J9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNsZVZhbHZlIHtcbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl9tb2RlTWFuYWdlciA9IG1vZGVNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vnlJ/miJDjgpLplovlp4vjgZnjgovjgIJcbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5faXNPcGVuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLndhcm5VcGRhdGVWYWx2ZU1vZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or55Sf5oiQ44KS5YGc5q2i44GZ44KL44CCXG4gICAgICog44Ki44OL44Oh44O844K344On44Oz44Gv57aa6KGM44GV44KM44KL44CCXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNPcGVuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YXJuVXBkYXRlVmFsdmVNb2RlKCk7XG4gICAgfVxuICAgIHdhcm5VcGRhdGVWYWx2ZU1vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlTWFuYWdlci5tb2RlICE9PSBcImxvb3BcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUGFydGljbGVHZW5lcmF0b3IgOiDjg6vjg7zjg5fmjIflrprkuK3jgavjg5Djg6vjg5bplovplonmk43kvZzjgpLooYzjgYTjgb7jgZfjgZ/jgILjgZPjga7mk43kvZzjga/jg6vjg7zjg5fmjIflrprkuK3jgavjga/lj43mmKDjgZXjgozjgb7jgZvjgpPjgIJcIik7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBSQUZUaWNrZXIgfSBmcm9tIFwiQG1hc2F0b21ha2luby9yYWYtdGlja2VyXCI7XG5pbXBvcnQgeyBQYXJ0aWNsZSB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgR2VuZXJhdGlvbk1vZGVNYW5hZ2VyLCB9IGZyb20gXCIuL0dlbmVyYXRpb25Nb2RlTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgTXVsdGlwbGVQYXJ0aWNsZVdheXMgfSBmcm9tIFwiLi9NdWx0aXBsZVBhcnRpY2xlV2F5cy5qc1wiO1xuaW1wb3J0IHsgUGFydGljbGVBbmltYXRvciB9IGZyb20gXCIuL1BhcnRpY2xlQW5pbWF0b3IuanNcIjtcbmltcG9ydCB7IFBhcnRpY2xlQ29udGFpbmVyIH0gZnJvbSBcIi4vUGFydGljbGVDb250YWluZXIuanNcIjtcbmltcG9ydCB7IFBhcnRpY2xlVmFsdmUgfSBmcm9tIFwiLi9QYXJ0aWNsZVZhbHZlLmpzXCI7XG4vKipcbiAqIOS4gOWumumWk+malOOBp+ODkeODvOODhuOCo+OCr+ODq+OCkueUn+aIkOOBl+OAgeOCouODi+ODoeODvOOCt+ODp+ODs+OBleOBm+OCi+OCr+ODqeOCueOAglxuICog44OR44O844OG44Kj44Kv44Or44Kk44Oz44K544K/44Oz44K544Gu55Sf5oiQ44Go566h55CG44KS6KGM44GG44CCXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNsZUdlbmVyYXRvciB7XG4gICAgZ2V0IGlzUGxheWluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICog44Kz44Oz44K544OI44Op44Kv44K/XG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKiBAcGFyYW0gb3B0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0aCwgb3B0aW9uKSB7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICog5YmN5Zue44OR44O844OG44Kj44Kv44Or55Sf5oiQ5pmC44GL44KJ44Gu57WM6YGO5pmC6ZaTIOWNmOS9jW1zXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXBzZWRGcm9tR2VuZXJhdGUgPSAwO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjgpLjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgZXjgZvjgovjgIJcbiAgICAgICAgICogQHBhcmFtIGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmFuaW1hdG9yLm1vdmUoZS5kZWx0YSk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlQ29udGFpbmVyLnJlbW92ZUNvbXBsZXRlZFBhcnRpY2xlcygpO1xuICAgICAgICAgICAgdGhpcy5hZGRQYXJ0aWNsZShlLmRlbHRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOODkeODvOODhuOCo+OCr+ODq+OCkuODq+ODvOODl+OCouODi+ODoeODvOOCt+ODp+ODs+OBleOBm+OCi+OAglxuICAgICAgICAgKiBAcGFyYW0gZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb29wID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlQ29udGFpbmVyLnBhcnRpY2xlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFuaW1hdG9yLm1vdmUoZS5kZWx0YSk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlQ29udGFpbmVyLnJvbGx1cFBhcnRpY2xlcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vZGVNYW5hZ2VyID0gbmV3IEdlbmVyYXRpb25Nb2RlTWFuYWdlcigpO1xuICAgICAgICB0aGlzLm11bHRpcGxlV2F5cyA9IG5ldyBNdWx0aXBsZVBhcnRpY2xlV2F5cyh7IHdheXM6IHBhdGggfSk7XG4gICAgICAgIHRoaXMucGFydGljbGVDb250YWluZXIgPSBuZXcgUGFydGljbGVDb250YWluZXIodGhpcy5tb2RlTWFuYWdlcik7XG4gICAgICAgIHRoaXMudmFsdmUgPSBuZXcgUGFydGljbGVWYWx2ZSh0aGlzLm1vZGVNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5hbmltYXRvciA9IG5ldyBQYXJ0aWNsZUFuaW1hdG9yKHRoaXMubW9kZU1hbmFnZXIsIHRoaXMucGFydGljbGVDb250YWluZXIpO1xuICAgICAgICB0aGlzLm1vZGVNYW5hZ2VyLm9uKFwiY2hhbmdlXCIsICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbiA9IFBhcnRpY2xlR2VuZXJhdG9yT3B0aW9uLmluaXRPcHRpb24ob3B0aW9uKTtcbiAgICAgICAgdGhpcy5tb2RlTWFuYWdlci5tb2RlID0gb3B0aW9uLmdlbmVyYXRpb25Nb2RlO1xuICAgICAgICB0aGlzLmFuaW1hdG9yLnVwZGF0ZUVhc2Uob3B0aW9uLmVhc2UpO1xuICAgICAgICB0aGlzLnByb2JhYmlsaXR5ID0gb3B0aW9uLnByb2JhYmlsaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLplovlp4vjgZnjgovjgIJcbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZU1hbmFnZXIubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcImxvb3BcIjpcbiAgICAgICAgICAgICAgICBSQUZUaWNrZXIuYWRkTGlzdGVuZXIoXCJ0aWNrXCIsIHRoaXMubG9vcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2VxdWVudGlhbFwiOlxuICAgICAgICAgICAgICAgIFJBRlRpY2tlci5hZGRMaXN0ZW5lcihcInRpY2tcIiwgdGhpcy5hbmltYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDjg5Hjg7zjg4bjgqPjgq/jg6vjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLlgZzmraLjgZnjgovjgIJcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIFJBRlRpY2tlci5yZW1vdmVMaXN0ZW5lcihcInRpY2tcIiwgdGhpcy5sb29wKTtcbiAgICAgICAgUkFGVGlja2VyLnJlbW92ZUxpc3RlbmVyKFwidGlja1wiLCB0aGlzLmFuaW1hdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgavkvLTjgYTjgIHmlrDopo/jg5Hjg7zjg4bjgqPjgq/jg6vjgpLov73liqDjgZnjgovjgIJcbiAgICAgKiBAcGFyYW0gZGVsdGFcbiAgICAgKi9cbiAgICBhZGRQYXJ0aWNsZShkZWx0YSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdmUuaXNPcGVuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRvcjtcbiAgICAgICAgdGhpcy5lbGFwc2VkRnJvbUdlbmVyYXRlICs9IGRlbHRhO1xuICAgICAgICB3aGlsZSAodGhpcy5lbGFwc2VkRnJvbUdlbmVyYXRlID4gYW5pbS5nZW5lcmF0aW9uSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZEZyb21HZW5lcmF0ZSAtPSBhbmltLmdlbmVyYXRpb25JbnRlcnZhbDtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSAodGhpcy5lbGFwc2VkRnJvbUdlbmVyYXRlICogYW5pbS5zcGVlZFBlclNlYykgLyAxMDAwO1xuICAgICAgICAgICAgLy/jgZnjgafjgavlr7/lkb3liIfjgozjga7jg5Hjg7zjg4bjgqPjgq/jg6vjga/nlJ/miJDjgpLjgrnjgq3jg4Pjg5fjgIJcbiAgICAgICAgICAgIGlmIChtb3ZlID4gUGFydGljbGUuTUFYX1JBVElPKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMuZ2VuZXJhdGUoKTtcbiAgICAgICAgICAgIHBhcnRpY2xlPy5hZGQobW92ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44KSMeOBpOi/veWKoOOBmeOCi+OAglxuICAgICAqL1xuICAgIGdlbmVyYXRlKCkge1xuICAgICAgICB0aGlzLm11bHRpcGxlV2F5cy5jb3VudFVwKCk7XG4gICAgICAgIC8v55m655Sf56K6546H44Gr5b+c44GY44Gm55Sf5oiQ44Gu5Y+v5ZCm44KS5Yik5a6a44GZ44KL44CCXG4gICAgICAgIGlmICh0aGlzLnByb2JhYmlsaXR5ICE9PSAxLjApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gdGhpcy5wcm9iYWJpbGl0eSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5tdWx0aXBsZVdheXMuZ2V0UGFydGljbGVXYXkoKTtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLmdlbmVyYXRlUGFydGljbGUocGF0aCk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdG9yLmVhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFydGljbGUuZWFzZSA9IHRoaXMuYW5pbWF0b3IuZWFzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpY2xlQ29udGFpbmVyLmFkZChwYXJ0aWNsZSk7XG4gICAgICAgIHJldHVybiBwYXJ0aWNsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog44OR44O844OG44Kj44Kv44Or44KS55Sf5oiQ44GZ44KL44CCXG4gICAgICogZ2VuZXJhdGXplqLmlbDjga7lhoXpg6jlh6bnkIbjgIJcbiAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAqL1xuICAgIGdlbmVyYXRlUGFydGljbGUocGF0aCkge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IG5ldyBQYXJ0aWNsZShwYXRoKTtcbiAgICAgICAgLy9UT0RPIOOBk+OBk+OBp+OCs+ODs+ODhuODiuOBq+aMv+WFpeOAglxuICAgICAgICByZXR1cm4gcGFydGljbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOe1jOi3r+S4iuOBq+ODkeODvOODhuOCo+OCr+ODq+OCkuaVt+OBjeipsOOCgeOCi+OAglxuICAgICAqL1xuICAgIGdlbmVyYXRlQWxsKCkge1xuICAgICAgICAvL+ODkeODvOODhuOCo+OCr+ODq+OBruacgOWkp+eUn+WtmOacn+mWkyDljZjkvY3jg5/jg6rnp5JcbiAgICAgICAgbGV0IGxpZmVUaW1lID0gMTAwMC4wIC8gdGhpcy5hbmltYXRvci5zcGVlZFBlclNlYztcbiAgICAgICAgd2hpbGUgKGxpZmVUaW1lID4gMC4wKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMuZ2VuZXJhdGUoKTtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZSlcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS51cGRhdGUoKGxpZmVUaW1lIC8gMTAwMCkgKiB0aGlzLmFuaW1hdG9yLnNwZWVkUGVyU2VjKTtcbiAgICAgICAgICAgIGxpZmVUaW1lIC09IHRoaXMuYW5pbWF0b3IuZ2VuZXJhdGlvbkludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxhcHNlZEZyb21HZW5lcmF0ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOODkeODvOODhuOCo+OCr+ODq+eUn+aIkOOBruWBnOatouOBqOODkeODvOODhuOCo+OCr+ODq+OBruegtOajhOOCkuihjOOBhuOAglxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUNvbnRhaW5lci5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMubXVsdGlwbGVXYXlzID0gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIOODkeODvOODhuOCo+OCr+ODq+eUn+aIkOaWueazleOCkuaMh+WumuOBmeOCi+OCquODl+OCt+ODp+ODs1xuICovXG5leHBvcnQgY2xhc3MgUGFydGljbGVHZW5lcmF0b3JPcHRpb24ge1xuICAgIHN0YXRpYyBpbml0T3B0aW9uKG9wdGlvbikge1xuICAgICAgICBvcHRpb24gPz89IHt9O1xuICAgICAgICBvcHRpb24uZ2VuZXJhdGlvbk1vZGUgPz89IFwic2VxdWVudGlhbFwiO1xuICAgICAgICBvcHRpb24ucHJvYmFiaWxpdHkgPz89IDEuMDtcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9QYXJ0aWNsZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vUGFydGljbGVXYXkuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0JlemllclV0aWwuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2dlbmVyYXRvci9QYXJ0aWNsZUdlbmVyYXRvci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZ2VuZXJhdG9yL011bHRpcGxlUGFydGljbGVXYXlzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9nZW5lcmF0b3IvUGFydGljbGVDb250YWluZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2dlbmVyYXRvci9HZW5lcmF0aW9uTW9kZU1hbmFnZXIuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2768\n')},1984:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZP: () => (/* binding */ exports)\n/* harmony export */ });\n/* unused harmony exports Easing, Group, Interpolation, Sequence, Tween, VERSION, add, getAll, nextId, now, remove, removeAll, update */\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\nvar Easing = Object.freeze({\n    Linear: Object.freeze({\n        None: function (amount) {\n            return amount;\n        },\n        In: function (amount) {\n            return this.None(amount);\n        },\n        Out: function (amount) {\n            return this.None(amount);\n        },\n        InOut: function (amount) {\n            return this.None(amount);\n        },\n    }),\n    Quadratic: Object.freeze({\n        In: function (amount) {\n            return amount * amount;\n        },\n        Out: function (amount) {\n            return amount * (2 - amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount;\n            }\n            return -0.5 * (--amount * (amount - 2) - 1);\n        },\n    }),\n    Cubic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount + 2);\n        },\n    }),\n    Quartic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return 1 - --amount * amount * amount * amount;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount;\n            }\n            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n        },\n    }),\n    Quintic: Object.freeze({\n        In: function (amount) {\n            return amount * amount * amount * amount * amount;\n        },\n        Out: function (amount) {\n            return --amount * amount * amount * amount * amount + 1;\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return 0.5 * amount * amount * amount * amount * amount;\n            }\n            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n        },\n    }),\n    Sinusoidal: Object.freeze({\n        In: function (amount) {\n            return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n        },\n        Out: function (amount) {\n            return Math.sin((amount * Math.PI) / 2);\n        },\n        InOut: function (amount) {\n            return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n        },\n    }),\n    Exponential: Object.freeze({\n        In: function (amount) {\n            return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n        },\n        Out: function (amount) {\n            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            if ((amount *= 2) < 1) {\n                return 0.5 * Math.pow(1024, amount - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n        },\n    }),\n    Circular: Object.freeze({\n        In: function (amount) {\n            return 1 - Math.sqrt(1 - amount * amount);\n        },\n        Out: function (amount) {\n            return Math.sqrt(1 - --amount * amount);\n        },\n        InOut: function (amount) {\n            if ((amount *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n        },\n    }),\n    Elastic: Object.freeze({\n        In: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n        },\n        Out: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n        },\n        InOut: function (amount) {\n            if (amount === 0) {\n                return 0;\n            }\n            if (amount === 1) {\n                return 1;\n            }\n            amount *= 2;\n            if (amount < 1) {\n                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n            }\n            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n        },\n    }),\n    Back: Object.freeze({\n        In: function (amount) {\n            var s = 1.70158;\n            return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n        },\n        Out: function (amount) {\n            var s = 1.70158;\n            return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;\n        },\n        InOut: function (amount) {\n            var s = 1.70158 * 1.525;\n            if ((amount *= 2) < 1) {\n                return 0.5 * (amount * amount * ((s + 1) * amount - s));\n            }\n            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n        },\n    }),\n    Bounce: Object.freeze({\n        In: function (amount) {\n            return 1 - Easing.Bounce.Out(1 - amount);\n        },\n        Out: function (amount) {\n            if (amount < 1 / 2.75) {\n                return 7.5625 * amount * amount;\n            }\n            else if (amount < 2 / 2.75) {\n                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n            }\n            else if (amount < 2.5 / 2.75) {\n                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n            }\n            else {\n                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n            }\n        },\n        InOut: function (amount) {\n            if (amount < 0.5) {\n                return Easing.Bounce.In(amount * 2) * 0.5;\n            }\n            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n        },\n    }),\n    generatePow: function (power) {\n        if (power === void 0) { power = 4; }\n        power = power < Number.EPSILON ? Number.EPSILON : power;\n        power = power > 10000 ? 10000 : power;\n        return {\n            In: function (amount) {\n                return Math.pow(amount, power);\n            },\n            Out: function (amount) {\n                return 1 - Math.pow((1 - amount), power);\n            },\n            InOut: function (amount) {\n                if (amount < 0.5) {\n                    return Math.pow((amount * 2), power) / 2;\n                }\n                return (1 - Math.pow((2 - amount * 2), power)) / 2 + 0.5;\n            },\n        };\n    },\n});\n\nvar now = function () { return performance.now(); };\n\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tween\n */\nvar Group = /** @class */ (function () {\n    function Group() {\n        this._tweens = {};\n        this._tweensAddedDuringUpdate = {};\n    }\n    Group.prototype.getAll = function () {\n        var _this = this;\n        return Object.keys(this._tweens).map(function (tweenId) {\n            return _this._tweens[tweenId];\n        });\n    };\n    Group.prototype.removeAll = function () {\n        this._tweens = {};\n    };\n    Group.prototype.add = function (tween) {\n        this._tweens[tween.getId()] = tween;\n        this._tweensAddedDuringUpdate[tween.getId()] = tween;\n    };\n    Group.prototype.remove = function (tween) {\n        delete this._tweens[tween.getId()];\n        delete this._tweensAddedDuringUpdate[tween.getId()];\n    };\n    Group.prototype.update = function (time, preserve) {\n        if (time === void 0) { time = now(); }\n        if (preserve === void 0) { preserve = false; }\n        var tweenIds = Object.keys(this._tweens);\n        if (tweenIds.length === 0) {\n            return false;\n        }\n        // Tweens are updated in \"batches\". If you add a new tween during an\n        // update, then the new tween will be updated in the next batch.\n        // If you remove a tween during an update, it may or may not be updated.\n        // However, if the removed tween was added during the current batch,\n        // then it will not be updated.\n        while (tweenIds.length > 0) {\n            this._tweensAddedDuringUpdate = {};\n            for (var i = 0; i < tweenIds.length; i++) {\n                var tween = this._tweens[tweenIds[i]];\n                var autoStart = !preserve;\n                if (tween && tween.update(time, autoStart) === false && !preserve) {\n                    delete this._tweens[tweenIds[i]];\n                }\n            }\n            tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n        }\n        return true;\n    };\n    return Group;\n}());\n\n/**\n *\n */\nvar Interpolation = {\n    Linear: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.Linear;\n        if (k < 0) {\n            return fn(v[0], v[1], f);\n        }\n        if (k > 1) {\n            return fn(v[m], v[m - 1], m - f);\n        }\n        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n    },\n    Bezier: function (v, k) {\n        var b = 0;\n        var n = v.length - 1;\n        var pw = Math.pow;\n        var bn = Interpolation.Utils.Bernstein;\n        for (var i = 0; i <= n; i++) {\n            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n        }\n        return b;\n    },\n    CatmullRom: function (v, k) {\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n        var fn = Interpolation.Utils.CatmullRom;\n        if (v[0] === v[m]) {\n            if (k < 0) {\n                i = Math.floor((f = m * (1 + k)));\n            }\n            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n        }\n        else {\n            if (k < 0) {\n                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n            if (k > 1) {\n                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n    },\n    Utils: {\n        Linear: function (p0, p1, t) {\n            return (p1 - p0) * t + p0;\n        },\n        Bernstein: function (n, i) {\n            var fc = Interpolation.Utils.Factorial;\n            return fc(n) / fc(i) / fc(n - i);\n        },\n        Factorial: (function () {\n            var a = [1];\n            return function (n) {\n                var s = 1;\n                if (a[n]) {\n                    return a[n];\n                }\n                for (var i = n; i > 1; i--) {\n                    s *= i;\n                }\n                a[n] = s;\n                return s;\n            };\n        })(),\n        CatmullRom: function (p0, p1, p2, p3, t) {\n            var v0 = (p2 - p0) * 0.5;\n            var v1 = (p3 - p1) * 0.5;\n            var t2 = t * t;\n            var t3 = t * t2;\n            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n        },\n    },\n};\n\n/**\n * Utils\n */\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n    }\n    Sequence.nextId = function () {\n        return Sequence._nextId++;\n    };\n    Sequence._nextId = 0;\n    return Sequence;\n}());\n\nvar mainGroup = new Group();\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar Tween = /** @class */ (function () {\n    function Tween(_object, _group) {\n        if (_group === void 0) { _group = mainGroup; }\n        this._object = _object;\n        this._group = _group;\n        this._isPaused = false;\n        this._pauseStart = 0;\n        this._valuesStart = {};\n        this._valuesEnd = {};\n        this._valuesStartRepeat = {};\n        this._duration = 1000;\n        this._isDynamic = false;\n        this._initialRepeat = 0;\n        this._repeat = 0;\n        this._yoyo = false;\n        this._isPlaying = false;\n        this._reversed = false;\n        this._delayTime = 0;\n        this._startTime = 0;\n        this._easingFunction = Easing.Linear.None;\n        this._interpolationFunction = Interpolation.Linear;\n        // eslint-disable-next-line\n        this._chainedTweens = [];\n        this._onStartCallbackFired = false;\n        this._onEveryStartCallbackFired = false;\n        this._id = Sequence.nextId();\n        this._isChainStopped = false;\n        this._propertiesAreSetUp = false;\n        this._goToEnd = false;\n    }\n    Tween.prototype.getId = function () {\n        return this._id;\n    };\n    Tween.prototype.isPlaying = function () {\n        return this._isPlaying;\n    };\n    Tween.prototype.isPaused = function () {\n        return this._isPaused;\n    };\n    Tween.prototype.getDuration = function () {\n        return this._duration;\n    };\n    Tween.prototype.to = function (target, duration) {\n        if (duration === void 0) { duration = 1000; }\n        if (this._isPlaying)\n            throw new Error('Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.');\n        this._valuesEnd = target;\n        this._propertiesAreSetUp = false;\n        this._duration = duration < 0 ? 0 : duration;\n        return this;\n    };\n    Tween.prototype.duration = function (duration) {\n        if (duration === void 0) { duration = 1000; }\n        this._duration = duration < 0 ? 0 : duration;\n        return this;\n    };\n    Tween.prototype.dynamic = function (dynamic) {\n        if (dynamic === void 0) { dynamic = false; }\n        this._isDynamic = dynamic;\n        return this;\n    };\n    Tween.prototype.start = function (time, overrideStartingValues) {\n        if (time === void 0) { time = now(); }\n        if (overrideStartingValues === void 0) { overrideStartingValues = false; }\n        if (this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        this._repeat = this._initialRepeat;\n        if (this._reversed) {\n            // If we were reversed (f.e. using the yoyo feature) then we need to\n            // flip the tween direction back to forward.\n            this._reversed = false;\n            for (var property in this._valuesStartRepeat) {\n                this._swapEndStartRepeatValues(property);\n                this._valuesStart[property] = this._valuesStartRepeat[property];\n            }\n        }\n        this._isPlaying = true;\n        this._isPaused = false;\n        this._onStartCallbackFired = false;\n        this._onEveryStartCallbackFired = false;\n        this._isChainStopped = false;\n        this._startTime = time;\n        this._startTime += this._delayTime;\n        if (!this._propertiesAreSetUp || overrideStartingValues) {\n            this._propertiesAreSetUp = true;\n            // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\n            if (!this._isDynamic) {\n                var tmp = {};\n                for (var prop in this._valuesEnd)\n                    tmp[prop] = this._valuesEnd[prop];\n                this._valuesEnd = tmp;\n            }\n            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);\n        }\n        return this;\n    };\n    Tween.prototype.startFromCurrentValues = function (time) {\n        return this.start(time, true);\n    };\n    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {\n        for (var property in _valuesEnd) {\n            var startValue = _object[property];\n            var startValueIsArray = Array.isArray(startValue);\n            var propType = startValueIsArray ? 'array' : typeof startValue;\n            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n            // If `to()` specifies a property that doesn't exist in the source object,\n            // we should not set that property in the object\n            if (propType === 'undefined' || propType === 'function') {\n                continue;\n            }\n            // Check if an Array was provided as property value\n            if (isInterpolationList) {\n                var endValues = _valuesEnd[property];\n                if (endValues.length === 0) {\n                    continue;\n                }\n                // Handle an array of relative values.\n                // Creates a local copy of the Array with the start value at the front\n                var temp = [startValue];\n                for (var i = 0, l = endValues.length; i < l; i += 1) {\n                    var value = this._handleRelativeValue(startValue, endValues[i]);\n                    if (isNaN(value)) {\n                        isInterpolationList = false;\n                        console.warn('Found invalid interpolation list. Skipping.');\n                        break;\n                    }\n                    temp.push(value);\n                }\n                if (isInterpolationList) {\n                    // if (_valuesStart[property] === undefined) { // handle end values only the first time. NOT NEEDED? setupProperties is now guarded by _propertiesAreSetUp.\n                    _valuesEnd[property] = temp;\n                    // }\n                }\n            }\n            // handle the deepness of the values\n            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {\n                _valuesStart[property] = startValueIsArray ? [] : {};\n                var nestedObject = startValue;\n                for (var prop in nestedObject) {\n                    _valuesStart[property][prop] = nestedObject[prop];\n                }\n                // TODO? repeat nested values? And yoyo? And array values?\n                _valuesStartRepeat[property] = startValueIsArray ? [] : {};\n                var endValues = _valuesEnd[property];\n                // If dynamic is not enabled, clone the end values instead of using the passed-in end values.\n                if (!this._isDynamic) {\n                    var tmp = {};\n                    for (var prop in endValues)\n                        tmp[prop] = endValues[prop];\n                    _valuesEnd[property] = endValues = tmp;\n                }\n                this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);\n            }\n            else {\n                // Save the starting value, but only once unless override is requested.\n                if (typeof _valuesStart[property] === 'undefined' || overrideStartingValues) {\n                    _valuesStart[property] = startValue;\n                }\n                if (!startValueIsArray) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n                }\n                if (isInterpolationList) {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n                }\n                else {\n                    _valuesStartRepeat[property] = _valuesStart[property] || 0;\n                }\n            }\n        }\n    };\n    Tween.prototype.stop = function () {\n        if (!this._isChainStopped) {\n            this._isChainStopped = true;\n            this.stopChainedTweens();\n        }\n        if (!this._isPlaying) {\n            return this;\n        }\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        this._isPlaying = false;\n        this._isPaused = false;\n        if (this._onStopCallback) {\n            this._onStopCallback(this._object);\n        }\n        return this;\n    };\n    Tween.prototype.end = function () {\n        this._goToEnd = true;\n        this.update(Infinity);\n        return this;\n    };\n    Tween.prototype.pause = function (time) {\n        if (time === void 0) { time = now(); }\n        if (this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = true;\n        this._pauseStart = time;\n        // eslint-disable-next-line\n        this._group && this._group.remove(this);\n        return this;\n    };\n    Tween.prototype.resume = function (time) {\n        if (time === void 0) { time = now(); }\n        if (!this._isPaused || !this._isPlaying) {\n            return this;\n        }\n        this._isPaused = false;\n        this._startTime += time - this._pauseStart;\n        this._pauseStart = 0;\n        // eslint-disable-next-line\n        this._group && this._group.add(this);\n        return this;\n    };\n    Tween.prototype.stopChainedTweens = function () {\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n            this._chainedTweens[i].stop();\n        }\n        return this;\n    };\n    Tween.prototype.group = function (group) {\n        if (group === void 0) { group = mainGroup; }\n        this._group = group;\n        return this;\n    };\n    Tween.prototype.delay = function (amount) {\n        if (amount === void 0) { amount = 0; }\n        this._delayTime = amount;\n        return this;\n    };\n    Tween.prototype.repeat = function (times) {\n        if (times === void 0) { times = 0; }\n        this._initialRepeat = times;\n        this._repeat = times;\n        return this;\n    };\n    Tween.prototype.repeatDelay = function (amount) {\n        this._repeatDelayTime = amount;\n        return this;\n    };\n    Tween.prototype.yoyo = function (yoyo) {\n        if (yoyo === void 0) { yoyo = false; }\n        this._yoyo = yoyo;\n        return this;\n    };\n    Tween.prototype.easing = function (easingFunction) {\n        if (easingFunction === void 0) { easingFunction = Easing.Linear.None; }\n        this._easingFunction = easingFunction;\n        return this;\n    };\n    Tween.prototype.interpolation = function (interpolationFunction) {\n        if (interpolationFunction === void 0) { interpolationFunction = Interpolation.Linear; }\n        this._interpolationFunction = interpolationFunction;\n        return this;\n    };\n    // eslint-disable-next-line\n    Tween.prototype.chain = function () {\n        var tweens = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            tweens[_i] = arguments[_i];\n        }\n        this._chainedTweens = tweens;\n        return this;\n    };\n    Tween.prototype.onStart = function (callback) {\n        this._onStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onEveryStart = function (callback) {\n        this._onEveryStartCallback = callback;\n        return this;\n    };\n    Tween.prototype.onUpdate = function (callback) {\n        this._onUpdateCallback = callback;\n        return this;\n    };\n    Tween.prototype.onRepeat = function (callback) {\n        this._onRepeatCallback = callback;\n        return this;\n    };\n    Tween.prototype.onComplete = function (callback) {\n        this._onCompleteCallback = callback;\n        return this;\n    };\n    Tween.prototype.onStop = function (callback) {\n        this._onStopCallback = callback;\n        return this;\n    };\n    /**\n     * @returns true if the tween is still playing after the update, false\n     * otherwise (calling update on a paused tween still returns true because\n     * it is still playing, just paused).\n     */\n    Tween.prototype.update = function (time, autoStart) {\n        var _this = this;\n        var _a;\n        if (time === void 0) { time = now(); }\n        if (autoStart === void 0) { autoStart = true; }\n        if (this._isPaused)\n            return true;\n        var property;\n        var endTime = this._startTime + this._duration;\n        if (!this._goToEnd && !this._isPlaying) {\n            if (time > endTime)\n                return false;\n            if (autoStart)\n                this.start(time, true);\n        }\n        this._goToEnd = false;\n        if (time < this._startTime) {\n            return true;\n        }\n        if (this._onStartCallbackFired === false) {\n            if (this._onStartCallback) {\n                this._onStartCallback(this._object);\n            }\n            this._onStartCallbackFired = true;\n        }\n        if (this._onEveryStartCallbackFired === false) {\n            if (this._onEveryStartCallback) {\n                this._onEveryStartCallback(this._object);\n            }\n            this._onEveryStartCallbackFired = true;\n        }\n        var elapsedTime = time - this._startTime;\n        var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);\n        var totalTime = this._duration + this._repeat * durationAndDelay;\n        var calculateElapsedPortion = function () {\n            if (_this._duration === 0)\n                return 1;\n            if (elapsedTime > totalTime) {\n                return 1;\n            }\n            var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);\n            var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;\n            // TODO use %?\n            // const timeIntoCurrentRepeat = elapsedTime % durationAndDelay\n            var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);\n            if (portion === 0 && elapsedTime === _this._duration) {\n                return 1;\n            }\n            return portion;\n        };\n        var elapsed = calculateElapsedPortion();\n        var value = this._easingFunction(elapsed);\n        // properties transformations\n        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);\n        if (this._onUpdateCallback) {\n            this._onUpdateCallback(this._object, elapsed);\n        }\n        if (this._duration === 0 || elapsedTime >= this._duration) {\n            if (this._repeat > 0) {\n                var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);\n                if (isFinite(this._repeat)) {\n                    this._repeat -= completeCount;\n                }\n                // Reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat) {\n                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {\n                        this._valuesStartRepeat[property] =\n                            // eslint-disable-next-line\n                            // @ts-ignore FIXME?\n                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n                    }\n                    if (this._yoyo) {\n                        this._swapEndStartRepeatValues(property);\n                    }\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n                if (this._yoyo) {\n                    this._reversed = !this._reversed;\n                }\n                this._startTime += durationAndDelay * completeCount;\n                if (this._onRepeatCallback) {\n                    this._onRepeatCallback(this._object);\n                }\n                this._onEveryStartCallbackFired = false;\n                return true;\n            }\n            else {\n                if (this._onCompleteCallback) {\n                    this._onCompleteCallback(this._object);\n                }\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n                    // Make the chained tweens start exactly at the time they should,\n                    // even if the `update()` method was called way past the duration of the tween\n                    this._chainedTweens[i].start(this._startTime + this._duration, false);\n                }\n                this._isPlaying = false;\n                return false;\n            }\n        }\n        return true;\n    };\n    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {\n        for (var property in _valuesEnd) {\n            // Don't update properties that do not exist in the source object\n            if (_valuesStart[property] === undefined) {\n                continue;\n            }\n            var start = _valuesStart[property] || 0;\n            var end = _valuesEnd[property];\n            var startIsArray = Array.isArray(_object[property]);\n            var endIsArray = Array.isArray(end);\n            var isInterpolationList = !startIsArray && endIsArray;\n            if (isInterpolationList) {\n                _object[property] = this._interpolationFunction(end, value);\n            }\n            else if (typeof end === 'object' && end) {\n                // eslint-disable-next-line\n                // @ts-ignore FIXME?\n                this._updateProperties(_object[property], start, end, value);\n            }\n            else {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                end = this._handleRelativeValue(start, end);\n                // Protect against non numeric properties.\n                if (typeof end === 'number') {\n                    // eslint-disable-next-line\n                    // @ts-ignore FIXME?\n                    _object[property] = start + (end - start) * value;\n                }\n            }\n        }\n    };\n    Tween.prototype._handleRelativeValue = function (start, end) {\n        if (typeof end !== 'string') {\n            return end;\n        }\n        if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            return start + parseFloat(end);\n        }\n        return parseFloat(end);\n    };\n    Tween.prototype._swapEndStartRepeatValues = function (property) {\n        var tmp = this._valuesStartRepeat[property];\n        var endValue = this._valuesEnd[property];\n        if (typeof endValue === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n        }\n        else {\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n        }\n        this._valuesEnd[property] = tmp;\n    };\n    return Tween;\n}());\n\nvar VERSION = '23.1.1';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\nvar nextId = Sequence.nextId;\n/**\n * Controlling groups of tweens\n *\n * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.\n * In these cases, you may want to create your own smaller groups of tweens.\n */\nvar TWEEN = mainGroup;\n// This is the best way to export things in a way that's compatible with both ES\n// Modules and CommonJS, without build hacks, and so as not to break the\n// existing API.\n// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881\nvar getAll = TWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nvar add = TWEEN.add.bind(TWEEN);\nvar remove = TWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nvar exports = {\n    Easing: Easing,\n    Group: Group,\n    Interpolation: Interpolation,\n    now: now,\n    Sequence: Sequence,\n    nextId: nextId,\n    Tween: Tween,\n    VERSION: VERSION,\n    getAll: getAll,\n    removeAll: removeAll,\n    add: add,\n    remove: remove,\n    update: update,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4NC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUySSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL0B0d2VlbmpzL3R3ZWVuLmpzL2Rpc3QvdHdlZW4uZXNtLmpzPzEwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgRWFzZSBjbGFzcyBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgZWFzaW5nIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggdHdlZW4uanMuXG4gKi9cbnZhciBFYXNpbmcgPSBPYmplY3QuZnJlZXplKHtcbiAgICBMaW5lYXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBOb25lOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTm9uZShhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk5vbmUoYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk5vbmUoYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBRdWFkcmF0aWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogKDIgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tYW1vdW50ICogKGFtb3VudCAtIDIpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgQ3ViaWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIFF1YXJ0aWM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgLSAyKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBRdWludGljOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBTaW51c29pZGFsOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zaW4oKCgxLjAgLSBhbW91bnQpICogTWF0aC5QSSkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oKGFtb3VudCAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLnNpbihNYXRoLlBJICogKDAuNSAtIGFtb3VudCkpKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBFeHBvbmVudGlhbDogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGFtb3VudCAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgYW1vdW50IC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoYW1vdW50IC0gMSkpICsgMik7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgQ2lyY3VsYXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGFtb3VudCAqIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS1hbW91bnQgKiBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBhbW91bnQgKiBhbW91bnQpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGFtb3VudCAtPSAyKSAqIGFtb3VudCkgKyAxKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBFbGFzdGljOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgMTAgKiAoYW1vdW50IC0gMSkpICogTWF0aC5zaW4oKGFtb3VudCAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMCAqIGFtb3VudCkgKiBNYXRoLnNpbigoYW1vdW50IC0gMC4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbW91bnQgKj0gMjtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiBNYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAtMTAgKiAoYW1vdW50IC0gMSkpICogTWF0aC5zaW4oKGFtb3VudCAtIDEuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuICAgICAgICB9LFxuICAgIH0pLFxuICAgIEJhY2s6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMSA/IDEgOiBhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyAwIDogLS1hbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBCb3VuY2U6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBFYXNpbmcuQm91bmNlLk91dCgxIC0gYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYW1vdW50IDwgMiAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAxLjUgLyAyLjc1KSAqIGFtb3VudCArIDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMi4yNSAvIDIuNzUpICogYW1vdW50ICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMi42MjUgLyAyLjc1KSAqIGFtb3VudCArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFYXNpbmcuQm91bmNlLkluKGFtb3VudCAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuT3V0KGFtb3VudCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBnZW5lcmF0ZVBvdzogZnVuY3Rpb24gKHBvd2VyKSB7XG4gICAgICAgIGlmIChwb3dlciA9PT0gdm9pZCAwKSB7IHBvd2VyID0gNDsgfVxuICAgICAgICBwb3dlciA9IHBvd2VyIDwgTnVtYmVyLkVQU0lMT04gPyBOdW1iZXIuRVBTSUxPTiA6IHBvd2VyO1xuICAgICAgICBwb3dlciA9IHBvd2VyID4gMTAwMDAgPyAxMDAwMCA6IHBvd2VyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coYW1vdW50LCBwb3dlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdygoMSAtIGFtb3VudCksIHBvd2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChhbW91bnQgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KChhbW91bnQgKiAyKSwgcG93ZXIpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgxIC0gTWF0aC5wb3coKDIgLSBhbW91bnQgKiAyKSwgcG93ZXIpKSAvIDIgKyAwLjU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpOyB9O1xuXG4vKipcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcbiAqXG4gKiBVc2luZyB0aGUgVFdFRU4gc2luZ2xldG9uIHRvIG1hbmFnZSB5b3VyIHR3ZWVucyBjYW4gY2F1c2UgaXNzdWVzIGluIGxhcmdlIGFwcHMgd2l0aCBtYW55IGNvbXBvbmVudHMuXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlblxuICovXG52YXIgR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICAgICAgICB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZSA9IHt9O1xuICAgIH1cbiAgICBHcm91cC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKS5tYXAoZnVuY3Rpb24gKHR3ZWVuSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdHdlZW5zW3R3ZWVuSWRdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbi5nZXRJZCgpXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xuICAgIH07XG4gICAgR3JvdXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBwcmVzZXJ2ZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxuICAgICAgICBpZiAocHJlc2VydmUgPT09IHZvaWQgMCkgeyBwcmVzZXJ2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucyk7XG4gICAgICAgIGlmICh0d2Vlbklkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUd2VlbnMgYXJlIHVwZGF0ZWQgaW4gXCJiYXRjaGVzXCIuIElmIHlvdSBhZGQgYSBuZXcgdHdlZW4gZHVyaW5nIGFuXG4gICAgICAgIC8vIHVwZGF0ZSwgdGhlbiB0aGUgbmV3IHR3ZWVuIHdpbGwgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCBiYXRjaC5cbiAgICAgICAgLy8gSWYgeW91IHJlbW92ZSBhIHR3ZWVuIGR1cmluZyBhbiB1cGRhdGUsIGl0IG1heSBvciBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSByZW1vdmVkIHR3ZWVuIHdhcyBhZGRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2gsXG4gICAgICAgIC8vIHRoZW4gaXQgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICAgICAgd2hpbGUgKHR3ZWVuSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVuSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW3R3ZWVuSWRzW2ldXTtcbiAgICAgICAgICAgICAgICB2YXIgYXV0b1N0YXJ0ID0gIXByZXNlcnZlO1xuICAgICAgICAgICAgICAgIGlmICh0d2VlbiAmJiB0d2Vlbi51cGRhdGUodGltZSwgYXV0b1N0YXJ0KSA9PT0gZmFsc2UgJiYgIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwO1xufSgpKTtcblxuLyoqXG4gKlxuICovXG52YXIgSW50ZXJwb2xhdGlvbiA9IHtcbiAgICBMaW5lYXI6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZiA9IG0gKiBrO1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG4gICAgICAgIHZhciBmbiA9IEludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xuICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbih2WzBdLCB2WzFdLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih2W21dLCB2W20gLSAxXSwgbSAtIGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbih2W2ldLCB2W2kgKyAxID4gbSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcbiAgICB9LFxuICAgIEJlemllcjogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIGIgPSAwO1xuICAgICAgICB2YXIgbiA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHB3ID0gTWF0aC5wb3c7XG4gICAgICAgIHZhciBibiA9IEludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgIGIgKz0gcHcoMSAtIGssIG4gLSBpKSAqIHB3KGssIGkpICogdltpXSAqIGJuKG4sIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmID0gbSAqIGs7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGZuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5DYXRtdWxsUm9tO1xuICAgICAgICBpZiAodlswXSA9PT0gdlttXSkge1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgaSA9IE1hdGguZmxvb3IoKGYgPSBtICogKDEgKyBrKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdlswXSAtIChmbih2WzBdLCB2WzBdLCB2WzFdLCB2WzFdLCAtZikgLSB2WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2W21dIC0gKGZuKHZbbV0sIHZbbV0sIHZbbSAtIDFdLCB2W20gLSAxXSwgZiAtIG0pIC0gdlttXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgVXRpbHM6IHtcbiAgICAgICAgTGluZWFyOiBmdW5jdGlvbiAocDAsIHAxLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB9LFxuICAgICAgICBCZXJuc3RlaW46IGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICB2YXIgZmMgPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkZhY3RvcmlhbDtcbiAgICAgICAgICAgIHJldHVybiBmYyhuKSAvIGZjKGkpIC8gZmMobiAtIGkpO1xuICAgICAgICB9LFxuICAgICAgICBGYWN0b3JpYWw6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFsxXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHZhciBzID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoYVtuXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcyAqPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhW25dID0gcztcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCksXG4gICAgICAgIENhdG11bGxSb206IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICAgICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICB2YXIgdDMgPSB0ICogdDI7XG4gICAgICAgICAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIFNlcXVlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlKCkge1xuICAgIH1cbiAgICBTZXF1ZW5jZS5uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTZXF1ZW5jZS5fbmV4dElkKys7XG4gICAgfTtcbiAgICBTZXF1ZW5jZS5fbmV4dElkID0gMDtcbiAgICByZXR1cm4gU2VxdWVuY2U7XG59KCkpO1xuXG52YXIgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cbnZhciBUd2VlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUd2Vlbihfb2JqZWN0LCBfZ3JvdXApIHtcbiAgICAgICAgaWYgKF9ncm91cCA9PT0gdm9pZCAwKSB7IF9ncm91cCA9IG1haW5Hcm91cDsgfVxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgICAgICB0aGlzLl9ncm91cCA9IF9ncm91cDtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0ID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDEwMDA7XG4gICAgICAgIHRoaXMuX2lzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsUmVwZWF0ID0gMDtcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gMDtcbiAgICAgICAgdGhpcy5feW95byA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5fZWFzaW5nRnVuY3Rpb24gPSBFYXNpbmcuTGluZWFyLk5vbmU7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IEludGVycG9sYXRpb24uTGluZWFyO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkID0gU2VxdWVuY2UubmV4dElkKCk7XG4gICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXNBcmVTZXRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIFR3ZWVuLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGF1c2VkO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkgeyBkdXJhdGlvbiA9IDEwMDA7IH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBjYWxsIFR3ZWVuLnRvKCkgd2hpbGUgVHdlZW4gaXMgYWxyZWFkeSBzdGFydGVkIG9yIHBhdXNlZC4gU3RvcCB0aGUgVHdlZW4gZmlyc3QuJyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0FyZVNldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gPCAwID8gMCA6IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkgeyBkdXJhdGlvbiA9IDEwMDA7IH1cbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiA8IDAgPyAwIDogZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmR5bmFtaWMgPSBmdW5jdGlvbiAoZHluYW1pYykge1xuICAgICAgICBpZiAoZHluYW1pYyA9PT0gdm9pZCAwKSB7IGR5bmFtaWMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLl9pc0R5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XG4gICAgICAgIGlmIChvdmVycmlkZVN0YXJ0aW5nVmFsdWVzID09PSB2b2lkIDApIHsgb3ZlcnJpZGVTdGFydGluZ1ZhbHVlcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5hZGQodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHRoaXMuX2luaXRpYWxSZXBlYXQ7XG4gICAgICAgIGlmICh0aGlzLl9yZXZlcnNlZCkge1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSByZXZlcnNlZCAoZi5lLiB1c2luZyB0aGUgeW95byBmZWF0dXJlKSB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGZsaXAgdGhlIHR3ZWVuIGRpcmVjdGlvbiBiYWNrIHRvIGZvcndhcmQuXG4gICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwRW5kU3RhcnRSZXBlYXRWYWx1ZXMocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSArPSB0aGlzLl9kZWxheVRpbWU7XG4gICAgICAgIGlmICghdGhpcy5fcHJvcGVydGllc0FyZVNldFVwIHx8IG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNBcmVTZXRVcCA9IHRydWU7XG4gICAgICAgICAgICAvLyBJZiBkeW5hbWljIGlzIG5vdCBlbmFibGVkLCBjbG9uZSB0aGUgZW5kIHZhbHVlcyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXNzZWQtaW4gZW5kIHZhbHVlcy5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fdmFsdWVzRW5kKVxuICAgICAgICAgICAgICAgICAgICB0bXBbcHJvcF0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcF07XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0dXBQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQsIG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnN0YXJ0RnJvbUN1cnJlbnRWYWx1ZXMgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCh0aW1lLCB0cnVlKTtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fc2V0dXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKF9vYmplY3QsIF92YWx1ZXNTdGFydCwgX3ZhbHVlc0VuZCwgX3ZhbHVlc1N0YXJ0UmVwZWF0LCBvdmVycmlkZVN0YXJ0aW5nVmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gX29iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgc3RhcnRWYWx1ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyAnYXJyYXknIDogdHlwZW9mIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uTGlzdCA9ICFzdGFydFZhbHVlSXNBcnJheSAmJiBBcnJheS5pc0FycmF5KF92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIC8vIElmIGB0bygpYCBzcGVjaWZpZXMgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3QsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgbm90IHNldCB0aGF0IHByb3BlcnR5IGluIHRoZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChwcm9wVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFuIEFycmF5IHdhcyBwcm92aWRlZCBhcyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWVzID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhbiBhcnJheSBvZiByZWxhdGl2ZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhIGxvY2FsIGNvcHkgb2YgdGhlIEFycmF5IHdpdGggdGhlIHN0YXJ0IHZhbHVlIGF0IHRoZSBmcm9udFxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gW3N0YXJ0VmFsdWVdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZW5kVmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oYW5kbGVSZWxhdGl2ZVZhbHVlKHN0YXJ0VmFsdWUsIGVuZFZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW50ZXJwb2xhdGlvbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRm91bmQgaW52YWxpZCBpbnRlcnBvbGF0aW9uIGxpc3QuIFNraXBwaW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkgeyAvLyBoYW5kbGUgZW5kIHZhbHVlcyBvbmx5IHRoZSBmaXJzdCB0aW1lLiBOT1QgTkVFREVEPyBzZXR1cFByb3BlcnRpZXMgaXMgbm93IGd1YXJkZWQgYnkgX3Byb3BlcnRpZXNBcmVTZXRVcC5cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBkZWVwbmVzcyBvZiB0aGUgdmFsdWVzXG4gICAgICAgICAgICBpZiAoKHByb3BUeXBlID09PSAnb2JqZWN0JyB8fCBzdGFydFZhbHVlSXNBcnJheSkgJiYgc3RhcnRWYWx1ZSAmJiAhaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlSXNBcnJheSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZE9iamVjdCA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBuZXN0ZWRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XVtwcm9wXSA9IG5lc3RlZE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETz8gcmVwZWF0IG5lc3RlZCB2YWx1ZXM/IEFuZCB5b3lvPyBBbmQgYXJyYXkgdmFsdWVzP1xuICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBzdGFydFZhbHVlSXNBcnJheSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgdmFyIGVuZFZhbHVlcyA9IF92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIC8vIElmIGR5bmFtaWMgaXMgbm90IGVuYWJsZWQsIGNsb25lIHRoZSBlbmQgdmFsdWVzIGluc3RlYWQgb2YgdXNpbmcgdGhlIHBhc3NlZC1pbiBlbmQgdmFsdWVzLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBlbmRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBbcHJvcF0gPSBlbmRWYWx1ZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNFbmRbcHJvcGVydHldID0gZW5kVmFsdWVzID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXMobmVzdGVkT2JqZWN0LCBfdmFsdWVzU3RhcnRbcHJvcGVydHldLCBlbmRWYWx1ZXMsIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0sIG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUsIGJ1dCBvbmx5IG9uY2UgdW5sZXNzIG92ZXJyaWRlIGlzIHJlcXVlc3RlZC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPT09ICd1bmRlZmluZWQnIHx8IG92ZXJyaWRlU3RhcnRpbmdWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3RhcnRWYWx1ZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gKj0gMS4wOyAvLyBFbnN1cmVzIHdlJ3JlIHVzaW5nIG51bWJlcnMsIG5vdCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV0uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNDaGFpblN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcENoYWluZWRUd2VlbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9vblN0b3BDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25TdG9wQ2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZShJbmZpbml0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93KCk7IH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IHRpbWU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdygpOyB9XG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRpbWUgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RvcENoYWluZWRUd2VlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnNbaV0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCA9PT0gdm9pZCAwKSB7IGdyb3VwID0gbWFpbkdyb3VwOyB9XG4gICAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHsgYW1vdW50ID0gMDsgfVxuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICBpZiAodGltZXMgPT09IHZvaWQgMCkgeyB0aW1lcyA9IDA7IH1cbiAgICAgICAgdGhpcy5faW5pdGlhbFJlcGVhdCA9IHRpbWVzO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aW1lcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX3JlcGVhdERlbGF5VGltZSA9IGFtb3VudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUueW95byA9IGZ1bmN0aW9uICh5b3lvKSB7XG4gICAgICAgIGlmICh5b3lvID09PSB2b2lkIDApIHsgeW95byA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX3lveW8gPSB5b3lvO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5lYXNpbmcgPSBmdW5jdGlvbiAoZWFzaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKGVhc2luZ0Z1bmN0aW9uID09PSB2b2lkIDApIHsgZWFzaW5nRnVuY3Rpb24gPSBFYXNpbmcuTGluZWFyLk5vbmU7IH1cbiAgICAgICAgdGhpcy5fZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmdGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuaW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25GdW5jdGlvbiA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25GdW5jdGlvbiA9IEludGVycG9sYXRpb24uTGluZWFyOyB9XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb25GdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBUd2Vlbi5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnMgPSB0d2VlbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uRXZlcnlTdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdlZW4gaXMgc3RpbGwgcGxheWluZyBhZnRlciB0aGUgdXBkYXRlLCBmYWxzZVxuICAgICAqIG90aGVyd2lzZSAoY2FsbGluZyB1cGRhdGUgb24gYSBwYXVzZWQgdHdlZW4gc3RpbGwgcmV0dXJucyB0cnVlIGJlY2F1c2VcbiAgICAgKiBpdCBpcyBzdGlsbCBwbGF5aW5nLCBqdXN0IHBhdXNlZCkuXG4gICAgICovXG4gICAgVHdlZW4ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBhdXRvU3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3coKTsgfVxuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB2b2lkIDApIHsgYXV0b1N0YXJ0ID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3BlcnR5O1xuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuX2dvVG9FbmQgJiYgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiBlbmRUaW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRvU3RhcnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCh0aW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nb1RvRW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkV2ZXJ5U3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25FdmVyeVN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gdGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgdmFyIGR1cmF0aW9uQW5kRGVsYXkgPSB0aGlzLl9kdXJhdGlvbiArICgoX2EgPSB0aGlzLl9yZXBlYXREZWxheVRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2RlbGF5VGltZSk7XG4gICAgICAgIHZhciB0b3RhbFRpbWUgPSB0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdCAqIGR1cmF0aW9uQW5kRGVsYXk7XG4gICAgICAgIHZhciBjYWxjdWxhdGVFbGFwc2VkUG9ydGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZFRpbWUgPiB0b3RhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aW1lc1JlcGVhdGVkID0gTWF0aC50cnVuYyhlbGFwc2VkVGltZSAvIGR1cmF0aW9uQW5kRGVsYXkpO1xuICAgICAgICAgICAgdmFyIHRpbWVJbnRvQ3VycmVudFJlcGVhdCA9IGVsYXBzZWRUaW1lIC0gdGltZXNSZXBlYXRlZCAqIGR1cmF0aW9uQW5kRGVsYXk7XG4gICAgICAgICAgICAvLyBUT0RPIHVzZSAlP1xuICAgICAgICAgICAgLy8gY29uc3QgdGltZUludG9DdXJyZW50UmVwZWF0ID0gZWxhcHNlZFRpbWUgJSBkdXJhdGlvbkFuZERlbGF5XG4gICAgICAgICAgICB2YXIgcG9ydGlvbiA9IE1hdGgubWluKHRpbWVJbnRvQ3VycmVudFJlcGVhdCAvIF90aGlzLl9kdXJhdGlvbiwgMSk7XG4gICAgICAgICAgICBpZiAocG9ydGlvbiA9PT0gMCAmJiBlbGFwc2VkVGltZSA9PT0gX3RoaXMuX2R1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9ydGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSBjYWxjdWxhdGVFbGFwc2VkUG9ydGlvbigpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9lYXNpbmdGdW5jdGlvbihlbGFwc2VkKTtcbiAgICAgICAgLy8gcHJvcGVydGllcyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvcGVydGllcyh0aGlzLl9vYmplY3QsIHRoaXMuX3ZhbHVlc1N0YXJ0LCB0aGlzLl92YWx1ZXNFbmQsIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuX29uVXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uVXBkYXRlQ2FsbGJhY2sodGhpcy5fb2JqZWN0LCBlbGFwc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZHVyYXRpb24gPT09IDAgfHwgZWxhcHNlZFRpbWUgPj0gdGhpcy5fZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlQ291bnQgPSBNYXRoLm1pbihNYXRoLnRydW5jKChlbGFwc2VkVGltZSAtIHRoaXMuX2R1cmF0aW9uKSAvIGR1cmF0aW9uQW5kRGVsYXkpICsgMSwgdGhpcy5fcmVwZWF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUodGhpcy5fcmVwZWF0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQgLT0gY29tcGxldGVDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVhc3NpZ24gc3RhcnRpbmcgdmFsdWVzLCByZXN0YXJ0IGJ5IG1ha2luZyBzdGFydFRpbWUgPSBub3dcbiAgICAgICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5feW95byAmJiB0eXBlb2YgdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gKyBwYXJzZUZsb2F0KHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl95b3lvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zd2FwRW5kU3RhcnRSZXBlYXRWYWx1ZXMocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSAhdGhpcy5fcmV2ZXJzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSArPSBkdXJhdGlvbkFuZERlbGF5ICogY29tcGxldGVDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25SZXBlYXRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlcGVhdENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uRXZlcnlTdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2hhaW5lZCB0d2VlbnMgc3RhcnQgZXhhY3RseSBhdCB0aGUgdGltZSB0aGV5IHNob3VsZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgYHVwZGF0ZSgpYCBtZXRob2Qgd2FzIGNhbGxlZCB3YXkgcGFzdCB0aGUgZHVyYXRpb24gb2YgdGhlIHR3ZWVuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnNbaV0uc3RhcnQodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fZHVyYXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl91cGRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKF9vYmplY3QsIF92YWx1ZXNTdGFydCwgX3ZhbHVlc0VuZCwgdmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHByb3BlcnRpZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydCA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgICAgICAgIHZhciBlbmQgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciBzdGFydElzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9vYmplY3RbcHJvcGVydHldKTtcbiAgICAgICAgICAgIHZhciBlbmRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShlbmQpO1xuICAgICAgICAgICAgdmFyIGlzSW50ZXJwb2xhdGlvbkxpc3QgPSAhc3RhcnRJc0FycmF5ICYmIGVuZElzQXJyYXk7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcnBvbGF0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGVuZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ29iamVjdCcgJiYgZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKF9vYmplY3RbcHJvcGVydHldLCBzdGFydCwgZW5kLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5faGFuZGxlUmVsYXRpdmVWYWx1ZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm9uIG51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX2hhbmRsZVJlbGF0aXZlVmFsdWUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5jaGFyQXQoMCkgPT09ICcrJyB8fCBlbmQuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydCArIHBhcnNlRmxvYXQoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbmQpO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl9zd2FwRW5kU3RhcnRSZXBlYXRWYWx1ZXMgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcbiAgICAgICAgdmFyIGVuZFZhbHVlID0gdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSArIHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID0gdG1wO1xuICAgIH07XG4gICAgcmV0dXJuIFR3ZWVuO1xufSgpKTtcblxudmFyIFZFUlNJT04gPSAnMjMuMS4xJztcblxuLyoqXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3ZWVuanMvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gKiBUaGFuayB5b3UgYWxsLCB5b3UncmUgYXdlc29tZSFcbiAqL1xudmFyIG5leHRJZCA9IFNlcXVlbmNlLm5leHRJZDtcbi8qKlxuICogQ29udHJvbGxpbmcgZ3JvdXBzIG9mIHR3ZWVuc1xuICpcbiAqIFVzaW5nIHRoZSBUV0VFTiBzaW5nbGV0b24gdG8gbWFuYWdlIHlvdXIgdHdlZW5zIGNhbiBjYXVzZSBpc3N1ZXMgaW4gbGFyZ2UgYXBwcyB3aXRoIG1hbnkgY29tcG9uZW50cy5cbiAqIEluIHRoZXNlIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gY3JlYXRlIHlvdXIgb3duIHNtYWxsZXIgZ3JvdXBzIG9mIHR3ZWVucy5cbiAqL1xudmFyIFRXRUVOID0gbWFpbkdyb3VwO1xuLy8gVGhpcyBpcyB0aGUgYmVzdCB3YXkgdG8gZXhwb3J0IHRoaW5ncyBpbiBhIHdheSB0aGF0J3MgY29tcGF0aWJsZSB3aXRoIGJvdGggRVNcbi8vIE1vZHVsZXMgYW5kIENvbW1vbkpTLCB3aXRob3V0IGJ1aWxkIGhhY2tzLCBhbmQgc28gYXMgbm90IHRvIGJyZWFrIHRoZVxuLy8gZXhpc3RpbmcgQVBJLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE5NjEjaXNzdWVjb21tZW50LTQyMzAzNzg4MVxudmFyIGdldEFsbCA9IFRXRUVOLmdldEFsbC5iaW5kKFRXRUVOKTtcbnZhciByZW1vdmVBbGwgPSBUV0VFTi5yZW1vdmVBbGwuYmluZChUV0VFTik7XG52YXIgYWRkID0gVFdFRU4uYWRkLmJpbmQoVFdFRU4pO1xudmFyIHJlbW92ZSA9IFRXRUVOLnJlbW92ZS5iaW5kKFRXRUVOKTtcbnZhciB1cGRhdGUgPSBUV0VFTi51cGRhdGUuYmluZChUV0VFTik7XG52YXIgZXhwb3J0cyA9IHtcbiAgICBFYXNpbmc6IEVhc2luZyxcbiAgICBHcm91cDogR3JvdXAsXG4gICAgSW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGlvbixcbiAgICBub3c6IG5vdyxcbiAgICBTZXF1ZW5jZTogU2VxdWVuY2UsXG4gICAgbmV4dElkOiBuZXh0SWQsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFZFUlNJT046IFZFUlNJT04sXG4gICAgZ2V0QWxsOiBnZXRBbGwsXG4gICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXG4gICAgYWRkOiBhZGQsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgdXBkYXRlOiB1cGRhdGUsXG59O1xuXG5leHBvcnQgeyBFYXNpbmcsIEdyb3VwLCBJbnRlcnBvbGF0aW9uLCBTZXF1ZW5jZSwgVHdlZW4sIFZFUlNJT04sIGFkZCwgZXhwb3J0cyBhcyBkZWZhdWx0LCBnZXRBbGwsIG5leHRJZCwgbm93LCByZW1vdmUsIHJlbW92ZUFsbCwgdXBkYXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1984\n")},7429:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony exports BooleanController, ColorController, Controller, FunctionController, GUI, NumberController, OptionController, StringController */\n/**\n * lil-gui\n * https://lil-gui.georgealways.com\n * @version 0.19.1\n * @author George Michael Brower\n * @license MIT\n */\n\n/**\n * Base class for all controllers.\n */\nclass Controller {\n\n\tconstructor( parent, object, property, className, elementType = 'div' ) {\n\n\t\t/**\n\t\t * The GUI that contains this controller.\n\t\t * @type {GUI}\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The object this controller will modify.\n\t\t * @type {object}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The name of the property to control.\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * Used to determine if the controller is disabled.\n\t\t * Use `controller.disable( true|false )` to modify this value.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._disabled = false;\n\n\t\t/**\n\t\t * Used to determine if the Controller is hidden.\n\t\t * Use `controller.show()` or `controller.hide()` to change this.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._hidden = false;\n\n\t\t/**\n\t\t * The value of `object[ property ]` when the controller was created.\n\t\t * @type {any}\n\t\t */\n\t\tthis.initialValue = this.getValue();\n\n\t\t/**\n\t\t * The outermost container DOM element for this controller.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.domElement = document.createElement( elementType );\n\t\tthis.domElement.classList.add( 'controller' );\n\t\tthis.domElement.classList.add( className );\n\n\t\t/**\n\t\t * The DOM element that contains the controller's name.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$name = document.createElement( 'div' );\n\t\tthis.$name.classList.add( 'name' );\n\n\t\tController.nextNameID = Controller.nextNameID || 0;\n\t\tthis.$name.id = `lil-gui-name-${++Controller.nextNameID}`;\n\n\t\t/**\n\t\t * The DOM element that contains the controller's \"widget\" (which differs by controller type).\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$widget = document.createElement( 'div' );\n\t\tthis.$widget.classList.add( 'widget' );\n\n\t\t/**\n\t\t * The DOM element that receives the disabled attribute when using disable().\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$disable = this.$widget;\n\n\t\tthis.domElement.appendChild( this.$name );\n\t\tthis.domElement.appendChild( this.$widget );\n\n\t\t// Don't fire global key events while typing in a controller\n\t\tthis.domElement.addEventListener( 'keydown', e => e.stopPropagation() );\n\t\tthis.domElement.addEventListener( 'keyup', e => e.stopPropagation() );\n\n\t\tthis.parent.children.push( this );\n\t\tthis.parent.controllers.push( this );\n\n\t\tthis.parent.$children.appendChild( this.domElement );\n\n\t\tthis._listenCallback = this._listenCallback.bind( this );\n\n\t\tthis.name( property );\n\n\t}\n\n\t/**\n\t * Sets the name of the controller and its label in the GUI.\n\t * @param {string} name\n\t * @returns {this}\n\t */\n\tname( name ) {\n\t\t/**\n\t\t * The controller's name. Use `controller.name( 'Name' )` to modify this value.\n\t\t * @type {string}\n\t\t */\n\t\tthis._name = name;\n\t\tthis.$name.innerHTML = name;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pass a function to be called whenever the value is modified by this controller.\n\t * The function receives the new value as its first parameter. The value of `this` will be the\n\t * controller.\n\t *\n\t * For function controllers, the `onChange` callback will be fired on click, after the function\n\t * executes.\n\t * @param {Function} callback\n\t * @returns {this}\n\t * @example\n\t * const controller = gui.add( object, 'property' );\n\t *\n\t * controller.onChange( function( v ) {\n\t * \tconsole.log( 'The value is now ' + v );\n\t * \tconsole.assert( this === controller );\n\t * } );\n\t */\n\tonChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onChange` events. Don't modify this value directly.\n\t\t * Use the `controller.onChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onChange = callback;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the onChange methods of this controller and its parent GUI.\n\t * @protected\n\t */\n\t_callOnChange() {\n\n\t\tthis.parent._callOnChange( this );\n\n\t\tif ( this._onChange !== undefined ) {\n\t\t\tthis._onChange.call( this, this.getValue() );\n\t\t}\n\n\t\tthis._changed = true;\n\n\t}\n\n\t/**\n\t * Pass a function to be called after this controller has been modified and loses focus.\n\t * @param {Function} callback\n\t * @returns {this}\n\t * @example\n\t * const controller = gui.add( object, 'property' );\n\t *\n\t * controller.onFinishChange( function( v ) {\n\t * \tconsole.log( 'Changes complete: ' + v );\n\t * \tconsole.assert( this === controller );\n\t * } );\n\t */\n\tonFinishChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onFinishChange` events. Don't modify this value\n\t\t * directly. Use the `controller.onFinishChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onFinishChange = callback;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Should be called by Controller when its widgets lose focus.\n\t * @protected\n\t */\n\t_callOnFinishChange() {\n\n\t\tif ( this._changed ) {\n\n\t\t\tthis.parent._callOnFinishChange( this );\n\n\t\t\tif ( this._onFinishChange !== undefined ) {\n\t\t\t\tthis._onFinishChange.call( this, this.getValue() );\n\t\t\t}\n\n\t\t}\n\n\t\tthis._changed = false;\n\n\t}\n\n\t/**\n\t * Sets the controller back to its initial value.\n\t * @returns {this}\n\t */\n\treset() {\n\t\tthis.setValue( this.initialValue );\n\t\tthis._callOnFinishChange();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables this controller.\n\t * @param {boolean} enabled\n\t * @returns {this}\n\t * @example\n\t * controller.enable();\n\t * controller.enable( false ); // disable\n\t * controller.enable( controller._disabled ); // toggle\n\t */\n\tenable( enabled = true ) {\n\t\treturn this.disable( !enabled );\n\t}\n\n\t/**\n\t * Disables this controller.\n\t * @param {boolean} disabled\n\t * @returns {this}\n\t * @example\n\t * controller.disable();\n\t * controller.disable( false ); // enable\n\t * controller.disable( !controller._disabled ); // toggle\n\t */\n\tdisable( disabled = true ) {\n\n\t\tif ( disabled === this._disabled ) return this;\n\n\t\tthis._disabled = disabled;\n\n\t\tthis.domElement.classList.toggle( 'disabled', disabled );\n\t\tthis.$disable.toggleAttribute( 'disabled', disabled );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Shows the Controller after it's been hidden.\n\t * @param {boolean} show\n\t * @returns {this}\n\t * @example\n\t * controller.show();\n\t * controller.show( false ); // hide\n\t * controller.show( controller._hidden ); // toggle\n\t */\n\tshow( show = true ) {\n\n\t\tthis._hidden = !show;\n\n\t\tthis.domElement.style.display = this._hidden ? 'none' : '';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Hides the Controller.\n\t * @returns {this}\n\t */\n\thide() {\n\t\treturn this.show( false );\n\t}\n\n\t/**\n\t * Changes this controller into a dropdown of options.\n\t *\n\t * Calling this method on an option controller will simply update the options. However, if this\n\t * controller was not already an option controller, old references to this controller are\n\t * destroyed, and a new controller is added to the end of the GUI.\n\t * @example\n\t * // safe usage\n\t *\n\t * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );\n\t * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );\n\t * gui.add( obj, 'prop3' );\n\t *\n\t * // danger\n\t *\n\t * const ctrl1 = gui.add( obj, 'prop1' );\n\t * gui.add( obj, 'prop2' );\n\t *\n\t * // calling options out of order adds a new controller to the end...\n\t * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );\n\t *\n\t * // ...and ctrl1 now references a controller that doesn't exist\n\t * assert( ctrl2 !== ctrl1 )\n\t * @param {object|Array} options\n\t * @returns {Controller}\n\t */\n\toptions( options ) {\n\t\tconst controller = this.parent.add( this.object, this.property, options );\n\t\tcontroller.name( this._name );\n\t\tthis.destroy();\n\t\treturn controller;\n\t}\n\n\t/**\n\t * Sets the minimum value. Only works on number controllers.\n\t * @param {number} min\n\t * @returns {this}\n\t */\n\tmin( min ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the maximum value. Only works on number controllers.\n\t * @param {number} max\n\t * @returns {this}\n\t */\n\tmax( max ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Values set by this controller will be rounded to multiples of `step`. Only works on number\n\t * controllers.\n\t * @param {number} step\n\t * @returns {this}\n\t */\n\tstep( step ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Rounds the displayed value to a fixed number of decimals, without affecting the actual value\n\t * like `step()`. Only works on number controllers.\n\t * @example\n\t * gui.add( object, 'property' ).listen().decimals( 4 );\n\t * @param {number} decimals\n\t * @returns {this}\n\t */\n\tdecimals( decimals ) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls `updateDisplay()` every animation frame. Pass `false` to stop listening.\n\t * @param {boolean} listen\n\t * @returns {this}\n\t */\n\tlisten( listen = true ) {\n\n\t\t/**\n\t\t * Used to determine if the controller is currently listening. Don't modify this value\n\t\t * directly. Use the `controller.listen( true|false )` method instead.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._listening = listen;\n\n\t\tif ( this._listenCallbackID !== undefined ) {\n\t\t\tcancelAnimationFrame( this._listenCallbackID );\n\t\t\tthis._listenCallbackID = undefined;\n\t\t}\n\n\t\tif ( this._listening ) {\n\t\t\tthis._listenCallback();\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t_listenCallback() {\n\n\t\tthis._listenCallbackID = requestAnimationFrame( this._listenCallback );\n\n\t\t// To prevent framerate loss, make sure the value has changed before updating the display.\n\t\t// Note: save() is used here instead of getValue() only because of ColorController. The !== operator\n\t\t// won't work for color objects or arrays, but ColorController.save() always returns a string.\n\n\t\tconst curValue = this.save();\n\n\t\tif ( curValue !== this._listenPrevValue ) {\n\t\t\tthis.updateDisplay();\n\t\t}\n\n\t\tthis._listenPrevValue = curValue;\n\n\t}\n\n\t/**\n\t * Returns `object[ property ]`.\n\t * @returns {any}\n\t */\n\tgetValue() {\n\t\treturn this.object[ this.property ];\n\t}\n\n\t/**\n\t * Sets the value of `object[ property ]`, invokes any `onChange` handlers and updates the display.\n\t * @param {any} value\n\t * @returns {this}\n\t */\n\tsetValue( value ) {\n\t\tthis.object[ this.property ] = value;\n\t\tthis._callOnChange();\n\t\tthis.updateDisplay();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates the display to keep it in sync with the current value. Useful for updating your\n\t * controllers when their values have been modified outside of the GUI.\n\t * @returns {this}\n\t */\n\tupdateDisplay() {\n\t\treturn this;\n\t}\n\n\tload( value ) {\n\t\tthis.setValue( value );\n\t\tthis._callOnFinishChange();\n\t\treturn this;\n\t}\n\n\tsave() {\n\t\treturn this.getValue();\n\t}\n\n\t/**\n\t * Destroys this controller and removes it from the parent GUI.\n\t */\n\tdestroy() {\n\t\tthis.listen( false );\n\t\tthis.parent.children.splice( this.parent.children.indexOf( this ), 1 );\n\t\tthis.parent.controllers.splice( this.parent.controllers.indexOf( this ), 1 );\n\t\tthis.parent.$children.removeChild( this.domElement );\n\t}\n\n}\n\nclass BooleanController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property ) {\n\n\t\tsuper( parent, object, property, 'boolean', 'label' );\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'checkbox' );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$widget.appendChild( this.$input );\n\n\t\tthis.$input.addEventListener( 'change', () => {\n\t\t\tthis.setValue( this.$input.checked );\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$disable = this.$input;\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\tupdateDisplay() {\n\t\tthis.$input.checked = this.getValue();\n\t\treturn this;\n\t}\n\n}\n\nfunction normalizeColorString( string ) {\n\n\tlet match, result;\n\n\tif ( match = string.match( /(#|0x)?([a-f0-9]{6})/i ) ) {\n\n\t\tresult = match[ 2 ];\n\n\t} else if ( match = string.match( /rgb\\(\\s*(\\d*)\\s*,\\s*(\\d*)\\s*,\\s*(\\d*)\\s*\\)/ ) ) {\n\n\t\tresult = parseInt( match[ 1 ] ).toString( 16 ).padStart( 2, 0 )\n\t\t\t+ parseInt( match[ 2 ] ).toString( 16 ).padStart( 2, 0 )\n\t\t\t+ parseInt( match[ 3 ] ).toString( 16 ).padStart( 2, 0 );\n\n\t} else if ( match = string.match( /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i ) ) {\n\n\t\tresult = match[ 1 ] + match[ 1 ] + match[ 2 ] + match[ 2 ] + match[ 3 ] + match[ 3 ];\n\n\t}\n\n\tif ( result ) {\n\t\treturn '#' + result;\n\t}\n\n\treturn false;\n\n}\n\nconst STRING = {\n\tisPrimitive: true,\n\tmatch: v => typeof v === 'string',\n\tfromHexString: normalizeColorString,\n\ttoHexString: normalizeColorString\n};\n\nconst INT = {\n\tisPrimitive: true,\n\tmatch: v => typeof v === 'number',\n\tfromHexString: string => parseInt( string.substring( 1 ), 16 ),\n\ttoHexString: value => '#' + value.toString( 16 ).padStart( 6, 0 )\n};\n\nconst ARRAY = {\n\tisPrimitive: false,\n\n\t// The arrow function is here to appease tree shakers like esbuild or webpack.\n\t// See https://esbuild.github.io/api/#tree-shaking\n\tmatch: v => Array.isArray( v ),\n\n\tfromHexString( string, target, rgbScale = 1 ) {\n\n\t\tconst int = INT.fromHexString( string );\n\n\t\ttarget[ 0 ] = ( int >> 16 & 255 ) / 255 * rgbScale;\n\t\ttarget[ 1 ] = ( int >> 8 & 255 ) / 255 * rgbScale;\n\t\ttarget[ 2 ] = ( int & 255 ) / 255 * rgbScale;\n\n\t},\n\ttoHexString( [ r, g, b ], rgbScale = 1 ) {\n\n\t\trgbScale = 255 / rgbScale;\n\n\t\tconst int = ( r * rgbScale ) << 16 ^\n\t\t\t( g * rgbScale ) << 8 ^\n\t\t\t( b * rgbScale ) << 0;\n\n\t\treturn INT.toHexString( int );\n\n\t}\n};\n\nconst OBJECT = {\n\tisPrimitive: false,\n\tmatch: v => Object( v ) === v,\n\tfromHexString( string, target, rgbScale = 1 ) {\n\n\t\tconst int = INT.fromHexString( string );\n\n\t\ttarget.r = ( int >> 16 & 255 ) / 255 * rgbScale;\n\t\ttarget.g = ( int >> 8 & 255 ) / 255 * rgbScale;\n\t\ttarget.b = ( int & 255 ) / 255 * rgbScale;\n\n\t},\n\ttoHexString( { r, g, b }, rgbScale = 1 ) {\n\n\t\trgbScale = 255 / rgbScale;\n\n\t\tconst int = ( r * rgbScale ) << 16 ^\n\t\t\t( g * rgbScale ) << 8 ^\n\t\t\t( b * rgbScale ) << 0;\n\n\t\treturn INT.toHexString( int );\n\n\t}\n};\n\nconst FORMATS = [ STRING, INT, ARRAY, OBJECT ];\n\nfunction getColorFormat( value ) {\n\treturn FORMATS.find( format => format.match( value ) );\n}\n\nclass ColorController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property, rgbScale ) {\n\n\t\tsuper( parent, object, property, 'color' );\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'color' );\n\t\tthis.$input.setAttribute( 'tabindex', -1 );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$text = document.createElement( 'input' );\n\t\tthis.$text.setAttribute( 'type', 'text' );\n\t\tthis.$text.setAttribute( 'spellcheck', 'false' );\n\t\tthis.$text.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$display = document.createElement( 'div' );\n\t\tthis.$display.classList.add( 'display' );\n\n\t\tthis.$display.appendChild( this.$input );\n\t\tthis.$widget.appendChild( this.$display );\n\t\tthis.$widget.appendChild( this.$text );\n\n\t\tthis._format = getColorFormat( this.initialValue );\n\t\tthis._rgbScale = rgbScale;\n\n\t\tthis._initialValueHexString = this.save();\n\t\tthis._textFocused = false;\n\n\t\tthis.$input.addEventListener( 'input', () => {\n\t\t\tthis._setValueFromHexString( this.$input.value );\n\t\t} );\n\n\t\tthis.$input.addEventListener( 'blur', () => {\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$text.addEventListener( 'input', () => {\n\t\t\tconst tryParse = normalizeColorString( this.$text.value );\n\t\t\tif ( tryParse ) {\n\t\t\t\tthis._setValueFromHexString( tryParse );\n\t\t\t}\n\t\t} );\n\n\t\tthis.$text.addEventListener( 'focus', () => {\n\t\t\tthis._textFocused = true;\n\t\t\tthis.$text.select();\n\t\t} );\n\n\t\tthis.$text.addEventListener( 'blur', () => {\n\t\t\tthis._textFocused = false;\n\t\t\tthis.updateDisplay();\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$disable = this.$text;\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\treset() {\n\t\tthis._setValueFromHexString( this._initialValueHexString );\n\t\treturn this;\n\t}\n\n\t_setValueFromHexString( value ) {\n\n\t\tif ( this._format.isPrimitive ) {\n\n\t\t\tconst newValue = this._format.fromHexString( value );\n\t\t\tthis.setValue( newValue );\n\n\t\t} else {\n\n\t\t\tthis._format.fromHexString( value, this.getValue(), this._rgbScale );\n\t\t\tthis._callOnChange();\n\t\t\tthis.updateDisplay();\n\n\t\t}\n\n\t}\n\n\tsave() {\n\t\treturn this._format.toHexString( this.getValue(), this._rgbScale );\n\t}\n\n\tload( value ) {\n\t\tthis._setValueFromHexString( value );\n\t\tthis._callOnFinishChange();\n\t\treturn this;\n\t}\n\n\tupdateDisplay() {\n\t\tthis.$input.value = this._format.toHexString( this.getValue(), this._rgbScale );\n\t\tif ( !this._textFocused ) {\n\t\t\tthis.$text.value = this.$input.value.substring( 1 );\n\t\t}\n\t\tthis.$display.style.backgroundColor = this.$input.value;\n\t\treturn this;\n\t}\n\n}\n\nclass FunctionController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property ) {\n\n\t\tsuper( parent, object, property, 'function' );\n\n\t\t// Buttons are the only case where widget contains name\n\t\tthis.$button = document.createElement( 'button' );\n\t\tthis.$button.appendChild( this.$name );\n\t\tthis.$widget.appendChild( this.$button );\n\n\t\tthis.$button.addEventListener( 'click', e => {\n\t\t\te.preventDefault();\n\t\t\tthis.getValue().call( this.object );\n\t\t\tthis._callOnChange();\n\t\t} );\n\n\t\t// enables :active pseudo class on mobile\n\t\tthis.$button.addEventListener( 'touchstart', () => {}, { passive: true } );\n\n\t\tthis.$disable = this.$button;\n\n\t}\n\n}\n\nclass NumberController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property, min, max, step ) {\n\n\t\tsuper( parent, object, property, 'number' );\n\n\t\tthis._initInput();\n\n\t\tthis.min( min );\n\t\tthis.max( max );\n\n\t\tconst stepExplicit = step !== undefined;\n\t\tthis.step( stepExplicit ? step : this._getImplicitStep(), stepExplicit );\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\tdecimals( decimals ) {\n\t\tthis._decimals = decimals;\n\t\tthis.updateDisplay();\n\t\treturn this;\n\t}\n\n\tmin( min ) {\n\t\tthis._min = min;\n\t\tthis._onUpdateMinMax();\n\t\treturn this;\n\t}\n\n\tmax( max ) {\n\t\tthis._max = max;\n\t\tthis._onUpdateMinMax();\n\t\treturn this;\n\t}\n\n\tstep( step, explicit = true ) {\n\t\tthis._step = step;\n\t\tthis._stepExplicit = explicit;\n\t\treturn this;\n\t}\n\n\tupdateDisplay() {\n\n\t\tconst value = this.getValue();\n\n\t\tif ( this._hasSlider ) {\n\n\t\t\tlet percent = ( value - this._min ) / ( this._max - this._min );\n\t\t\tpercent = Math.max( 0, Math.min( percent, 1 ) );\n\n\t\t\tthis.$fill.style.width = percent * 100 + '%';\n\n\t\t}\n\n\t\tif ( !this._inputFocused ) {\n\t\t\tthis.$input.value = this._decimals === undefined ? value : value.toFixed( this._decimals );\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t_initInput() {\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'text' );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\t// On touch devices only, use input[type=number] to force a numeric keyboard.\n\t\t// Ideally we could use one input type everywhere, but [type=number] has quirks\n\t\t// on desktop, and [inputmode=decimal] has quirks on iOS.\n\t\t// See https://github.com/georgealways/lil-gui/pull/16\n\n\t\tconst isTouch = window.matchMedia( '(pointer: coarse)' ).matches;\n\n\t\tif ( isTouch ) {\n\t\t\tthis.$input.setAttribute( 'type', 'number' );\n\t\t\tthis.$input.setAttribute( 'step', 'any' );\n\t\t}\n\n\t\tthis.$widget.appendChild( this.$input );\n\n\t\tthis.$disable = this.$input;\n\n\t\tconst onInput = () => {\n\n\t\t\tlet value = parseFloat( this.$input.value );\n\n\t\t\tif ( isNaN( value ) ) return;\n\n\t\t\tif ( this._stepExplicit ) {\n\t\t\t\tvalue = this._snap( value );\n\t\t\t}\n\n\t\t\tthis.setValue( this._clamp( value ) );\n\n\t\t};\n\n\t\t// Keys & mouse wheel\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst increment = delta => {\n\n\t\t\tconst value = parseFloat( this.$input.value );\n\n\t\t\tif ( isNaN( value ) ) return;\n\n\t\t\tthis._snapClampSetValue( value + delta );\n\n\t\t\t// Force the input to updateDisplay when it's focused\n\t\t\tthis.$input.value = this.getValue();\n\n\t\t};\n\n\t\tconst onKeyDown = e => {\n\t\t\t// Using `e.key` instead of `e.code` also catches NumpadEnter\n\t\t\tif ( e.key === 'Enter' ) {\n\t\t\t\tthis.$input.blur();\n\t\t\t}\n\t\t\tif ( e.code === 'ArrowUp' ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tincrement( this._step * this._arrowKeyMultiplier( e ) );\n\t\t\t}\n\t\t\tif ( e.code === 'ArrowDown' ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tincrement( this._step * this._arrowKeyMultiplier( e ) * -1 );\n\t\t\t}\n\t\t};\n\n\t\tconst onWheel = e => {\n\t\t\tif ( this._inputFocused ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tincrement( this._step * this._normalizeMouseWheel( e ) );\n\t\t\t}\n\t\t};\n\n\t\t// Vertical drag\n\t\t// ---------------------------------------------------------------------\n\n\t\tlet testingForVerticalDrag = false,\n\t\t\tinitClientX,\n\t\t\tinitClientY,\n\t\t\tprevClientY,\n\t\t\tinitValue,\n\t\t\tdragDelta;\n\n\t\t// Once the mouse is dragged more than DRAG_THRESH px on any axis, we decide\n\t\t// on the user's intent: horizontal means highlight, vertical means drag.\n\t\tconst DRAG_THRESH = 5;\n\n\t\tconst onMouseDown = e => {\n\n\t\t\tinitClientX = e.clientX;\n\t\t\tinitClientY = prevClientY = e.clientY;\n\t\t\ttestingForVerticalDrag = true;\n\n\t\t\tinitValue = this.getValue();\n\t\t\tdragDelta = 0;\n\n\t\t\twindow.addEventListener( 'mousemove', onMouseMove );\n\t\t\twindow.addEventListener( 'mouseup', onMouseUp );\n\n\t\t};\n\n\t\tconst onMouseMove = e => {\n\n\t\t\tif ( testingForVerticalDrag ) {\n\n\t\t\t\tconst dx = e.clientX - initClientX;\n\t\t\t\tconst dy = e.clientY - initClientY;\n\n\t\t\t\tif ( Math.abs( dy ) > DRAG_THRESH ) {\n\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tthis.$input.blur();\n\t\t\t\t\ttestingForVerticalDrag = false;\n\t\t\t\t\tthis._setDraggingStyle( true, 'vertical' );\n\n\t\t\t\t} else if ( Math.abs( dx ) > DRAG_THRESH ) {\n\n\t\t\t\t\tonMouseUp();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// This isn't an else so that the first move counts towards dragDelta\n\t\t\tif ( !testingForVerticalDrag ) {\n\n\t\t\t\tconst dy = e.clientY - prevClientY;\n\n\t\t\t\tdragDelta -= dy * this._step * this._arrowKeyMultiplier( e );\n\n\t\t\t\t// Clamp dragDelta so we don't have 'dead space' after dragging past bounds.\n\t\t\t\t// We're okay with the fact that bounds can be undefined here.\n\t\t\t\tif ( initValue + dragDelta > this._max ) {\n\t\t\t\t\tdragDelta = this._max - initValue;\n\t\t\t\t} else if ( initValue + dragDelta < this._min ) {\n\t\t\t\t\tdragDelta = this._min - initValue;\n\t\t\t\t}\n\n\t\t\t\tthis._snapClampSetValue( initValue + dragDelta );\n\n\t\t\t}\n\n\t\t\tprevClientY = e.clientY;\n\n\t\t};\n\n\t\tconst onMouseUp = () => {\n\t\t\tthis._setDraggingStyle( false, 'vertical' );\n\t\t\tthis._callOnFinishChange();\n\t\t\twindow.removeEventListener( 'mousemove', onMouseMove );\n\t\t\twindow.removeEventListener( 'mouseup', onMouseUp );\n\t\t};\n\n\t\t// Focus state & onFinishChange\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst onFocus = () => {\n\t\t\tthis._inputFocused = true;\n\t\t};\n\n\t\tconst onBlur = () => {\n\t\t\tthis._inputFocused = false;\n\t\t\tthis.updateDisplay();\n\t\t\tthis._callOnFinishChange();\n\t\t};\n\n\t\tthis.$input.addEventListener( 'input', onInput );\n\t\tthis.$input.addEventListener( 'keydown', onKeyDown );\n\t\tthis.$input.addEventListener( 'wheel', onWheel, { passive: false } );\n\t\tthis.$input.addEventListener( 'mousedown', onMouseDown );\n\t\tthis.$input.addEventListener( 'focus', onFocus );\n\t\tthis.$input.addEventListener( 'blur', onBlur );\n\n\t}\n\n\t_initSlider() {\n\n\t\tthis._hasSlider = true;\n\n\t\t// Build DOM\n\t\t// ---------------------------------------------------------------------\n\n\t\tthis.$slider = document.createElement( 'div' );\n\t\tthis.$slider.classList.add( 'slider' );\n\n\t\tthis.$fill = document.createElement( 'div' );\n\t\tthis.$fill.classList.add( 'fill' );\n\n\t\tthis.$slider.appendChild( this.$fill );\n\t\tthis.$widget.insertBefore( this.$slider, this.$input );\n\n\t\tthis.domElement.classList.add( 'hasSlider' );\n\n\t\t// Map clientX to value\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst map = ( v, a, b, c, d ) => {\n\t\t\treturn ( v - a ) / ( b - a ) * ( d - c ) + c;\n\t\t};\n\n\t\tconst setValueFromX = clientX => {\n\t\t\tconst rect = this.$slider.getBoundingClientRect();\n\t\t\tlet value = map( clientX, rect.left, rect.right, this._min, this._max );\n\t\t\tthis._snapClampSetValue( value );\n\t\t};\n\n\t\t// Mouse drag\n\t\t// ---------------------------------------------------------------------\n\n\t\tconst mouseDown = e => {\n\t\t\tthis._setDraggingStyle( true );\n\t\t\tsetValueFromX( e.clientX );\n\t\t\twindow.addEventListener( 'mousemove', mouseMove );\n\t\t\twindow.addEventListener( 'mouseup', mouseUp );\n\t\t};\n\n\t\tconst mouseMove = e => {\n\t\t\tsetValueFromX( e.clientX );\n\t\t};\n\n\t\tconst mouseUp = () => {\n\t\t\tthis._callOnFinishChange();\n\t\t\tthis._setDraggingStyle( false );\n\t\t\twindow.removeEventListener( 'mousemove', mouseMove );\n\t\t\twindow.removeEventListener( 'mouseup', mouseUp );\n\t\t};\n\n\t\t// Touch drag\n\t\t// ---------------------------------------------------------------------\n\n\t\tlet testingForScroll = false, prevClientX, prevClientY;\n\n\t\tconst beginTouchDrag = e => {\n\t\t\te.preventDefault();\n\t\t\tthis._setDraggingStyle( true );\n\t\t\tsetValueFromX( e.touches[ 0 ].clientX );\n\t\t\ttestingForScroll = false;\n\t\t};\n\n\t\tconst onTouchStart = e => {\n\n\t\t\tif ( e.touches.length > 1 ) return;\n\n\t\t\t// If we're in a scrollable container, we should wait for the first\n\t\t\t// touchmove to see if the user is trying to slide or scroll.\n\t\t\tif ( this._hasScrollBar ) {\n\n\t\t\t\tprevClientX = e.touches[ 0 ].clientX;\n\t\t\t\tprevClientY = e.touches[ 0 ].clientY;\n\t\t\t\ttestingForScroll = true;\n\n\t\t\t} else {\n\n\t\t\t\t// Otherwise, we can set the value straight away on touchstart.\n\t\t\t\tbeginTouchDrag( e );\n\n\t\t\t}\n\n\t\t\twindow.addEventListener( 'touchmove', onTouchMove, { passive: false } );\n\t\t\twindow.addEventListener( 'touchend', onTouchEnd );\n\n\t\t};\n\n\t\tconst onTouchMove = e => {\n\n\t\t\tif ( testingForScroll ) {\n\n\t\t\t\tconst dx = e.touches[ 0 ].clientX - prevClientX;\n\t\t\t\tconst dy = e.touches[ 0 ].clientY - prevClientY;\n\n\t\t\t\tif ( Math.abs( dx ) > Math.abs( dy ) ) {\n\n\t\t\t\t\t// We moved horizontally, set the value and stop checking.\n\t\t\t\t\tbeginTouchDrag( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// This was, in fact, an attempt to scroll. Abort.\n\t\t\t\t\twindow.removeEventListener( 'touchmove', onTouchMove );\n\t\t\t\t\twindow.removeEventListener( 'touchend', onTouchEnd );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\te.preventDefault();\n\t\t\t\tsetValueFromX( e.touches[ 0 ].clientX );\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst onTouchEnd = () => {\n\t\t\tthis._callOnFinishChange();\n\t\t\tthis._setDraggingStyle( false );\n\t\t\twindow.removeEventListener( 'touchmove', onTouchMove );\n\t\t\twindow.removeEventListener( 'touchend', onTouchEnd );\n\t\t};\n\n\t\t// Mouse wheel\n\t\t// ---------------------------------------------------------------------\n\n\t\t// We have to use a debounced function to call onFinishChange because\n\t\t// there's no way to tell when the user is \"done\" mouse-wheeling.\n\t\tconst callOnFinishChange = this._callOnFinishChange.bind( this );\n\t\tconst WHEEL_DEBOUNCE_TIME = 400;\n\t\tlet wheelFinishChangeTimeout;\n\n\t\tconst onWheel = e => {\n\n\t\t\t// ignore vertical wheels if there's a scrollbar\n\t\t\tconst isVertical = Math.abs( e.deltaX ) < Math.abs( e.deltaY );\n\t\t\tif ( isVertical && this._hasScrollBar ) return;\n\n\t\t\te.preventDefault();\n\n\t\t\t// set value\n\t\t\tconst delta = this._normalizeMouseWheel( e ) * this._step;\n\t\t\tthis._snapClampSetValue( this.getValue() + delta );\n\n\t\t\t// force the input to updateDisplay when it's focused\n\t\t\tthis.$input.value = this.getValue();\n\n\t\t\t// debounce onFinishChange\n\t\t\tclearTimeout( wheelFinishChangeTimeout );\n\t\t\twheelFinishChangeTimeout = setTimeout( callOnFinishChange, WHEEL_DEBOUNCE_TIME );\n\n\t\t};\n\n\t\tthis.$slider.addEventListener( 'mousedown', mouseDown );\n\t\tthis.$slider.addEventListener( 'touchstart', onTouchStart, { passive: false } );\n\t\tthis.$slider.addEventListener( 'wheel', onWheel, { passive: false } );\n\n\t}\n\n\t_setDraggingStyle( active, axis = 'horizontal' ) {\n\t\tif ( this.$slider ) {\n\t\t\tthis.$slider.classList.toggle( 'active', active );\n\t\t}\n\t\tdocument.body.classList.toggle( 'lil-gui-dragging', active );\n\t\tdocument.body.classList.toggle( `lil-gui-${axis}`, active );\n\t}\n\n\t_getImplicitStep() {\n\n\t\tif ( this._hasMin && this._hasMax ) {\n\t\t\treturn ( this._max - this._min ) / 1000;\n\t\t}\n\n\t\treturn 0.1;\n\n\t}\n\n\t_onUpdateMinMax() {\n\n\t\tif ( !this._hasSlider && this._hasMin && this._hasMax ) {\n\n\t\t\t// If this is the first time we're hearing about min and max\n\t\t\t// and we haven't explicitly stated what our step is, let's\n\t\t\t// update that too.\n\t\t\tif ( !this._stepExplicit ) {\n\t\t\t\tthis.step( this._getImplicitStep(), false );\n\t\t\t}\n\n\t\t\tthis._initSlider();\n\t\t\tthis.updateDisplay();\n\n\t\t}\n\n\t}\n\n\t_normalizeMouseWheel( e ) {\n\n\t\tlet { deltaX, deltaY } = e;\n\n\t\t// Safari and Chrome report weird non-integral values for a notched wheel,\n\t\t// but still expose actual lines scrolled via wheelDelta. Notched wheels\n\t\t// should behave the same way as arrow keys.\n\t\tif ( Math.floor( e.deltaY ) !== e.deltaY && e.wheelDelta ) {\n\t\t\tdeltaX = 0;\n\t\t\tdeltaY = -e.wheelDelta / 120;\n\t\t\tdeltaY *= this._stepExplicit ? 1 : 10;\n\t\t}\n\n\t\tconst wheel = deltaX + -deltaY;\n\n\t\treturn wheel;\n\n\t}\n\n\t_arrowKeyMultiplier( e ) {\n\n\t\tlet mult = this._stepExplicit ? 1 : 10;\n\n\t\tif ( e.shiftKey ) {\n\t\t\tmult *= 10;\n\t\t} else if ( e.altKey ) {\n\t\t\tmult /= 10;\n\t\t}\n\n\t\treturn mult;\n\n\t}\n\n\t_snap( value ) {\n\n\t\t// This would be the logical way to do things, but floating point errors.\n\t\t// return Math.round( value / this._step ) * this._step;\n\n\t\t// Using inverse step solves a lot of them, but not all\n\t\t// const inverseStep = 1 / this._step;\n\t\t// return Math.round( value * inverseStep ) / inverseStep;\n\n\t\t// Not happy about this, but haven't seen it break.\n\t\tconst r = Math.round( value / this._step ) * this._step;\n\t\treturn parseFloat( r.toPrecision( 15 ) );\n\n\t}\n\n\t_clamp( value ) {\n\t\t// either condition is false if min or max is undefined\n\t\tif ( value < this._min ) value = this._min;\n\t\tif ( value > this._max ) value = this._max;\n\t\treturn value;\n\t}\n\n\t_snapClampSetValue( value ) {\n\t\tthis.setValue( this._clamp( this._snap( value ) ) );\n\t}\n\n\tget _hasScrollBar() {\n\t\tconst root = this.parent.root.$children;\n\t\treturn root.scrollHeight > root.clientHeight;\n\t}\n\n\tget _hasMin() {\n\t\treturn this._min !== undefined;\n\t}\n\n\tget _hasMax() {\n\t\treturn this._max !== undefined;\n\t}\n\n}\n\nclass OptionController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property, options ) {\n\n\t\tsuper( parent, object, property, 'option' );\n\n\t\tthis.$select = document.createElement( 'select' );\n\t\tthis.$select.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$display = document.createElement( 'div' );\n\t\tthis.$display.classList.add( 'display' );\n\n\t\tthis.$select.addEventListener( 'change', () => {\n\t\t\tthis.setValue( this._values[ this.$select.selectedIndex ] );\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$select.addEventListener( 'focus', () => {\n\t\t\tthis.$display.classList.add( 'focus' );\n\t\t} );\n\n\t\tthis.$select.addEventListener( 'blur', () => {\n\t\t\tthis.$display.classList.remove( 'focus' );\n\t\t} );\n\n\t\tthis.$widget.appendChild( this.$select );\n\t\tthis.$widget.appendChild( this.$display );\n\n\t\tthis.$disable = this.$select;\n\n\t\tthis.options( options );\n\n\t}\n\n\toptions( options ) {\n\n\t\tthis._values = Array.isArray( options ) ? options : Object.values( options );\n\t\tthis._names = Array.isArray( options ) ? options : Object.keys( options );\n\n\t\tthis.$select.replaceChildren();\n\n\t\tthis._names.forEach( name => {\n\t\t\tconst $option = document.createElement( 'option' );\n\t\t\t$option.innerHTML = name;\n\t\t\tthis.$select.appendChild( $option );\n\t\t} );\n\n\t\tthis.updateDisplay();\n\n\t\treturn this;\n\n\t}\n\n\tupdateDisplay() {\n\t\tconst value = this.getValue();\n\t\tconst index = this._values.indexOf( value );\n\t\tthis.$select.selectedIndex = index;\n\t\tthis.$display.innerHTML = index === -1 ? value : this._names[ index ];\n\t\treturn this;\n\t}\n\n}\n\nclass StringController extends (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (Controller) : null) {\n\n\tconstructor( parent, object, property ) {\n\n\t\tsuper( parent, object, property, 'string' );\n\n\t\tthis.$input = document.createElement( 'input' );\n\t\tthis.$input.setAttribute( 'type', 'text' );\n\t\tthis.$input.setAttribute( 'aria-labelledby', this.$name.id );\n\n\t\tthis.$input.addEventListener( 'input', () => {\n\t\t\tthis.setValue( this.$input.value );\n\t\t} );\n\n\t\tthis.$input.addEventListener( 'keydown', e => {\n\t\t\tif ( e.code === 'Enter' ) {\n\t\t\t\tthis.$input.blur();\n\t\t\t}\n\t\t} );\n\n\t\tthis.$input.addEventListener( 'blur', () => {\n\t\t\tthis._callOnFinishChange();\n\t\t} );\n\n\t\tthis.$widget.appendChild( this.$input );\n\n\t\tthis.$disable = this.$input;\n\n\t\tthis.updateDisplay();\n\n\t}\n\n\tupdateDisplay() {\n\t\tthis.$input.value = this.getValue();\n\t\treturn this;\n\t}\n\n}\n\nconst stylesheet = (/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (`.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, \"Droid Sans Mono\", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: \" \";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: \"lil-gui\";\n  content: \"↕\";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: \"lil-gui\";\n  content: \"▾\";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: \"▸\";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: \"Empty\";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: \"lil-gui\";\n  content: \"✓\";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: \"lil-gui\";\n  src: url(\"data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==\") format(\"woff\");\n}`) : null);\n\nfunction _injectStyles( cssContent ) {\n\tconst injected = document.createElement( 'style' );\n\tinjected.innerHTML = cssContent;\n\tconst before = document.querySelector( 'head link[rel=stylesheet], head style' );\n\tif ( before ) {\n\t\tdocument.head.insertBefore( injected, before );\n\t} else {\n\t\tdocument.head.appendChild( injected );\n\t}\n}\n\nlet stylesInjected = false;\n\nclass GUI {\n\n\t/**\n\t * Creates a panel that holds controllers.\n\t * @example\n\t * new GUI();\n\t * new GUI( { container: document.getElementById( 'custom' ) } );\n\t *\n\t * @param {object} [options]\n\t * @param {boolean} [options.autoPlace=true]\n\t * Adds the GUI to `document.body` and fixes it to the top right of the page.\n\t *\n\t * @param {HTMLElement} [options.container]\n\t * Adds the GUI to this DOM element. Overrides `autoPlace`.\n\t *\n\t * @param {number} [options.width=245]\n\t * Width of the GUI in pixels, usually set when name labels become too long. Note that you can make\n\t * name labels wider in CSS with `.lil‑gui { ‑‑name‑width: 55% }`.\n\t *\n\t * @param {string} [options.title=Controls]\n\t * Name to display in the title bar.\n\t *\n\t * @param {boolean} [options.closeFolders=false]\n\t * Pass `true` to close all folders in this GUI by default.\n\t *\n\t * @param {boolean} [options.injectStyles=true]\n\t * Injects the default stylesheet into the page if this is the first GUI.\n\t * Pass `false` to use your own stylesheet.\n\t *\n\t * @param {number} [options.touchStyles=true]\n\t * Makes controllers larger on touch devices. Pass `false` to disable touch styles.\n\t *\n\t * @param {GUI} [options.parent]\n\t * Adds this GUI as a child in another GUI. Usually this is done for you by `addFolder()`.\n\t *\n\t */\n\tconstructor( {\n\t\tparent,\n\t\tautoPlace = parent === undefined,\n\t\tcontainer,\n\t\twidth,\n\t\ttitle = 'Controls',\n\t\tcloseFolders = false,\n\t\tinjectStyles = true,\n\t\ttouchStyles = true\n\t} = {} ) {\n\n\t\t/**\n\t\t * The GUI containing this folder, or `undefined` if this is the root GUI.\n\t\t * @type {GUI}\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The top level GUI containing this folder, or `this` if this is the root GUI.\n\t\t * @type {GUI}\n\t\t */\n\t\tthis.root = parent ? parent.root : this;\n\n\t\t/**\n\t\t * The list of controllers and folders contained by this GUI.\n\t\t * @type {Array<GUI|Controller>}\n\t\t */\n\t\tthis.children = [];\n\n\t\t/**\n\t\t * The list of controllers contained by this GUI.\n\t\t * @type {Array<Controller>}\n\t\t */\n\t\tthis.controllers = [];\n\n\t\t/**\n\t\t * The list of folders contained by this GUI.\n\t\t * @type {Array<GUI>}\n\t\t */\n\t\tthis.folders = [];\n\n\t\t/**\n\t\t * Used to determine if the GUI is closed. Use `gui.open()` or `gui.close()` to change this.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._closed = false;\n\n\t\t/**\n\t\t * Used to determine if the GUI is hidden. Use `gui.show()` or `gui.hide()` to change this.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._hidden = false;\n\n\t\t/**\n\t\t * The outermost container element.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.domElement = document.createElement( 'div' );\n\t\tthis.domElement.classList.add( 'lil-gui' );\n\n\t\t/**\n\t\t * The DOM element that contains the title.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$title = document.createElement( 'div' );\n\t\tthis.$title.classList.add( 'title' );\n\t\tthis.$title.setAttribute( 'role', 'button' );\n\t\tthis.$title.setAttribute( 'aria-expanded', true );\n\t\tthis.$title.setAttribute( 'tabindex', 0 );\n\n\t\tthis.$title.addEventListener( 'click', () => this.openAnimated( this._closed ) );\n\t\tthis.$title.addEventListener( 'keydown', e => {\n\t\t\tif ( e.code === 'Enter' || e.code === 'Space' ) {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.$title.click();\n\t\t\t}\n\t\t} );\n\n\t\t// enables :active pseudo class on mobile\n\t\tthis.$title.addEventListener( 'touchstart', () => {}, { passive: true } );\n\n\t\t/**\n\t\t * The DOM element that contains children.\n\t\t * @type {HTMLElement}\n\t\t */\n\t\tthis.$children = document.createElement( 'div' );\n\t\tthis.$children.classList.add( 'children' );\n\n\t\tthis.domElement.appendChild( this.$title );\n\t\tthis.domElement.appendChild( this.$children );\n\n\t\tthis.title( title );\n\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.children.push( this );\n\t\t\tthis.parent.folders.push( this );\n\n\t\t\tthis.parent.$children.appendChild( this.domElement );\n\n\t\t\t// Stop the constructor early, everything onward only applies to root GUI's\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.domElement.classList.add( 'root' );\n\n\t\tif ( touchStyles ) {\n\t\t\tthis.domElement.classList.add( 'allow-touch-styles' );\n\t\t}\n\n\t\t// Inject stylesheet if we haven't done that yet\n\t\tif ( !stylesInjected && injectStyles ) {\n\t\t\t_injectStyles( stylesheet );\n\t\t\tstylesInjected = true;\n\t\t}\n\n\t\tif ( container ) {\n\n\t\t\tcontainer.appendChild( this.domElement );\n\n\t\t} else if ( autoPlace ) {\n\n\t\t\tthis.domElement.classList.add( 'autoPlace' );\n\t\t\tdocument.body.appendChild( this.domElement );\n\n\t\t}\n\n\t\tif ( width ) {\n\t\t\tthis.domElement.style.setProperty( '--width', width + 'px' );\n\t\t}\n\n\t\tthis._closeFolders = closeFolders;\n\n\t}\n\n\t/**\n\t * Adds a controller to the GUI, inferring controller type using the `typeof` operator.\n\t * @example\n\t * gui.add( object, 'property' );\n\t * gui.add( object, 'number', 0, 100, 1 );\n\t * gui.add( object, 'options', [ 1, 2, 3 ] );\n\t *\n\t * @param {object} object The object the controller will modify.\n\t * @param {string} property Name of the property to control.\n\t * @param {number|object|Array} [$1] Minimum value for number controllers, or the set of\n\t * selectable values for a dropdown.\n\t * @param {number} [max] Maximum value for number controllers.\n\t * @param {number} [step] Step value for number controllers.\n\t * @returns {Controller}\n\t */\n\tadd( object, property, $1, max, step ) {\n\n\t\tif ( Object( $1 ) === $1 ) {\n\n\t\t\treturn new OptionController( this, object, property, $1 );\n\n\t\t}\n\n\t\tconst initialValue = object[ property ];\n\n\t\tswitch ( typeof initialValue ) {\n\n\t\t\tcase 'number':\n\n\t\t\t\treturn new NumberController( this, object, property, $1, max, step );\n\n\t\t\tcase 'boolean':\n\n\t\t\t\treturn new BooleanController( this, object, property );\n\n\t\t\tcase 'string':\n\n\t\t\t\treturn new StringController( this, object, property );\n\n\t\t\tcase 'function':\n\n\t\t\t\treturn new FunctionController( this, object, property );\n\n\t\t}\n\n\t\tconsole.error( `gui.add failed\n\tproperty:`, property, `\n\tobject:`, object, `\n\tvalue:`, initialValue );\n\n\t}\n\n\t/**\n\t * Adds a color controller to the GUI.\n\t * @example\n\t * params = {\n\t * \tcssColor: '#ff00ff',\n\t * \trgbColor: { r: 0, g: 0.2, b: 0.4 },\n\t * \tcustomRange: [ 0, 127, 255 ],\n\t * };\n\t *\n\t * gui.addColor( params, 'cssColor' );\n\t * gui.addColor( params, 'rgbColor' );\n\t * gui.addColor( params, 'customRange', 255 );\n\t *\n\t * @param {object} object The object the controller will modify.\n\t * @param {string} property Name of the property to control.\n\t * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may\n\t * need to set this to 255 if your colors are too bright.\n\t * @returns {Controller}\n\t */\n\taddColor( object, property, rgbScale = 1 ) {\n\t\treturn new ColorController( this, object, property, rgbScale );\n\t}\n\n\t/**\n\t * Adds a folder to the GUI, which is just another GUI. This method returns\n\t * the nested GUI so you can add controllers to it.\n\t * @example\n\t * const folder = gui.addFolder( 'Position' );\n\t * folder.add( position, 'x' );\n\t * folder.add( position, 'y' );\n\t * folder.add( position, 'z' );\n\t *\n\t * @param {string} title Name to display in the folder's title bar.\n\t * @returns {GUI}\n\t */\n\taddFolder( title ) {\n\t\tconst folder = new GUI( { parent: this, title } );\n\t\tif ( this.root._closeFolders ) folder.close();\n\t\treturn folder;\n\t}\n\n\t/**\n\t * Recalls values that were saved with `gui.save()`.\n\t * @param {object} obj\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {this}\n\t */\n\tload( obj, recursive = true ) {\n\n\t\tif ( obj.controllers ) {\n\n\t\t\tthis.controllers.forEach( c => {\n\n\t\t\t\tif ( c instanceof FunctionController ) return;\n\n\t\t\t\tif ( c._name in obj.controllers ) {\n\t\t\t\t\tc.load( obj.controllers[ c._name ] );\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( recursive && obj.folders ) {\n\n\t\t\tthis.folders.forEach( f => {\n\n\t\t\t\tif ( f._title in obj.folders ) {\n\t\t\t\t\tf.load( obj.folders[ f._title ] );\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to\n\t * recall these values.\n\t * @example\n\t * {\n\t * \tcontrollers: {\n\t * \t\tprop1: 1,\n\t * \t\tprop2: 'value',\n\t * \t\t...\n\t * \t},\n\t * \tfolders: {\n\t * \t\tfolderName1: { controllers, folders },\n\t * \t\tfolderName2: { controllers, folders }\n\t * \t\t...\n\t * \t}\n\t * }\n\t *\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {object}\n\t */\n\tsave( recursive = true ) {\n\n\t\tconst obj = {\n\t\t\tcontrollers: {},\n\t\t\tfolders: {}\n\t\t};\n\n\t\tthis.controllers.forEach( c => {\n\n\t\t\tif ( c instanceof FunctionController ) return;\n\n\t\t\tif ( c._name in obj.controllers ) {\n\t\t\t\tthrow new Error( `Cannot save GUI with duplicate property \"${c._name}\"` );\n\t\t\t}\n\n\t\t\tobj.controllers[ c._name ] = c.save();\n\n\t\t} );\n\n\t\tif ( recursive ) {\n\n\t\t\tthis.folders.forEach( f => {\n\n\t\t\t\tif ( f._title in obj.folders ) {\n\t\t\t\t\tthrow new Error( `Cannot save GUI with duplicate folder \"${f._title}\"` );\n\t\t\t\t}\n\n\t\t\t\tobj.folders[ f._title ] = f.save();\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn obj;\n\n\t}\n\n\t/**\n\t * Opens a GUI or folder. GUI and folders are open by default.\n\t * @param {boolean} open Pass false to close.\n\t * @returns {this}\n\t * @example\n\t * gui.open(); // open\n\t * gui.open( false ); // close\n\t * gui.open( gui._closed ); // toggle\n\t */\n\topen( open = true ) {\n\n\t\tthis._setClosed( !open );\n\n\t\tthis.$title.setAttribute( 'aria-expanded', !this._closed );\n\t\tthis.domElement.classList.toggle( 'closed', this._closed );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Closes the GUI.\n\t * @returns {this}\n\t */\n\tclose() {\n\t\treturn this.open( false );\n\t}\n\n\t_setClosed( closed ) {\n\t\tif ( this._closed === closed ) return;\n\t\tthis._closed = closed;\n\t\tthis._callOnOpenClose( this );\n\t}\n\n\t/**\n\t * Shows the GUI after it's been hidden.\n\t * @param {boolean} show\n\t * @returns {this}\n\t * @example\n\t * gui.show();\n\t * gui.show( false ); // hide\n\t * gui.show( gui._hidden ); // toggle\n\t */\n\tshow( show = true ) {\n\n\t\tthis._hidden = !show;\n\n\t\tthis.domElement.style.display = this._hidden ? 'none' : '';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Hides the GUI.\n\t * @returns {this}\n\t */\n\thide() {\n\t\treturn this.show( false );\n\t}\n\n\topenAnimated( open = true ) {\n\n\t\t// set state immediately\n\t\tthis._setClosed( !open );\n\n\t\tthis.$title.setAttribute( 'aria-expanded', !this._closed );\n\n\t\t// wait for next frame to measure $children\n\t\trequestAnimationFrame( () => {\n\n\t\t\t// explicitly set initial height for transition\n\t\t\tconst initialHeight = this.$children.clientHeight;\n\t\t\tthis.$children.style.height = initialHeight + 'px';\n\n\t\t\tthis.domElement.classList.add( 'transition' );\n\n\t\t\tconst onTransitionEnd = e => {\n\t\t\t\tif ( e.target !== this.$children ) return;\n\t\t\t\tthis.$children.style.height = '';\n\t\t\t\tthis.domElement.classList.remove( 'transition' );\n\t\t\t\tthis.$children.removeEventListener( 'transitionend', onTransitionEnd );\n\t\t\t};\n\n\t\t\tthis.$children.addEventListener( 'transitionend', onTransitionEnd );\n\n\t\t\t// todo: this is wrong if children's scrollHeight makes for a gui taller than maxHeight\n\t\t\tconst targetHeight = !open ? 0 : this.$children.scrollHeight;\n\n\t\t\tthis.domElement.classList.toggle( 'closed', !open );\n\n\t\t\trequestAnimationFrame( () => {\n\t\t\t\tthis.$children.style.height = targetHeight + 'px';\n\t\t\t} );\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Change the title of this GUI.\n\t * @param {string} title\n\t * @returns {this}\n\t */\n\ttitle( title ) {\n\t\t/**\n\t\t * Current title of the GUI. Use `gui.title( 'Title' )` to modify this value.\n\t\t * @type {string}\n\t\t */\n\t\tthis._title = title;\n\t\tthis.$title.innerHTML = title;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets all controllers to their initial values.\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {this}\n\t */\n\treset( recursive = true ) {\n\t\tconst controllers = recursive ? this.controllersRecursive() : this.controllers;\n\t\tcontrollers.forEach( c => c.reset() );\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pass a function to be called whenever a controller in this GUI changes.\n\t * @param {function({object:object, property:string, value:any, controller:Controller})} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onChange( event => {\n\t * \tevent.object     // object that was modified\n\t * \tevent.property   // string, name of property\n\t * \tevent.value      // new value of controller\n\t * \tevent.controller // controller that was modified\n\t * } );\n\t */\n\tonChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onChange` events. Don't modify this value\n\t\t * directly. Use the `gui.onChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onChange = callback;\n\t\treturn this;\n\t}\n\n\t_callOnChange( controller ) {\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._callOnChange( controller );\n\t\t}\n\n\t\tif ( this._onChange !== undefined ) {\n\t\t\tthis._onChange.call( this, {\n\t\t\t\tobject: controller.object,\n\t\t\t\tproperty: controller.property,\n\t\t\t\tvalue: controller.getValue(),\n\t\t\t\tcontroller\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Pass a function to be called whenever a controller in this GUI has finished changing.\n\t * @param {function({object:object, property:string, value:any, controller:Controller})} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onFinishChange( event => {\n\t * \tevent.object     // object that was modified\n\t * \tevent.property   // string, name of property\n\t * \tevent.value      // new value of controller\n\t * \tevent.controller // controller that was modified\n\t * } );\n\t */\n\tonFinishChange( callback ) {\n\t\t/**\n\t\t * Used to access the function bound to `onFinishChange` events. Don't modify this value\n\t\t * directly. Use the `gui.onFinishChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onFinishChange = callback;\n\t\treturn this;\n\t}\n\n\t_callOnFinishChange( controller ) {\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._callOnFinishChange( controller );\n\t\t}\n\n\t\tif ( this._onFinishChange !== undefined ) {\n\t\t\tthis._onFinishChange.call( this, {\n\t\t\t\tobject: controller.object,\n\t\t\t\tproperty: controller.property,\n\t\t\t\tvalue: controller.getValue(),\n\t\t\t\tcontroller\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Pass a function to be called when this GUI or its descendants are opened or closed.\n\t * @param {function(GUI)} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onOpenClose( changedGUI => {\n\t * \tconsole.log( changedGUI._closed );\n\t * } );\n\t */\n\tonOpenClose( callback ) {\n\t\tthis._onOpenClose = callback;\n\t\treturn this;\n\t}\n\n\t_callOnOpenClose( changedGUI ) {\n\t\tif ( this.parent ) {\n\t\t\tthis.parent._callOnOpenClose( changedGUI );\n\t\t}\n\n\t\tif ( this._onOpenClose !== undefined ) {\n\t\t\tthis._onOpenClose.call( this, changedGUI );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all DOM elements and event listeners associated with this GUI.\n\t */\n\tdestroy() {\n\n\t\tif ( this.parent ) {\n\t\t\tthis.parent.children.splice( this.parent.children.indexOf( this ), 1 );\n\t\t\tthis.parent.folders.splice( this.parent.folders.indexOf( this ), 1 );\n\t\t}\n\n\t\tif ( this.domElement.parentElement ) {\n\t\t\tthis.domElement.parentElement.removeChild( this.domElement );\n\t\t}\n\n\t\tArray.from( this.children ).forEach( c => c.destroy() );\n\n\t}\n\n\t/**\n\t * Returns an array of controllers contained by this GUI and its descendents.\n\t * @returns {Controller[]}\n\t */\n\tcontrollersRecursive() {\n\t\tlet controllers = Array.from( this.controllers );\n\t\tthis.folders.forEach( f => {\n\t\t\tcontrollers = controllers.concat( f.controllersRecursive() );\n\t\t} );\n\t\treturn controllers;\n\t}\n\n\t/**\n\t * Returns an array of folders contained by this GUI and its descendents.\n\t * @returns {GUI[]}\n\t */\n\tfoldersRecursive() {\n\t\tlet folders = Array.from( this.folders );\n\t\tthis.folders.forEach( f => {\n\t\t\tfolders = folders.concat( f.foldersRecursive() );\n\t\t} );\n\t\treturn folders;\n\t}\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((/* runtime-dependent pure expression or super */ 365 == __webpack_require__.j ? (GUI) : null));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDLDRGQUFVOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsRUFBRTs7QUFFaEQ7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0YsZ0JBQWdCLFNBQVM7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsNEZBQVU7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLDRGQUFVOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSx1REFBdUQsSUFBSSxnQkFBZ0I7O0FBRTNFOztBQUVBOztBQUVBOztBQUVBLCtCQUErQiw0RkFBVTs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsd0RBQXdELGlCQUFpQjtBQUN6RTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEYscURBQXFELGlCQUFpQjs7QUFFdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsNEZBQVU7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCLDRGQUFVOztBQUV6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsaUVBQWlFLEdBQUc7QUFDMUYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUscUZBQUcsV0FBQztBQUNzSCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL2xpbC1ndWkvZGlzdC9saWwtZ3VpLmVzbS5qcz9iZDM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbGlsLWd1aVxuICogaHR0cHM6Ly9saWwtZ3VpLmdlb3JnZWFsd2F5cy5jb21cbiAqIEB2ZXJzaW9uIDAuMTkuMVxuICogQGF1dGhvciBHZW9yZ2UgTWljaGFlbCBCcm93ZXJcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNvbnRyb2xsZXJzLlxuICovXG5jbGFzcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCBjbGFzc05hbWUsIGVsZW1lbnRUeXBlID0gJ2RpdicgKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgR1VJIHRoYXQgY29udGFpbnMgdGhpcyBjb250cm9sbGVyLlxuXHRcdCAqIEB0eXBlIHtHVUl9XG5cdFx0ICovXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoaXMgY29udHJvbGxlciB3aWxsIG1vZGlmeS5cblx0XHQgKiBAdHlwZSB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNvbnRyb2wuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgY29udHJvbGxlciBpcyBkaXNhYmxlZC5cblx0XHQgKiBVc2UgYGNvbnRyb2xsZXIuZGlzYWJsZSggdHJ1ZXxmYWxzZSApYCB0byBtb2RpZnkgdGhpcyB2YWx1ZS5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIENvbnRyb2xsZXIgaXMgaGlkZGVuLlxuXHRcdCAqIFVzZSBgY29udHJvbGxlci5zaG93KClgIG9yIGBjb250cm9sbGVyLmhpZGUoKWAgdG8gY2hhbmdlIHRoaXMuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5faGlkZGVuID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdmFsdWUgb2YgYG9iamVjdFsgcHJvcGVydHkgXWAgd2hlbiB0aGUgY29udHJvbGxlciB3YXMgY3JlYXRlZC5cblx0XHQgKiBAdHlwZSB7YW55fVxuXHRcdCAqL1xuXHRcdHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG91dGVybW9zdCBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoaXMgY29udHJvbGxlci5cblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggZWxlbWVudFR5cGUgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ2NvbnRyb2xsZXInICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoIGNsYXNzTmFtZSApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2xsZXIncyBuYW1lLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLiRuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR0aGlzLiRuYW1lLmNsYXNzTGlzdC5hZGQoICduYW1lJyApO1xuXG5cdFx0Q29udHJvbGxlci5uZXh0TmFtZUlEID0gQ29udHJvbGxlci5uZXh0TmFtZUlEIHx8IDA7XG5cdFx0dGhpcy4kbmFtZS5pZCA9IGBsaWwtZ3VpLW5hbWUtJHsrK0NvbnRyb2xsZXIubmV4dE5hbWVJRH1gO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2xsZXIncyBcIndpZGdldFwiICh3aGljaCBkaWZmZXJzIGJ5IGNvbnRyb2xsZXIgdHlwZSkuXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHRoaXMuJHdpZGdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kd2lkZ2V0LmNsYXNzTGlzdC5hZGQoICd3aWRnZXQnICk7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgRE9NIGVsZW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdoZW4gdXNpbmcgZGlzYWJsZSgpLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kd2lkZ2V0O1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLiRuYW1lICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLiR3aWRnZXQgKTtcblxuXHRcdC8vIERvbid0IGZpcmUgZ2xvYmFsIGtleSBldmVudHMgd2hpbGUgdHlwaW5nIGluIGEgY29udHJvbGxlclxuXHRcdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCkgKTtcblxuXHRcdHRoaXMucGFyZW50LmNoaWxkcmVuLnB1c2goIHRoaXMgKTtcblx0XHR0aGlzLnBhcmVudC5jb250cm9sbGVycy5wdXNoKCB0aGlzICk7XG5cblx0XHR0aGlzLnBhcmVudC4kY2hpbGRyZW4uYXBwZW5kQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXG5cdFx0dGhpcy5fbGlzdGVuQ2FsbGJhY2sgPSB0aGlzLl9saXN0ZW5DYWxsYmFjay5iaW5kKCB0aGlzICk7XG5cblx0XHR0aGlzLm5hbWUoIHByb3BlcnR5ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyIGFuZCBpdHMgbGFiZWwgaW4gdGhlIEdVSS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRuYW1lKCBuYW1lICkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb250cm9sbGVyJ3MgbmFtZS4gVXNlIGBjb250cm9sbGVyLm5hbWUoICdOYW1lJyApYCB0byBtb2RpZnkgdGhpcyB2YWx1ZS5cblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMuX25hbWUgPSBuYW1lO1xuXHRcdHRoaXMuJG5hbWUuaW5uZXJIVE1MID0gbmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBpcyBtb2RpZmllZCBieSB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgbmV3IHZhbHVlIGFzIGl0cyBmaXJzdCBwYXJhbWV0ZXIuIFRoZSB2YWx1ZSBvZiBgdGhpc2Agd2lsbCBiZSB0aGVcblx0ICogY29udHJvbGxlci5cblx0ICpcblx0ICogRm9yIGZ1bmN0aW9uIGNvbnRyb2xsZXJzLCB0aGUgYG9uQ2hhbmdlYCBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIG9uIGNsaWNrLCBhZnRlciB0aGUgZnVuY3Rpb25cblx0ICogZXhlY3V0ZXMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb25zdCBjb250cm9sbGVyID0gZ3VpLmFkZCggb2JqZWN0LCAncHJvcGVydHknICk7XG5cdCAqXG5cdCAqIGNvbnRyb2xsZXIub25DaGFuZ2UoIGZ1bmN0aW9uKCB2ICkge1xuXHQgKiBcdGNvbnNvbGUubG9nKCAnVGhlIHZhbHVlIGlzIG5vdyAnICsgdiApO1xuXHQgKiBcdGNvbnNvbGUuYXNzZXJ0KCB0aGlzID09PSBjb250cm9sbGVyICk7XG5cdCAqIH0gKTtcblx0ICovXG5cdG9uQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlIGRpcmVjdGx5LlxuXHRcdCAqIFVzZSB0aGUgYGNvbnRyb2xsZXIub25DaGFuZ2UoIGNhbGxiYWNrIClgIG1ldGhvZCBpbnN0ZWFkLlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLl9vbkNoYW5nZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIHRoZSBvbkNoYW5nZSBtZXRob2RzIG9mIHRoaXMgY29udHJvbGxlciBhbmQgaXRzIHBhcmVudCBHVUkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jYWxsT25DaGFuZ2UoKSB7XG5cblx0XHR0aGlzLnBhcmVudC5fY2FsbE9uQ2hhbmdlKCB0aGlzICk7XG5cblx0XHRpZiAoIHRoaXMuX29uQ2hhbmdlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZS5jYWxsKCB0aGlzLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jaGFuZ2VkID0gdHJ1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyBjb250cm9sbGVyIGhhcyBiZWVuIG1vZGlmaWVkIGFuZCBsb3NlcyBmb2N1cy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnN0IGNvbnRyb2xsZXIgPSBndWkuYWRkKCBvYmplY3QsICdwcm9wZXJ0eScgKTtcblx0ICpcblx0ICogY29udHJvbGxlci5vbkZpbmlzaENoYW5nZSggZnVuY3Rpb24oIHYgKSB7XG5cdCAqIFx0Y29uc29sZS5sb2coICdDaGFuZ2VzIGNvbXBsZXRlOiAnICsgdiApO1xuXHQgKiBcdGNvbnNvbGUuYXNzZXJ0KCB0aGlzID09PSBjb250cm9sbGVyICk7XG5cdCAqIH0gKTtcblx0ICovXG5cdG9uRmluaXNoQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uRmluaXNoQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlXG5cdFx0ICogZGlyZWN0bHkuIFVzZSB0aGUgYGNvbnRyb2xsZXIub25GaW5pc2hDaGFuZ2UoIGNhbGxiYWNrIClgIG1ldGhvZCBpbnN0ZWFkLlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLl9vbkZpbmlzaENoYW5nZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3VsZCBiZSBjYWxsZWQgYnkgQ29udHJvbGxlciB3aGVuIGl0cyB3aWRnZXRzIGxvc2UgZm9jdXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jYWxsT25GaW5pc2hDaGFuZ2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2NoYW5nZWQgKSB7XG5cblx0XHRcdHRoaXMucGFyZW50Ll9jYWxsT25GaW5pc2hDaGFuZ2UoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCB0aGlzLl9vbkZpbmlzaENoYW5nZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLl9vbkZpbmlzaENoYW5nZS5jYWxsKCB0aGlzLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuX2NoYW5nZWQgPSBmYWxzZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbnRyb2xsZXIgYmFjayB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRyZXNldCgpIHtcblx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLmluaXRpYWxWYWx1ZSApO1xuXHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdGhpcyBjb250cm9sbGVyLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnRyb2xsZXIuZW5hYmxlKCk7XG5cdCAqIGNvbnRyb2xsZXIuZW5hYmxlKCBmYWxzZSApOyAvLyBkaXNhYmxlXG5cdCAqIGNvbnRyb2xsZXIuZW5hYmxlKCBjb250cm9sbGVyLl9kaXNhYmxlZCApOyAvLyB0b2dnbGVcblx0ICovXG5cdGVuYWJsZSggZW5hYmxlZCA9IHRydWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzYWJsZSggIWVuYWJsZWQgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnRyb2xsZXIuZGlzYWJsZSgpO1xuXHQgKiBjb250cm9sbGVyLmRpc2FibGUoIGZhbHNlICk7IC8vIGVuYWJsZVxuXHQgKiBjb250cm9sbGVyLmRpc2FibGUoICFjb250cm9sbGVyLl9kaXNhYmxlZCApOyAvLyB0b2dnbGVcblx0ICovXG5cdGRpc2FibGUoIGRpc2FibGVkID0gdHJ1ZSApIHtcblxuXHRcdGlmICggZGlzYWJsZWQgPT09IHRoaXMuX2Rpc2FibGVkICkgcmV0dXJuIHRoaXM7XG5cblx0XHR0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoICdkaXNhYmxlZCcsIGRpc2FibGVkICk7XG5cdFx0dGhpcy4kZGlzYWJsZS50b2dnbGVBdHRyaWJ1dGUoICdkaXNhYmxlZCcsIGRpc2FibGVkICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3dzIHRoZSBDb250cm9sbGVyIGFmdGVyIGl0J3MgYmVlbiBoaWRkZW4uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogY29udHJvbGxlci5zaG93KCk7XG5cdCAqIGNvbnRyb2xsZXIuc2hvdyggZmFsc2UgKTsgLy8gaGlkZVxuXHQgKiBjb250cm9sbGVyLnNob3coIGNvbnRyb2xsZXIuX2hpZGRlbiApOyAvLyB0b2dnbGVcblx0ICovXG5cdHNob3coIHNob3cgPSB0cnVlICkge1xuXG5cdFx0dGhpcy5faGlkZGVuID0gIXNob3c7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2hpZGRlbiA/ICdub25lJyA6ICcnO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBIaWRlcyB0aGUgQ29udHJvbGxlci5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRoaWRlKCkge1xuXHRcdHJldHVybiB0aGlzLnNob3coIGZhbHNlICk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGlzIGNvbnRyb2xsZXIgaW50byBhIGRyb3Bkb3duIG9mIG9wdGlvbnMuXG5cdCAqXG5cdCAqIENhbGxpbmcgdGhpcyBtZXRob2Qgb24gYW4gb3B0aW9uIGNvbnRyb2xsZXIgd2lsbCBzaW1wbHkgdXBkYXRlIHRoZSBvcHRpb25zLiBIb3dldmVyLCBpZiB0aGlzXG5cdCAqIGNvbnRyb2xsZXIgd2FzIG5vdCBhbHJlYWR5IGFuIG9wdGlvbiBjb250cm9sbGVyLCBvbGQgcmVmZXJlbmNlcyB0byB0aGlzIGNvbnRyb2xsZXIgYXJlXG5cdCAqIGRlc3Ryb3llZCwgYW5kIGEgbmV3IGNvbnRyb2xsZXIgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgR1VJLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBzYWZlIHVzYWdlXG5cdCAqXG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AxJyApLm9wdGlvbnMoIFsgJ2EnLCAnYicsICdjJyBdICk7XG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AyJyApLm9wdGlvbnMoIHsgQmlnOiAxMCwgU21hbGw6IDEgfSApO1xuXHQgKiBndWkuYWRkKCBvYmosICdwcm9wMycgKTtcblx0ICpcblx0ICogLy8gZGFuZ2VyXG5cdCAqXG5cdCAqIGNvbnN0IGN0cmwxID0gZ3VpLmFkZCggb2JqLCAncHJvcDEnICk7XG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AyJyApO1xuXHQgKlxuXHQgKiAvLyBjYWxsaW5nIG9wdGlvbnMgb3V0IG9mIG9yZGVyIGFkZHMgYSBuZXcgY29udHJvbGxlciB0byB0aGUgZW5kLi4uXG5cdCAqIGNvbnN0IGN0cmwyID0gY3RybDEub3B0aW9ucyggWyAnYScsICdiJywgJ2MnIF0gKTtcblx0ICpcblx0ICogLy8gLi4uYW5kIGN0cmwxIG5vdyByZWZlcmVuY2VzIGEgY29udHJvbGxlciB0aGF0IGRvZXNuJ3QgZXhpc3Rcblx0ICogYXNzZXJ0KCBjdHJsMiAhPT0gY3RybDEgKVxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7Q29udHJvbGxlcn1cblx0ICovXG5cdG9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IHRoaXMucGFyZW50LmFkZCggdGhpcy5vYmplY3QsIHRoaXMucHJvcGVydHksIG9wdGlvbnMgKTtcblx0XHRjb250cm9sbGVyLm5hbWUoIHRoaXMuX25hbWUgKTtcblx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRyZXR1cm4gY29udHJvbGxlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBtaW5pbXVtIHZhbHVlLiBPbmx5IHdvcmtzIG9uIG51bWJlciBjb250cm9sbGVycy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdG1pbiggbWluICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1heGltdW0gdmFsdWUuIE9ubHkgd29ya3Mgb24gbnVtYmVyIGNvbnRyb2xsZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4XG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0bWF4KCBtYXggKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVmFsdWVzIHNldCBieSB0aGlzIGNvbnRyb2xsZXIgd2lsbCBiZSByb3VuZGVkIHRvIG11bHRpcGxlcyBvZiBgc3RlcGAuIE9ubHkgd29ya3Mgb24gbnVtYmVyXG5cdCAqIGNvbnRyb2xsZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RlcFxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHN0ZXAoIHN0ZXAgKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUm91bmRzIHRoZSBkaXNwbGF5ZWQgdmFsdWUgdG8gYSBmaXhlZCBudW1iZXIgb2YgZGVjaW1hbHMsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBhY3R1YWwgdmFsdWVcblx0ICogbGlrZSBgc3RlcCgpYC4gT25seSB3b3JrcyBvbiBudW1iZXIgY29udHJvbGxlcnMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5hZGQoIG9iamVjdCwgJ3Byb3BlcnR5JyApLmxpc3RlbigpLmRlY2ltYWxzKCA0ICk7XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsc1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGRlY2ltYWxzKCBkZWNpbWFscyApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyBgdXBkYXRlRGlzcGxheSgpYCBldmVyeSBhbmltYXRpb24gZnJhbWUuIFBhc3MgYGZhbHNlYCB0byBzdG9wIGxpc3RlbmluZy5cblx0ICogQHBhcmFtIHtib29sZWFufSBsaXN0ZW5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRsaXN0ZW4oIGxpc3RlbiA9IHRydWUgKSB7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgY29udHJvbGxlciBpcyBjdXJyZW50bHkgbGlzdGVuaW5nLiBEb24ndCBtb2RpZnkgdGhpcyB2YWx1ZVxuXHRcdCAqIGRpcmVjdGx5LiBVc2UgdGhlIGBjb250cm9sbGVyLmxpc3RlbiggdHJ1ZXxmYWxzZSApYCBtZXRob2QgaW5zdGVhZC5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9saXN0ZW5pbmcgPSBsaXN0ZW47XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbkNhbGxiYWNrSUQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9saXN0ZW5DYWxsYmFja0lEICk7XG5cdFx0XHR0aGlzLl9saXN0ZW5DYWxsYmFja0lEID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbGlzdGVuaW5nICkge1xuXHRcdFx0dGhpcy5fbGlzdGVuQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X2xpc3RlbkNhbGxiYWNrKCkge1xuXG5cdFx0dGhpcy5fbGlzdGVuQ2FsbGJhY2tJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGhpcy5fbGlzdGVuQ2FsbGJhY2sgKTtcblxuXHRcdC8vIFRvIHByZXZlbnQgZnJhbWVyYXRlIGxvc3MsIG1ha2Ugc3VyZSB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgYmVmb3JlIHVwZGF0aW5nIHRoZSBkaXNwbGF5LlxuXHRcdC8vIE5vdGU6IHNhdmUoKSBpcyB1c2VkIGhlcmUgaW5zdGVhZCBvZiBnZXRWYWx1ZSgpIG9ubHkgYmVjYXVzZSBvZiBDb2xvckNvbnRyb2xsZXIuIFRoZSAhPT0gb3BlcmF0b3Jcblx0XHQvLyB3b24ndCB3b3JrIGZvciBjb2xvciBvYmplY3RzIG9yIGFycmF5cywgYnV0IENvbG9yQ29udHJvbGxlci5zYXZlKCkgYWx3YXlzIHJldHVybnMgYSBzdHJpbmcuXG5cblx0XHRjb25zdCBjdXJWYWx1ZSA9IHRoaXMuc2F2ZSgpO1xuXG5cdFx0aWYgKCBjdXJWYWx1ZSAhPT0gdGhpcy5fbGlzdGVuUHJldlZhbHVlICkge1xuXHRcdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGlzdGVuUHJldlZhbHVlID0gY3VyVmFsdWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBvYmplY3RbIHByb3BlcnR5IF1gLlxuXHQgKiBAcmV0dXJucyB7YW55fVxuXHQgKi9cblx0Z2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMub2JqZWN0WyB0aGlzLnByb3BlcnR5IF07XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgYG9iamVjdFsgcHJvcGVydHkgXWAsIGludm9rZXMgYW55IGBvbkNoYW5nZWAgaGFuZGxlcnMgYW5kIHVwZGF0ZXMgdGhlIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHR0aGlzLm9iamVjdFsgdGhpcy5wcm9wZXJ0eSBdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2FsbE9uQ2hhbmdlKCk7XG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgZGlzcGxheSB0byBrZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgY3VycmVudCB2YWx1ZS4gVXNlZnVsIGZvciB1cGRhdGluZyB5b3VyXG5cdCAqIGNvbnRyb2xsZXJzIHdoZW4gdGhlaXIgdmFsdWVzIGhhdmUgYmVlbiBtb2RpZmllZCBvdXRzaWRlIG9mIHRoZSBHVUkuXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGxvYWQoIHZhbHVlICkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzYXZlKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhpcyBjb250cm9sbGVyIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHBhcmVudCBHVUkuXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMubGlzdGVuKCBmYWxzZSApO1xuXHRcdHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZiggdGhpcyApLCAxICk7XG5cdFx0dGhpcy5wYXJlbnQuY29udHJvbGxlcnMuc3BsaWNlKCB0aGlzLnBhcmVudC5jb250cm9sbGVycy5pbmRleE9mKCB0aGlzICksIDEgKTtcblx0XHR0aGlzLnBhcmVudC4kY2hpbGRyZW4ucmVtb3ZlQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXHR9XG5cbn1cblxuY2xhc3MgQm9vbGVhbkNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5ICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ2Jvb2xlYW4nLCAnbGFiZWwnICk7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ2NoZWNrYm94JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kaW5wdXQgKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLiRpbnB1dC5jaGVja2VkICk7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kaW5wdXQ7XG5cblx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHR9XG5cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHR0aGlzLiRpbnB1dC5jaGVja2VkID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3JTdHJpbmcoIHN0cmluZyApIHtcblxuXHRsZXQgbWF0Y2gsIHJlc3VsdDtcblxuXHRpZiAoIG1hdGNoID0gc3RyaW5nLm1hdGNoKCAvKCN8MHgpPyhbYS1mMC05XXs2fSkvaSApICkge1xuXG5cdFx0cmVzdWx0ID0gbWF0Y2hbIDIgXTtcblxuXHR9IGVsc2UgaWYgKCBtYXRjaCA9IHN0cmluZy5tYXRjaCggL3JnYlxcKFxccyooXFxkKilcXHMqLFxccyooXFxkKilcXHMqLFxccyooXFxkKilcXHMqXFwpLyApICkge1xuXG5cdFx0cmVzdWx0ID0gcGFyc2VJbnQoIG1hdGNoWyAxIF0gKS50b1N0cmluZyggMTYgKS5wYWRTdGFydCggMiwgMCApXG5cdFx0XHQrIHBhcnNlSW50KCBtYXRjaFsgMiBdICkudG9TdHJpbmcoIDE2ICkucGFkU3RhcnQoIDIsIDAgKVxuXHRcdFx0KyBwYXJzZUludCggbWF0Y2hbIDMgXSApLnRvU3RyaW5nKCAxNiApLnBhZFN0YXJ0KCAyLCAwICk7XG5cblx0fSBlbHNlIGlmICggbWF0Y2ggPSBzdHJpbmcubWF0Y2goIC9eIz8oW2EtZjAtOV0pKFthLWYwLTldKShbYS1mMC05XSkkL2kgKSApIHtcblxuXHRcdHJlc3VsdCA9IG1hdGNoWyAxIF0gKyBtYXRjaFsgMSBdICsgbWF0Y2hbIDIgXSArIG1hdGNoWyAyIF0gKyBtYXRjaFsgMyBdICsgbWF0Y2hbIDMgXTtcblxuXHR9XG5cblx0aWYgKCByZXN1bHQgKSB7XG5cdFx0cmV0dXJuICcjJyArIHJlc3VsdDtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG5jb25zdCBTVFJJTkcgPSB7XG5cdGlzUHJpbWl0aXZlOiB0cnVlLFxuXHRtYXRjaDogdiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycsXG5cdGZyb21IZXhTdHJpbmc6IG5vcm1hbGl6ZUNvbG9yU3RyaW5nLFxuXHR0b0hleFN0cmluZzogbm9ybWFsaXplQ29sb3JTdHJpbmdcbn07XG5cbmNvbnN0IElOVCA9IHtcblx0aXNQcmltaXRpdmU6IHRydWUsXG5cdG1hdGNoOiB2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyxcblx0ZnJvbUhleFN0cmluZzogc3RyaW5nID0+IHBhcnNlSW50KCBzdHJpbmcuc3Vic3RyaW5nKCAxICksIDE2ICksXG5cdHRvSGV4U3RyaW5nOiB2YWx1ZSA9PiAnIycgKyB2YWx1ZS50b1N0cmluZyggMTYgKS5wYWRTdGFydCggNiwgMCApXG59O1xuXG5jb25zdCBBUlJBWSA9IHtcblx0aXNQcmltaXRpdmU6IGZhbHNlLFxuXG5cdC8vIFRoZSBhcnJvdyBmdW5jdGlvbiBpcyBoZXJlIHRvIGFwcGVhc2UgdHJlZSBzaGFrZXJzIGxpa2UgZXNidWlsZCBvciB3ZWJwYWNrLlxuXHQvLyBTZWUgaHR0cHM6Ly9lc2J1aWxkLmdpdGh1Yi5pby9hcGkvI3RyZWUtc2hha2luZ1xuXHRtYXRjaDogdiA9PiBBcnJheS5pc0FycmF5KCB2ICksXG5cblx0ZnJvbUhleFN0cmluZyggc3RyaW5nLCB0YXJnZXQsIHJnYlNjYWxlID0gMSApIHtcblxuXHRcdGNvbnN0IGludCA9IElOVC5mcm9tSGV4U3RyaW5nKCBzdHJpbmcgKTtcblxuXHRcdHRhcmdldFsgMCBdID0gKCBpbnQgPj4gMTYgJiAyNTUgKSAvIDI1NSAqIHJnYlNjYWxlO1xuXHRcdHRhcmdldFsgMSBdID0gKCBpbnQgPj4gOCAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cdFx0dGFyZ2V0WyAyIF0gPSAoIGludCAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cblx0fSxcblx0dG9IZXhTdHJpbmcoIFsgciwgZywgYiBdLCByZ2JTY2FsZSA9IDEgKSB7XG5cblx0XHRyZ2JTY2FsZSA9IDI1NSAvIHJnYlNjYWxlO1xuXG5cdFx0Y29uc3QgaW50ID0gKCByICogcmdiU2NhbGUgKSA8PCAxNiBeXG5cdFx0XHQoIGcgKiByZ2JTY2FsZSApIDw8IDggXlxuXHRcdFx0KCBiICogcmdiU2NhbGUgKSA8PCAwO1xuXG5cdFx0cmV0dXJuIElOVC50b0hleFN0cmluZyggaW50ICk7XG5cblx0fVxufTtcblxuY29uc3QgT0JKRUNUID0ge1xuXHRpc1ByaW1pdGl2ZTogZmFsc2UsXG5cdG1hdGNoOiB2ID0+IE9iamVjdCggdiApID09PSB2LFxuXHRmcm9tSGV4U3RyaW5nKCBzdHJpbmcsIHRhcmdldCwgcmdiU2NhbGUgPSAxICkge1xuXG5cdFx0Y29uc3QgaW50ID0gSU5ULmZyb21IZXhTdHJpbmcoIHN0cmluZyApO1xuXG5cdFx0dGFyZ2V0LnIgPSAoIGludCA+PiAxNiAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cdFx0dGFyZ2V0LmcgPSAoIGludCA+PiA4ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblx0XHR0YXJnZXQuYiA9ICggaW50ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblxuXHR9LFxuXHR0b0hleFN0cmluZyggeyByLCBnLCBiIH0sIHJnYlNjYWxlID0gMSApIHtcblxuXHRcdHJnYlNjYWxlID0gMjU1IC8gcmdiU2NhbGU7XG5cblx0XHRjb25zdCBpbnQgPSAoIHIgKiByZ2JTY2FsZSApIDw8IDE2IF5cblx0XHRcdCggZyAqIHJnYlNjYWxlICkgPDwgOCBeXG5cdFx0XHQoIGIgKiByZ2JTY2FsZSApIDw8IDA7XG5cblx0XHRyZXR1cm4gSU5ULnRvSGV4U3RyaW5nKCBpbnQgKTtcblxuXHR9XG59O1xuXG5jb25zdCBGT1JNQVRTID0gWyBTVFJJTkcsIElOVCwgQVJSQVksIE9CSkVDVCBdO1xuXG5mdW5jdGlvbiBnZXRDb2xvckZvcm1hdCggdmFsdWUgKSB7XG5cdHJldHVybiBGT1JNQVRTLmZpbmQoIGZvcm1hdCA9PiBmb3JtYXQubWF0Y2goIHZhbHVlICkgKTtcbn1cblxuY2xhc3MgQ29sb3JDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgcmdiU2NhbGUgKSB7XG5cblx0XHRzdXBlciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCAnY29sb3InICk7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ2NvbG9yJyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgLTEgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHR0aGlzLiR0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuXHRcdHRoaXMuJHRleHQuc2V0QXR0cmlidXRlKCAndHlwZScsICd0ZXh0JyApO1xuXHRcdHRoaXMuJHRleHQuc2V0QXR0cmlidXRlKCAnc3BlbGxjaGVjaycsICdmYWxzZScgKTtcblx0XHR0aGlzLiR0ZXh0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJGRpc3BsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJGRpc3BsYXkuY2xhc3NMaXN0LmFkZCggJ2Rpc3BsYXknICk7XG5cblx0XHR0aGlzLiRkaXNwbGF5LmFwcGVuZENoaWxkKCB0aGlzLiRpbnB1dCApO1xuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kZGlzcGxheSApO1xuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kdGV4dCApO1xuXG5cdFx0dGhpcy5fZm9ybWF0ID0gZ2V0Q29sb3JGb3JtYXQoIHRoaXMuaW5pdGlhbFZhbHVlICk7XG5cdFx0dGhpcy5fcmdiU2NhbGUgPSByZ2JTY2FsZTtcblxuXHRcdHRoaXMuX2luaXRpYWxWYWx1ZUhleFN0cmluZyA9IHRoaXMuc2F2ZSgpO1xuXHRcdHRoaXMuX3RleHRGb2N1c2VkID0gZmFsc2U7XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9zZXRWYWx1ZUZyb21IZXhTdHJpbmcoIHRoaXMuJGlucHV0LnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiR0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsICgpID0+IHtcblx0XHRcdGNvbnN0IHRyeVBhcnNlID0gbm9ybWFsaXplQ29sb3JTdHJpbmcoIHRoaXMuJHRleHQudmFsdWUgKTtcblx0XHRcdGlmICggdHJ5UGFyc2UgKSB7XG5cdFx0XHRcdHRoaXMuX3NldFZhbHVlRnJvbUhleFN0cmluZyggdHJ5UGFyc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLiR0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsICgpID0+IHtcblx0XHRcdHRoaXMuX3RleHRGb2N1c2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMuJHRleHQuc2VsZWN0KCk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kdGV4dC5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsICgpID0+IHtcblx0XHRcdHRoaXMuX3RleHRGb2N1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiR0ZXh0O1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0fVxuXG5cdHJlc2V0KCkge1xuXHRcdHRoaXMuX3NldFZhbHVlRnJvbUhleFN0cmluZyggdGhpcy5faW5pdGlhbFZhbHVlSGV4U3RyaW5nICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfc2V0VmFsdWVGcm9tSGV4U3RyaW5nKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fZm9ybWF0LmlzUHJpbWl0aXZlICkge1xuXG5cdFx0XHRjb25zdCBuZXdWYWx1ZSA9IHRoaXMuX2Zvcm1hdC5mcm9tSGV4U3RyaW5nKCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSggbmV3VmFsdWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuX2Zvcm1hdC5mcm9tSGV4U3RyaW5nKCB2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9yZ2JTY2FsZSApO1xuXHRcdFx0dGhpcy5fY2FsbE9uQ2hhbmdlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2F2ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm9ybWF0LnRvSGV4U3RyaW5nKCB0aGlzLmdldFZhbHVlKCksIHRoaXMuX3JnYlNjYWxlICk7XG5cdH1cblxuXHRsb2FkKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zZXRWYWx1ZUZyb21IZXhTdHJpbmcoIHZhbHVlICk7XG5cdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR1cGRhdGVEaXNwbGF5KCkge1xuXHRcdHRoaXMuJGlucHV0LnZhbHVlID0gdGhpcy5fZm9ybWF0LnRvSGV4U3RyaW5nKCB0aGlzLmdldFZhbHVlKCksIHRoaXMuX3JnYlNjYWxlICk7XG5cdFx0aWYgKCAhdGhpcy5fdGV4dEZvY3VzZWQgKSB7XG5cdFx0XHR0aGlzLiR0ZXh0LnZhbHVlID0gdGhpcy4kaW5wdXQudmFsdWUuc3Vic3RyaW5nKCAxICk7XG5cdFx0fVxuXHRcdHRoaXMuJGRpc3BsYXkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy4kaW5wdXQudmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5jbGFzcyBGdW5jdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5ICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ2Z1bmN0aW9uJyApO1xuXG5cdFx0Ly8gQnV0dG9ucyBhcmUgdGhlIG9ubHkgY2FzZSB3aGVyZSB3aWRnZXQgY29udGFpbnMgbmFtZVxuXHRcdHRoaXMuJGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdidXR0b24nICk7XG5cdFx0dGhpcy4kYnV0dG9uLmFwcGVuZENoaWxkKCB0aGlzLiRuYW1lICk7XG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRidXR0b24gKTtcblxuXHRcdHRoaXMuJGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBlID0+IHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuZ2V0VmFsdWUoKS5jYWxsKCB0aGlzLm9iamVjdCApO1xuXHRcdFx0dGhpcy5fY2FsbE9uQ2hhbmdlKCk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gZW5hYmxlcyA6YWN0aXZlIHBzZXVkbyBjbGFzcyBvbiBtb2JpbGVcblx0XHR0aGlzLiRidXR0b24uYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCAoKSA9PiB7fSwgeyBwYXNzaXZlOiB0cnVlIH0gKTtcblxuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiRidXR0b247XG5cblx0fVxuXG59XG5cbmNsYXNzIE51bWJlckNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCApIHtcblxuXHRcdHN1cGVyKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksICdudW1iZXInICk7XG5cblx0XHR0aGlzLl9pbml0SW5wdXQoKTtcblxuXHRcdHRoaXMubWluKCBtaW4gKTtcblx0XHR0aGlzLm1heCggbWF4ICk7XG5cblx0XHRjb25zdCBzdGVwRXhwbGljaXQgPSBzdGVwICE9PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zdGVwKCBzdGVwRXhwbGljaXQgPyBzdGVwIDogdGhpcy5fZ2V0SW1wbGljaXRTdGVwKCksIHN0ZXBFeHBsaWNpdCApO1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0fVxuXG5cdGRlY2ltYWxzKCBkZWNpbWFscyApIHtcblx0XHR0aGlzLl9kZWNpbWFscyA9IGRlY2ltYWxzO1xuXHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bWluKCBtaW4gKSB7XG5cdFx0dGhpcy5fbWluID0gbWluO1xuXHRcdHRoaXMuX29uVXBkYXRlTWluTWF4KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRtYXgoIG1heCApIHtcblx0XHR0aGlzLl9tYXggPSBtYXg7XG5cdFx0dGhpcy5fb25VcGRhdGVNaW5NYXgoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHN0ZXAoIHN0ZXAsIGV4cGxpY2l0ID0gdHJ1ZSApIHtcblx0XHR0aGlzLl9zdGVwID0gc3RlcDtcblx0XHR0aGlzLl9zdGVwRXhwbGljaXQgPSBleHBsaWNpdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHVwZGF0ZURpc3BsYXkoKSB7XG5cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRcdGlmICggdGhpcy5faGFzU2xpZGVyICkge1xuXG5cdFx0XHRsZXQgcGVyY2VudCA9ICggdmFsdWUgLSB0aGlzLl9taW4gKSAvICggdGhpcy5fbWF4IC0gdGhpcy5fbWluICk7XG5cdFx0XHRwZXJjZW50ID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBwZXJjZW50LCAxICkgKTtcblxuXHRcdFx0dGhpcy4kZmlsbC5zdHlsZS53aWR0aCA9IHBlcmNlbnQgKiAxMDAgKyAnJSc7XG5cblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLl9pbnB1dEZvY3VzZWQgKSB7XG5cdFx0XHR0aGlzLiRpbnB1dC52YWx1ZSA9IHRoaXMuX2RlY2ltYWxzID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLnRvRml4ZWQoIHRoaXMuX2RlY2ltYWxzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9pbml0SW5wdXQoKSB7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ3RleHQnICk7XG5cdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy4kbmFtZS5pZCApO1xuXG5cdFx0Ly8gT24gdG91Y2ggZGV2aWNlcyBvbmx5LCB1c2UgaW5wdXRbdHlwZT1udW1iZXJdIHRvIGZvcmNlIGEgbnVtZXJpYyBrZXlib2FyZC5cblx0XHQvLyBJZGVhbGx5IHdlIGNvdWxkIHVzZSBvbmUgaW5wdXQgdHlwZSBldmVyeXdoZXJlLCBidXQgW3R5cGU9bnVtYmVyXSBoYXMgcXVpcmtzXG5cdFx0Ly8gb24gZGVza3RvcCwgYW5kIFtpbnB1dG1vZGU9ZGVjaW1hbF0gaGFzIHF1aXJrcyBvbiBpT1MuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW9yZ2VhbHdheXMvbGlsLWd1aS9wdWxsLzE2XG5cblx0XHRjb25zdCBpc1RvdWNoID0gd2luZG93Lm1hdGNoTWVkaWEoICcocG9pbnRlcjogY29hcnNlKScgKS5tYXRjaGVzO1xuXG5cdFx0aWYgKCBpc1RvdWNoICkge1xuXHRcdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAndHlwZScsICdudW1iZXInICk7XG5cdFx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdzdGVwJywgJ2FueScgKTtcblx0XHR9XG5cblx0XHR0aGlzLiR3aWRnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuJGlucHV0ICk7XG5cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kaW5wdXQ7XG5cblx0XHRjb25zdCBvbklucHV0ID0gKCkgPT4ge1xuXG5cdFx0XHRsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KCB0aGlzLiRpbnB1dC52YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHRoaXMuX3N0ZXBFeHBsaWNpdCApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9zbmFwKCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLl9jbGFtcCggdmFsdWUgKSApO1xuXG5cdFx0fTtcblxuXHRcdC8vIEtleXMgJiBtb3VzZSB3aGVlbFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Y29uc3QgaW5jcmVtZW50ID0gZGVsdGEgPT4ge1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoIHRoaXMuJGlucHV0LnZhbHVlICk7XG5cblx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3NuYXBDbGFtcFNldFZhbHVlKCB2YWx1ZSArIGRlbHRhICk7XG5cblx0XHRcdC8vIEZvcmNlIHRoZSBpbnB1dCB0byB1cGRhdGVEaXNwbGF5IHdoZW4gaXQncyBmb2N1c2VkXG5cdFx0XHR0aGlzLiRpbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRcdH07XG5cblx0XHRjb25zdCBvbktleURvd24gPSBlID0+IHtcblx0XHRcdC8vIFVzaW5nIGBlLmtleWAgaW5zdGVhZCBvZiBgZS5jb2RlYCBhbHNvIGNhdGNoZXMgTnVtcGFkRW50ZXJcblx0XHRcdGlmICggZS5rZXkgPT09ICdFbnRlcicgKSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LmJsdXIoKTtcblx0XHRcdH1cblx0XHRcdGlmICggZS5jb2RlID09PSAnQXJyb3dVcCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0aW5jcmVtZW50KCB0aGlzLl9zdGVwICogdGhpcy5fYXJyb3dLZXlNdWx0aXBsaWVyKCBlICkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggZS5jb2RlID09PSAnQXJyb3dEb3duJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRpbmNyZW1lbnQoIHRoaXMuX3N0ZXAgKiB0aGlzLl9hcnJvd0tleU11bHRpcGxpZXIoIGUgKSAqIC0xICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uV2hlZWwgPSBlID0+IHtcblx0XHRcdGlmICggdGhpcy5faW5wdXRGb2N1c2VkICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGluY3JlbWVudCggdGhpcy5fc3RlcCAqIHRoaXMuX25vcm1hbGl6ZU1vdXNlV2hlZWwoIGUgKSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBWZXJ0aWNhbCBkcmFnXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRsZXQgdGVzdGluZ0ZvclZlcnRpY2FsRHJhZyA9IGZhbHNlLFxuXHRcdFx0aW5pdENsaWVudFgsXG5cdFx0XHRpbml0Q2xpZW50WSxcblx0XHRcdHByZXZDbGllbnRZLFxuXHRcdFx0aW5pdFZhbHVlLFxuXHRcdFx0ZHJhZ0RlbHRhO1xuXG5cdFx0Ly8gT25jZSB0aGUgbW91c2UgaXMgZHJhZ2dlZCBtb3JlIHRoYW4gRFJBR19USFJFU0ggcHggb24gYW55IGF4aXMsIHdlIGRlY2lkZVxuXHRcdC8vIG9uIHRoZSB1c2VyJ3MgaW50ZW50OiBob3Jpem9udGFsIG1lYW5zIGhpZ2hsaWdodCwgdmVydGljYWwgbWVhbnMgZHJhZy5cblx0XHRjb25zdCBEUkFHX1RIUkVTSCA9IDU7XG5cblx0XHRjb25zdCBvbk1vdXNlRG93biA9IGUgPT4ge1xuXG5cdFx0XHRpbml0Q2xpZW50WCA9IGUuY2xpZW50WDtcblx0XHRcdGluaXRDbGllbnRZID0gcHJldkNsaWVudFkgPSBlLmNsaWVudFk7XG5cdFx0XHR0ZXN0aW5nRm9yVmVydGljYWxEcmFnID0gdHJ1ZTtcblxuXHRcdFx0aW5pdFZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0ZHJhZ0RlbHRhID0gMDtcblxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwICk7XG5cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25Nb3VzZU1vdmUgPSBlID0+IHtcblxuXHRcdFx0aWYgKCB0ZXN0aW5nRm9yVmVydGljYWxEcmFnICkge1xuXG5cdFx0XHRcdGNvbnN0IGR4ID0gZS5jbGllbnRYIC0gaW5pdENsaWVudFg7XG5cdFx0XHRcdGNvbnN0IGR5ID0gZS5jbGllbnRZIC0gaW5pdENsaWVudFk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZHkgKSA+IERSQUdfVEhSRVNIICkge1xuXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHRoaXMuJGlucHV0LmJsdXIoKTtcblx0XHRcdFx0XHR0ZXN0aW5nRm9yVmVydGljYWxEcmFnID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggdHJ1ZSwgJ3ZlcnRpY2FsJyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIE1hdGguYWJzKCBkeCApID4gRFJBR19USFJFU0ggKSB7XG5cblx0XHRcdFx0XHRvbk1vdXNlVXAoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhpcyBpc24ndCBhbiBlbHNlIHNvIHRoYXQgdGhlIGZpcnN0IG1vdmUgY291bnRzIHRvd2FyZHMgZHJhZ0RlbHRhXG5cdFx0XHRpZiAoICF0ZXN0aW5nRm9yVmVydGljYWxEcmFnICkge1xuXG5cdFx0XHRcdGNvbnN0IGR5ID0gZS5jbGllbnRZIC0gcHJldkNsaWVudFk7XG5cblx0XHRcdFx0ZHJhZ0RlbHRhIC09IGR5ICogdGhpcy5fc3RlcCAqIHRoaXMuX2Fycm93S2V5TXVsdGlwbGllciggZSApO1xuXG5cdFx0XHRcdC8vIENsYW1wIGRyYWdEZWx0YSBzbyB3ZSBkb24ndCBoYXZlICdkZWFkIHNwYWNlJyBhZnRlciBkcmFnZ2luZyBwYXN0IGJvdW5kcy5cblx0XHRcdFx0Ly8gV2UncmUgb2theSB3aXRoIHRoZSBmYWN0IHRoYXQgYm91bmRzIGNhbiBiZSB1bmRlZmluZWQgaGVyZS5cblx0XHRcdFx0aWYgKCBpbml0VmFsdWUgKyBkcmFnRGVsdGEgPiB0aGlzLl9tYXggKSB7XG5cdFx0XHRcdFx0ZHJhZ0RlbHRhID0gdGhpcy5fbWF4IC0gaW5pdFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbml0VmFsdWUgKyBkcmFnRGVsdGEgPCB0aGlzLl9taW4gKSB7XG5cdFx0XHRcdFx0ZHJhZ0RlbHRhID0gdGhpcy5fbWluIC0gaW5pdFZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fc25hcENsYW1wU2V0VmFsdWUoIGluaXRWYWx1ZSArIGRyYWdEZWx0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByZXZDbGllbnRZID0gZS5jbGllbnRZO1xuXG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIGZhbHNlLCAndmVydGljYWwnICk7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUgKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCApO1xuXHRcdH07XG5cblx0XHQvLyBGb2N1cyBzdGF0ZSAmIG9uRmluaXNoQ2hhbmdlXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRjb25zdCBvbkZvY3VzID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5faW5wdXRGb2N1c2VkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25CbHVyID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5faW5wdXRGb2N1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBvbklucHV0ICk7XG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24gKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0gKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24gKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBvbkZvY3VzICk7XG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBvbkJsdXIgKTtcblxuXHR9XG5cblx0X2luaXRTbGlkZXIoKSB7XG5cblx0XHR0aGlzLl9oYXNTbGlkZXIgPSB0cnVlO1xuXG5cdFx0Ly8gQnVpbGQgRE9NXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHR0aGlzLiRzbGlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJHNsaWRlci5jbGFzc0xpc3QuYWRkKCAnc2xpZGVyJyApO1xuXG5cdFx0dGhpcy4kZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kZmlsbC5jbGFzc0xpc3QuYWRkKCAnZmlsbCcgKTtcblxuXHRcdHRoaXMuJHNsaWRlci5hcHBlbmRDaGlsZCggdGhpcy4kZmlsbCApO1xuXHRcdHRoaXMuJHdpZGdldC5pbnNlcnRCZWZvcmUoIHRoaXMuJHNsaWRlciwgdGhpcy4kaW5wdXQgKTtcblxuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnaGFzU2xpZGVyJyApO1xuXG5cdFx0Ly8gTWFwIGNsaWVudFggdG8gdmFsdWVcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdGNvbnN0IG1hcCA9ICggdiwgYSwgYiwgYywgZCApID0+IHtcblx0XHRcdHJldHVybiAoIHYgLSBhICkgLyAoIGIgLSBhICkgKiAoIGQgLSBjICkgKyBjO1xuXHRcdH07XG5cblx0XHRjb25zdCBzZXRWYWx1ZUZyb21YID0gY2xpZW50WCA9PiB7XG5cdFx0XHRjb25zdCByZWN0ID0gdGhpcy4kc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0bGV0IHZhbHVlID0gbWFwKCBjbGllbnRYLCByZWN0LmxlZnQsIHJlY3QucmlnaHQsIHRoaXMuX21pbiwgdGhpcy5fbWF4ICk7XG5cdFx0XHR0aGlzLl9zbmFwQ2xhbXBTZXRWYWx1ZSggdmFsdWUgKTtcblx0XHR9O1xuXG5cdFx0Ly8gTW91c2UgZHJhZ1xuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Y29uc3QgbW91c2VEb3duID0gZSA9PiB7XG5cdFx0XHR0aGlzLl9zZXREcmFnZ2luZ1N0eWxlKCB0cnVlICk7XG5cdFx0XHRzZXRWYWx1ZUZyb21YKCBlLmNsaWVudFggKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBtb3VzZVVwICk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IG1vdXNlTW92ZSA9IGUgPT4ge1xuXHRcdFx0c2V0VmFsdWVGcm9tWCggZS5jbGllbnRYICk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IG1vdXNlVXAgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdXNlTW92ZSApO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgbW91c2VVcCApO1xuXHRcdH07XG5cblx0XHQvLyBUb3VjaCBkcmFnXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRsZXQgdGVzdGluZ0ZvclNjcm9sbCA9IGZhbHNlLCBwcmV2Q2xpZW50WCwgcHJldkNsaWVudFk7XG5cblx0XHRjb25zdCBiZWdpblRvdWNoRHJhZyA9IGUgPT4ge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggdHJ1ZSApO1xuXHRcdFx0c2V0VmFsdWVGcm9tWCggZS50b3VjaGVzWyAwIF0uY2xpZW50WCApO1xuXHRcdFx0dGVzdGluZ0ZvclNjcm9sbCA9IGZhbHNlO1xuXHRcdH07XG5cblx0XHRjb25zdCBvblRvdWNoU3RhcnQgPSBlID0+IHtcblxuXHRcdFx0aWYgKCBlLnRvdWNoZXMubGVuZ3RoID4gMSApIHJldHVybjtcblxuXHRcdFx0Ly8gSWYgd2UncmUgaW4gYSBzY3JvbGxhYmxlIGNvbnRhaW5lciwgd2Ugc2hvdWxkIHdhaXQgZm9yIHRoZSBmaXJzdFxuXHRcdFx0Ly8gdG91Y2htb3ZlIHRvIHNlZSBpZiB0aGUgdXNlciBpcyB0cnlpbmcgdG8gc2xpZGUgb3Igc2Nyb2xsLlxuXHRcdFx0aWYgKCB0aGlzLl9oYXNTY3JvbGxCYXIgKSB7XG5cblx0XHRcdFx0cHJldkNsaWVudFggPSBlLnRvdWNoZXNbIDAgXS5jbGllbnRYO1xuXHRcdFx0XHRwcmV2Q2xpZW50WSA9IGUudG91Y2hlc1sgMCBdLmNsaWVudFk7XG5cdFx0XHRcdHRlc3RpbmdGb3JTY3JvbGwgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UgY2FuIHNldCB0aGUgdmFsdWUgc3RyYWlnaHQgYXdheSBvbiB0b3VjaHN0YXJ0LlxuXHRcdFx0XHRiZWdpblRvdWNoRHJhZyggZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQgKTtcblxuXHRcdH07XG5cblx0XHRjb25zdCBvblRvdWNoTW92ZSA9IGUgPT4ge1xuXG5cdFx0XHRpZiAoIHRlc3RpbmdGb3JTY3JvbGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgZHggPSBlLnRvdWNoZXNbIDAgXS5jbGllbnRYIC0gcHJldkNsaWVudFg7XG5cdFx0XHRcdGNvbnN0IGR5ID0gZS50b3VjaGVzWyAwIF0uY2xpZW50WSAtIHByZXZDbGllbnRZO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIGR4ICkgPiBNYXRoLmFicyggZHkgKSApIHtcblxuXHRcdFx0XHRcdC8vIFdlIG1vdmVkIGhvcml6b250YWxseSwgc2V0IHRoZSB2YWx1ZSBhbmQgc3RvcCBjaGVja2luZy5cblx0XHRcdFx0XHRiZWdpblRvdWNoRHJhZyggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBUaGlzIHdhcywgaW4gZmFjdCwgYW4gYXR0ZW1wdCB0byBzY3JvbGwuIEFib3J0LlxuXHRcdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUgKTtcblx0XHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHNldFZhbHVlRnJvbVgoIGUudG91Y2hlc1sgMCBdLmNsaWVudFggKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uVG91Y2hFbmQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCApO1xuXHRcdH07XG5cblx0XHQvLyBNb3VzZSB3aGVlbFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Ly8gV2UgaGF2ZSB0byB1c2UgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdG8gY2FsbCBvbkZpbmlzaENoYW5nZSBiZWNhdXNlXG5cdFx0Ly8gdGhlcmUncyBubyB3YXkgdG8gdGVsbCB3aGVuIHRoZSB1c2VyIGlzIFwiZG9uZVwiIG1vdXNlLXdoZWVsaW5nLlxuXHRcdGNvbnN0IGNhbGxPbkZpbmlzaENoYW5nZSA9IHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZS5iaW5kKCB0aGlzICk7XG5cdFx0Y29uc3QgV0hFRUxfREVCT1VOQ0VfVElNRSA9IDQwMDtcblx0XHRsZXQgd2hlZWxGaW5pc2hDaGFuZ2VUaW1lb3V0O1xuXG5cdFx0Y29uc3Qgb25XaGVlbCA9IGUgPT4ge1xuXG5cdFx0XHQvLyBpZ25vcmUgdmVydGljYWwgd2hlZWxzIGlmIHRoZXJlJ3MgYSBzY3JvbGxiYXJcblx0XHRcdGNvbnN0IGlzVmVydGljYWwgPSBNYXRoLmFicyggZS5kZWx0YVggKSA8IE1hdGguYWJzKCBlLmRlbHRhWSApO1xuXHRcdFx0aWYgKCBpc1ZlcnRpY2FsICYmIHRoaXMuX2hhc1Njcm9sbEJhciApIHJldHVybjtcblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHQvLyBzZXQgdmFsdWVcblx0XHRcdGNvbnN0IGRlbHRhID0gdGhpcy5fbm9ybWFsaXplTW91c2VXaGVlbCggZSApICogdGhpcy5fc3RlcDtcblx0XHRcdHRoaXMuX3NuYXBDbGFtcFNldFZhbHVlKCB0aGlzLmdldFZhbHVlKCkgKyBkZWx0YSApO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgaW5wdXQgdG8gdXBkYXRlRGlzcGxheSB3aGVuIGl0J3MgZm9jdXNlZFxuXHRcdFx0dGhpcy4kaW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cblx0XHRcdC8vIGRlYm91bmNlIG9uRmluaXNoQ2hhbmdlXG5cdFx0XHRjbGVhclRpbWVvdXQoIHdoZWVsRmluaXNoQ2hhbmdlVGltZW91dCApO1xuXHRcdFx0d2hlZWxGaW5pc2hDaGFuZ2VUaW1lb3V0ID0gc2V0VGltZW91dCggY2FsbE9uRmluaXNoQ2hhbmdlLCBXSEVFTF9ERUJPVU5DRV9USU1FICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy4kc2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBtb3VzZURvd24gKTtcblx0XHR0aGlzLiRzbGlkZXIuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogZmFsc2UgfSApO1xuXHRcdHRoaXMuJHNsaWRlci5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0gKTtcblxuXHR9XG5cblx0X3NldERyYWdnaW5nU3R5bGUoIGFjdGl2ZSwgYXhpcyA9ICdob3Jpem9udGFsJyApIHtcblx0XHRpZiAoIHRoaXMuJHNsaWRlciApIHtcblx0XHRcdHRoaXMuJHNsaWRlci5jbGFzc0xpc3QudG9nZ2xlKCAnYWN0aXZlJywgYWN0aXZlICk7XG5cdFx0fVxuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSggJ2xpbC1ndWktZHJhZ2dpbmcnLCBhY3RpdmUgKTtcblx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoIGBsaWwtZ3VpLSR7YXhpc31gLCBhY3RpdmUgKTtcblx0fVxuXG5cdF9nZXRJbXBsaWNpdFN0ZXAoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2hhc01pbiAmJiB0aGlzLl9oYXNNYXggKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzLl9tYXggLSB0aGlzLl9taW4gKSAvIDEwMDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDAuMTtcblxuXHR9XG5cblx0X29uVXBkYXRlTWluTWF4KCkge1xuXG5cdFx0aWYgKCAhdGhpcy5faGFzU2xpZGVyICYmIHRoaXMuX2hhc01pbiAmJiB0aGlzLl9oYXNNYXggKSB7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UncmUgaGVhcmluZyBhYm91dCBtaW4gYW5kIG1heFxuXHRcdFx0Ly8gYW5kIHdlIGhhdmVuJ3QgZXhwbGljaXRseSBzdGF0ZWQgd2hhdCBvdXIgc3RlcCBpcywgbGV0J3Ncblx0XHRcdC8vIHVwZGF0ZSB0aGF0IHRvby5cblx0XHRcdGlmICggIXRoaXMuX3N0ZXBFeHBsaWNpdCApIHtcblx0XHRcdFx0dGhpcy5zdGVwKCB0aGlzLl9nZXRJbXBsaWNpdFN0ZXAoKSwgZmFsc2UgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faW5pdFNsaWRlcigpO1xuXHRcdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9ub3JtYWxpemVNb3VzZVdoZWVsKCBlICkge1xuXG5cdFx0bGV0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IGU7XG5cblx0XHQvLyBTYWZhcmkgYW5kIENocm9tZSByZXBvcnQgd2VpcmQgbm9uLWludGVncmFsIHZhbHVlcyBmb3IgYSBub3RjaGVkIHdoZWVsLFxuXHRcdC8vIGJ1dCBzdGlsbCBleHBvc2UgYWN0dWFsIGxpbmVzIHNjcm9sbGVkIHZpYSB3aGVlbERlbHRhLiBOb3RjaGVkIHdoZWVsc1xuXHRcdC8vIHNob3VsZCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFzIGFycm93IGtleXMuXG5cdFx0aWYgKCBNYXRoLmZsb29yKCBlLmRlbHRhWSApICE9PSBlLmRlbHRhWSAmJiBlLndoZWVsRGVsdGEgKSB7XG5cdFx0XHRkZWx0YVggPSAwO1xuXHRcdFx0ZGVsdGFZID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcblx0XHRcdGRlbHRhWSAqPSB0aGlzLl9zdGVwRXhwbGljaXQgPyAxIDogMTA7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2hlZWwgPSBkZWx0YVggKyAtZGVsdGFZO1xuXG5cdFx0cmV0dXJuIHdoZWVsO1xuXG5cdH1cblxuXHRfYXJyb3dLZXlNdWx0aXBsaWVyKCBlICkge1xuXG5cdFx0bGV0IG11bHQgPSB0aGlzLl9zdGVwRXhwbGljaXQgPyAxIDogMTA7XG5cblx0XHRpZiAoIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRtdWx0ICo9IDEwO1xuXHRcdH0gZWxzZSBpZiAoIGUuYWx0S2V5ICkge1xuXHRcdFx0bXVsdCAvPSAxMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbXVsdDtcblxuXHR9XG5cblx0X3NuYXAoIHZhbHVlICkge1xuXG5cdFx0Ly8gVGhpcyB3b3VsZCBiZSB0aGUgbG9naWNhbCB3YXkgdG8gZG8gdGhpbmdzLCBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLlxuXHRcdC8vIHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAvIHRoaXMuX3N0ZXAgKSAqIHRoaXMuX3N0ZXA7XG5cblx0XHQvLyBVc2luZyBpbnZlcnNlIHN0ZXAgc29sdmVzIGEgbG90IG9mIHRoZW0sIGJ1dCBub3QgYWxsXG5cdFx0Ly8gY29uc3QgaW52ZXJzZVN0ZXAgPSAxIC8gdGhpcy5fc3RlcDtcblx0XHQvLyByZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiBpbnZlcnNlU3RlcCApIC8gaW52ZXJzZVN0ZXA7XG5cblx0XHQvLyBOb3QgaGFwcHkgYWJvdXQgdGhpcywgYnV0IGhhdmVuJ3Qgc2VlbiBpdCBicmVhay5cblx0XHRjb25zdCByID0gTWF0aC5yb3VuZCggdmFsdWUgLyB0aGlzLl9zdGVwICkgKiB0aGlzLl9zdGVwO1xuXHRcdHJldHVybiBwYXJzZUZsb2F0KCByLnRvUHJlY2lzaW9uKCAxNSApICk7XG5cblx0fVxuXG5cdF9jbGFtcCggdmFsdWUgKSB7XG5cdFx0Ly8gZWl0aGVyIGNvbmRpdGlvbiBpcyBmYWxzZSBpZiBtaW4gb3IgbWF4IGlzIHVuZGVmaW5lZFxuXHRcdGlmICggdmFsdWUgPCB0aGlzLl9taW4gKSB2YWx1ZSA9IHRoaXMuX21pbjtcblx0XHRpZiAoIHZhbHVlID4gdGhpcy5fbWF4ICkgdmFsdWUgPSB0aGlzLl9tYXg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0X3NuYXBDbGFtcFNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLl9jbGFtcCggdGhpcy5fc25hcCggdmFsdWUgKSApICk7XG5cdH1cblxuXHRnZXQgX2hhc1Njcm9sbEJhcigpIHtcblx0XHRjb25zdCByb290ID0gdGhpcy5wYXJlbnQucm9vdC4kY2hpbGRyZW47XG5cdFx0cmV0dXJuIHJvb3Quc2Nyb2xsSGVpZ2h0ID4gcm9vdC5jbGllbnRIZWlnaHQ7XG5cdH1cblxuXHRnZXQgX2hhc01pbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHRnZXQgX2hhc01heCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4ICE9PSB1bmRlZmluZWQ7XG5cdH1cblxufVxuXG5jbGFzcyBPcHRpb25Db250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgb3B0aW9ucyApIHtcblxuXHRcdHN1cGVyKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksICdvcHRpb24nICk7XG5cblx0XHR0aGlzLiRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc2VsZWN0JyApO1xuXHRcdHRoaXMuJHNlbGVjdC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHR0aGlzLiRkaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR0aGlzLiRkaXNwbGF5LmNsYXNzTGlzdC5hZGQoICdkaXNwbGF5JyApO1xuXG5cdFx0dGhpcy4kc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLl92YWx1ZXNbIHRoaXMuJHNlbGVjdC5zZWxlY3RlZEluZGV4IF0gKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLiRkaXNwbGF5LmNsYXNzTGlzdC5hZGQoICdmb2N1cycgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiRzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHR0aGlzLiRkaXNwbGF5LmNsYXNzTGlzdC5yZW1vdmUoICdmb2N1cycgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiR3aWRnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuJHNlbGVjdCApO1xuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kZGlzcGxheSApO1xuXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJHNlbGVjdDtcblxuXHRcdHRoaXMub3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdH1cblxuXHRvcHRpb25zKCBvcHRpb25zICkge1xuXG5cdFx0dGhpcy5fdmFsdWVzID0gQXJyYXkuaXNBcnJheSggb3B0aW9ucyApID8gb3B0aW9ucyA6IE9iamVjdC52YWx1ZXMoIG9wdGlvbnMgKTtcblx0XHR0aGlzLl9uYW1lcyA9IEFycmF5LmlzQXJyYXkoIG9wdGlvbnMgKSA/IG9wdGlvbnMgOiBPYmplY3Qua2V5cyggb3B0aW9ucyApO1xuXG5cdFx0dGhpcy4kc2VsZWN0LnJlcGxhY2VDaGlsZHJlbigpO1xuXG5cdFx0dGhpcy5fbmFtZXMuZm9yRWFjaCggbmFtZSA9PiB7XG5cdFx0XHRjb25zdCAkb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ29wdGlvbicgKTtcblx0XHRcdCRvcHRpb24uaW5uZXJIVE1MID0gbmFtZTtcblx0XHRcdHRoaXMuJHNlbGVjdC5hcHBlbmRDaGlsZCggJG9wdGlvbiApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVwZGF0ZURpc3BsYXkoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLl92YWx1ZXMuaW5kZXhPZiggdmFsdWUgKTtcblx0XHR0aGlzLiRzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuXHRcdHRoaXMuJGRpc3BsYXkuaW5uZXJIVE1MID0gaW5kZXggPT09IC0xID8gdmFsdWUgOiB0aGlzLl9uYW1lc1sgaW5kZXggXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59XG5cbmNsYXNzIFN0cmluZ0NvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5ICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ3N0cmluZycgKTtcblxuXHRcdHRoaXMuJGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3R5cGUnLCAndGV4dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLiRpbnB1dC52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgZSA9PiB7XG5cdFx0XHRpZiAoIGUuY29kZSA9PT0gJ0VudGVyJyApIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQuYmx1cigpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgKCkgPT4ge1xuXHRcdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRpbnB1dCApO1xuXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJGlucHV0O1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0fVxuXG5cdHVwZGF0ZURpc3BsYXkoKSB7XG5cdFx0dGhpcy4kaW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5jb25zdCBzdHlsZXNoZWV0ID0gYC5saWwtZ3VpIHtcbiAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtZmFtaWx5KTtcbiAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUpO1xuICBsaW5lLWhlaWdodDogMTtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xuICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XG4gIHVzZXItc2VsZWN0OiBub25lO1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgLS1iYWNrZ3JvdW5kLWNvbG9yOiAjMWYxZjFmO1xuICAtLXRleHQtY29sb3I6ICNlYmViZWI7XG4gIC0tdGl0bGUtYmFja2dyb3VuZC1jb2xvcjogIzExMTExMTtcbiAgLS10aXRsZS10ZXh0LWNvbG9yOiAjZWJlYmViO1xuICAtLXdpZGdldC1jb2xvcjogIzQyNDI0MjtcbiAgLS1ob3Zlci1jb2xvcjogIzRmNGY0ZjtcbiAgLS1mb2N1cy1jb2xvcjogIzU5NTk1OTtcbiAgLS1udW1iZXItY29sb3I6ICMyY2M5ZmY7XG4gIC0tc3RyaW5nLWNvbG9yOiAjYTJkYjNjO1xuICAtLWZvbnQtc2l6ZTogMTFweDtcbiAgLS1pbnB1dC1mb250LXNpemU6IDExcHg7XG4gIC0tZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIEFyaWFsLCBzYW5zLXNlcmlmO1xuICAtLWZvbnQtZmFtaWx5LW1vbm86IE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcIkRyb2lkIFNhbnMgTW9ub1wiLCBtb25vc3BhY2U7XG4gIC0tcGFkZGluZzogNHB4O1xuICAtLXNwYWNpbmc6IDRweDtcbiAgLS13aWRnZXQtaGVpZ2h0OiAyMHB4O1xuICAtLXRpdGxlLWhlaWdodDogY2FsYyh2YXIoLS13aWRnZXQtaGVpZ2h0KSArIHZhcigtLXNwYWNpbmcpICogMS4yNSk7XG4gIC0tbmFtZS13aWR0aDogNDUlO1xuICAtLXNsaWRlci1rbm9iLXdpZHRoOiAycHg7XG4gIC0tc2xpZGVyLWlucHV0LXdpZHRoOiAyNyU7XG4gIC0tY29sb3ItaW5wdXQtd2lkdGg6IDI3JTtcbiAgLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoOiA0NXB4O1xuICAtLWNvbG9yLWlucHV0LW1pbi13aWR0aDogNDVweDtcbiAgLS1mb2xkZXItaW5kZW50OiA3cHg7XG4gIC0td2lkZ2V0LXBhZGRpbmc6IDAgMCAwIDNweDtcbiAgLS13aWRnZXQtYm9yZGVyLXJhZGl1czogMnB4O1xuICAtLWNoZWNrYm94LXNpemU6IGNhbGMoMC43NSAqIHZhcigtLXdpZGdldC1oZWlnaHQpKTtcbiAgLS1zY3JvbGxiYXItd2lkdGg6IDVweDtcbn1cbi5saWwtZ3VpLCAubGlsLWd1aSAqIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuLmxpbC1ndWkucm9vdCB7XG4gIHdpZHRoOiB2YXIoLS13aWR0aCwgMjQ1cHgpO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLWNvbG9yKTtcbn1cbi5saWwtZ3VpLnJvb3QgPiAudGl0bGUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS10aXRsZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgY29sb3I6IHZhcigtLXRpdGxlLXRleHQtY29sb3IpO1xufVxuLmxpbC1ndWkucm9vdCA+IC5jaGlsZHJlbiB7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbn1cbi5saWwtZ3VpLnJvb3QgPiAuY2hpbGRyZW46Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgd2lkdGg6IHZhcigtLXNjcm9sbGJhci13aWR0aCk7XG4gIGhlaWdodDogdmFyKC0tc2Nyb2xsYmFyLXdpZHRoKTtcbiAgYmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZC1jb2xvcik7XG59XG4ubGlsLWd1aS5yb290ID4gLmNoaWxkcmVuOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXNjcm9sbGJhci13aWR0aCk7XG4gIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbn1cbkBtZWRpYSAocG9pbnRlcjogY29hcnNlKSB7XG4gIC5saWwtZ3VpLmFsbG93LXRvdWNoLXN0eWxlcywgLmxpbC1ndWkuYWxsb3ctdG91Y2gtc3R5bGVzIC5saWwtZ3VpIHtcbiAgICAtLXdpZGdldC1oZWlnaHQ6IDI4cHg7XG4gICAgLS1wYWRkaW5nOiA2cHg7XG4gICAgLS1zcGFjaW5nOiA2cHg7XG4gICAgLS1mb250LXNpemU6IDEzcHg7XG4gICAgLS1pbnB1dC1mb250LXNpemU6IDE2cHg7XG4gICAgLS1mb2xkZXItaW5kZW50OiAxMHB4O1xuICAgIC0tc2Nyb2xsYmFyLXdpZHRoOiA3cHg7XG4gICAgLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoOiA1MHB4O1xuICAgIC0tY29sb3ItaW5wdXQtbWluLXdpZHRoOiA2NXB4O1xuICB9XG59XG4ubGlsLWd1aS5mb3JjZS10b3VjaC1zdHlsZXMsIC5saWwtZ3VpLmZvcmNlLXRvdWNoLXN0eWxlcyAubGlsLWd1aSB7XG4gIC0td2lkZ2V0LWhlaWdodDogMjhweDtcbiAgLS1wYWRkaW5nOiA2cHg7XG4gIC0tc3BhY2luZzogNnB4O1xuICAtLWZvbnQtc2l6ZTogMTNweDtcbiAgLS1pbnB1dC1mb250LXNpemU6IDE2cHg7XG4gIC0tZm9sZGVyLWluZGVudDogMTBweDtcbiAgLS1zY3JvbGxiYXItd2lkdGg6IDdweDtcbiAgLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoOiA1MHB4O1xuICAtLWNvbG9yLWlucHV0LW1pbi13aWR0aDogNjVweDtcbn1cbi5saWwtZ3VpLmF1dG9QbGFjZSB7XG4gIG1heC1oZWlnaHQ6IDEwMCU7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgdG9wOiAwO1xuICByaWdodDogMTVweDtcbiAgei1pbmRleDogMTAwMTtcbn1cblxuLmxpbC1ndWkgLmNvbnRyb2xsZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBwYWRkaW5nOiAwIHZhcigtLXBhZGRpbmcpO1xuICBtYXJnaW46IHZhcigtLXNwYWNpbmcpIDA7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5kaXNhYmxlZCB7XG4gIG9wYWNpdHk6IDAuNTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLmRpc2FibGVkLCAubGlsLWd1aSAuY29udHJvbGxlci5kaXNhYmxlZCAqIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmUgIWltcG9ydGFudDtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyID4gLm5hbWUge1xuICBtaW4td2lkdGg6IHZhcigtLW5hbWUtd2lkdGgpO1xuICBmbGV4LXNocmluazogMDtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgcGFkZGluZy1yaWdodDogdmFyKC0tc3BhY2luZyk7XG4gIGxpbmUtaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyIC53aWRnZXQge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xuICBtaW4taGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLnN0cmluZyBpbnB1dCB7XG4gIGNvbG9yOiB2YXIoLS1zdHJpbmctY29sb3IpO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuYm9vbGVhbiB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLmNvbG9yIC5kaXNwbGF5IHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgLmNvbnRyb2xsZXIuY29sb3IgLmRpc3BsYXk6aG92ZXI6YmVmb3JlIHtcbiAgICBjb250ZW50OiBcIiBcIjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNmZmY5O1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgbGVmdDogMDtcbiAgfVxufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuY29sb3IgaW5wdXRbdHlwZT1jb2xvcl0ge1xuICBvcGFjaXR5OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5jb2xvciBpbnB1dFt0eXBlPXRleHRdIHtcbiAgbWFyZ2luLWxlZnQ6IHZhcigtLXNwYWNpbmcpO1xuICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHktbW9ubyk7XG4gIG1pbi13aWR0aDogdmFyKC0tY29sb3ItaW5wdXQtbWluLXdpZHRoKTtcbiAgd2lkdGg6IHZhcigtLWNvbG9yLWlucHV0LXdpZHRoKTtcbiAgZmxleC1zaHJpbms6IDA7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gc2VsZWN0IHtcbiAgb3BhY2l0eTogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMTAwJTtcbiAgbWF4LXdpZHRoOiAxMDAlO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC5kaXNwbGF5IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICBsaW5lLWhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgd29yZC1icmVhazogYnJlYWstYWxsO1xuICBwYWRkaW5nLWxlZnQ6IDAuNTVlbTtcbiAgcGFkZGluZy1yaWdodDogMS43NWVtO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS13aWRnZXQtY29sb3IpO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC5kaXNwbGF5LmZvY3VzIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm9wdGlvbiAuZGlzcGxheS5hY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gLmRpc3BsYXk6YWZ0ZXIge1xuICBmb250LWZhbWlseTogXCJsaWwtZ3VpXCI7XG4gIGNvbnRlbnQ6IFwi4oaVXCI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBwYWRkaW5nLXJpZ2h0OiAwLjM3NWVtO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC53aWRnZXQsXG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gc2VsZWN0IHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC53aWRnZXQ6aG92ZXIgLmRpc3BsYXkge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWhvdmVyLWNvbG9yKTtcbiAgfVxufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIubnVtYmVyIGlucHV0IHtcbiAgY29sb3I6IHZhcigtLW51bWJlci1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIuaGFzU2xpZGVyIGlucHV0IHtcbiAgbWFyZ2luLWxlZnQ6IHZhcigtLXNwYWNpbmcpO1xuICB3aWR0aDogdmFyKC0tc2xpZGVyLWlucHV0LXdpZHRoKTtcbiAgbWluLXdpZHRoOiB2YXIoLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoKTtcbiAgZmxleC1zaHJpbms6IDA7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlciB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS13aWRnZXQtY29sb3IpO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS13aWRnZXQtYm9yZGVyLXJhZGl1cyk7XG4gIHBhZGRpbmctcmlnaHQ6IHZhcigtLXNsaWRlci1rbm9iLXdpZHRoKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgY3Vyc29yOiBldy1yZXNpemU7XG4gIHRvdWNoLWFjdGlvbjogcGFuLXk7XG59XG5AbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0taG92ZXItY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlci5hY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlci5hY3RpdmUgLmZpbGwge1xuICBvcGFjaXR5OiAwLjk1O1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIubnVtYmVyIC5maWxsIHtcbiAgaGVpZ2h0OiAxMDAlO1xuICBib3JkZXItcmlnaHQ6IHZhcigtLXNsaWRlci1rbm9iLXdpZHRoKSBzb2xpZCB2YXIoLS1udW1iZXItY29sb3IpO1xuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbn1cblxuLmxpbC1ndWktZHJhZ2dpbmcgLmxpbC1ndWkge1xuICAtLWhvdmVyLWNvbG9yOiB2YXIoLS13aWRnZXQtY29sb3IpO1xufVxuLmxpbC1ndWktZHJhZ2dpbmcgKiB7XG4gIGN1cnNvcjogZXctcmVzaXplICFpbXBvcnRhbnQ7XG59XG5cbi5saWwtZ3VpLWRyYWdnaW5nLmxpbC1ndWktdmVydGljYWwgKiB7XG4gIGN1cnNvcjogbnMtcmVzaXplICFpbXBvcnRhbnQ7XG59XG5cbi5saWwtZ3VpIC50aXRsZSB7XG4gIGhlaWdodDogdmFyKC0tdGl0bGUtaGVpZ2h0KTtcbiAgbGluZS1oZWlnaHQ6IGNhbGModmFyKC0tdGl0bGUtaGVpZ2h0KSAtIDRweCk7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIHBhZGRpbmc6IDAgdmFyKC0tcGFkZGluZyk7XG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgb3V0bGluZTogbm9uZTtcbiAgdGV4dC1kZWNvcmF0aW9uLXNraXA6IG9iamVjdHM7XG59XG4ubGlsLWd1aSAudGl0bGU6YmVmb3JlIHtcbiAgZm9udC1mYW1pbHk6IFwibGlsLWd1aVwiO1xuICBjb250ZW50OiBcIuKWvlwiO1xuICBwYWRkaW5nLXJpZ2h0OiAycHg7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbn1cbi5saWwtZ3VpIC50aXRsZTphY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS10aXRsZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgb3BhY2l0eTogMC43NTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIGJvZHk6bm90KC5saWwtZ3VpLWRyYWdnaW5nKSAubGlsLWd1aSAudGl0bGU6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLXRpdGxlLWJhY2tncm91bmQtY29sb3IpO1xuICAgIG9wYWNpdHk6IDAuODU7XG4gIH1cbiAgLmxpbC1ndWkgLnRpdGxlOmZvY3VzIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpLnJvb3QgPiAudGl0bGU6Zm9jdXMge1xuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcbn1cbi5saWwtZ3VpLmNsb3NlZCA+IC50aXRsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIuKWuFwiO1xufVxuLmxpbC1ndWkuY2xvc2VkID4gLmNoaWxkcmVuIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC03cHgpO1xuICBvcGFjaXR5OiAwO1xufVxuLmxpbC1ndWkuY2xvc2VkOm5vdCgudHJhbnNpdGlvbikgPiAuY2hpbGRyZW4ge1xuICBkaXNwbGF5OiBub25lO1xufVxuLmxpbC1ndWkudHJhbnNpdGlvbiA+IC5jaGlsZHJlbiB7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDMwMG1zO1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBoZWlnaHQsIG9wYWNpdHksIHRyYW5zZm9ybTtcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIsIDAuNiwgMC4zNSwgMSk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuLmxpbC1ndWkgLmNoaWxkcmVuOmVtcHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiRW1wdHlcIjtcbiAgcGFkZGluZzogMCB2YXIoLS1wYWRkaW5nKTtcbiAgbWFyZ2luOiB2YXIoLS1zcGFjaW5nKSAwO1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgZm9udC1zdHlsZTogaXRhbGljO1xuICBsaW5lLWhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIG9wYWNpdHk6IDAuNTtcbn1cbi5saWwtZ3VpLnJvb3QgPiAuY2hpbGRyZW4gPiAubGlsLWd1aSA+IC50aXRsZSB7XG4gIGJvcmRlcjogMCBzb2xpZCB2YXIoLS13aWRnZXQtY29sb3IpO1xuICBib3JkZXItd2lkdGg6IDFweCAwO1xuICB0cmFuc2l0aW9uOiBib3JkZXItY29sb3IgMzAwbXM7XG59XG4ubGlsLWd1aS5yb290ID4gLmNoaWxkcmVuID4gLmxpbC1ndWkuY2xvc2VkID4gLnRpdGxlIHtcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG4ubGlsLWd1aSArIC5jb250cm9sbGVyIHtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXdpZGdldC1jb2xvcik7XG4gIG1hcmdpbi10b3A6IDA7XG4gIHBhZGRpbmctdG9wOiB2YXIoLS1zcGFjaW5nKTtcbn1cbi5saWwtZ3VpIC5saWwtZ3VpIC5saWwtZ3VpID4gLnRpdGxlIHtcbiAgYm9yZGVyOiBub25lO1xufVxuLmxpbC1ndWkgLmxpbC1ndWkgLmxpbC1ndWkgPiAuY2hpbGRyZW4ge1xuICBib3JkZXI6IG5vbmU7XG4gIG1hcmdpbi1sZWZ0OiB2YXIoLS1mb2xkZXItaW5kZW50KTtcbiAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCB2YXIoLS13aWRnZXQtY29sb3IpO1xufVxuLmxpbC1ndWkgLmxpbC1ndWkgLmNvbnRyb2xsZXIge1xuICBib3JkZXI6IG5vbmU7XG59XG5cbi5saWwtZ3VpIGxhYmVsLCAubGlsLWd1aSBpbnB1dCwgLmxpbC1ndWkgYnV0dG9uIHtcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbi5saWwtZ3VpIGlucHV0IHtcbiAgYm9yZGVyOiAwO1xuICBvdXRsaW5lOiBub25lO1xuICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHkpO1xuICBmb250LXNpemU6IHZhcigtLWlucHV0LWZvbnQtc2l6ZSk7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgYmFja2dyb3VuZDogdmFyKC0td2lkZ2V0LWNvbG9yKTtcbiAgY29sb3I6IHZhcigtLXRleHQtY29sb3IpO1xuICB3aWR0aDogMTAwJTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIC5saWwtZ3VpIGlucHV0OmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ob3Zlci1jb2xvcik7XG4gIH1cbiAgLmxpbC1ndWkgaW5wdXQ6YWN0aXZlIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIGlucHV0OmRpc2FibGVkIHtcbiAgb3BhY2l0eTogMTtcbn1cbi5saWwtZ3VpIGlucHV0W3R5cGU9dGV4dF0sXG4ubGlsLWd1aSBpbnB1dFt0eXBlPW51bWJlcl0ge1xuICBwYWRkaW5nOiB2YXIoLS13aWRnZXQtcGFkZGluZyk7XG4gIC1tb3otYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xufVxuLmxpbC1ndWkgaW5wdXRbdHlwZT10ZXh0XTpmb2N1cyxcbi5saWwtZ3VpIGlucHV0W3R5cGU9bnVtYmVyXTpmb2N1cyB7XG4gIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbn1cbi5saWwtZ3VpIGlucHV0W3R5cGU9Y2hlY2tib3hdIHtcbiAgYXBwZWFyYW5jZTogbm9uZTtcbiAgd2lkdGg6IHZhcigtLWNoZWNrYm94LXNpemUpO1xuICBoZWlnaHQ6IHZhcigtLWNoZWNrYm94LXNpemUpO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS13aWRnZXQtYm9yZGVyLXJhZGl1cyk7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmxpbC1ndWkgaW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZDpiZWZvcmUge1xuICBmb250LWZhbWlseTogXCJsaWwtZ3VpXCI7XG4gIGNvbnRlbnQ6IFwi4pyTXCI7XG4gIGZvbnQtc2l6ZTogdmFyKC0tY2hlY2tib3gtc2l6ZSk7XG4gIGxpbmUtaGVpZ2h0OiB2YXIoLS1jaGVja2JveC1zaXplKTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIC5saWwtZ3VpIGlucHV0W3R5cGU9Y2hlY2tib3hdOmZvY3VzIHtcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggdmFyKC0tZm9jdXMtY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSBidXR0b24ge1xuICBvdXRsaW5lOiBub25lO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseSk7XG4gIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplKTtcbiAgY29sb3I6IHZhcigtLXRleHQtY29sb3IpO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG4gIGJhY2tncm91bmQ6IHZhcigtLXdpZGdldC1jb2xvcik7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgYm9yZGVyOiBub25lO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgYnV0dG9uOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ob3Zlci1jb2xvcik7XG4gIH1cbiAgLmxpbC1ndWkgYnV0dG9uOmZvY3VzIHtcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggdmFyKC0tZm9jdXMtY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSBidXR0b246YWN0aXZlIHtcbiAgYmFja2dyb3VuZDogdmFyKC0tZm9jdXMtY29sb3IpO1xufVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6IFwibGlsLWd1aVwiO1xuICBzcmM6IHVybChcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVXNBQXNBQUFBQUNKd0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCSFUxVkNBQUFCQ0FBQUFINEFBQURBSW13bVlFOVRMeklBQUFHSUFBQUFQd0FBQUdCS3FINVNZMjFoY0FBQUFjZ0FBQUQwQUFBQ3J1a3l5SkJuYkhsbUFBQUN2QUFBQUY4QUFBQ0VJWnBXSDJobFlXUUFBQU1jQUFBQUp3QUFBRFpmY2oyemFHaGxZUUFBQTBRQUFBQVlBQUFBSkFDNUFIaG9iWFI0QUFBRFhBQUFBQkFBQUFCTUFaQUFBR3h2WTJFQUFBTnNBQUFBRkFBQUFDZ0NFZ0l5YldGNGNBQUFBNEFBQUFBZUFBQUFJQUVmQUJKdVlXMWxBQUFEb0FBQUFTSUFBQUlLOVNVVS9YQnZjM1FBQUFURUFBQUFaZ0FBQUpDVGNNYzJlSnhWamJFT2dqQVVSVStoRlJCSzFkR1JMK0FMbkFpVG95TUxFekZwblB6L2VBc2h3U2E5NzUxN2MvTXd3Sm1lQjlrd1BsKzBjZjUrdUdQWlhzcVB1NG52WmFiY1NabGRaNmtmeVdub21GWS9lU2NLcVpOV3VwS0pPNmtYTjNLOXVDVm9MN2lJblByMVg1YmFYczN0anVNcUN0ekV1YWdtL0FBbHpRZ1BBQUI0bkdOZ1lSQmxuTURBeXNEQVlNL2dCaVQ1b0xRQkF3dURKQU1ERXdNck13TldFSkRtbXNKd2dDRmVYWmdoQmNqbFpNZ0ZDek9pS09JRkFCNzFCYjhBZUp5MWtqRnV3a0FRUlorRHdSQXdCdE5RUlVHS1E4T2RLQ0FXVWhBZ0tMaEl1QXNWU3BXejVCYmtqM2RFZ1lpVUlzenFXZHBaZStaNy93QjFvQ1ltSW9ib2l3aUxUMldqS2wvanNjckhmR2cvcEtkTWt5a2xDNVpzMkxFZkhZcGpjUm9Qem1lOU1XV21rM2RXYks5T2JrV2tpa09ldEo1NTRmV3lvRXNtZFNsdCt1UjBwQ0pSMzRiNnQvVFZnMVNZM3NZdmRmOHZ1aUtycHlhRFhESVNpZWdwMTdwNzU3OUdwM3ArK3k3SFBBaVk5cG1UaWJsanJyODVxU2lkdGxnNCtsMjVHTENhUzhlNnJSeE5CbXNuRVJ1bktiYU9PYlJ6N043Mmp1NXZkQWpZcEJYSGdKeWxPQVZzTXNlREFQRVA4TFlvVUhpY1kyQmlBQUVmaGlBR0pnWldCZ1o3Um5GUmRuVkpFTENRbEJTUmxBVEpNb0xWMkRLNGdsU1lzNnVicTV2YktySkxTYkdyZ0Vtb3ZEdURKVmhlM1Z6Y1hGd05MQ09JTEIvQzRJdVExeFRuNUZQaWxCVGo1RlBtQkFCNFd3b3FBSGljWTJCa1lHQUE0c2sxc1IvaitXMitNbkF6cERCZ0F5RU1RVUNTZzRFSnhBRUF3VWdGSGdCNG5HTmdaR0JnU0dGZ2dKTWhESXdNcUVBWUFCeUhBVEo0bkdOZ0FJSVVORXdtQUFCbDNBR1JlSnhqWUFBQ0lRWWxCaU1HSjN3UUFFY1FCRVY0bkdOZ1pHQmdFR1pnWTJCaUFBRVF5UVdFREF6L3dYd0dBQXNQQVRJQUFIaWNYZEJOU3NOQUhBWHdsMzVpQTBVUVhZbk1TaGZTOUdQWkE3VDdMZ0l1MDNTU3Brd3pZVEl0MUJONEFrL2dLVHlBZUN4ZnczOWpaa2p5bXpjdkF3bUFXL3dnd0hVRUdEYjM2K2pRUTNHWEdvdDc5TDI0anhDUDRnSHpGL0VJcjRqRUllN3d4aE9DM2cyVE1ZeTRRNytMdS9TSHVFZC9pdnQ0d0pkNHdQeGJQRUtNWDNHSTUrREpGR2FTbjRxTnprOG1jYktTUjZ4ZFhkaFN6YU9aSkd0ZGFwZDR2VlBiaTZyUCtjTDdUR1hPSHRYS2xsNGJZMVhsN0VHblB0cDdYeTJuMDB6eUtMVkhma0hCYTRJY0oyb0QzY2dnZ1d2dC9WL0ZiRHJVbEVVSmhUbi8wYXpWV2JOVE5yMEVuczhkZTF0Y2VLOXhabWZCMUNQak9tUEg0a2l0bXZPdWJjTnBtVlROM29GSnlqekN2bm1yd2hKVHpxelZqOWppU1g5MTFGamVBQUI0bkczSE1SS0NNQkJBMGYwZ2lpS2k0RFU4azBWMkdXYklaRE9oNFBvV1d2cTZKNVY4SWY5TlZOUWNhRGh5b3VYTWhZNHJQVGNHN2p3WW1YaEtxOFd6K3A3NjJhTmFlWVhvbTJuM20yZExUVmdzckNnRko3T1RtSWtZYndJYkM2dklCN1dtRmZBQUFBPT1cIikgZm9ybWF0KFwid29mZlwiKTtcbn1gO1xuXG5mdW5jdGlvbiBfaW5qZWN0U3R5bGVzKCBjc3NDb250ZW50ICkge1xuXHRjb25zdCBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzdHlsZScgKTtcblx0aW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcblx0Y29uc3QgYmVmb3JlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ2hlYWQgbGlua1tyZWw9c3R5bGVzaGVldF0sIGhlYWQgc3R5bGUnICk7XG5cdGlmICggYmVmb3JlICkge1xuXHRcdGRvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKCBpbmplY3RlZCwgYmVmb3JlICk7XG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggaW5qZWN0ZWQgKTtcblx0fVxufVxuXG5sZXQgc3R5bGVzSW5qZWN0ZWQgPSBmYWxzZTtcblxuY2xhc3MgR1VJIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHBhbmVsIHRoYXQgaG9sZHMgY29udHJvbGxlcnMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIG5ldyBHVUkoKTtcblx0ICogbmV3IEdVSSggeyBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCAnY3VzdG9tJyApIH0gKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9QbGFjZT10cnVlXVxuXHQgKiBBZGRzIHRoZSBHVUkgdG8gYGRvY3VtZW50LmJvZHlgIGFuZCBmaXhlcyBpdCB0byB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdXG5cdCAqIEFkZHMgdGhlIEdVSSB0byB0aGlzIERPTSBlbGVtZW50LiBPdmVycmlkZXMgYGF1dG9QbGFjZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD0yNDVdXG5cdCAqIFdpZHRoIG9mIHRoZSBHVUkgaW4gcGl4ZWxzLCB1c3VhbGx5IHNldCB3aGVuIG5hbWUgbGFiZWxzIGJlY29tZSB0b28gbG9uZy4gTm90ZSB0aGF0IHlvdSBjYW4gbWFrZVxuXHQgKiBuYW1lIGxhYmVscyB3aWRlciBpbiBDU1Mgd2l0aCBgLmxpbOKAkWd1aSB7IOKAkeKAkW5hbWXigJF3aWR0aDogNTUlIH1gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGl0bGU9Q29udHJvbHNdXG5cdCAqIE5hbWUgdG8gZGlzcGxheSBpbiB0aGUgdGl0bGUgYmFyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb3NlRm9sZGVycz1mYWxzZV1cblx0ICogUGFzcyBgdHJ1ZWAgdG8gY2xvc2UgYWxsIGZvbGRlcnMgaW4gdGhpcyBHVUkgYnkgZGVmYXVsdC5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmplY3RTdHlsZXM9dHJ1ZV1cblx0ICogSW5qZWN0cyB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IGludG8gdGhlIHBhZ2UgaWYgdGhpcyBpcyB0aGUgZmlyc3QgR1VJLlxuXHQgKiBQYXNzIGBmYWxzZWAgdG8gdXNlIHlvdXIgb3duIHN0eWxlc2hlZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3VjaFN0eWxlcz10cnVlXVxuXHQgKiBNYWtlcyBjb250cm9sbGVycyBsYXJnZXIgb24gdG91Y2ggZGV2aWNlcy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUgdG91Y2ggc3R5bGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0dVSX0gW29wdGlvbnMucGFyZW50XVxuXHQgKiBBZGRzIHRoaXMgR1VJIGFzIGEgY2hpbGQgaW4gYW5vdGhlciBHVUkuIFVzdWFsbHkgdGhpcyBpcyBkb25lIGZvciB5b3UgYnkgYGFkZEZvbGRlcigpYC5cblx0ICpcblx0ICovXG5cdGNvbnN0cnVjdG9yKCB7XG5cdFx0cGFyZW50LFxuXHRcdGF1dG9QbGFjZSA9IHBhcmVudCA9PT0gdW5kZWZpbmVkLFxuXHRcdGNvbnRhaW5lcixcblx0XHR3aWR0aCxcblx0XHR0aXRsZSA9ICdDb250cm9scycsXG5cdFx0Y2xvc2VGb2xkZXJzID0gZmFsc2UsXG5cdFx0aW5qZWN0U3R5bGVzID0gdHJ1ZSxcblx0XHR0b3VjaFN0eWxlcyA9IHRydWVcblx0fSA9IHt9ICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIEdVSSBjb250YWluaW5nIHRoaXMgZm9sZGVyLCBvciBgdW5kZWZpbmVkYCBpZiB0aGlzIGlzIHRoZSByb290IEdVSS5cblx0XHQgKiBAdHlwZSB7R1VJfVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvcCBsZXZlbCBHVUkgY29udGFpbmluZyB0aGlzIGZvbGRlciwgb3IgYHRoaXNgIGlmIHRoaXMgaXMgdGhlIHJvb3QgR1VJLlxuXHRcdCAqIEB0eXBlIHtHVUl9XG5cdFx0ICovXG5cdFx0dGhpcy5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiB0aGlzO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpc3Qgb2YgY29udHJvbGxlcnMgYW5kIGZvbGRlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJLlxuXHRcdCAqIEB0eXBlIHtBcnJheTxHVUl8Q29udHJvbGxlcj59XG5cdFx0ICovXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpc3Qgb2YgY29udHJvbGxlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJLlxuXHRcdCAqIEB0eXBlIHtBcnJheTxDb250cm9sbGVyPn1cblx0XHQgKi9cblx0XHR0aGlzLmNvbnRyb2xsZXJzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlzdCBvZiBmb2xkZXJzIGNvbnRhaW5lZCBieSB0aGlzIEdVSS5cblx0XHQgKiBAdHlwZSB7QXJyYXk8R1VJPn1cblx0XHQgKi9cblx0XHR0aGlzLmZvbGRlcnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBHVUkgaXMgY2xvc2VkLiBVc2UgYGd1aS5vcGVuKClgIG9yIGBndWkuY2xvc2UoKWAgdG8gY2hhbmdlIHRoaXMuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgR1VJIGlzIGhpZGRlbi4gVXNlIGBndWkuc2hvdygpYCBvciBgZ3VpLmhpZGUoKWAgdG8gY2hhbmdlIHRoaXMuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5faGlkZGVuID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb3V0ZXJtb3N0IGNvbnRhaW5lciBlbGVtZW50LlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnbGlsLWd1aScgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aXRsZS5cblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dGhpcy4kdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJHRpdGxlLmNsYXNzTGlzdC5hZGQoICd0aXRsZScgKTtcblx0XHR0aGlzLiR0aXRsZS5zZXRBdHRyaWJ1dGUoICdyb2xlJywgJ2J1dHRvbicgKTtcblx0XHR0aGlzLiR0aXRsZS5zZXRBdHRyaWJ1dGUoICdhcmlhLWV4cGFuZGVkJywgdHJ1ZSApO1xuXHRcdHRoaXMuJHRpdGxlLnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgMCApO1xuXG5cdFx0dGhpcy4kdGl0bGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgKCkgPT4gdGhpcy5vcGVuQW5pbWF0ZWQoIHRoaXMuX2Nsb3NlZCApICk7XG5cdFx0dGhpcy4kdGl0bGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBlID0+IHtcblx0XHRcdGlmICggZS5jb2RlID09PSAnRW50ZXInIHx8IGUuY29kZSA9PT0gJ1NwYWNlJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGlzLiR0aXRsZS5jbGljaygpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIGVuYWJsZXMgOmFjdGl2ZSBwc2V1ZG8gY2xhc3Mgb24gbW9iaWxlXG5cdFx0dGhpcy4kdGl0bGUuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCAoKSA9PiB7fSwgeyBwYXNzaXZlOiB0cnVlIH0gKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIGNoaWxkcmVuLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLiRjaGlsZHJlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kY2hpbGRyZW4uY2xhc3NMaXN0LmFkZCggJ2NoaWxkcmVuJyApO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLiR0aXRsZSApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy4kY2hpbGRyZW4gKTtcblxuXHRcdHRoaXMudGl0bGUoIHRpdGxlICk7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXG5cdFx0XHR0aGlzLnBhcmVudC5jaGlsZHJlbi5wdXNoKCB0aGlzICk7XG5cdFx0XHR0aGlzLnBhcmVudC5mb2xkZXJzLnB1c2goIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5wYXJlbnQuJGNoaWxkcmVuLmFwcGVuZENoaWxkKCB0aGlzLmRvbUVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gU3RvcCB0aGUgY29uc3RydWN0b3IgZWFybHksIGV2ZXJ5dGhpbmcgb253YXJkIG9ubHkgYXBwbGllcyB0byByb290IEdVSSdzXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3Jvb3QnICk7XG5cblx0XHRpZiAoIHRvdWNoU3R5bGVzICkge1xuXHRcdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICdhbGxvdy10b3VjaC1zdHlsZXMnICk7XG5cdFx0fVxuXG5cdFx0Ly8gSW5qZWN0IHN0eWxlc2hlZXQgaWYgd2UgaGF2ZW4ndCBkb25lIHRoYXQgeWV0XG5cdFx0aWYgKCAhc3R5bGVzSW5qZWN0ZWQgJiYgaW5qZWN0U3R5bGVzICkge1xuXHRcdFx0X2luamVjdFN0eWxlcyggc3R5bGVzaGVldCApO1xuXHRcdFx0c3R5bGVzSW5qZWN0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggY29udGFpbmVyICkge1xuXG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXG5cdFx0fSBlbHNlIGlmICggYXV0b1BsYWNlICkge1xuXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ2F1dG9QbGFjZScgKTtcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3aWR0aCApIHtcblx0XHRcdHRoaXMuZG9tRWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSggJy0td2lkdGgnLCB3aWR0aCArICdweCcgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbG9zZUZvbGRlcnMgPSBjbG9zZUZvbGRlcnM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY29udHJvbGxlciB0byB0aGUgR1VJLCBpbmZlcnJpbmcgY29udHJvbGxlciB0eXBlIHVzaW5nIHRoZSBgdHlwZW9mYCBvcGVyYXRvci5cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLmFkZCggb2JqZWN0LCAncHJvcGVydHknICk7XG5cdCAqIGd1aS5hZGQoIG9iamVjdCwgJ251bWJlcicsIDAsIDEwMCwgMSApO1xuXHQgKiBndWkuYWRkKCBvYmplY3QsICdvcHRpb25zJywgWyAxLCAyLCAzIF0gKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBjb250cm9sbGVyIHdpbGwgbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29udHJvbC5cblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fEFycmF5fSBbJDFdIE1pbmltdW0gdmFsdWUgZm9yIG51bWJlciBjb250cm9sbGVycywgb3IgdGhlIHNldCBvZlxuXHQgKiBzZWxlY3RhYmxlIHZhbHVlcyBmb3IgYSBkcm9wZG93bi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYXhdIE1heGltdW0gdmFsdWUgZm9yIG51bWJlciBjb250cm9sbGVycy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwXSBTdGVwIHZhbHVlIGZvciBudW1iZXIgY29udHJvbGxlcnMuXG5cdCAqIEByZXR1cm5zIHtDb250cm9sbGVyfVxuXHQgKi9cblx0YWRkKCBvYmplY3QsIHByb3BlcnR5LCAkMSwgbWF4LCBzdGVwICkge1xuXG5cdFx0aWYgKCBPYmplY3QoICQxICkgPT09ICQxICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIoIHRoaXMsIG9iamVjdCwgcHJvcGVydHksICQxICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbml0aWFsVmFsdWUgPSBvYmplY3RbIHByb3BlcnR5IF07XG5cblx0XHRzd2l0Y2ggKCB0eXBlb2YgaW5pdGlhbFZhbHVlICkge1xuXG5cdFx0XHRjYXNlICdudW1iZXInOlxuXG5cdFx0XHRcdHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlciggdGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgJDEsIG1heCwgc3RlcCApO1xuXG5cdFx0XHRjYXNlICdib29sZWFuJzpcblxuXHRcdFx0XHRyZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5ICk7XG5cblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5ICk7XG5cblx0XHRcdGNhc2UgJ2Z1bmN0aW9uJzpcblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlciggdGhpcywgb2JqZWN0LCBwcm9wZXJ0eSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc29sZS5lcnJvciggYGd1aS5hZGQgZmFpbGVkXG5cdHByb3BlcnR5OmAsIHByb3BlcnR5LCBgXG5cdG9iamVjdDpgLCBvYmplY3QsIGBcblx0dmFsdWU6YCwgaW5pdGlhbFZhbHVlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY29sb3IgY29udHJvbGxlciB0byB0aGUgR1VJLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYXJhbXMgPSB7XG5cdCAqIFx0Y3NzQ29sb3I6ICcjZmYwMGZmJyxcblx0ICogXHRyZ2JDb2xvcjogeyByOiAwLCBnOiAwLjIsIGI6IDAuNCB9LFxuXHQgKiBcdGN1c3RvbVJhbmdlOiBbIDAsIDEyNywgMjU1IF0sXG5cdCAqIH07XG5cdCAqXG5cdCAqIGd1aS5hZGRDb2xvciggcGFyYW1zLCAnY3NzQ29sb3InICk7XG5cdCAqIGd1aS5hZGRDb2xvciggcGFyYW1zLCAncmdiQ29sb3InICk7XG5cdCAqIGd1aS5hZGRDb2xvciggcGFyYW1zLCAnY3VzdG9tUmFuZ2UnLCAyNTUgKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBjb250cm9sbGVyIHdpbGwgbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29udHJvbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJnYlNjYWxlIE1heGltdW0gdmFsdWUgZm9yIGEgY29sb3IgY2hhbm5lbCB3aGVuIHVzaW5nIGFuIFJHQiBjb2xvci4gWW91IG1heVxuXHQgKiBuZWVkIHRvIHNldCB0aGlzIHRvIDI1NSBpZiB5b3VyIGNvbG9ycyBhcmUgdG9vIGJyaWdodC5cblx0ICogQHJldHVybnMge0NvbnRyb2xsZXJ9XG5cdCAqL1xuXHRhZGRDb2xvciggb2JqZWN0LCBwcm9wZXJ0eSwgcmdiU2NhbGUgPSAxICkge1xuXHRcdHJldHVybiBuZXcgQ29sb3JDb250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5LCByZ2JTY2FsZSApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmb2xkZXIgdG8gdGhlIEdVSSwgd2hpY2ggaXMganVzdCBhbm90aGVyIEdVSS4gVGhpcyBtZXRob2QgcmV0dXJuc1xuXHQgKiB0aGUgbmVzdGVkIEdVSSBzbyB5b3UgY2FuIGFkZCBjb250cm9sbGVycyB0byBpdC5cblx0ICogQGV4YW1wbGVcblx0ICogY29uc3QgZm9sZGVyID0gZ3VpLmFkZEZvbGRlciggJ1Bvc2l0aW9uJyApO1xuXHQgKiBmb2xkZXIuYWRkKCBwb3NpdGlvbiwgJ3gnICk7XG5cdCAqIGZvbGRlci5hZGQoIHBvc2l0aW9uLCAneScgKTtcblx0ICogZm9sZGVyLmFkZCggcG9zaXRpb24sICd6JyApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgTmFtZSB0byBkaXNwbGF5IGluIHRoZSBmb2xkZXIncyB0aXRsZSBiYXIuXG5cdCAqIEByZXR1cm5zIHtHVUl9XG5cdCAqL1xuXHRhZGRGb2xkZXIoIHRpdGxlICkge1xuXHRcdGNvbnN0IGZvbGRlciA9IG5ldyBHVUkoIHsgcGFyZW50OiB0aGlzLCB0aXRsZSB9ICk7XG5cdFx0aWYgKCB0aGlzLnJvb3QuX2Nsb3NlRm9sZGVycyApIGZvbGRlci5jbG9zZSgpO1xuXHRcdHJldHVybiBmb2xkZXI7XG5cdH1cblxuXHQvKipcblx0ICogUmVjYWxscyB2YWx1ZXMgdGhhdCB3ZXJlIHNhdmVkIHdpdGggYGd1aS5zYXZlKClgLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb2JqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFBhc3MgZmFsc2UgdG8gZXhjbHVkZSBmb2xkZXJzIGRlc2NlbmRpbmcgZnJvbSB0aGlzIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRsb2FkKCBvYmosIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHRpZiAoIG9iai5jb250cm9sbGVycyApIHtcblxuXHRcdFx0dGhpcy5jb250cm9sbGVycy5mb3JFYWNoKCBjID0+IHtcblxuXHRcdFx0XHRpZiAoIGMgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCBjLl9uYW1lIGluIG9iai5jb250cm9sbGVycyApIHtcblx0XHRcdFx0XHRjLmxvYWQoIG9iai5jb250cm9sbGVyc1sgYy5fbmFtZSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZWN1cnNpdmUgJiYgb2JqLmZvbGRlcnMgKSB7XG5cblx0XHRcdHRoaXMuZm9sZGVycy5mb3JFYWNoKCBmID0+IHtcblxuXHRcdFx0XHRpZiAoIGYuX3RpdGxlIGluIG9iai5mb2xkZXJzICkge1xuXHRcdFx0XHRcdGYubG9hZCggb2JqLmZvbGRlcnNbIGYuX3RpdGxlIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IG1hcHBpbmcgY29udHJvbGxlciBuYW1lcyB0byB2YWx1ZXMuIFRoZSBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBgZ3VpLmxvYWQoKWAgdG9cblx0ICogcmVjYWxsIHRoZXNlIHZhbHVlcy5cblx0ICogQGV4YW1wbGVcblx0ICoge1xuXHQgKiBcdGNvbnRyb2xsZXJzOiB7XG5cdCAqIFx0XHRwcm9wMTogMSxcblx0ICogXHRcdHByb3AyOiAndmFsdWUnLFxuXHQgKiBcdFx0Li4uXG5cdCAqIFx0fSxcblx0ICogXHRmb2xkZXJzOiB7XG5cdCAqIFx0XHRmb2xkZXJOYW1lMTogeyBjb250cm9sbGVycywgZm9sZGVycyB9LFxuXHQgKiBcdFx0Zm9sZGVyTmFtZTI6IHsgY29udHJvbGxlcnMsIGZvbGRlcnMgfVxuXHQgKiBcdFx0Li4uXG5cdCAqIFx0fVxuXHQgKiB9XG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFBhc3MgZmFsc2UgdG8gZXhjbHVkZSBmb2xkZXJzIGRlc2NlbmRpbmcgZnJvbSB0aGlzIEdVSS5cblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG5cdHNhdmUoIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRjb250cm9sbGVyczoge30sXG5cdFx0XHRmb2xkZXJzOiB7fVxuXHRcdH07XG5cblx0XHR0aGlzLmNvbnRyb2xsZXJzLmZvckVhY2goIGMgPT4ge1xuXG5cdFx0XHRpZiAoIGMgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIgKSByZXR1cm47XG5cblx0XHRcdGlmICggYy5fbmFtZSBpbiBvYmouY29udHJvbGxlcnMgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYENhbm5vdCBzYXZlIEdVSSB3aXRoIGR1cGxpY2F0ZSBwcm9wZXJ0eSBcIiR7Yy5fbmFtZX1cImAgKTtcblx0XHRcdH1cblxuXHRcdFx0b2JqLmNvbnRyb2xsZXJzWyBjLl9uYW1lIF0gPSBjLnNhdmUoKTtcblxuXHRcdH0gKTtcblxuXHRcdGlmICggcmVjdXJzaXZlICkge1xuXG5cdFx0XHR0aGlzLmZvbGRlcnMuZm9yRWFjaCggZiA9PiB7XG5cblx0XHRcdFx0aWYgKCBmLl90aXRsZSBpbiBvYmouZm9sZGVycyApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBDYW5ub3Qgc2F2ZSBHVUkgd2l0aCBkdXBsaWNhdGUgZm9sZGVyIFwiJHtmLl90aXRsZX1cImAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iai5mb2xkZXJzWyBmLl90aXRsZSBdID0gZi5zYXZlKCk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBPcGVucyBhIEdVSSBvciBmb2xkZXIuIEdVSSBhbmQgZm9sZGVycyBhcmUgb3BlbiBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW4gUGFzcyBmYWxzZSB0byBjbG9zZS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5vcGVuKCk7IC8vIG9wZW5cblx0ICogZ3VpLm9wZW4oIGZhbHNlICk7IC8vIGNsb3NlXG5cdCAqIGd1aS5vcGVuKCBndWkuX2Nsb3NlZCApOyAvLyB0b2dnbGVcblx0ICovXG5cdG9wZW4oIG9wZW4gPSB0cnVlICkge1xuXG5cdFx0dGhpcy5fc2V0Q2xvc2VkKCAhb3BlbiApO1xuXG5cdFx0dGhpcy4kdGl0bGUuc2V0QXR0cmlidXRlKCAnYXJpYS1leHBhbmRlZCcsICF0aGlzLl9jbG9zZWQgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSggJ2Nsb3NlZCcsIHRoaXMuX2Nsb3NlZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRjbG9zZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcGVuKCBmYWxzZSApO1xuXHR9XG5cblx0X3NldENsb3NlZCggY2xvc2VkICkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkID09PSBjbG9zZWQgKSByZXR1cm47XG5cdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHRoaXMuX2NhbGxPbk9wZW5DbG9zZSggdGhpcyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3dzIHRoZSBHVUkgYWZ0ZXIgaXQncyBiZWVuIGhpZGRlbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBzaG93XG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBndWkuc2hvdygpO1xuXHQgKiBndWkuc2hvdyggZmFsc2UgKTsgLy8gaGlkZVxuXHQgKiBndWkuc2hvdyggZ3VpLl9oaWRkZW4gKTsgLy8gdG9nZ2xlXG5cdCAqL1xuXHRzaG93KCBzaG93ID0gdHJ1ZSApIHtcblxuXHRcdHRoaXMuX2hpZGRlbiA9ICFzaG93O1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9oaWRkZW4gPyAnbm9uZScgOiAnJztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSGlkZXMgdGhlIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRoaWRlKCkge1xuXHRcdHJldHVybiB0aGlzLnNob3coIGZhbHNlICk7XG5cdH1cblxuXHRvcGVuQW5pbWF0ZWQoIG9wZW4gPSB0cnVlICkge1xuXG5cdFx0Ly8gc2V0IHN0YXRlIGltbWVkaWF0ZWx5XG5cdFx0dGhpcy5fc2V0Q2xvc2VkKCAhb3BlbiApO1xuXG5cdFx0dGhpcy4kdGl0bGUuc2V0QXR0cmlidXRlKCAnYXJpYS1leHBhbmRlZCcsICF0aGlzLl9jbG9zZWQgKTtcblxuXHRcdC8vIHdhaXQgZm9yIG5leHQgZnJhbWUgdG8gbWVhc3VyZSAkY2hpbGRyZW5cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IHtcblxuXHRcdFx0Ly8gZXhwbGljaXRseSBzZXQgaW5pdGlhbCBoZWlnaHQgZm9yIHRyYW5zaXRpb25cblx0XHRcdGNvbnN0IGluaXRpYWxIZWlnaHQgPSB0aGlzLiRjaGlsZHJlbi5jbGllbnRIZWlnaHQ7XG5cdFx0XHR0aGlzLiRjaGlsZHJlbi5zdHlsZS5oZWlnaHQgPSBpbml0aWFsSGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICd0cmFuc2l0aW9uJyApO1xuXG5cdFx0XHRjb25zdCBvblRyYW5zaXRpb25FbmQgPSBlID0+IHtcblx0XHRcdFx0aWYgKCBlLnRhcmdldCAhPT0gdGhpcy4kY2hpbGRyZW4gKSByZXR1cm47XG5cdFx0XHRcdHRoaXMuJGNoaWxkcmVuLnN0eWxlLmhlaWdodCA9ICcnO1xuXHRcdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSggJ3RyYW5zaXRpb24nICk7XG5cdFx0XHRcdHRoaXMuJGNoaWxkcmVuLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kICk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLiRjaGlsZHJlbi5hZGRFdmVudExpc3RlbmVyKCAndHJhbnNpdGlvbmVuZCcsIG9uVHJhbnNpdGlvbkVuZCApO1xuXG5cdFx0XHQvLyB0b2RvOiB0aGlzIGlzIHdyb25nIGlmIGNoaWxkcmVuJ3Mgc2Nyb2xsSGVpZ2h0IG1ha2VzIGZvciBhIGd1aSB0YWxsZXIgdGhhbiBtYXhIZWlnaHRcblx0XHRcdGNvbnN0IHRhcmdldEhlaWdodCA9ICFvcGVuID8gMCA6IHRoaXMuJGNoaWxkcmVuLnNjcm9sbEhlaWdodDtcblxuXHRcdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoICdjbG9zZWQnLCAhb3BlbiApO1xuXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IHtcblx0XHRcdFx0dGhpcy4kY2hpbGRyZW4uc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0ICsgJ3B4Jztcblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSB0aXRsZSBvZiB0aGlzIEdVSS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0dGl0bGUoIHRpdGxlICkge1xuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgdGl0bGUgb2YgdGhlIEdVSS4gVXNlIGBndWkudGl0bGUoICdUaXRsZScgKWAgdG8gbW9kaWZ5IHRoaXMgdmFsdWUuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLl90aXRsZSA9IHRpdGxlO1xuXHRcdHRoaXMuJHRpdGxlLmlubmVySFRNTCA9IHRpdGxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2V0cyBhbGwgY29udHJvbGxlcnMgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFBhc3MgZmFsc2UgdG8gZXhjbHVkZSBmb2xkZXJzIGRlc2NlbmRpbmcgZnJvbSB0aGlzIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRyZXNldCggcmVjdXJzaXZlID0gdHJ1ZSApIHtcblx0XHRjb25zdCBjb250cm9sbGVycyA9IHJlY3Vyc2l2ZSA/IHRoaXMuY29udHJvbGxlcnNSZWN1cnNpdmUoKSA6IHRoaXMuY29udHJvbGxlcnM7XG5cdFx0Y29udHJvbGxlcnMuZm9yRWFjaCggYyA9PiBjLnJlc2V0KCkgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIGEgY29udHJvbGxlciBpbiB0aGlzIEdVSSBjaGFuZ2VzLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKHtvYmplY3Q6b2JqZWN0LCBwcm9wZXJ0eTpzdHJpbmcsIHZhbHVlOmFueSwgY29udHJvbGxlcjpDb250cm9sbGVyfSl9IGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBndWkub25DaGFuZ2UoIGV2ZW50ID0+IHtcblx0ICogXHRldmVudC5vYmplY3QgICAgIC8vIG9iamVjdCB0aGF0IHdhcyBtb2RpZmllZFxuXHQgKiBcdGV2ZW50LnByb3BlcnR5ICAgLy8gc3RyaW5nLCBuYW1lIG9mIHByb3BlcnR5XG5cdCAqIFx0ZXZlbnQudmFsdWUgICAgICAvLyBuZXcgdmFsdWUgb2YgY29udHJvbGxlclxuXHQgKiBcdGV2ZW50LmNvbnRyb2xsZXIgLy8gY29udHJvbGxlciB0aGF0IHdhcyBtb2RpZmllZFxuXHQgKiB9ICk7XG5cdCAqL1xuXHRvbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cdFx0LyoqXG5cdFx0ICogVXNlZCB0byBhY2Nlc3MgdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIGBvbkNoYW5nZWAgZXZlbnRzLiBEb24ndCBtb2RpZnkgdGhpcyB2YWx1ZVxuXHRcdCAqIGRpcmVjdGx5LiBVc2UgdGhlIGBndWkub25DaGFuZ2UoIGNhbGxiYWNrIClgIG1ldGhvZCBpbnN0ZWFkLlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLl9vbkNoYW5nZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2NhbGxPbkNoYW5nZSggY29udHJvbGxlciApIHtcblxuXHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XG5cdFx0XHR0aGlzLnBhcmVudC5fY2FsbE9uQ2hhbmdlKCBjb250cm9sbGVyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9vbkNoYW5nZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5fb25DaGFuZ2UuY2FsbCggdGhpcywge1xuXHRcdFx0XHRvYmplY3Q6IGNvbnRyb2xsZXIub2JqZWN0LFxuXHRcdFx0XHRwcm9wZXJ0eTogY29udHJvbGxlci5wcm9wZXJ0eSxcblx0XHRcdFx0dmFsdWU6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSxcblx0XHRcdFx0Y29udHJvbGxlclxuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIGEgY29udHJvbGxlciBpbiB0aGlzIEdVSSBoYXMgZmluaXNoZWQgY2hhbmdpbmcuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oe29iamVjdDpvYmplY3QsIHByb3BlcnR5OnN0cmluZywgdmFsdWU6YW55LCBjb250cm9sbGVyOkNvbnRyb2xsZXJ9KX0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5vbkZpbmlzaENoYW5nZSggZXZlbnQgPT4ge1xuXHQgKiBcdGV2ZW50Lm9iamVjdCAgICAgLy8gb2JqZWN0IHRoYXQgd2FzIG1vZGlmaWVkXG5cdCAqIFx0ZXZlbnQucHJvcGVydHkgICAvLyBzdHJpbmcsIG5hbWUgb2YgcHJvcGVydHlcblx0ICogXHRldmVudC52YWx1ZSAgICAgIC8vIG5ldyB2YWx1ZSBvZiBjb250cm9sbGVyXG5cdCAqIFx0ZXZlbnQuY29udHJvbGxlciAvLyBjb250cm9sbGVyIHRoYXQgd2FzIG1vZGlmaWVkXG5cdCAqIH0gKTtcblx0ICovXG5cdG9uRmluaXNoQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uRmluaXNoQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlXG5cdFx0ICogZGlyZWN0bHkuIFVzZSB0aGUgYGd1aS5vbkZpbmlzaENoYW5nZSggY2FsbGJhY2sgKWAgbWV0aG9kIGluc3RlYWQuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdHRoaXMuX29uRmluaXNoQ2hhbmdlID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfY2FsbE9uRmluaXNoQ2hhbmdlKCBjb250cm9sbGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcblx0XHRcdHRoaXMucGFyZW50Ll9jYWxsT25GaW5pc2hDaGFuZ2UoIGNvbnRyb2xsZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX29uRmluaXNoQ2hhbmdlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9vbkZpbmlzaENoYW5nZS5jYWxsKCB0aGlzLCB7XG5cdFx0XHRcdG9iamVjdDogY29udHJvbGxlci5vYmplY3QsXG5cdFx0XHRcdHByb3BlcnR5OiBjb250cm9sbGVyLnByb3BlcnR5LFxuXHRcdFx0XHR2YWx1ZTogY29udHJvbGxlci5nZXRWYWx1ZSgpLFxuXHRcdFx0XHRjb250cm9sbGVyXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGlzIEdVSSBvciBpdHMgZGVzY2VuZGFudHMgYXJlIG9wZW5lZCBvciBjbG9zZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oR1VJKX0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5vbk9wZW5DbG9zZSggY2hhbmdlZEdVSSA9PiB7XG5cdCAqIFx0Y29uc29sZS5sb2coIGNoYW5nZWRHVUkuX2Nsb3NlZCApO1xuXHQgKiB9ICk7XG5cdCAqL1xuXHRvbk9wZW5DbG9zZSggY2FsbGJhY2sgKSB7XG5cdFx0dGhpcy5fb25PcGVuQ2xvc2UgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9jYWxsT25PcGVuQ2xvc2UoIGNoYW5nZWRHVUkgKSB7XG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcblx0XHRcdHRoaXMucGFyZW50Ll9jYWxsT25PcGVuQ2xvc2UoIGNoYW5nZWRHVUkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX29uT3BlbkNsb3NlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9vbk9wZW5DbG9zZS5jYWxsKCB0aGlzLCBjaGFuZ2VkR1VJICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIGFsbCBET00gZWxlbWVudHMgYW5kIGV2ZW50IGxpc3RlbmVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBHVUkuXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcblx0XHRcdHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZiggdGhpcyApLCAxICk7XG5cdFx0XHR0aGlzLnBhcmVudC5mb2xkZXJzLnNwbGljZSggdGhpcy5wYXJlbnQuZm9sZGVycy5pbmRleE9mKCB0aGlzICksIDEgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50ICkge1xuXHRcdFx0dGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXHRcdH1cblxuXHRcdEFycmF5LmZyb20oIHRoaXMuY2hpbGRyZW4gKS5mb3JFYWNoKCBjID0+IGMuZGVzdHJveSgpICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbnRyb2xsZXJzIGNvbnRhaW5lZCBieSB0aGlzIEdVSSBhbmQgaXRzIGRlc2NlbmRlbnRzLlxuXHQgKiBAcmV0dXJucyB7Q29udHJvbGxlcltdfVxuXHQgKi9cblx0Y29udHJvbGxlcnNSZWN1cnNpdmUoKSB7XG5cdFx0bGV0IGNvbnRyb2xsZXJzID0gQXJyYXkuZnJvbSggdGhpcy5jb250cm9sbGVycyApO1xuXHRcdHRoaXMuZm9sZGVycy5mb3JFYWNoKCBmID0+IHtcblx0XHRcdGNvbnRyb2xsZXJzID0gY29udHJvbGxlcnMuY29uY2F0KCBmLmNvbnRyb2xsZXJzUmVjdXJzaXZlKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGNvbnRyb2xsZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9sZGVycyBjb250YWluZWQgYnkgdGhpcyBHVUkgYW5kIGl0cyBkZXNjZW5kZW50cy5cblx0ICogQHJldHVybnMge0dVSVtdfVxuXHQgKi9cblx0Zm9sZGVyc1JlY3Vyc2l2ZSgpIHtcblx0XHRsZXQgZm9sZGVycyA9IEFycmF5LmZyb20oIHRoaXMuZm9sZGVycyApO1xuXHRcdHRoaXMuZm9sZGVycy5mb3JFYWNoKCBmID0+IHtcblx0XHRcdGZvbGRlcnMgPSBmb2xkZXJzLmNvbmNhdCggZi5mb2xkZXJzUmVjdXJzaXZlKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZvbGRlcnM7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBHVUk7XG5leHBvcnQgeyBCb29sZWFuQ29udHJvbGxlciwgQ29sb3JDb250cm9sbGVyLCBDb250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIEdVSSwgTnVtYmVyQ29udHJvbGxlciwgT3B0aW9uQ29udHJvbGxlciwgU3RyaW5nQ29udHJvbGxlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7429\n")}}]);