"use strict";(self.webpackChunk_masatomakino_pixijs_particle_waypoint=self.webpackChunk_masatomakino_pixijs_particle_waypoint||[]).push([[737],{4687:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/ResizePlugin.mjs\n\n\n"use strict";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      "resizeTo",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer\'s view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener("resize", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener("resize", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/TickerPlugin.mjs\n\n\n\n\n"use strict";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      "ticker",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, ticker_const/* UPDATE_PRIORITY */.u.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker/* Ticker */.v.shared : new Ticker/* Ticker */.v();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(ResizePlugin);\nExtensions/* extensions */.Rw.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWE7O0FBRWQ7QUFDeEI7Ozs7Ozs7QUN4RjZEO0FBQ1A7QUFDUjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQWU7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFNLGNBQWMsb0JBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFhOztBQUVkO0FBQ3hCOzs7QUNoRTBEO0FBQ1I7QUFDQTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxZQUFZO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXBwL1Jlc2l6ZVBsdWdpbi5tanM/ZmIzZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hcHAvVGlja2VyUGx1Z2luLm1qcz83OGUyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9pbml0Lm1qcz9lNmNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIGFwcC5BcHBsaWNhdGlvbiNcbiAgICAgICAqL1xuICAgICAge1xuICAgICAgICBzZXQoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYW5jZWxSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH07XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKTtcbiAgICAgICAgdGhpcy5fcmVzaXplSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc2l6ZVRvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi4vdGlja2VyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi90aWNrZXIvVGlja2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHBsdWdpbiB3aXRoIHNjb3BlIG9mIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAqIEBzdGF0aWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFNlZSBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgc2hhcmVkVGlja2VyOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICBcInRpY2tlclwiLFxuICAgICAge1xuICAgICAgICBzZXQodGlja2VyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH07XG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIoKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgY29uc3Qgb2xkVGlja2VyID0gdGhpcy5fdGlja2VyO1xuICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9SZXNpemVQbHVnaW4ubWpzJztcbmltcG9ydCB7IFRpY2tlclBsdWdpbiB9IGZyb20gJy4vVGlja2VyUGx1Z2luLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4687\n')},9249:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterPipe.mjs\n\n\n"use strict";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      canBundle: false,\n      action: "pushFilter",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === "pushFilter") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === "popFilter") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(1980);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.isRenderGroupRoot) {\n    bounds.applyMatrix(target.renderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.isRenderGroupRoot || manageEffects) {\n    localBounds = matrixAndBoundsPool/* boundsPool */.W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.renderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  } else if (target.isRenderGroupRoot) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  }\n}\n\n\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs\n\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getRenderableBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst quadGeometry = new Geometry/* Geometry */.Z({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: "float32x2",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup/* UniformGroup */.o({\n      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }\n    });\n    this._globalFilterBindGroup = new BindGroup/* BindGroup */.v({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== "inherit") {\n        if (filter.antialias === "on") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        (0,warn/* warn */.Z)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    bounds.scale(resolution).fit(renderer.renderTarget.rootViewPort).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture/* Texture */.x.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool/* TexturePool */.z.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(flip);\n      TexturePool/* TexturePool */.z.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool/* TexturePool */.z.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point/* Point */.E.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture/* Texture */.x) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: "triangle-list"\n    });\n    if (renderer.type === types/* RendererType */.g.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds/* Bounds */.Y(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix/* Matrix */.y.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(FilterSystem);\nExtensions/* extensions */.Rw.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQix5QkFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCOzs7QUN0VjBEO0FBQ1o7QUFDSTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxVQUFVO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9GaWx0ZXJQaXBlLm1qcz82NGEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanM/MmI5MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldFJlbmRlcmFibGVCb3VuZHMubWpzP2MzYjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9GaWx0ZXJTeXN0ZW0ubWpzP2MyOGQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9pbml0Lm1qcz9kZGVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGaWx0ZXJQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHB1c2goZmlsdGVyRWZmZWN0LCBjb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgcmVuZGVyUGlwZXMgPSB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcztcbiAgICByZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2UsXG4gICAgICBhY3Rpb246IFwicHVzaEZpbHRlclwiLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgZmlsdGVyRWZmZWN0XG4gICAgfSk7XG4gIH1cbiAgcG9wKF9maWx0ZXJFZmZlY3QsIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiZmlsdGVyXCIsXG4gICAgICBhY3Rpb246IFwicG9wRmlsdGVyXCIsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShpbnN0cnVjdGlvbikge1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicHVzaEZpbHRlclwiKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5maWx0ZXIucHVzaChpbnN0cnVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicG9wRmlsdGVyXCIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkZpbHRlclBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImZpbHRlclwiXG59O1xuXG5leHBvcnQgeyBGaWx0ZXJQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IGJvdW5kc1Bvb2wgfSBmcm9tICcuL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuZnVuY3Rpb24gZ2V0RmFzdEdsb2JhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcykge1xuICBib3VuZHMuY2xlYXIoKTtcbiAgX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZSh0YXJnZXQsIGJvdW5kcyk7XG4gIGlmICghYm91bmRzLmlzVmFsaWQpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9XG4gIGlmICghdGFyZ2V0LmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgYm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5yZW5kZXJHcm91cC5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUodGFyZ2V0LCBib3VuZHMpIHtcbiAgaWYgKHRhcmdldC5sb2NhbERpc3BsYXlTdGF0dXMgIT09IDcgfHwgIXRhcmdldC5tZWFzdXJhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hbmFnZUVmZmVjdHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgbGV0IGxvY2FsQm91bmRzID0gYm91bmRzO1xuICBpZiAodGFyZ2V0LmlzUmVuZGVyR3JvdXBSb290IHx8IG1hbmFnZUVmZmVjdHMpIHtcbiAgICBsb2NhbEJvdW5kcyA9IGJvdW5kc1Bvb2wuZ2V0KCkuY2xlYXIoKTtcbiAgfVxuICBpZiAodGFyZ2V0LmJvdW5kc0FyZWEpIHtcbiAgICBib3VuZHMuYWRkUmVjdCh0YXJnZXQuYm91bmRzQXJlYSwgdGFyZ2V0LndvcmxkVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGFyZ2V0LnJlbmRlclBpcGVJZCkge1xuICAgICAgY29uc3Qgdmlld0JvdW5kcyA9IHRhcmdldC5ib3VuZHM7XG4gICAgICBsb2NhbEJvdW5kcy5hZGRGcmFtZShcbiAgICAgICAgdmlld0JvdW5kcy5taW5YLFxuICAgICAgICB2aWV3Qm91bmRzLm1pblksXG4gICAgICAgIHZpZXdCb3VuZHMubWF4WCxcbiAgICAgICAgdmlld0JvdW5kcy5tYXhZLFxuICAgICAgICB0YXJnZXQuZ3JvdXBUcmFuc2Zvcm1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUoY2hpbGRyZW5baV0sIGxvY2FsQm91bmRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hbmFnZUVmZmVjdHMpIHtcbiAgICBsZXQgYWR2YW5jZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0LmVmZmVjdHNbaV0uYWRkQm91bmRzKSB7XG4gICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICBhZHZhbmNlZCA9IHRydWU7XG4gICAgICAgICAgbG9jYWxCb3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZWZmZWN0c1tpXS5hZGRCb3VuZHMobG9jYWxCb3VuZHMsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWR2YW5jZWQpIHtcbiAgICAgIGxvY2FsQm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGVtcE1hdHJpeCkuaW52ZXJ0KCkpO1xuICAgICAgYm91bmRzLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdGFyZ2V0LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzKTtcbiAgICBib3VuZHNQb29sLnJldHVybihsb2NhbEJvdW5kcyk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0LmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdGFyZ2V0LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0pO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGxvY2FsQm91bmRzKTtcbiAgfVxufVxuXG5leHBvcnQgeyBfZ2V0R2xvYmFsQm91bmRzUmVjdXJzaXZlLCBnZXRGYXN0R2xvYmFsQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGYXN0R2xvYmFsQm91bmRzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyhyZW5kZXJhYmxlcywgYm91bmRzKSB7XG4gIGJvdW5kcy5jbGVhcigpO1xuICBjb25zdCB0ZW1wTWF0cml4ID0gYm91bmRzLm1hdHJpeDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcbiAgICBpZiAocmVuZGVyYWJsZS5nbG9iYWxEaXNwbGF5U3RhdHVzIDwgNykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJvdW5kcy5tYXRyaXggPSByZW5kZXJhYmxlLndvcmxkVHJhbnNmb3JtO1xuICAgIHJlbmRlcmFibGUuYWRkQm91bmRzKGJvdW5kcyk7XG4gIH1cbiAgYm91bmRzLm1hdHJpeCA9IHRlbXBNYXRyaXg7XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmV4cG9ydCB7IGdldEdsb2JhbFJlbmRlcmFibGVCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlbmRlcmFibGVCb3VuZHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0RmFzdEdsb2JhbEJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0UmVuZGVyYWJsZUJvdW5kcy5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHF1YWRHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSh7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhUG9zaXRpb246IHtcbiAgICAgIGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLFxuICAgICAgbG9jYXRpb246IDAsXG4gICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9LFxuICBpbmRleEJ1ZmZlcjogbmV3IFVpbnQzMkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSlcbn0pO1xuY2xhc3MgRmlsdGVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJTdGFja0luZGV4ID0gMDtcbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuX2ZpbHRlckdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1SW5wdXRTaXplOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1SW5wdXRQaXhlbDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUlucHV0Q2xhbXA6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVPdXRwdXRGcmFtZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUdsb2JhbEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1T3V0cHV0VGV4dHVyZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9XG4gICAgfSk7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwID0gbmV3IEJpbmRHcm91cCh7fSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFjayB0ZXh0dXJlIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbHRlci4gUmVxdWlyZXMgdGhlIGZpbHRlciB0byBoYXZlIGBibGVuZFJlcXVpcmVkYCBzZXQgdG8gdHJ1ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYWN0aXZlQmFja1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUZpbHRlckRhdGE/LmJhY2tUZXh0dXJlO1xuICB9XG4gIHB1c2goaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgZmlsdGVycyA9IGluc3RydWN0aW9uLmZpbHRlckVmZmVjdC5maWx0ZXJzO1xuICAgIGlmICghdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF0pIHtcbiAgICAgIHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXhdID0gdGhpcy5fZ2V0RmlsdGVyRGF0YSgpO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgdGhpcy5fZmlsdGVyU3RhY2tJbmRleCsrO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmlsdGVyRGF0YS5za2lwID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgaWYgKGluc3RydWN0aW9uLnJlbmRlcmFibGVzKSB7XG4gICAgICBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzKGluc3RydWN0aW9uLnJlbmRlcmFibGVzLCBib3VuZHMpO1xuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEpIHtcbiAgICAgIGJvdW5kcy5jbGVhcigpO1xuICAgICAgYm91bmRzLmFkZFJlY3QoaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEpO1xuICAgICAgYm91bmRzLmFwcGx5TWF0cml4KGluc3RydWN0aW9uLmNvbnRhaW5lci53b3JsZFRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldEZhc3RHbG9iYWxCb3VuZHMoaW5zdHJ1Y3Rpb24uY29udGFpbmVyLCBib3VuZHMpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvclRleHR1cmVTb3VyY2UgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFJlbmRlclRhcmdldC5jb2xvclRleHR1cmUuc291cmNlO1xuICAgIGxldCByZXNvbHV0aW9uID0gY29sb3JUZXh0dXJlU291cmNlLl9yZXNvbHV0aW9uO1xuICAgIGxldCBwYWRkaW5nID0gMDtcbiAgICBsZXQgYW50aWFsaWFzID0gY29sb3JUZXh0dXJlU291cmNlLmFudGlhbGlhcztcbiAgICBsZXQgYmxlbmRSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWluKHJlc29sdXRpb24sIGZpbHRlci5yZXNvbHV0aW9uKTtcbiAgICAgIHBhZGRpbmcgKz0gZmlsdGVyLnBhZGRpbmc7XG4gICAgICBpZiAoZmlsdGVyLmFudGlhbGlhcyAhPT0gXCJpbmhlcml0XCIpIHtcbiAgICAgICAgaWYgKGZpbHRlci5hbnRpYWxpYXMgPT09IFwib25cIikge1xuICAgICAgICAgIGFudGlhbGlhcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW50aWFsaWFzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ29tcGF0aWJsZSA9ICEhKGZpbHRlci5jb21wYXRpYmxlUmVuZGVyZXJzICYgcmVuZGVyZXIudHlwZSk7XG4gICAgICBpZiAoIWlzQ29tcGF0aWJsZSkge1xuICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci5ibGVuZFJlcXVpcmVkICYmICEocmVuZGVyZXIuYmFja0J1ZmZlcj8udXNlQmFja0J1ZmZlciA/PyB0cnVlKSkge1xuICAgICAgICB3YXJuKFwiQmxlbmQgZmlsdGVyIHJlcXVpcmVzIGJhY2tCdWZmZXIgb24gV2ViR0wgcmVuZGVyZXIgdG8gYmUgZW5hYmxlZC4gU2V0IGB1c2VCYWNrQnVmZmVyOiB0cnVlYCBpbiB0aGUgcmVuZGVyZXIgb3B0aW9ucy5cIik7XG4gICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbmFibGVkID0gZmlsdGVyLmVuYWJsZWQgfHwgZW5hYmxlZDtcbiAgICAgIGJsZW5kUmVxdWlyZWQgPSBibGVuZFJlcXVpcmVkIHx8IGZpbHRlci5ibGVuZFJlcXVpcmVkO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIGZpbHRlckRhdGEuc2tpcCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJvdW5kcy5zY2FsZShyZXNvbHV0aW9uKS5maXQocmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJvb3RWaWV3UG9ydCkuc2NhbGUoMSAvIHJlc29sdXRpb24pLnBhZChwYWRkaW5nKS5jZWlsKCk7XG4gICAgaWYgKCFib3VuZHMuaXNQb3NpdGl2ZSkge1xuICAgICAgZmlsdGVyRGF0YS5za2lwID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmlsdGVyRGF0YS5za2lwID0gZmFsc2U7XG4gICAgZmlsdGVyRGF0YS5ib3VuZHMgPSBib3VuZHM7XG4gICAgZmlsdGVyRGF0YS5ibGVuZFJlcXVpcmVkID0gYmxlbmRSZXF1aXJlZDtcbiAgICBmaWx0ZXJEYXRhLmNvbnRhaW5lciA9IGluc3RydWN0aW9uLmNvbnRhaW5lcjtcbiAgICBmaWx0ZXJEYXRhLmZpbHRlckVmZmVjdCA9IGluc3RydWN0aW9uLmZpbHRlckVmZmVjdDtcbiAgICBmaWx0ZXJEYXRhLnByZXZpb3VzUmVuZGVyU3VyZmFjZSA9IHJlbmRlcmVyLnJlbmRlclRhcmdldC5yZW5kZXJTdXJmYWNlO1xuICAgIGZpbHRlckRhdGEuaW5wdXRUZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICBib3VuZHMud2lkdGgsXG4gICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGFudGlhbGlhc1xuICAgICk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmJpbmQoZmlsdGVyRGF0YS5pbnB1dFRleHR1cmUsIHRydWUpO1xuICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnB1c2goe1xuICAgICAgb2Zmc2V0OiBib3VuZHNcbiAgICB9KTtcbiAgfVxuICBwb3AoKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrSW5kZXgtLTtcbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgaWYgKGZpbHRlckRhdGEuc2tpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVGaWx0ZXJEYXRhID0gZmlsdGVyRGF0YTtcbiAgICBjb25zdCBpbnB1dFRleHR1cmUgPSBmaWx0ZXJEYXRhLmlucHV0VGV4dHVyZTtcbiAgICBjb25zdCBib3VuZHMgPSBmaWx0ZXJEYXRhLmJvdW5kcztcbiAgICBsZXQgYmFja1RleHR1cmUgPSBUZXh0dXJlLkVNUFRZO1xuICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgaWYgKGZpbHRlckRhdGEuYmxlbmRSZXF1aXJlZCkge1xuICAgICAgY29uc3QgcHJldmlvdXNCb3VuZHMgPSB0aGlzLl9maWx0ZXJTdGFja0luZGV4ID4gMCA/IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXggLSAxXS5ib3VuZHMgOiBudWxsO1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmdldFJlbmRlclRhcmdldChmaWx0ZXJEYXRhLnByZXZpb3VzUmVuZGVyU3VyZmFjZSk7XG4gICAgICBiYWNrVGV4dHVyZSA9IHRoaXMuZ2V0QmFja1RleHR1cmUocmVuZGVyVGFyZ2V0LCBib3VuZHMsIHByZXZpb3VzQm91bmRzKTtcbiAgICB9XG4gICAgZmlsdGVyRGF0YS5iYWNrVGV4dHVyZSA9IGJhY2tUZXh0dXJlO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXJEYXRhLmZpbHRlckVmZmVjdC5maWx0ZXJzO1xuICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShpbnB1dFRleHR1cmUuc291cmNlLnN0eWxlLCAyKTtcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoYmFja1RleHR1cmUuc291cmNlLCAzKTtcbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5wb3AoKTtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcywgaW5wdXRUZXh0dXJlLCBmaWx0ZXJEYXRhLnByZXZpb3VzUmVuZGVyU3VyZmFjZSwgZmFsc2UpO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShpbnB1dFRleHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZmxpcCA9IGZpbHRlckRhdGEuaW5wdXRUZXh0dXJlO1xuICAgICAgbGV0IGZsb3AgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgICBmbGlwLnNvdXJjZS5fcmVzb2x1dGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICAgICAgZmlsdGVyLmFwcGx5KHRoaXMsIGZsaXAsIGZsb3AsIHRydWUpO1xuICAgICAgICBjb25zdCB0ID0gZmxpcDtcbiAgICAgICAgZmxpcCA9IGZsb3A7XG4gICAgICAgIGZsb3AgPSB0O1xuICAgICAgfVxuICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBmaWx0ZXJEYXRhLnByZXZpb3VzUmVuZGVyU3VyZmFjZSwgZmFsc2UpO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShmbGlwKTtcbiAgICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoZmxvcCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJEYXRhLmJsZW5kUmVxdWlyZWQpIHtcbiAgICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYmFja1RleHR1cmUpO1xuICAgIH1cbiAgfVxuICBnZXRCYWNrVGV4dHVyZShsYXN0UmVuZGVyU3VyZmFjZSwgYm91bmRzLCBwcmV2aW91c0JvdW5kcykge1xuICAgIGNvbnN0IGJhY2tncm91bmRSZXNvbHV0aW9uID0gbGFzdFJlbmRlclN1cmZhY2UuY29sb3JUZXh0dXJlLnNvdXJjZS5fcmVzb2x1dGlvbjtcbiAgICBjb25zdCBiYWNrVGV4dHVyZSA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgYm91bmRzLmhlaWdodCxcbiAgICAgIGJhY2tncm91bmRSZXNvbHV0aW9uLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGxldCB4ID0gYm91bmRzLm1pblg7XG4gICAgbGV0IHkgPSBib3VuZHMubWluWTtcbiAgICBpZiAocHJldmlvdXNCb3VuZHMpIHtcbiAgICAgIHggLT0gcHJldmlvdXNCb3VuZHMubWluWDtcbiAgICAgIHkgLT0gcHJldmlvdXNCb3VuZHMubWluWTtcbiAgICB9XG4gICAgeCA9IE1hdGguZmxvb3IoeCAqIGJhY2tncm91bmRSZXNvbHV0aW9uKTtcbiAgICB5ID0gTWF0aC5mbG9vcih5ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKGJvdW5kcy53aWR0aCAqIGJhY2tncm91bmRSZXNvbHV0aW9uKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCAqIGJhY2tncm91bmRSZXNvbHV0aW9uKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRhcmdldC5jb3B5VG9UZXh0dXJlKFxuICAgICAgbGFzdFJlbmRlclN1cmZhY2UsXG4gICAgICBiYWNrVGV4dHVyZSxcbiAgICAgIHsgeCwgeSB9LFxuICAgICAgeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICB7IHg6IDAsIHk6IDAgfVxuICAgICk7XG4gICAgcmV0dXJuIGJhY2tUZXh0dXJlO1xuICB9XG4gIGFwcGx5RmlsdGVyKGZpbHRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgZmlsdGVyRGF0YSA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXhdO1xuICAgIGNvbnN0IGJvdW5kcyA9IGZpbHRlckRhdGEuYm91bmRzO1xuICAgIGNvbnN0IG9mZnNldCA9IFBvaW50LnNoYXJlZDtcbiAgICBjb25zdCBwcmV2aW91c1JlbmRlclN1cmZhY2UgPSBmaWx0ZXJEYXRhLnByZXZpb3VzUmVuZGVyU3VyZmFjZTtcbiAgICBjb25zdCBpc0ZpbmFsVGFyZ2V0ID0gcHJldmlvdXNSZW5kZXJTdXJmYWNlID09PSBvdXRwdXQ7XG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlbmRlclRhcmdldC5yb290UmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2ZpbHRlclN0YWNrSW5kZXggLSAxO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPiAwICYmIHRoaXMuX2ZpbHRlclN0YWNrW2N1cnJlbnRJbmRleF0uc2tpcCkge1xuICAgICAgLS1jdXJyZW50SW5kZXg7XG4gICAgfVxuICAgIGlmIChjdXJyZW50SW5kZXggPiAwKSB7XG4gICAgICByZXNvbHV0aW9uID0gdGhpcy5fZmlsdGVyU3RhY2tbY3VycmVudEluZGV4XS5pbnB1dFRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJVbmlmb3JtcyA9IHRoaXMuX2ZpbHRlckdsb2JhbFVuaWZvcm1zO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gZmlsdGVyVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgY29uc3Qgb3V0cHV0RnJhbWUgPSB1bmlmb3Jtcy51T3V0cHV0RnJhbWU7XG4gICAgY29uc3QgaW5wdXRTaXplID0gdW5pZm9ybXMudUlucHV0U2l6ZTtcbiAgICBjb25zdCBpbnB1dFBpeGVsID0gdW5pZm9ybXMudUlucHV0UGl4ZWw7XG4gICAgY29uc3QgaW5wdXRDbGFtcCA9IHVuaWZvcm1zLnVJbnB1dENsYW1wO1xuICAgIGNvbnN0IGdsb2JhbEZyYW1lID0gdW5pZm9ybXMudUdsb2JhbEZyYW1lO1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmUgPSB1bmlmb3Jtcy51T3V0cHV0VGV4dHVyZTtcbiAgICBpZiAoaXNGaW5hbFRhcmdldCkge1xuICAgICAgbGV0IGxhc3RJbmRleCA9IHRoaXMuX2ZpbHRlclN0YWNrSW5kZXg7XG4gICAgICB3aGlsZSAobGFzdEluZGV4ID4gMCkge1xuICAgICAgICBsYXN0SW5kZXgtLTtcbiAgICAgICAgY29uc3QgZmlsdGVyRGF0YTIgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4IC0gMV07XG4gICAgICAgIGlmICghZmlsdGVyRGF0YTIuc2tpcCkge1xuICAgICAgICAgIG9mZnNldC54ID0gZmlsdGVyRGF0YTIuYm91bmRzLm1pblg7XG4gICAgICAgICAgb2Zmc2V0LnkgPSBmaWx0ZXJEYXRhMi5ib3VuZHMubWluWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0cHV0RnJhbWVbMF0gPSBib3VuZHMubWluWCAtIG9mZnNldC54O1xuICAgICAgb3V0cHV0RnJhbWVbMV0gPSBib3VuZHMubWluWSAtIG9mZnNldC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRGcmFtZVswXSA9IDA7XG4gICAgICBvdXRwdXRGcmFtZVsxXSA9IDA7XG4gICAgfVxuICAgIG91dHB1dEZyYW1lWzJdID0gaW5wdXQuZnJhbWUud2lkdGg7XG4gICAgb3V0cHV0RnJhbWVbM10gPSBpbnB1dC5mcmFtZS5oZWlnaHQ7XG4gICAgaW5wdXRTaXplWzBdID0gaW5wdXQuc291cmNlLndpZHRoO1xuICAgIGlucHV0U2l6ZVsxXSA9IGlucHV0LnNvdXJjZS5oZWlnaHQ7XG4gICAgaW5wdXRTaXplWzJdID0gMSAvIGlucHV0U2l6ZVswXTtcbiAgICBpbnB1dFNpemVbM10gPSAxIC8gaW5wdXRTaXplWzFdO1xuICAgIGlucHV0UGl4ZWxbMF0gPSBpbnB1dC5zb3VyY2UucGl4ZWxXaWR0aDtcbiAgICBpbnB1dFBpeGVsWzFdID0gaW5wdXQuc291cmNlLnBpeGVsSGVpZ2h0O1xuICAgIGlucHV0UGl4ZWxbMl0gPSAxIC8gaW5wdXRQaXhlbFswXTtcbiAgICBpbnB1dFBpeGVsWzNdID0gMSAvIGlucHV0UGl4ZWxbMV07XG4gICAgaW5wdXRDbGFtcFswXSA9IDAuNSAqIGlucHV0UGl4ZWxbMl07XG4gICAgaW5wdXRDbGFtcFsxXSA9IDAuNSAqIGlucHV0UGl4ZWxbM107XG4gICAgaW5wdXRDbGFtcFsyXSA9IGlucHV0LmZyYW1lLndpZHRoICogaW5wdXRTaXplWzJdIC0gMC41ICogaW5wdXRQaXhlbFsyXTtcbiAgICBpbnB1dENsYW1wWzNdID0gaW5wdXQuZnJhbWUuaGVpZ2h0ICogaW5wdXRTaXplWzNdIC0gMC41ICogaW5wdXRQaXhlbFszXTtcbiAgICBjb25zdCByb290VGV4dHVyZSA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJvb3RSZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlO1xuICAgIGdsb2JhbEZyYW1lWzBdID0gb2Zmc2V0LnggKiByZXNvbHV0aW9uO1xuICAgIGdsb2JhbEZyYW1lWzFdID0gb2Zmc2V0LnkgKiByZXNvbHV0aW9uO1xuICAgIGdsb2JhbEZyYW1lWzJdID0gcm9vdFRleHR1cmUuc291cmNlLndpZHRoICogcmVzb2x1dGlvbjtcbiAgICBnbG9iYWxGcmFtZVszXSA9IHJvb3RUZXh0dXJlLnNvdXJjZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LmdldFJlbmRlclRhcmdldChvdXRwdXQpO1xuICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5iaW5kKG91dHB1dCwgISFjbGVhcik7XG4gICAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIG91dHB1dFRleHR1cmVbMF0gPSBvdXRwdXQuZnJhbWUud2lkdGg7XG4gICAgICBvdXRwdXRUZXh0dXJlWzFdID0gb3V0cHV0LmZyYW1lLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0VGV4dHVyZVswXSA9IHJlbmRlclRhcmdldC53aWR0aDtcbiAgICAgIG91dHB1dFRleHR1cmVbMV0gPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgIH1cbiAgICBvdXRwdXRUZXh0dXJlWzJdID0gcmVuZGVyVGFyZ2V0LmlzUm9vdCA/IC0xIDogMTtcbiAgICBmaWx0ZXJVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBpZiAocmVuZGVyZXIucmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoKSB7XG4gICAgICBjb25zdCBiYXRjaFVuaWZvcm1zID0gcmVuZGVyZXIucmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoLmdldFVib1Jlc291cmNlKGZpbHRlclVuaWZvcm1zKTtcbiAgICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShiYXRjaFVuaWZvcm1zLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGZpbHRlclVuaWZvcm1zLCAwKTtcbiAgICB9XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGlucHV0LnNvdXJjZSwgMSk7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGlucHV0LnNvdXJjZS5zdHlsZSwgMik7XG4gICAgZmlsdGVyLmdyb3Vwc1swXSA9IHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cDtcbiAgICByZW5kZXJlci5lbmNvZGVyLmRyYXcoe1xuICAgICAgZ2VvbWV0cnk6IHF1YWRHZW9tZXRyeSxcbiAgICAgIHNoYWRlcjogZmlsdGVyLFxuICAgICAgc3RhdGU6IGZpbHRlci5fc3RhdGUsXG4gICAgICB0b3BvbG9neTogXCJ0cmlhbmdsZS1saXN0XCJcbiAgICB9KTtcbiAgICBpZiAocmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdMKSB7XG4gICAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuZmluaXNoUmVuZGVyUGFzcygpO1xuICAgIH1cbiAgfVxuICBfZ2V0RmlsdGVyRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2tpcDogZmFsc2UsXG4gICAgICBpbnB1dFRleHR1cmU6IG51bGwsXG4gICAgICBib3VuZHM6IG5ldyBCb3VuZHMoKSxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIGZpbHRlckVmZmVjdDogbnVsbCxcbiAgICAgIGJsZW5kUmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgcHJldmlvdXNSZW5kZXJTdXJmYWNlOiBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTXVsdGlwbHkgX2lucHV0IG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXNfIHRvIHRoaXMgbWF0cml4IHRvIGdldCBfc3ByaXRlIHRleHR1cmUgbm9ybWFsaXplZCBjb29yZGluYXRlc18uXG4gICAqXG4gICAqIFVzZSBgb3V0cHV0TWF0cml4ICogdlRleHR1cmVDb29yZGAgaW4gdGhlIHNoYWRlci5cbiAgICogQHBhcmFtIG91dHB1dE1hdHJpeCAtIFRoZSBtYXRyaXggdG8gb3V0cHV0IHRvLlxuICAgKiBAcGFyYW0ge1Nwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB0byBtYXAgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBtYXBwZWQgbWF0cml4LlxuICAgKi9cbiAgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgc3ByaXRlKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2FjdGl2ZUZpbHRlckRhdGE7XG4gICAgY29uc3QgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LnNldChcbiAgICAgIGRhdGEuaW5wdXRUZXh0dXJlLl9zb3VyY2Uud2lkdGgsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGRhdGEuaW5wdXRUZXh0dXJlLl9zb3VyY2UuaGVpZ2h0LFxuICAgICAgZGF0YS5ib3VuZHMubWluWCxcbiAgICAgIGRhdGEuYm91bmRzLm1pbllcbiAgICApO1xuICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHlUbyhNYXRyaXguc2hhcmVkKTtcbiAgICB3b3JsZFRyYW5zZm9ybS5pbnZlcnQoKTtcbiAgICBtYXBwZWRNYXRyaXgucHJlcGVuZCh3b3JsZFRyYW5zZm9ybSk7XG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKFxuICAgICAgMSAvIHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgMSAvIHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodFxuICAgICk7XG4gICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShzcHJpdGUuYW5jaG9yLngsIHNwcml0ZS5hbmNob3IueSk7XG4gICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkZpbHRlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiZmlsdGVyXCJcbn07XG5cbmV4cG9ydCB7IEZpbHRlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEZpbHRlclBpcGUgfSBmcm9tICcuL0ZpbHRlclBpcGUubWpzJztcbmltcG9ydCB7IEZpbHRlclN5c3RlbSB9IGZyb20gJy4vRmlsdGVyU3lzdGVtLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoRmlsdGVyU3lzdGVtKTtcbmV4dGVuc2lvbnMuYWRkKEZpbHRlclBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9249\n')},5774:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   y: () => (/* binding */ batchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4589);\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3870);\n\n\n\n"use strict";\nconst sampleValues = new Int32Array(_batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A);\nfor (let i = 0; i < _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A; i++) {\n  sampleValues[i] = i;\n}\nconst batchSamplersUniformGroup = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__/* .UniformGroup */ .o({\n  uTextures: { value: sampleValues, type: `i32`, size: _batcher_shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A }\n}, { isStatic: true });\n\n\n//# sourceMappingURL=batchSamplersUniformGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTtBQUNHOztBQUVwRTtBQUNBLG9DQUFvQyw0RUFBWTtBQUNoRCxnQkFBZ0IsSUFBSSw0RUFBWSxFQUFFO0FBQ2xDO0FBQ0E7QUFDQSxzQ0FBc0Msa0ZBQVk7QUFDbEQsZUFBZSx3Q0FBd0MsNEVBQVk7QUFDbkUsQ0FBQyxJQUFJLGdCQUFnQjs7QUFFZ0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcz8xZDg0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1BWF9URVhUVVJFUyB9IGZyb20gJy4uLy4uLy4uL2JhdGNoZXIvc2hhcmVkL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KE1BWF9URVhUVVJFUyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IE1BWF9URVhUVVJFUzsgaSsrKSB7XG4gIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG59XG5jb25zdCBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gIHVUZXh0dXJlczogeyB2YWx1ZTogc2FtcGxlVmFsdWVzLCB0eXBlOiBgaTMyYCwgc2l6ZTogTUFYX1RFWFRVUkVTIH1cbn0sIHsgaXNTdGF0aWM6IHRydWUgfSk7XG5cbmV4cG9ydCB7IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5774\n')},131:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4181);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const { width, height } = canvasAndContext.canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRTtBQUNOOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0VBQVE7QUFDdkIsZ0JBQWdCLHdFQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcz8xZDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBuZXh0UG93MiB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21pc2MvcG93Mi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhbnZhc1Bvb2xDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc09wdGlvbnMpIHtcbiAgICB0aGlzLl9jYW52YXNQb29sID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYW52YXNPcHRpb25zID0gY2FudmFzT3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0dXJlIHdpdGggcGFyYW1zIHRoYXQgd2VyZSBzcGVjaWZpZWQgaW4gcG9vbCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHBpeGVsV2lkdGggLSBXaWR0aCBvZiB0ZXh0dXJlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHBpeGVsSGVpZ2h0IC0gSGVpZ2h0IG9mIHRleHR1cmUgaW4gcGl4ZWxzLlxuICAgKi9cbiAgX2NyZWF0ZUNhbnZhc0FuZENvbnRleHQocGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IHBpeGVsV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHBpeGVsSGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxuICAgKiBAcGFyYW0gbWluV2lkdGggLSBUaGUgbWluaW11bSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHJldHVybnMgVGhlIG5ldyByZW5kZXIgdGV4dHVyZS5cbiAgICovXG4gIGdldE9wdGltYWxDYW52YXNBbmRDb250ZXh0KG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24gPSAxKSB7XG4gICAgbWluV2lkdGggPSBNYXRoLmNlaWwobWluV2lkdGggKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluSGVpZ2h0ID0gTWF0aC5jZWlsKG1pbkhlaWdodCAqIHJlc29sdXRpb24gLSAxZS02KTtcbiAgICBtaW5XaWR0aCA9IG5leHRQb3cyKG1pbldpZHRoKTtcbiAgICBtaW5IZWlnaHQgPSBuZXh0UG93MihtaW5IZWlnaHQpO1xuICAgIGNvbnN0IGtleSA9IChtaW5XaWR0aCA8PCAxNykgKyAobWluSGVpZ2h0IDw8IDEpO1xuICAgIGlmICghdGhpcy5fY2FudmFzUG9vbFtrZXldKSB7XG4gICAgICB0aGlzLl9jYW52YXNQb29sW2tleV0gPSBbXTtcbiAgICB9XG4gICAgbGV0IGNhbnZhc0FuZENvbnRleHQgPSB0aGlzLl9jYW52YXNQb29sW2tleV0ucG9wKCk7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgICBjYW52YXNBbmRDb250ZXh0ID0gdGhpcy5fY3JlYXRlQ2FudmFzQW5kQ29udGV4dChtaW5XaWR0aCwgbWluSGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0FuZENvbnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIFBsYWNlIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gY2FudmFzQW5kQ29udGV4dFxuICAgKi9cbiAgcmV0dXJuQ2FudmFzQW5kQ29udGV4dChjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBrZXkgPSAod2lkdGggPDwgMTcpICsgKGhlaWdodCA8PCAxKTtcbiAgICB0aGlzLl9jYW52YXNQb29sW2tleV0ucHVzaChjYW52YXNBbmRDb250ZXh0KTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYW52YXNQb29sID0ge307XG4gIH1cbn1cbmNvbnN0IENhbnZhc1Bvb2wgPSBuZXcgQ2FudmFzUG9vbENsYXNzKCk7XG5cbmV4cG9ydCB7IENhbnZhc1Bvb2wsIENhbnZhc1Bvb2xDbGFzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUG9vbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///131\n')},9010:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\nvar BatchableGraphics = __webpack_require__(26);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.Z.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    graphics.on("destroyed", () => {\n      this.destroyRenderable(graphics);\n    });\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      PoolGroup/* BigPool */.u.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GraphicsPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(GraphicsPipe);\nExtensions/* extensions */.Rw.add(GraphicsContextSystem/* GraphicsContextSystem */.hJ);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFtRTtBQUNTO0FBQ2hCO0FBQ0k7QUFDSjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTyxLQUFLLDBDQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUFPO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDNUk2RDtBQUNjO0FBQ2xCOztBQUV6RDtBQUNBLDZCQUFVLEtBQUssWUFBWTtBQUMzQiw2QkFBVSxLQUFLLG1EQUFxQjtBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc1BpcGUubWpzP2E5MjIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3MvaW5pdC5tanM/MDQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IGNvbG9yMzJCaXRUb1VuaWZvcm0gfSBmcm9tICcuLi9ncHUvY29sb3JUb1VuaWZvcm0ubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZUdyYXBoaWNzIH0gZnJvbSAnLi9CYXRjaGFibGVHcmFwaGljcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdyYXBoaWNzUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBhZGFwdG9yKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLmZvcjJkKCk7XG4gICAgLy8gYmF0Y2hhYmxlIGdyYXBoaWNzIGxpc3QsIHVzZWQgdG8gcmVuZGVyIGJhdGNoZXNcbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBhZGFwdG9yO1xuICAgIHRoaXMuX2FkYXB0b3IuaW5pdCgpO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jb250ZXh0O1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSAhIXRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXTtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSB8fCB3YXNCYXRjaGVkICE9PSBncHVDb250ZXh0LmlzQmF0Y2hhYmxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoZ3JhcGhpY3MsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMucmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0LnVwZGF0ZUdwdUNvbnRleHQoZ3JhcGhpY3MuY29udGV4dCk7XG4gICAgaWYgKGdyYXBoaWNzLl9kaWRHcmFwaGljc1VwZGF0ZSkge1xuICAgICAgZ3JhcGhpY3MuX2RpZEdyYXBoaWNzVXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWJ1aWxkKGdyYXBoaWNzKTtcbiAgICB9XG4gICAgaWYgKGdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIHRoaXMuX2FkZFRvQmF0Y2hlcihncmFwaGljcywgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICAgIGluc3RydWN0aW9uU2V0LmFkZChncmFwaGljcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoZ3JhcGhpY3MpIHtcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdO1xuICAgIGlmIChiYXRjaGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgICBiYXRjaC5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoYmF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGlmICh0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0pIHtcbiAgICAgIHRoaXMuX3JlbW92ZUJhdGNoRm9yUmVuZGVyYWJsZShncmFwaGljcy51aWQpO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKGdyYXBoaWNzKSB7XG4gICAgaWYgKCFncmFwaGljcy5pc1JlbmRlcmFibGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jb250ZXh0O1xuICAgIGNvbnN0IGNvbnRleHRTeXN0ZW0gPSByZW5kZXJlci5ncmFwaGljc0NvbnRleHQ7XG4gICAgaWYgKCFjb250ZXh0U3lzdGVtLmdldEdwdUNvbnRleHQoY29udGV4dCkuYmF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hhZGVyID0gY29udGV4dC5jdXN0b21TaGFkZXIgfHwgdGhpcy5fYWRhcHRvci5zaGFkZXI7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBncmFwaGljcy5ncm91cEJsZW5kTW9kZTtcbiAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0gc2hhZGVyLnJlc291cmNlcy5sb2NhbFVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIGxvY2FsVW5pZm9ybXMudVRyYW5zZm9ybU1hdHJpeCA9IGdyYXBoaWNzLmdyb3VwVHJhbnNmb3JtO1xuICAgIGxvY2FsVW5pZm9ybXMudVJvdW5kID0gcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgZ3JhcGhpY3MuX3JvdW5kUGl4ZWxzO1xuICAgIGNvbG9yMzJCaXRUb1VuaWZvcm0oXG4gICAgICBncmFwaGljcy5ncm91cENvbG9yQWxwaGEsXG4gICAgICBsb2NhbFVuaWZvcm1zLnVDb2xvcixcbiAgICAgIDBcbiAgICApO1xuICAgIHRoaXMuX2FkYXB0b3IuZXhlY3V0ZSh0aGlzLCBncmFwaGljcyk7XG4gIH1cbiAgX3JlYnVpbGQoZ3JhcGhpY3MpIHtcbiAgICBjb25zdCB3YXNCYXRjaGVkID0gISF0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF07XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMucmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0LnVwZGF0ZUdwdUNvbnRleHQoZ3JhcGhpY3MuY29udGV4dCk7XG4gICAgaWYgKHdhc0JhdGNoZWQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUJhdGNoRm9yUmVuZGVyYWJsZShncmFwaGljcy51aWQpO1xuICAgIH1cbiAgICBpZiAoZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSkge1xuICAgICAgdGhpcy5faW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgICB9XG4gICAgZ3JhcGhpY3MuYmF0Y2hlZCA9IGdwdUNvbnRleHQuaXNCYXRjaGFibGU7XG4gIH1cbiAgX2FkZFRvQmF0Y2hlcihncmFwaGljcywgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBiYXRjaFBpcGUgPSB0aGlzLnJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoO1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9nZXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBiYXRjaFBpcGUuYWRkVG9CYXRjaChiYXRjaCwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgfVxuICBfZ2V0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdIHx8IHRoaXMuX2luaXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcyk7XG4gIH1cbiAgX2luaXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jb250ZXh0O1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dC5nZXRHcHVDb250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IHJvdW5kUGl4ZWxzID0gdGhpcy5yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBncmFwaGljcy5fcm91bmRQaXhlbHM7XG4gICAgY29uc3QgYmF0Y2hlcyA9IGdwdUNvbnRleHQuYmF0Y2hlcy5tYXAoKGJhdGNoKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaENsb25lID0gQmlnUG9vbC5nZXQoQmF0Y2hhYmxlR3JhcGhpY3MpO1xuICAgICAgYmF0Y2guY29weVRvKGJhdGNoQ2xvbmUpO1xuICAgICAgYmF0Y2hDbG9uZS5yZW5kZXJhYmxlID0gZ3JhcGhpY3M7XG4gICAgICBiYXRjaENsb25lLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHM7XG4gICAgICByZXR1cm4gYmF0Y2hDbG9uZTtcbiAgICB9KTtcbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0gPSBiYXRjaGVzO1xuICAgIGdyYXBoaWNzLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoZ3JhcGhpY3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXRjaGVzO1xuICB9XG4gIF9yZW1vdmVCYXRjaEZvclJlbmRlcmFibGUoZ3JhcGhpY3NVaWQpIHtcbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzVWlkXS5mb3JFYWNoKChiYXRjaCkgPT4ge1xuICAgICAgQmlnUG9vbC5yZXR1cm4oYmF0Y2gpO1xuICAgIH0pO1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3NVaWRdID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2FkYXB0b3IuZGVzdHJveSgpO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoKSB7XG4gICAgICB0aGlzLl9yZW1vdmVCYXRjaEZvclJlbmRlcmFibGUoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2ggPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3JhcGhpY3NQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJncmFwaGljc1wiXG59O1xuXG5leHBvcnQgeyBHcmFwaGljc1BpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3NoYXJlZC9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzUGlwZSB9IGZyb20gJy4vc2hhcmVkL0dyYXBoaWNzUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEdyYXBoaWNzUGlwZSk7XG5leHRlbnNpb25zLmFkZChHcmFwaGljc0NvbnRleHRTeXN0ZW0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9010\n')},6475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ Graphics)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8400);\n/* harmony import */ var _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6653);\n\n\n\n\n"use strict";\nclass Graphics extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: "Graphics",\n      ...rest\n    });\n    this.canBundle = true;\n    this.renderPipeId = "graphics";\n    this._roundPixels = 0;\n    if (!context) {\n      this._context = this._ownedContext = new _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g();\n    } else {\n      this._context = context;\n    }\n    this._context.on("update", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off("update", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod("setFillStyle", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod("setStrokeStyle", args);\n  }\n  fill(...args) {\n    return this._callContextMethod("fill", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod("stroke", args);\n  }\n  texture(...args) {\n    return this._callContextMethod("texture", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod("beginPath", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod("cut", []);\n  }\n  arc(...args) {\n    return this._callContextMethod("arc", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod("arcTo", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod("arcToSvg", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod("bezierCurveTo", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod("closePath", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod("ellipse", args);\n  }\n  circle(...args) {\n    return this._callContextMethod("circle", args);\n  }\n  path(...args) {\n    return this._callContextMethod("path", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod("lineTo", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod("moveTo", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod("quadraticCurveTo", args);\n  }\n  rect(...args) {\n    return this._callContextMethod("rect", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod("roundRect", args);\n  }\n  poly(...args) {\n    return this._callContextMethod("poly", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod("regularPoly", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod("roundPoly", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod("roundShape", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod("filletRect", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod("chamferRect", args);\n  }\n  star(...args) {\n    return this._callContextMethod("star", args);\n  }\n  svg(...args) {\n    return this._callContextMethod("svg", args);\n  }\n  restore(...args) {\n    return this._callContextMethod("restore", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod("save", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod("resetTransform", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod("rotate", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod("scale", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod("setTransform", args);\n  }\n  transform(...args) {\n    return this._callContextMethod("transform", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod("translate", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod("clear", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.width || strokeStyle.color !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.color || strokeStyle.alpha !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawCircle has been renamed to Graphics#circle");\n    return this._callContextMethod("circle", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawEllipse has been renamed to Graphics#ellipse");\n    return this._callContextMethod("ellipse", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawPolygon has been renamed to Graphics#poly");\n    return this._callContextMethod("poly", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRect has been renamed to Graphics#rect");\n    return this._callContextMethod("rect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");\n    return this._callContextMethod("roundRect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawStar has been renamed to Graphics#star");\n    return this._callContextMethod("star", args);\n  }\n}\n\n\n//# sourceMappingURL=Graphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDbkI7QUFDRjs7QUFFeEQ7QUFDQSx1QkFBdUIseUVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQWU7QUFDMUMsa0JBQWtCO0FBQ2xCO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBFQUFlO0FBQzlELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQWUsbURBQW1ELDBFQUFlLG1EQUFtRCwwRUFBZTtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljcy5tanM/NDZhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0IH0gZnJvbSAnLi9HcmFwaGljc0NvbnRleHQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBHcmFwaGljcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGV4dDogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQsIHJvdW5kUGl4ZWxzLCAuLi5yZXN0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHtcbiAgICAgIGxhYmVsOiBcIkdyYXBoaWNzXCIsXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJncmFwaGljc1wiO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gMDtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9vd25lZENvbnRleHQgPSBuZXcgR3JhcGhpY3NDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLmFsbG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHMgPz8gZmFsc2U7XG4gIH1cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB0aGlzLl9jb250ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbnRleHQub2ZmKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgYm91bmRzIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBib3VuZHMgb2YgdGhpcyBvYmplY3QgdG8gdGhlIGJvdW5kcyBvYmplY3QuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUaGUgb3V0cHV0IGJvdW5kcyBvYmplY3QuXG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyh0aGlzLl9jb250ZXh0LmJvdW5kcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY29udGFpbnNQb2ludChwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqICBXaGV0aGVyIG9yIG5vdCB0byByb3VuZCB0aGUgeC95IHBvc2l0aW9uIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgb25WaWV3VXBkYXRlKCkge1xuICAgIHRoaXMuX2RpZENoYW5nZUlkICs9IDEgPDwgMTI7XG4gICAgdGhpcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5vbkNoaWxkVmlld1VwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgZ3JhcGhpY3MgcmVuZGVyYWJsZSBhbmQgb3B0aW9uYWxseSBpdHMgY29udGV4dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqXG4gICAqIElmIHRoZSBjb250ZXh0IHdhcyBjcmVhdGVkIGJ5IHRoaXMgZ3JhcGhpY3MgYW5kIGBkZXN0cm95KGZhbHNlKWAgb3IgYGRlc3Ryb3koKWAgaXMgY2FsbGVkXG4gICAqIHRoZW4gdGhlIGNvbnRleHQgd2lsbCBzdGlsbCBiZSBkZXN0cm95ZWQuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIGV4cGxpY2l0bHkgbm90IGRlc3Ryb3kgdGhpcyBjb250ZXh0IHRoYXQgdGhpcyBncmFwaGljcyBjcmVhdGVkLFxuICAgKiB0aGVuIHlvdSBzaG91bGQgcGFzcyBkZXN0cm95KHsgY29udGV4dDogZmFsc2UgfSlcbiAgICpcbiAgICogSWYgdGhlIGNvbnRleHQgd2FzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IgdGhlbiBpdCB3aWxsIG5vdCBiZSBkZXN0cm95ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb250ZXh0PWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSBjb250ZXh0XG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fb3duZWRDb250ZXh0ICYmICFvcHRpb25zKSB7XG4gICAgICB0aGlzLl9vd25lZENvbnRleHQuZGVzdHJveShvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUgfHwgb3B0aW9ucz8uY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fY29udGV4dC5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLl9vd25lZENvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbiAgX2NhbGxDb250ZXh0TWV0aG9kKG1ldGhvZCwgYXJncykge1xuICAgIHRoaXMuY29udGV4dFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHcmFwaGljc0NvbnRleHQgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgZmlsbCBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gVGhlIGZpbGwgc3R5bGUgY2FuIGJlIGEgY29sb3IsIGdyYWRpZW50LFxuICAgKiBwYXR0ZXJuLCBvciBhIG1vcmUgY29tcGxleCBzdHlsZSBkZWZpbmVkIGJ5IGEgRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSBUaGUgZmlsbCBzdHlsZSB0byBhcHBseS4gVGhpcyBjYW4gYmUgYSBzaW1wbGUgY29sb3IsIGEgZ3JhZGllbnQgb3JcbiAgICogcGF0dGVybiBvYmplY3QsIG9yIGEgRmlsbFN0eWxlIG9yIENvbnZlcnRlZEZpbGxTdHlsZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNldEZpbGxTdHlsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2V0RmlsbFN0eWxlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gU2ltaWxhciB0byBmaWxsIHN0eWxlcywgc3Ryb2tlIHN0eWxlcyBjYW5cbiAgICogZW5jb21wYXNzIGNvbG9ycywgZ3JhZGllbnRzLCBwYXR0ZXJucywgb3IgbW9yZSBkZXRhaWxlZCBjb25maWd1cmF0aW9ucyB2aWEgYSBTdHJva2VTdHlsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RmlsbFN0eWxlSW5wdXRzfSBhcmdzIC0gVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBjb2xvciwgYSBncmFkaWVudCBvciBwYXR0ZXJuLFxuICAgKiBvciBhIFN0cm9rZVN0eWxlIG9yIENvbnZlcnRlZFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0U3Ryb2tlU3R5bGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNldFN0cm9rZVN0eWxlXCIsIGFyZ3MpO1xuICB9XG4gIGZpbGwoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImZpbGxcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cm9rZXMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS4gVGhpcyBtZXRob2QgY2FuIHRha2UgYW4gb3B0aW9uYWxcbiAgICogRmlsbFN0eWxlSW5wdXRzIHBhcmFtZXRlciB0byBkZWZpbmUgdGhlIHN0cm9rZSdzIGFwcGVhcmFuY2UsIGluY2x1ZGluZyBpdHMgY29sb3IsIHdpZHRoLCBhbmQgb3RoZXIgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSAoT3B0aW9uYWwpIFRoZSBzdHJva2Ugc3R5bGUgdG8gYXBwbHkuIENhbiBiZSBkZWZpbmVkIGFzIGEgc2ltcGxlIGNvbG9yIG9yIGEgbW9yZVxuICAgKiBjb21wbGV4IHN0eWxlIG9iamVjdC4gSWYgb21pdHRlZCwgdXNlcyB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHN0cm9rZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic3Ryb2tlXCIsIGFyZ3MpO1xuICB9XG4gIHRleHR1cmUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInRleHR1cmVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCBwYXRoLiBBbnkgcHJldmlvdXMgcGF0aCBhbmQgaXRzIGNvbW1hbmRzIGFyZSBkaXNjYXJkZWQgYW5kIGEgbmV3IHBhdGggaXNcbiAgICogc3RhcnRlZC4gVGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkIGJlZm9yZSBiZWdpbm5pbmcgYSBuZXcgc2hhcGUgb3Igc2VyaWVzIG9mIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGJlZ2luUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJiZWdpblBhdGhcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgY3V0b3V0IHRvIHRoZSBsYXN0IGRyYXduIHNoYXBlLiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGhvbGVzIG9yIGNvbXBsZXggc2hhcGVzIGJ5XG4gICAqIHN1YnRyYWN0aW5nIGEgcGF0aCBmcm9tIHRoZSBwcmV2aW91c2x5IGRyYXduIHBhdGguIElmIGEgaG9sZSBpcyBub3QgY29tcGxldGVseSBpbiBhIHNoYXBlLCBpdCB3aWxsXG4gICAqIGZhaWwgdG8gY3V0IGNvcnJlY3RseSFcbiAgICovXG4gIGN1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjdXRcIiwgW10pO1xuICB9XG4gIGFyYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjXCIsIGFyZ3MpO1xuICB9XG4gIGFyY1RvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJhcmNUb1wiLCBhcmdzKTtcbiAgfVxuICBhcmNUb1N2ZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjVG9TdmdcIiwgYXJncyk7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYmV6aWVyQ3VydmVUb1wiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNsb3NlUGF0aFwiLCBbXSk7XG4gIH1cbiAgZWxsaXBzZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiZWxsaXBzZVwiLCBhcmdzKTtcbiAgfVxuICBjaXJjbGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNpcmNsZVwiLCBhcmdzKTtcbiAgfVxuICBwYXRoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwYXRoXCIsIGFyZ3MpO1xuICB9XG4gIGxpbmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwibGluZVRvXCIsIGFyZ3MpO1xuICB9XG4gIG1vdmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwibW92ZVRvXCIsIGFyZ3MpO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInF1YWRyYXRpY0N1cnZlVG9cIiwgYXJncyk7XG4gIH1cbiAgcmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVjdFwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUmVjdFwiLCBhcmdzKTtcbiAgfVxuICBwb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwb2x5XCIsIGFyZ3MpO1xuICB9XG4gIHJlZ3VsYXJQb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWd1bGFyUG9seVwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFBvbHkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUG9seVwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFNoYXBlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3VuZFNoYXBlXCIsIGFyZ3MpO1xuICB9XG4gIGZpbGxldFJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImZpbGxldFJlY3RcIiwgYXJncyk7XG4gIH1cbiAgY2hhbWZlclJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNoYW1mZXJSZWN0XCIsIGFyZ3MpO1xuICB9XG4gIHN0YXIoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInN0YXJcIiwgYXJncyk7XG4gIH1cbiAgc3ZnKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdmdcIiwgYXJncyk7XG4gIH1cbiAgcmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVzdG9yZVwiLCBhcmdzKTtcbiAgfVxuICAvKiogU2F2ZXMgdGhlIGN1cnJlbnQgZ3JhcGhpY3Mgc3RhdGUsIGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnMsIGZpbGwgc3R5bGVzLCBhbmQgc3Ryb2tlIHN0eWxlcywgb250byBhIHN0YWNrLiAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNhdmVcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgZ2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmdcbiAgICogYW55IHRyYW5zZm9ybWF0aW9ucyAocm90YXRpb24sIHNjYWxpbmcsIHRyYW5zbGF0aW9uKSBwcmV2aW91c2x5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlc2V0VHJhbnNmb3JtXCIsIFtdKTtcbiAgfVxuICByb3RhdGVUcmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdGF0ZVwiLCBhcmdzKTtcbiAgfVxuICBzY2FsZVRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2NhbGVcIiwgYXJncyk7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzZXRUcmFuc2Zvcm1cIiwgYXJncyk7XG4gIH1cbiAgdHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0cmFuc2Zvcm1cIiwgYXJncyk7XG4gIH1cbiAgdHJhbnNsYXRlVHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0cmFuc2xhdGVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgZHJhd2luZyBjb21tYW5kcyBmcm9tIHRoZSBncmFwaGljcyBjb250ZXh0LCBlZmZlY3RpdmVseSByZXNldHRpbmcgaXQuIFRoaXMgaW5jbHVkZXMgY2xlYXJpbmcgdGhlIHBhdGgsXG4gICAqIGFuZCBvcHRpb25hbGx5IHJlc2V0dGluZyB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2xlYXJcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZmlsbCBzdHlsZSB0byB1c2UuXG4gICAqIEB0eXBlIHtDb252ZXJ0ZWRGaWxsU3R5bGV9XG4gICAqL1xuICBnZXQgZmlsbFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZTtcbiAgfVxuICBzZXQgZmlsbFN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cm9rZSBzdHlsZSB0byB1c2UuXG4gICAqIEB0eXBlIHtDb252ZXJ0ZWRTdHJva2VTdHlsZX1cbiAgICovXG4gIGdldCBzdHJva2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5zdHJva2VTdHlsZTtcbiAgfVxuICBzZXQgc3Ryb2tlU3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3Mgb2JqZWN0LlxuICAgKiBOb3RlIHRoYXQgb25seSB0aGUgY29udGV4dCBvZiB0aGUgb2JqZWN0IGlzIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICogQHBhcmFtIGRlZXAgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIGRlZXAgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdC4gSWYgZmFsc2UsIHRoZSBjb250ZXh0XG4gICAqIHdpbGwgYmUgc2hhcmVkIGJldHdlZW4gdGhlIHR3byBvYmplY3RzIChkZWZhdWx0IGZhbHNlKS4gSWYgdHJ1ZSwgdGhlIGNvbnRleHQgd2lsbCBiZVxuICAgKiBjbG9uZWQgKHJlY29tbWVuZGVkIGlmIHlvdSBuZWVkIHRvIG1vZGlmeSB0aGUgY29udGV4dCBpbiBhbnkgd2F5KS5cbiAgICogQHJldHVybnMgLSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICovXG4gIGNsb25lKGRlZXAgPSBmYWxzZSkge1xuICAgIGlmIChkZWVwKSB7XG4gICAgICByZXR1cm4gbmV3IEdyYXBoaWNzKHRoaXMuX2NvbnRleHQuY2xvbmUoKSk7XG4gICAgfVxuICAgIHRoaXMuX293bmVkQ29udGV4dCA9IG51bGw7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgR3JhcGhpY3ModGhpcy5fY29udGV4dCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8vIC0tLS0tLS0tIHY3IGRlcHJlY2F0aW9ucyAtLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gY29sb3JcbiAgICogQHBhcmFtIGFscGhhXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGV9IGluc3RlYWRcbiAgICovXG4gIGxpbmVTdHlsZSh3aWR0aCwgY29sb3IsIGFscGhhKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2xpbmVTdHlsZSBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGUgdG8gc2V0IHRoZSBzdHJva2Ugc3R5bGUuXCIpO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0ge307XG4gICAgd2lkdGggJiYgKHN0cm9rZVN0eWxlLndpZHRoID0gd2lkdGgpO1xuICAgIGNvbG9yICYmIChzdHJva2VTdHlsZS5jb2xvciA9IGNvbG9yKTtcbiAgICBhbHBoYSAmJiAoc3Ryb2tlU3R5bGUuYWxwaGEgPSBhbHBoYSk7XG4gICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBjb2xvclxuICAgKiBAcGFyYW0gYWxwaGFcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNmaWxsfSBpbnN0ZWFkXG4gICAqL1xuICBiZWdpbkZpbGwoY29sb3IsIGFscGhhKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2JlZ2luRmlsbCBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3MjZmlsbCB0byBmaWxsIHRoZSBzaGFwZSB3aXRoIHRoZSBkZXNpcmVkIHN0eWxlLlwiKTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSB7fTtcbiAgICBjb2xvciAmJiAoZmlsbFN0eWxlLmNvbG9yID0gY29sb3IpO1xuICAgIGFscGhhICYmIChmaWxsU3R5bGUuYWxwaGEgPSBhbHBoYSk7XG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNmaWxsfSBpbnN0ZWFkXG4gICAqL1xuICBlbmRGaWxsKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNlbmRGaWxsIGlzIG5vIGxvbmdlciBuZWVkZWQuIFVzZSBHcmFwaGljcyNmaWxsIHRvIGZpbGwgdGhlIHNoYXBlIHdpdGggdGhlIGRlc2lyZWQgc3R5bGUuXCIpO1xuICAgIHRoaXMuY29udGV4dC5maWxsKCk7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKHN0cm9rZVN0eWxlLndpZHRoICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLndpZHRoIHx8IHN0cm9rZVN0eWxlLmNvbG9yICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLmNvbG9yIHx8IHN0cm9rZVN0eWxlLmFscGhhICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLmFscGhhKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2NpcmNsZX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd0NpcmNsZSguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdDaXJjbGUgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNjaXJjbGVcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2lyY2xlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2VsbGlwc2V9IGluc3RlYWRcbiAgICovXG4gIGRyYXdFbGxpcHNlKC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd0VsbGlwc2UgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNlbGxpcHNlXCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImVsbGlwc2VcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjcG9seX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1BvbHlnb24oLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3UG9seWdvbiBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI3BvbHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicG9seVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNyZWN0fSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3UmVjdCguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdSZWN0IGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3MjcmVjdFwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWN0XCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3JvdW5kUmVjdH0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1JvdW5kZWRSZWN0KC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd1JvdW5kZWRSZWN0IGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3Mjcm91bmRSZWN0XCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUmVjdFwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNzdGFyfSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3U3RhciguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdTdGFyIGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3Mjc3RhclwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdGFyXCIsIGFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCB7IEdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6475\n')},8540:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup/* UniformGroup */.o({\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    this.localUniformsBindGroup = new BindGroup/* BindGroup */.v({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: "mesh",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    PoolGroup/* BigPool */.u.return(gpuMesh);\n    this._gpuBatchableMeshHash[mesh.uid] = null;\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on("destroyed", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = PoolGroup/* BigPool */.u.get(BatchableMesh/* BatchableMesh */.X);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        PoolGroup/* BigPool */.u.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=MeshPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ1Q7QUFDd0I7QUFDUztBQUMvQjtBQUNnQjtBQUN4Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFZO0FBQ3pDLDBCQUEwQixXQUFXLG9CQUFNLHlCQUF5QjtBQUNwRSxnQkFBZ0IsMERBQTBEO0FBQzFFLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsc0NBQXNDLDBCQUFTO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBTztBQUNYO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBTyxLQUFLLGtDQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRW9CO0FBQ3BCOzs7QUNsSjZEO0FBQ1o7O0FBRWpEO0FBQ0EsNkJBQVUsS0FBSyxRQUFRO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9zaGFyZWQvTWVzaFBpcGUubWpzP2I1YzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9pbml0Lm1qcz83ZTZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci9CaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uLy4uL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4vQmF0Y2hhYmxlTWVzaC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE1lc2hQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIsIGFkYXB0b3IpIHtcbiAgICB0aGlzLmxvY2FsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6IHsgdmFsdWU6IG5ldyBNYXRyaXgoKSwgdHlwZTogXCJtYXQzeDM8ZjMyPlwiIH0sXG4gICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICB0aGlzLmxvY2FsVW5pZm9ybXNCaW5kR3JvdXAgPSBuZXcgQmluZEdyb3VwKHtcbiAgICAgIDA6IHRoaXMubG9jYWxVbmlmb3Jtc1xuICAgIH0pO1xuICAgIHRoaXMuX21lc2hEYXRhSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBhZGFwdG9yO1xuICAgIHRoaXMuX2FkYXB0b3IuaW5pdCgpO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShtZXNoKSB7XG4gICAgY29uc3QgbWVzaERhdGEgPSB0aGlzLl9nZXRNZXNoRGF0YShtZXNoKTtcbiAgICBjb25zdCB3YXNCYXRjaGVkID0gbWVzaERhdGEuYmF0Y2hlZDtcbiAgICBjb25zdCBpc0JhdGNoZWQgPSBtZXNoLmJhdGNoZWQ7XG4gICAgbWVzaERhdGEuYmF0Y2hlZCA9IGlzQmF0Y2hlZDtcbiAgICBpZiAod2FzQmF0Y2hlZCAhPT0gaXNCYXRjaGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQmF0Y2hlZCkge1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLl9nZW9tZXRyeTtcbiAgICAgIGlmIChnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCAhPT0gbWVzaERhdGEuaW5kZXhTaXplIHx8IGdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGggIT09IG1lc2hEYXRhLnZlcnRleFNpemUpIHtcbiAgICAgICAgbWVzaERhdGEuaW5kZXhTaXplID0gZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIG1lc2hEYXRhLnZlcnRleFNpemUgPSBnZW9tZXRyeS5wb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhdGNoYWJsZU1lc2ggPSB0aGlzLl9nZXRCYXRjaGFibGVNZXNoKG1lc2gpO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1lc2gudGV4dHVyZTtcbiAgICAgIGlmIChiYXRjaGFibGVNZXNoLnRleHR1cmUuX3NvdXJjZSAhPT0gdGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgIGlmIChiYXRjaGFibGVNZXNoLnRleHR1cmUuX3NvdXJjZSAhPT0gdGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoYWJsZU1lc2guYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoYmF0Y2hhYmxlTWVzaCwgdGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUobWVzaCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBiYXRjaGVyID0gdGhpcy5yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaDtcbiAgICBjb25zdCB7IGJhdGNoZWQgfSA9IHRoaXMuX2dldE1lc2hEYXRhKG1lc2gpO1xuICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICBjb25zdCBncHVCYXRjaGFibGVNZXNoID0gdGhpcy5fZ2V0QmF0Y2hhYmxlTWVzaChtZXNoKTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IG1lc2guX3RleHR1cmU7XG4gICAgICBncHVCYXRjaGFibGVNZXNoLmdlb21ldHJ5ID0gbWVzaC5fZ2VvbWV0cnk7XG4gICAgICBiYXRjaGVyLmFkZFRvQmF0Y2goZ3B1QmF0Y2hhYmxlTWVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhdGNoZXIuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgICAgcmVuZGVyUGlwZUlkOiBcIm1lc2hcIixcbiAgICAgICAgbWVzaFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUobWVzaCkge1xuICAgIGlmIChtZXNoLmJhdGNoZWQpIHtcbiAgICAgIGNvbnN0IGdwdUJhdGNoYWJsZU1lc2ggPSB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF07XG4gICAgICBncHVCYXRjaGFibGVNZXNoLnRleHR1cmUgPSBtZXNoLl90ZXh0dXJlO1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoZ3B1QmF0Y2hhYmxlTWVzaCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdID0gbnVsbDtcbiAgICBjb25zdCBncHVNZXNoID0gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdO1xuICAgIEJpZ1Bvb2wucmV0dXJuKGdwdU1lc2gpO1xuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXSA9IG51bGw7XG4gIH1cbiAgZXhlY3V0ZSh7IG1lc2ggfSkge1xuICAgIGlmICghbWVzaC5pc1JlbmRlcmFibGUpXG4gICAgICByZXR1cm47XG4gICAgbWVzaC5zdGF0ZS5ibGVuZE1vZGUgPSBtZXNoLmdyb3VwQmxlbmRNb2RlO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSB0aGlzLmxvY2FsVW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51bmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gbWVzaC5ncm91cFRyYW5zZm9ybTtcbiAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVSb3VuZCA9IHRoaXMucmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgbWVzaC5fcm91bmRQaXhlbHM7XG4gICAgbG9jYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBjb2xvcjMyQml0VG9Vbmlmb3JtKFxuICAgICAgbWVzaC5ncm91cENvbG9yQWxwaGEsXG4gICAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVDb2xvcixcbiAgICAgIDBcbiAgICApO1xuICAgIHRoaXMuX2FkYXB0b3IuZXhlY3V0ZSh0aGlzLCBtZXNoKTtcbiAgfVxuICBfZ2V0TWVzaERhdGEobWVzaCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdIHx8IHRoaXMuX2luaXRNZXNoRGF0YShtZXNoKTtcbiAgfVxuICBfaW5pdE1lc2hEYXRhKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdID0ge1xuICAgICAgYmF0Y2hlZDogbWVzaC5iYXRjaGVkLFxuICAgICAgaW5kZXhTaXplOiBtZXNoLl9nZW9tZXRyeS5pbmRpY2VzPy5sZW5ndGgsXG4gICAgICB2ZXJ0ZXhTaXplOiBtZXNoLl9nZW9tZXRyeS5wb3NpdGlvbnM/Lmxlbmd0aFxuICAgIH07XG4gICAgbWVzaC5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKG1lc2gpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdO1xuICB9XG4gIF9nZXRCYXRjaGFibGVNZXNoKG1lc2gpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdIHx8IHRoaXMuX2luaXRCYXRjaGFibGVNZXNoKG1lc2gpO1xuICB9XG4gIF9pbml0QmF0Y2hhYmxlTWVzaChtZXNoKSB7XG4gICAgY29uc3QgZ3B1TWVzaCA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZU1lc2gpO1xuICAgIGdwdU1lc2gubWVzaCA9IG1lc2g7XG4gICAgZ3B1TWVzaC50ZXh0dXJlID0gbWVzaC5fdGV4dHVyZTtcbiAgICBncHVNZXNoLnJvdW5kUGl4ZWxzID0gdGhpcy5yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBtZXNoLl9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF0gPSBncHVNZXNoO1xuICAgIGdwdU1lc2gubWVzaCA9IG1lc2g7XG4gICAgcmV0dXJuIGdwdU1lc2g7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2gpIHtcbiAgICAgIGlmICh0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFtpXSkge1xuICAgICAgICBCaWdQb29sLnJldHVybih0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2ggPSBudWxsO1xuICAgIHRoaXMubG9jYWxVbmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5sb2NhbFVuaWZvcm1zQmluZEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLl9hZGFwdG9yLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9hZGFwdG9yID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbk1lc2hQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJtZXNoXCJcbn07XG5cbmV4cG9ydCB7IE1lc2hQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNZXNoUGlwZSB9IGZyb20gJy4vc2hhcmVkL01lc2hQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoTWVzaFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8540\n')},2653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ BatchableMesh)\n/* harmony export */ });\n\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvs = geometry.uvs;\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = uvs[i];\n      float32View[index + 3] = uvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\n\n//# sourceMappingURL=BatchableMesh.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL3NoYXJlZC9CYXRjaGFibGVNZXNoLm1qcz82NGRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hhYmxlTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IDA7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNoLmdyb3VwQmxlbmRNb2RlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMubWVzaCA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoZXIgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2ggPSBudWxsO1xuICB9XG4gIHBhY2tJbmRleChpbmRleEJ1ZmZlciwgaW5kZXgsIGluZGljZXNPZmZzZXQpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeS5pbmRpY2VzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXhCdWZmZXJbaW5kZXgrK10gPSBpbmRpY2VzW2ldICsgaW5kaWNlc09mZnNldDtcbiAgICB9XG4gIH1cbiAgcGFja0F0dHJpYnV0ZXMoZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4LCB0ZXh0dXJlSWQpIHtcbiAgICBjb25zdCBtZXNoID0gdGhpcy5tZXNoO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBjb25zdCB3dCA9IG1lc2guZ3JvdXBUcmFuc2Zvcm07XG4gICAgY29uc3QgdGV4dHVyZUlkQW5kUm91bmQgPSB0ZXh0dXJlSWQgPDwgMTYgfCB0aGlzLnJvdW5kUGl4ZWxzICYgNjU1MzU7XG4gICAgY29uc3QgYSA9IHd0LmE7XG4gICAgY29uc3QgYiA9IHd0LmI7XG4gICAgY29uc3QgYyA9IHd0LmM7XG4gICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgY29uc3QgdHggPSB3dC50eDtcbiAgICBjb25zdCB0eSA9IHd0LnR5O1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LnBvc2l0aW9ucztcbiAgICBjb25zdCB1dnMgPSBnZW9tZXRyeS51dnM7XG4gICAgY29uc3QgYWJnciA9IG1lc2guZ3JvdXBDb2xvckFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gcG9zaXRpb25zW2ldO1xuICAgICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICBmbG9hdDMyVmlld1tpbmRleCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAyXSA9IHV2c1tpXTtcbiAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgdWludDMyVmlld1tpbmRleCArIDRdID0gYWJncjtcbiAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyA1XSA9IHRleHR1cmVJZEFuZFJvdW5kO1xuICAgICAgaW5kZXggKz0gNjtcbiAgICB9XG4gIH1cbiAgZ2V0IHZlcnRleFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkucG9zaXRpb25zLmxlbmd0aCAvIDI7XG4gIH1cbiAgZ2V0IGluZGV4U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5pbmRpY2VzLmxlbmd0aDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXRjaGFibGVNZXNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaGFibGVNZXNoLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2653\n")},4428:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   x: () => (/* binding */ MeshGeometry)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7494);\n/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5324);\n/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);\n\n\n\n\n\n"use strict";\nconst _MeshGeometry = class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .P, "use new MeshGeometry({ positions, uvs, indices }) instead");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: positions,\n      label: "attribute-mesh-positions",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const uvBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: uvs,\n      label: "attribute-mesh-uvs",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const indexBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: indices,\n      label: "index-mesh-buffer",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.INDEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = "auto";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: "triangle-list",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ0k7QUFDRTtBQUNSOztBQUU3RTtBQUNBLGtEQUFrRCxnR0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9GQUFXLENBQUMsMkVBQU0sMEJBQTBCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEZBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCx5QkFBeUIsMEZBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCw0QkFBNEIsMEZBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxTQUFTLDhGQUFXO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanM/NTdmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9jb25zdC5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfTWVzaEdlb21ldHJ5ID0gY2xhc3MgX01lc2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcInVzZSBuZXcgTWVzaEdlb21ldHJ5KHsgcG9zaXRpb25zLCB1dnMsIGluZGljZXMgfSkgaW5zdGVhZFwiKTtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHBvc2l0aW9uczogb3B0aW9ucyxcbiAgICAgICAgdXZzOiBhcmdzWzFdLFxuICAgICAgICBpbmRpY2VzOiBhcmdzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fTWVzaEdlb21ldHJ5LmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgcG9zaXRpb25zID0gb3B0aW9ucy5wb3NpdGlvbnMgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuICAgIGNvbnN0IHV2cyA9IG9wdGlvbnMudXZzIHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKTtcbiAgICBjb25zdCBpbmRpY2VzID0gb3B0aW9ucy5pbmRpY2VzIHx8IG5ldyBVaW50MzJBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pO1xuICAgIGNvbnN0IHNocmlua1RvRml0ID0gb3B0aW9ucy5zaHJpbmtCdWZmZXJzVG9GaXQ7XG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHBvc2l0aW9ucyxcbiAgICAgIGxhYmVsOiBcImF0dHJpYnV0ZS1tZXNoLXBvc2l0aW9uc1wiLFxuICAgICAgc2hyaW5rVG9GaXQsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuVkVSVEVYIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICB9KTtcbiAgICBjb25zdCB1dkJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogdXZzLFxuICAgICAgbGFiZWw6IFwiYXR0cmlidXRlLW1lc2gtdXZzXCIsXG4gICAgICBzaHJpbmtUb0ZpdCxcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5WRVJURVggfCBCdWZmZXJVc2FnZS5DT1BZX0RTVFxuICAgIH0pO1xuICAgIGNvbnN0IGluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcih7XG4gICAgICBkYXRhOiBpbmRpY2VzLFxuICAgICAgbGFiZWw6IFwiaW5kZXgtbWVzaC1idWZmZXJcIixcbiAgICAgIHNocmlua1RvRml0LFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLklOREVYIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGFQb3NpdGlvbjoge1xuICAgICAgICAgIGJ1ZmZlcjogcG9zaXRpb25CdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcImZsb2F0MzJ4MlwiLFxuICAgICAgICAgIHN0cmlkZTogMiAqIDQsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFVVjoge1xuICAgICAgICAgIGJ1ZmZlcjogdXZCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcImZsb2F0MzJ4MlwiLFxuICAgICAgICAgIHN0cmlkZTogMiAqIDQsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbmRleEJ1ZmZlcixcbiAgICAgIHRvcG9sb2d5OiBvcHRpb25zLnRvcG9sb2d5XG4gICAgfSk7XG4gICAgdGhpcy5iYXRjaE1vZGUgPSBcImF1dG9cIjtcbiAgfVxuICAvKiogVGhlIHBvc2l0aW9ucyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmFQb3NpdGlvbi5idWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgcG9zaXRpb25zKHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLmFQb3NpdGlvbi5idWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgVVZzIG9mIHRoZSBtZXNoLiAqL1xuICBnZXQgdXZzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuYVVWLmJ1ZmZlci5kYXRhO1xuICB9XG4gIHNldCB1dnModmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMuYVVWLmJ1ZmZlci5kYXRhID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBpbmRpY2VzIG9mIHRoZSBtZXNoLiAqL1xuICBnZXQgaW5kaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlci5kYXRhO1xuICB9XG4gIHNldCBpbmRpY2VzKHZhbHVlKSB7XG4gICAgdGhpcy5pbmRleEJ1ZmZlci5kYXRhID0gdmFsdWU7XG4gIH1cbn07XG5fTWVzaEdlb21ldHJ5LmRlZmF1bHRPcHRpb25zID0ge1xuICB0b3BvbG9neTogXCJ0cmlhbmdsZS1saXN0XCIsXG4gIHNocmlua0J1ZmZlcnNUb0ZpdDogZmFsc2Vcbn07XG5sZXQgTWVzaEdlb21ldHJ5ID0gX01lc2hHZW9tZXRyeTtcblxuZXhwb3J0IHsgTWVzaEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoR2VvbWV0cnkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4428\n')},2092:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs\n\n\n\n"use strict";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === "number") {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs\n\n\n\n"use strict";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this._textureMatrix = new Matrix/* Matrix */.y();\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    if (options.textureMatrix) {\n      this._textureMatrix.copyFrom(options.textureMatrix);\n    }\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer("aPosition").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const textureMatrix = this._textureMatrix;\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    multiplyUvs(textureMatrix, uvs);\n    this.getBuffer("aUV").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\nfunction multiplyUvs(matrix, uvs, out) {\n  out ?? (out = uvs);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  for (let i = 0; i < uvs.length; i += 2) {\n    const x = uvs[i];\n    const y = uvs[i + 1];\n    out[i] = x * a + y * c + tx;\n    out[i + 1] = x * b + y * d + ty;\n  }\n  return out;\n}\n\n\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs\n\n\n\n\n\n"use strict";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    PoolGroup/* BigPool */.u.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh/* BatchableMesh */.X();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on("destroyed", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "nineSliceSprite"\n};\n\n\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRTtBQUNYOztBQUUvRDtBQUNBLG9EQUFvRCxnQ0FBWTtBQUNoRTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsTUFBTSxrQ0FBVyxDQUFDLHlCQUFNLGtEQUFrRCxzQ0FBc0M7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCOzs7QUM3RXVEO0FBQ1M7O0FBRWhFO0FBQ0EsNERBQTRELGFBQWE7QUFDekUsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixvQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0I7OztBQzNHZ0U7QUFDUDtBQUNRO0FBQ0w7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWE7QUFDM0MsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7OztBQzVFNkQ7QUFDRzs7QUFFaEU7QUFDQSw2QkFBVSxLQUFLLG1CQUFtQjtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gtcGxhbmUvUGxhbmVHZW9tZXRyeS5tanM/NjZjOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtbmluZS1zbGljZS9OaW5lU2xpY2VHZW9tZXRyeS5tanM/ZjFhMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtbmluZS1zbGljZS9OaW5lU2xpY2VTcHJpdGVQaXBlLm1qcz84NjAxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL2luaXQubWpzP2UyZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IE1lc2hHZW9tZXRyeSB9IGZyb20gJy4uL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9QbGFuZUdlb21ldHJ5ID0gY2xhc3MgX1BsYW5lR2VvbWV0cnkgZXh0ZW5kcyBNZXNoR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJQbGFuZUdlb21ldHJ5IGNvbnN0cnVjdG9yIGNoYW5nZWQgcGxlYXNlIHVzZSB7IHdpZHRoLCBoZWlnaHQsIHZlcnRpY2VzWCwgdmVydGljZXNZIH0gaW5zdGVhZFwiKTtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBvcHRpb25zLFxuICAgICAgICBoZWlnaHQ6IGFyZ3NbMV0sXG4gICAgICAgIHZlcnRpY2VzWDogYXJnc1syXSxcbiAgICAgICAgdmVydGljZXNZOiBhcmdzWzNdXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmJ1aWxkKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgcGxhbmUgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gcGxhbmUgZ2VvbWV0cnlcbiAgICovXG4gIGJ1aWxkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fUGxhbmVHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMudmVydGljZXNYID0gdGhpcy52ZXJ0aWNlc1ggPz8gb3B0aW9ucy52ZXJ0aWNlc1g7XG4gICAgdGhpcy52ZXJ0aWNlc1kgPSB0aGlzLnZlcnRpY2VzWSA/PyBvcHRpb25zLnZlcnRpY2VzWTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCA/PyBvcHRpb25zLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgPz8gb3B0aW9ucy5oZWlnaHQ7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLnZlcnRpY2VzWCAqIHRoaXMudmVydGljZXNZO1xuICAgIGNvbnN0IHZlcnRzID0gW107XG4gICAgY29uc3QgdXZzID0gW107XG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHZlcnRpY2VzWCA9IHRoaXMudmVydGljZXNYIC0gMTtcbiAgICBjb25zdCB2ZXJ0aWNlc1kgPSB0aGlzLnZlcnRpY2VzWSAtIDE7XG4gICAgY29uc3Qgc2l6ZVggPSB0aGlzLndpZHRoIC8gdmVydGljZXNYO1xuICAgIGNvbnN0IHNpemVZID0gdGhpcy5oZWlnaHQgLyB2ZXJ0aWNlc1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIHRoaXMudmVydGljZXNYO1xuICAgICAgY29uc3QgeSA9IGkgLyB0aGlzLnZlcnRpY2VzWCB8IDA7XG4gICAgICB2ZXJ0cy5wdXNoKHggKiBzaXplWCwgeSAqIHNpemVZKTtcbiAgICAgIHV2cy5wdXNoKHggLyB2ZXJ0aWNlc1gsIHkgLyB2ZXJ0aWNlc1kpO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbFN1YiA9IHZlcnRpY2VzWCAqIHZlcnRpY2VzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsU3ViOyBpKyspIHtcbiAgICAgIGNvbnN0IHhwb3MgPSBpICUgdmVydGljZXNYO1xuICAgICAgY29uc3QgeXBvcyA9IGkgLyB2ZXJ0aWNlc1ggfCAwO1xuICAgICAgY29uc3QgdmFsdWUgPSB5cG9zICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWUyID0geXBvcyAqIHRoaXMudmVydGljZXNYICsgeHBvcyArIDE7XG4gICAgICBjb25zdCB2YWx1ZTMgPSAoeXBvcyArIDEpICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWU0ID0gKHlwb3MgKyAxKSAqIHRoaXMudmVydGljZXNYICsgeHBvcyArIDE7XG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZTIsXG4gICAgICAgIHZhbHVlMyxcbiAgICAgICAgdmFsdWUyLFxuICAgICAgICB2YWx1ZTQsXG4gICAgICAgIHZhbHVlM1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMV0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodXZzKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoaW5kaWNlcyk7XG4gICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xuICB9XG59O1xuX1BsYW5lR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHdpZHRoOiAxMDAsXG4gIGhlaWdodDogMTAwLFxuICB2ZXJ0aWNlc1g6IDEwLFxuICB2ZXJ0aWNlc1k6IDEwXG59O1xubGV0IFBsYW5lR2VvbWV0cnkgPSBfUGxhbmVHZW9tZXRyeTtcblxuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGxhbmVHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQbGFuZUdlb21ldHJ5IH0gZnJvbSAnLi4vbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX05pbmVTbGljZUdlb21ldHJ5ID0gY2xhc3MgX05pbmVTbGljZUdlb21ldHJ5IGV4dGVuZHMgUGxhbmVHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9OaW5lU2xpY2VHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHN1cGVyKHtcbiAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcbiAgICAgIHZlcnRpY2VzWDogNCxcbiAgICAgIHZlcnRpY2VzWTogNFxuICAgIH0pO1xuICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIE5pbmVTbGljZUdlb21ldHJ5IHdpdGggdGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgdGhlIE5pbmVTbGljZUdlb21ldHJ5LlxuICAgKi9cbiAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCA/PyB0aGlzLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPz8gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IG9wdGlvbnMub3JpZ2luYWxXaWR0aCA/PyB0aGlzLl9vcmlnaW5hbFdpZHRoO1xuICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gb3B0aW9ucy5vcmlnaW5hbEhlaWdodCA/PyB0aGlzLl9vcmlnaW5hbEhlaWdodDtcbiAgICB0aGlzLl9sZWZ0V2lkdGggPSBvcHRpb25zLmxlZnRXaWR0aCA/PyB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IG9wdGlvbnMucmlnaHRXaWR0aCA/PyB0aGlzLl9yaWdodFdpZHRoO1xuICAgIHRoaXMuX3RvcEhlaWdodCA9IG9wdGlvbnMudG9wSGVpZ2h0ID8/IHRoaXMuX3RvcEhlaWdodDtcbiAgICB0aGlzLl9ib3R0b21IZWlnaHQgPSBvcHRpb25zLmJvdHRvbUhlaWdodCA/PyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZU1hdHJpeCkge1xuICAgICAgdGhpcy5fdGV4dHVyZU1hdHJpeC5jb3B5RnJvbShvcHRpb25zLnRleHR1cmVNYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgdmVydGljZXMuICovXG4gIHVwZGF0ZVBvc2l0aW9ucygpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9ucztcbiAgICBjb25zdCB3ID0gdGhpcy5fbGVmdFdpZHRoICsgdGhpcy5fcmlnaHRXaWR0aDtcbiAgICBjb25zdCBzY2FsZVcgPSB0aGlzLndpZHRoID4gdyA/IDEgOiB0aGlzLndpZHRoIC8gdztcbiAgICBjb25zdCBoID0gdGhpcy5fdG9wSGVpZ2h0ICsgdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlSCA9IHRoaXMuaGVpZ2h0ID4gaCA/IDEgOiB0aGlzLmhlaWdodCAvIGg7XG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbihzY2FsZVcsIHNjYWxlSCk7XG4gICAgcG9zaXRpb25zWzldID0gcG9zaXRpb25zWzExXSA9IHBvc2l0aW9uc1sxM10gPSBwb3NpdGlvbnNbMTVdID0gdGhpcy5fdG9wSGVpZ2h0ICogc2NhbGU7XG4gICAgcG9zaXRpb25zWzE3XSA9IHBvc2l0aW9uc1sxOV0gPSBwb3NpdGlvbnNbMjFdID0gcG9zaXRpb25zWzIzXSA9IHRoaXMuaGVpZ2h0IC0gdGhpcy5fYm90dG9tSGVpZ2h0ICogc2NhbGU7XG4gICAgcG9zaXRpb25zWzI1XSA9IHBvc2l0aW9uc1syN10gPSBwb3NpdGlvbnNbMjldID0gcG9zaXRpb25zWzMxXSA9IHRoaXMuaGVpZ2h0O1xuICAgIHBvc2l0aW9uc1syXSA9IHBvc2l0aW9uc1sxMF0gPSBwb3NpdGlvbnNbMThdID0gcG9zaXRpb25zWzI2XSA9IHRoaXMuX2xlZnRXaWR0aCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1s0XSA9IHBvc2l0aW9uc1sxMl0gPSBwb3NpdGlvbnNbMjBdID0gcG9zaXRpb25zWzI4XSA9IHRoaXMud2lkdGggLSB0aGlzLl9yaWdodFdpZHRoICogc2NhbGU7XG4gICAgcG9zaXRpb25zWzZdID0gcG9zaXRpb25zWzE0XSA9IHBvc2l0aW9uc1syMl0gPSBwb3NpdGlvbnNbMzBdID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLmdldEJ1ZmZlcihcImFQb3NpdGlvblwiKS51cGRhdGUoKTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgVVZzIG9mIHRoZSB2ZXJ0aWNlcy4gKi9cbiAgdXBkYXRlVXZzKCkge1xuICAgIGNvbnN0IHRleHR1cmVNYXRyaXggPSB0aGlzLl90ZXh0dXJlTWF0cml4O1xuICAgIGNvbnN0IHV2cyA9IHRoaXMudXZzO1xuICAgIHV2c1swXSA9IHV2c1s4XSA9IHV2c1sxNl0gPSB1dnNbMjRdID0gMDtcbiAgICB1dnNbMV0gPSB1dnNbM10gPSB1dnNbNV0gPSB1dnNbN10gPSAwO1xuICAgIHV2c1s2XSA9IHV2c1sxNF0gPSB1dnNbMjJdID0gdXZzWzMwXSA9IDE7XG4gICAgdXZzWzI1XSA9IHV2c1syN10gPSB1dnNbMjldID0gdXZzWzMxXSA9IDE7XG4gICAgY29uc3QgX3V2dyA9IDEgLyB0aGlzLl9vcmlnaW5hbFdpZHRoO1xuICAgIGNvbnN0IF91dmggPSAxIC8gdGhpcy5fb3JpZ2luYWxIZWlnaHQ7XG4gICAgdXZzWzJdID0gdXZzWzEwXSA9IHV2c1sxOF0gPSB1dnNbMjZdID0gX3V2dyAqIHRoaXMuX2xlZnRXaWR0aDtcbiAgICB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0O1xuICAgIHV2c1s0XSA9IHV2c1sxMl0gPSB1dnNbMjBdID0gdXZzWzI4XSA9IDEgLSBfdXZ3ICogdGhpcy5fcmlnaHRXaWR0aDtcbiAgICB1dnNbMTddID0gdXZzWzE5XSA9IHV2c1syMV0gPSB1dnNbMjNdID0gMSAtIF91dmggKiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgbXVsdGlwbHlVdnModGV4dHVyZU1hdHJpeCwgdXZzKTtcbiAgICB0aGlzLmdldEJ1ZmZlcihcImFVVlwiKS51cGRhdGUoKTtcbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgTmluZVNsaWNlR2VvbWV0cnkuICovXG5fTmluZVNsaWNlR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmUuICovXG4gIHdpZHRoOiAxMDAsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBOaW5lU2xpY2VQbGFuZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSB2ZXJ0aWNlcyBhbmQgVVYncyBvZiB0aGlzIHBsYW5lLiAqL1xuICBoZWlnaHQ6IDEwMCxcbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgbGVmdCBjb2x1bW4uICovXG4gIGxlZnRXaWR0aDogMTAsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSB0b3Agcm93LiAqL1xuICB0b3BIZWlnaHQ6IDEwLFxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSByaWdodCBjb2x1bW4uICovXG4gIHJpZ2h0V2lkdGg6IDEwLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgYm90dG9tIHJvdy4gKi9cbiAgYm90dG9tSGVpZ2h0OiAxMCxcbiAgLyoqIFRoZSBvcmlnaW5hbCB3aWR0aCBvZiB0aGUgdGV4dHVyZSAqL1xuICBvcmlnaW5hbFdpZHRoOiAxMDAsXG4gIC8qKiBUaGUgb3JpZ2luYWwgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlICovXG4gIG9yaWdpbmFsSGVpZ2h0OiAxMDBcbn07XG5sZXQgTmluZVNsaWNlR2VvbWV0cnkgPSBfTmluZVNsaWNlR2VvbWV0cnk7XG5mdW5jdGlvbiBtdWx0aXBseVV2cyhtYXRyaXgsIHV2cywgb3V0KSB7XG4gIG91dCA/PyAob3V0ID0gdXZzKTtcbiAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICBjb25zdCBiID0gbWF0cml4LmI7XG4gIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgeCA9IHV2c1tpXTtcbiAgICBjb25zdCB5ID0gdXZzW2kgKyAxXTtcbiAgICBvdXRbaV0gPSB4ICogYSArIHkgKiBjICsgdHg7XG4gICAgb3V0W2kgKyAxXSA9IHggKiBiICsgeSAqIGQgKyB0eTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgeyBOaW5lU2xpY2VHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmluZVNsaWNlR2VvbWV0cnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVNZXNoIH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanMnO1xuaW1wb3J0IHsgTmluZVNsaWNlR2VvbWV0cnkgfSBmcm9tICcuL05pbmVTbGljZUdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgTmluZVNsaWNlU3ByaXRlUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1U3ByaXRlSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShzcHJpdGUsIF9pbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dldEdwdVNwcml0ZShzcHJpdGUpO1xuICAgIGlmIChzcHJpdGUuX2RpZFNwcml0ZVVwZGF0ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoYWJsZVNwcml0ZShzcHJpdGUsIGdwdVNwcml0ZSk7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChncHVTcHJpdGUpO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoc3ByaXRlKSB7XG4gICAgY29uc3QgZ3B1U3ByaXRlID0gdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXTtcbiAgICBpZiAoc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIGdwdVNwcml0ZS5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoZ3B1U3ByaXRlKTtcbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUoc3ByaXRlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoZ3B1U3ByaXRlLnRleHR1cmUuX3NvdXJjZSAhPT0gdGV4dHVyZS5fc291cmNlKSB7XG4gICAgICByZXR1cm4gIWdwdVNwcml0ZS5iYXRjaGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZShncHVTcHJpdGUsIHRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUoc3ByaXRlKSB7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXTtcbiAgICBCaWdQb29sLnJldHVybihiYXRjaGFibGVTcHJpdGUpO1xuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF0gPSBudWxsO1xuICB9XG4gIF91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBiYXRjaGFibGVTcHJpdGUpIHtcbiAgICBzcHJpdGUuX2RpZFNwcml0ZVVwZGF0ZSA9IGZhbHNlO1xuICAgIGJhdGNoYWJsZVNwcml0ZS5nZW9tZXRyeS51cGRhdGUoc3ByaXRlKTtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgfVxuICBfZ2V0R3B1U3ByaXRlKHNwcml0ZSkge1xuICAgIHJldHVybiB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdIHx8IHRoaXMuX2luaXRHUFVTcHJpdGUoc3ByaXRlKTtcbiAgfVxuICBfaW5pdEdQVVNwcml0ZShzcHJpdGUpIHtcbiAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gbmV3IEJhdGNoYWJsZU1lc2goKTtcbiAgICBiYXRjaGFibGVNZXNoLmdlb21ldHJ5ID0gbmV3IE5pbmVTbGljZUdlb21ldHJ5KCk7XG4gICAgYmF0Y2hhYmxlTWVzaC5tZXNoID0gc3ByaXRlO1xuICAgIGJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICBiYXRjaGFibGVNZXNoLnJvdW5kUGl4ZWxzID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgc3ByaXRlLl9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdID0gYmF0Y2hhYmxlTWVzaDtcbiAgICBzcHJpdGUub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShzcHJpdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXRjaGFibGVNZXNoO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdVNwcml0ZUhhc2gpIHtcbiAgICAgIGNvbnN0IGJhdGNoYWJsZU1lc2ggPSB0aGlzLl9ncHVTcHJpdGVIYXNoW2ldO1xuICAgICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2ggPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbk5pbmVTbGljZVNwcml0ZVBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcIm5pbmVTbGljZVNwcml0ZVwiXG59O1xuXG5leHBvcnQgeyBOaW5lU2xpY2VTcHJpdGVQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OaW5lU2xpY2VTcHJpdGVQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IE5pbmVTbGljZVNwcml0ZVBpcGUgfSBmcm9tICcuL05pbmVTbGljZVNwcml0ZVBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChOaW5lU2xpY2VTcHJpdGVQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2092\n')},1015:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(8070);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs\n\nconst tilingBit = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=tilingBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader/* Shader */.e {\n  constructor() {\n    gpuProgram ?? (gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBit */.XH,\n        tilingBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    }));\n    glProgram ?? (glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBitGl */.$g,\n        tilingBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    }));\n    const tilingUniforms = new UniformGroup/* UniformGroup */.o({\n      uMapCoord: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },\n      uTextureTransform: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup/* UniformGroup */.o({\n          uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n          uRound: { value: 0, type: "f32" }\n        }),\n        tilingUniforms,\n        uTexture: Texture/* Texture */.x.EMPTY.source,\n        uSampler: Texture/* Texture */.x.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\n\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs\n\n\n"use strict";\nclass QuadGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\n\n//# sourceMappingURL=QuadGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs\n\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n\n//# sourceMappingURL=setPositions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs\n\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=applyMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs\n\n\n\n"use strict";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix/* Matrix */.y.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\n\n//# sourceMappingURL=setUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh/* BatchableMesh */.X());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: State/* State */.Z.default2d\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry/* MeshGeometry */.x({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on("destroyed", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== "repeat") {\n      style.addressMode = "repeat";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === types/* RendererType */.g.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "tilingSprite"\n};\n\n\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7O0FDOUo2RDtBQUNIOztBQUUxRDtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvdGlsaW5nQml0Lm1qcz84Y2E3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL1RpbGluZ1Nwcml0ZVNoYWRlci5tanM/YzBkMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanM/M2EyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFBvc2l0aW9ucy5tanM/OTYyMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL2FwcGx5TWF0cml4Lm1qcz8yZWNlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvc2V0VXZzLm1qcz82MmU2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvVGlsaW5nU3ByaXRlUGlwZS5tanM/ZjIzOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL2luaXQubWpzPzE2NmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0aWxpbmdCaXQgPSB7XG4gIG5hbWU6IFwidGlsaW5nLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBUaWxpbmdVbmlmb3JtcyB7XG4gICAgICAgICAgICAgICAgdU1hcENvb3JkOm1hdDN4MzxmMzI+LFxuICAgICAgICAgICAgICAgIHVDbGFtcEZyYW1lOnZlYzQ8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBPZmZzZXQ6dmVjMjxmMzI+LFxuICAgICAgICAgICAgICAgIHVUZXh0dXJlVHJhbnNmb3JtOm1hdDN4MzxmMzI+LFxuICAgICAgICAgICAgICAgIHVTaXplQW5jaG9yOnZlYzQ8ZjMyPlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiB0aWxpbmdVbmlmb3JtczogVGlsaW5nVW5pZm9ybXM7XG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICB2VVYgPSAodGlsaW5nVW5pZm9ybXMudVRleHR1cmVUcmFuc2Zvcm0gKiB2ZWMzKGFVViwgMS4wKSkueHk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uIC0gdGlsaW5nVW5pZm9ybXMudVNpemVBbmNob3IuencpICogdGlsaW5nVW5pZm9ybXMudVNpemVBbmNob3IueHk7XG4gICAgICAgIGBcbiAgICApXG4gIH0sXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBzdHJ1Y3QgVGlsaW5nVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVNYXBDb29yZDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBGcmFtZTp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wT2Zmc2V0OnZlYzI8ZjMyPixcbiAgICAgICAgICAgICAgICB1VGV4dHVyZVRyYW5zZm9ybTptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1U2l6ZUFuY2hvcjp2ZWM0PGYzMj5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdGlsaW5nVW5pZm9ybXM6IFRpbGluZ1VuaWZvcm1zO1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuXG4gICAgICAgICAgICB2YXIgY29vcmQgPSB2VVYgKyBjZWlsKHRpbGluZ1VuaWZvcm1zLnVDbGFtcE9mZnNldCAtIHZVVik7XG4gICAgICAgICAgICBjb29yZCA9ICh0aWxpbmdVbmlmb3Jtcy51TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcbiAgICAgICAgICAgIHZhciB1bmNsYW1wZWQgPSBjb29yZDtcbiAgICAgICAgICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHRpbGluZ1VuaWZvcm1zLnVDbGFtcEZyYW1lLnh5LCB0aWxpbmdVbmlmb3Jtcy51Q2xhbXBGcmFtZS56dyk7XG5cbiAgICAgICAgICAgIHZhciBiaWFzID0gMC47XG5cbiAgICAgICAgICAgIGlmKHVuY2xhbXBlZC54ID09IGNvb3JkLnggJiYgdW5jbGFtcGVkLnkgPT0gY29vcmQueSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaWFzID0gLTMyLjtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZVNhbXBsZUJpYXModVRleHR1cmUsIHVTYW1wbGVyLCBjb29yZCwgYmlhcyk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCB0aWxpbmdCaXRHbCA9IHtcbiAgbmFtZTogXCJ0aWxpbmctYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVUZXh0dXJlVHJhbnNmb3JtO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVTaXplQW5jaG9yO1xuICAgICAgICBcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdlVWID0gKHVUZXh0dXJlVHJhbnNmb3JtICogdmVjMyhhVVYsIDEuMCkpLnh5O1xuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IChwb3NpdGlvbiAtIHVTaXplQW5jaG9yLnp3KSAqIHVTaXplQW5jaG9yLnh5O1xuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDbGFtcEZyYW1lO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVDbGFtcE9mZnNldDtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuXG4gICAgICAgIHZlYzIgY29vcmQgPSB2VVYgKyBjZWlsKHVDbGFtcE9mZnNldCAtIHZVVik7XG4gICAgICAgIGNvb3JkID0gKHVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xuICAgICAgICB2ZWMyIHVuY2xhbXBlZCA9IGNvb3JkO1xuICAgICAgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1Q2xhbXBGcmFtZS54eSwgdUNsYW1wRnJhbWUuencpO1xuICAgICAgICBcbiAgICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlLCBjb29yZCwgdW5jbGFtcGVkID09IGNvb3JkID8gMC4wIDogLTMyLjApOy8vIGxvZC1iaWFzIHZlcnkgbmVnYXRpdmUgdG8gZm9yY2UgbG9kIDBcbiAgICBcbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgdGlsaW5nQml0LCB0aWxpbmdCaXRHbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsaW5nQml0Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGxvY2FsVW5pZm9ybUJpdCwgbG9jYWxVbmlmb3JtQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdCwgcm91bmRQaXhlbHNCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgdGlsaW5nQml0LCB0aWxpbmdCaXRHbCB9IGZyb20gJy4vdGlsaW5nQml0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IGdwdVByb2dyYW07XG5sZXQgZ2xQcm9ncmFtO1xuY2xhc3MgVGlsaW5nU3ByaXRlU2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgZ3B1UHJvZ3JhbSA/PyAoZ3B1UHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcInRpbGluZy1zcHJpdGUtc2hhZGVyXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGxvY2FsVW5pZm9ybUJpdCxcbiAgICAgICAgdGlsaW5nQml0LFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pKTtcbiAgICBnbFByb2dyYW0gPz8gKGdsUHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwidGlsaW5nLXNwcml0ZS1zaGFkZXJcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgbG9jYWxVbmlmb3JtQml0R2wsXG4gICAgICAgIHRpbGluZ0JpdEdsLFxuICAgICAgICByb3VuZFBpeGVsc0JpdEdsXG4gICAgICBdXG4gICAgfSkpO1xuICAgIGNvbnN0IHRpbGluZ1VuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1TWFwQ29vcmQ6IHsgdmFsdWU6IG5ldyBNYXRyaXgoKSwgdHlwZTogXCJtYXQzeDM8ZjMyPlwiIH0sXG4gICAgICB1Q2xhbXBGcmFtZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1Q2xhbXBPZmZzZXQ6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9LFxuICAgICAgdVRleHR1cmVUcmFuc2Zvcm06IHsgdmFsdWU6IG5ldyBNYXRyaXgoKSwgdHlwZTogXCJtYXQzeDM8ZjMyPlwiIH0sXG4gICAgICB1U2l6ZUFuY2hvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMTAwLCAxMDAsIDAuNSwgMC41XSksIHR5cGU6IFwidmVjNDxmMzI+XCIgfVxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgbG9jYWxVbmlmb3JtczogbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgICAgIHVSb3VuZDogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9XG4gICAgICAgIH0pLFxuICAgICAgICB0aWxpbmdVbmlmb3JtcyxcbiAgICAgICAgdVRleHR1cmU6IFRleHR1cmUuRU1QVFkuc291cmNlLFxuICAgICAgICB1U2FtcGxlcjogVGV4dHVyZS5FTVBUWS5zb3VyY2Uuc3R5bGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVVbmlmb3Jtcyh3aWR0aCwgaGVpZ2h0LCBtYXRyaXgsIGFuY2hvclgsIGFuY2hvclksIHRleHR1cmUpIHtcbiAgICBjb25zdCB0aWxpbmdVbmlmb3JtcyA9IHRoaXMucmVzb3VyY2VzLnRpbGluZ1VuaWZvcm1zO1xuICAgIGNvbnN0IHRleHR1cmVXaWR0aCA9IHRleHR1cmUud2lkdGg7XG4gICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IHRleHR1cmUuaGVpZ2h0O1xuICAgIGNvbnN0IHRleHR1cmVNYXRyaXggPSB0ZXh0dXJlLnRleHR1cmVNYXRyaXg7XG4gICAgY29uc3QgdVRleHR1cmVUcmFuc2Zvcm0gPSB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51VGV4dHVyZVRyYW5zZm9ybTtcbiAgICB1VGV4dHVyZVRyYW5zZm9ybS5zZXQoXG4gICAgICBtYXRyaXguYSAqIHRleHR1cmVXaWR0aCAvIHdpZHRoLFxuICAgICAgbWF0cml4LmIgKiB0ZXh0dXJlV2lkdGggLyBoZWlnaHQsXG4gICAgICBtYXRyaXguYyAqIHRleHR1cmVIZWlnaHQgLyB3aWR0aCxcbiAgICAgIG1hdHJpeC5kICogdGV4dHVyZUhlaWdodCAvIGhlaWdodCxcbiAgICAgIG1hdHJpeC50eCAvIHdpZHRoLFxuICAgICAgbWF0cml4LnR5IC8gaGVpZ2h0XG4gICAgKTtcbiAgICB1VGV4dHVyZVRyYW5zZm9ybS5pbnZlcnQoKTtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51TWFwQ29vcmQgPSB0ZXh0dXJlTWF0cml4Lm1hcENvb3JkO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVDbGFtcEZyYW1lID0gdGV4dHVyZU1hdHJpeC51Q2xhbXBGcmFtZTtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51Q2xhbXBPZmZzZXQgPSB0ZXh0dXJlTWF0cml4LnVDbGFtcE9mZnNldDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51VGV4dHVyZVRyYW5zZm9ybSA9IHVUZXh0dXJlVHJhbnNmb3JtO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVTaXplQW5jaG9yWzBdID0gd2lkdGg7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbMV0gPSBoZWlnaHQ7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbMl0gPSBhbmNob3JYO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVTaXplQW5jaG9yWzNdID0gYW5jaG9yWTtcbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdGhpcy5yZXNvdXJjZXMudVRleHR1cmUgPSB0ZXh0dXJlLnNvdXJjZTtcbiAgICAgIHRoaXMucmVzb3VyY2VzLnVTYW1wbGVyID0gdGV4dHVyZS5zb3VyY2Uuc3R5bGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFRpbGluZ1Nwcml0ZVNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlU2hhZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IE1lc2hHZW9tZXRyeSB9IGZyb20gJy4uLy4uL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFF1YWRHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLFxuICAgICAgdXZzOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXG4gICAgICBpbmRpY2VzOiBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFF1YWRHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVhZEdlb21ldHJ5Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc2V0UG9zaXRpb25zKHRpbGluZ1Nwcml0ZSwgcG9zaXRpb25zKSB7XG4gIGNvbnN0IGFuY2hvclggPSB0aWxpbmdTcHJpdGUuYW5jaG9yLng7XG4gIGNvbnN0IGFuY2hvclkgPSB0aWxpbmdTcHJpdGUuYW5jaG9yLnk7XG4gIHBvc2l0aW9uc1swXSA9IC1hbmNob3JYICogdGlsaW5nU3ByaXRlLndpZHRoO1xuICBwb3NpdGlvbnNbMV0gPSAtYW5jaG9yWSAqIHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG4gIHBvc2l0aW9uc1syXSA9ICgxIC0gYW5jaG9yWCkgKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1szXSA9IC1hbmNob3JZICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzRdID0gKDEgLSBhbmNob3JYKSAqIHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgcG9zaXRpb25zWzVdID0gKDEgLSBhbmNob3JZKSAqIHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG4gIHBvc2l0aW9uc1s2XSA9IC1hbmNob3JYICogdGlsaW5nU3ByaXRlLndpZHRoO1xuICBwb3NpdGlvbnNbN10gPSAoMSAtIGFuY2hvclkpICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbn1cblxuZXhwb3J0IHsgc2V0UG9zaXRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRQb3NpdGlvbnMubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcHBseU1hdHJpeChhcnJheSwgc3RyaWRlLCBvZmZzZXQsIG1hdHJpeCkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBzaXplID0gYXJyYXkubGVuZ3RoIC8gKHN0cmlkZSB8fCAyKTtcbiAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICBjb25zdCBiID0gbWF0cml4LmI7XG4gIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gIG9mZnNldCAqPSBzdHJpZGU7XG4gIHdoaWxlIChpbmRleCA8IHNpemUpIHtcbiAgICBjb25zdCB4ID0gYXJyYXlbb2Zmc2V0XTtcbiAgICBjb25zdCB5ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG4gICAgYXJyYXlbb2Zmc2V0XSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICBhcnJheVtvZmZzZXQgKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGluZGV4Kys7XG4gIH1cbn1cblxuZXhwb3J0IHsgYXBwbHlNYXRyaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5TWF0cml4Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IGFwcGx5TWF0cml4IH0gZnJvbSAnLi9hcHBseU1hdHJpeC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHNldFV2cyh0aWxpbmdTcHJpdGUsIHV2cykge1xuICBjb25zdCB0ZXh0dXJlID0gdGlsaW5nU3ByaXRlLnRleHR1cmU7XG4gIGNvbnN0IHdpZHRoID0gdGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gIGxldCBhbmNob3JYID0gMDtcbiAgbGV0IGFuY2hvclkgPSAwO1xuICBpZiAodGlsaW5nU3ByaXRlLl9hcHBseUFuY2hvclRvVGV4dHVyZSkge1xuICAgIGFuY2hvclggPSB0aWxpbmdTcHJpdGUuYW5jaG9yLng7XG4gICAgYW5jaG9yWSA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueTtcbiAgfVxuICB1dnNbMF0gPSB1dnNbNl0gPSAtYW5jaG9yWDtcbiAgdXZzWzJdID0gdXZzWzRdID0gMSAtIGFuY2hvclg7XG4gIHV2c1sxXSA9IHV2c1szXSA9IC1hbmNob3JZO1xuICB1dnNbNV0gPSB1dnNbN10gPSAxIC0gYW5jaG9yWTtcbiAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IE1hdHJpeC5zaGFyZWQ7XG4gIHRleHR1cmVNYXRyaXguY29weUZyb20odGlsaW5nU3ByaXRlLl90aWxlVHJhbnNmb3JtLm1hdHJpeCk7XG4gIHRleHR1cmVNYXRyaXgudHggLz0gdGlsaW5nU3ByaXRlLndpZHRoO1xuICB0ZXh0dXJlTWF0cml4LnR5IC89IHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG4gIHRleHR1cmVNYXRyaXguaW52ZXJ0KCk7XG4gIHRleHR1cmVNYXRyaXguc2NhbGUodGlsaW5nU3ByaXRlLndpZHRoIC8gd2lkdGgsIHRpbGluZ1Nwcml0ZS5oZWlnaHQgLyBoZWlnaHQpO1xuICBhcHBseU1hdHJpeCh1dnMsIDIsIDAsIHRleHR1cmVNYXRyaXgpO1xufVxuXG5leHBvcnQgeyBzZXRVdnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldFV2cy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBjb2xvcjMyQml0VG9Vbmlmb3JtIH0gZnJvbSAnLi4vZ3JhcGhpY3MvZ3B1L2NvbG9yVG9Vbmlmb3JtLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVNZXNoIH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanMnO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBUaWxpbmdTcHJpdGVTaGFkZXIgfSBmcm9tICcuL3NoYWRlci9UaWxpbmdTcHJpdGVTaGFkZXIubWpzJztcbmltcG9ydCB7IFF1YWRHZW9tZXRyeSB9IGZyb20gJy4vdXRpbHMvUXVhZEdlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBzZXRQb3NpdGlvbnMgfSBmcm9tICcuL3V0aWxzL3NldFBvc2l0aW9ucy5tanMnO1xuaW1wb3J0IHsgc2V0VXZzIH0gZnJvbSAnLi91dGlscy9zZXRVdnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzaGFyZWRRdWFkID0gbmV3IFF1YWRHZW9tZXRyeSgpO1xuY2xhc3MgVGlsaW5nU3ByaXRlUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShyZW5kZXJhYmxlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEocmVuZGVyYWJsZSk7XG4gICAgY29uc3QgY291bGRCYXRjaCA9IHRpbGluZ1Nwcml0ZURhdGEuY2FuQmF0Y2g7XG4gICAgdGhpcy5fdXBkYXRlQ2FuQmF0Y2gocmVuZGVyYWJsZSk7XG4gICAgY29uc3QgY2FuQmF0Y2ggPSB0aWxpbmdTcHJpdGVEYXRhLmNhbkJhdGNoO1xuICAgIGlmIChjYW5CYXRjaCAmJiBjYW5CYXRjaCA9PT0gY291bGRCYXRjaCkge1xuICAgICAgY29uc3QgeyBiYXRjaGFibGVNZXNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSByZW5kZXJhYmxlLnRleHR1cmUuX3NvdXJjZSkge1xuICAgICAgICByZXR1cm4gIWJhdGNoYWJsZU1lc2guYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoYmF0Y2hhYmxlTWVzaCwgcmVuZGVyYWJsZS50ZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdWxkQmF0Y2ggIT09IGNhbkJhdGNoO1xuICB9XG4gIGFkZFJlbmRlcmFibGUodGlsaW5nU3ByaXRlLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGJhdGNoZXIgPSB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaDtcbiAgICB0aGlzLl91cGRhdGVDYW5CYXRjaCh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHRpbGluZ1Nwcml0ZURhdGEgPSB0aGlzLl9nZXRUaWxpbmdTcHJpdGVEYXRhKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgeyBnZW9tZXRyeSwgY2FuQmF0Y2ggfSA9IHRpbGluZ1Nwcml0ZURhdGE7XG4gICAgaWYgKGNhbkJhdGNoKSB7XG4gICAgICB0aWxpbmdTcHJpdGVEYXRhLmJhdGNoYWJsZU1lc2ggfHwgKHRpbGluZ1Nwcml0ZURhdGEuYmF0Y2hhYmxlTWVzaCA9IG5ldyBCYXRjaGFibGVNZXNoKCkpO1xuICAgICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IHRpbGluZ1Nwcml0ZURhdGEuYmF0Y2hhYmxlTWVzaDtcbiAgICAgIGlmICh0aWxpbmdTcHJpdGUuX2RpZFRpbGluZ1Nwcml0ZVVwZGF0ZSkge1xuICAgICAgICB0aWxpbmdTcHJpdGUuX2RpZFRpbGluZ1Nwcml0ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVNZXNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgICAgIGJhdGNoYWJsZU1lc2guZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgYmF0Y2hhYmxlTWVzaC5tZXNoID0gdGlsaW5nU3ByaXRlO1xuICAgICAgICBiYXRjaGFibGVNZXNoLnRleHR1cmUgPSB0aWxpbmdTcHJpdGUuX3RleHR1cmU7XG4gICAgICB9XG4gICAgICBiYXRjaGFibGVNZXNoLnJvdW5kUGl4ZWxzID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgdGlsaW5nU3ByaXRlLl9yb3VuZFBpeGVscztcbiAgICAgIGJhdGNoZXIuYWRkVG9CYXRjaChiYXRjaGFibGVNZXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmF0Y2hlci5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgICB0aWxpbmdTcHJpdGVEYXRhLnNoYWRlciB8fCAodGlsaW5nU3ByaXRlRGF0YS5zaGFkZXIgPSBuZXcgVGlsaW5nU3ByaXRlU2hhZGVyKCkpO1xuICAgICAgdGhpcy51cGRhdGVSZW5kZXJhYmxlKHRpbGluZ1Nwcml0ZSk7XG4gICAgICBpbnN0cnVjdGlvblNldC5hZGQodGlsaW5nU3ByaXRlKTtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZSh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCB7IHNoYWRlciB9ID0gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF07XG4gICAgc2hhZGVyLmdyb3Vwc1swXSA9IHRoaXMuX3JlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLmJpbmRHcm91cDtcbiAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0gc2hhZGVyLnJlc291cmNlcy5sb2NhbFVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIGxvY2FsVW5pZm9ybXMudVRyYW5zZm9ybU1hdHJpeCA9IHRpbGluZ1Nwcml0ZS5ncm91cFRyYW5zZm9ybTtcbiAgICBsb2NhbFVuaWZvcm1zLnVSb3VuZCA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHRpbGluZ1Nwcml0ZS5fcm91bmRQaXhlbHM7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIHRpbGluZ1Nwcml0ZS5ncm91cENvbG9yQWxwaGEsXG4gICAgICBsb2NhbFVuaWZvcm1zLnVDb2xvcixcbiAgICAgIDBcbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogc2hhcmVkUXVhZCxcbiAgICAgIHNoYWRlcixcbiAgICAgIHN0YXRlOiBTdGF0ZS5kZWZhdWx0MmRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHRpbGluZ1Nwcml0ZURhdGEgPSB0aGlzLl9nZXRUaWxpbmdTcHJpdGVEYXRhKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgeyBjYW5CYXRjaCB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICBpZiAoY2FuQmF0Y2gpIHtcbiAgICAgIGNvbnN0IHsgYmF0Y2hhYmxlTWVzaCB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICAgIGlmICh0aWxpbmdTcHJpdGUuX2RpZFRpbGluZ1Nwcml0ZVVwZGF0ZSlcbiAgICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlTWVzaCh0aWxpbmdTcHJpdGUpO1xuICAgICAgYmF0Y2hhYmxlTWVzaC5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoYmF0Y2hhYmxlTWVzaCk7XG4gICAgfSBlbHNlIGlmICh0aWxpbmdTcHJpdGUuX2RpZFRpbGluZ1Nwcml0ZVVwZGF0ZSkge1xuICAgICAgY29uc3QgeyBzaGFkZXIgfSA9IHRpbGluZ1Nwcml0ZURhdGE7XG4gICAgICBzaGFkZXIudXBkYXRlVW5pZm9ybXMoXG4gICAgICAgIHRpbGluZ1Nwcml0ZS53aWR0aCxcbiAgICAgICAgdGlsaW5nU3ByaXRlLmhlaWdodCxcbiAgICAgICAgdGlsaW5nU3ByaXRlLl90aWxlVHJhbnNmb3JtLm1hdHJpeCxcbiAgICAgICAgdGlsaW5nU3ByaXRlLmFuY2hvci54LFxuICAgICAgICB0aWxpbmdTcHJpdGUuYW5jaG9yLnksXG4gICAgICAgIHRpbGluZ1Nwcml0ZS50ZXh0dXJlXG4gICAgICApO1xuICAgIH1cbiAgICB0aWxpbmdTcHJpdGUuX2RpZFRpbGluZ1Nwcml0ZVVwZGF0ZSA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHRpbGluZ1Nwcml0ZURhdGEgPSB0aGlzLl9nZXRUaWxpbmdTcHJpdGVEYXRhKHRpbGluZ1Nwcml0ZSk7XG4gICAgdGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoID0gbnVsbDtcbiAgICB0aWxpbmdTcHJpdGVEYXRhLnNoYWRlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoW3RpbGluZ1Nwcml0ZS51aWRdID0gbnVsbDtcbiAgfVxuICBfZ2V0VGlsaW5nU3ByaXRlRGF0YShyZW5kZXJhYmxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoW3JlbmRlcmFibGUudWlkXSB8fCB0aGlzLl9pbml0VGlsaW5nU3ByaXRlRGF0YShyZW5kZXJhYmxlKTtcbiAgfVxuICBfaW5pdFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgTWVzaEdlb21ldHJ5KHtcbiAgICAgIGluZGljZXM6IHNoYXJlZFF1YWQuaW5kaWNlcyxcbiAgICAgIHBvc2l0aW9uczogc2hhcmVkUXVhZC5wb3NpdGlvbnMuc2xpY2UoKSxcbiAgICAgIHV2czogc2hhcmVkUXVhZC51dnMuc2xpY2UoKVxuICAgIH0pO1xuICAgIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoW3RpbGluZ1Nwcml0ZS51aWRdID0ge1xuICAgICAgY2FuQmF0Y2g6IHRydWUsXG4gICAgICByZW5kZXJhYmxlOiB0aWxpbmdTcHJpdGUsXG4gICAgICBnZW9tZXRyeVxuICAgIH07XG4gICAgdGlsaW5nU3ByaXRlLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF07XG4gIH1cbiAgX3VwZGF0ZUJhdGNoYWJsZU1lc2godGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgcmVuZGVyYWJsZURhdGEgPSB0aGlzLl9nZXRUaWxpbmdTcHJpdGVEYXRhKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gcmVuZGVyYWJsZURhdGE7XG4gICAgY29uc3Qgc3R5bGUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZS5zb3VyY2Uuc3R5bGU7XG4gICAgaWYgKHN0eWxlLmFkZHJlc3NNb2RlICE9PSBcInJlcGVhdFwiKSB7XG4gICAgICBzdHlsZS5hZGRyZXNzTW9kZSA9IFwicmVwZWF0XCI7XG4gICAgICBzdHlsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgc2V0VXZzKHRpbGluZ1Nwcml0ZSwgZ2VvbWV0cnkudXZzKTtcbiAgICBzZXRQb3NpdGlvbnModGlsaW5nU3ByaXRlLCBnZW9tZXRyeS5wb3NpdGlvbnMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoW2ldLnJlbmRlcmFibGUpO1xuICAgIH1cbiAgICB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIF91cGRhdGVDYW5CYXRjaCh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCByZW5kZXJhYmxlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGlsaW5nU3ByaXRlLnRleHR1cmU7XG4gICAgbGV0IF9ub25Qb3dPZjJ3cmFwcGluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHTCkge1xuICAgICAgX25vblBvd09mMndyYXBwaW5nID0gdGhpcy5fcmVuZGVyZXIuY29udGV4dC5zdXBwb3J0cy5ub25Qb3dPZjJ3cmFwcGluZztcbiAgICB9XG4gICAgcmVuZGVyYWJsZURhdGEuY2FuQmF0Y2ggPSB0ZXh0dXJlLnRleHR1cmVNYXRyaXguaXNTaW1wbGUgJiYgKF9ub25Qb3dPZjJ3cmFwcGluZyB8fCB0ZXh0dXJlLnNvdXJjZS5pc1Bvd2VyT2ZUd28pO1xuICAgIHJldHVybiByZW5kZXJhYmxlRGF0YS5jYW5CYXRjaDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cblRpbGluZ1Nwcml0ZVBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcInRpbGluZ1Nwcml0ZVwiXG59O1xuXG5leHBvcnQgeyBUaWxpbmdTcHJpdGVQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGVQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRpbGluZ1Nwcml0ZVBpcGUgfSBmcm9tICcuL1RpbGluZ1Nwcml0ZVBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChUaWxpbmdTcHJpdGVQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1015\n')},6678:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(8479);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(4146);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\n\n\n\n"use strict";\nclass AbstractBitmapFont extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = "";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: "none", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or "none".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");\n    return this.distanceField.type;\n  }\n  destroy() {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture.destroy();\n    }\n    this.chars = null;\n  }\n}\n\n\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  if (chars === "") {\n    return [];\n  }\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error("[BitmapFont]: Invalid character delimiter.");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture/* Texture */.x.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === "italic" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== "\\n" && char !== "\\r" && char !== "\t" && char !== " ") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle/* Rectangle */.A(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture/* Texture */.x({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture/* Texture */.x({\n      source: new ImageSource/* ImageSource */.c({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: "premultiply-alpha-on-upload"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color/* Color */.I.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = "black";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\n\n\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs\n\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === " ") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[" "];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === "\\r" || char === "\\n" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === "\\r" || char === "\\n") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === "center") {\n    alignCenter(layoutData);\n  } else if (style.align === "right") {\n    alignRight(layoutData);\n  } else if (style.align === "justify") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\n\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs\n\n\n\n\n\n\n\n"use strict";\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [["a", "z"], ["A", "Z"], " "];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [["0", "9"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[" ", "~"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill) {\n      fontFamilyKey += style._fill.fill.uid;\n      overrideFill = false;\n    }\n    if (!Cache/* Cache */.C.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fnt.once("destroy", () => Cache/* Cache */.C.remove(fontFamilyKey));\n      Cache/* Cache */.C.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache/* Cache */.C.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout(text.split(""), style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === "string") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error("[BitmapFontManager] Property `name` is required.");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle/* TextStyle */.p ? textStyle : new TextStyle/* TextStyle */.p(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(""));\n    Cache/* Cache */.C.set(`${name}-bitmap`, font);\n    font.once("destroy", () => Cache/* Cache */.C.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache/* Cache */.C.get(cacheKey);\n    if (font) {\n      Cache/* Cache */.C.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\n\n//# sourceMappingURL=BitmapFontManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs\n\n\n\n\n\n"use strict";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const textureSource = textures[charData.page].source;\n      const frameReal = new Rectangle/* Rectangle */.A(\n        charData.x,\n        charData.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture/* Texture */.x({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: "none",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from \'pixi.js\';\n   *\n   * BitmapFont.install(\'TitleFont\', {\n   *     fontFamily: \'Arial\',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: \'purple\',\n   * });\n   *\n   * const title = new BitmapText({ text: \'This is the title\', fontFamily: \'TitleFont\' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs\n\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs\n\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName("info")[0];\n    const common = xml.getElementsByTagName("common")[0];\n    const distanceField = xml.getElementsByTagName("distanceField")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute("fieldType"),\n        range: parseInt(distanceField.getAttribute("distanceRange"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    data.fontSize = parseInt(info.getAttribute("size"), 10);\n    data.fontFamily = info.getAttribute("face");\n    data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute("id"), 10);\n      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute("page"), 10) || 0,\n        x: parseInt(charNode.getAttribute("x"), 10),\n        y: parseInt(charNode.getAttribute("y"), 10),\n        width: parseInt(charNode.getAttribute("width"), 10),\n        height: parseInt(charNode.getAttribute("height"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),\n        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute("first"), 10);\n      const second = parseInt(kerning[i].getAttribute("second"), 10);\n      const amount = parseInt(kerning[i].getAttribute("amount"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs\n\n\n\n"use strict";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return bitmapFontXMLParser.test(adapter/* DOMAdapter */.z.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(adapter/* DOMAdapter */.z.get().parseXML(data));\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validExtensions = [".xml", ".fnt"];\nconst bitmapFontCachePlugin = {\n  extension: Extensions/* ExtensionType */.nw.CacheParser,\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Normal\n  },\n  test(url) {\n    return validExtensions.includes(path/* path */.E.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path/* path */.E.join(path/* path */.E.dirname(src), pageFile);\n      imagePath = (0,copySearchParams/* copySearchParams */.u)(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n    return await response.text();\n  },\n  unload(bitmapFont) {\n    bitmapFont.destroy();\n  }\n};\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(6475);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs\nvar shared_const = __webpack_require__(4589);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(2110);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6600);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs\nvar batchSamplersUniformGroup = __webpack_require__(5774);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 1 modules\nvar UniformGroup = __webpack_require__(3870);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs\n\nconst localUniformMSDFBit = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs\n\nconst mSDFBit = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=mSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass SdfShader extends Shader/* Shader */.e {\n  constructor() {\n    const uniforms = new UniformGroup/* UniformGroup */.o({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uDistance: { value: 4, type: "f32" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)(shared_const/* MAX_TEXTURES */.A),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(shared_const/* MAX_TEXTURES */.A),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: batchSamplersUniformGroup/* batchSamplersUniformGroup */.y\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=SdfShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    PoolGroup/* BigPool */.u.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== "none") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(\n      -bitmapText._anchor._x * bitmapTextLayout.width - padding,\n      -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding\n    ).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : "black",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = PoolGroup/* BigPool */.u.get(Graphics/* Graphics */.T);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on("destroyed", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache/* Cache */.C.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "bitmapText"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\n\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7OztBQzVKcUQ7QUFDcUI7QUFDeEI7QUFDVTtBQUNVO0FBQ0o7O0FBRWxFO0FBQ0E7QUFDQTtBQUNB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S0FBSyx3QkFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFLLFFBQVEsV0FBVztBQUNoRCxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQ3BKNkQ7QUFDc0I7QUFDN0I7O0FBRXREO0FBQ0EsNkJBQVUsS0FBSyxjQUFjLEVBQUUsY0FBYyxFQUFFLHFCQUFxQjtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0Fic3RyYWN0Qml0bWFwRm9udC5tanM/YjI3OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5tanM/MDEyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9EeW5hbWljQml0bWFwRm9udC5tanM/ZTNhOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC91dGlscy9nZXRCaXRtYXBUZXh0TGF5b3V0Lm1qcz8zYWVlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnRNYW5hZ2VyLm1qcz9kYjNmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnQubWpzP2NiN2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvYml0bWFwRm9udFRleHRQYXJzZXIubWpzPzA0ZjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvYml0bWFwRm9udFhNTFBhcnNlci5tanM/ZjYwNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcz82MDRlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL2Fzc2V0L2xvYWRCaXRtYXBGb250Lm1qcz8zODAwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzPzU4NGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbVNERkJpdC5tanM/YTI1YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L3NkZlNoYWRlci9TZGZTaGFkZXIubWpzP2E5Y2IiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwVGV4dFBpcGUubWpzP2E0NGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvaW5pdC5tanM/MjcxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBYnN0cmFjdEJpdG1hcEZvbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBUaGUgbWFwIG9mIGNoYXJhY3RlcnMgYnkgY2hhcmFjdGVyIGNvZGUuICovXG4gICAgdGhpcy5jaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lLWhlaWdodCBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZUhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZvbnQgZmFjZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJcIjtcbiAgICAvKiogVGhlIG1ldHJpY3Mgb2YgdGhlIGZvbnQgZmFjZS4gKi9cbiAgICB0aGlzLmZvbnRNZXRyaWNzID0geyBmb250U2l6ZTogMCwgYXNjZW50OiAwLCBkZXNjZW50OiAwIH07XG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCBvZiB0aGUgZm9udCBmYWNlIGZyb20gdGhlIGJhc2VsaW5lLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5iYXNlTGluZU9mZnNldCA9IDA7XG4gICAgLyoqIFRoZSByYW5nZSBhbmQgdHlwZSBvZiB0aGUgZGlzdGFuY2UgZmllbGQgZm9yIHRoaXMgZm9udC4gKi9cbiAgICB0aGlzLmRpc3RhbmNlRmllbGQgPSB7IHR5cGU6IFwibm9uZVwiLCByYW5nZTogMCB9O1xuICAgIC8qKiBUaGUgbWFwIG9mIGJhc2UgcGFnZSB0ZXh0dXJlcyAoaS5lLiwgc2hlZXRzIG9mIGdseXBocykuICovXG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy4gKi9cbiAgICB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplID0gMTAwO1xuICAgIHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgPSAxMDA7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmb250IGZhY2UuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgZm9udEZhbWlseWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBmb250KCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LmZvbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmZvbnRGYW1pbHkgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuZm9udEZhbWlseTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hcCBvZiBiYXNlIHBhZ2UgdGV4dHVyZXMgKGkuZS4sIHNoZWV0cyBvZiBnbHlwaHMpLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYHBhZ2VzYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHBhZ2VUZXh0dXJlcygpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5wYWdlVGV4dHVyZXMgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LnBhZ2VzIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLnBhZ2VzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBmb250TWV0cmljcy5mb250U2l6ZWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LnNpemUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmZvbnRNZXRyaWNzLmZvbnRTaXplIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmZvbnRNZXRyaWNzLmZvbnRTaXplO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiBkaXN0YW5jZSBmaWVsZCBmb3IgdGhpcyBmb250IG9yIFwibm9uZVwiLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGRpc3RhbmNlRmllbGQudHlwZWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBkaXN0YW5jZUZpZWxkUmFuZ2UoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZFJhbmdlIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5kaXN0YW5jZUZpZWxkLnJhbmdlIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlRmllbGQucmFuZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYW5nZSBvZiB0aGUgZGlzdGFuY2UgZmllbGQgaW4gcGl4ZWxzLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGRpc3RhbmNlRmllbGQucmFuZ2VgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZGlzdGFuY2VGaWVsZFR5cGUoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZFR5cGUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmRpc3RhbmNlRmllbGQudHlwZSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZUZpZWxkLnR5cGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuY2hhcnMpIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0udGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0Qml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpIHtcbiAgaWYgKGNoYXJzID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICh0eXBlb2YgY2hhcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjaGFycyA9IFtjaGFyc107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gY2hhcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGNoYXJzW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBpZiAoaXRlbS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMF0ubGVuZ3RoID09PSAwIHx8IGl0ZW1bMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgZGVsaW1pdGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Q29kZSA9IGl0ZW1bMF0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGNvbnN0IGVuZENvZGUgPSBpdGVtWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZW5kQ29kZSA8IHN0YXJ0Q29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkyID0gc3RhcnRDb2RlLCBqMiA9IGVuZENvZGU7IGkyIDw9IGoyOyBpMisrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goLi4uQXJyYXkuZnJvbShpdGVtKSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBFbXB0eSBzZXQgd2hlbiByZXNvbHZpbmcgY2hhcmFjdGVycy5cIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy9DYW52YXNUZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9jYW52YXMvdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRHluYW1pY0JpdG1hcEZvbnQgZXh0ZW5kcyBBYnN0cmFjdEJpdG1hcEZvbnQge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGR5bmFtaWMgYml0bWFwIGZvbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGEgcmVzb2x1dGlvbiBtb2RpZmllciBmb3IgdGhlIGZvbnQgc2l6ZS4uXG4gICAgICogdGV4dHVyZSByZXNvbHV0aW9uIHdpbGwgYWxzbyBiZSB1c2VkIHRvIHNjYWxlIHRleHR1cmUgYWNjb3JkaW5nIHRvIGl0cyBmb250IHNpemUgYWxzb1xuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgLyoqIFRoZSBwYWdlcyBvZiB0aGUgZm9udC4gKi9cbiAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgdGhpcy5fcGFkZGluZyA9IDQ7XG4gICAgdGhpcy5fbWVhc3VyZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fY3VycmVudENoYXJzID0gW107XG4gICAgdGhpcy5fY3VycmVudFggPSAwO1xuICAgIHRoaXMuX2N1cnJlbnRZID0gMDtcbiAgICB0aGlzLl9jdXJyZW50UGFnZUluZGV4ID0gLTE7XG4gICAgdGhpcy5fc2tpcEtlcm5pbmcgPSBmYWxzZTtcbiAgICBjb25zdCBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc3R5bGUgPSBkeW5hbWljT3B0aW9ucy5zdHlsZS5jbG9uZSgpO1xuICAgIGlmIChkeW5hbWljT3B0aW9ucy5vdmVycmlkZUZpbGwpIHtcbiAgICAgIHN0eWxlLl9maWxsLmNvbG9yID0gMTY3NzcyMTU7XG4gICAgICBzdHlsZS5fZmlsbC5hbHBoYSA9IDE7XG4gICAgICBzdHlsZS5fZmlsbC50ZXh0dXJlID0gVGV4dHVyZS5XSElURTtcbiAgICAgIHN0eWxlLl9maWxsLmZpbGwgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ZWRGb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZTtcbiAgICBjb25zdCBmb250ID0gZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUoc3R5bGUpO1xuICAgIGlmIChkeW5hbWljT3B0aW9ucy5vdmVycmlkZVNpemUpIHtcbiAgICAgIGlmIChzdHlsZS5fc3Ryb2tlKSB7XG4gICAgICAgIHN0eWxlLl9zdHJva2Uud2lkdGggKj0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZSAvIHJlcXVlc3RlZEZvbnRTaXplO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgPSByZXF1ZXN0ZWRGb250U2l6ZTtcbiAgICB9XG4gICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLl9za2lwS2VybmluZyA9IGR5bmFtaWNPcHRpb25zLnNraXBLZXJuaW5nID8/IGZhbHNlO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGR5bmFtaWNPcHRpb25zLnJlc29sdXRpb24gPz8gMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gZHluYW1pY09wdGlvbnMucGFkZGluZyA/PyA0O1xuICAgIHRoaXMuZm9udE1ldHJpY3MgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IHRoaXMuZm9udE1ldHJpY3MuZm9udFNpemUgfHwgc3R5bGUuZm9udFNpemU7XG4gIH1cbiAgZW5zdXJlQ2hhcmFjdGVycyhjaGFycykge1xuICAgIGNvbnN0IGNoYXJMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpLmZpbHRlcigoY2hhcikgPT4gIXRoaXMuX2N1cnJlbnRDaGFycy5pbmNsdWRlcyhjaGFyKSkuZmlsdGVyKChjaGFyLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKGNoYXIpID09PSBpbmRleCk7XG4gICAgaWYgKCFjaGFyTGlzdC5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY3VycmVudENoYXJzID0gWy4uLnRoaXMuX2N1cnJlbnRDaGFycywgLi4uY2hhckxpc3RdO1xuICAgIGxldCBwYWdlRGF0YTtcbiAgICBpZiAodGhpcy5fY3VycmVudFBhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHBhZ2VEYXRhID0gdGhpcy5fbmV4dFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZURhdGEgPSB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdO1xuICAgIH1cbiAgICBsZXQgeyBjYW52YXMsIGNvbnRleHQgfSA9IHBhZ2VEYXRhLmNhbnZhc0FuZENvbnRleHQ7XG4gICAgbGV0IHRleHR1cmVTb3VyY2UgPSBwYWdlRGF0YS50ZXh0dXJlLnNvdXJjZTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGxldCBjdXJyZW50WCA9IHRoaXMuX2N1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50WSA9IHRoaXMuX2N1cnJlbnRZO1xuICAgIGNvbnN0IGZvbnRTY2FsZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nICogZm9udFNjYWxlO1xuICAgIGNvbnN0IHdpZHRoU2NhbGUgPSBzdHlsZS5mb250U3R5bGUgPT09IFwiaXRhbGljXCIgPyAyIDogMTtcbiAgICBsZXQgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgbGV0IHNraXBUZXh0dXJlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJMaXN0W2ldO1xuICAgICAgY29uc3QgbWV0cmljcyA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KGNoYXIsIHN0eWxlLCBjYW52YXMsIGZhbHNlKTtcbiAgICAgIG1ldHJpY3MubGluZUhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSB3aWR0aFNjYWxlICogbWV0cmljcy53aWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0ICogZm9udFNjYWxlO1xuICAgICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIHBhZGRpbmcgKiAyO1xuICAgICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgcGFkZGluZyAqIDI7XG4gICAgICBza2lwVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgaWYgKGNoYXIgIT09IFwiXFxuXCIgJiYgY2hhciAhPT0gXCJcXHJcIiAmJiBjaGFyICE9PSBcIlx0XCIgJiYgY2hhciAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2tpcFRleHR1cmUgPSB0cnVlO1xuICAgICAgICBtYXhDaGFySGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KHBhZGRlZEhlaWdodCwgbWF4Q2hhckhlaWdodCkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRYICsgcGFkZGVkV2lkdGggPiA1MTIpIHtcbiAgICAgICAgY3VycmVudFkgKz0gbWF4Q2hhckhlaWdodDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IHBhZGRlZEhlaWdodDtcbiAgICAgICAgY3VycmVudFggPSAwO1xuICAgICAgICBpZiAoY3VycmVudFkgKyBtYXhDaGFySGVpZ2h0ID4gNTEyKSB7XG4gICAgICAgICAgdGV4dHVyZVNvdXJjZS51cGRhdGUoKTtcbiAgICAgICAgICBjb25zdCBwYWdlRGF0YTIgPSB0aGlzLl9uZXh0UGFnZSgpO1xuICAgICAgICAgIGNhbnZhcyA9IHBhZ2VEYXRhMi5jYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbiAgICAgICAgICBjb250ZXh0ID0gcGFnZURhdGEyLmNhbnZhc0FuZENvbnRleHQuY29udGV4dDtcbiAgICAgICAgICB0ZXh0dXJlU291cmNlID0gcGFnZURhdGEyLnRleHR1cmUuc291cmNlO1xuICAgICAgICAgIGN1cnJlbnRZID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeEFkdmFuY2UgPSB3aWR0aCAvIGZvbnRTY2FsZSAtIChzdHlsZS5kcm9wU2hhZG93Py5kaXN0YW5jZSA/PyAwKSAtIChzdHlsZS5fc3Ryb2tlPy53aWR0aCA/PyAwKTtcbiAgICAgIHRoaXMuY2hhcnNbY2hhcl0gPSB7XG4gICAgICAgIGlkOiBjaGFyLmNvZGVQb2ludEF0KDApLFxuICAgICAgICB4T2Zmc2V0OiAtdGhpcy5fcGFkZGluZyxcbiAgICAgICAgeU9mZnNldDogLXRoaXMuX3BhZGRpbmcsXG4gICAgICAgIHhBZHZhbmNlLFxuICAgICAgICBrZXJuaW5nOiB7fVxuICAgICAgfTtcbiAgICAgIGlmIChza2lwVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9kcmF3R2x5cGgoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBtZXRyaWNzLFxuICAgICAgICAgIGN1cnJlbnRYICsgcGFkZGluZyxcbiAgICAgICAgICBjdXJyZW50WSArIHBhZGRpbmcsXG4gICAgICAgICAgZm9udFNjYWxlLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHB4ID0gdGV4dHVyZVNvdXJjZS53aWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgcHkgPSB0ZXh0dXJlU291cmNlLmhlaWdodCAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgIGN1cnJlbnRYIC8gcHggKiB0ZXh0dXJlU291cmNlLndpZHRoLFxuICAgICAgICAgIGN1cnJlbnRZIC8gcHkgKiB0ZXh0dXJlU291cmNlLmhlaWdodCxcbiAgICAgICAgICBwYWRkZWRXaWR0aCAvIHB4ICogdGV4dHVyZVNvdXJjZS53aWR0aCxcbiAgICAgICAgICBwYWRkZWRIZWlnaHQgLyBweSAqIHRleHR1cmVTb3VyY2UuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2hhcnNbY2hhcl0udGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgICAgICBzb3VyY2U6IHRleHR1cmVTb3VyY2UsXG4gICAgICAgICAgZnJhbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRYICs9IE1hdGguY2VpbChwYWRkZWRXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHR1cmVTb3VyY2UudXBkYXRlKCk7XG4gICAgdGhpcy5fY3VycmVudFggPSBjdXJyZW50WDtcbiAgICB0aGlzLl9jdXJyZW50WSA9IGN1cnJlbnRZO1xuICAgIHRoaXMuX3NraXBLZXJuaW5nICYmIHRoaXMuX2FwcGx5S2VybmluZyhjaGFyTGlzdCwgY29udGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqIFRoZSBtYXAgb2YgYmFzZSBwYWdlIHRleHR1cmVzIChpLmUuLCBzaGVldHMgb2YgZ2x5cGhzKS5cbiAgICovXG4gIGdldCBwYWdlVGV4dHVyZXMoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQucGFnZVRleHR1cmVzIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5wYWdlcyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlcztcbiAgfVxuICBfYXBwbHlLZXJuaW5nKG5ld0NoYXJzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbWVhc3VyZUNhY2hlID0gdGhpcy5fbWVhc3VyZUNhY2hlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gbmV3Q2hhcnNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2N1cnJlbnRDaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBzZWNvbmQgPSB0aGlzLl9jdXJyZW50Q2hhcnNbal07XG4gICAgICAgIGxldCBjMSA9IG1lYXN1cmVDYWNoZVtmaXJzdF07XG4gICAgICAgIGlmICghYzEpXG4gICAgICAgICAgYzEgPSBtZWFzdXJlQ2FjaGVbZmlyc3RdID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCkud2lkdGg7XG4gICAgICAgIGxldCBjMiA9IG1lYXN1cmVDYWNoZVtzZWNvbmRdO1xuICAgICAgICBpZiAoIWMyKVxuICAgICAgICAgIGMyID0gbWVhc3VyZUNhY2hlW3NlY29uZF0gPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHNlY29uZCkud2lkdGg7XG4gICAgICAgIGxldCB0b3RhbCA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QgKyBzZWNvbmQpLndpZHRoO1xuICAgICAgICBsZXQgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW2ZpcnN0XS5rZXJuaW5nW3NlY29uZF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0ICsgc2Vjb25kKS53aWR0aDtcbiAgICAgICAgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX25leHRQYWdlKCkge1xuICAgIHRoaXMuX2N1cnJlbnRQYWdlSW5kZXgrKztcbiAgICBjb25zdCB0ZXh0dXJlUmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCg1MTIsIDUxMiwgdGV4dHVyZVJlc29sdXRpb24pO1xuICAgIHRoaXMuX3NldHVwQ29udGV4dChjYW52YXNBbmRDb250ZXh0LmNvbnRleHQsIHRoaXMuX3N0eWxlLCB0ZXh0dXJlUmVzb2x1dGlvbik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRleHR1cmVSZXNvbHV0aW9uICogKHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgSW1hZ2VTb3VyY2Uoe1xuICAgICAgICByZXNvdXJjZTogY2FudmFzQW5kQ29udGV4dC5jYW52YXMsXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIGFscGhhTW9kZTogXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBwYWdlRGF0YSA9IHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdID0gcGFnZURhdGE7XG4gICAgcmV0dXJuIHBhZ2VEYXRhO1xuICB9XG4gIC8vIGNhbnZhcyBzdHlsZSFcbiAgX3NldHVwQ29udGV4dChjb250ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbikge1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZTtcbiAgICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemU7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuX3N0cm9rZTtcbiAgICBjb25zdCBzdHJva2VUaGlja25lc3MgPSBzdHJva2U/LndpZHRoID8/IDA7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VUaGlja25lc3M7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gc3Ryb2tlLmpvaW47XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2UubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNGaWxsU3R5bGUoc3Ryb2tlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLl9maWxsKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fZmlsbCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICBjb25zdCBzaGFkb3dPcHRpb25zID0gc3R5bGUuZHJvcFNoYWRvdztcbiAgICAgIGNvbnN0IHJnYiA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzaGFkb3dPcHRpb25zLmNvbG9yKS50b0FycmF5KCk7XG4gICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHNoYWRvd09wdGlvbnMuYmx1ciAqIHJlc29sdXRpb247XG4gICAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzaGFkb3dPcHRpb25zLmRpc3RhbmNlICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBgcmdiYSgke3JnYlswXSAqIDI1NX0sJHtyZ2JbMV0gKiAyNTV9LCR7cmdiWzJdICogMjU1fSwke3NoYWRvd09wdGlvbnMuYWxwaGF9KWA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG4gIF9kcmF3R2x5cGgoY29udGV4dCwgbWV0cmljcywgeCwgeSwgZm9udFNjYWxlLCBzdHlsZSkge1xuICAgIGNvbnN0IGNoYXIgPSBtZXRyaWNzLnRleHQ7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgY29uc3Qgc3Ryb2tlVGhpY2tuZXNzID0gKHN0cm9rZT8ud2lkdGggPz8gMCkgKiBmb250U2NhbGU7XG4gICAgY29uc3QgdHggPSB4ICsgc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCB0eSA9IHkgLSBzdHJva2VUaGlja25lc3MgLyAyO1xuICAgIGNvbnN0IGRlc2NlbnQgPSBmb250UHJvcGVydGllcy5kZXNjZW50ICogZm9udFNjYWxlO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiBmb250U2NhbGU7XG4gICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5fZmlsbCkge1xuICAgICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBjYW52YXNBbmRDb250ZXh0LCB0ZXh0dXJlIH0gPSB0aGlzLnBhZ2VzW2ldO1xuICAgICAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpO1xuICAgICAgdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2VzID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBEeW5hbWljQml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHluYW1pY0JpdG1hcEZvbnQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRCaXRtYXBUZXh0TGF5b3V0KGNoYXJzLCBzdHlsZSwgZm9udCkge1xuICBjb25zdCBsYXlvdXREYXRhID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIHNjYWxlOiBzdHlsZS5mb250U2l6ZSAvIGZvbnQuYmFzZU1lYXN1cmVtZW50Rm9udFNpemUsXG4gICAgbGluZXM6IFt7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGNoYXJQb3NpdGlvbnM6IFtdLFxuICAgICAgc3BhY2VXaWR0aDogMCxcbiAgICAgIHNwYWNlc0luZGV4OiBbXSxcbiAgICAgIGNoYXJzOiBbXVxuICAgIH1dXG4gIH07XG4gIGxheW91dERhdGEub2Zmc2V0WSA9IGZvbnQuYmFzZUxpbmVPZmZzZXQ7XG4gIGxldCBjdXJyZW50TGluZSA9IGxheW91dERhdGEubGluZXNbMF07XG4gIGxldCBwcmV2aW91c0NoYXIgPSBudWxsO1xuICBsZXQgZmlyc3RXb3JkID0gdHJ1ZTtcbiAgY29uc3QgY3VycmVudFdvcmQgPSB7XG4gICAgc3BhY2VXb3JkOiBmYWxzZSxcbiAgICB3aWR0aDogMCxcbiAgICBzdGFydDogMCxcbiAgICBpbmRleDogMCxcbiAgICAvLyB1c2UgaW5kZXggdG8gbm90IG1vZGlmeSB0aGUgYXJyYXkgYXMgd2UgdXNlIGl0IGEgbG90IVxuICAgIHBvc2l0aW9uczogW10sXG4gICAgY2hhcnM6IFtdXG4gIH07XG4gIGNvbnN0IG5leHRXb3JkID0gKHdvcmQpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IGN1cnJlbnRMaW5lLndpZHRoO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VycmVudFdvcmQuaW5kZXg7IGorKykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB3b3JkLnBvc2l0aW9uc1tqXTtcbiAgICAgIGN1cnJlbnRMaW5lLmNoYXJzLnB1c2god29yZC5jaGFyc1tqXSk7XG4gICAgICBjdXJyZW50TGluZS5jaGFyUG9zaXRpb25zLnB1c2gocG9zaXRpb24gKyBzdGFydCk7XG4gICAgfVxuICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHdvcmQud2lkdGg7XG4gICAgZmlyc3RXb3JkID0gZmFsc2U7XG4gICAgY3VycmVudFdvcmQud2lkdGggPSAwO1xuICAgIGN1cnJlbnRXb3JkLmluZGV4ID0gMDtcbiAgICBjdXJyZW50V29yZC5jaGFycy5sZW5ndGggPSAwO1xuICB9O1xuICBjb25zdCBuZXh0TGluZSA9ICgpID0+IHtcbiAgICBsZXQgaW5kZXggPSBjdXJyZW50TGluZS5jaGFycy5sZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Q2hhciA9IGN1cnJlbnRMaW5lLmNoYXJzW2luZGV4XTtcbiAgICB3aGlsZSAobGFzdENoYXIgPT09IFwiIFwiKSB7XG4gICAgICBjdXJyZW50TGluZS53aWR0aCAtPSBmb250LmNoYXJzW2xhc3RDaGFyXS54QWR2YW5jZTtcbiAgICAgIGxhc3RDaGFyID0gY3VycmVudExpbmUuY2hhcnNbLS1pbmRleF07XG4gICAgfVxuICAgIGxheW91dERhdGEud2lkdGggPSBNYXRoLm1heChsYXlvdXREYXRhLndpZHRoLCBjdXJyZW50TGluZS53aWR0aCk7XG4gICAgY3VycmVudExpbmUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGNoYXJQb3NpdGlvbnM6IFtdLFxuICAgICAgY2hhcnM6IFtdLFxuICAgICAgc3BhY2VXaWR0aDogMCxcbiAgICAgIHNwYWNlc0luZGV4OiBbXVxuICAgIH07XG4gICAgZmlyc3RXb3JkID0gdHJ1ZTtcbiAgICBsYXlvdXREYXRhLmxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgIGxheW91dERhdGEuaGVpZ2h0ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfTtcbiAgY29uc3Qgc2NhbGUgPSBmb250LmJhc2VNZWFzdXJlbWVudEZvbnRTaXplIC8gc3R5bGUuZm9udFNpemU7XG4gIGNvbnN0IGFkanVzdGVkTGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmcgKiBzY2FsZTtcbiAgY29uc3QgYWRqdXN0ZWRXb3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCAqIHNjYWxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aCArIDE7IGkrKykge1xuICAgIGxldCBjaGFyO1xuICAgIGNvbnN0IGlzRW5kID0gaSA9PT0gY2hhcnMubGVuZ3RoO1xuICAgIGlmICghaXNFbmQpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgY29uc3QgY2hhckRhdGEgPSBmb250LmNoYXJzW2NoYXJdIHx8IGZvbnQuY2hhcnNbXCIgXCJdO1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvKD86XFxzKS8udGVzdChjaGFyKTtcbiAgICBjb25zdCBpc1dvcmRCcmVhayA9IGlzU3BhY2UgfHwgY2hhciA9PT0gXCJcXHJcIiB8fCBjaGFyID09PSBcIlxcblwiIHx8IGlzRW5kO1xuICAgIGlmIChpc1dvcmRCcmVhaykge1xuICAgICAgY29uc3QgYWRkV29yZFRvTmV4dExpbmUgPSAhZmlyc3RXb3JkICYmIHN0eWxlLndvcmRXcmFwICYmIGN1cnJlbnRMaW5lLndpZHRoICsgY3VycmVudFdvcmQud2lkdGggLSBhZGp1c3RlZExldHRlclNwYWNpbmcgPiBhZGp1c3RlZFdvcmRXcmFwV2lkdGg7XG4gICAgICBpZiAoYWRkV29yZFRvTmV4dExpbmUpIHtcbiAgICAgICAgbmV4dExpbmUoKTtcbiAgICAgICAgbmV4dFdvcmQoY3VycmVudFdvcmQpO1xuICAgICAgICBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50V29yZC5zdGFydCA9IGN1cnJlbnRMaW5lLndpZHRoO1xuICAgICAgICBuZXh0V29yZChjdXJyZW50V29yZCk7XG4gICAgICAgIGlmICghaXNFbmQpIHtcbiAgICAgICAgICBjdXJyZW50TGluZS5jaGFyUG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSBcIlxcclwiIHx8IGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgbmV4dExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNFbmQpIHtcbiAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9IGNoYXJEYXRhLnhBZHZhbmNlICsgKGNoYXJEYXRhLmtlcm5pbmdbcHJldmlvdXNDaGFyXSB8fCAwKSArIGFkanVzdGVkTGV0dGVyU3BhY2luZztcbiAgICAgICAgY3VycmVudExpbmUud2lkdGggKz0gc3BhY2VXaWR0aDtcbiAgICAgICAgY3VycmVudExpbmUuc3BhY2VXaWR0aCA9IHNwYWNlV2lkdGg7XG4gICAgICAgIGN1cnJlbnRMaW5lLnNwYWNlc0luZGV4LnB1c2goY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGgpO1xuICAgICAgICBjdXJyZW50TGluZS5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXJuaW5nID0gY2hhckRhdGEua2VybmluZ1twcmV2aW91c0NoYXJdIHx8IDA7XG4gICAgICBjb25zdCBuZXh0Q2hhcldpZHRoID0gY2hhckRhdGEueEFkdmFuY2UgKyBrZXJuaW5nICsgYWRqdXN0ZWRMZXR0ZXJTcGFjaW5nO1xuICAgICAgY3VycmVudFdvcmQucG9zaXRpb25zW2N1cnJlbnRXb3JkLmluZGV4KytdID0gY3VycmVudFdvcmQud2lkdGggKyBrZXJuaW5nO1xuICAgICAgY3VycmVudFdvcmQuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgIGN1cnJlbnRXb3JkLndpZHRoICs9IG5leHRDaGFyV2lkdGg7XG4gICAgfVxuICAgIHByZXZpb3VzQ2hhciA9IGNoYXI7XG4gIH1cbiAgbmV4dExpbmUoKTtcbiAgaWYgKHN0eWxlLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgYWxpZ25DZW50ZXIobGF5b3V0RGF0YSk7XG4gIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgIGFsaWduUmlnaHQobGF5b3V0RGF0YSk7XG4gIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwianVzdGlmeVwiKSB7XG4gICAgYWxpZ25KdXN0aWZ5KGxheW91dERhdGEpO1xuICB9XG4gIHJldHVybiBsYXlvdXREYXRhO1xufVxuZnVuY3Rpb24gYWxpZ25DZW50ZXIobWVhc3VyZW1lbnREYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnREYXRhLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IG1lYXN1cmVtZW50RGF0YS5saW5lc1tpXTtcbiAgICBjb25zdCBvZmZzZXQgPSBtZWFzdXJlbWVudERhdGEud2lkdGggLyAyIC0gbGluZS53aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxpbmUuY2hhclBvc2l0aW9uc1tqXSArPSBvZmZzZXQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGlnblJpZ2h0KG1lYXN1cmVtZW50RGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVhc3VyZW1lbnREYXRhLndpZHRoIC0gbGluZS53aWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgbGluZS5jaGFyUG9zaXRpb25zW2pdICs9IG9mZnNldDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFsaWduSnVzdGlmeShtZWFzdXJlbWVudERhdGEpIHtcbiAgY29uc3Qgd2lkdGggPSBtZWFzdXJlbWVudERhdGEud2lkdGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnREYXRhLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IG1lYXN1cmVtZW50RGF0YS5saW5lc1tpXTtcbiAgICBsZXQgaW5keSA9IDA7XG4gICAgbGV0IHNwYWNlSW5kZXggPSBsaW5lLnNwYWNlc0luZGV4W2luZHkrK107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgdG90YWxTcGFjZXMgPSBsaW5lLnNwYWNlc0luZGV4Lmxlbmd0aDtcbiAgICBjb25zdCBuZXdTcGFjZVdpZHRoID0gKHdpZHRoIC0gbGluZS53aWR0aCkgLyB0b3RhbFNwYWNlcztcbiAgICBjb25zdCBzcGFjZVdpZHRoID0gbmV3U3BhY2VXaWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGogPT09IHNwYWNlSW5kZXgpIHtcbiAgICAgICAgc3BhY2VJbmRleCA9IGxpbmUuc3BhY2VzSW5kZXhbaW5keSsrXTtcbiAgICAgICAgb2Zmc2V0ICs9IHNwYWNlV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lLmNoYXJQb3NpdGlvbnNbal0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBnZXRCaXRtYXBUZXh0TGF5b3V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCaXRtYXBUZXh0TGF5b3V0Lm1qcy5tYXBcbiIsImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IER5bmFtaWNCaXRtYXBGb250IH0gZnJvbSAnLi9EeW5hbWljQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQml0bWFwRm9udE1hbmFnZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2hhcmFjdGVyIHNldCBpbmNsdWRlcyBhbGwgdGhlIGxldHRlcnMgaW4gdGhlIGFscGhhYmV0IChib3RoIGxvd2VyLSBhbmQgdXBwZXItIGNhc2UpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogQml0bWFwRm9udC5mcm9tKCdFeGFtcGxlRm9udCcsIHN0eWxlLCB7IGNoYXJzOiBCaXRtYXBGb250LkFMUEhBIH0pXG4gICAgICovXG4gICAgdGhpcy5BTFBIQSA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIGRlY2ltYWwgZGlnaXRzIChmcm9tIDAgdG8gOSkuXG4gICAgICogQHR5cGUge3N0cmluZ1tdW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBCaXRtYXBGb250LmZyb20oJ0V4YW1wbGVGb250Jywgc3R5bGUsIHsgY2hhcnM6IEJpdG1hcEZvbnQuTlVNRVJJQyB9KVxuICAgICAqL1xuICAgIHRoaXMuTlVNRVJJQyA9IFtbXCIwXCIsIFwiOVwiXV07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGFyYWN0ZXIgc2V0IGlzIHRoZSB1bmlvbiBvZiBgQml0bWFwRm9udC5BTFBIQWAgYW5kIGBCaXRtYXBGb250Lk5VTUVSSUNgLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuQUxQSEFOVU1FUklDID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgY29uc2lzdHMgb2YgYWxsIHRoZSBBU0NJSSB0YWJsZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXVtdfVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5hc2NpaXRhYmxlLmNvbS9cbiAgICAgKi9cbiAgICB0aGlzLkFTQ0lJID0gW1tcIiBcIiwgXCJ+XCJdXTtcbiAgICAvKiogRGVmYXVsdCBvcHRpb25zIGZvciBpbnN0YWxsaW5nIGEgbmV3IEJpdG1hcEZvbnQuICovXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGNoYXJzOiB0aGlzLkFMUEhBTlVNRVJJQyxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBwYWRkaW5nOiA0LFxuICAgICAgc2tpcEtlcm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgZm9udCBmb3IgdGhlIHNwZWNpZmllZCB0ZXh0IGFuZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBnZXQgdGhlIGZvbnQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldEZvbnQodGV4dCwgc3R5bGUpIHtcbiAgICBsZXQgZm9udEZhbWlseUtleSA9IGAke3N0eWxlLmZvbnRGYW1pbHl9LWJpdG1hcGA7XG4gICAgbGV0IG92ZXJyaWRlRmlsbCA9IHRydWU7XG4gICAgaWYgKHN0eWxlLl9maWxsLmZpbGwpIHtcbiAgICAgIGZvbnRGYW1pbHlLZXkgKz0gc3R5bGUuX2ZpbGwuZmlsbC51aWQ7XG4gICAgICBvdmVycmlkZUZpbGwgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFDYWNoZS5oYXMoZm9udEZhbWlseUtleSkpIHtcbiAgICAgIGNvbnN0IGZudCA9IG5ldyBEeW5hbWljQml0bWFwRm9udCh7XG4gICAgICAgIHN0eWxlLFxuICAgICAgICBvdmVycmlkZUZpbGwsXG4gICAgICAgIG92ZXJyaWRlU2l6ZTogdHJ1ZSxcbiAgICAgICAgLi4udGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBmbnQub25jZShcImRlc3Ryb3lcIiwgKCkgPT4gQ2FjaGUucmVtb3ZlKGZvbnRGYW1pbHlLZXkpKTtcbiAgICAgIENhY2hlLnNldChcbiAgICAgICAgZm9udEZhbWlseUtleSxcbiAgICAgICAgZm50XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkeW5hbWljRm9udCA9IENhY2hlLmdldChmb250RmFtaWx5S2V5KTtcbiAgICBkeW5hbWljRm9udC5lbnN1cmVDaGFyYWN0ZXJzPy4odGV4dCk7XG4gICAgcmV0dXJuIGR5bmFtaWNGb250O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheW91dCBvZiBhIHRleHQgZm9yIHRoZSBzcGVjaWZpZWQgc3R5bGUuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZ2V0IHRoZSBsYXlvdXQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldExheW91dCh0ZXh0LCBzdHlsZSkge1xuICAgIGNvbnN0IGJpdG1hcEZvbnQgPSB0aGlzLmdldEZvbnQodGV4dCwgc3R5bGUpO1xuICAgIHJldHVybiBnZXRCaXRtYXBUZXh0TGF5b3V0KHRleHQuc3BsaXQoXCJcIiksIHN0eWxlLCBiaXRtYXBGb250KTtcbiAgfVxuICAvKipcbiAgICogTWVhc3VyZSB0aGUgdGV4dCB1c2luZyB0aGUgc3BlY2lmaWVkIHN0eWxlLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIG1lYXN1cmVcbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHRvIHVzZVxuICAgKi9cbiAgbWVhc3VyZVRleHQodGV4dCwgc3R5bGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXlvdXQodGV4dCwgc3R5bGUpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGluc3RhbGwoLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMsXG4gICAgICAgIHN0eWxlOiBhcmdzWzFdLFxuICAgICAgICBjaGFyczogYXJnc1syXT8uY2hhcnMsXG4gICAgICAgIHJlc29sdXRpb246IGFyZ3NbMl0/LnJlc29sdXRpb24sXG4gICAgICAgIHBhZGRpbmc6IGFyZ3NbMl0/LnBhZGRpbmcsXG4gICAgICAgIHNraXBLZXJuaW5nOiBhcmdzWzJdPy5za2lwS2VybmluZ1xuICAgICAgfTtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250TWFuYWdlci5pbnN0YWxsKG5hbWUsIHN0eWxlLCBvcHRpb25zKSBpcyBkZXByZWNhdGVkLCB1c2UgQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbCh7bmFtZSwgc3R5bGUsIC4uLm9wdGlvbnN9KVwiKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IG9wdGlvbnM/Lm5hbWU7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udE1hbmFnZXJdIFByb3BlcnR5IGBuYW1lYCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlID0gdGV4dFN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlID8gdGV4dFN0eWxlIDogbmV3IFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIGNvbnN0IG92ZXJyaWRlRmlsbCA9IHN0eWxlLl9maWxsLmZpbGwgIT09IG51bGwgJiYgc3R5bGUuX2ZpbGwuZmlsbCAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IGZvbnQgPSBuZXcgRHluYW1pY0JpdG1hcEZvbnQoe1xuICAgICAgc3R5bGUsXG4gICAgICBvdmVycmlkZUZpbGwsXG4gICAgICBza2lwS2VybmluZzogb3B0aW9ucy5za2lwS2VybmluZyxcbiAgICAgIHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIHJlc29sdXRpb246IG9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgIG92ZXJyaWRlU2l6ZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBmbGF0Q2hhcnMgPSByZXNvbHZlQ2hhcmFjdGVycyhvcHRpb25zLmNoYXJzKTtcbiAgICBmb250LmVuc3VyZUNoYXJhY3RlcnMoZmxhdENoYXJzLmpvaW4oXCJcIikpO1xuICAgIENhY2hlLnNldChgJHtuYW1lfS1iaXRtYXBgLCBmb250KTtcbiAgICBmb250Lm9uY2UoXCJkZXN0cm95XCIsICgpID0+IENhY2hlLnJlbW92ZShgJHtuYW1lfS1iaXRtYXBgKSk7XG4gICAgcmV0dXJuIGZvbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW5zdGFsbHMgYSBiaXRtYXAgZm9udCBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYml0bWFwIGZvbnQgdG8gdW5pbnN0YWxsLlxuICAgKi9cbiAgdW5pbnN0YWxsKG5hbWUpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke25hbWV9LWJpdG1hcGA7XG4gICAgY29uc3QgZm9udCA9IENhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG4gICAgICBmb250LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IEJpdG1hcEZvbnRNYW5hZ2VyID0gbmV3IEJpdG1hcEZvbnRNYW5hZ2VyQ2xhc3MoKTtcblxuZXhwb3J0IHsgQml0bWFwRm9udE1hbmFnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcEZvbnRNYW5hZ2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEFic3RyYWN0Qml0bWFwRm9udCB9IGZyb20gJy4vQWJzdHJhY3RCaXRtYXBGb250Lm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250TWFuYWdlciB9IGZyb20gJy4vQml0bWFwRm9udE1hbmFnZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaXRtYXBGb250IGV4dGVuZHMgQWJzdHJhY3RCaXRtYXBGb250IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgdXJsKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7IHRleHR1cmVzLCBkYXRhIH0gPSBvcHRpb25zO1xuICAgIE9iamVjdC5rZXlzKGRhdGEucGFnZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgcGFnZURhdGEgPSBkYXRhLnBhZ2VzW3BhcnNlSW50KGtleSwgMTApXTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1twYWdlRGF0YS5pZF07XG4gICAgICB0aGlzLnBhZ2VzLnB1c2goeyB0ZXh0dXJlIH0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKGRhdGEuY2hhcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2tleV07XG4gICAgICBjb25zdCB0ZXh0dXJlU291cmNlID0gdGV4dHVyZXNbY2hhckRhdGEucGFnZV0uc291cmNlO1xuICAgICAgY29uc3QgZnJhbWVSZWFsID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgY2hhckRhdGEueCxcbiAgICAgICAgY2hhckRhdGEueSxcbiAgICAgICAgY2hhckRhdGEud2lkdGgsXG4gICAgICAgIGNoYXJEYXRhLmhlaWdodFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh7XG4gICAgICAgIHNvdXJjZTogdGV4dHVyZVNvdXJjZSxcbiAgICAgICAgZnJhbWU6IGZyYW1lUmVhbFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNoYXJzW2tleV0gPSB7XG4gICAgICAgIGlkOiBrZXkuY29kZVBvaW50QXQoMCksXG4gICAgICAgIHhPZmZzZXQ6IGNoYXJEYXRhLnhPZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IGNoYXJEYXRhLnlPZmZzZXQsXG4gICAgICAgIHhBZHZhbmNlOiBjaGFyRGF0YS54QWR2YW5jZSxcbiAgICAgICAga2VybmluZzogY2hhckRhdGEua2VybmluZyA/PyB7fSxcbiAgICAgICAgdGV4dHVyZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRNZXRyaWNzID0ge1xuICAgICAgYXNjZW50OiAwLFxuICAgICAgZGVzY2VudDogMCxcbiAgICAgIGZvbnRTaXplOiBkYXRhLmZvbnRTaXplXG4gICAgfTtcbiAgICB0aGlzLmJhc2VMaW5lT2Zmc2V0ID0gZGF0YS5iYXNlTGluZU9mZnNldDtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZGF0YS5mb250RmFtaWx5O1xuICAgIHRoaXMuZGlzdGFuY2VGaWVsZCA9IGRhdGEuZGlzdGFuY2VGaWVsZCA/PyB7XG4gICAgICB0eXBlOiBcIm5vbmVcIixcbiAgICAgIHJhbmdlOiAwXG4gICAgfTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEJpdG1hcEZvbnQgb2JqZWN0LiAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdGV4dHVyZSB9ID0gdGhpcy5wYWdlc1tpXTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGJpdG1hcC1mb250IGZvciB0aGUgZ2l2ZW4gc3R5bGUgYW5kIGNoYXJhY3RlciBzZXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZXR1cCBvcHRpb25zIGZvciBmb250IGdlbmVyYXRpb24uXG4gICAqIEByZXR1cm5zIEZvbnQgZ2VuZXJhdGVkIGJ5IHN0eWxlIG9wdGlvbnMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEJpdG1hcEZvbnQsIEJpdG1hcFRleHQgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogQml0bWFwRm9udC5pbnN0YWxsKCdUaXRsZUZvbnQnLCB7XG4gICAqICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgKiAgICAgZm9udFNpemU6IDEyLFxuICAgKiAgICAgc3Ryb2tlVGhpY2tuZXNzOiAyLFxuICAgKiAgICAgZmlsbDogJ3B1cnBsZScsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCB0aXRsZSA9IG5ldyBCaXRtYXBUZXh0KHsgdGV4dDogJ1RoaXMgaXMgdGhlIHRpdGxlJywgZm9udEZhbWlseTogJ1RpdGxlRm9udCcgfSk7XG4gICAqL1xuICBzdGF0aWMgaW5zdGFsbChvcHRpb25zKSB7XG4gICAgQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVW5pbnN0YWxscyBhIGJpdG1hcCBmb250IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaXRtYXAgZm9udCB0byB1bmluc3RhbGwuXG4gICAqL1xuICBzdGF0aWMgdW5pbnN0YWxsKG5hbWUpIHtcbiAgICBCaXRtYXBGb250TWFuYWdlci51bmluc3RhbGwobmFtZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJpdG1hcEZvbnRUZXh0UGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5zdGFydHNXaXRoKFwiaW5mbyBmYWNlPVwiKTtcbiAgfSxcbiAgcGFyc2UodHh0KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0eHQubWF0Y2goL15bYS16XStcXHMrLiskL2dtKTtcbiAgICBjb25zdCByYXdEYXRhID0ge1xuICAgICAgaW5mbzogW10sXG4gICAgICBjb21tb246IFtdLFxuICAgICAgcGFnZTogW10sXG4gICAgICBjaGFyOiBbXSxcbiAgICAgIGNoYXJzOiBbXSxcbiAgICAgIGtlcm5pbmc6IFtdLFxuICAgICAga2VybmluZ3M6IFtdLFxuICAgICAgZGlzdGFuY2VGaWVsZDogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgaSBpbiBpdGVtcykge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW1zW2ldLm1hdGNoKC9eW2Etel0rL2dtKVswXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBpdGVtc1tpXS5tYXRjaCgvW2EtekEtWl0rPShbXlxcc1wiJ10rfFwiKFteXCJdKilcIikvZ20pO1xuICAgICAgY29uc3QgaXRlbURhdGEgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaTIgaW4gYXR0cmlidXRlTGlzdCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGF0dHJpYnV0ZUxpc3RbaTJdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0gc3BsaXRbMF07XG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gc3BsaXRbMV0ucmVwbGFjZSgvXCIvZ20sIFwiXCIpO1xuICAgICAgICBjb25zdCBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChzdHJWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNOYU4oZmxvYXRWYWx1ZSkgPyBzdHJWYWx1ZSA6IGZsb2F0VmFsdWU7XG4gICAgICAgIGl0ZW1EYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJhd0RhdGFbbmFtZV0ucHVzaChpdGVtRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB7XG4gICAgICBjaGFyczoge30sXG4gICAgICBwYWdlczogW10sXG4gICAgICBsaW5lSGVpZ2h0OiAwLFxuICAgICAgZm9udFNpemU6IDAsXG4gICAgICBmb250RmFtaWx5OiBcIlwiLFxuICAgICAgZGlzdGFuY2VGaWVsZDogbnVsbCxcbiAgICAgIGJhc2VMaW5lT2Zmc2V0OiAwXG4gICAgfTtcbiAgICBjb25zdCBbaW5mb10gPSByYXdEYXRhLmluZm87XG4gICAgY29uc3QgW2NvbW1vbl0gPSByYXdEYXRhLmNvbW1vbjtcbiAgICBjb25zdCBbZGlzdGFuY2VGaWVsZF0gPSByYXdEYXRhLmRpc3RhbmNlRmllbGQgPz8gW107XG4gICAgaWYgKGRpc3RhbmNlRmllbGQpIHtcbiAgICAgIGZvbnQuZGlzdGFuY2VGaWVsZCA9IHtcbiAgICAgICAgcmFuZ2U6IHBhcnNlSW50KGRpc3RhbmNlRmllbGQuZGlzdGFuY2VSYW5nZSwgMTApLFxuICAgICAgICB0eXBlOiBkaXN0YW5jZUZpZWxkLmZpZWxkVHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9udC5mb250U2l6ZSA9IHBhcnNlSW50KGluZm8uc2l6ZSwgMTApO1xuICAgIGZvbnQuZm9udEZhbWlseSA9IGluZm8uZmFjZTtcbiAgICBmb250LmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24ubGluZUhlaWdodCwgMTApO1xuICAgIGNvbnN0IHBhZ2UgPSByYXdEYXRhLnBhZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb250LnBhZ2VzLnB1c2goe1xuICAgICAgICBpZDogcGFyc2VJbnQocGFnZVtpXS5pZCwgMTApIHx8IDAsXG4gICAgICAgIGZpbGU6IHBhZ2VbaV0uZmlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGZvbnQuYmFzZUxpbmVPZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLSBwYXJzZUludChjb21tb24uYmFzZSwgMTApO1xuICAgIGNvbnN0IGNoYXIgPSByYXdEYXRhLmNoYXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyTm9kZSA9IGNoYXJbaV07XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGNoYXJOb2RlLmlkLCAxMCk7XG4gICAgICBsZXQgbGV0dGVyID0gY2hhck5vZGUubGV0dGVyID8/IGNoYXJOb2RlLmNoYXIgPz8gU3RyaW5nLmZyb21DaGFyQ29kZShpZCk7XG4gICAgICBpZiAobGV0dGVyID09PSBcInNwYWNlXCIpXG4gICAgICAgIGxldHRlciA9IFwiIFwiO1xuICAgICAgbWFwW2lkXSA9IGxldHRlcjtcbiAgICAgIGZvbnQuY2hhcnNbbGV0dGVyXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRleHR1cmUgZGVldHMuLlxuICAgICAgICBwYWdlOiBwYXJzZUludChjaGFyTm9kZS5wYWdlLCAxMCkgfHwgMCxcbiAgICAgICAgeDogcGFyc2VJbnQoY2hhck5vZGUueCwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChjaGFyTm9kZS55LCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyTm9kZS53aWR0aCwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXJOb2RlLmhlaWdodCwgMTApLFxuICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS54b2Zmc2V0LCAxMCksXG4gICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGNoYXJOb2RlLnlvZmZzZXQsIDEwKSxcbiAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGNoYXJOb2RlLnhhZHZhbmNlLCAxMCksXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXJuaW5nID0gcmF3RGF0YS5rZXJuaW5nIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlyc3QgPSBwYXJzZUludChrZXJuaW5nW2ldLmZpcnN0LCAxMCk7XG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChrZXJuaW5nW2ldLnNlY29uZCwgMTApO1xuICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5hbW91bnQsIDEwKTtcbiAgICAgIGZvbnQuY2hhcnNbbWFwW3NlY29uZF1dLmtlcm5pbmdbbWFwW2ZpcnN0XV0gPSBhbW91bnQ7XG4gICAgfVxuICAgIHJldHVybiBmb250O1xuICB9XG59O1xuXG5leHBvcnQgeyBiaXRtYXBGb250VGV4dFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFRleHRQYXJzZXIubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBiaXRtYXBGb250WE1MUGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICBjb25zdCB4bWwgPSBkYXRhO1xuICAgIHJldHVybiB0eXBlb2YgeG1sICE9PSBcInN0cmluZ1wiICYmIFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIiBpbiB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFnZVwiKS5sZW5ndGggJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKVswXS5nZXRBdHRyaWJ1dGUoXCJmYWNlXCIpICE9PSBudWxsO1xuICB9LFxuICBwYXJzZSh4bWwpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgY2hhcnM6IHt9LFxuICAgICAgcGFnZXM6IFtdLFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIGZvbnRTaXplOiAwLFxuICAgICAgZm9udEZhbWlseTogXCJcIixcbiAgICAgIGRpc3RhbmNlRmllbGQ6IG51bGwsXG4gICAgICBiYXNlTGluZU9mZnNldDogMFxuICAgIH07XG4gICAgY29uc3QgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImluZm9cIilbMF07XG4gICAgY29uc3QgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29tbW9uXCIpWzBdO1xuICAgIGNvbnN0IGRpc3RhbmNlRmllbGQgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXN0YW5jZUZpZWxkXCIpWzBdO1xuICAgIGlmIChkaXN0YW5jZUZpZWxkKSB7XG4gICAgICBkYXRhLmRpc3RhbmNlRmllbGQgPSB7XG4gICAgICAgIHR5cGU6IGRpc3RhbmNlRmllbGQuZ2V0QXR0cmlidXRlKFwiZmllbGRUeXBlXCIpLFxuICAgICAgICByYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZC5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhZ2UgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpO1xuICAgIGNvbnN0IGNoYXIgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjaGFyXCIpO1xuICAgIGNvbnN0IGtlcm5pbmcgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJrZXJuaW5nXCIpO1xuICAgIGRhdGEuZm9udFNpemUgPSBwYXJzZUludChpbmZvLmdldEF0dHJpYnV0ZShcInNpemVcIiksIDEwKTtcbiAgICBkYXRhLmZvbnRGYW1pbHkgPSBpbmZvLmdldEF0dHJpYnV0ZShcImZhY2VcIik7XG4gICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZShcImxpbmVIZWlnaHRcIiksIDEwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEucGFnZXMucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChwYWdlW2ldLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgZmlsZTogcGFnZVtpXS5nZXRBdHRyaWJ1dGUoXCJmaWxlXCIpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgZGF0YS5iYXNlTGluZU9mZnNldCA9IGRhdGEubGluZUhlaWdodCAtIHBhcnNlSW50KGNvbW1vbi5nZXRBdHRyaWJ1dGUoXCJiYXNlXCIpLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyTm9kZSA9IGNoYXJbaV07XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCk7XG4gICAgICBsZXQgbGV0dGVyID0gY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwibGV0dGVyXCIpID8/IGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImNoYXJcIikgPz8gU3RyaW5nLmZyb21DaGFyQ29kZShpZCk7XG4gICAgICBpZiAobGV0dGVyID09PSBcInNwYWNlXCIpXG4gICAgICAgIGxldHRlciA9IFwiIFwiO1xuICAgICAgbWFwW2lkXSA9IGxldHRlcjtcbiAgICAgIGRhdGEuY2hhcnNbbGV0dGVyXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRleHR1cmUgZGVldHMuLlxuICAgICAgICBwYWdlOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJwYWdlXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgeDogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ5XCIpLCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICAvLyByZW5kZXIgZGVldHMuLlxuICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ4b2Zmc2V0XCIpLCAxMCksXG4gICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInlvZmZzZXRcIiksIDEwKSxcbiAgICAgICAgLy8gKyBiYXNlTGluZU9mZnNldCxcbiAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMCksXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJmaXJzdFwiKSwgMTApO1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJzZWNvbmRcIiksIDEwKTtcbiAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMCk7XG4gICAgICBkYXRhLmNoYXJzW21hcFtzZWNvbmRdXS5rZXJuaW5nW21hcFtmaXJzdF1dID0gYW1vdW50O1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFhNTFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFhNTFBhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFhNTFBhcnNlciB9IGZyb20gJy4vYml0bWFwRm9udFhNTFBhcnNlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIgPSB7XG4gIHRlc3QoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpKSB7XG4gICAgICByZXR1cm4gYml0bWFwRm9udFhNTFBhcnNlci50ZXN0KERPTUFkYXB0ZXIuZ2V0KCkucGFyc2VYTUwoZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gYml0bWFwRm9udFhNTFBhcnNlci5wYXJzZShET01BZGFwdGVyLmdldCgpLnBhcnNlWE1MKGRhdGEpKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzJztcbmltcG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvdXRpbHMvY29weVNlYXJjaFBhcmFtcy5tanMnO1xuaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICcuLi8uLi8uLi91dGlscy9wYXRoLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250IH0gZnJvbSAnLi4vQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfSBmcm9tICcuL2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsaWRFeHRlbnNpb25zID0gW1wiLnhtbFwiLCBcIi5mbnRcIl07XG5jb25zdCBiaXRtYXBGb250Q2FjaGVQbHVnaW4gPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5DYWNoZVBhcnNlcixcbiAgdGVzdDogKGFzc2V0KSA9PiBhc3NldCBpbnN0YW5jZW9mIEJpdG1hcEZvbnQsXG4gIGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCkge1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBvdXRba2V5XSA9IGFzc2V0O1xuICAgIH0pO1xuICAgIG91dFtgJHthc3NldC5mb250RmFtaWx5fS1iaXRtYXBgXSA9IGFzc2V0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5jb25zdCBsb2FkQml0bWFwRm9udCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gdmFsaWRFeHRlbnNpb25zLmluY2x1ZGVzKHBhdGguZXh0bmFtZSh1cmwpLnRvTG93ZXJDYXNlKCkpO1xuICB9LFxuICBhc3luYyB0ZXN0UGFyc2UoZGF0YSkge1xuICAgIHJldHVybiBiaXRtYXBGb250VGV4dFBhcnNlci50ZXN0KGRhdGEpIHx8IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIudGVzdChkYXRhKTtcbiAgfSxcbiAgYXN5bmMgcGFyc2UoYXNzZXQsIGRhdGEsIGxvYWRlcikge1xuICAgIGNvbnN0IGJpdG1hcEZvbnREYXRhID0gYml0bWFwRm9udFRleHRQYXJzZXIudGVzdChhc3NldCkgPyBiaXRtYXBGb250VGV4dFBhcnNlci5wYXJzZShhc3NldCkgOiBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLnBhcnNlKGFzc2V0KTtcbiAgICBjb25zdCB7IHNyYyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IHBhZ2VzIH0gPSBiaXRtYXBGb250RGF0YTtcbiAgICBjb25zdCB0ZXh0dXJlVXJscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHBhZ2VGaWxlID0gcGFnZXNbaV0uZmlsZTtcbiAgICAgIGxldCBpbWFnZVBhdGggPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKHNyYyksIHBhZ2VGaWxlKTtcbiAgICAgIGltYWdlUGF0aCA9IGNvcHlTZWFyY2hQYXJhbXMoaW1hZ2VQYXRoLCBzcmMpO1xuICAgICAgdGV4dHVyZVVybHMucHVzaChpbWFnZVBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRUZXh0dXJlcyA9IGF3YWl0IGxvYWRlci5sb2FkKHRleHR1cmVVcmxzKTtcbiAgICBjb25zdCB0ZXh0dXJlcyA9IHRleHR1cmVVcmxzLm1hcCgodXJsKSA9PiBsb2FkZWRUZXh0dXJlc1t1cmxdKTtcbiAgICBjb25zdCBiaXRtYXBGb250ID0gbmV3IEJpdG1hcEZvbnQoe1xuICAgICAgZGF0YTogYml0bWFwRm9udERhdGEsXG4gICAgICB0ZXh0dXJlc1xuICAgIH0sIHNyYyk7XG4gICAgcmV0dXJuIGJpdG1hcEZvbnQ7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIH0sXG4gIHVubG9hZChiaXRtYXBGb250KSB7XG4gICAgYml0bWFwRm9udC5kZXN0cm95KCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJpdG1hcEZvbnRDYWNoZVBsdWdpbiwgbG9hZEJpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbG9jYWxVbmlmb3JtTVNERkJpdCA9IHtcbiAgbmFtZTogXCJsb2NhbC11bmlmb3JtLW1zZGYtYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IExvY2FsVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1RGlzdGFuY2U6IGYzMixcbiAgICAgICAgICAgICAgICB1Um91bmQ6ZjMyLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGxvY2FsVW5pZm9ybXMgOiBMb2NhbFVuaWZvcm1zO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICB2Q29sb3IgKj0gbG9jYWxVbmlmb3Jtcy51Q29sb3I7XG4gICAgICAgICAgICBtb2RlbE1hdHJpeCAqPSBsb2NhbFVuaWZvcm1zLnVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGBcbiAgICApLFxuICAgIGVuZDogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgaWYobG9jYWxVbmlmb3Jtcy51Um91bmQgPT0gMSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2UG9zaXRpb24gPSB2ZWM0KHJvdW5kUGl4ZWxzKHZQb3NpdGlvbi54eSwgZ2xvYmFsVW5pZm9ybXMudVJlc29sdXRpb24pLCB2UG9zaXRpb24uencpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IExvY2FsVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1RGlzdGFuY2U6IGYzMlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGxvY2FsVW5pZm9ybXMgOiBMb2NhbFVuaWZvcm1zO1xuICAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYCBcbiAgICAgICAgICAgIG91dENvbG9yID0gdkNvbG9yICogY2FsY3VsYXRlTVNERkFscGhhKG91dENvbG9yLCBsb2NhbFVuaWZvcm1zLnVEaXN0YW5jZSk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgPSB7XG4gIG5hbWU6IFwibG9jYWwtdW5pZm9ybS1tc2RmLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVJvdW5kO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB2Q29sb3IgKj0gdUNvbG9yO1xuICAgICAgICAgICAgbW9kZWxNYXRyaXggKj0gdVRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgYFxuICAgICksXG4gICAgZW5kOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICBpZih1Um91bmQgPT0gMS4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24ueHkgPSByb3VuZFBpeGVscyhnbF9Qb3NpdGlvbi54eSwgdVJlc29sdXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1RGlzdGFuY2U7XG4gICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgIFxuICAgICAgICAgICAgb3V0Q29sb3IgPSB2Q29sb3IgKiBjYWxjdWxhdGVNU0RGQWxwaGEob3V0Q29sb3IsIHVEaXN0YW5jZSk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5cbmV4cG9ydCB7IGxvY2FsVW5pZm9ybU1TREZCaXQsIGxvY2FsVW5pZm9ybU1TREZCaXRHbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxVbmlmb3JtTVNERkJpdC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1TREZCaXQgPSB7XG4gIG5hbWU6IFwibXNkZi1iaXRcIixcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIGZuIGNhbGN1bGF0ZU1TREZBbHBoYShtc2RmQ29sb3I6dmVjNDxmMzI+LCBkaXN0YW5jZTpmMzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTVNERlxuICAgICAgICAgICAgICAgIHZhciBtZWRpYW4gPSBtc2RmQ29sb3IuciArIG1zZGZDb2xvci5nICsgbXNkZkNvbG9yLmIgLVxuICAgICAgICAgICAgICAgICAgICBtaW4obXNkZkNvbG9yLnIsIG1pbihtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKSAtXG4gICAgICAgICAgICAgICAgICAgIG1heChtc2RmQ29sb3IuciwgbWF4KG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU0RGXG4gICAgICAgICAgICAgICAgbWVkaWFuID0gbWluKG1lZGlhbiwgbXNkZkNvbG9yLmEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjcmVlblB4RGlzdGFuY2UgPSBkaXN0YW5jZSAqIChtZWRpYW4gLSAwLjUpO1xuICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFuIDwgMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDAuMDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lZGlhbiA+IDAuOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuY29uc3QgbVNERkJpdEdsID0ge1xuICBuYW1lOiBcIm1zZGYtYml0XCIsXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICBmbG9hdCBjYWxjdWxhdGVNU0RGQWxwaGEodmVjNCBtc2RmQ29sb3IsIGZsb2F0IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTVNERlxuICAgICAgICAgICAgICAgIGZsb2F0IG1lZGlhbiA9IG1zZGZDb2xvci5yICsgbXNkZkNvbG9yLmcgKyBtc2RmQ29sb3IuYiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbihtc2RmQ29sb3IuciwgbWluKG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4KG1zZGZDb2xvci5yLCBtYXgobXNkZkNvbG9yLmcsIG1zZGZDb2xvci5iKSk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTREZcbiAgICAgICAgICAgICAgICBtZWRpYW4gPSBtaW4obWVkaWFuLCBtc2RmQ29sb3IuYSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmbG9hdCBzY3JlZW5QeERpc3RhbmNlID0gZGlzdGFuY2UgKiAobWVkaWFuIC0gMC41KTtcbiAgICAgICAgICAgICAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhbiA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAwLjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgbVNERkJpdCwgbVNERkJpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tU0RGQml0Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IE1BWF9URVhUVVJFUyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL3NoYXJlZC9jb25zdC5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtLCBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlSGlnaFNoYWRlclRvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgY29sb3JCaXQsIGNvbG9yQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0LCBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2dlbmVyYXRlVGV4dHVyZUJhdGNoQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdCwgcm91bmRQaXhlbHNCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuaW1wb3J0IHsgYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL2JhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IGxvY2FsVW5pZm9ybU1TREZCaXQsIGxvY2FsVW5pZm9ybU1TREZCaXRHbCB9IGZyb20gJy4vc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtTVNERkJpdC5tanMnO1xuaW1wb3J0IHsgbVNERkJpdCwgbVNERkJpdEdsIH0gZnJvbSAnLi9zaGFkZXItYml0cy9tU0RGQml0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgU2RmU2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1VHJhbnNmb3JtTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgdURpc3RhbmNlOiB7IHZhbHVlOiA0LCB0eXBlOiBcImYzMlwiIH0sXG4gICAgICB1Um91bmQ6IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdwdVByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdwdVByb2dyYW0oe1xuICAgICAgbmFtZTogXCJzZGYtc2hhZGVyXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGNvbG9yQml0LFxuICAgICAgICBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdChNQVhfVEVYVFVSRVMpLFxuICAgICAgICBsb2NhbFVuaWZvcm1NU0RGQml0LFxuICAgICAgICBtU0RGQml0LFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdEdsLFxuICAgICAgICBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsKE1BWF9URVhUVVJFUyksXG4gICAgICAgIGxvY2FsVW5pZm9ybU1TREZCaXRHbCxcbiAgICAgICAgbVNERkJpdEdsLFxuICAgICAgICByb3VuZFBpeGVsc0JpdEdsXG4gICAgICBdXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBsb2NhbFVuaWZvcm1zOiB1bmlmb3JtcyxcbiAgICAgICAgYmF0Y2hTYW1wbGVyczogYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cFxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFNkZlNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2RmU2hhZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSAnLi4vZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzLm1qcyc7XG5pbXBvcnQgeyBTZGZTaGFkZXIgfSBmcm9tICcuLi90ZXh0L3NkZlNoYWRlci9TZGZTaGFkZXIubWpzJztcbmltcG9ydCB7IEJpdG1hcEZvbnRNYW5hZ2VyIH0gZnJvbSAnLi9CaXRtYXBGb250TWFuYWdlci5tanMnO1xuaW1wb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpdG1hcFRleHRQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVCaXRtYXBUZXh0ID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGdyYXBoaWNzUmVuZGVyYWJsZSA9IHRoaXMuX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCk7XG4gICAgaWYgKGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRleHQoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmdyYXBoaWNzLnZhbGlkYXRlUmVuZGVyYWJsZShncmFwaGljc1JlbmRlcmFibGUpO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoYml0bWFwVGV4dCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncmFwaGljc1JlbmRlcmFibGUgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpO1xuICAgIHN5bmNXaXRoUHJveHkoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICBpZiAoYml0bWFwVGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgYml0bWFwVGV4dC5fZGlkVGV4dFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5ncmFwaGljcy5hZGRSZW5kZXJhYmxlKGdyYXBoaWNzUmVuZGVyYWJsZSwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGlmIChncmFwaGljc1JlbmRlcmFibGUuY29udGV4dC5jdXN0b21TaGFkZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGJpdG1hcFRleHQpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5VWlkKGJpdG1hcFRleHQudWlkKTtcbiAgfVxuICBfZGVzdHJveVJlbmRlcmFibGVCeVVpZChyZW5kZXJhYmxlVWlkKSB7XG4gICAgQmlnUG9vbC5yZXR1cm4odGhpcy5fZ3B1Qml0bWFwVGV4dFtyZW5kZXJhYmxlVWlkXSk7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dFtyZW5kZXJhYmxlVWlkXSA9IG51bGw7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShiaXRtYXBUZXh0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NSZW5kZXJhYmxlID0gdGhpcy5fZ2V0R3B1Qml0bWFwVGV4dChiaXRtYXBUZXh0KTtcbiAgICBzeW5jV2l0aFByb3h5KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuZ3JhcGhpY3MudXBkYXRlUmVuZGVyYWJsZShncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIGlmIChncmFwaGljc1JlbmRlcmFibGUuY29udGV4dC5jdXN0b21TaGFkZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVDb250ZXh0KGJpdG1hcFRleHQsIHByb3h5R3JhcGhpY3MpIHtcbiAgICBjb25zdCB7IGNvbnRleHQgfSA9IHByb3h5R3JhcGhpY3M7XG4gICAgY29uc3QgYml0bWFwRm9udCA9IEJpdG1hcEZvbnRNYW5hZ2VyLmdldEZvbnQoYml0bWFwVGV4dC50ZXh0LCBiaXRtYXBUZXh0Ll9zdHlsZSk7XG4gICAgY29udGV4dC5jbGVhcigpO1xuICAgIGlmIChiaXRtYXBGb250LmRpc3RhbmNlRmllbGQudHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIGlmICghY29udGV4dC5jdXN0b21TaGFkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZGZTaGFkZXIpIHtcbiAgICAgICAgICB0aGlzLl9zZGZTaGFkZXIgPSBuZXcgU2RmU2hhZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXN0b21TaGFkZXIgPSB0aGlzLl9zZGZTaGFkZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gQXJyYXkuZnJvbShiaXRtYXBUZXh0LnRleHQpO1xuICAgIGNvbnN0IHN0eWxlID0gYml0bWFwVGV4dC5fc3R5bGU7XG4gICAgbGV0IGN1cnJlbnRZID0gKHN0eWxlLl9zdHJva2U/LndpZHRoIHx8IDApIC8gMjtcbiAgICBjdXJyZW50WSArPSBiaXRtYXBGb250LmJhc2VMaW5lT2Zmc2V0O1xuICAgIGNvbnN0IGJpdG1hcFRleHRMYXlvdXQgPSBnZXRCaXRtYXBUZXh0TGF5b3V0KGNoYXJzLCBzdHlsZSwgYml0bWFwRm9udCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBwYWRkaW5nID0gc3R5bGUucGFkZGluZztcbiAgICBjb25zdCBzY2FsZSA9IGJpdG1hcFRleHRMYXlvdXQuc2NhbGU7XG4gICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAtYml0bWFwVGV4dC5fYW5jaG9yLl94ICogYml0bWFwVGV4dExheW91dC53aWR0aCAtIHBhZGRpbmcsXG4gICAgICAtYml0bWFwVGV4dC5fYW5jaG9yLl95ICogKGJpdG1hcFRleHRMYXlvdXQuaGVpZ2h0ICsgYml0bWFwVGV4dExheW91dC5vZmZzZXRZKSAtIHBhZGRpbmdcbiAgICApLnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgY29uc3QgdGludCA9IHN0eWxlLl9maWxsLmNvbG9yO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0bWFwVGV4dExheW91dC5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGJpdG1hcFRleHRMYXlvdXQubGluZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBjaGFyID0gY2hhcnNbaW5kZXgrK107XG4gICAgICAgIGNvbnN0IGNoYXJEYXRhID0gYml0bWFwRm9udC5jaGFyc1tjaGFyXTtcbiAgICAgICAgaWYgKGNoYXJEYXRhPy50ZXh0dXJlKSB7XG4gICAgICAgICAgY29udGV4dC50ZXh0dXJlKFxuICAgICAgICAgICAgY2hhckRhdGEudGV4dHVyZSxcbiAgICAgICAgICAgIHRpbnQgPyB0aW50IDogXCJibGFja1wiLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChsaW5lLmNoYXJQb3NpdGlvbnNbal0gKyBjaGFyRGF0YS54T2Zmc2V0KSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoY3VycmVudFkgKyBjaGFyRGF0YS55T2Zmc2V0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRZICs9IGJpdG1hcEZvbnQubGluZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9ncHVCaXRtYXBUZXh0W2JpdG1hcFRleHQudWlkXSB8fCB0aGlzLmluaXRHcHVUZXh0KGJpdG1hcFRleHQpO1xuICB9XG4gIGluaXRHcHVUZXh0KGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBwcm94eVJlbmRlcmFibGUgPSBCaWdQb29sLmdldChHcmFwaGljcyk7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF0gPSBwcm94eVJlbmRlcmFibGU7XG4gICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBwcm94eVJlbmRlcmFibGUpO1xuICAgIGJpdG1hcFRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShiaXRtYXBUZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF07XG4gIH1cbiAgX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpLmNvbnRleHQ7XG4gICAgY29uc3QgZm9udEZhbWlseSA9IGJpdG1hcFRleHQuX3N0eWxlLmZvbnRGYW1pbHk7XG4gICAgY29uc3QgZHluYW1pY0ZvbnQgPSBDYWNoZS5nZXQoYCR7Zm9udEZhbWlseX0tYml0bWFwYCk7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBiaXRtYXBUZXh0Lmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IGR4ID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKSAvIDI7XG4gICAgY29uc3QgZm9udFNjYWxlID0gZHluYW1pY0ZvbnQuYmFzZVJlbmRlcmVkRm9udFNpemUgLyBiaXRtYXBUZXh0Ll9zdHlsZS5mb250U2l6ZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gYml0bWFwVGV4dC5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgY29uc3QgZGlzdGFuY2UgPSB3b3JsZFNjYWxlICogZHluYW1pY0ZvbnQuZGlzdGFuY2VGaWVsZC5yYW5nZSAqICgxIC8gZm9udFNjYWxlKSAqIHJlc29sdXRpb247XG4gICAgY29udGV4dC5jdXN0b21TaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXMudURpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IHVpZCBpbiB0aGlzLl9ncHVCaXRtYXBUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5VWlkKHVpZCk7XG4gICAgfVxuICAgIHRoaXMuX2dwdUJpdG1hcFRleHQgPSBudWxsO1xuICAgIHRoaXMuX3NkZlNoYWRlcj8uZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLl9zZGZTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkJpdG1hcFRleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJiaXRtYXBUZXh0XCJcbn07XG5mdW5jdGlvbiBzeW5jV2l0aFByb3h5KGNvbnRhaW5lciwgcHJveHkpIHtcbiAgcHJveHkuZ3JvdXBUcmFuc2Zvcm0gPSBjb250YWluZXIuZ3JvdXBUcmFuc2Zvcm07XG4gIHByb3h5Lmdyb3VwQ29sb3JBbHBoYSA9IGNvbnRhaW5lci5ncm91cENvbG9yQWxwaGE7XG4gIHByb3h5Lmdyb3VwQ29sb3IgPSBjb250YWluZXIuZ3JvdXBDb2xvcjtcbiAgcHJveHkuZ3JvdXBCbGVuZE1vZGUgPSBjb250YWluZXIuZ3JvdXBCbGVuZE1vZGU7XG4gIHByb3h5Lmdsb2JhbERpc3BsYXlTdGF0dXMgPSBjb250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cztcbiAgcHJveHkuZ3JvdXBUcmFuc2Zvcm0gPSBjb250YWluZXIuZ3JvdXBUcmFuc2Zvcm07XG4gIHByb3h5LmxvY2FsRGlzcGxheVN0YXR1cyA9IGNvbnRhaW5lci5sb2NhbERpc3BsYXlTdGF0dXM7XG4gIHByb3h5Lmdyb3VwQWxwaGEgPSBjb250YWluZXIuZ3JvdXBBbHBoYTtcbiAgcHJveHkuX3JvdW5kUGl4ZWxzID0gY29udGFpbmVyLl9yb3VuZFBpeGVscztcbn1cblxuZXhwb3J0IHsgQml0bWFwVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcFRleHRQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGxvYWRCaXRtYXBGb250LCBiaXRtYXBGb250Q2FjaGVQbHVnaW4gfSBmcm9tICcuL2Fzc2V0L2xvYWRCaXRtYXBGb250Lm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vQml0bWFwVGV4dFBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChCaXRtYXBUZXh0UGlwZSwgbG9hZEJpdG1hcEZvbnQsIGJpdG1hcEZvbnRDYWNoZVBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6678\n')},1709:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText._onUpdate();\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture/* Texture */.x.EMPTY,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture/* Texture */.x.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on("destroyed", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "htmlText"\n};\n\n\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isSafari.mjs\n\n\n"use strict";\nfunction isSafari() {\n  const { userAgent } = adapter/* DOMAdapter */.z.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n\n//# sourceMappingURL=isSafari.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs\n\nconst nssvg = "http://www.w3.org/2000/svg";\nconst nsxhtml = "http://www.w3.org/1999/xhtml";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, "svg");\n    this.foreignObject = document.createElementNS(nssvg, "foreignObject");\n    this.domElement = document.createElementNS(nsxhtml, "div");\n    this.styleElement = document.createElementNS(nsxhtml, "style");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\n\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs\nvar generateTextStyleKey = __webpack_require__(740);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs\n\n\n"use strict";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color/* Color */.I.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(";");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(" ");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color/* Color */.I.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color/* Color */.I.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color/* Color */.I.shared.setValue(stroke.color).toHex()}`,\n    "paint-order: stroke"\n  ].join(";");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color/* Color */.I.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace("{{VALUE}}", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(";")} }`);\n  }\n}\n\n\n//# sourceMappingURL=textStyleToCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs\n\n\n\n\n\n"use strict";\nclass HTMLTextStyle extends TextStyle/* TextStyle */.p {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /** List of style overrides that will be applied to the HTML text. */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  _generateKey() {\n    this._styleKey = (0,generateTextStyleKey/* generateTextStyleKey */.L)(this) + this._cssOverrides.join("-");\n    return this._styleKey;\n  }\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides\n    });\n  }\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride(\'background-color: red\');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride(\'background-color: red\');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  set fill(value) {\n    if (typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.Z)("[HTMLTextStyle] only color fill is not supported by HTMLText");\n    }\n    super.fill = value;\n  }\n  set stroke(value) {\n    if (value && typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.Z)("[HTMLTextStyle] only color stroke is not supported by HTMLText");\n    }\n    super.stroke = value;\n  }\n}\n\n\n//# sourceMappingURL=HtmlTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs\n\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(":")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\n\n//# sourceMappingURL=extractFontFamilies.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs\n\n\n"use strict";\nasync function loadFontAsBase64(url) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\n\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs\n\n\n"use strict";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: "${style.fontFamily}";\n        src: url(\'${dataSrc}\');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n\n//# sourceMappingURL=loadFontCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs\n\n\n\n"use strict";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache/* Cache */.C.has(fontFamily)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache/* Cache */.C.get(fontFamily);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join("\\n");\n}\n\n\n//# sourceMappingURL=getFontCss.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs\n\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute("width", width.toString());\n  svgRoot.setAttribute("height", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\n\n//# sourceMappingURL=getSVGUrl.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs\n\n\n"use strict";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\n\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs\n\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = "anonymous";\n  });\n}\n\n\n//# sourceMappingURL=loadSVGImage.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs\n\n\n\n"use strict";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\n\n//# sourceMappingURL=measureHtmlText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === types/* RendererType */.g.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = PoolGroup/* BigPool */.u.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    PoolGroup/* BigPool */.u.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          (0,warn/* warn */.Z)("HTMLTextSystem: Failed to clean texture");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = "unknown";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "htmlText"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: "Arial",\n  fontStyle: "normal",\n  fontWeight: "normal"\n};\n\n\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(HTMLTextSystem);\nExtensions/* extensions */.Rw.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxvQkFBSTtBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4QkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQzNINkQ7QUFDWDtBQUNJOztBQUV0RDtBQUNBLDZCQUFVLEtBQUssY0FBYztBQUM3Qiw2QkFBVSxLQUFLLFlBQVk7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSFRNTFRleHRQaXBlLm1qcz80ODJlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2Jyb3dzZXIvaXNTYWZhcmkubWpzP2U2ZDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0UmVuZGVyRGF0YS5tanM/N2EwMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvdGV4dFN0eWxlVG9DU1MubWpzP2M0YjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0h0bWxUZXh0U3R5bGUubWpzPzI1MWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2V4dHJhY3RGb250RmFtaWxpZXMubWpzPzE4NDkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250QXNCYXNlNjQubWpzPzE1YjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250Q1NTLm1qcz82NDY2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRGb250Q3NzLm1qcz8xYWE5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRTVkdVcmwubWpzPzdhOWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2dldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZS5tanM/MWQ5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbG9hZFNWR0ltYWdlLm1qcz83NGFmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9tZWFzdXJlSHRtbFRleHQubWpzP2NkNjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0U3lzdGVtLm1qcz83MTM3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC9pbml0Lm1qcz8zZjIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHVwZGF0ZVF1YWRCb3VuZHMgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi4vc3ByaXRlL0JhdGNoYWJsZVNwcml0ZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1VGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGh0bWxUZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQoaHRtbFRleHQpO1xuICAgIGNvbnN0IG5ld0tleSA9IGh0bWxUZXh0Ll9nZXRLZXkoKTtcbiAgICBpZiAoZ3B1VGV4dC50ZXh0dXJlTmVlZHNVcGxvYWRpbmcpIHtcbiAgICAgIGdwdVRleHQudGV4dHVyZU5lZWRzVXBsb2FkaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KGh0bWxUZXh0KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KGh0bWxUZXh0KTtcbiAgICB9XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGh0bWxUZXh0KSB7XG4gICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeUlkKGh0bWxUZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChodG1sVGV4dFVpZCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9ncHVUZXh0W2h0bWxUZXh0VWlkXTtcbiAgICB0aGlzLl9yZW5kZXJlci5odG1sVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgQmlnUG9vbC5yZXR1cm4oZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGUpO1xuICAgIHRoaXMuX2dwdVRleHRbaHRtbFRleHRVaWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlVGV4dChodG1sVGV4dCkge1xuICAgIGNvbnN0IG5ld0tleSA9IGh0bWxUZXh0Ll9nZXRLZXkoKTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICB0aGlzLl91cGRhdGVHcHVUZXh0KGh0bWxUZXh0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgY29uc3QgcGFkZGluZyA9IGh0bWxUZXh0Ll9zdHlsZS5wYWRkaW5nO1xuICAgIHVwZGF0ZVF1YWRCb3VuZHMoYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcywgaHRtbFRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIGFzeW5jIF91cGRhdGVHcHVUZXh0KGh0bWxUZXh0KSB7XG4gICAgaHRtbFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgaWYgKGdwdVRleHQuZ2VuZXJhdGluZ1RleHR1cmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmh0bWxUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICBncHVUZXh0LmdlbmVyYXRpbmdUZXh0dXJlID0gdHJ1ZTtcbiAgICBncHVUZXh0LmN1cnJlbnRLZXkgPSBuZXdLZXk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IGh0bWxUZXh0LnJlc29sdXRpb24gPz8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICBjb25zdCB0ZXh0dXJlID0gYXdhaXQgdGhpcy5fcmVuZGVyZXIuaHRtbFRleHQuZ2V0TWFuYWdlZFRleHR1cmUoXG4gICAgICBodG1sVGV4dC50ZXh0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGh0bWxUZXh0Ll9zdHlsZSxcbiAgICAgIGh0bWxUZXh0Ll9nZXRLZXkoKVxuICAgICk7XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGU7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBncHVUZXh0LnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIGdwdVRleHQuZ2VuZXJhdGluZ1RleHR1cmUgPSBmYWxzZTtcbiAgICBncHVUZXh0LnRleHR1cmVOZWVkc1VwbG9hZGluZyA9IHRydWU7XG4gICAgaHRtbFRleHQuX29uVXBkYXRlKCk7XG4gICAgY29uc3QgcGFkZGluZyA9IGh0bWxUZXh0Ll9zdHlsZS5wYWRkaW5nO1xuICAgIHVwZGF0ZVF1YWRCb3VuZHMoYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcywgaHRtbFRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIF9nZXRHcHVUZXh0KGh0bWxUZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVRleHRbaHRtbFRleHQudWlkXSB8fCB0aGlzLmluaXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgfVxuICBpbml0R3B1VGV4dChodG1sVGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHREYXRhID0ge1xuICAgICAgdGV4dHVyZTogVGV4dHVyZS5FTVBUWSxcbiAgICAgIGN1cnJlbnRLZXk6IFwiLS1cIixcbiAgICAgIGJhdGNoYWJsZVNwcml0ZTogQmlnUG9vbC5nZXQoQmF0Y2hhYmxlU3ByaXRlKSxcbiAgICAgIHRleHR1cmVOZWVkc1VwbG9hZGluZzogZmFsc2UsXG4gICAgICBnZW5lcmF0aW5nVGV4dHVyZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZTtcbiAgICBiYXRjaGFibGVTcHJpdGUucmVuZGVyYWJsZSA9IGh0bWxUZXh0O1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gVGV4dHVyZS5FTVBUWTtcbiAgICBiYXRjaGFibGVTcHJpdGUuYm91bmRzID0geyBtaW5YOiAwLCBtYXhYOiAxLCBtaW5ZOiAwLCBtYXhZOiAwIH07XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnJvdW5kUGl4ZWxzID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgaHRtbFRleHQuX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdVRleHRbaHRtbFRleHQudWlkXSA9IGdwdVRleHREYXRhO1xuICAgIGh0bWxUZXh0Lm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoaHRtbFRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBncHVUZXh0RGF0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVRleHQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkhUTUxUZXh0UGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiaHRtbFRleHRcIlxufTtcblxuZXhwb3J0IHsgSFRNTFRleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCk7XG4gIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG5cbmV4cG9ydCB7IGlzU2FmYXJpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1NhZmFyaS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG5zc3ZnID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgbnN4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuY2xhc3MgSFRNTFRleHRSZW5kZXJEYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdmdSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zc3ZnLCBcInN2Z1wiKTtcbiAgICB0aGlzLmZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnN4aHRtbCwgXCJkaXZcIik7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnN4aHRtbCwgXCJzdHlsZVwiKTtcbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3QgeyBmb3JlaWduT2JqZWN0LCBzdmdSb290LCBzdHlsZUVsZW1lbnQsIGRvbUVsZW1lbnQgfSA9IHRoaXM7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMDAwXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMTAwMDBcIik7XG4gICAgZm9yZWlnbk9iamVjdC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgc3ZnUm9vdC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgICBmb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChkb21FbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBIVE1MVGV4dFJlbmRlckRhdGEsIG5zc3ZnLCBuc3hodG1sIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFJlbmRlckRhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHRleHRTdHlsZVRvQ1NTKHN0eWxlKSB7XG4gIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gIGNvbnN0IGZpbGwgPSBzdHlsZS5fZmlsbDtcbiAgY29uc3QgY3NzU3R5bGVTdHJpbmcgPSBbXG4gICAgYGNvbG9yOiAke0NvbG9yLnNoYXJlZC5zZXRWYWx1ZShmaWxsLmNvbG9yKS50b0hleCgpfWAsXG4gICAgYGZvbnQtc2l6ZTogJHtzdHlsZS5mb250U2l6ZX1weGAsXG4gICAgYGZvbnQtZmFtaWx5OiAke3N0eWxlLmZvbnRGYW1pbHl9YCxcbiAgICBgZm9udC13ZWlnaHQ6ICR7c3R5bGUuZm9udFdlaWdodH1gLFxuICAgIGBmb250LXN0eWxlOiAke3N0eWxlLmZvbnRTdHlsZX1gLFxuICAgIGBmb250LXZhcmlhbnQ6ICR7c3R5bGUuZm9udFZhcmlhbnR9YCxcbiAgICBgbGV0dGVyLXNwYWNpbmc6ICR7c3R5bGUubGV0dGVyU3BhY2luZ31weGAsXG4gICAgYHRleHQtYWxpZ246ICR7c3R5bGUuYWxpZ259YCxcbiAgICBgcGFkZGluZzogJHtzdHlsZS5wYWRkaW5nfXB4YCxcbiAgICBgd2hpdGUtc3BhY2U6ICR7c3R5bGUud2hpdGVTcGFjZSA9PT0gXCJwcmVcIiAmJiBzdHlsZS53b3JkV3JhcCA/IFwicHJlLXdyYXBcIiA6IHN0eWxlLndoaXRlU3BhY2V9YCxcbiAgICAuLi5zdHlsZS5saW5lSGVpZ2h0ID8gW2BsaW5lLWhlaWdodDogJHtzdHlsZS5saW5lSGVpZ2h0fXB4YF0gOiBbXSxcbiAgICAuLi5zdHlsZS53b3JkV3JhcCA/IFtcbiAgICAgIGB3b3JkLXdyYXA6ICR7c3R5bGUuYnJlYWtXb3JkcyA/IFwiYnJlYWstYWxsXCIgOiBcImJyZWFrLXdvcmRcIn1gLFxuICAgICAgYG1heC13aWR0aDogJHtzdHlsZS53b3JkV3JhcFdpZHRofXB4YFxuICAgIF0gOiBbXSxcbiAgICAuLi5zdHJva2UgPyBbc3Ryb2tlVG9DU1Moc3Ryb2tlKV0gOiBbXSxcbiAgICAuLi5zdHlsZS5kcm9wU2hhZG93ID8gW2Ryb3BTaGFkb3dUb0NTUyhzdHlsZS5kcm9wU2hhZG93KV0gOiBbXSxcbiAgICAuLi5zdHlsZS5jc3NPdmVycmlkZXNcbiAgXS5qb2luKFwiO1wiKTtcbiAgY29uc3QgY3NzU3R5bGVzID0gW2BkaXYgeyAke2Nzc1N0eWxlU3RyaW5nfSB9YF07XG4gIHRhZ1N0eWxlVG9DU1Moc3R5bGUudGFnU3R5bGVzLCBjc3NTdHlsZXMpO1xuICByZXR1cm4gY3NzU3R5bGVzLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gZHJvcFNoYWRvd1RvQ1NTKGRyb3BTaGFkb3dTdHlsZSkge1xuICBjb25zdCBjb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShkcm9wU2hhZG93U3R5bGUuY29sb3IpLnNldEFscGhhKGRyb3BTaGFkb3dTdHlsZS5hbHBoYSkudG9IZXhhKCk7XG4gIGNvbnN0IHggPSBNYXRoLnJvdW5kKE1hdGguY29zKGRyb3BTaGFkb3dTdHlsZS5hbmdsZSkgKiBkcm9wU2hhZG93U3R5bGUuZGlzdGFuY2UpO1xuICBjb25zdCB5ID0gTWF0aC5yb3VuZChNYXRoLnNpbihkcm9wU2hhZG93U3R5bGUuYW5nbGUpICogZHJvcFNoYWRvd1N0eWxlLmRpc3RhbmNlKTtcbiAgY29uc3QgcG9zaXRpb24gPSBgJHt4fXB4ICR7eX1weGA7XG4gIGlmIChkcm9wU2hhZG93U3R5bGUuYmx1ciA+IDApIHtcbiAgICByZXR1cm4gYHRleHQtc2hhZG93OiAke3Bvc2l0aW9ufSAke2Ryb3BTaGFkb3dTdHlsZS5ibHVyfXB4ICR7Y29sb3J9YDtcbiAgfVxuICByZXR1cm4gYHRleHQtc2hhZG93OiAke3Bvc2l0aW9ufSAke2NvbG9yfWA7XG59XG5mdW5jdGlvbiBzdHJva2VUb0NTUyhzdHJva2UpIHtcbiAgcmV0dXJuIFtcbiAgICBgLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aDogJHtzdHJva2Uud2lkdGh9cHhgLFxuICAgIGAtd2Via2l0LXRleHQtc3Ryb2tlLWNvbG9yOiAke0NvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdHJva2UuY29sb3IpLnRvSGV4KCl9YCxcbiAgICBgdGV4dC1zdHJva2Utd2lkdGg6ICR7c3Ryb2tlLndpZHRofXB4YCxcbiAgICBgdGV4dC1zdHJva2UtY29sb3I6ICR7Q29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZS5jb2xvcikudG9IZXgoKX1gLFxuICAgIFwicGFpbnQtb3JkZXI6IHN0cm9rZVwiXG4gIF0uam9pbihcIjtcIik7XG59XG5jb25zdCB0ZW1wbGF0ZXMgPSB7XG4gIGZvbnRTaXplOiBgZm9udC1zaXplOiB7e1ZBTFVFfX1weGAsXG4gIGZvbnRGYW1pbHk6IGBmb250LWZhbWlseToge3tWQUxVRX19YCxcbiAgZm9udFdlaWdodDogYGZvbnQtd2VpZ2h0OiB7e1ZBTFVFfX1gLFxuICBmb250U3R5bGU6IGBmb250LXN0eWxlOiB7e1ZBTFVFfX1gLFxuICBmb250VmFyaWFudDogYGZvbnQtdmFyaWFudDoge3tWQUxVRX19YCxcbiAgbGV0dGVyU3BhY2luZzogYGxldHRlci1zcGFjaW5nOiB7e1ZBTFVFfX1weGAsXG4gIGFsaWduOiBgdGV4dC1hbGlnbjoge3tWQUxVRX19YCxcbiAgcGFkZGluZzogYHBhZGRpbmc6IHt7VkFMVUV9fXB4YCxcbiAgd2hpdGVTcGFjZTogYHdoaXRlLXNwYWNlOiB7e1ZBTFVFfX1gLFxuICBsaW5lSGVpZ2h0OiBgbGluZS1oZWlnaHQ6IHt7VkFMVUV9fXB4YCxcbiAgd29yZFdyYXBXaWR0aDogYG1heC13aWR0aDoge3tWQUxVRX19cHhgXG59O1xuY29uc3QgdHJhbnNmb3JtID0ge1xuICBmaWxsOiAodmFsdWUpID0+IGBjb2xvcjogJHtDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUpLnRvSGV4KCl9YCxcbiAgYnJlYWtXb3JkczogKHZhbHVlKSA9PiBgd29yZC13cmFwOiAke3ZhbHVlID8gXCJicmVhay1hbGxcIiA6IFwiYnJlYWstd29yZFwifWAsXG4gIHN0cm9rZTogc3Ryb2tlVG9DU1MsXG4gIGRyb3BTaGFkb3c6IGRyb3BTaGFkb3dUb0NTU1xufTtcbmZ1bmN0aW9uIHRhZ1N0eWxlVG9DU1ModGFnU3R5bGVzLCBvdXQpIHtcbiAgZm9yIChjb25zdCBpIGluIHRhZ1N0eWxlcykge1xuICAgIGNvbnN0IHRhZ1N0eWxlID0gdGFnU3R5bGVzW2ldO1xuICAgIGNvbnN0IGNzc1RhZ1N0eWxlID0gW107XG4gICAgZm9yIChjb25zdCBqIGluIHRhZ1N0eWxlKSB7XG4gICAgICBpZiAodHJhbnNmb3JtW2pdKSB7XG4gICAgICAgIGNzc1RhZ1N0eWxlLnB1c2godHJhbnNmb3JtW2pdKHRhZ1N0eWxlW2pdKSk7XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlc1tqXSkge1xuICAgICAgICBjc3NUYWdTdHlsZS5wdXNoKHRlbXBsYXRlc1tqXS5yZXBsYWNlKFwie3tWQUxVRX19XCIsIHRhZ1N0eWxlW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKGAke2l9IHsgJHtjc3NUYWdTdHlsZS5qb2luKFwiO1wiKX0gfWApO1xuICB9XG59XG5cbmV4cG9ydCB7IHRleHRTdHlsZVRvQ1NTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0U3R5bGVUb0NTUy5tanMubWFwXG4iLCJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuLi90ZXh0L1RleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVUZXh0U3R5bGVLZXkgfSBmcm9tICcuLi90ZXh0L3V0aWxzL2dlbmVyYXRlVGV4dFN0eWxlS2V5Lm1qcyc7XG5pbXBvcnQgeyB0ZXh0U3R5bGVUb0NTUyB9IGZyb20gJy4vdXRpbHMvdGV4dFN0eWxlVG9DU1MubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBIVE1MVGV4dFN0eWxlIGV4dGVuZHMgVGV4dFN0eWxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5fY3NzT3ZlcnJpZGVzID0gW107XG4gICAgdGhpcy5jc3NPdmVycmlkZXMgPz8gKHRoaXMuY3NzT3ZlcnJpZGVzID0gb3B0aW9ucy5jc3NPdmVycmlkZXMpO1xuICAgIHRoaXMudGFnU3R5bGVzID0gb3B0aW9ucy50YWdTdHlsZXMgPz8ge307XG4gIH1cbiAgLyoqIExpc3Qgb2Ygc3R5bGUgb3ZlcnJpZGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBIVE1MIHRleHQuICovXG4gIHNldCBjc3NPdmVycmlkZXModmFsdWUpIHtcbiAgICB0aGlzLl9jc3NPdmVycmlkZXMgPSB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgZ2V0IGNzc092ZXJyaWRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3NzT3ZlcnJpZGVzO1xuICB9XG4gIF9nZW5lcmF0ZUtleSgpIHtcbiAgICB0aGlzLl9zdHlsZUtleSA9IGdlbmVyYXRlVGV4dFN0eWxlS2V5KHRoaXMpICsgdGhpcy5fY3NzT3ZlcnJpZGVzLmpvaW4oXCItXCIpO1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUtleTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fY3NzU3R5bGUgPSBudWxsO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEhUTUxUZXh0U3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBAcmV0dXJucyBOZXcgY2xvbmVkIEhUTUxUZXh0U3R5bGUgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEhUTUxUZXh0U3R5bGUoe1xuICAgICAgYWxpZ246IHRoaXMuYWxpZ24sXG4gICAgICBicmVha1dvcmRzOiB0aGlzLmJyZWFrV29yZHMsXG4gICAgICBkcm9wU2hhZG93OiB0aGlzLmRyb3BTaGFkb3csXG4gICAgICBmaWxsOiB0aGlzLl9maWxsLFxuICAgICAgZm9udEZhbWlseTogdGhpcy5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IHRoaXMuZm9udFN0eWxlLFxuICAgICAgZm9udFZhcmlhbnQ6IHRoaXMuZm9udFZhcmlhbnQsXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcsXG4gICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmcsXG4gICAgICBzdHJva2U6IHRoaXMuX3N0cm9rZSxcbiAgICAgIHdoaXRlU3BhY2U6IHRoaXMud2hpdGVTcGFjZSxcbiAgICAgIHdvcmRXcmFwOiB0aGlzLndvcmRXcmFwLFxuICAgICAgd29yZFdyYXBXaWR0aDogdGhpcy53b3JkV3JhcFdpZHRoLFxuICAgICAgY3NzT3ZlcnJpZGVzOiB0aGlzLmNzc092ZXJyaWRlc1xuICAgIH0pO1xuICB9XG4gIGdldCBjc3NTdHlsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2Nzc1N0eWxlKSB7XG4gICAgICB0aGlzLl9jc3NTdHlsZSA9IHRleHRTdHlsZVRvQ1NTKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3NzU3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHN0eWxlIG92ZXJyaWRlLCB0aGlzIGNhbiBiZSBhbnkgQ1NTIHByb3BlcnR5XG4gICAqIGl0IHdpbGwgb3ZlcnJpZGUgYW55IGJ1aWx0LWluIHN0eWxlLiBUaGlzIGlzIHRoZVxuICAgKiBwcm9wZXJ0eSBhbmQgdGhlIHZhbHVlIGFzIGEgc3RyaW5nIChlLmcuLCBgY29sb3I6IHJlZGApLlxuICAgKiBUaGlzIHdpbGwgb3ZlcnJpZGUgYW55IG90aGVyIGludGVybmFsIHN0eWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBDU1Mgc3R5bGUocykgdG8gYWRkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZS5hZGRPdmVycmlkZSgnYmFja2dyb3VuZC1jb2xvcjogcmVkJyk7XG4gICAqL1xuICBhZGRPdmVycmlkZSguLi52YWx1ZSkge1xuICAgIGNvbnN0IHRvQWRkID0gdmFsdWUuZmlsdGVyKCh2KSA9PiAhdGhpcy5jc3NPdmVycmlkZXMuaW5jbHVkZXModikpO1xuICAgIGlmICh0b0FkZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNzc092ZXJyaWRlcy5wdXNoKC4uLnRvQWRkKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IG92ZXJyaWRlcyB0aGF0IG1hdGNoIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gQ1NTIHN0eWxlIHRvIHJlbW92ZS5cbiAgICogQGV4YW1wbGVcbiAgICogc3R5bGUucmVtb3ZlT3ZlcnJpZGUoJ2JhY2tncm91bmQtY29sb3I6IHJlZCcpO1xuICAgKi9cbiAgcmVtb3ZlT3ZlcnJpZGUoLi4udmFsdWUpIHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IHZhbHVlLmZpbHRlcigodikgPT4gdGhpcy5jc3NPdmVycmlkZXMuaW5jbHVkZXModikpO1xuICAgIGlmICh0b1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNzc092ZXJyaWRlcyA9IHRoaXMuY3NzT3ZlcnJpZGVzLmZpbHRlcigodikgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKHYpKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldCBmaWxsKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHdhcm4oXCJbSFRNTFRleHRTdHlsZV0gb25seSBjb2xvciBmaWxsIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gICAgfVxuICAgIHN1cGVyLmZpbGwgPSB2YWx1ZTtcbiAgfVxuICBzZXQgc3Ryb2tlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHdhcm4oXCJbSFRNTFRleHRTdHlsZV0gb25seSBjb2xvciBzdHJva2UgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgICB9XG4gICAgc3VwZXIuc3Ryb2tlID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgSFRNTFRleHRTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHRtbFRleHRTdHlsZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGV4dHJhY3RGb250RmFtaWxpZXModGV4dCwgc3R5bGUpIHtcbiAgY29uc3QgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHk7XG4gIGNvbnN0IGZvbnRGYW1pbGllcyA9IFtdO1xuICBjb25zdCBkZWR1cGUgPSB7fTtcbiAgY29uc3QgcmVnZXggPSAvZm9udC1mYW1pbHk6KFteO1wiXFxzXSspL2c7XG4gIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHJlZ2V4KTtcbiAgZnVuY3Rpb24gYWRkRm9udEZhbWlseShmb250RmFtaWx5Mikge1xuICAgIGlmICghZGVkdXBlW2ZvbnRGYW1pbHkyXSkge1xuICAgICAgZm9udEZhbWlsaWVzLnB1c2goZm9udEZhbWlseTIpO1xuICAgICAgZGVkdXBlW2ZvbnRGYW1pbHkyXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGZvbnRGYW1pbHkpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb250RmFtaWx5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHlbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkpO1xuICB9XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgY29uc3QgZm9udEZhbWlseTIgPSBtYXRjaC5zcGxpdChcIjpcIilbMV0udHJpbSgpO1xuICAgICAgYWRkRm9udEZhbWlseShmb250RmFtaWx5Mik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBpIGluIHN0eWxlLnRhZ1N0eWxlcykge1xuICAgIGNvbnN0IGZvbnRGYW1pbHkyID0gc3R5bGUudGFnU3R5bGVzW2ldLmZvbnRGYW1pbHk7XG4gICAgYWRkRm9udEZhbWlseShmb250RmFtaWx5Mik7XG4gIH1cbiAgcmV0dXJuIGZvbnRGYW1pbGllcztcbn1cblxuZXhwb3J0IHsgZXh0cmFjdEZvbnRGYW1pbGllcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEZvbnRGYW1pbGllcy5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRGb250QXNCYXNlNjQodXJsKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBjb25zdCBkYXRhU3JjID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICB9KTtcbiAgcmV0dXJuIGRhdGFTcmM7XG59XG5cbmV4cG9ydCB7IGxvYWRGb250QXNCYXNlNjQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRGb250QXNCYXNlNjQubWpzLm1hcFxuIiwiaW1wb3J0IHsgbG9hZEZvbnRBc0Jhc2U2NCB9IGZyb20gJy4vbG9hZEZvbnRBc0Jhc2U2NC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRGb250Q1NTKHN0eWxlLCB1cmwpIHtcbiAgY29uc3QgZGF0YVNyYyA9IGF3YWl0IGxvYWRGb250QXNCYXNlNjQodXJsKTtcbiAgcmV0dXJuIGBAZm9udC1mYWNlIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IFwiJHtzdHlsZS5mb250RmFtaWx5fVwiO1xuICAgICAgICBzcmM6IHVybCgnJHtkYXRhU3JjfScpO1xuICAgICAgICBmb250LXdlaWdodDogJHtzdHlsZS5mb250V2VpZ2h0fTtcbiAgICAgICAgZm9udC1zdHlsZTogJHtzdHlsZS5mb250U3R5bGV9O1xuICAgIH1gO1xufVxuXG5leHBvcnQgeyBsb2FkRm9udENTUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEZvbnRDU1MubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvY2FjaGUvQ2FjaGUubWpzJztcbmltcG9ydCB7IGxvYWRGb250Q1NTIH0gZnJvbSAnLi9sb2FkRm9udENTUy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IEZvbnRTdHlsZVByb21pc2VDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5hc3luYyBmdW5jdGlvbiBnZXRGb250Q3NzKGZvbnRGYW1pbGllcywgc3R5bGUsIGRlZmF1bHRPcHRpb25zKSB7XG4gIGNvbnN0IGZvbnRQcm9taXNlcyA9IGZvbnRGYW1pbGllcy5maWx0ZXIoKGZvbnRGYW1pbHkpID0+IENhY2hlLmhhcyhmb250RmFtaWx5KSkubWFwKChmb250RmFtaWx5LCBpKSA9PiB7XG4gICAgaWYgKCFGb250U3R5bGVQcm9taXNlQ2FjaGUuaGFzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBjb25zdCB7IHVybCB9ID0gQ2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgRm9udFN0eWxlUHJvbWlzZUNhY2hlLnNldChmb250RmFtaWx5LCBsb2FkRm9udENTUyhzdHlsZSwgdXJsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBGb250U3R5bGVQcm9taXNlQ2FjaGUuc2V0KGZvbnRGYW1pbHksIGxvYWRGb250Q1NTKHtcbiAgICAgICAgICBmb250V2VpZ2h0OiBkZWZhdWx0T3B0aW9ucy5mb250V2VpZ2h0LFxuICAgICAgICAgIGZvbnRTdHlsZTogZGVmYXVsdE9wdGlvbnMuZm9udFN0eWxlLFxuICAgICAgICAgIGZvbnRGYW1pbHlcbiAgICAgICAgfSwgdXJsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGb250U3R5bGVQcm9taXNlQ2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICB9KTtcbiAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChmb250UHJvbWlzZXMpKS5qb2luKFwiXFxuXCIpO1xufVxuXG5leHBvcnQgeyBGb250U3R5bGVQcm9taXNlQ2FjaGUsIGdldEZvbnRDc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEZvbnRDc3MubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRTVkdVcmwodGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIGZvbnRDU1MsIGh0bWxUZXh0RGF0YSkge1xuICBjb25zdCB7IGRvbUVsZW1lbnQsIHN0eWxlRWxlbWVudCwgc3ZnUm9vdCB9ID0gaHRtbFRleHREYXRhO1xuICBkb21FbGVtZW50LmlubmVySFRNTCA9IGA8c3R5bGU+JHtzdHlsZS5jc3NTdHlsZX08L3N0eWxlPjxkaXY+JHt0ZXh0fTwvZGl2PmA7XG4gIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHRyYW5zZm9ybTogc2NhbGUoJHtyZXNvbHV0aW9ufSk7dHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IGRpc3BsYXk6IGlubGluZS1ibG9ja2ApO1xuICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBmb250Q1NTO1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGh0bWxUZXh0RGF0YS5pbWFnZTtcbiAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aC50b1N0cmluZygpKTtcbiAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICByZXR1cm4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmdSb290KTtcbn1cblxuZXhwb3J0IHsgZ2V0U1ZHVXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTVkdVcmwubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ2FudmFzUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZShpbWFnZSwgcmVzb2x1dGlvbikge1xuICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dChcbiAgICBpbWFnZS53aWR0aCxcbiAgICBpbWFnZS5oZWlnaHQsXG4gICAgcmVzb2x1dGlvblxuICApO1xuICBjb25zdCB7IGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gIENhbnZhc1Bvb2wucmV0dXJuQ2FudmFzQW5kQ29udGV4dChjYW52YXNBbmRDb250ZXh0KTtcbiAgcmV0dXJuIGNhbnZhc0FuZENvbnRleHQuY2FudmFzO1xufVxuXG5leHBvcnQgeyBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGxvYWRTVkdJbWFnZShpbWFnZSwgdXJsLCBkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4gc2V0VGltZW91dChyZXNvbHZlMiwgMTAwKSk7XG4gICAgfVxuICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGltYWdlLnNyYyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGY4LCR7ZW5jb2RlVVJJQ29tcG9uZW50KHVybCl9YDtcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBsb2FkU1ZHSW1hZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRTVkdJbWFnZS5tanMubWFwXG4iLCJpbXBvcnQgeyBDYW52YXNUZXh0TWV0cmljcyB9IGZyb20gJy4uLy4uL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFJlbmRlckRhdGEgfSBmcm9tICcuLi9IVE1MVGV4dFJlbmRlckRhdGEubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgdGVtcEhUTUxUZXh0UmVuZGVyRGF0YTtcbmZ1bmN0aW9uIG1lYXN1cmVIdG1sVGV4dCh0ZXh0LCBzdHlsZSwgZm9udFN0eWxlQ1NTLCBodG1sVGV4dFJlbmRlckRhdGEpIHtcbiAgaHRtbFRleHRSZW5kZXJEYXRhID0gaHRtbFRleHRSZW5kZXJEYXRhIHx8IHRlbXBIVE1MVGV4dFJlbmRlckRhdGEgfHwgKHRlbXBIVE1MVGV4dFJlbmRlckRhdGEgPSBuZXcgSFRNTFRleHRSZW5kZXJEYXRhKCkpO1xuICBjb25zdCB7IGRvbUVsZW1lbnQsIHN0eWxlRWxlbWVudCwgc3ZnUm9vdCB9ID0gaHRtbFRleHRSZW5kZXJEYXRhO1xuICBkb21FbGVtZW50LmlubmVySFRNTCA9IGA8c3R5bGU+JHtzdHlsZS5jc3NTdHlsZX08L3N0eWxlPjxkaXY+JHt0ZXh0fTwvZGl2PmA7XG4gIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDsgZGlzcGxheTogaW5saW5lLWJsb2NrXCIpO1xuICBpZiAoZm9udFN0eWxlQ1NTKSB7XG4gICAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gZm9udFN0eWxlQ1NTO1xuICB9XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnUm9vdCk7XG4gIGNvbnN0IGNvbnRlbnRCb3VuZHMgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBzdmdSb290LnJlbW92ZSgpO1xuICBjb25zdCBkZXNjZW5kZXJQYWRkaW5nID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoc3R5bGUuZm9udFN0eWxlKS5kZXNjZW50O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjb250ZW50Qm91bmRzLndpZHRoLFxuICAgIGhlaWdodDogY29udGVudEJvdW5kcy5oZWlnaHQgKyBkZXNjZW5kZXJQYWRkaW5nXG4gIH07XG59XG5cbmV4cG9ydCB7IG1lYXN1cmVIdG1sVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVhc3VyZUh0bWxUZXh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRleHR1cmVQb29sIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlUG9vbC5tanMnO1xuaW1wb3J0IHsgUmVuZGVyZXJUeXBlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy90eXBlcy5tanMnO1xuaW1wb3J0IHsgaXNTYWZhcmkgfSBmcm9tICcuLi8uLi91dGlscy9icm93c2VyL2lzU2FmYXJpLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IGdldFBvMlRleHR1cmVGcm9tU291cmNlIH0gZnJvbSAnLi4vdGV4dC91dGlscy9nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRSZW5kZXJEYXRhIH0gZnJvbSAnLi9IVE1MVGV4dFJlbmRlckRhdGEubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0U3R5bGUgfSBmcm9tICcuL0h0bWxUZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IGV4dHJhY3RGb250RmFtaWxpZXMgfSBmcm9tICcuL3V0aWxzL2V4dHJhY3RGb250RmFtaWxpZXMubWpzJztcbmltcG9ydCB7IGdldEZvbnRDc3MgfSBmcm9tICcuL3V0aWxzL2dldEZvbnRDc3MubWpzJztcbmltcG9ydCB7IGdldFNWR1VybCB9IGZyb20gJy4vdXRpbHMvZ2V0U1ZHVXJsLm1qcyc7XG5pbXBvcnQgeyBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UgfSBmcm9tICcuL3V0aWxzL2dldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZS5tanMnO1xuaW1wb3J0IHsgbG9hZFNWR0ltYWdlIH0gZnJvbSAnLi91dGlscy9sb2FkU1ZHSW1hZ2UubWpzJztcbmltcG9ydCB7IG1lYXN1cmVIdG1sVGV4dCB9IGZyb20gJy4vdXRpbHMvbWVhc3VyZUh0bWxUZXh0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgSFRNTFRleHRTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9jcmVhdGVDYW52YXMgPSByZW5kZXJlci50eXBlID09PSBSZW5kZXJlclR5cGUuV0VCR1BVO1xuICB9XG4gIGdldFRleHR1cmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9idWlsZFRleHR1cmVQcm9taXNlKFxuICAgICAgb3B0aW9ucy50ZXh0LFxuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uLFxuICAgICAgb3B0aW9ucy5zdHlsZVxuICAgICk7XG4gIH1cbiAgZ2V0TWFuYWdlZFRleHR1cmUodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUsIHRleHRLZXkpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0pIHtcbiAgICAgIHRoaXMuX2luY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0ucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2J1aWxkVGV4dHVyZVByb21pc2UodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUpLnRoZW4oKHRleHR1cmUpID0+IHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSk7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0gPSB7XG4gICAgICB0ZXh0dXJlOiBudWxsLFxuICAgICAgcHJvbWlzZSxcbiAgICAgIHVzYWdlQ291bnQ6IDFcbiAgICB9O1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIF9idWlsZFRleHR1cmVQcm9taXNlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlKSB7XG4gICAgY29uc3QgaHRtbFRleHREYXRhID0gQmlnUG9vbC5nZXQoSFRNTFRleHRSZW5kZXJEYXRhKTtcbiAgICBjb25zdCBmb250RmFtaWxpZXMgPSBleHRyYWN0Rm9udEZhbWlsaWVzKHRleHQsIHN0eWxlKTtcbiAgICBjb25zdCBmb250Q1NTID0gYXdhaXQgZ2V0Rm9udENzcyhcbiAgICAgIGZvbnRGYW1pbGllcyxcbiAgICAgIHN0eWxlLFxuICAgICAgSFRNTFRleHRTdHlsZS5kZWZhdWx0VGV4dFN0eWxlXG4gICAgKTtcbiAgICBjb25zdCBtZWFzdXJlZCA9IG1lYXN1cmVIdG1sVGV4dCh0ZXh0LCBzdHlsZSwgZm9udENTUywgaHRtbFRleHREYXRhKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQud2lkdGgpICsgc3R5bGUucGFkZGluZyAqIDIpICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLm1heCgxLCBtZWFzdXJlZC5oZWlnaHQpICsgc3R5bGUucGFkZGluZyAqIDIpICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgaW1hZ2UgPSBodG1sVGV4dERhdGEuaW1hZ2U7XG4gICAgaW1hZ2Uud2lkdGggPSB3aWR0aCB8IDA7XG4gICAgaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0IHwgMDtcbiAgICBjb25zdCBzdmdVUkwgPSBnZXRTVkdVcmwodGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIGZvbnRDU1MsIGh0bWxUZXh0RGF0YSk7XG4gICAgYXdhaXQgbG9hZFNWR0ltYWdlKGltYWdlLCBzdmdVUkwsIGlzU2FmYXJpKCkgJiYgZm9udEZhbWlsaWVzLmxlbmd0aCA+IDApO1xuICAgIGxldCByZXNvdXJjZSA9IGltYWdlO1xuICAgIGlmICh0aGlzLl9jcmVhdGVDYW52YXMpIHtcbiAgICAgIHJlc291cmNlID0gZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlKGltYWdlLCByZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IGdldFBvMlRleHR1cmVGcm9tU291cmNlKHJlc291cmNlLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICBpZiAodGhpcy5fY3JlYXRlQ2FudmFzKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci50ZXh0dXJlLmluaXRTb3VyY2UodGV4dHVyZS5zb3VyY2UpO1xuICAgIH1cbiAgICBCaWdQb29sLnJldHVybihodG1sVGV4dERhdGEpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIF9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50Kys7XG4gIH1cbiAgZGVjcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgY29uc3QgYWN0aXZlVGV4dHVyZSA9IHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldO1xuICAgIGlmICghYWN0aXZlVGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBhY3RpdmVUZXh0dXJlLnVzYWdlQ291bnQtLTtcbiAgICBpZiAoYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50ID09PSAwKSB7XG4gICAgICBpZiAoYWN0aXZlVGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVUZXh0dXJlLnByb21pc2UudGhlbigodGV4dHVyZSkgPT4ge1xuICAgICAgICAgIGFjdGl2ZVRleHR1cmUudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgICAgdGhpcy5fY2xlYW5VcChhY3RpdmVUZXh0dXJlKTtcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIHdhcm4oXCJIVE1MVGV4dFN5c3RlbTogRmFpbGVkIHRvIGNsZWFuIHRleHR1cmVcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBfY2xlYW5VcChhY3RpdmVUZXh0dXJlKSB7XG4gICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShhY3RpdmVUZXh0dXJlLnRleHR1cmUpO1xuICAgIGFjdGl2ZVRleHR1cmUudGV4dHVyZS5zb3VyY2UucmVzb3VyY2UgPSBudWxsO1xuICAgIGFjdGl2ZVRleHR1cmUudGV4dHVyZS5zb3VyY2UudXBsb2FkTWV0aG9kSWQgPSBcInVua25vd25cIjtcbiAgfVxuICBnZXRSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnVzYWdlQ291bnQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5IVE1MVGV4dFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiaHRtbFRleHRcIlxufTtcbkhUTUxUZXh0U3lzdGVtLmRlZmF1bHRGb250T3B0aW9ucyA9IHtcbiAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbn07XG5cbmV4cG9ydCB7IEhUTUxUZXh0U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFBpcGUgfSBmcm9tICcuL0hUTUxUZXh0UGlwZS5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRTeXN0ZW0gfSBmcm9tICcuL0hUTUxUZXh0U3lzdGVtLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoSFRNTFRleHRTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5hZGQoSFRNTFRleHRQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1709\n')},3779:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p: () => (/* binding */ TextStyle)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4146);\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8409);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(156);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6653);\n/* harmony import */ var _graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4915);\n/* harmony import */ var _utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(740);\n\n\n\n\n\n\n\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = {\n        ..._TextStyle.defaultDropShadow,\n        ...value\n      };\n    } else {\n      this._dropShadow = value ? {\n        ..._TextStyle.defaultDropShadow\n      } : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertFillInputToFillStyle */ .w)(\n      value === 0 ? \"black\" : value,\n      _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__/* .GraphicsContext */ .g.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertFillInputToFillStyle */ .w)(value, _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__/* .GraphicsContext */ .g.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = (0,_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__/* .generateTextStyleKey */ .L)(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .v8_0_0 */ .P, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    style.stroke = {\n      color,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fill)) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .v8_0_0 */ .P, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    const gradientFill = new _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__/* .FillGradient */ .f(0, 0, 0, style.fontSize * 1.7);\n    const fills = oldStyle.fill.map((color) => _color_Color_mjs__WEBPACK_IMPORTED_MODULE_6__/* .Color */ .I.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0Qiw2QkFBNkIseUZBQVk7QUFDekMsK0NBQStDLDREQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvVGV4dFN0eWxlLm1qcz9mNmZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgRmlsbEdyYWRpZW50IH0gZnJvbSAnLi4vZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0NvbnRleHQgfSBmcm9tICcuLi9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUgfSBmcm9tICcuLi9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGVUZXh0U3R5bGVLZXkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVGV4dFN0eWxlID0gY2xhc3MgX1RleHRTdHlsZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHN0eWxlID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnZlcnRWN1RvdjhTdHlsZShzdHlsZSk7XG4gICAgY29uc3QgZnVsbFN0eWxlID0geyAuLi5fVGV4dFN0eWxlLmRlZmF1bHRUZXh0U3R5bGUsIC4uLnN0eWxlIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnVsbFN0eWxlKSB7XG4gICAgICBjb25zdCB0aGlzS2V5ID0ga2V5O1xuICAgICAgdGhpc1t0aGlzS2V5XSA9IGZ1bGxTdHlsZVtrZXldO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0LCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dC5cbiAgICogQG1lbWJlciB7J2xlZnQnfCdjZW50ZXInfCdyaWdodCd8J2p1c3RpZnknfVxuICAgKi9cbiAgZ2V0IGFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgfVxuICBzZXQgYWxpZ24odmFsdWUpIHtcbiAgICB0aGlzLl9hbGlnbiA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIEluZGljYXRlcyBpZiBsaW5lcyBjYW4gYmUgd3JhcHBlZCB3aXRoaW4gd29yZHMsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlLiAqL1xuICBnZXQgYnJlYWtXb3JkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgfVxuICBzZXQgYnJlYWtXb3Jkcyh2YWx1ZSkge1xuICAgIHRoaXMuX2JyZWFrV29yZHMgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHQuICovXG4gIGdldCBkcm9wU2hhZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93O1xuICB9XG4gIHNldCBkcm9wU2hhZG93KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IHtcbiAgICAgICAgLi4uX1RleHRTdHlsZS5kZWZhdWx0RHJvcFNoYWRvdyxcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Ryb3BTaGFkb3cgPSB2YWx1ZSA/IHtcbiAgICAgICAgLi4uX1RleHRTdHlsZS5kZWZhdWx0RHJvcFNoYWRvd1xuICAgICAgfSA6IG51bGw7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBmb250IGZhbWlseSwgY2FuIGJlIGEgc2luZ2xlIGZvbnQgbmFtZSwgb3IgYSBsaXN0IG9mIG5hbWVzIHdoZXJlIHRoZSBmaXJzdCBpcyB0aGUgcHJlZmVycmVkIGZvbnQuICovXG4gIGdldCBmb250RmFtaWx5KCkge1xuICAgIHJldHVybiB0aGlzLl9mb250RmFtaWx5O1xuICB9XG4gIHNldCBmb250RmFtaWx5KHZhbHVlKSB7XG4gICAgdGhpcy5fZm9udEZhbWlseSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBmb250IHNpemUgKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKSAqL1xuICBnZXQgZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplO1xuICB9XG4gIHNldCBmb250U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2ZvbnRTaXplID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9udFNpemUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvbnQgc3R5bGUuXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdpdGFsaWMnfCdvYmxpcXVlJ31cbiAgICovXG4gIGdldCBmb250U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgfVxuICBzZXQgZm9udFN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fZm9udFN0eWxlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvbnQgdmFyaWFudC5cbiAgICogQG1lbWJlciB7J25vcm1hbCd8J3NtYWxsLWNhcHMnfVxuICAgKi9cbiAgZ2V0IGZvbnRWYXJpYW50KCkge1xuICAgIHJldHVybiB0aGlzLl9mb250VmFyaWFudDtcbiAgfVxuICBzZXQgZm9udFZhcmlhbnQodmFsdWUpIHtcbiAgICB0aGlzLl9mb250VmFyaWFudCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IHdlaWdodC5cbiAgICogQG1lbWJlciB7J25vcm1hbCd8J2JvbGQnfCdib2xkZXInfCdsaWdodGVyJ3wnMTAwJ3wnMjAwJ3wnMzAwJ3wnNDAwJ3wnNTAwJ3wnNjAwJ3wnNzAwJ3wnODAwJ3wnOTAwJ31cbiAgICovXG4gIGdldCBmb250V2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9mb250V2VpZ2h0O1xuICB9XG4gIHNldCBmb250V2VpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5fZm9udFdlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzLiAqL1xuICBnZXQgbGVhZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgfVxuICBzZXQgbGVhZGluZyh2YWx1ZSkge1xuICAgIHRoaXMuX2xlYWRpbmcgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgYW1vdW50IG9mIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzLCBkZWZhdWx0IGlzIDAuICovXG4gIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHNldCBsZXR0ZXJTcGFjaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXMuICovXG4gIGdldCBsaW5lSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lSGVpZ2h0O1xuICB9XG4gIHNldCBsaW5lSGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5fbGluZUhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE9jY2FzaW9uYWxseSBzb21lIGZvbnRzIGFyZSBjcm9wcGVkLiBBZGRpbmcgc29tZSBwYWRkaW5nIHdpbGwgcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nXG4gICAqIGJ5IGFkZGluZyBwYWRkaW5nIHRvIGFsbCBzaWRlcyBvZiB0aGUgdGV4dC5cbiAgICovXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICB9XG4gIHNldCBwYWRkaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5fcGFkZGluZyA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVycy4gVGhpcyBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIG9ubHkgdXNlIHRoaXMgaWYgeW91IGhhdmUgdG8hICovXG4gIGdldCB0cmltKCkge1xuICAgIHJldHVybiB0aGlzLl90cmltO1xuICB9XG4gIHNldCB0cmltKHZhbHVlKSB7XG4gICAgdGhpcy5fdHJpbSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlbGluZSBvZiB0aGUgdGV4dCB0aGF0IGlzIHJlbmRlcmVkLlxuICAgKiBAbWVtYmVyIHsnYWxwaGFiZXRpYyd8J3RvcCd8J2hhbmdpbmcnfCdtaWRkbGUnfCdpZGVvZ3JhcGhpYyd8J2JvdHRvbSd9XG4gICAqL1xuICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gIH1cbiAgc2V0IHRleHRCYXNlbGluZSh2YWx1ZSkge1xuICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEhvdyBuZXdsaW5lcyBhbmQgc3BhY2VzIHNob3VsZCBiZSBoYW5kbGVkLlxuICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxuICAgKlxuICAgKiAgdmFsdWUgICAgICAgfCBOZXcgbGluZXMgICAgIHwgICBTcGFjZXNcbiAgICogIC0tLSAgICAgICAgIHwgLS0tICAgICAgICAgICB8ICAgLS0tXG4gICAqICdub3JtYWwnICAgICB8IENvbGxhcHNlICAgICAgfCAgIENvbGxhcHNlXG4gICAqICdwcmUnICAgICAgICB8IFByZXNlcnZlICAgICAgfCAgIFByZXNlcnZlXG4gICAqICdwcmUtbGluZScgICB8IFByZXNlcnZlICAgICAgfCAgIENvbGxhcHNlXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdwcmUnfCdwcmUtbGluZSd9XG4gICAqL1xuICBnZXQgd2hpdGVTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2hpdGVTcGFjZTtcbiAgfVxuICBzZXQgd2hpdGVTcGFjZSh2YWx1ZSkge1xuICAgIHRoaXMuX3doaXRlU3BhY2UgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBJbmRpY2F0ZXMgaWYgd29yZCB3cmFwIHNob3VsZCBiZSB1c2VkLiAqL1xuICBnZXQgd29yZFdyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwO1xuICB9XG4gIHNldCB3b3JkV3JhcCh2YWx1ZSkge1xuICAgIHRoaXMuX3dvcmRXcmFwID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZS4gKi9cbiAgZ2V0IHdvcmRXcmFwV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gIH1cbiAgc2V0IHdvcmRXcmFwV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93b3JkV3JhcFdpZHRoID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogQSBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nLiwgJ3JlZCcsICcjMDBGRjAwJy4gKi9cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsRmlsbDtcbiAgfVxuICBzZXQgZmlsbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fb3JpZ2luYWxGaWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX29yaWdpbmFsRmlsbCA9IHZhbHVlO1xuICAgIHRoaXMuX2ZpbGwgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUoXG4gICAgICB2YWx1ZSA9PT0gMCA/IFwiYmxhY2tcIiA6IHZhbHVlLFxuICAgICAgR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRGaWxsU3R5bGVcbiAgICApO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIEEgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZSwgZS5nLiwgJ2JsdWUnLCAnI0ZDRkYwMCcuICovXG4gIGdldCBzdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsU3Ryb2tlO1xuICB9XG4gIHNldCBzdHJva2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMuX29yaWdpbmFsU3Ryb2tlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX29yaWdpbmFsU3Ryb2tlID0gdmFsdWU7XG4gICAgdGhpcy5fc3Ryb2tlID0gY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlKHZhbHVlLCBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIF9nZW5lcmF0ZUtleSgpIHtcbiAgICB0aGlzLl9zdHlsZUtleSA9IGdlbmVyYXRlVGV4dFN0eWxlS2V5KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUtleTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fc3R5bGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogUmVzZXRzIGFsbCBwcm9wZXJ0aWVzIHRvIHRoZSBkZWZhdWx0IHZhbHVlcyAqL1xuICByZXNldCgpIHtcbiAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSBfVGV4dFN0eWxlLmRlZmF1bHRUZXh0U3R5bGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdFN0eWxlKSB7XG4gICAgICB0aGlzW2tleV0gPSBkZWZhdWx0U3R5bGVba2V5XTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0eWxlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUtleSB8fCB0aGlzLl9nZW5lcmF0ZUtleSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIE5ldyBjbG9uZWQgVGV4dFN0eWxlIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVGV4dFN0eWxlKHtcbiAgICAgIGFsaWduOiB0aGlzLmFsaWduLFxuICAgICAgYnJlYWtXb3JkczogdGhpcy5icmVha1dvcmRzLFxuICAgICAgZHJvcFNoYWRvdzogdGhpcy5kcm9wU2hhZG93LFxuICAgICAgZmlsbDogdGhpcy5fZmlsbCxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlOiB0aGlzLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50OiB0aGlzLmZvbnRWYXJpYW50LFxuICAgICAgZm9udFdlaWdodDogdGhpcy5mb250V2VpZ2h0LFxuICAgICAgbGVhZGluZzogdGhpcy5sZWFkaW5nLFxuICAgICAgbGV0dGVyU3BhY2luZzogdGhpcy5sZXR0ZXJTcGFjaW5nLFxuICAgICAgbGluZUhlaWdodDogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UsXG4gICAgICB0ZXh0QmFzZWxpbmU6IHRoaXMudGV4dEJhc2VsaW5lLFxuICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgd29yZFdyYXA6IHRoaXMud29yZFdyYXAsXG4gICAgICB3b3JkV3JhcFdpZHRoOiB0aGlzLndvcmRXcmFwV2lkdGhcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyB0ZXh0IHN0eWxlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIHRoaXMgc3R5bGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlU291cmNlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlU291cmNlIG9mIHRoZSB0aGlzIHN0eWxlXG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMgPSBmYWxzZSkge1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlU291cmNlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmVTb3VyY2U7XG4gICAgICBpZiAodGhpcy5fZmlsbD8udGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9maWxsLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fb3JpZ2luYWxGaWxsPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsRmlsbC50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0cm9rZT8udGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9zdHJva2UudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbFN0cm9rZT8udGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFN0cm9rZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9maWxsID0gbnVsbDtcbiAgICB0aGlzLl9zdHJva2UgPSBudWxsO1xuICAgIHRoaXMuZHJvcFNoYWRvdyA9IG51bGw7XG4gICAgdGhpcy5fb3JpZ2luYWxTdHJva2UgPSBudWxsO1xuICAgIHRoaXMuX29yaWdpbmFsRmlsbCA9IG51bGw7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgZHJvcCBzaGFkb3cgc2V0dGluZ3MgKi9cbl9UZXh0U3R5bGUuZGVmYXVsdERyb3BTaGFkb3cgPSB7XG4gIC8qKiBTZXQgYWxwaGEgZm9yIHRoZSBkcm9wIHNoYWRvdyAqL1xuICBhbHBoYTogMSxcbiAgLyoqIFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvdyAqL1xuICBhbmdsZTogTWF0aC5QSSAvIDYsXG4gIC8qKiBTZXQgYSBzaGFkb3cgYmx1ciByYWRpdXMgKi9cbiAgYmx1cjogMCxcbiAgLyoqIEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSAgZS5nLiwgJ3JlZCcsICcjMDBGRjAwJyAqL1xuICBjb2xvcjogXCJibGFja1wiLFxuICAvKiogU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93ICovXG4gIGRpc3RhbmNlOiA1XG59O1xuLyoqIFRoZSBkZWZhdWx0IHRleHQgc3R5bGUgc2V0dGluZ3MgKi9cbl9UZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZSA9IHtcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmFsaWdufVxuICAgKiBAdHlwZSB7J2xlZnQnfCdjZW50ZXInfCdyaWdodCd8J2p1c3RpZnknfVxuICAgKi9cbiAgYWxpZ246IFwibGVmdFwiLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUuYnJlYWtXb3Jkc30gKi9cbiAgYnJlYWtXb3JkczogZmFsc2UsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5kcm9wU2hhZG93fSAqL1xuICBkcm9wU2hhZG93OiBudWxsLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZmlsbH1cbiAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW118Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybn1cbiAgICovXG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRGYW1pbHl9XG4gICAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG4gICAqL1xuICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5mb250U2l6ZX1cbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XG4gICAqL1xuICBmb250U2l6ZTogMjYsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5mb250U3R5bGV9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wnaXRhbGljJ3wnb2JsaXF1ZSd9XG4gICAqL1xuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5mb250VmFyaWFudH1cbiAgICogQHR5cGUgeydub3JtYWwnfCdzbWFsbC1jYXBzJ31cbiAgICovXG4gIGZvbnRWYXJpYW50OiBcIm5vcm1hbFwiLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZm9udFdlaWdodH1cbiAgICogQHR5cGUgeydub3JtYWwnfCdib2xkJ3wnYm9sZGVyJ3wnbGlnaHRlcid8JzEwMCd8JzIwMCd8JzMwMCd8JzQwMCd8JzUwMCd8JzYwMCd8JzcwMCd8JzgwMCd8JzkwMCd9XG4gICAqL1xuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUubGVhZGluZ30gKi9cbiAgbGVhZGluZzogMCxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmxldHRlclNwYWNpbmd9ICovXG4gIGxldHRlclNwYWNpbmc6IDAsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5saW5lSGVpZ2h0fSAqL1xuICBsaW5lSGVpZ2h0OiAwLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUucGFkZGluZ30gKi9cbiAgcGFkZGluZzogMCxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLnN0cm9rZX1cbiAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAqL1xuICBzdHJva2U6IG51bGwsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS50ZXh0QmFzZWxpbmV9XG4gICAqIEB0eXBlIHsnYWxwaGFiZXRpYyd8J3RvcCd8J2hhbmdpbmcnfCdtaWRkbGUnfCdpZGVvZ3JhcGhpYyd8J2JvdHRvbSd9XG4gICAqL1xuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUudHJpbX0gKi9cbiAgdHJpbTogZmFsc2UsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS53aGl0ZVNwYWNlfVxuICAgKiBAdHlwZSB7J25vcm1hbCd8J3ByZSd8J3ByZS1saW5lJ31cbiAgICovXG4gIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS53b3JkV3JhcH0gKi9cbiAgd29yZFdyYXA6IGZhbHNlLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUud29yZFdyYXBXaWR0aH0gKi9cbiAgd29yZFdyYXBXaWR0aDogMTAwXG59O1xubGV0IFRleHRTdHlsZSA9IF9UZXh0U3R5bGU7XG5mdW5jdGlvbiBjb252ZXJ0VjdUb3Y4U3R5bGUoc3R5bGUpIHtcbiAgY29uc3Qgb2xkU3R5bGUgPSBzdHlsZTtcbiAgaWYgKHR5cGVvZiBvbGRTdHlsZS5kcm9wU2hhZG93ID09PSBcImJvb2xlYW5cIiAmJiBvbGRTdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBUZXh0U3R5bGUuZGVmYXVsdERyb3BTaGFkb3c7XG4gICAgc3R5bGUuZHJvcFNoYWRvdyA9IHtcbiAgICAgIGFscGhhOiBvbGRTdHlsZS5kcm9wU2hhZG93QWxwaGEgPz8gZGVmYXVsdHMuYWxwaGEsXG4gICAgICBhbmdsZTogb2xkU3R5bGUuZHJvcFNoYWRvd0FuZ2xlID8/IGRlZmF1bHRzLmFuZ2xlLFxuICAgICAgYmx1cjogb2xkU3R5bGUuZHJvcFNoYWRvd0JsdXIgPz8gZGVmYXVsdHMuYmx1cixcbiAgICAgIGNvbG9yOiBvbGRTdHlsZS5kcm9wU2hhZG93Q29sb3IgPz8gZGVmYXVsdHMuY29sb3IsXG4gICAgICBkaXN0YW5jZTogb2xkU3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlID8/IGRlZmF1bHRzLmRpc3RhbmNlXG4gICAgfTtcbiAgfVxuICBpZiAob2xkU3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcInN0cm9rZVRoaWNrbmVzcyBpcyBub3cgYSBwYXJ0IG9mIHN0cm9rZVwiKTtcbiAgICBjb25zdCBjb2xvciA9IG9sZFN0eWxlLnN0cm9rZTtcbiAgICBzdHlsZS5zdHJva2UgPSB7XG4gICAgICBjb2xvcixcbiAgICAgIHdpZHRoOiBvbGRTdHlsZS5zdHJva2VUaGlja25lc3NcbiAgICB9O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9sZFN0eWxlLmZpbGwpKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcImdyYWRpZW50IGZpbGwgaXMgbm93IGEgZmlsbCBwYXR0ZXJuOiBgbmV3IEZpbGxHcmFkaWVudCguLi4pYFwiKTtcbiAgICBjb25zdCBncmFkaWVudEZpbGwgPSBuZXcgRmlsbEdyYWRpZW50KDAsIDAsIDAsIHN0eWxlLmZvbnRTaXplICogMS43KTtcbiAgICBjb25zdCBmaWxscyA9IG9sZFN0eWxlLmZpbGwubWFwKChjb2xvcikgPT4gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b051bWJlcigpKTtcbiAgICBmaWxscy5mb3JFYWNoKChudW1iZXIsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCByYXRpbyA9IG9sZFN0eWxlLmZpbGxHcmFkaWVudFN0b3BzW2luZGV4XSA/PyBpbmRleCAvIGZpbGxzLmxlbmd0aDtcbiAgICAgIGdyYWRpZW50RmlsbC5hZGRDb2xvclN0b3AocmF0aW8sIG51bWJlcik7XG4gICAgfSk7XG4gICAgc3R5bGUuZmlsbCA9IHtcbiAgICAgIGZpbGw6IGdyYWRpZW50RmlsbFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0U3R5bGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3779\n")},3374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ CanvasTextMetrics)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\n\n"use strict";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .fontStringFromTextStyle */ .M)(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object\'s wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      } catch (ex) {\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = "M";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `\'\\u0065\\u0301\'`, letter e with acute)\n * or emojis with modifiers (e.g. `\'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don\'t support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won\'t use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome\'s new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\n\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUNnQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLGVBQWU7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQixvR0FBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUVBQVU7QUFDM0IsUUFBUTtBQUNSLGlCQUFpQix5RUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGtCQUFrQiwrQ0FBK0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dE1ldHJpY3MubWpzP2JkMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvbnRleHRTZXR0aW5ncyA9IHtcbiAgLy8gVGV4dE1ldHJpY3MgcmVxdWlyZXMgZ2V0SW1hZ2VEYXRhIHJlYWRiYWNrIGZvciBtZWFzdXJpbmcgZm9udHMuXG4gIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxufTtcbmNvbnN0IF9DYW52YXNUZXh0TWV0cmljcyA9IGNsYXNzIF9DYW52YXNUZXh0TWV0cmljcyB7XG4gIC8qKlxuICAgKiBDaGVja2luZyB0aGF0IHdlIGNhbiB1c2UgbW9kZXJuIGNhbnZhcyAyRCBBUEkuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgYW4gdW5zdGFibGUgQVBJLCBDaHJvbWUgPCA5NCB1c2UgYHRleHRMZXR0ZXJTcGFjaW5nYCwgbGF0ZXIgdmVyc2lvbnMgdXNlIGBsZXR0ZXJTcGFjaW5nYC5cbiAgICogQHNlZSBUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvbGV0dGVyU3BhY2luZ1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vb3JpZ2ludHJpYWxzLyMvdmlld190cmlhbC8zNTg1OTkxMjAzMjkzNzU3NDQxXG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHJlc3VsdCA9IF9DYW52YXNUZXh0TWV0cmljcy5fZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZDtcbiAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHByb3RvID0gRE9NQWRhcHRlci5nZXQoKS5nZXRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQoKS5wcm90b3R5cGU7XG4gICAgICByZXN1bHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2V4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQgPSBcImxldHRlclNwYWNpbmdcIiBpbiBwcm90byB8fCBcInRleHRMZXR0ZXJTcGFjaW5nXCIgaW4gcHJvdG87XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHRleHQgdGhhdCB3YXMgbWVhc3VyZWRcbiAgICogQHBhcmFtIHN0eWxlIC0gdGhlIHN0eWxlIHRoYXQgd2FzIG1lYXN1cmVkXG4gICAqIEBwYXJhbSB3aWR0aCAtIHRoZSBtZWFzdXJlZCB3aWR0aCBvZiB0aGUgdGV4dFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIG1lYXN1cmVkIGhlaWdodCBvZiB0aGUgdGV4dFxuICAgKiBAcGFyYW0gbGluZXMgLSBhbiBhcnJheSBvZiB0aGUgbGluZXMgb2YgdGV4dCBicm9rZW4gYnkgbmV3IGxpbmVzIGFuZCB3cmFwcGluZyBpZiBzcGVjaWZpZWQgaW4gc3R5bGVcbiAgICogQHBhcmFtIGxpbmVXaWR0aHMgLSBhbiBhcnJheSBvZiB0aGUgbGluZSB3aWR0aHMgZm9yIGVhY2ggbGluZSBtYXRjaGVkIHRvIGBsaW5lc2BcbiAgICogQHBhcmFtIGxpbmVIZWlnaHQgLSB0aGUgbWVhc3VyZWQgbGluZSBoZWlnaHQgZm9yIHRoaXMgc3R5bGVcbiAgICogQHBhcmFtIG1heExpbmVXaWR0aCAtIHRoZSBtYXhpbXVtIGxpbmUgd2lkdGggZm9yIGFsbCBtZWFzdXJlZCBsaW5lc1xuICAgKiBAcGFyYW0ge0ZvbnRNZXRyaWNzfSBmb250UHJvcGVydGllcyAtIHRoZSBmb250IHByb3BlcnRpZXMgb2JqZWN0IGZyb20gVGV4dE1ldHJpY3MubWVhc3VyZUZvbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCwgbWF4TGluZVdpZHRoLCBmb250UHJvcGVydGllcykge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gbGluZVdpZHRocztcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIHRoaXMubWF4TGluZVdpZHRoID0gbWF4TGluZVdpZHRoO1xuICAgIHRoaXMuZm9udFByb3BlcnRpZXMgPSBmb250UHJvcGVydGllcztcbiAgfVxuICAvKipcbiAgICogTWVhc3VyZXMgdGhlIHN1cHBsaWVkIHN0cmluZyBvZiB0ZXh0IGFuZCByZXR1cm5zIGEgUmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIG1lYXN1cmUuXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSB0ZXh0IHN0eWxlIHRvIHVzZSBmb3IgbWVhc3VyaW5nXG4gICAqIEBwYXJhbSBjYW52YXMgLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gICAqIEBwYXJhbSB3b3JkV3JhcFxuICAgKiBAcmV0dXJucyBNZWFzdXJlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0ZXh0LlxuICAgKi9cbiAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQgPSBcIiBcIiwgc3R5bGUsIGNhbnZhcyA9IF9DYW52YXNUZXh0TWV0cmljcy5fY2FudmFzLCB3b3JkV3JhcCA9IHN0eWxlLndvcmRXcmFwKSB7XG4gICAgY29uc3QgdGV4dEtleSA9IGAke3RleHR9OiR7c3R5bGUuc3R5bGVLZXl9YDtcbiAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLl9tZWFzdXJlbWVudENhY2hlW3RleHRLZXldKVxuICAgICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZW1lbnRDYWNoZVt0ZXh0S2V5XTtcbiAgICBjb25zdCBmb250ID0gZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUoc3R5bGUpO1xuICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gX0NhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgIGlmIChmb250UHJvcGVydGllcy5mb250U2l6ZSA9PT0gMCkge1xuICAgICAgZm9udFByb3BlcnRpZXMuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZTtcbiAgICAgIGZvbnRQcm9wZXJ0aWVzLmFzY2VudCA9IHN0eWxlLmZvbnRTaXplO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9fY29udGV4dDtcbiAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgIGNvbnN0IG91dHB1dFRleHQgPSB3b3JkV3JhcCA/IF9DYW52YXNUZXh0TWV0cmljcy5fd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykgOiB0ZXh0O1xuICAgIGNvbnN0IGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IF9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZVRleHQobGluZXNbaV0sIHN0eWxlLmxldHRlclNwYWNpbmcsIGNvbnRleHQpO1xuICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcbiAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzdHlsZS5fc3Ryb2tlPy53aWR0aCB8fCAwO1xuICAgIGxldCB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0cm9rZVdpZHRoO1xuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93LmRpc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodCB8fCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0cm9rZVdpZHRoO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0cm9rZVdpZHRoICogMikgKyAobGluZXMubGVuZ3RoIC0gMSkgKiAobGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcpO1xuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICBoZWlnaHQgKz0gc3R5bGUuZHJvcFNoYWRvdy5kaXN0YW5jZTtcbiAgICB9XG4gICAgY29uc3QgbWVhc3VyZW1lbnRzID0gbmV3IF9DYW52YXNUZXh0TWV0cmljcyhcbiAgICAgIHRleHQsXG4gICAgICBzdHlsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGluZXMsXG4gICAgICBsaW5lV2lkdGhzLFxuICAgICAgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsXG4gICAgICBtYXhMaW5lV2lkdGgsXG4gICAgICBmb250UHJvcGVydGllc1xuICAgICk7XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgfVxuICBzdGF0aWMgX21lYXN1cmVUZXh0KHRleHQsIGxldHRlclNwYWNpbmcsIGNvbnRleHQpIHtcbiAgICBsZXQgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCkge1xuICAgICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICBjb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgaWYgKHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgICAgd2lkdGggLT0gbGV0dGVyU3BhY2luZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoICs9IChfQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodGV4dCkubGVuZ3RoIC0gMSkgKiBsZXR0ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgbmV3bGluZXMgdG8gYSBzdHJpbmcgdG8gaGF2ZSBpdCBvcHRpbWFsbHkgZml0IGludG8gdGhlIGhvcml6b250YWxcbiAgICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gdGV4dCAtIFN0cmluZyB0byBhcHBseSB3b3JkIHdyYXBwaW5nIHRvXG4gICAqIEBwYXJhbSBzdHlsZSAtIHRoZSBzdHlsZSB0byB1c2Ugd2hlbiB3cmFwcGluZ1xuICAgKiBAcGFyYW0gY2FudmFzIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgKiBAcmV0dXJucyBOZXcgc3RyaW5nIHdpdGggbmV3IGxpbmVzIGFwcGxpZWQgd2hlcmUgcmVxdWlyZWRcbiAgICovXG4gIHN0YXRpYyBfd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcyA9IF9DYW52YXNUZXh0TWV0cmljcy5fY2FudmFzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICBsZXQgd2lkdGggPSAwO1xuICAgIGxldCBsaW5lID0gXCJcIjtcbiAgICBsZXQgbGluZXMgPSBcIlwiO1xuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgeyBsZXR0ZXJTcGFjaW5nLCB3aGl0ZVNwYWNlIH0gPSBzdHlsZTtcbiAgICBjb25zdCBjb2xsYXBzZVNwYWNlcyA9IF9DYW52YXNUZXh0TWV0cmljcy5fY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSk7XG4gICAgY29uc3QgY29sbGFwc2VOZXdsaW5lcyA9IF9DYW52YXNUZXh0TWV0cmljcy5fY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKTtcbiAgICBsZXQgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICBjb25zdCB3b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgY29uc3QgdG9rZW5zID0gX0NhbnZhc1RleHRNZXRyaWNzLl90b2tlbml6ZSh0ZXh0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5faXNOZXdsaW5lKHRva2VuKSkge1xuICAgICAgICBpZiAoIWNvbGxhcHNlTmV3bGluZXMpIHtcbiAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSk7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZVNwYWNlcykge1xuICAgICAgICBjb25zdCBjdXJySXNCcmVha2luZ1NwYWNlID0gX0NhbnZhc1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbik7XG4gICAgICAgIGNvbnN0IGxhc3RJc0JyZWFraW5nU3BhY2UgPSBfQ2FudmFzVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGxpbmVbbGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChjdXJySXNCcmVha2luZ1NwYWNlICYmIGxhc3RJc0JyZWFraW5nU3BhY2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5XaWR0aCA9IF9DYW52YXNUZXh0TWV0cmljcy5fZ2V0RnJvbUNhY2hlKHRva2VuLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICBpZiAodG9rZW5XaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgaWYgKGxpbmUgIT09IFwiXCIpIHtcbiAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSk7XG4gICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuY2FuQnJlYWtXb3Jkcyh0b2tlbiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJzID0gX0NhbnZhc1RleHRNZXRyaWNzLndvcmRXcmFwU3BsaXQodG9rZW4pO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhcmFjdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBjaGFyYWN0ZXJzW2pdO1xuICAgICAgICAgICAgbGV0IGxhc3RDaGFyID0gY2hhcjtcbiAgICAgICAgICAgIGxldCBrID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJzW2ogKyBrXSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJhY3RlcnNbaiArIGtdO1xuICAgICAgICAgICAgICBpZiAoIV9DYW52YXNUZXh0TWV0cmljcy5jYW5CcmVha0NoYXJzKGxhc3RDaGFyLCBuZXh0Q2hhciwgdG9rZW4sIGosIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgICAgICAgY2hhciArPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0Q2hhciA9IG5leHRDaGFyO1xuICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqICs9IGsgLSAxO1xuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyV2lkdGggPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2dldEZyb21DYWNoZShjaGFyLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lICs9IGNoYXI7XG4gICAgICAgICAgICB3aWR0aCArPSBjaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGFzdFRva2VuID0gaSA9PT0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKHRva2VuLCAhaXNMYXN0VG9rZW4pO1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCB8fCAhX0NhbnZhc1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbikgfHwgY2FuUHJlcGVuZFNwYWNlcykge1xuICAgICAgICAgIGxpbmUgKz0gdG9rZW47XG4gICAgICAgICAgd2lkdGggKz0gdG9rZW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSwgZmFsc2UpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICAvKipcbiAgICogQ29udmllbmllbmNlIGZ1bmN0aW9uIGZvciBsb2dnaW5nIGVhY2ggbGluZSBhZGRlZCBkdXJpbmcgdGhlIHdvcmRXcmFwIG1ldGhvZC5cbiAgICogQHBhcmFtIGxpbmUgICAgLSBUaGUgbGluZSBvZiB0ZXh0IHRvIGFkZFxuICAgKiBAcGFyYW0gbmV3TGluZSAtIEFkZCBuZXcgbGluZSBjaGFyYWN0ZXIgdG8gZW5kXG4gICAqIEByZXR1cm5zIEEgZm9ybWF0dGVkIGxpbmVcbiAgICovXG4gIHN0YXRpYyBfYWRkTGluZShsaW5lLCBuZXdMaW5lID0gdHJ1ZSkge1xuICAgIGxpbmUgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX3RyaW1SaWdodChsaW5lKTtcbiAgICBsaW5lID0gbmV3TGluZSA/IGAke2xpbmV9XG5gIDogbGluZTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyAmIHNldHMgdGhlIHdpZHRocyBvZiBjYWxjdWxhdGVkIGNoYXJhY3RlcnMgaW4gYSBjYWNoZSBvYmplY3RcbiAgICogQHBhcmFtIGtleSAgICAgICAgICAgIC0gVGhlIGtleVxuICAgKiBAcGFyYW0gbGV0dGVyU3BhY2luZyAgLSBUaGUgbGV0dGVyIHNwYWNpbmdcbiAgICogQHBhcmFtIGNhY2hlICAgICAgICAgIC0gVGhlIGNhY2hlXG4gICAqIEBwYXJhbSBjb250ZXh0ICAgICAgICAtIFRoZSBjYW52YXMgY29udGV4dFxuICAgKiBAcmV0dXJucyBUaGUgZnJvbSBjYWNoZS5cbiAgICovXG4gIHN0YXRpYyBfZ2V0RnJvbUNhY2hlKGtleSwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpIHtcbiAgICBsZXQgd2lkdGggPSBjYWNoZVtrZXldO1xuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHdpZHRoID0gX0NhbnZhc1RleHRNZXRyaWNzLl9tZWFzdXJlVGV4dChrZXksIGxldHRlclNwYWNpbmcsIGNvbnRleHQpICsgbGV0dGVyU3BhY2luZztcbiAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIGJyZWFraW5nIHNwYWNlcy5cbiAgICogQHBhcmFtIHdoaXRlU3BhY2UgLSBUaGUgVGV4dFN0eWxlIHByb3BlcnR5IHdoaXRlU3BhY2VcbiAgICogQHJldHVybnMgU2hvdWxkIGNvbGxhcHNlXG4gICAqL1xuICBzdGF0aWMgX2NvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpIHtcbiAgICByZXR1cm4gd2hpdGVTcGFjZSA9PT0gXCJub3JtYWxcIiB8fCB3aGl0ZVNwYWNlID09PSBcInByZS1saW5lXCI7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgbmV3TGluZSBjaGFycy5cbiAgICogQHBhcmFtIHdoaXRlU3BhY2UgLSBUaGUgd2hpdGUgc3BhY2VcbiAgICogQHJldHVybnMgc2hvdWxkIGNvbGxhcHNlXG4gICAqL1xuICBzdGF0aWMgX2NvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSkge1xuICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSBcIm5vcm1hbFwiO1xuICB9XG4gIC8qKlxuICAgKiBUcmltcyBicmVha2luZyB3aGl0ZXNwYWNlcyBmcm9tIHN0cmluZy5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dFxuICAgKiBAcmV0dXJucyBUcmltbWVkIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIF90cmltUmlnaHQodGV4dCkge1xuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgIGlmICghX0NhbnZhc1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShjaGFyKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgY2hhciBpcyBhIG5ld2xpbmUuXG4gICAqIEBwYXJhbSBjaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIG5ld2xpbmUsIEZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBfaXNOZXdsaW5lKGNoYXIpIHtcbiAgICBpZiAodHlwZW9mIGNoYXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fbmV3bGluZXMuaW5jbHVkZXMoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBjaGFyIGlzIGEgYnJlYWtpbmcgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogSXQgYWxsb3dzIG9uZSB0byBkZXRlcm1pbmUgd2hldGhlciBjaGFyIHNob3VsZCBiZSBhIGJyZWFraW5nIHdoaXRlc3BhY2VcbiAgICogRm9yIGV4YW1wbGUgY2VydGFpbiBjaGFyYWN0ZXJzIGluIENKSyBsYW5ncyBvciBudW1iZXJzLlxuICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBjaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcGFyYW0gW19uZXh0Q2hhcl0gLSBUaGUgbmV4dCBjaGFyYWN0ZXJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB3aGl0ZXNwYWNlLCBGYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgaXNCcmVha2luZ1NwYWNlKGNoYXIsIF9uZXh0Q2hhcikge1xuICAgIGlmICh0eXBlb2YgY2hhciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdHMgYSBzdHJpbmcgaW50byB3b3JkcywgYnJlYWtpbmctc3BhY2VzIGFuZCBuZXdMaW5lIGNoYXJhY3RlcnNcbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dFxuICAgKiBAcmV0dXJucyBBIHRva2VuaXplZCBhcnJheVxuICAgKi9cbiAgc3RhdGljIF90b2tlbml6ZSh0ZXh0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgbGV0IHRva2VuID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhciwgbmV4dENoYXIpIHx8IF9DYW52YXNUZXh0TWV0cmljcy5faXNOZXdsaW5lKGNoYXIpKSB7XG4gICAgICAgIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB0b2tlbiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goY2hhcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdG9rZW4gKz0gY2hhcjtcbiAgICB9XG4gICAgaWYgKHRva2VuICE9PSBcIlwiKSB7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIGhlbHBlciBtZXRob2QgdXNlZCBpbnRlcm5hbGx5IGJ5IFRleHRNZXRyaWNzLCBleHBvc2VkIHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoZSBjbGFzcydzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBJdCBhbGxvd3Mgb25lIHRvIGN1c3RvbWlzZSB3aGljaCB3b3JkcyBzaG91bGQgYnJlYWtcbiAgICogRXhhbXBsZXMgYXJlIGlmIHRoZSB0b2tlbiBpcyBDSksgb3IgbnVtYmVycy5cbiAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgKiBAcGFyYW0gX3Rva2VuIC0gVGhlIHRva2VuXG4gICAqIEBwYXJhbSBicmVha1dvcmRzIC0gVGhlIHN0eWxlIGF0dHIgYnJlYWsgd29yZHNcbiAgICogQHJldHVybnMgV2hldGhlciB0byBicmVhayB3b3JkIG9yIG5vdFxuICAgKi9cbiAgc3RhdGljIGNhbkJyZWFrV29yZHMoX3Rva2VuLCBicmVha1dvcmRzKSB7XG4gICAgcmV0dXJuIGJyZWFrV29yZHM7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIGhlbHBlciBtZXRob2QgdXNlZCBpbnRlcm5hbGx5IGJ5IFRleHRNZXRyaWNzLCBleHBvc2VkIHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoZSBjbGFzcydzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBJdCBhbGxvd3Mgb25lIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcGFpciBvZiBjaGFyYWN0ZXJzXG4gICAqIHNob3VsZCBiZSBicm9rZW4gYnkgbmV3bGluZXNcbiAgICogRm9yIGV4YW1wbGUgY2VydGFpbiBjaGFyYWN0ZXJzIGluIENKSyBsYW5ncyBvciBudW1iZXJzLlxuICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBfY2hhciAtIFRoZSBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIF9uZXh0Q2hhciAtIFRoZSBuZXh0IGNoYXJhY3RlclxuICAgKiBAcGFyYW0gX3Rva2VuIC0gVGhlIHRva2VuL3dvcmQgdGhlIGNoYXJhY3RlcnMgYXJlIGZyb21cbiAgICogQHBhcmFtIF9pbmRleCAtIFRoZSBpbmRleCBpbiB0aGUgdG9rZW4gb2YgdGhlIGNoYXJcbiAgICogQHBhcmFtIF9icmVha1dvcmRzIC0gVGhlIHN0eWxlIGF0dHIgYnJlYWsgd29yZHNcbiAgICogQHJldHVybnMgd2hldGhlciB0byBicmVhayB3b3JkIG9yIG5vdFxuICAgKi9cbiAgc3RhdGljIGNhbkJyZWFrQ2hhcnMoX2NoYXIsIF9uZXh0Q2hhciwgX3Rva2VuLCBfaW5kZXgsIF9icmVha1dvcmRzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIGhlbHBlciBtZXRob2QgdXNlZCBpbnRlcm5hbGx5IGJ5IFRleHRNZXRyaWNzLCBleHBvc2VkIHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoZSBjbGFzcydzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHRva2VuICh1c3VhbGx5IGEgd29yZCkgaGFzIHRvIGJlIHNwbGl0IGludG8gc2VwYXJhdGUgcGllY2VzXG4gICAqIGluIG9yZGVyIHRvIGRldGVybWluZSB0aGUgcG9pbnQgdG8gYnJlYWsgYSB3b3JkLlxuICAgKiBJdCBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gdG9rZW4gLSBUaGUgdG9rZW4gdG8gc3BsaXRcbiAgICogQHJldHVybnMgVGhlIGNoYXJhY3RlcnMgb2YgdGhlIHRva2VuXG4gICAqIEBzZWUgQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXJcbiAgICovXG4gIHN0YXRpYyB3b3JkV3JhcFNwbGl0KHRva2VuKSB7XG4gICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0b2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250LXN0eWxlXG4gICAqIEBwYXJhbSBmb250IC0gU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3R5bGUgb2YgdGhlIGZvbnRcbiAgICogQHJldHVybnMgRm9udCBwcm9wZXJ0aWVzIG9iamVjdFxuICAgKi9cbiAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcbiAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLl9mb250c1tmb250XSkge1xuICAgICAgcmV0dXJuIF9DYW52YXNUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2NvbnRleHQ7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBtZXRyaWNzID0gY29udGV4dC5tZWFzdXJlVGV4dChfQ2FudmFzVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgKyBfQ2FudmFzVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgYXNjZW50OiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgZGVzY2VudDogbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBmb250U2l6ZTogbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50XG4gICAgfTtcbiAgICBfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdID0gcHJvcGVydGllcztcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgZm9udCBtZXRyaWNzIGluIG1ldHJpY3MgY2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9udF0gLSBmb250IG5hbWUuIElmIGZvbnQgbmFtZSBub3Qgc2V0IHRoZW4gY2xlYXIgY2FjaGUgZm9yIGFsbCBmb250cy5cbiAgICovXG4gIHN0YXRpYyBjbGVhck1ldHJpY3MoZm9udCA9IFwiXCIpIHtcbiAgICBpZiAoZm9udCkge1xuICAgICAgZGVsZXRlIF9DYW52YXNUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgfSBlbHNlIHtcbiAgICAgIF9DYW52YXNUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhY2hlZCBjYW52YXMgZWxlbWVudCBmb3IgbWVhc3VyaW5nIHRleHRcbiAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IGlzbid0IGJlY2F1c2Ugb2YgYmFja3dhcmQgY29tcGF0LCB3aWxsIGZpeCBsYXRlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGdldCBfY2FudmFzKCkge1xuICAgIGlmICghX0NhbnZhc1RleHRNZXRyaWNzLl9fY2FudmFzKSB7XG4gICAgICBsZXQgY2FudmFzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgICAgICBpZiAoY29udGV4dD8ubWVhc3VyZVRleHQpIHtcbiAgICAgICAgICBfQ2FudmFzVGV4dE1ldHJpY3MuX19jYW52YXMgPSBjO1xuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDEwO1xuICAgICAgX0NhbnZhc1RleHRNZXRyaWNzLl9fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLl9fY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBUT0RPOiB0aGlzIHNob3VsZCBiZSBwcml2YXRlLCBidXQgaXNuJ3QgYmVjYXVzZSBvZiBiYWNrd2FyZCBjb21wYXQsIHdpbGwgZml4IGxhdGVyLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgZ2V0IF9jb250ZXh0KCkge1xuICAgIGlmICghX0NhbnZhc1RleHRNZXRyaWNzLl9fY29udGV4dCkge1xuICAgICAgX0NhbnZhc1RleHRNZXRyaWNzLl9fY29udGV4dCA9IF9DYW52YXNUZXh0TWV0cmljcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLl9fY29udGV4dDtcbiAgfVxufTtcbi8qKlxuICogU3RyaW5nIHVzZWQgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuXG4gKiBUaGVzZSBjaGFyYWN0ZXJzIGFyZSBhbGwgdGFsbCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IHJlcXVpcmVkIGZvciB0ZXh0LlxuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgPSBcInxcXHhDOXFcXHhDNVwiO1xuLyoqIEJhc2VsaW5lIHN5bWJvbCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0wgPSBcIk1cIjtcbi8qKiBCYXNlbGluZSBtdWx0aXBsaWVyIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgPSAxLjQ7XG4vKiogSGVpZ2h0IG11bHRpcGxpZXIgZm9yIHNldHRpbmcgaGVpZ2h0IG9mIGNhbnZhcyB0byBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLkhFSUdIVF9NVUxUSVBMSUVSID0gMjtcbi8qKlxuICogQSBVbmljb2RlIFwiY2hhcmFjdGVyXCIsIG9yIFwiZ3JhcGhlbWUgY2x1c3RlclwiLCBjYW4gYmUgY29tcG9zZWQgb2YgbXVsdGlwbGUgVW5pY29kZSBjb2RlIHBvaW50cyxcbiAqIHN1Y2ggYXMgbGV0dGVycyB3aXRoIGRpYWNyaXRpY2FsIG1hcmtzIChlLmcuIGAnXFx1MDA2NVxcdTAzMDEnYCwgbGV0dGVyIGUgd2l0aCBhY3V0ZSlcbiAqIG9yIGVtb2ppcyB3aXRoIG1vZGlmaWVycyAoZS5nLiBgJ1xcdUQ4M0VcXHVEREQxXFx1MjAwRFxcdUQ4M0RcXHVEQ0JCJ2AsIHRlY2hub2xvZ2lzdCkuXG4gKiBUaGUgbmV3IGBJbnRsLlNlZ21lbnRlcmAgQVBJIGluIEVTMjAyMiBjYW4gc3BsaXQgdGhlIHN0cmluZyBpbnRvIGdyYXBoZW1lIGNsdXN0ZXJzIGNvcnJlY3RseS4gSWYgaXQgaXMgbm90IGF2YWlsYWJsZSxcbiAqIFBpeGlKUyB3aWxsIGZhbGxiYWNrIHRvIHVzZSB0aGUgaXRlcmF0b3Igb2YgU3RyaW5nLCB3aGljaCBjYW4gb25seSBzcGlsdCB0aGUgc3RyaW5nIGludG8gY29kZSBwb2ludHMuXG4gKiBJZiB5b3Ugd2FudCB0byBnZXQgZnVsbCBmdW5jdGlvbmFsaXR5IGluIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgYEludGwuU2VnbWVudGVyYCAoc3VjaCBhcyBGaXJlZm94KSxcbiAqIHlvdSBjYW4gdXNlIG90aGVyIGxpYnJhcmllcyBzdWNoIGFzIFtncmFwaGVtZS1zcGxpdHRlcl17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ3JhcGhlbWUtc3BsaXR0ZXJ9XG4gKiBvciBbZ3JhcGhlbWVyXXtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9ncmFwaGVtZXJ9IHRvIGNyZWF0ZSBhIHBvbHlmaWxsLiBTaW5jZSB0aGVzZSBsaWJyYXJpZXMgY2FuIGJlXG4gKiByZWxhdGl2ZWx5IGxhcmdlIGluIHNpemUgdG8gaGFuZGxlIHZhcmlvdXMgVW5pY29kZSBncmFwaGVtZSBjbHVzdGVycyBwcm9wZXJseSwgUGl4aUpTIHdvbid0IHVzZSB0aGVtIGRpcmVjdGx5LlxuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIgPSAoKCkgPT4ge1xuICBpZiAodHlwZW9mIEludGw/LlNlZ21lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2VnbWVudGVyID0gbmV3IEludGwuU2VnbWVudGVyKCk7XG4gICAgcmV0dXJuIChzKSA9PiBbLi4uc2VnbWVudGVyLnNlZ21lbnQocyldLm1hcCgoeCkgPT4geC5zZWdtZW50KTtcbiAgfVxuICByZXR1cm4gKHMpID0+IFsuLi5zXTtcbn0pKCk7XG4vKipcbiAqIE5ldyByZW5kZXJpbmcgYmVoYXZpb3IgZm9yIGxldHRlci1zcGFjaW5nIHdoaWNoIHVzZXMgQ2hyb21lJ3MgbmV3IG5hdGl2ZSBBUEkuIFRoaXMgd2lsbFxuICogbGVhZCB0byBtb3JlIGFjY3VyYXRlIGxldHRlci1zcGFjaW5nIHJlc3VsdHMgYmVjYXVzZSBpdCBkb2VzIG5vdCB0cnkgdG8gbWFudWFsbHkgZHJhd1xuICogZWFjaCBjaGFyYWN0ZXIuIEhvd2V2ZXIsIHRoaXMgQ2hyb21lIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBub3Qgc2VydmUgYWxsIGNhc2VzIHlldC5cbiAqIEBzZWUgVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZFxuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuLyoqIENhY2hlIG9mIHtAc2VlIFRleHRNZXRyaWNzLkZvbnRNZXRyaWNzfSBvYmplY3RzLiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLl9mb250cyA9IHt9O1xuLyoqIENhY2hlIG9mIG5ldyBsaW5lIGNoYXJzLiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLl9uZXdsaW5lcyA9IFtcbiAgMTAsXG4gIC8vIGxpbmUgZmVlZFxuICAxM1xuICAvLyBjYXJyaWFnZSByZXR1cm5cbl07XG4vKiogQ2FjaGUgb2YgYnJlYWtpbmcgc3BhY2VzLiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFtcbiAgOSxcbiAgLy8gY2hhcmFjdGVyIHRhYnVsYXRpb25cbiAgMzIsXG4gIC8vIHNwYWNlXG4gIDgxOTIsXG4gIC8vIGVuIHF1YWRcbiAgODE5MyxcbiAgLy8gZW0gcXVhZFxuICA4MTk0LFxuICAvLyBlbiBzcGFjZVxuICA4MTk1LFxuICAvLyBlbSBzcGFjZVxuICA4MTk2LFxuICAvLyB0aHJlZS1wZXItZW0gc3BhY2VcbiAgODE5NyxcbiAgLy8gZm91ci1wZXItZW0gc3BhY2VcbiAgODE5OCxcbiAgLy8gc2l4LXBlci1lbSBzcGFjZVxuICA4MjAwLFxuICAvLyBwdW5jdHVhdGlvbiBzcGFjZVxuICA4MjAxLFxuICAvLyB0aGluIHNwYWNlXG4gIDgyMDIsXG4gIC8vIGhhaXIgc3BhY2VcbiAgODI4NyxcbiAgLy8gbWVkaXVtIG1hdGhlbWF0aWNhbCBzcGFjZVxuICAxMjI4OFxuICAvLyBpZGVvZ3JhcGhpYyBzcGFjZVxuXTtcbl9DYW52YXNUZXh0TWV0cmljcy5fbWVhc3VyZW1lbnRDYWNoZSA9IHt9O1xubGV0IENhbnZhc1RleHRNZXRyaWNzID0gX0NhbnZhc1RleHRNZXRyaWNzO1xuXG5leHBvcnQgeyBDYW52YXNUZXh0TWV0cmljcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzVGV4dE1ldHJpY3MubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3374\n')},13:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M: () => (/* binding */ fontStringFromTextStyle)\n/* harmony export */ });\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(",");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `"${fontFamily}"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n}\n\n\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLHVCQUF1QjtBQUNqSDs7QUFFbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanM/ZDNhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGdlbmVyaWNGb250RmFtaWxpZXMgPSBbXG4gIFwic2VyaWZcIixcbiAgXCJzYW5zLXNlcmlmXCIsXG4gIFwibW9ub3NwYWNlXCIsXG4gIFwiY3Vyc2l2ZVwiLFxuICBcImZhbnRhc3lcIixcbiAgXCJzeXN0ZW0tdWlcIlxuXTtcbmZ1bmN0aW9uIGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IGZvbnRTaXplU3RyaW5nID0gdHlwZW9mIHN0eWxlLmZvbnRTaXplID09PSBcIm51bWJlclwiID8gYCR7c3R5bGUuZm9udFNpemV9cHhgIDogc3R5bGUuZm9udFNpemU7XG4gIGxldCBmb250RmFtaWxpZXMgPSBzdHlsZS5mb250RmFtaWx5O1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUuZm9udEZhbWlseSkpIHtcbiAgICBmb250RmFtaWxpZXMgPSBzdHlsZS5mb250RmFtaWx5LnNwbGl0KFwiLFwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gZm9udEZhbWlsaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgIGlmICghLyhbXFxcIlxcJ10pW15cXCdcXFwiXStcXDEvLnRlc3QoZm9udEZhbWlseSkgJiYgIWdlbmVyaWNGb250RmFtaWxpZXMuaW5jbHVkZXMoZm9udEZhbWlseSkpIHtcbiAgICAgIGZvbnRGYW1pbHkgPSBgXCIke2ZvbnRGYW1pbHl9XCJgO1xuICAgIH1cbiAgICBmb250RmFtaWxpZXNbaV0gPSBmb250RmFtaWx5O1xuICB9XG4gIHJldHVybiBgJHtzdHlsZS5mb250U3R5bGV9ICR7c3R5bGUuZm9udFZhcmlhbnR9ICR7c3R5bGUuZm9udFdlaWdodH0gJHtmb250U2l6ZVN0cmluZ30gJHtmb250RmFtaWxpZXMuam9pbihcIixcIil9YDtcbn1cblxuZXhwb3J0IHsgZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},778:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ getCanvasFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9853);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4796);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1261);\n\n\n\n\n\n\n\n"use strict";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture */ .x.WHITE && !fillStyle.fill) {\n    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");\n    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillPattern */ .h) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");\n    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__/* .FillGradient */ .f) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === "linear") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__/* .warn */ .Z)("FillStyle not recognised", fillStyle);\n  return "red";\n}\n\n\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzNCO0FBQ29CO0FBQ0Y7O0FBRTVFO0FBQ0E7QUFDQSw0QkFBNEIsNkZBQU87QUFDbkMsV0FBVyw0REFBSztBQUNoQixJQUFJO0FBQ0o7QUFDQSwrQ0FBK0MscUVBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUMsdUZBQVc7QUFDbEQ7QUFDQTtBQUNBLG9EQUFvRCxxRUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQyx5RkFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQUs7QUFDaEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQUk7QUFDTjtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvY2FudmFzL3V0aWxzL2dldENhbnZhc0ZpbGxTdHlsZS5tanM/ZTE5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBGaWxsR3JhZGllbnQgfSBmcm9tICcuLi8uLi8uLi9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsR3JhZGllbnQubWpzJztcbmltcG9ydCB7IEZpbGxQYXR0ZXJuIH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbFBhdHRlcm4ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRDYW52YXNGaWxsU3R5bGUoZmlsbFN0eWxlLCBjb250ZXh0KSB7XG4gIGlmIChmaWxsU3R5bGUudGV4dHVyZSA9PT0gVGV4dHVyZS5XSElURSAmJiAhZmlsbFN0eWxlLmZpbGwpIHtcbiAgICByZXR1cm4gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGZpbGxTdHlsZS5jb2xvcikudG9IZXgoKTtcbiAgfSBlbHNlIGlmICghZmlsbFN0eWxlLmZpbGwpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGZpbGxTdHlsZS50ZXh0dXJlLnNvdXJjZS5yZXNvdXJjZSwgXCJyZXBlYXRcIik7XG4gICAgY29uc3QgdGVtcE1hdHJpeCA9IGZpbGxTdHlsZS5tYXRyaXguY29weVRvKE1hdHJpeC5zaGFyZWQpO1xuICAgIHRlbXBNYXRyaXguc2NhbGUoZmlsbFN0eWxlLnRleHR1cmUuZnJhbWUud2lkdGgsIGZpbGxTdHlsZS50ZXh0dXJlLmZyYW1lLmhlaWdodCk7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0odGVtcE1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmZpbGwgaW5zdGFuY2VvZiBGaWxsUGF0dGVybikge1xuICAgIGNvbnN0IGZpbGxQYXR0ZXJuID0gZmlsbFN0eWxlLmZpbGw7XG4gICAgY29uc3QgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihmaWxsUGF0dGVybi50ZXh0dXJlLnNvdXJjZS5yZXNvdXJjZSwgXCJyZXBlYXRcIik7XG4gICAgY29uc3QgdGVtcE1hdHJpeCA9IGZpbGxQYXR0ZXJuLnRyYW5zZm9ybS5jb3B5VG8oTWF0cml4LnNoYXJlZCk7XG4gICAgdGVtcE1hdHJpeC5zY2FsZShcbiAgICAgIGZpbGxQYXR0ZXJuLnRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICBmaWxsUGF0dGVybi50ZXh0dXJlLmZyYW1lLmhlaWdodFxuICAgICk7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0odGVtcE1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmZpbGwgaW5zdGFuY2VvZiBGaWxsR3JhZGllbnQpIHtcbiAgICBjb25zdCBmaWxsR3JhZGllbnQgPSBmaWxsU3R5bGUuZmlsbDtcbiAgICBpZiAoZmlsbEdyYWRpZW50LnR5cGUgPT09IFwibGluZWFyXCIpIHtcbiAgICAgIGNvbnN0IGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgICAgZmlsbEdyYWRpZW50LngwLFxuICAgICAgICBmaWxsR3JhZGllbnQueTAsXG4gICAgICAgIGZpbGxHcmFkaWVudC54MSxcbiAgICAgICAgZmlsbEdyYWRpZW50LnkxXG4gICAgICApO1xuICAgICAgZmlsbEdyYWRpZW50LmdyYWRpZW50U3RvcHMuZm9yRWFjaCgoc3RvcCkgPT4ge1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdG9wLmNvbG9yKS50b0hleCgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfVxuICB3YXJuKFwiRmlsbFN0eWxlIG5vdCByZWNvZ25pc2VkXCIsIGZpbGxTdHlsZSk7XG4gIHJldHVybiBcInJlZFwiO1xufVxuXG5leHBvcnQgeyBnZXRDYW52YXNGaWxsU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENhbnZhc0ZpbGxTdHlsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///778\n')},2:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs\n\n\n\n\n\n"use strict";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    const resolution = text.resolution ?? this._renderer.resolution;\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n      text.text,\n      resolution,\n      text._style,\n      text._getKey()\n    );\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on("destroyed", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "text"\n};\n\n\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs\n\n\n"use strict";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle/* Rectangle */.A.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle/* Rectangle */.A(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass CanvasTextSystem {\n  constructor() {\n    this._activeTextures = {};\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = (0,pow2/* nextPow2 */.a9)(width);\n    height = (0,pow2/* nextPow2 */.a9)(height);\n    return { width, height };\n  }\n  getTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = "unknown";\n      source.alphaMode = "no-premultiply-alpha";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to \'pre-generate\' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color/* Color */.I.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._stroke, context);\n        }\n        context.shadowColor = "black";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it\'s for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics/* CanvasTextMetrics */.c.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "canvasText"\n};\n\n\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(CanvasTextSystem);\nExtensions/* extensions */.Rw.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVqRTtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CLDZCQUFVLEtBQUssY0FBYztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRQaXBlLm1qcz8wNzAwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2NhbnZhcy9nZXRDYW52YXNCb3VuZGluZ0JveC5tanM/M2UxMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1wYXJ0aWNsZS13YXlwb2ludC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy9DYW52YXNUZXh0U3lzdGVtLm1qcz9iMGQ0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLXBhcnRpY2xlLXdheXBvaW50Ly4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvaW5pdC5tanM/NjVmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZGF0YS91cGRhdGVRdWFkQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZVNwcml0ZSB9IGZyb20gJy4uLy4uL3Nwcml0ZS9CYXRjaGFibGVTcHJpdGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1VGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBuZXdLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0ZXh0LnJlc29sdXRpb24gPz8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5nZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgdGV4dC50ZXh0LFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICB0ZXh0Ll9zdHlsZVxuICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gaXMgb25seSBiZWluZyB1c2VkIGJ5IHRoaXMgdGV4dDpcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5nZXRSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpID09PSAxICYmIHdpZHRoID09PSBncHVUZXh0LnRleHR1cmUuX3NvdXJjZS53aWR0aCAmJiBoZWlnaHQgPT09IGdwdVRleHQudGV4dHVyZS5fc291cmNlLmhlaWdodFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZSh0ZXh0LCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAodGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUodGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KHRleHQpO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGlmICh0ZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KHRleHQpO1xuICAgIH1cbiAgICBiYXRjaGFibGVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUodGV4dCkge1xuICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZCh0ZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZCh0ZXh0VWlkKSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dwdVRleHRbdGV4dFVpZF07XG4gICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgQmlnUG9vbC5yZXR1cm4oZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGUpO1xuICAgIHRoaXMuX2dwdVRleHRbdGV4dFVpZF0gPSBudWxsO1xuICB9XG4gIF91cGRhdGVUZXh0KHRleHQpIHtcbiAgICBjb25zdCBuZXdLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUdwdVRleHQodGV4dCk7XG4gICAgfVxuICAgIHRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGV4dC5fc3R5bGUucGFkZGluZztcbiAgICB1cGRhdGVRdWFkQm91bmRzKGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMsIHRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIF91cGRhdGVHcHVUZXh0KHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC50ZXh0dXJlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5jYW52YXNUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRleHQucmVzb2x1dGlvbiA/PyB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGdwdVRleHQudGV4dHVyZSA9IGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5nZXRUZXh0dXJlKFxuICAgICAgdGV4dC50ZXh0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHRleHQuX3N0eWxlLFxuICAgICAgdGV4dC5fZ2V0S2V5KClcbiAgICApO1xuICAgIGdwdVRleHQuY3VycmVudEtleSA9IHRleHQuX2dldEtleSgpO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gZ3B1VGV4dC50ZXh0dXJlO1xuICB9XG4gIF9nZXRHcHVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1VGV4dFt0ZXh0LnVpZF0gfHwgdGhpcy5pbml0R3B1VGV4dCh0ZXh0KTtcbiAgfVxuICBpbml0R3B1VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dERhdGEgPSB7XG4gICAgICB0ZXh0dXJlOiBudWxsLFxuICAgICAgY3VycmVudEtleTogXCItLVwiLFxuICAgICAgYmF0Y2hhYmxlU3ByaXRlOiBCaWdQb29sLmdldChCYXRjaGFibGVTcHJpdGUpXG4gICAgfTtcbiAgICBncHVUZXh0RGF0YS5iYXRjaGFibGVTcHJpdGUucmVuZGVyYWJsZSA9IHRleHQ7XG4gICAgZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcyA9IHsgbWluWDogMCwgbWF4WDogMSwgbWluWTogMCwgbWF4WTogMCB9O1xuICAgIGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZS5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHRleHQuX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdVRleHRbdGV4dC51aWRdID0gZ3B1VGV4dERhdGE7XG4gICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB0ZXh0Lm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUodGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdwdVRleHREYXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdVRleHQpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuQ2FudmFzVGV4dFBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcInRleHRcIlxufTtcblxuZXhwb3J0IHsgQ2FudmFzVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjaGVja1JvdyhkYXRhLCB3aWR0aCwgeSkge1xuICBmb3IgKGxldCB4ID0gMCwgaW5kZXggPSA0ICogeSAqIHdpZHRoOyB4IDwgd2lkdGg7ICsreCwgaW5kZXggKz0gNCkge1xuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgeCwgdG9wLCBib3R0b20pIHtcbiAgY29uc3Qgc3RyaWRlID0gNCAqIHdpZHRoO1xuICBmb3IgKGxldCB5ID0gdG9wLCBpbmRleCA9IHRvcCAqIHN0cmlkZSArIDQgKiB4OyB5IDw9IGJvdHRvbTsgKyt5LCBpbmRleCArPSBzdHJpZGUpIHtcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzQm91bmRpbmdCb3goY2FudmFzLCByZXNvbHV0aW9uID0gMSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhcztcbiAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICB9KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgfVxuICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCB0b3AgPSAwO1xuICBsZXQgcmlnaHQgPSB3aWR0aCAtIDE7XG4gIGxldCBib3R0b20gPSBoZWlnaHQgLSAxO1xuICB3aGlsZSAodG9wIDwgaGVpZ2h0ICYmIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB0b3ApKVxuICAgICsrdG9wO1xuICBpZiAodG9wID09PSBoZWlnaHQpXG4gICAgcmV0dXJuIFJlY3RhbmdsZS5FTVBUWTtcbiAgd2hpbGUgKGNoZWNrUm93KGRhdGEsIHdpZHRoLCBib3R0b20pKVxuICAgIC0tYm90dG9tO1xuICB3aGlsZSAoY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIGxlZnQsIHRvcCwgYm90dG9tKSlcbiAgICArK2xlZnQ7XG4gIHdoaWxlIChjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgcmlnaHQsIHRvcCwgYm90dG9tKSlcbiAgICAtLXJpZ2h0O1xuICArK3JpZ2h0O1xuICArK2JvdHRvbTtcbiAgcmV0dXJuIG5ldyBSZWN0YW5nbGUobGVmdCAvIHJlc29sdXRpb24sIHRvcCAvIHJlc29sdXRpb24sIChyaWdodCAtIGxlZnQpIC8gcmVzb2x1dGlvbiwgKGJvdHRvbSAtIHRvcCkgLyByZXNvbHV0aW9uKTtcbn1cblxuZXhwb3J0IHsgZ2V0Q2FudmFzQm91bmRpbmdCb3ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENhbnZhc0JvdW5kaW5nQm94Lm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IG5leHRQb3cyIH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNQb29sIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcyc7XG5pbXBvcnQgeyBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL2dldFBvMlRleHR1cmVGcm9tU291cmNlLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0TWV0cmljcyB9IGZyb20gJy4vQ2FudmFzVGV4dE1ldHJpY3MubWpzJztcbmltcG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNUZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXMgPSB7fTtcbiAgfVxuICBnZXRUZXh0dXJlU2l6ZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICAgIGNvbnN0IG1lYXN1cmVkID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGV4dCB8fCBcIiBcIiwgc3R5bGUpO1xuICAgIGxldCB3aWR0aCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQud2lkdGgpICsgc3R5bGUucGFkZGluZyAqIDIpICogcmVzb2x1dGlvbik7XG4gICAgbGV0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC0gMWUtNik7XG4gICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAtIDFlLTYpO1xuICAgIHdpZHRoID0gbmV4dFBvdzIod2lkdGgpO1xuICAgIGhlaWdodCA9IG5leHRQb3cyKGhlaWdodCk7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICB9XG4gIGdldFRleHR1cmUodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUsIHRleHRLZXkpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0pIHtcbiAgICAgIHRoaXMuX2luY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udGV4dHVyZTtcbiAgICB9XG4gICAgY29uc3QgbWVhc3VyZWQgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlVGV4dCh0ZXh0IHx8IFwiIFwiLCBzdHlsZSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGNhbnZhc0FuZENvbnRleHQgPSBDYW52YXNQb29sLmdldE9wdGltYWxDYW52YXNBbmRDb250ZXh0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSBjYW52YXNBbmRDb250ZXh0O1xuICAgIHRoaXMucmVuZGVyVGV4dFRvQ2FudmFzKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBjYW52YXNBbmRDb250ZXh0KTtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICBpZiAoc3R5bGUudHJpbSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IGdldENhbnZhc0JvdW5kaW5nQm94KGNhbnZhcywgcmVzb2x1dGlvbik7XG4gICAgICB0ZXh0dXJlLmZyYW1lLmNvcHlGcm9tKHRyaW1tZWQpO1xuICAgICAgdGV4dHVyZS51cGRhdGVVdnMoKTtcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0gPSB7XG4gICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgdGV4dHVyZSxcbiAgICAgIHVzYWdlQ291bnQ6IDFcbiAgICB9O1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIF9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50Kys7XG4gIH1cbiAgZGVjcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgY29uc3QgYWN0aXZlVGV4dHVyZSA9IHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldO1xuICAgIGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudC0tO1xuICAgIGlmIChhY3RpdmVUZXh0dXJlLnVzYWdlQ291bnQgPT09IDApIHtcbiAgICAgIENhbnZhc1Bvb2wucmV0dXJuQ2FudmFzQW5kQ29udGV4dChhY3RpdmVUZXh0dXJlLmNhbnZhc0FuZENvbnRleHQpO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShhY3RpdmVUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgY29uc3Qgc291cmNlID0gYWN0aXZlVGV4dHVyZS50ZXh0dXJlLnNvdXJjZTtcbiAgICAgIHNvdXJjZS5yZXNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2UudXBsb2FkTWV0aG9kSWQgPSBcInVua25vd25cIjtcbiAgICAgIHNvdXJjZS5hbHBoYU1vZGUgPSBcIm5vLXByZW11bHRpcGx5LWFscGhhXCI7XG4gICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldFJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0ZXh0IHRvIGl0cyBjYW52YXMsIGFuZCB1cGRhdGVzIGl0cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGVuc3VyZSB0aGUgdGV4dHVyZSBpcyBjb3JyZWN0IGJlZm9yZSByZW5kZXJpbmcsXG4gICAqIGJ1dCBpdCBjYW4gYmUgdXNlZCBjYWxsZWQgZXh0ZXJuYWxseSwgZm9yIGV4YW1wbGUgZnJvbSB0aGlzIGNsYXNzIHRvICdwcmUtZ2VuZXJhdGUnIHRoZSB0ZXh0dXJlIGZyb20gYSBwaWVjZSBvZiB0ZXh0LFxuICAgKiBhbmQgdGhlbiBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFNwcml0ZXMuXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSBzdHlsZVxuICAgKiBAcGFyYW0gcmVzb2x1dGlvblxuICAgKiBAcGFyYW0gY2FudmFzQW5kQ29udGV4dFxuICAgKi9cbiAgcmVuZGVyVGV4dFRvQ2FudmFzKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgY29uc3QgeyBjYW52YXMsIGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gICAgY29uc3QgZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBtZWFzdXJlZCA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRleHQgfHwgXCIgXCIsIHN0eWxlKTtcbiAgICBjb25zdCBsaW5lcyA9IG1lYXN1cmVkLmxpbmVzO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZWFzdXJlZC5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSBtZWFzdXJlZC5saW5lV2lkdGhzO1xuICAgIGNvbnN0IG1heExpbmVXaWR0aCA9IG1lYXN1cmVkLm1heExpbmVXaWR0aDtcbiAgICBjb25zdCBmb250UHJvcGVydGllcyA9IG1lYXN1cmVkLmZvbnRQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgY29udGV4dC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIGNvbnRleHQuc2NhbGUocmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgbWVhc3VyZWQud2lkdGggKyA0LCBtZWFzdXJlZC5oZWlnaHQgKyA0KTtcbiAgICBpZiAoc3R5bGUuX3N0cm9rZT8ud2lkdGgpIHtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuX3N0cm9rZTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlU3R5bGUud2lkdGg7XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZVN0eWxlLmpvaW47XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBzdHJva2VTdHlsZS5jYXA7XG4gICAgfVxuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgbGV0IGxpbmVQb3NpdGlvblg7XG4gICAgbGV0IGxpbmVQb3NpdGlvblk7XG4gICAgY29uc3QgcGFzc2VzQ291bnQgPSBzdHlsZS5kcm9wU2hhZG93ID8gMiA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXNzZXNDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBpc1NoYWRvd1Bhc3MgPSBzdHlsZS5kcm9wU2hhZG93ICYmIGkgPT09IDA7XG4gICAgICBjb25zdCBkc09mZnNldFRleHQgPSBpc1NoYWRvd1Bhc3MgPyBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSA6IDA7XG4gICAgICBjb25zdCBkc09mZnNldFNoYWRvdyA9IGRzT2Zmc2V0VGV4dCAqIHJlc29sdXRpb247XG4gICAgICBpZiAoaXNTaGFkb3dQYXNzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjb25zdCBzaGFkb3dPcHRpb25zID0gc3R5bGUuZHJvcFNoYWRvdztcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0NvbG9yID0gc2hhZG93T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0FscGhhID0gc2hhZG93T3B0aW9ucy5hbHBoYTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShkcm9wU2hhZG93Q29sb3IpLnNldEFscGhhKGRyb3BTaGFkb3dBbHBoYSkudG9SZ2JhU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dCbHVyID0gc2hhZG93T3B0aW9ucy5ibHVyICogcmVzb2x1dGlvbjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0Rpc3RhbmNlID0gc2hhZG93T3B0aW9ucy5kaXN0YW5jZSAqIHJlc29sdXRpb247XG4gICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBNYXRoLmNvcyhzaGFkb3dPcHRpb25zLmFuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2UgKyBkc09mZnNldFNoYWRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzdHlsZS5fZmlsbD8uYWxwaGEgPz8gMTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5fZmlsbCA/IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fZmlsbCwgY29udGV4dCkgOiBudWxsO1xuICAgICAgICBpZiAoc3R5bGUuX3N0cm9rZT8ud2lkdGgpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzRmlsbFN0eWxlKHN0eWxlLl9zdHJva2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICB9XG4gICAgICBsZXQgbGluZVBvc2l0aW9uWVNoaWZ0ID0gKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSkgLyAyO1xuICAgICAgaWYgKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSA8IDApIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWVNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc3R5bGUuX3N0cm9rZT8ud2lkdGggPz8gMDtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsaW5lcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IHN0cm9rZVdpZHRoIC8gMiArIGkyICogbGluZUhlaWdodCArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudCArIGxpbmVQb3NpdGlvbllTaGlmdDtcbiAgICAgICAgaWYgKHN0eWxlLmFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpMl0pIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuX3N0cm9rZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdMZXR0ZXJTcGFjaW5nKFxuICAgICAgICAgICAgbGluZXNbaTJdLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dCxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5fZmlsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5fZHJhd0xldHRlclNwYWNpbmcoXG4gICAgICAgICAgICBsaW5lc1tpMl0sXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YICsgc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nIC0gZHNPZmZzZXRUZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZHJhd1xuICAgKiBAcGFyYW0gc3R5bGVcbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICogQHBhcmFtIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICogQHBhcmFtIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBpc1N0cm9rZSAtIElzIHRoaXMgZHJhd2luZyBmb3IgdGhlIG91dHNpZGUgc3Ryb2tlIG9mIHRoZVxuICAgKiAgdGV4dD8gSWYgbm90LCBpdCdzIGZvciB0aGUgaW5zaWRlIGZpbGxcbiAgICovXG4gIF9kcmF3TGV0dGVyU3BhY2luZyh0ZXh0LCBzdHlsZSwgY2FudmFzQW5kQ29udGV4dCwgeCwgeSwgaXNTdHJva2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgY29udGV4dCB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICBsZXQgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuICAgIGlmIChDYW52YXNUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGV0dGVyU3BhY2luZyA9PT0gMCB8fCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHg7XG4gICAgY29uc3Qgc3RyaW5nQXJyYXkgPSBDYW52YXNUZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0ZXh0KTtcbiAgICBsZXQgcHJldmlvdXNXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgbGV0IGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY3VycmVudENoYXIgPSBzdHJpbmdBcnJheVtpXTtcbiAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfVxuICAgICAgbGV0IHRleHRTdHIgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdGV4dFN0ciArPSBzdHJpbmdBcnJheVtqXTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dFN0cikud2lkdGg7XG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gcHJldmlvdXNXaWR0aCAtIGN1cnJlbnRXaWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgICBwcmV2aW91c1dpZHRoID0gY3VycmVudFdpZHRoO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkNhbnZhc1RleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcImNhbnZhc1RleHRcIlxufTtcblxuZXhwb3J0IHsgQ2FudmFzVGV4dFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzVGV4dFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0UGlwZSB9IGZyb20gJy4vY2FudmFzL0NhbnZhc1RleHRQaXBlLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0U3lzdGVtIH0gZnJvbSAnLi9jYW52YXMvQ2FudmFzVGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKENhbnZhc1RleHRTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5hZGQoQ2FudmFzVGV4dFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},740:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ generateTextStyleKey)\n/* harmony export */ });\n\nconst valuesToIterateForKeys = [\n  "_fontFamily",\n  "_fontStyle",\n  "_fontSize",\n  "_fontVariant",\n  "_fontWeight",\n  "_breakWords",\n  "_align",\n  "_leading",\n  "_letterSpacing",\n  "_lineHeight",\n  "_textBaseline",\n  "_whiteSpace",\n  "_wordWrap",\n  "_wordWrapWidth",\n  "_padding",\n  "_cssOverrides",\n  "_trim"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = valuesToIterateForKeys[i];\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  return key.join("-");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.uid;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\n\n\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanM/MTkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHZhbHVlc1RvSXRlcmF0ZUZvcktleXMgPSBbXG4gIFwiX2ZvbnRGYW1pbHlcIixcbiAgXCJfZm9udFN0eWxlXCIsXG4gIFwiX2ZvbnRTaXplXCIsXG4gIFwiX2ZvbnRWYXJpYW50XCIsXG4gIFwiX2ZvbnRXZWlnaHRcIixcbiAgXCJfYnJlYWtXb3Jkc1wiLFxuICBcIl9hbGlnblwiLFxuICBcIl9sZWFkaW5nXCIsXG4gIFwiX2xldHRlclNwYWNpbmdcIixcbiAgXCJfbGluZUhlaWdodFwiLFxuICBcIl90ZXh0QmFzZWxpbmVcIixcbiAgXCJfd2hpdGVTcGFjZVwiLFxuICBcIl93b3JkV3JhcFwiLFxuICBcIl93b3JkV3JhcFdpZHRoXCIsXG4gIFwiX3BhZGRpbmdcIixcbiAgXCJfY3NzT3ZlcnJpZGVzXCIsXG4gIFwiX3RyaW1cIlxuXTtcbmZ1bmN0aW9uIGdlbmVyYXRlVGV4dFN0eWxlS2V5KHN0eWxlKSB7XG4gIGNvbnN0IGtleSA9IFtdO1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlc1RvSXRlcmF0ZUZvcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wID0gdmFsdWVzVG9JdGVyYXRlRm9yS2V5c1tpXTtcbiAgICBrZXlbaW5kZXgrK10gPSBzdHlsZVtwcm9wXTtcbiAgfVxuICBpbmRleCA9IGFkZEZpbGxTdHlsZUtleShzdHlsZS5fZmlsbCwga2V5LCBpbmRleCk7XG4gIGluZGV4ID0gYWRkU3Rva2VTdHlsZUtleShzdHlsZS5fc3Ryb2tlLCBrZXksIGluZGV4KTtcbiAgcmV0dXJuIGtleS5qb2luKFwiLVwiKTtcbn1cbmZ1bmN0aW9uIGFkZEZpbGxTdHlsZUtleShmaWxsU3R5bGUsIGtleSwgaW5kZXgpIHtcbiAgaWYgKCFmaWxsU3R5bGUpXG4gICAgcmV0dXJuIGluZGV4O1xuICBrZXlbaW5kZXgrK10gPSBmaWxsU3R5bGUuY29sb3I7XG4gIGtleVtpbmRleCsrXSA9IGZpbGxTdHlsZS5hbHBoYTtcbiAga2V5W2luZGV4KytdID0gZmlsbFN0eWxlLmZpbGw/LnVpZDtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gYWRkU3Rva2VTdHlsZUtleShzdHJva2VTdHlsZSwga2V5LCBpbmRleCkge1xuICBpZiAoIXN0cm9rZVN0eWxlKVxuICAgIHJldHVybiBpbmRleDtcbiAgaW5kZXggPSBhZGRGaWxsU3R5bGVLZXkoc3Ryb2tlU3R5bGUsIGtleSwgaW5kZXgpO1xuICBrZXlbaW5kZXgrK10gPSBzdHJva2VTdHlsZS53aWR0aDtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUuYWxpZ25tZW50O1xuICBrZXlbaW5kZXgrK10gPSBzdHJva2VTdHlsZS5jYXA7XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLmpvaW47XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLm1pdGVyTGltaXQ7XG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVUZXh0U3R5bGVLZXkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVGV4dFN0eWxlS2V5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///740\n')},1647:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ getPo2TextureFromSource)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6669);\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(535);\n\n\n\n"use strict";\nconst tempBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Bounds */ .Y();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TexturePool */ .z.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = "image";\n  texture.source.resource = image;\n  texture.source.alphaMode = "premultiply-alpha-on-upload";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit("update", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\n\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRjtBQUMvQjs7QUFFM0Q7QUFDQSx1QkFBdUIseUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFHQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtcGFydGljbGUtd2F5cG9pbnQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC91dGlscy9nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanM/YTUyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbmZ1bmN0aW9uIGdldFBvMlRleHR1cmVGcm9tU291cmNlKGltYWdlLCB3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gIGNvbnN0IGJvdW5kcyA9IHRlbXBCb3VuZHM7XG4gIGJvdW5kcy5taW5YID0gMDtcbiAgYm91bmRzLm1pblkgPSAwO1xuICBib3VuZHMubWF4WCA9IGltYWdlLndpZHRoIC8gcmVzb2x1dGlvbiB8IDA7XG4gIGJvdW5kcy5tYXhZID0gaW1hZ2UuaGVpZ2h0IC8gcmVzb2x1dGlvbiB8IDA7XG4gIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICBib3VuZHMud2lkdGgsXG4gICAgYm91bmRzLmhlaWdodCxcbiAgICByZXNvbHV0aW9uLFxuICAgIGZhbHNlXG4gICk7XG4gIHRleHR1cmUuc291cmNlLnVwbG9hZE1ldGhvZElkID0gXCJpbWFnZVwiO1xuICB0ZXh0dXJlLnNvdXJjZS5yZXNvdXJjZSA9IGltYWdlO1xuICB0ZXh0dXJlLnNvdXJjZS5hbHBoYU1vZGUgPSBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICB0ZXh0dXJlLmZyYW1lLndpZHRoID0gd2lkdGggLyByZXNvbHV0aW9uO1xuICB0ZXh0dXJlLmZyYW1lLmhlaWdodCA9IGhlaWdodCAvIHJlc29sdXRpb247XG4gIHRleHR1cmUuc291cmNlLmVtaXQoXCJ1cGRhdGVcIiwgdGV4dHVyZS5zb3VyY2UpO1xuICB0ZXh0dXJlLnVwZGF0ZVV2cygpO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZXhwb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFBvMlRleHR1cmVGcm9tU291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1647\n')}}]);